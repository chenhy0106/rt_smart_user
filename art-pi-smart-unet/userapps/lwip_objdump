
root/bin/lwIPKit.elf:     file format elf32-littlearm


Disassembly of section .text:

00100000 <_start>:
  100000:	e1a0d003 	mov	sp, r3
  100004:	ebffffff 	bl	100008 <_start_c>

00100008 <_start_c>:
  100008:	e3a0c000 	mov	ip, #0
  10000c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  100010:	e59f3018 	ldr	r3, [pc, #24]	; 100030 <_start_c+0x28>
  100014:	e24dd00c 	sub	sp, sp, #12
  100018:	e5901000 	ldr	r1, [r0]
  10001c:	e2802004 	add	r2, r0, #4
  100020:	e88d1008 	stm	sp, {r3, ip}
  100024:	e59f0008 	ldr	r0, [pc, #8]	; 100034 <_start_c+0x2c>
  100028:	e59f3008 	ldr	r3, [pc, #8]	; 100038 <_start_c+0x30>
  10002c:	eb00e41a 	bl	13909c <__libc_start_main>
  100030:	00145594 	.word	0x00145594
  100034:	00103c5c 	.word	0x00103c5c
  100038:	00145588 	.word	0x00145588

0010003c <deregister_tm_clones>:
  10003c:	e59f0018 	ldr	r0, [pc, #24]	; 10005c <deregister_tm_clones+0x20>
  100040:	e59f3018 	ldr	r3, [pc, #24]	; 100060 <deregister_tm_clones+0x24>
  100044:	e1530000 	cmp	r3, r0
  100048:	012fff1e 	bxeq	lr
  10004c:	e59f3010 	ldr	r3, [pc, #16]	; 100064 <deregister_tm_clones+0x28>
  100050:	e3530000 	cmp	r3, #0
  100054:	012fff1e 	bxeq	lr
  100058:	e12fff13 	bx	r3
  10005c:	0014e3f0 	.word	0x0014e3f0
  100060:	0014e3f0 	.word	0x0014e3f0
  100064:	00000000 	.word	0x00000000

00100068 <register_tm_clones>:
  100068:	e59f0024 	ldr	r0, [pc, #36]	; 100094 <register_tm_clones+0x2c>
  10006c:	e59f1024 	ldr	r1, [pc, #36]	; 100098 <register_tm_clones+0x30>
  100070:	e0411000 	sub	r1, r1, r0
  100074:	e1a01141 	asr	r1, r1, #2
  100078:	e0811fa1 	add	r1, r1, r1, lsr #31
  10007c:	e1b010c1 	asrs	r1, r1, #1
  100080:	012fff1e 	bxeq	lr
  100084:	e59f3010 	ldr	r3, [pc, #16]	; 10009c <register_tm_clones+0x34>
  100088:	e3530000 	cmp	r3, #0
  10008c:	012fff1e 	bxeq	lr
  100090:	e12fff13 	bx	r3
  100094:	0014e3f0 	.word	0x0014e3f0
  100098:	0014e3f0 	.word	0x0014e3f0
  10009c:	00000000 	.word	0x00000000

001000a0 <__do_global_dtors_aux>:
  1000a0:	e92d4010 	push	{r4, lr}
  1000a4:	e59f402c 	ldr	r4, [pc, #44]	; 1000d8 <__do_global_dtors_aux+0x38>
  1000a8:	e5d43000 	ldrb	r3, [r4]
  1000ac:	e3530000 	cmp	r3, #0
  1000b0:	18bd8010 	popne	{r4, pc}
  1000b4:	ebffffe0 	bl	10003c <deregister_tm_clones>
  1000b8:	e59f301c 	ldr	r3, [pc, #28]	; 1000dc <__do_global_dtors_aux+0x3c>
  1000bc:	e3530000 	cmp	r3, #0
  1000c0:	0a000001 	beq	1000cc <__do_global_dtors_aux+0x2c>
  1000c4:	e59f0014 	ldr	r0, [pc, #20]	; 1000e0 <__do_global_dtors_aux+0x40>
  1000c8:	e320f000 	nop	{0}
  1000cc:	e3a03001 	mov	r3, #1
  1000d0:	e5c43000 	strb	r3, [r4]
  1000d4:	e8bd8010 	pop	{r4, pc}
  1000d8:	0014e3f0 	.word	0x0014e3f0
  1000dc:	00000000 	.word	0x00000000
  1000e0:	0014d1d8 	.word	0x0014d1d8

001000e4 <frame_dummy>:
  1000e4:	e59f3020 	ldr	r3, [pc, #32]	; 10010c <frame_dummy+0x28>
  1000e8:	e3530000 	cmp	r3, #0
  1000ec:	0a000005 	beq	100108 <frame_dummy+0x24>
  1000f0:	e92d4010 	push	{r4, lr}
  1000f4:	e59f1014 	ldr	r1, [pc, #20]	; 100110 <frame_dummy+0x2c>
  1000f8:	e59f0014 	ldr	r0, [pc, #20]	; 100114 <frame_dummy+0x30>
  1000fc:	e320f000 	nop	{0}
  100100:	e8bd4010 	pop	{r4, lr}
  100104:	eaffffd7 	b	100068 <register_tm_clones>
  100108:	eaffffd6 	b	100068 <register_tm_clones>
  10010c:	00000000 	.word	0x00000000
  100110:	0014e3f4 	.word	0x0014e3f4
  100114:	0014d1d8 	.word	0x0014d1d8

00100118 <rt_channel_open>:

#include <sys/rtt_syscall.h>
#include <rtthread.h>

int rt_channel_open(const char *name, int flags)
{
  100118:	e92d4800 	push	{fp, lr}
  10011c:	e28db004 	add	fp, sp, #4
  100120:	e24dd008 	sub	sp, sp, #8
  100124:	e50b0008 	str	r0, [fp, #-8]
  100128:	e50b100c 	str	r1, [fp, #-12]
    return syscall(_NRSYS_channel_open, name, flags);
  10012c:	e51b200c 	ldr	r2, [fp, #-12]
  100130:	e51b1008 	ldr	r1, [fp, #-8]
  100134:	e3a0002c 	mov	r0, #44	; 0x2c
  100138:	eb00f147 	bl	13c65c <syscall>
  10013c:	e1a03000 	mov	r3, r0
}
  100140:	e1a00003 	mov	r0, r3
  100144:	e24bd004 	sub	sp, fp, #4
  100148:	e8bd8800 	pop	{fp, pc}

0010014c <rt_channel_close>:

rt_err_t rt_channel_close(int fd)
{
  10014c:	e92d4800 	push	{fp, lr}
  100150:	e28db004 	add	fp, sp, #4
  100154:	e24dd008 	sub	sp, sp, #8
  100158:	e50b0008 	str	r0, [fp, #-8]
    return syscall(_NRSYS_channel_close, fd);
  10015c:	e51b1008 	ldr	r1, [fp, #-8]
  100160:	e3a0002d 	mov	r0, #45	; 0x2d
  100164:	eb00f13c 	bl	13c65c <syscall>
  100168:	e1a03000 	mov	r3, r0
}
  10016c:	e1a00003 	mov	r0, r3
  100170:	e24bd004 	sub	sp, fp, #4
  100174:	e8bd8800 	pop	{fp, pc}

00100178 <rt_channel_send_recv>:

rt_err_t rt_channel_send_recv(int fd, rt_channel_msg_t data, rt_channel_msg_t data_ret)
{
  100178:	e92d4800 	push	{fp, lr}
  10017c:	e28db004 	add	fp, sp, #4
  100180:	e24dd018 	sub	sp, sp, #24
  100184:	e50b0008 	str	r0, [fp, #-8]
  100188:	e50b100c 	str	r1, [fp, #-12]
  10018c:	e50b2010 	str	r2, [fp, #-16]
    return syscall(_NRSYS_channel_send_recv_timeout, fd, data, data_ret, RT_WAITING_FOREVER);
  100190:	e3e03000 	mvn	r3, #0
  100194:	e58d3000 	str	r3, [sp]
  100198:	e51b3010 	ldr	r3, [fp, #-16]
  10019c:	e51b200c 	ldr	r2, [fp, #-12]
  1001a0:	e51b1008 	ldr	r1, [fp, #-8]
  1001a4:	e3a0002f 	mov	r0, #47	; 0x2f
  1001a8:	eb00f12b 	bl	13c65c <syscall>
  1001ac:	e1a03000 	mov	r3, r0
}
  1001b0:	e1a00003 	mov	r0, r3
  1001b4:	e24bd004 	sub	sp, fp, #4
  1001b8:	e8bd8800 	pop	{fp, pc}

001001bc <rt_channel_send_recv_timeout>:

rt_err_t rt_channel_send_recv_timeout(int fd, rt_channel_msg_t data, rt_channel_msg_t data_ret, rt_int32_t time)
{
  1001bc:	e92d4800 	push	{fp, lr}
  1001c0:	e28db004 	add	fp, sp, #4
  1001c4:	e24dd018 	sub	sp, sp, #24
  1001c8:	e50b0008 	str	r0, [fp, #-8]
  1001cc:	e50b100c 	str	r1, [fp, #-12]
  1001d0:	e50b2010 	str	r2, [fp, #-16]
  1001d4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return syscall(_NRSYS_channel_send_recv_timeout, fd, data, data_ret, time);
  1001d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1001dc:	e58d3000 	str	r3, [sp]
  1001e0:	e51b3010 	ldr	r3, [fp, #-16]
  1001e4:	e51b200c 	ldr	r2, [fp, #-12]
  1001e8:	e51b1008 	ldr	r1, [fp, #-8]
  1001ec:	e3a0002f 	mov	r0, #47	; 0x2f
  1001f0:	eb00f119 	bl	13c65c <syscall>
  1001f4:	e1a03000 	mov	r3, r0
}
  1001f8:	e1a00003 	mov	r0, r3
  1001fc:	e24bd004 	sub	sp, fp, #4
  100200:	e8bd8800 	pop	{fp, pc}

00100204 <rt_channel_send>:

rt_err_t rt_channel_send(int fd, rt_channel_msg_t data)
{
  100204:	e92d4800 	push	{fp, lr}
  100208:	e28db004 	add	fp, sp, #4
  10020c:	e24dd008 	sub	sp, sp, #8
  100210:	e50b0008 	str	r0, [fp, #-8]
  100214:	e50b100c 	str	r1, [fp, #-12]
    return syscall(_NRSYS_channel_send, fd, data);
  100218:	e51b200c 	ldr	r2, [fp, #-12]
  10021c:	e51b1008 	ldr	r1, [fp, #-8]
  100220:	e3a0002e 	mov	r0, #46	; 0x2e
  100224:	eb00f10c 	bl	13c65c <syscall>
  100228:	e1a03000 	mov	r3, r0
}
  10022c:	e1a00003 	mov	r0, r3
  100230:	e24bd004 	sub	sp, fp, #4
  100234:	e8bd8800 	pop	{fp, pc}

00100238 <rt_channel_reply>:

rt_err_t rt_channel_reply(int fd, rt_channel_msg_t data)
{
  100238:	e92d4800 	push	{fp, lr}
  10023c:	e28db004 	add	fp, sp, #4
  100240:	e24dd008 	sub	sp, sp, #8
  100244:	e50b0008 	str	r0, [fp, #-8]
  100248:	e50b100c 	str	r1, [fp, #-12]
    return syscall(_NRSYS_channel_reply, fd, data);
  10024c:	e51b200c 	ldr	r2, [fp, #-12]
  100250:	e51b1008 	ldr	r1, [fp, #-8]
  100254:	e3a00030 	mov	r0, #48	; 0x30
  100258:	eb00f0ff 	bl	13c65c <syscall>
  10025c:	e1a03000 	mov	r3, r0
}
  100260:	e1a00003 	mov	r0, r3
  100264:	e24bd004 	sub	sp, fp, #4
  100268:	e8bd8800 	pop	{fp, pc}

0010026c <rt_channel_recv>:

rt_err_t rt_channel_recv(int fd, rt_channel_msg_t data)
{
  10026c:	e92d4800 	push	{fp, lr}
  100270:	e28db004 	add	fp, sp, #4
  100274:	e24dd008 	sub	sp, sp, #8
  100278:	e50b0008 	str	r0, [fp, #-8]
  10027c:	e50b100c 	str	r1, [fp, #-12]
    return syscall(_NRSYS_channel_recv_timeout, fd, data, RT_WAITING_FOREVER);
  100280:	e3e03000 	mvn	r3, #0
  100284:	e51b200c 	ldr	r2, [fp, #-12]
  100288:	e51b1008 	ldr	r1, [fp, #-8]
  10028c:	e3a00031 	mov	r0, #49	; 0x31
  100290:	eb00f0f1 	bl	13c65c <syscall>
  100294:	e1a03000 	mov	r3, r0
}
  100298:	e1a00003 	mov	r0, r3
  10029c:	e24bd004 	sub	sp, fp, #4
  1002a0:	e8bd8800 	pop	{fp, pc}

001002a4 <rt_channel_recv_timeout>:

rt_err_t rt_channel_recv_timeout(int fd, rt_channel_msg_t data, rt_int32_t time)
{
  1002a4:	e92d4800 	push	{fp, lr}
  1002a8:	e28db004 	add	fp, sp, #4
  1002ac:	e24dd010 	sub	sp, sp, #16
  1002b0:	e50b0008 	str	r0, [fp, #-8]
  1002b4:	e50b100c 	str	r1, [fp, #-12]
  1002b8:	e50b2010 	str	r2, [fp, #-16]
    return syscall(_NRSYS_channel_recv_timeout, fd, data, time);
  1002bc:	e51b3010 	ldr	r3, [fp, #-16]
  1002c0:	e51b200c 	ldr	r2, [fp, #-12]
  1002c4:	e51b1008 	ldr	r1, [fp, #-8]
  1002c8:	e3a00031 	mov	r0, #49	; 0x31
  1002cc:	eb00f0e2 	bl	13c65c <syscall>
  1002d0:	e1a03000 	mov	r3, r0
}
  1002d4:	e1a00003 	mov	r0, r3
  1002d8:	e24bd004 	sub	sp, fp, #4
  1002dc:	e8bd8800 	pop	{fp, pc}

001002e0 <rt_channel_peek>:

rt_err_t rt_channel_peek(int fd, rt_channel_msg_t data)
{
  1002e0:	e92d4800 	push	{fp, lr}
  1002e4:	e28db004 	add	fp, sp, #4
  1002e8:	e24dd008 	sub	sp, sp, #8
  1002ec:	e50b0008 	str	r0, [fp, #-8]
  1002f0:	e50b100c 	str	r1, [fp, #-12]
    return syscall(_NRSYS_channel_recv_timeout, fd, data, 0);
  1002f4:	e3a03000 	mov	r3, #0
  1002f8:	e51b200c 	ldr	r2, [fp, #-12]
  1002fc:	e51b1008 	ldr	r1, [fp, #-8]
  100300:	e3a00031 	mov	r0, #49	; 0x31
  100304:	eb00f0d4 	bl	13c65c <syscall>
  100308:	e1a03000 	mov	r3, r0
}
  10030c:	e1a00003 	mov	r0, r3
  100310:	e24bd004 	sub	sp, fp, #4
  100314:	e8bd8800 	pop	{fp, pc}

00100318 <rt_completion_init>:
 * 2019-10-01     Bernard      code cleanup
 */
#include <rtdevice.h>

void rt_completion_init(struct rt_completion *completion)
{
  100318:	e92d4800 	push	{fp, lr}
  10031c:	e28db004 	add	fp, sp, #4
  100320:	e24dd008 	sub	sp, sp, #8
  100324:	e50b0008 	str	r0, [fp, #-8]
    if (completion && completion->flag == 0)
  100328:	e51b3008 	ldr	r3, [fp, #-8]
  10032c:	e3530000 	cmp	r3, #0
  100330:	0a00000d 	beq	10036c <rt_completion_init+0x54>
  100334:	e51b3008 	ldr	r3, [fp, #-8]
  100338:	e5933000 	ldr	r3, [r3]
  10033c:	e3530000 	cmp	r3, #0
  100340:	1a000009 	bne	10036c <rt_completion_init+0x54>
    {
        completion->flag = 0x5A5A;
  100344:	e51b3008 	ldr	r3, [fp, #-8]
  100348:	e3052a5a 	movw	r2, #23130	; 0x5a5a
  10034c:	e5832000 	str	r2, [r3]
        completion->wait_event = rt_event_create("completion", RT_IPC_FLAG_FIFO);
  100350:	e3a01000 	mov	r1, #0
  100354:	e30505a0 	movw	r0, #21920	; 0x55a0
  100358:	e3400014 	movt	r0, #20
  10035c:	eb0005e5 	bl	101af8 <rt_event_create>
  100360:	e1a02000 	mov	r2, r0
  100364:	e51b3008 	ldr	r3, [fp, #-8]
  100368:	e5832004 	str	r2, [r3, #4]
    }
}
  10036c:	e320f000 	nop	{0}
  100370:	e24bd004 	sub	sp, fp, #4
  100374:	e8bd8800 	pop	{fp, pc}

00100378 <rt_completion_wait>:

rt_err_t rt_completion_wait(struct rt_completion *completion,
    rt_int32_t timeout)
{
  100378:	e92d4800 	push	{fp, lr}
  10037c:	e28db004 	add	fp, sp, #4
  100380:	e24dd018 	sub	sp, sp, #24
  100384:	e50b0010 	str	r0, [fp, #-16]
  100388:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    rt_err_t ret;
    rt_uint32_t recv = 0;
  10038c:	e3a03000 	mov	r3, #0
  100390:	e50b300c 	str	r3, [fp, #-12]

    ret = rt_event_recv(completion->wait_event, 0x01, RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, timeout, &recv);
  100394:	e51b3010 	ldr	r3, [fp, #-16]
  100398:	e5930004 	ldr	r0, [r3, #4]
  10039c:	e24b300c 	sub	r3, fp, #12
  1003a0:	e58d3000 	str	r3, [sp]
  1003a4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1003a8:	e3a02006 	mov	r2, #6
  1003ac:	e3a01001 	mov	r1, #1
  1003b0:	eb000684 	bl	101dc8 <rt_event_recv>
  1003b4:	e50b0008 	str	r0, [fp, #-8]

    return ret;
  1003b8:	e51b3008 	ldr	r3, [fp, #-8]
}
  1003bc:	e1a00003 	mov	r0, r3
  1003c0:	e24bd004 	sub	sp, fp, #4
  1003c4:	e8bd8800 	pop	{fp, pc}

001003c8 <rt_completion_done>:

void rt_completion_done(struct rt_completion *completion)
{
  1003c8:	e92d4800 	push	{fp, lr}
  1003cc:	e28db004 	add	fp, sp, #4
  1003d0:	e24dd008 	sub	sp, sp, #8
  1003d4:	e50b0008 	str	r0, [fp, #-8]
    rt_event_send(completion->wait_event, 0x01);
  1003d8:	e51b3008 	ldr	r3, [fp, #-8]
  1003dc:	e5933004 	ldr	r3, [r3, #4]
  1003e0:	e3a01001 	mov	r1, #1
  1003e4:	e1a00003 	mov	r0, r3
  1003e8:	eb000658 	bl	101d50 <rt_event_send>
}
  1003ec:	e320f000 	nop	{0}
  1003f0:	e24bd004 	sub	sp, fp, #4
  1003f4:	e8bd8800 	pop	{fp, pc}

001003f8 <rt_device_init>:

#include <sys/rtt_syscall.h>
#include <rtthread.h>

rt_err_t rt_device_init(rt_device_t dev)
{
  1003f8:	e92d4800 	push	{fp, lr}
  1003fc:	e28db004 	add	fp, sp, #4
  100400:	e24dd008 	sub	sp, sp, #8
  100404:	e50b0008 	str	r0, [fp, #-8]
    return syscall(_NRSYS_rt_device_init, dev);
  100408:	e51b1008 	ldr	r1, [fp, #-8]
  10040c:	e3a0003b 	mov	r0, #59	; 0x3b
  100410:	eb00f091 	bl	13c65c <syscall>
  100414:	e1a03000 	mov	r3, r0
}
  100418:	e1a00003 	mov	r0, r3
  10041c:	e24bd004 	sub	sp, fp, #4
  100420:	e8bd8800 	pop	{fp, pc}

00100424 <rt_device_register>:

rt_err_t rt_device_register(rt_device_t dev,
        const char *name,
        rt_uint16_t flags)
{
  100424:	e92d4800 	push	{fp, lr}
  100428:	e28db004 	add	fp, sp, #4
  10042c:	e24dd010 	sub	sp, sp, #16
  100430:	e50b0008 	str	r0, [fp, #-8]
  100434:	e50b100c 	str	r1, [fp, #-12]
  100438:	e1a03002 	mov	r3, r2
  10043c:	e14b30be 	strh	r3, [fp, #-14]
    return syscall(_NRSYS_rt_device_register, dev, name, flags);
  100440:	e15b30be 	ldrh	r3, [fp, #-14]
  100444:	e51b200c 	ldr	r2, [fp, #-12]
  100448:	e51b1008 	ldr	r1, [fp, #-8]
  10044c:	e3a0003c 	mov	r0, #60	; 0x3c
  100450:	eb00f081 	bl	13c65c <syscall>
  100454:	e1a03000 	mov	r3, r0
}
  100458:	e1a00003 	mov	r0, r3
  10045c:	e24bd004 	sub	sp, fp, #4
  100460:	e8bd8800 	pop	{fp, pc}

00100464 <rt_device_control>:

rt_err_t rt_device_control(rt_device_t dev, int cmd, void *arg)
{
  100464:	e92d4800 	push	{fp, lr}
  100468:	e28db004 	add	fp, sp, #4
  10046c:	e24dd010 	sub	sp, sp, #16
  100470:	e50b0008 	str	r0, [fp, #-8]
  100474:	e50b100c 	str	r1, [fp, #-12]
  100478:	e50b2010 	str	r2, [fp, #-16]
    return syscall(_NRSYS_rt_device_control, dev, cmd, arg);
  10047c:	e51b3010 	ldr	r3, [fp, #-16]
  100480:	e51b200c 	ldr	r2, [fp, #-12]
  100484:	e51b1008 	ldr	r1, [fp, #-8]
  100488:	e3a0003d 	mov	r0, #61	; 0x3d
  10048c:	eb00f072 	bl	13c65c <syscall>
  100490:	e1a03000 	mov	r3, r0
}
  100494:	e1a00003 	mov	r0, r3
  100498:	e24bd004 	sub	sp, fp, #4
  10049c:	e8bd8800 	pop	{fp, pc}

001004a0 <rt_device_find>:

rt_device_t rt_device_find(const char *name)
{
  1004a0:	e92d4800 	push	{fp, lr}
  1004a4:	e28db004 	add	fp, sp, #4
  1004a8:	e24dd008 	sub	sp, sp, #8
  1004ac:	e50b0008 	str	r0, [fp, #-8]
    return (rt_device_t)syscall(_NRSYS_rt_device_find, name);
  1004b0:	e51b1008 	ldr	r1, [fp, #-8]
  1004b4:	e3a0003e 	mov	r0, #62	; 0x3e
  1004b8:	eb00f067 	bl	13c65c <syscall>
  1004bc:	e1a03000 	mov	r3, r0
}
  1004c0:	e1a00003 	mov	r0, r3
  1004c4:	e24bd004 	sub	sp, fp, #4
  1004c8:	e8bd8800 	pop	{fp, pc}

001004cc <rt_device_open>:

rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
{
  1004cc:	e92d4800 	push	{fp, lr}
  1004d0:	e28db004 	add	fp, sp, #4
  1004d4:	e24dd008 	sub	sp, sp, #8
  1004d8:	e50b0008 	str	r0, [fp, #-8]
  1004dc:	e1a03001 	mov	r3, r1
  1004e0:	e14b30ba 	strh	r3, [fp, #-10]
    return syscall(_NRSYS_rt_device_open, dev, oflag);
  1004e4:	e15b30ba 	ldrh	r3, [fp, #-10]
  1004e8:	e1a02003 	mov	r2, r3
  1004ec:	e51b1008 	ldr	r1, [fp, #-8]
  1004f0:	e3a0003f 	mov	r0, #63	; 0x3f
  1004f4:	eb00f058 	bl	13c65c <syscall>
  1004f8:	e1a03000 	mov	r3, r0
}
  1004fc:	e1a00003 	mov	r0, r3
  100500:	e24bd004 	sub	sp, fp, #4
  100504:	e8bd8800 	pop	{fp, pc}

00100508 <rt_device_close>:

rt_err_t rt_device_close(rt_device_t dev)
{
  100508:	e92d4800 	push	{fp, lr}
  10050c:	e28db004 	add	fp, sp, #4
  100510:	e24dd008 	sub	sp, sp, #8
  100514:	e50b0008 	str	r0, [fp, #-8]
    return syscall(_NRSYS_rt_device_close, dev);
  100518:	e51b1008 	ldr	r1, [fp, #-8]
  10051c:	e3a00040 	mov	r0, #64	; 0x40
  100520:	eb00f04d 	bl	13c65c <syscall>
  100524:	e1a03000 	mov	r3, r0
}
  100528:	e1a00003 	mov	r0, r3
  10052c:	e24bd004 	sub	sp, fp, #4
  100530:	e8bd8800 	pop	{fp, pc}

00100534 <rt_device_read>:

rt_size_t rt_device_read(rt_device_t dev,
        rt_off_t    pos,
        void       *buffer,
        rt_size_t   size)
{
  100534:	e92d4800 	push	{fp, lr}
  100538:	e28db004 	add	fp, sp, #4
  10053c:	e24dd018 	sub	sp, sp, #24
  100540:	e50b0008 	str	r0, [fp, #-8]
  100544:	e50b100c 	str	r1, [fp, #-12]
  100548:	e50b2010 	str	r2, [fp, #-16]
  10054c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return syscall(_NRSYS_rt_device_read, dev, pos, buffer, size);
  100550:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  100554:	e58d3000 	str	r3, [sp]
  100558:	e51b3010 	ldr	r3, [fp, #-16]
  10055c:	e51b200c 	ldr	r2, [fp, #-12]
  100560:	e51b1008 	ldr	r1, [fp, #-8]
  100564:	e3a00041 	mov	r0, #65	; 0x41
  100568:	eb00f03b 	bl	13c65c <syscall>
  10056c:	e1a03000 	mov	r3, r0
}
  100570:	e1a00003 	mov	r0, r3
  100574:	e24bd004 	sub	sp, fp, #4
  100578:	e8bd8800 	pop	{fp, pc}

0010057c <rt_device_write>:

rt_size_t rt_device_write(rt_device_t dev,
        rt_off_t    pos,
        const void *buffer,
        rt_size_t   size)
{
  10057c:	e92d4800 	push	{fp, lr}
  100580:	e28db004 	add	fp, sp, #4
  100584:	e24dd018 	sub	sp, sp, #24
  100588:	e50b0008 	str	r0, [fp, #-8]
  10058c:	e50b100c 	str	r1, [fp, #-12]
  100590:	e50b2010 	str	r2, [fp, #-16]
  100594:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return syscall(_NRSYS_rt_device_write, dev, pos, buffer, size);;
  100598:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10059c:	e58d3000 	str	r3, [sp]
  1005a0:	e51b3010 	ldr	r3, [fp, #-16]
  1005a4:	e51b200c 	ldr	r2, [fp, #-12]
  1005a8:	e51b1008 	ldr	r1, [fp, #-8]
  1005ac:	e3a00042 	mov	r0, #66	; 0x42
  1005b0:	eb00f029 	bl	13c65c <syscall>
  1005b4:	e1a03000 	mov	r3, r0
}
  1005b8:	e1a00003 	mov	r0, r3
  1005bc:	e24bd004 	sub	sp, fp, #4
  1005c0:	e8bd8800 	pop	{fp, pc}

001005c4 <closesocket>:
#include <netinet/in.h>
#include <fcntl.h>
#include <time.h>

int closesocket(int s)
{
  1005c4:	e92d4800 	push	{fp, lr}
  1005c8:	e28db004 	add	fp, sp, #4
  1005cc:	e24dd008 	sub	sp, sp, #8
  1005d0:	e50b0008 	str	r0, [fp, #-8]
    return (int)syscall(_NRSYS_closesocket, s);
  1005d4:	e51b1008 	ldr	r1, [fp, #-8]
  1005d8:	e3a00053 	mov	r0, #83	; 0x53
  1005dc:	eb00f01e 	bl	13c65c <syscall>
  1005e0:	e1a03000 	mov	r3, r0
}
  1005e4:	e1a00003 	mov	r0, r3
  1005e8:	e24bd004 	sub	sp, fp, #4
  1005ec:	e8bd8800 	pop	{fp, pc}

001005f0 <getaddrinfo>:

int getaddrinfo(const char *restrict host, const char *restrict serv, const struct addrinfo *restrict hint, struct addrinfo **restrict res)
{
  1005f0:	e92d4800 	push	{fp, lr}
  1005f4:	e28db004 	add	fp, sp, #4
  1005f8:	e24dd020 	sub	sp, sp, #32
  1005fc:	e50b0010 	str	r0, [fp, #-16]
  100600:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  100604:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  100608:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    struct addrinfo *ret = NULL;
  10060c:	e3a03000 	mov	r3, #0
  100610:	e50b3008 	str	r3, [fp, #-8]

    ret = (struct addrinfo *) malloc(sizeof(struct addrinfo) + sizeof(struct sockaddr));
  100614:	e3a00030 	mov	r0, #48	; 0x30
  100618:	eb00f3cc 	bl	13d550 <malloc>
  10061c:	e1a03000 	mov	r3, r0
  100620:	e50b3008 	str	r3, [fp, #-8]
    if (ret)
  100624:	e51b3008 	ldr	r3, [fp, #-8]
  100628:	e3530000 	cmp	r3, #0
  10062c:	0a000011 	beq	100678 <getaddrinfo+0x88>
    {
        ret->ai_addr = (struct sockaddr *)(ret + 1);
  100630:	e51b3008 	ldr	r3, [fp, #-8]
  100634:	e2832020 	add	r2, r3, #32
  100638:	e51b3008 	ldr	r3, [fp, #-8]
  10063c:	e5832014 	str	r2, [r3, #20]

        /* invoke syscall */
        int result = syscall(_NRSYS_getaddrinfo, host, serv, hint, ret);
  100640:	e51b3008 	ldr	r3, [fp, #-8]
  100644:	e58d3000 	str	r3, [sp]
  100648:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10064c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  100650:	e51b1010 	ldr	r1, [fp, #-16]
  100654:	e3a00054 	mov	r0, #84	; 0x54
  100658:	eb00efff 	bl	13c65c <syscall>
  10065c:	e50b000c 	str	r0, [fp, #-12]
        if (result == 0)
  100660:	e51b300c 	ldr	r3, [fp, #-12]
  100664:	e3530000 	cmp	r3, #0
  100668:	1a000002 	bne	100678 <getaddrinfo+0x88>
        {
            *res = ret;
  10066c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  100670:	e51b2008 	ldr	r2, [fp, #-8]
  100674:	e5832000 	str	r2, [r3]
        }
    }

    return 0;
  100678:	e3a03000 	mov	r3, #0
}
  10067c:	e1a00003 	mov	r0, r3
  100680:	e24bd004 	sub	sp, fp, #4
  100684:	e8bd8800 	pop	{fp, pc}

00100688 <freeaddrinfo>:

void freeaddrinfo(struct addrinfo *p)
{
  100688:	e92d4800 	push	{fp, lr}
  10068c:	e28db004 	add	fp, sp, #4
  100690:	e24dd008 	sub	sp, sp, #8
  100694:	e50b0008 	str	r0, [fp, #-8]
    /* p->ai_canonname, p->ai_next should be NULL. */
    free(p);
  100698:	e51b0008 	ldr	r0, [fp, #-8]
  10069c:	eb00f567 	bl	13dc40 <free>
}
  1006a0:	e320f000 	nop	{0}
  1006a4:	e24bd004 	sub	sp, fp, #4
  1006a8:	e8bd8800 	pop	{fp, pc}

001006ac <gethostbyname2_r>:

int gethostbyname2_r(const char *name, int af, struct hostent *ret,
                    char *buf, size_t buflen,
                    struct hostent **result, int *err)
{
  1006ac:	e92d4800 	push	{fp, lr}
  1006b0:	e28db004 	add	fp, sp, #4
  1006b4:	e24dd020 	sub	sp, sp, #32
  1006b8:	e50b0008 	str	r0, [fp, #-8]
  1006bc:	e50b100c 	str	r1, [fp, #-12]
  1006c0:	e50b2010 	str	r2, [fp, #-16]
  1006c4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return syscall(_NRSYS_gethostbyname2_r, name, af, ret, buf, buflen, result, err);
  1006c8:	e59b300c 	ldr	r3, [fp, #12]
  1006cc:	e58d300c 	str	r3, [sp, #12]
  1006d0:	e59b3008 	ldr	r3, [fp, #8]
  1006d4:	e58d3008 	str	r3, [sp, #8]
  1006d8:	e59b3004 	ldr	r3, [fp, #4]
  1006dc:	e58d3004 	str	r3, [sp, #4]
  1006e0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1006e4:	e58d3000 	str	r3, [sp]
  1006e8:	e51b3010 	ldr	r3, [fp, #-16]
  1006ec:	e51b200c 	ldr	r2, [fp, #-12]
  1006f0:	e51b1008 	ldr	r1, [fp, #-8]
  1006f4:	e3a00055 	mov	r0, #85	; 0x55
  1006f8:	eb00efd7 	bl	13c65c <syscall>
  1006fc:	e1a03000 	mov	r3, r0
}
  100700:	e1a00003 	mov	r0, r3
  100704:	e24bd004 	sub	sp, fp, #4
  100708:	e8bd8800 	pop	{fp, pc}

0010070c <setnonblocking>:

/* set non-blocking */
int setnonblocking(int fd)
{
  10070c:	e92d4800 	push	{fp, lr}
  100710:	e28db004 	add	fp, sp, #4
  100714:	e24dd010 	sub	sp, sp, #16
  100718:	e50b0010 	str	r0, [fp, #-16]
    int old_option = fcntl( fd, F_GETFL, 0);
  10071c:	e3a02000 	mov	r2, #0
  100720:	e3a01003 	mov	r1, #3
  100724:	e51b0010 	ldr	r0, [fp, #-16]
  100728:	eb00e2b9 	bl	139214 <fcntl>
  10072c:	e50b0008 	str	r0, [fp, #-8]
    int new_option = old_option | O_NONBLOCK;
  100730:	e51b3008 	ldr	r3, [fp, #-8]
  100734:	e3833b02 	orr	r3, r3, #2048	; 0x800
  100738:	e50b300c 	str	r3, [fp, #-12]
    if (fcntl(fd, F_SETFL, new_option) == -1)
  10073c:	e51b200c 	ldr	r2, [fp, #-12]
  100740:	e3a01004 	mov	r1, #4
  100744:	e51b0010 	ldr	r0, [fp, #-16]
  100748:	eb00e2b1 	bl	139214 <fcntl>
  10074c:	e1a03000 	mov	r3, r0
  100750:	e3730001 	cmn	r3, #1
  100754:	1a000004 	bne	10076c <setnonblocking+0x60>
    {
        printf("Set noblocking error!\n");
  100758:	e30505ac 	movw	r0, #21932	; 0x55ac
  10075c:	e3400014 	movt	r0, #20
  100760:	eb00f822 	bl	13e7f0 <puts>
        return 1;
  100764:	e3a03001 	mov	r3, #1
  100768:	ea000000 	b	100770 <setnonblocking+0x64>
    }
    return old_option;
  10076c:	e51b3008 	ldr	r3, [fp, #-8]
}
  100770:	e1a00003 	mov	r0, r3
  100774:	e24bd004 	sub	sp, fp, #4
  100778:	e8bd8800 	pop	{fp, pc}

0010077c <socketpair>:

int socketpair(int domain, int type, int protocol, int sv[2])
{
  10077c:	e92d4810 	push	{r4, fp, lr}
  100780:	e28db008 	add	fp, sp, #8
  100784:	e24ddf43 	sub	sp, sp, #268	; 0x10c
  100788:	e50b0100 	str	r0, [fp, #-256]	; 0xffffff00
  10078c:	e50b1104 	str	r1, [fp, #-260]	; 0xfffffefc
  100790:	e50b2108 	str	r2, [fp, #-264]	; 0xfffffef8
  100794:	e50b310c 	str	r3, [fp, #-268]	; 0xfffffef4
    int listenfd = -1, acceptfd = -1, clientfd = -1;
  100798:	e3e03000 	mvn	r3, #0
  10079c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  1007a0:	e3e03000 	mvn	r3, #0
  1007a4:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  1007a8:	e3e03000 	mvn	r3, #0
  1007ac:	e50b3010 	str	r3, [fp, #-16]
    /* for server, accept, client */
    struct sockaddr_in saddr, aaddr, caddr;
    socklen_t len = sizeof(struct sockaddr_in);
  1007b0:	e3a03010 	mov	r3, #16
  1007b4:	e50b3064 	str	r3, [fp, #-100]	; 0xffffff9c
    int on = 1;
  1007b8:	e3a03001 	mov	r3, #1
  1007bc:	e50b3068 	str	r3, [fp, #-104]	; 0xffffff98
    int fdopt;
    int rt_port;

    /* for select */
    int maxfdp = 0;
  1007c0:	e3a03000 	mov	r3, #0
  1007c4:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    int rst;
    fd_set rfd;
    struct timeval timeout = {0, 1000};
  1007c8:	e3a02000 	mov	r2, #0
  1007cc:	e3a03000 	mov	r3, #0
  1007d0:	e14b2ffc 	strd	r2, [fp, #-252]	; 0xffffff04
  1007d4:	e3a03ffa 	mov	r3, #1000	; 0x3e8
  1007d8:	e50b30f4 	str	r3, [fp, #-244]	; 0xffffff0c

    /* server socket */
    if ((listenfd = socket(domain, type, protocol)) < 0)
  1007dc:	e51b2108 	ldr	r2, [fp, #-264]	; 0xfffffef8
  1007e0:	e51b1104 	ldr	r1, [fp, #-260]	; 0xfffffefc
  1007e4:	e51b0100 	ldr	r0, [fp, #-256]	; 0xffffff00
  1007e8:	eb00f694 	bl	13e240 <socket>
  1007ec:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
  1007f0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1007f4:	e3530000 	cmp	r3, #0
  1007f8:	aa00000f 	bge	10083c <socketpair+0xc0>
    {
        printf("Create listenfd socket error: %s(errno: %d)\n", strerror(errno), errno);
  1007fc:	eb00e235 	bl	1390d8 <__errno_location>
  100800:	e1a03000 	mov	r3, r0
  100804:	e5933000 	ldr	r3, [r3]
  100808:	e1a00003 	mov	r0, r3
  10080c:	eb00e253 	bl	139160 <strerror>
  100810:	e1a04000 	mov	r4, r0
  100814:	eb00e22f 	bl	1390d8 <__errno_location>
  100818:	e1a03000 	mov	r3, r0
  10081c:	e5933000 	ldr	r3, [r3]
  100820:	e1a02003 	mov	r2, r3
  100824:	e1a01004 	mov	r1, r4
  100828:	e30505c4 	movw	r0, #21956	; 0x55c4
  10082c:	e3400014 	movt	r0, #20
  100830:	eb00f7e0 	bl	13e7b8 <printf>
        return -1;
  100834:	e3e03000 	mvn	r3, #0
  100838:	ea000117 	b	100c9c <socketpair+0x520>
    }
    /* non-blocking */
    setnonblocking(listenfd);
  10083c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  100840:	ebffffb1 	bl	10070c <setnonblocking>

    /* get random port: 5001~65001 */
    srand((unsigned)time(NULL));
  100844:	e3a00000 	mov	r0, #0
  100848:	eb0109be 	bl	142f48 <time>
  10084c:	e1a02000 	mov	r2, r0
  100850:	e1a03001 	mov	r3, r1
  100854:	e1a03002 	mov	r3, r2
  100858:	e1a00003 	mov	r0, r3
  10085c:	eb00f6c4 	bl	13e374 <srand>
    rt_port = rand() % 60000 + 5001;
  100860:	eb00f6c9 	bl	13e38c <rand>
  100864:	e1a02000 	mov	r2, r0
  100868:	e30b3273 	movw	r3, #45683	; 0xb273
  10086c:	e34435e7 	movt	r3, #17895	; 0x45e7
  100870:	e0c10392 	smull	r0, r1, r2, r3
  100874:	e1a01741 	asr	r1, r1, #14
  100878:	e1a03fc2 	asr	r3, r2, #31
  10087c:	e0413003 	sub	r3, r1, r3
  100880:	e30e1a60 	movw	r1, #60000	; 0xea60
  100884:	e0030391 	mul	r3, r1, r3
  100888:	e0423003 	sub	r3, r2, r3
  10088c:	e2833d4e 	add	r3, r3, #4992	; 0x1380
  100890:	e2833009 	add	r3, r3, #9
  100894:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8

    /* bind and listen */
    memset(&saddr, 0, sizeof(saddr));
  100898:	e24b3040 	sub	r3, fp, #64	; 0x40
  10089c:	e3a02010 	mov	r2, #16
  1008a0:	e3a01000 	mov	r1, #0
  1008a4:	e1a00003 	mov	r0, r3
  1008a8:	eb0102f1 	bl	141474 <memset>
    memset(&aaddr, 0, sizeof(aaddr));
  1008ac:	e24b3050 	sub	r3, fp, #80	; 0x50
  1008b0:	e3a02010 	mov	r2, #16
  1008b4:	e3a01000 	mov	r1, #0
  1008b8:	e1a00003 	mov	r0, r3
  1008bc:	eb0102ec 	bl	141474 <memset>
    saddr.sin_family = domain;
  1008c0:	e51b3100 	ldr	r3, [fp, #-256]	; 0xffffff00
  1008c4:	e6ff3073 	uxth	r3, r3
  1008c8:	e14b34b0 	strh	r3, [fp, #-64]	; 0xffffffc0
    saddr.sin_port = htons(rt_port);
  1008cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1008d0:	e6ff3073 	uxth	r3, r3
  1008d4:	e1a00003 	mov	r0, r3
  1008d8:	eb00f626 	bl	13e178 <htons>
  1008dc:	e1a03000 	mov	r3, r0
  1008e0:	e14b33be 	strh	r3, [fp, #-62]	; 0xffffffc2
    saddr.sin_addr.s_addr = htonl(INADDR_ANY);
  1008e4:	e3a00000 	mov	r0, #0
  1008e8:	eb00f61d 	bl	13e164 <htonl>
  1008ec:	e1a03000 	mov	r3, r0
  1008f0:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4

    if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (const char*)&on, sizeof(int)) < 0)
  1008f4:	e24b2068 	sub	r2, fp, #104	; 0x68
  1008f8:	e3a03004 	mov	r3, #4
  1008fc:	e58d3000 	str	r3, [sp]
  100900:	e1a03002 	mov	r3, r2
  100904:	e3a02002 	mov	r2, #2
  100908:	e3a01001 	mov	r1, #1
  10090c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  100910:	eb00f631 	bl	13e1dc <setsockopt>
  100914:	e1a03000 	mov	r3, r0
  100918:	e3530000 	cmp	r3, #0
  10091c:	aa000003 	bge	100930 <socketpair+0x1b4>
    {
        perror("Setsockopt reuseadd failed");
  100920:	e30505f4 	movw	r0, #22004	; 0x55f4
  100924:	e3400014 	movt	r0, #20
  100928:	eb00f759 	bl	13e694 <perror>
        goto __exit;
  10092c:	ea0000cf 	b	100c70 <socketpair+0x4f4>
    }

    if (bind(listenfd, (struct sockaddr*)&saddr, sizeof(saddr)) == -1)
  100930:	e24b3040 	sub	r3, fp, #64	; 0x40
  100934:	e3a02010 	mov	r2, #16
  100938:	e1a01003 	mov	r1, r3
  10093c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  100940:	eb00f5e2 	bl	13e0d0 <bind>
  100944:	e1a03000 	mov	r3, r0
  100948:	e3730001 	cmn	r3, #1
  10094c:	1a00000e 	bne	10098c <socketpair+0x210>
    {
        printf("Bind socket error: %s(errno: %d), fd=%d\n", strerror(errno), errno, listenfd);
  100950:	eb00e1e0 	bl	1390d8 <__errno_location>
  100954:	e1a03000 	mov	r3, r0
  100958:	e5933000 	ldr	r3, [r3]
  10095c:	e1a00003 	mov	r0, r3
  100960:	eb00e1fe 	bl	139160 <strerror>
  100964:	e1a04000 	mov	r4, r0
  100968:	eb00e1da 	bl	1390d8 <__errno_location>
  10096c:	e1a03000 	mov	r3, r0
  100970:	e5932000 	ldr	r2, [r3]
  100974:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  100978:	e1a01004 	mov	r1, r4
  10097c:	e3050610 	movw	r0, #22032	; 0x5610
  100980:	e3400014 	movt	r0, #20
  100984:	eb00f78b 	bl	13e7b8 <printf>
        goto __exit;
  100988:	ea0000b8 	b	100c70 <socketpair+0x4f4>
    }

    if (listen(listenfd, 10) == -1)
  10098c:	e3a0100a 	mov	r1, #10
  100990:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  100994:	eb00f5fc 	bl	13e18c <listen>
  100998:	e1a03000 	mov	r3, r0
  10099c:	e3730001 	cmn	r3, #1
  1009a0:	1a00000e 	bne	1009e0 <socketpair+0x264>
    {
        printf("Listen socket error: %s(errno: %d)\n", strerror(errno), errno);
  1009a4:	eb00e1cb 	bl	1390d8 <__errno_location>
  1009a8:	e1a03000 	mov	r3, r0
  1009ac:	e5933000 	ldr	r3, [r3]
  1009b0:	e1a00003 	mov	r0, r3
  1009b4:	eb00e1e9 	bl	139160 <strerror>
  1009b8:	e1a04000 	mov	r4, r0
  1009bc:	eb00e1c5 	bl	1390d8 <__errno_location>
  1009c0:	e1a03000 	mov	r3, r0
  1009c4:	e5933000 	ldr	r3, [r3]
  1009c8:	e1a02003 	mov	r2, r3
  1009cc:	e1a01004 	mov	r1, r4
  1009d0:	e305063c 	movw	r0, #22076	; 0x563c
  1009d4:	e3400014 	movt	r0, #20
  1009d8:	eb00f776 	bl	13e7b8 <printf>
        goto __exit;
  1009dc:	ea0000a3 	b	100c70 <socketpair+0x4f4>
    }

    /* client socket */
    if ((clientfd = socket(domain, type, protocol)) < 0)
  1009e0:	e51b2108 	ldr	r2, [fp, #-264]	; 0xfffffef8
  1009e4:	e51b1104 	ldr	r1, [fp, #-260]	; 0xfffffefc
  1009e8:	e51b0100 	ldr	r0, [fp, #-256]	; 0xffffff00
  1009ec:	eb00f613 	bl	13e240 <socket>
  1009f0:	e50b0010 	str	r0, [fp, #-16]
  1009f4:	e51b3010 	ldr	r3, [fp, #-16]
  1009f8:	e3530000 	cmp	r3, #0
  1009fc:	aa00000e 	bge	100a3c <socketpair+0x2c0>
    {
        printf("Create clientfd socket error: %s(errno: %d)\n", strerror(errno), errno);
  100a00:	eb00e1b4 	bl	1390d8 <__errno_location>
  100a04:	e1a03000 	mov	r3, r0
  100a08:	e5933000 	ldr	r3, [r3]
  100a0c:	e1a00003 	mov	r0, r3
  100a10:	eb00e1d2 	bl	139160 <strerror>
  100a14:	e1a04000 	mov	r4, r0
  100a18:	eb00e1ae 	bl	1390d8 <__errno_location>
  100a1c:	e1a03000 	mov	r3, r0
  100a20:	e5933000 	ldr	r3, [r3]
  100a24:	e1a02003 	mov	r2, r3
  100a28:	e1a01004 	mov	r1, r4
  100a2c:	e3050660 	movw	r0, #22112	; 0x5660
  100a30:	e3400014 	movt	r0, #20
  100a34:	eb00f75f 	bl	13e7b8 <printf>
        goto __exit;
  100a38:	ea00008c 	b	100c70 <socketpair+0x4f4>
    }

    /* non-blocking */
    fdopt = setnonblocking(clientfd);
  100a3c:	e51b0010 	ldr	r0, [fp, #-16]
  100a40:	ebffff31 	bl	10070c <setnonblocking>
  100a44:	e50b002c 	str	r0, [fp, #-44]	; 0xffffffd4
    /* client connect */
    memset(&caddr, 0, sizeof(caddr));
  100a48:	e24b3060 	sub	r3, fp, #96	; 0x60
  100a4c:	e3a02010 	mov	r2, #16
  100a50:	e3a01000 	mov	r1, #0
  100a54:	e1a00003 	mov	r0, r3
  100a58:	eb010285 	bl	141474 <memset>
    caddr.sin_family = domain;
  100a5c:	e51b3100 	ldr	r3, [fp, #-256]	; 0xffffff00
  100a60:	e6ff3073 	uxth	r3, r3
  100a64:	e14b36b0 	strh	r3, [fp, #-96]	; 0xffffffa0
    caddr.sin_port =htons(rt_port);
  100a68:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  100a6c:	e6ff3073 	uxth	r3, r3
  100a70:	e1a00003 	mov	r0, r3
  100a74:	eb00f5bf 	bl	13e178 <htons>
  100a78:	e1a03000 	mov	r3, r0
  100a7c:	e14b35be 	strh	r3, [fp, #-94]	; 0xffffffa2
    caddr.sin_addr.s_addr=htonl(INADDR_ANY);
  100a80:	e3a00000 	mov	r0, #0
  100a84:	eb00f5b6 	bl	13e164 <htonl>
  100a88:	e1a03000 	mov	r3, r0
  100a8c:	e50b305c 	str	r3, [fp, #-92]	; 0xffffffa4
    connect(clientfd, (struct sockaddr*)&caddr, sizeof(caddr));
  100a90:	e24b3060 	sub	r3, fp, #96	; 0x60
  100a94:	e3a02010 	mov	r2, #16
  100a98:	e1a01003 	mov	r1, r3
  100a9c:	e51b0010 	ldr	r0, [fp, #-16]
  100aa0:	eb00f5a0 	bl	13e128 <connect>

    /* do select */
    FD_ZERO(&rfd);
  100aa4:	e24b30e8 	sub	r3, fp, #232	; 0xe8
  100aa8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  100aac:	e3a03020 	mov	r3, #32
  100ab0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  100ab4:	ea000007 	b	100ad8 <socketpair+0x35c>
  100ab8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  100abc:	e2832004 	add	r2, r3, #4
  100ac0:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  100ac4:	e3a02000 	mov	r2, #0
  100ac8:	e5832000 	str	r2, [r3]
  100acc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  100ad0:	e2433001 	sub	r3, r3, #1
  100ad4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  100ad8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  100adc:	e3530000 	cmp	r3, #0
  100ae0:	1afffff4 	bne	100ab8 <socketpair+0x33c>
    FD_SET(listenfd, &rfd);
  100ae4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  100ae8:	e1a022a3 	lsr	r2, r3, #5
  100aec:	e1a03102 	lsl	r3, r2, #2
  100af0:	e24b100c 	sub	r1, fp, #12
  100af4:	e0813003 	add	r3, r1, r3
  100af8:	e51310dc 	ldr	r1, [r3, #-220]	; 0xffffff24
  100afc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  100b00:	e203301f 	and	r3, r3, #31
  100b04:	e3a00001 	mov	r0, #1
  100b08:	e1a03310 	lsl	r3, r0, r3
  100b0c:	e1811003 	orr	r1, r1, r3
  100b10:	e1a03102 	lsl	r3, r2, #2
  100b14:	e24b200c 	sub	r2, fp, #12
  100b18:	e0823003 	add	r3, r2, r3
  100b1c:	e50310dc 	str	r1, [r3, #-220]	; 0xffffff24
    FD_SET(clientfd, &rfd);
  100b20:	e51b3010 	ldr	r3, [fp, #-16]
  100b24:	e1a022a3 	lsr	r2, r3, #5
  100b28:	e1a03102 	lsl	r3, r2, #2
  100b2c:	e24b100c 	sub	r1, fp, #12
  100b30:	e0813003 	add	r3, r1, r3
  100b34:	e51310dc 	ldr	r1, [r3, #-220]	; 0xffffff24
  100b38:	e51b3010 	ldr	r3, [fp, #-16]
  100b3c:	e203301f 	and	r3, r3, #31
  100b40:	e3a00001 	mov	r0, #1
  100b44:	e1a03310 	lsl	r3, r0, r3
  100b48:	e1811003 	orr	r1, r1, r3
  100b4c:	e1a03102 	lsl	r3, r2, #2
  100b50:	e24b200c 	sub	r2, fp, #12
  100b54:	e0823003 	add	r3, r2, r3
  100b58:	e50310dc 	str	r1, [r3, #-220]	; 0xffffff24
    maxfdp = listenfd > clientfd ? listenfd+1 : clientfd+1;
  100b5c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  100b60:	e51b3010 	ldr	r3, [fp, #-16]
  100b64:	e1520003 	cmp	r2, r3
  100b68:	da000002 	ble	100b78 <socketpair+0x3fc>
  100b6c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  100b70:	e2833001 	add	r3, r3, #1
  100b74:	ea000001 	b	100b80 <socketpair+0x404>
  100b78:	e51b3010 	ldr	r3, [fp, #-16]
  100b7c:	e2833001 	add	r3, r3, #1
  100b80:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    rst = select(maxfdp, &rfd, NULL, NULL, &timeout);
  100b84:	e24b10e8 	sub	r1, fp, #232	; 0xe8
  100b88:	e24b30fc 	sub	r3, fp, #252	; 0xfc
  100b8c:	e58d3000 	str	r3, [sp]
  100b90:	e3a03000 	mov	r3, #0
  100b94:	e3a02000 	mov	r2, #0
  100b98:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  100b9c:	eb00f60c 	bl	13e3d4 <select>
  100ba0:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
    switch(rst)
  100ba4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  100ba8:	e3730001 	cmn	r3, #1
  100bac:	0a000002 	beq	100bbc <socketpair+0x440>
  100bb0:	e3530000 	cmp	r3, #0
  100bb4:	0a000004 	beq	100bcc <socketpair+0x450>
  100bb8:	ea000007 	b	100bdc <socketpair+0x460>
    {
    case -1:
        perror("select error");
  100bbc:	e3050690 	movw	r0, #22160	; 0x5690
  100bc0:	e3400014 	movt	r0, #20
  100bc4:	eb00f6b2 	bl	13e694 <perror>
        goto __exit;
  100bc8:	ea000028 	b	100c70 <socketpair+0x4f4>
        break;
    case 0:
        perror("continue");
  100bcc:	e30506a0 	movw	r0, #22176	; 0x56a0
  100bd0:	e3400014 	movt	r0, #20
  100bd4:	eb00f6ae 	bl	13e694 <perror>
        break;
  100bd8:	ea000024 	b	100c70 <socketpair+0x4f4>
    default:
        if (FD_ISSET(listenfd, &rfd))
  100bdc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  100be0:	e1a032a3 	lsr	r3, r3, #5
  100be4:	e1a03103 	lsl	r3, r3, #2
  100be8:	e24b200c 	sub	r2, fp, #12
  100bec:	e0823003 	add	r3, r2, r3
  100bf0:	e51320dc 	ldr	r2, [r3, #-220]	; 0xffffff24
  100bf4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  100bf8:	e203301f 	and	r3, r3, #31
  100bfc:	e1a03332 	lsr	r3, r2, r3
  100c00:	e2033001 	and	r3, r3, #1
  100c04:	e3530000 	cmp	r3, #0
  100c08:	0a000017 	beq	100c6c <socketpair+0x4f0>
        {
            if ((acceptfd = accept(listenfd, (struct sockaddr*)&caddr, &len)) > 0)
  100c0c:	e24b2064 	sub	r2, fp, #100	; 0x64
  100c10:	e24b3060 	sub	r3, fp, #96	; 0x60
  100c14:	e1a01003 	mov	r1, r3
  100c18:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  100c1c:	eb00f51c 	bl	13e094 <accept>
  100c20:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  100c24:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  100c28:	e3530000 	cmp	r3, #0
  100c2c:	da00000c 	ble	100c64 <socketpair+0x4e8>
            {
                close(listenfd);
  100c30:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  100c34:	eb0108cf 	bl	142f78 <close>
                /* set old optional back */
                fcntl(clientfd, F_SETFL, fdopt);
  100c38:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  100c3c:	e3a01004 	mov	r1, #4
  100c40:	e51b0010 	ldr	r0, [fp, #-16]
  100c44:	eb00e172 	bl	139214 <fcntl>
                sv[0] = clientfd;
  100c48:	e51b310c 	ldr	r3, [fp, #-268]	; 0xfffffef4
  100c4c:	e51b2010 	ldr	r2, [fp, #-16]
  100c50:	e5832000 	str	r2, [r3]
                sv[1] = acceptfd;
  100c54:	e51b310c 	ldr	r3, [fp, #-268]	; 0xfffffef4
  100c58:	e2833004 	add	r3, r3, #4
  100c5c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  100c60:	e5832000 	str	r2, [r3]
            }

            return 0;
  100c64:	e3a03000 	mov	r3, #0
  100c68:	ea00000b 	b	100c9c <socketpair+0x520>
        }
    }

__exit:
  100c6c:	e320f000 	nop	{0}
    if (listenfd >= 0) close(listenfd);
  100c70:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  100c74:	e3530000 	cmp	r3, #0
  100c78:	ba000001 	blt	100c84 <socketpair+0x508>
  100c7c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  100c80:	eb0108bc 	bl	142f78 <close>
    if (clientfd >= 0) close(clientfd);
  100c84:	e51b3010 	ldr	r3, [fp, #-16]
  100c88:	e3530000 	cmp	r3, #0
  100c8c:	ba000001 	blt	100c98 <socketpair+0x51c>
  100c90:	e51b0010 	ldr	r0, [fp, #-16]
  100c94:	eb0108b7 	bl	142f78 <close>

    return -1;
  100c98:	e3e03000 	mvn	r3, #0
}
  100c9c:	e1a00003 	mov	r0, r3
  100ca0:	e24bd008 	sub	sp, fp, #8
  100ca4:	e8bd8810 	pop	{r4, fp, pc}

00100ca8 <rt_mutex_create>:
            return RT_EIO;\
        }\
    } while (0)

rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
{
  100ca8:	e92d4800 	push	{fp, lr}
  100cac:	e28db004 	add	fp, sp, #4
  100cb0:	e24dd010 	sub	sp, sp, #16
  100cb4:	e50b0010 	str	r0, [fp, #-16]
  100cb8:	e1a03001 	mov	r3, r1
  100cbc:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    RT_USER_IPC_CREATE(RT_Object_Class_Mutex, _NRSYS_mutex_create, name, flag);
  100cc0:	e3a00008 	mov	r0, #8
  100cc4:	eb00f221 	bl	13d550 <malloc>
  100cc8:	e1a03000 	mov	r3, r0
  100ccc:	e50b3008 	str	r3, [fp, #-8]
  100cd0:	e51b3008 	ldr	r3, [fp, #-8]
  100cd4:	e3530000 	cmp	r3, #0
  100cd8:	1a000001 	bne	100ce4 <rt_mutex_create+0x3c>
  100cdc:	e3a03000 	mov	r3, #0
  100ce0:	ea000015 	b	100d3c <rt_mutex_create+0x94>
  100ce4:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  100ce8:	e1a02003 	mov	r2, r3
  100cec:	e51b1010 	ldr	r1, [fp, #-16]
  100cf0:	e3a00016 	mov	r0, #22
  100cf4:	eb00ee58 	bl	13c65c <syscall>
  100cf8:	e1a03000 	mov	r3, r0
  100cfc:	e1a02003 	mov	r2, r3
  100d00:	e51b3008 	ldr	r3, [fp, #-8]
  100d04:	e5832004 	str	r2, [r3, #4]
  100d08:	e51b3008 	ldr	r3, [fp, #-8]
  100d0c:	e5933004 	ldr	r3, [r3, #4]
  100d10:	e3530000 	cmp	r3, #0
  100d14:	0a000003 	beq	100d28 <rt_mutex_create+0x80>
  100d18:	e51b3008 	ldr	r3, [fp, #-8]
  100d1c:	e3a02003 	mov	r2, #3
  100d20:	e5832000 	str	r2, [r3]
  100d24:	ea000003 	b	100d38 <rt_mutex_create+0x90>
  100d28:	e51b0008 	ldr	r0, [fp, #-8]
  100d2c:	eb00f3c3 	bl	13dc40 <free>
  100d30:	e3a03000 	mov	r3, #0
  100d34:	e50b3008 	str	r3, [fp, #-8]
  100d38:	e51b3008 	ldr	r3, [fp, #-8]
}
  100d3c:	e1a00003 	mov	r0, r3
  100d40:	e24bd004 	sub	sp, fp, #4
  100d44:	e8bd8800 	pop	{fp, pc}

00100d48 <rt_mutex_init>:

rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
{
  100d48:	e92d4800 	push	{fp, lr}
  100d4c:	e28db004 	add	fp, sp, #4
  100d50:	e24dd010 	sub	sp, sp, #16
  100d54:	e50b0008 	str	r0, [fp, #-8]
  100d58:	e50b100c 	str	r1, [fp, #-12]
  100d5c:	e1a03002 	mov	r3, r2
  100d60:	e54b300d 	strb	r3, [fp, #-13]
    RT_USER_IPC_INIT(mutex, RT_Object_Class_Mutex, _NRSYS_mutex_create, name, flag);
  100d64:	e51b3008 	ldr	r3, [fp, #-8]
  100d68:	e3530000 	cmp	r3, #0
  100d6c:	1a000001 	bne	100d78 <rt_mutex_init+0x30>
  100d70:	e3a03008 	mov	r3, #8
  100d74:	ea000012 	b	100dc4 <rt_mutex_init+0x7c>
  100d78:	e55b300d 	ldrb	r3, [fp, #-13]
  100d7c:	e1a02003 	mov	r2, r3
  100d80:	e51b100c 	ldr	r1, [fp, #-12]
  100d84:	e3a00016 	mov	r0, #22
  100d88:	eb00ee33 	bl	13c65c <syscall>
  100d8c:	e1a03000 	mov	r3, r0
  100d90:	e1a02003 	mov	r2, r3
  100d94:	e51b3008 	ldr	r3, [fp, #-8]
  100d98:	e5832004 	str	r2, [r3, #4]
  100d9c:	e51b3008 	ldr	r3, [fp, #-8]
  100da0:	e5933004 	ldr	r3, [r3, #4]
  100da4:	e3530000 	cmp	r3, #0
  100da8:	0a000004 	beq	100dc0 <rt_mutex_init+0x78>
  100dac:	e51b3008 	ldr	r3, [fp, #-8]
  100db0:	e3a02003 	mov	r2, #3
  100db4:	e5832000 	str	r2, [r3]
  100db8:	e3a03000 	mov	r3, #0
  100dbc:	ea000000 	b	100dc4 <rt_mutex_init+0x7c>
  100dc0:	e3a03001 	mov	r3, #1
}
  100dc4:	e1a00003 	mov	r0, r3
  100dc8:	e24bd004 	sub	sp, fp, #4
  100dcc:	e8bd8800 	pop	{fp, pc}

00100dd0 <rt_mutex_delete>:

rt_err_t rt_mutex_delete(rt_mutex_t mutex)
{
  100dd0:	e92d4800 	push	{fp, lr}
  100dd4:	e28db004 	add	fp, sp, #4
  100dd8:	e24dd010 	sub	sp, sp, #16
  100ddc:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DELETE(mutex, RT_Object_Class_Mutex, _NRSYS_mutex_delete);
  100de0:	e51b3010 	ldr	r3, [fp, #-16]
  100de4:	e3530000 	cmp	r3, #0
  100de8:	0a000003 	beq	100dfc <rt_mutex_delete+0x2c>
  100dec:	e51b3010 	ldr	r3, [fp, #-16]
  100df0:	e5933004 	ldr	r3, [r3, #4]
  100df4:	e3530000 	cmp	r3, #0
  100df8:	1a000001 	bne	100e04 <rt_mutex_delete+0x34>
  100dfc:	e3a03008 	mov	r3, #8
  100e00:	ea000013 	b	100e54 <rt_mutex_delete+0x84>
  100e04:	e51b3010 	ldr	r3, [fp, #-16]
  100e08:	e5933000 	ldr	r3, [r3]
  100e0c:	e3530003 	cmp	r3, #3
  100e10:	0a000001 	beq	100e1c <rt_mutex_delete+0x4c>
  100e14:	e3a03008 	mov	r3, #8
  100e18:	ea00000d 	b	100e54 <rt_mutex_delete+0x84>
  100e1c:	e51b3010 	ldr	r3, [fp, #-16]
  100e20:	e5933004 	ldr	r3, [r3, #4]
  100e24:	e1a01003 	mov	r1, r3
  100e28:	e3a00017 	mov	r0, #23
  100e2c:	eb00ee0a 	bl	13c65c <syscall>
  100e30:	e50b0008 	str	r0, [fp, #-8]
  100e34:	e51b3008 	ldr	r3, [fp, #-8]
  100e38:	e3530000 	cmp	r3, #0
  100e3c:	0a000001 	beq	100e48 <rt_mutex_delete+0x78>
  100e40:	e51b3008 	ldr	r3, [fp, #-8]
  100e44:	ea000002 	b	100e54 <rt_mutex_delete+0x84>
  100e48:	e51b0010 	ldr	r0, [fp, #-16]
  100e4c:	eb00f37b 	bl	13dc40 <free>
  100e50:	e3a03000 	mov	r3, #0
}
  100e54:	e1a00003 	mov	r0, r3
  100e58:	e24bd004 	sub	sp, fp, #4
  100e5c:	e8bd8800 	pop	{fp, pc}

00100e60 <rt_mutex_detach>:

rt_err_t rt_mutex_detach(rt_mutex_t mutex)
{
  100e60:	e92d4800 	push	{fp, lr}
  100e64:	e28db004 	add	fp, sp, #4
  100e68:	e24dd010 	sub	sp, sp, #16
  100e6c:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DETACH(mutex, RT_Object_Class_Mutex, _NRSYS_mutex_delete);
  100e70:	e51b3010 	ldr	r3, [fp, #-16]
  100e74:	e3530000 	cmp	r3, #0
  100e78:	0a000003 	beq	100e8c <rt_mutex_detach+0x2c>
  100e7c:	e51b3010 	ldr	r3, [fp, #-16]
  100e80:	e5933004 	ldr	r3, [r3, #4]
  100e84:	e3530000 	cmp	r3, #0
  100e88:	1a000001 	bne	100e94 <rt_mutex_detach+0x34>
  100e8c:	e3a03008 	mov	r3, #8
  100e90:	ea000017 	b	100ef4 <rt_mutex_detach+0x94>
  100e94:	e51b3010 	ldr	r3, [fp, #-16]
  100e98:	e5933000 	ldr	r3, [r3]
  100e9c:	e3530003 	cmp	r3, #3
  100ea0:	0a000001 	beq	100eac <rt_mutex_detach+0x4c>
  100ea4:	e3a03008 	mov	r3, #8
  100ea8:	ea000011 	b	100ef4 <rt_mutex_detach+0x94>
  100eac:	e51b3010 	ldr	r3, [fp, #-16]
  100eb0:	e5933004 	ldr	r3, [r3, #4]
  100eb4:	e1a01003 	mov	r1, r3
  100eb8:	e3a00017 	mov	r0, #23
  100ebc:	eb00ede6 	bl	13c65c <syscall>
  100ec0:	e50b0008 	str	r0, [fp, #-8]
  100ec4:	e51b3008 	ldr	r3, [fp, #-8]
  100ec8:	e3530000 	cmp	r3, #0
  100ecc:	0a000001 	beq	100ed8 <rt_mutex_detach+0x78>
  100ed0:	e51b3008 	ldr	r3, [fp, #-8]
  100ed4:	ea000006 	b	100ef4 <rt_mutex_detach+0x94>
  100ed8:	e51b3010 	ldr	r3, [fp, #-16]
  100edc:	e3a02000 	mov	r2, #0
  100ee0:	e5832000 	str	r2, [r3]
  100ee4:	e51b3010 	ldr	r3, [fp, #-16]
  100ee8:	e3a02000 	mov	r2, #0
  100eec:	e5832004 	str	r2, [r3, #4]
  100ef0:	e3a03000 	mov	r3, #0
}
  100ef4:	e1a00003 	mov	r0, r3
  100ef8:	e24bd004 	sub	sp, fp, #4
  100efc:	e8bd8800 	pop	{fp, pc}

00100f00 <rt_mutex_take>:

rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
{
  100f00:	e92d4800 	push	{fp, lr}
  100f04:	e28db004 	add	fp, sp, #4
  100f08:	e24dd008 	sub	sp, sp, #8
  100f0c:	e50b0008 	str	r0, [fp, #-8]
  100f10:	e50b100c 	str	r1, [fp, #-12]
    RT_USER_IPC_CHECK(mutex, RT_Object_Class_Mutex);
  100f14:	e51b3008 	ldr	r3, [fp, #-8]
  100f18:	e3530000 	cmp	r3, #0
  100f1c:	0a000003 	beq	100f30 <rt_mutex_take+0x30>
  100f20:	e51b3008 	ldr	r3, [fp, #-8]
  100f24:	e5933004 	ldr	r3, [r3, #4]
  100f28:	e3530000 	cmp	r3, #0
  100f2c:	1a000001 	bne	100f38 <rt_mutex_take+0x38>
  100f30:	e3a03008 	mov	r3, #8
  100f34:	ea00000c 	b	100f6c <rt_mutex_take+0x6c>
  100f38:	e51b3008 	ldr	r3, [fp, #-8]
  100f3c:	e5933000 	ldr	r3, [r3]
  100f40:	e3530003 	cmp	r3, #3
  100f44:	0a000001 	beq	100f50 <rt_mutex_take+0x50>
  100f48:	e3a03008 	mov	r3, #8
  100f4c:	ea000006 	b	100f6c <rt_mutex_take+0x6c>
    return syscall(_NRSYS_mutex_take, mutex->data, time);
  100f50:	e51b3008 	ldr	r3, [fp, #-8]
  100f54:	e5933004 	ldr	r3, [r3, #4]
  100f58:	e51b200c 	ldr	r2, [fp, #-12]
  100f5c:	e1a01003 	mov	r1, r3
  100f60:	e3a00018 	mov	r0, #24
  100f64:	eb00edbc 	bl	13c65c <syscall>
  100f68:	e1a03000 	mov	r3, r0
}
  100f6c:	e1a00003 	mov	r0, r3
  100f70:	e24bd004 	sub	sp, fp, #4
  100f74:	e8bd8800 	pop	{fp, pc}

00100f78 <rt_mutex_release>:

rt_err_t rt_mutex_release(rt_mutex_t mutex)
{
  100f78:	e92d4800 	push	{fp, lr}
  100f7c:	e28db004 	add	fp, sp, #4
  100f80:	e24dd008 	sub	sp, sp, #8
  100f84:	e50b0008 	str	r0, [fp, #-8]
    RT_USER_IPC_CHECK(mutex, RT_Object_Class_Mutex);
  100f88:	e51b3008 	ldr	r3, [fp, #-8]
  100f8c:	e3530000 	cmp	r3, #0
  100f90:	0a000003 	beq	100fa4 <rt_mutex_release+0x2c>
  100f94:	e51b3008 	ldr	r3, [fp, #-8]
  100f98:	e5933004 	ldr	r3, [r3, #4]
  100f9c:	e3530000 	cmp	r3, #0
  100fa0:	1a000001 	bne	100fac <rt_mutex_release+0x34>
  100fa4:	e3a03008 	mov	r3, #8
  100fa8:	ea00000b 	b	100fdc <rt_mutex_release+0x64>
  100fac:	e51b3008 	ldr	r3, [fp, #-8]
  100fb0:	e5933000 	ldr	r3, [r3]
  100fb4:	e3530003 	cmp	r3, #3
  100fb8:	0a000001 	beq	100fc4 <rt_mutex_release+0x4c>
  100fbc:	e3a03008 	mov	r3, #8
  100fc0:	ea000005 	b	100fdc <rt_mutex_release+0x64>
    return syscall(_NRSYS_mutex_release, mutex->data);
  100fc4:	e51b3008 	ldr	r3, [fp, #-8]
  100fc8:	e5933004 	ldr	r3, [r3, #4]
  100fcc:	e1a01003 	mov	r1, r3
  100fd0:	e3a00019 	mov	r0, #25
  100fd4:	eb00eda0 	bl	13c65c <syscall>
  100fd8:	e1a03000 	mov	r3, r0
}
  100fdc:	e1a00003 	mov	r0, r3
  100fe0:	e24bd004 	sub	sp, fp, #4
  100fe4:	e8bd8800 	pop	{fp, pc}

00100fe8 <rt_sem_create>:

rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
{
  100fe8:	e92d4800 	push	{fp, lr}
  100fec:	e28db004 	add	fp, sp, #4
  100ff0:	e24dd018 	sub	sp, sp, #24
  100ff4:	e50b0010 	str	r0, [fp, #-16]
  100ff8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  100ffc:	e1a03002 	mov	r3, r2
  101000:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    RT_USER_IPC_CREATE(RT_Object_Class_Semaphore, _NRSYS_sem_create, name, value, flag);
  101004:	e3a00008 	mov	r0, #8
  101008:	eb00f150 	bl	13d550 <malloc>
  10100c:	e1a03000 	mov	r3, r0
  101010:	e50b3008 	str	r3, [fp, #-8]
  101014:	e51b3008 	ldr	r3, [fp, #-8]
  101018:	e3530000 	cmp	r3, #0
  10101c:	1a000001 	bne	101028 <rt_sem_create+0x40>
  101020:	e3a03000 	mov	r3, #0
  101024:	ea000015 	b	101080 <rt_sem_create+0x98>
  101028:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  10102c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  101030:	e51b1010 	ldr	r1, [fp, #-16]
  101034:	e3a00012 	mov	r0, #18
  101038:	eb00ed87 	bl	13c65c <syscall>
  10103c:	e1a03000 	mov	r3, r0
  101040:	e1a02003 	mov	r2, r3
  101044:	e51b3008 	ldr	r3, [fp, #-8]
  101048:	e5832004 	str	r2, [r3, #4]
  10104c:	e51b3008 	ldr	r3, [fp, #-8]
  101050:	e5933004 	ldr	r3, [r3, #4]
  101054:	e3530000 	cmp	r3, #0
  101058:	0a000003 	beq	10106c <rt_sem_create+0x84>
  10105c:	e51b3008 	ldr	r3, [fp, #-8]
  101060:	e3a02002 	mov	r2, #2
  101064:	e5832000 	str	r2, [r3]
  101068:	ea000003 	b	10107c <rt_sem_create+0x94>
  10106c:	e51b0008 	ldr	r0, [fp, #-8]
  101070:	eb00f2f2 	bl	13dc40 <free>
  101074:	e3a03000 	mov	r3, #0
  101078:	e50b3008 	str	r3, [fp, #-8]
  10107c:	e51b3008 	ldr	r3, [fp, #-8]
}
  101080:	e1a00003 	mov	r0, r3
  101084:	e24bd004 	sub	sp, fp, #4
  101088:	e8bd8800 	pop	{fp, pc}

0010108c <rt_sem_init>:

rt_err_t rt_sem_init(rt_sem_t sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t  flag)
{
  10108c:	e92d4800 	push	{fp, lr}
  101090:	e28db004 	add	fp, sp, #4
  101094:	e24dd010 	sub	sp, sp, #16
  101098:	e50b0008 	str	r0, [fp, #-8]
  10109c:	e50b100c 	str	r1, [fp, #-12]
  1010a0:	e50b2010 	str	r2, [fp, #-16]
  1010a4:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    RT_USER_IPC_INIT(sem, RT_Object_Class_Semaphore, _NRSYS_sem_create, name, value, flag);
  1010a8:	e51b3008 	ldr	r3, [fp, #-8]
  1010ac:	e3530000 	cmp	r3, #0
  1010b0:	1a000001 	bne	1010bc <rt_sem_init+0x30>
  1010b4:	e3a03008 	mov	r3, #8
  1010b8:	ea000012 	b	101108 <rt_sem_init+0x7c>
  1010bc:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  1010c0:	e51b2010 	ldr	r2, [fp, #-16]
  1010c4:	e51b100c 	ldr	r1, [fp, #-12]
  1010c8:	e3a00012 	mov	r0, #18
  1010cc:	eb00ed62 	bl	13c65c <syscall>
  1010d0:	e1a03000 	mov	r3, r0
  1010d4:	e1a02003 	mov	r2, r3
  1010d8:	e51b3008 	ldr	r3, [fp, #-8]
  1010dc:	e5832004 	str	r2, [r3, #4]
  1010e0:	e51b3008 	ldr	r3, [fp, #-8]
  1010e4:	e5933004 	ldr	r3, [r3, #4]
  1010e8:	e3530000 	cmp	r3, #0
  1010ec:	0a000004 	beq	101104 <rt_sem_init+0x78>
  1010f0:	e51b3008 	ldr	r3, [fp, #-8]
  1010f4:	e3a02002 	mov	r2, #2
  1010f8:	e5832000 	str	r2, [r3]
  1010fc:	e3a03000 	mov	r3, #0
  101100:	ea000000 	b	101108 <rt_sem_init+0x7c>
  101104:	e3a03001 	mov	r3, #1
}
  101108:	e1a00003 	mov	r0, r3
  10110c:	e24bd004 	sub	sp, fp, #4
  101110:	e8bd8800 	pop	{fp, pc}

00101114 <rt_sem_delete>:

rt_err_t rt_sem_delete(rt_sem_t sem)
{
  101114:	e92d4800 	push	{fp, lr}
  101118:	e28db004 	add	fp, sp, #4
  10111c:	e24dd010 	sub	sp, sp, #16
  101120:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DELETE(sem, RT_Object_Class_Semaphore, _NRSYS_sem_delete);
  101124:	e51b3010 	ldr	r3, [fp, #-16]
  101128:	e3530000 	cmp	r3, #0
  10112c:	0a000003 	beq	101140 <rt_sem_delete+0x2c>
  101130:	e51b3010 	ldr	r3, [fp, #-16]
  101134:	e5933004 	ldr	r3, [r3, #4]
  101138:	e3530000 	cmp	r3, #0
  10113c:	1a000001 	bne	101148 <rt_sem_delete+0x34>
  101140:	e3a03008 	mov	r3, #8
  101144:	ea000013 	b	101198 <rt_sem_delete+0x84>
  101148:	e51b3010 	ldr	r3, [fp, #-16]
  10114c:	e5933000 	ldr	r3, [r3]
  101150:	e3530002 	cmp	r3, #2
  101154:	0a000001 	beq	101160 <rt_sem_delete+0x4c>
  101158:	e3a03008 	mov	r3, #8
  10115c:	ea00000d 	b	101198 <rt_sem_delete+0x84>
  101160:	e51b3010 	ldr	r3, [fp, #-16]
  101164:	e5933004 	ldr	r3, [r3, #4]
  101168:	e1a01003 	mov	r1, r3
  10116c:	e3a00013 	mov	r0, #19
  101170:	eb00ed39 	bl	13c65c <syscall>
  101174:	e50b0008 	str	r0, [fp, #-8]
  101178:	e51b3008 	ldr	r3, [fp, #-8]
  10117c:	e3530000 	cmp	r3, #0
  101180:	0a000001 	beq	10118c <rt_sem_delete+0x78>
  101184:	e51b3008 	ldr	r3, [fp, #-8]
  101188:	ea000002 	b	101198 <rt_sem_delete+0x84>
  10118c:	e51b0010 	ldr	r0, [fp, #-16]
  101190:	eb00f2aa 	bl	13dc40 <free>
  101194:	e3a03000 	mov	r3, #0
}
  101198:	e1a00003 	mov	r0, r3
  10119c:	e24bd004 	sub	sp, fp, #4
  1011a0:	e8bd8800 	pop	{fp, pc}

001011a4 <rt_sem_detach>:

rt_err_t rt_sem_detach(rt_sem_t sem)
{
  1011a4:	e92d4800 	push	{fp, lr}
  1011a8:	e28db004 	add	fp, sp, #4
  1011ac:	e24dd010 	sub	sp, sp, #16
  1011b0:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DETACH(sem, RT_Object_Class_Semaphore, _NRSYS_sem_delete);
  1011b4:	e51b3010 	ldr	r3, [fp, #-16]
  1011b8:	e3530000 	cmp	r3, #0
  1011bc:	0a000003 	beq	1011d0 <rt_sem_detach+0x2c>
  1011c0:	e51b3010 	ldr	r3, [fp, #-16]
  1011c4:	e5933004 	ldr	r3, [r3, #4]
  1011c8:	e3530000 	cmp	r3, #0
  1011cc:	1a000001 	bne	1011d8 <rt_sem_detach+0x34>
  1011d0:	e3a03008 	mov	r3, #8
  1011d4:	ea000017 	b	101238 <rt_sem_detach+0x94>
  1011d8:	e51b3010 	ldr	r3, [fp, #-16]
  1011dc:	e5933000 	ldr	r3, [r3]
  1011e0:	e3530002 	cmp	r3, #2
  1011e4:	0a000001 	beq	1011f0 <rt_sem_detach+0x4c>
  1011e8:	e3a03008 	mov	r3, #8
  1011ec:	ea000011 	b	101238 <rt_sem_detach+0x94>
  1011f0:	e51b3010 	ldr	r3, [fp, #-16]
  1011f4:	e5933004 	ldr	r3, [r3, #4]
  1011f8:	e1a01003 	mov	r1, r3
  1011fc:	e3a00013 	mov	r0, #19
  101200:	eb00ed15 	bl	13c65c <syscall>
  101204:	e50b0008 	str	r0, [fp, #-8]
  101208:	e51b3008 	ldr	r3, [fp, #-8]
  10120c:	e3530000 	cmp	r3, #0
  101210:	0a000001 	beq	10121c <rt_sem_detach+0x78>
  101214:	e51b3008 	ldr	r3, [fp, #-8]
  101218:	ea000006 	b	101238 <rt_sem_detach+0x94>
  10121c:	e51b3010 	ldr	r3, [fp, #-16]
  101220:	e3a02000 	mov	r2, #0
  101224:	e5832000 	str	r2, [r3]
  101228:	e51b3010 	ldr	r3, [fp, #-16]
  10122c:	e3a02000 	mov	r2, #0
  101230:	e5832004 	str	r2, [r3, #4]
  101234:	e3a03000 	mov	r3, #0
}
  101238:	e1a00003 	mov	r0, r3
  10123c:	e24bd004 	sub	sp, fp, #4
  101240:	e8bd8800 	pop	{fp, pc}

00101244 <rt_sem_release>:

rt_err_t rt_sem_release(rt_sem_t sem)
{
  101244:	e92d4800 	push	{fp, lr}
  101248:	e28db004 	add	fp, sp, #4
  10124c:	e24dd008 	sub	sp, sp, #8
  101250:	e50b0008 	str	r0, [fp, #-8]
    RT_USER_IPC_CHECK(sem, RT_Object_Class_Semaphore);
  101254:	e51b3008 	ldr	r3, [fp, #-8]
  101258:	e3530000 	cmp	r3, #0
  10125c:	0a000003 	beq	101270 <rt_sem_release+0x2c>
  101260:	e51b3008 	ldr	r3, [fp, #-8]
  101264:	e5933004 	ldr	r3, [r3, #4]
  101268:	e3530000 	cmp	r3, #0
  10126c:	1a000001 	bne	101278 <rt_sem_release+0x34>
  101270:	e3a03008 	mov	r3, #8
  101274:	ea00000b 	b	1012a8 <rt_sem_release+0x64>
  101278:	e51b3008 	ldr	r3, [fp, #-8]
  10127c:	e5933000 	ldr	r3, [r3]
  101280:	e3530002 	cmp	r3, #2
  101284:	0a000001 	beq	101290 <rt_sem_release+0x4c>
  101288:	e3a03008 	mov	r3, #8
  10128c:	ea000005 	b	1012a8 <rt_sem_release+0x64>
    return syscall(_NRSYS_sem_release, sem->data);
  101290:	e51b3008 	ldr	r3, [fp, #-8]
  101294:	e5933004 	ldr	r3, [r3, #4]
  101298:	e1a01003 	mov	r1, r3
  10129c:	e3a00015 	mov	r0, #21
  1012a0:	eb00eced 	bl	13c65c <syscall>
  1012a4:	e1a03000 	mov	r3, r0
}
  1012a8:	e1a00003 	mov	r0, r3
  1012ac:	e24bd004 	sub	sp, fp, #4
  1012b0:	e8bd8800 	pop	{fp, pc}

001012b4 <rt_sem_take>:

rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
{
  1012b4:	e92d4800 	push	{fp, lr}
  1012b8:	e28db004 	add	fp, sp, #4
  1012bc:	e24dd008 	sub	sp, sp, #8
  1012c0:	e50b0008 	str	r0, [fp, #-8]
  1012c4:	e50b100c 	str	r1, [fp, #-12]
    RT_USER_IPC_CHECK(sem, RT_Object_Class_Semaphore);
  1012c8:	e51b3008 	ldr	r3, [fp, #-8]
  1012cc:	e3530000 	cmp	r3, #0
  1012d0:	0a000003 	beq	1012e4 <rt_sem_take+0x30>
  1012d4:	e51b3008 	ldr	r3, [fp, #-8]
  1012d8:	e5933004 	ldr	r3, [r3, #4]
  1012dc:	e3530000 	cmp	r3, #0
  1012e0:	1a000001 	bne	1012ec <rt_sem_take+0x38>
  1012e4:	e3a03008 	mov	r3, #8
  1012e8:	ea00000c 	b	101320 <rt_sem_take+0x6c>
  1012ec:	e51b3008 	ldr	r3, [fp, #-8]
  1012f0:	e5933000 	ldr	r3, [r3]
  1012f4:	e3530002 	cmp	r3, #2
  1012f8:	0a000001 	beq	101304 <rt_sem_take+0x50>
  1012fc:	e3a03008 	mov	r3, #8
  101300:	ea000006 	b	101320 <rt_sem_take+0x6c>
    return syscall(_NRSYS_sem_take, sem->data, time);
  101304:	e51b3008 	ldr	r3, [fp, #-8]
  101308:	e5933004 	ldr	r3, [r3, #4]
  10130c:	e51b200c 	ldr	r2, [fp, #-12]
  101310:	e1a01003 	mov	r1, r3
  101314:	e3a00014 	mov	r0, #20
  101318:	eb00eccf 	bl	13c65c <syscall>
  10131c:	e1a03000 	mov	r3, r0
}
  101320:	e1a00003 	mov	r0, r3
  101324:	e24bd004 	sub	sp, fp, #4
  101328:	e8bd8800 	pop	{fp, pc}

0010132c <rt_mb_create>:

rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
{
  10132c:	e92d4800 	push	{fp, lr}
  101330:	e28db004 	add	fp, sp, #4
  101334:	e24dd018 	sub	sp, sp, #24
  101338:	e50b0010 	str	r0, [fp, #-16]
  10133c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  101340:	e1a03002 	mov	r3, r2
  101344:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    RT_USER_IPC_CREATE(RT_Object_Class_MailBox, _NRSYS_mb_create, name, size, flag);
  101348:	e3a00008 	mov	r0, #8
  10134c:	eb00f07f 	bl	13d550 <malloc>
  101350:	e1a03000 	mov	r3, r0
  101354:	e50b3008 	str	r3, [fp, #-8]
  101358:	e51b3008 	ldr	r3, [fp, #-8]
  10135c:	e3530000 	cmp	r3, #0
  101360:	1a000001 	bne	10136c <rt_mb_create+0x40>
  101364:	e3a03000 	mov	r3, #0
  101368:	ea000015 	b	1013c4 <rt_mb_create+0x98>
  10136c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  101370:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  101374:	e51b1010 	ldr	r1, [fp, #-16]
  101378:	e3a0001e 	mov	r0, #30
  10137c:	eb00ecb6 	bl	13c65c <syscall>
  101380:	e1a03000 	mov	r3, r0
  101384:	e1a02003 	mov	r2, r3
  101388:	e51b3008 	ldr	r3, [fp, #-8]
  10138c:	e5832004 	str	r2, [r3, #4]
  101390:	e51b3008 	ldr	r3, [fp, #-8]
  101394:	e5933004 	ldr	r3, [r3, #4]
  101398:	e3530000 	cmp	r3, #0
  10139c:	0a000003 	beq	1013b0 <rt_mb_create+0x84>
  1013a0:	e51b3008 	ldr	r3, [fp, #-8]
  1013a4:	e3a02005 	mov	r2, #5
  1013a8:	e5832000 	str	r2, [r3]
  1013ac:	ea000003 	b	1013c0 <rt_mb_create+0x94>
  1013b0:	e51b0008 	ldr	r0, [fp, #-8]
  1013b4:	eb00f221 	bl	13dc40 <free>
  1013b8:	e3a03000 	mov	r3, #0
  1013bc:	e50b3008 	str	r3, [fp, #-8]
  1013c0:	e51b3008 	ldr	r3, [fp, #-8]
}
  1013c4:	e1a00003 	mov	r0, r3
  1013c8:	e24bd004 	sub	sp, fp, #4
  1013cc:	e8bd8800 	pop	{fp, pc}

001013d0 <rt_mb_init>:
rt_err_t rt_mb_init(rt_mailbox_t mb,
                    const char  *name,
                    void        *msgpool,
                    rt_size_t    size,
                    rt_uint8_t   flag)
{
  1013d0:	e92d4800 	push	{fp, lr}
  1013d4:	e28db004 	add	fp, sp, #4
  1013d8:	e24dd010 	sub	sp, sp, #16
  1013dc:	e50b0008 	str	r0, [fp, #-8]
  1013e0:	e50b100c 	str	r1, [fp, #-12]
  1013e4:	e50b2010 	str	r2, [fp, #-16]
  1013e8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    RT_USER_IPC_INIT(mb, RT_Object_Class_MailBox, _NRSYS_mb_create, name, size, flag);
  1013ec:	e51b3008 	ldr	r3, [fp, #-8]
  1013f0:	e3530000 	cmp	r3, #0
  1013f4:	1a000001 	bne	101400 <rt_mb_init+0x30>
  1013f8:	e3a03008 	mov	r3, #8
  1013fc:	ea000012 	b	10144c <rt_mb_init+0x7c>
  101400:	e5db3004 	ldrb	r3, [fp, #4]
  101404:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  101408:	e51b100c 	ldr	r1, [fp, #-12]
  10140c:	e3a0001e 	mov	r0, #30
  101410:	eb00ec91 	bl	13c65c <syscall>
  101414:	e1a03000 	mov	r3, r0
  101418:	e1a02003 	mov	r2, r3
  10141c:	e51b3008 	ldr	r3, [fp, #-8]
  101420:	e5832004 	str	r2, [r3, #4]
  101424:	e51b3008 	ldr	r3, [fp, #-8]
  101428:	e5933004 	ldr	r3, [r3, #4]
  10142c:	e3530000 	cmp	r3, #0
  101430:	0a000004 	beq	101448 <rt_mb_init+0x78>
  101434:	e51b3008 	ldr	r3, [fp, #-8]
  101438:	e3a02005 	mov	r2, #5
  10143c:	e5832000 	str	r2, [r3]
  101440:	e3a03000 	mov	r3, #0
  101444:	ea000000 	b	10144c <rt_mb_init+0x7c>
  101448:	e3a03001 	mov	r3, #1
}
  10144c:	e1a00003 	mov	r0, r3
  101450:	e24bd004 	sub	sp, fp, #4
  101454:	e8bd8800 	pop	{fp, pc}

00101458 <rt_mb_delete>:


rt_err_t rt_mb_delete(rt_mailbox_t mb)
{
  101458:	e92d4800 	push	{fp, lr}
  10145c:	e28db004 	add	fp, sp, #4
  101460:	e24dd010 	sub	sp, sp, #16
  101464:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DELETE(mb, RT_Object_Class_MailBox, _NRSYS_mb_delete);
  101468:	e51b3010 	ldr	r3, [fp, #-16]
  10146c:	e3530000 	cmp	r3, #0
  101470:	0a000003 	beq	101484 <rt_mb_delete+0x2c>
  101474:	e51b3010 	ldr	r3, [fp, #-16]
  101478:	e5933004 	ldr	r3, [r3, #4]
  10147c:	e3530000 	cmp	r3, #0
  101480:	1a000001 	bne	10148c <rt_mb_delete+0x34>
  101484:	e3a03008 	mov	r3, #8
  101488:	ea000013 	b	1014dc <rt_mb_delete+0x84>
  10148c:	e51b3010 	ldr	r3, [fp, #-16]
  101490:	e5933000 	ldr	r3, [r3]
  101494:	e3530005 	cmp	r3, #5
  101498:	0a000001 	beq	1014a4 <rt_mb_delete+0x4c>
  10149c:	e3a03008 	mov	r3, #8
  1014a0:	ea00000d 	b	1014dc <rt_mb_delete+0x84>
  1014a4:	e51b3010 	ldr	r3, [fp, #-16]
  1014a8:	e5933004 	ldr	r3, [r3, #4]
  1014ac:	e1a01003 	mov	r1, r3
  1014b0:	e3a0001f 	mov	r0, #31
  1014b4:	eb00ec68 	bl	13c65c <syscall>
  1014b8:	e50b0008 	str	r0, [fp, #-8]
  1014bc:	e51b3008 	ldr	r3, [fp, #-8]
  1014c0:	e3530000 	cmp	r3, #0
  1014c4:	0a000001 	beq	1014d0 <rt_mb_delete+0x78>
  1014c8:	e51b3008 	ldr	r3, [fp, #-8]
  1014cc:	ea000002 	b	1014dc <rt_mb_delete+0x84>
  1014d0:	e51b0010 	ldr	r0, [fp, #-16]
  1014d4:	eb00f1d9 	bl	13dc40 <free>
  1014d8:	e3a03000 	mov	r3, #0
}
  1014dc:	e1a00003 	mov	r0, r3
  1014e0:	e24bd004 	sub	sp, fp, #4
  1014e4:	e8bd8800 	pop	{fp, pc}

001014e8 <rt_mb_detach>:

rt_err_t rt_mb_detach(rt_mailbox_t mb)
{
  1014e8:	e92d4800 	push	{fp, lr}
  1014ec:	e28db004 	add	fp, sp, #4
  1014f0:	e24dd010 	sub	sp, sp, #16
  1014f4:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DETACH(mb, RT_Object_Class_MailBox, _NRSYS_mb_delete);
  1014f8:	e51b3010 	ldr	r3, [fp, #-16]
  1014fc:	e3530000 	cmp	r3, #0
  101500:	0a000003 	beq	101514 <rt_mb_detach+0x2c>
  101504:	e51b3010 	ldr	r3, [fp, #-16]
  101508:	e5933004 	ldr	r3, [r3, #4]
  10150c:	e3530000 	cmp	r3, #0
  101510:	1a000001 	bne	10151c <rt_mb_detach+0x34>
  101514:	e3a03008 	mov	r3, #8
  101518:	ea000017 	b	10157c <rt_mb_detach+0x94>
  10151c:	e51b3010 	ldr	r3, [fp, #-16]
  101520:	e5933000 	ldr	r3, [r3]
  101524:	e3530005 	cmp	r3, #5
  101528:	0a000001 	beq	101534 <rt_mb_detach+0x4c>
  10152c:	e3a03008 	mov	r3, #8
  101530:	ea000011 	b	10157c <rt_mb_detach+0x94>
  101534:	e51b3010 	ldr	r3, [fp, #-16]
  101538:	e5933004 	ldr	r3, [r3, #4]
  10153c:	e1a01003 	mov	r1, r3
  101540:	e3a0001f 	mov	r0, #31
  101544:	eb00ec44 	bl	13c65c <syscall>
  101548:	e50b0008 	str	r0, [fp, #-8]
  10154c:	e51b3008 	ldr	r3, [fp, #-8]
  101550:	e3530000 	cmp	r3, #0
  101554:	0a000001 	beq	101560 <rt_mb_detach+0x78>
  101558:	e51b3008 	ldr	r3, [fp, #-8]
  10155c:	ea000006 	b	10157c <rt_mb_detach+0x94>
  101560:	e51b3010 	ldr	r3, [fp, #-16]
  101564:	e3a02000 	mov	r2, #0
  101568:	e5832000 	str	r2, [r3]
  10156c:	e51b3010 	ldr	r3, [fp, #-16]
  101570:	e3a02000 	mov	r2, #0
  101574:	e5832004 	str	r2, [r3, #4]
  101578:	e3a03000 	mov	r3, #0
}
  10157c:	e1a00003 	mov	r0, r3
  101580:	e24bd004 	sub	sp, fp, #4
  101584:	e8bd8800 	pop	{fp, pc}

00101588 <rt_mb_send_wait>:

rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
        rt_ubase_t   value,
        rt_int32_t   timeout)
{
  101588:	e92d4800 	push	{fp, lr}
  10158c:	e28db004 	add	fp, sp, #4
  101590:	e24dd010 	sub	sp, sp, #16
  101594:	e50b0008 	str	r0, [fp, #-8]
  101598:	e50b100c 	str	r1, [fp, #-12]
  10159c:	e50b2010 	str	r2, [fp, #-16]
    RT_USER_IPC_CHECK(mb, RT_Object_Class_MailBox);
  1015a0:	e51b3008 	ldr	r3, [fp, #-8]
  1015a4:	e3530000 	cmp	r3, #0
  1015a8:	0a000003 	beq	1015bc <rt_mb_send_wait+0x34>
  1015ac:	e51b3008 	ldr	r3, [fp, #-8]
  1015b0:	e5933004 	ldr	r3, [r3, #4]
  1015b4:	e3530000 	cmp	r3, #0
  1015b8:	1a000001 	bne	1015c4 <rt_mb_send_wait+0x3c>
  1015bc:	e3a03008 	mov	r3, #8
  1015c0:	ea00000c 	b	1015f8 <rt_mb_send_wait+0x70>
  1015c4:	e51b3008 	ldr	r3, [fp, #-8]
  1015c8:	e5933000 	ldr	r3, [r3]
  1015cc:	e3530005 	cmp	r3, #5
  1015d0:	0a000001 	beq	1015dc <rt_mb_send_wait+0x54>
  1015d4:	e3a03008 	mov	r3, #8
  1015d8:	ea000006 	b	1015f8 <rt_mb_send_wait+0x70>
    return syscall(_NRSYS_mb_send_wait, mb->data, value, timeout);
  1015dc:	e51b3008 	ldr	r3, [fp, #-8]
  1015e0:	e5931004 	ldr	r1, [r3, #4]
  1015e4:	e51b3010 	ldr	r3, [fp, #-16]
  1015e8:	e51b200c 	ldr	r2, [fp, #-12]
  1015ec:	e3a00021 	mov	r0, #33	; 0x21
  1015f0:	eb00ec19 	bl	13c65c <syscall>
  1015f4:	e1a03000 	mov	r3, r0
}
  1015f8:	e1a00003 	mov	r0, r3
  1015fc:	e24bd004 	sub	sp, fp, #4
  101600:	e8bd8800 	pop	{fp, pc}

00101604 <rt_mb_send>:

rt_err_t rt_mb_send(rt_mailbox_t mb, rt_ubase_t value)
{
  101604:	e92d4800 	push	{fp, lr}
  101608:	e28db004 	add	fp, sp, #4
  10160c:	e24dd008 	sub	sp, sp, #8
  101610:	e50b0008 	str	r0, [fp, #-8]
  101614:	e50b100c 	str	r1, [fp, #-12]
    RT_USER_IPC_CHECK(mb, RT_Object_Class_MailBox);
  101618:	e51b3008 	ldr	r3, [fp, #-8]
  10161c:	e3530000 	cmp	r3, #0
  101620:	0a000003 	beq	101634 <rt_mb_send+0x30>
  101624:	e51b3008 	ldr	r3, [fp, #-8]
  101628:	e5933004 	ldr	r3, [r3, #4]
  10162c:	e3530000 	cmp	r3, #0
  101630:	1a000001 	bne	10163c <rt_mb_send+0x38>
  101634:	e3a03008 	mov	r3, #8
  101638:	ea00000c 	b	101670 <rt_mb_send+0x6c>
  10163c:	e51b3008 	ldr	r3, [fp, #-8]
  101640:	e5933000 	ldr	r3, [r3]
  101644:	e3530005 	cmp	r3, #5
  101648:	0a000001 	beq	101654 <rt_mb_send+0x50>
  10164c:	e3a03008 	mov	r3, #8
  101650:	ea000006 	b	101670 <rt_mb_send+0x6c>
    return syscall(_NRSYS_mb_send, mb->data, value);
  101654:	e51b3008 	ldr	r3, [fp, #-8]
  101658:	e5933004 	ldr	r3, [r3, #4]
  10165c:	e51b200c 	ldr	r2, [fp, #-12]
  101660:	e1a01003 	mov	r1, r3
  101664:	e3a00020 	mov	r0, #32
  101668:	eb00ebfb 	bl	13c65c <syscall>
  10166c:	e1a03000 	mov	r3, r0
}
  101670:	e1a00003 	mov	r0, r3
  101674:	e24bd004 	sub	sp, fp, #4
  101678:	e8bd8800 	pop	{fp, pc}

0010167c <rt_mb_recv>:

rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout)
{
  10167c:	e92d4800 	push	{fp, lr}
  101680:	e28db004 	add	fp, sp, #4
  101684:	e24dd010 	sub	sp, sp, #16
  101688:	e50b0008 	str	r0, [fp, #-8]
  10168c:	e50b100c 	str	r1, [fp, #-12]
  101690:	e50b2010 	str	r2, [fp, #-16]
    RT_USER_IPC_CHECK(mb, RT_Object_Class_MailBox);
  101694:	e51b3008 	ldr	r3, [fp, #-8]
  101698:	e3530000 	cmp	r3, #0
  10169c:	0a000003 	beq	1016b0 <rt_mb_recv+0x34>
  1016a0:	e51b3008 	ldr	r3, [fp, #-8]
  1016a4:	e5933004 	ldr	r3, [r3, #4]
  1016a8:	e3530000 	cmp	r3, #0
  1016ac:	1a000001 	bne	1016b8 <rt_mb_recv+0x3c>
  1016b0:	e3a03008 	mov	r3, #8
  1016b4:	ea00000c 	b	1016ec <rt_mb_recv+0x70>
  1016b8:	e51b3008 	ldr	r3, [fp, #-8]
  1016bc:	e5933000 	ldr	r3, [r3]
  1016c0:	e3530005 	cmp	r3, #5
  1016c4:	0a000001 	beq	1016d0 <rt_mb_recv+0x54>
  1016c8:	e3a03008 	mov	r3, #8
  1016cc:	ea000006 	b	1016ec <rt_mb_recv+0x70>
    return syscall(_NRSYS_mb_recv, mb->data, value, timeout);
  1016d0:	e51b3008 	ldr	r3, [fp, #-8]
  1016d4:	e5931004 	ldr	r1, [r3, #4]
  1016d8:	e51b3010 	ldr	r3, [fp, #-16]
  1016dc:	e51b200c 	ldr	r2, [fp, #-12]
  1016e0:	e3a00022 	mov	r0, #34	; 0x22
  1016e4:	eb00ebdc 	bl	13c65c <syscall>
  1016e8:	e1a03000 	mov	r3, r0
}
  1016ec:	e1a00003 	mov	r0, r3
  1016f0:	e24bd004 	sub	sp, fp, #4
  1016f4:	e8bd8800 	pop	{fp, pc}

001016f8 <rt_mq_create>:

rt_mq_t rt_mq_create(const char *name,
                     rt_size_t   msg_size,
                     rt_size_t   max_msgs,
                     rt_uint8_t  flag)
{
  1016f8:	e92d4800 	push	{fp, lr}
  1016fc:	e28db004 	add	fp, sp, #4
  101700:	e24dd020 	sub	sp, sp, #32
  101704:	e50b0010 	str	r0, [fp, #-16]
  101708:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10170c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  101710:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    RT_USER_IPC_CREATE(RT_Object_Class_MessageQueue, _NRSYS_mq_create, name, msg_size, max_msgs, flag);
  101714:	e3a00008 	mov	r0, #8
  101718:	eb00ef8c 	bl	13d550 <malloc>
  10171c:	e1a03000 	mov	r3, r0
  101720:	e50b3008 	str	r3, [fp, #-8]
  101724:	e51b3008 	ldr	r3, [fp, #-8]
  101728:	e3530000 	cmp	r3, #0
  10172c:	1a000001 	bne	101738 <rt_mq_create+0x40>
  101730:	e3a03000 	mov	r3, #0
  101734:	ea000017 	b	101798 <rt_mq_create+0xa0>
  101738:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
  10173c:	e58d3000 	str	r3, [sp]
  101740:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  101744:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  101748:	e51b1010 	ldr	r1, [fp, #-16]
  10174c:	e3a00023 	mov	r0, #35	; 0x23
  101750:	eb00ebc1 	bl	13c65c <syscall>
  101754:	e1a03000 	mov	r3, r0
  101758:	e1a02003 	mov	r2, r3
  10175c:	e51b3008 	ldr	r3, [fp, #-8]
  101760:	e5832004 	str	r2, [r3, #4]
  101764:	e51b3008 	ldr	r3, [fp, #-8]
  101768:	e5933004 	ldr	r3, [r3, #4]
  10176c:	e3530000 	cmp	r3, #0
  101770:	0a000003 	beq	101784 <rt_mq_create+0x8c>
  101774:	e51b3008 	ldr	r3, [fp, #-8]
  101778:	e3a02006 	mov	r2, #6
  10177c:	e5832000 	str	r2, [r3]
  101780:	ea000003 	b	101794 <rt_mq_create+0x9c>
  101784:	e51b0008 	ldr	r0, [fp, #-8]
  101788:	eb00f12c 	bl	13dc40 <free>
  10178c:	e3a03000 	mov	r3, #0
  101790:	e50b3008 	str	r3, [fp, #-8]
  101794:	e51b3008 	ldr	r3, [fp, #-8]
}
  101798:	e1a00003 	mov	r0, r3
  10179c:	e24bd004 	sub	sp, fp, #4
  1017a0:	e8bd8800 	pop	{fp, pc}

001017a4 <rt_mq_init>:
                    const char *name,
                    void       *msgpool,
                    rt_size_t   msg_size,
                    rt_size_t   pool_size,
                    rt_uint8_t  flag)
{
  1017a4:	e92d4800 	push	{fp, lr}
  1017a8:	e28db004 	add	fp, sp, #4
  1017ac:	e24dd018 	sub	sp, sp, #24
  1017b0:	e50b0008 	str	r0, [fp, #-8]
  1017b4:	e50b100c 	str	r1, [fp, #-12]
  1017b8:	e50b2010 	str	r2, [fp, #-16]
  1017bc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    RT_USER_IPC_INIT(mq, RT_Object_Class_MessageQueue, _NRSYS_mq_create, name, msg_size, pool_size/msg_size, flag);
  1017c0:	e51b3008 	ldr	r3, [fp, #-8]
  1017c4:	e3530000 	cmp	r3, #0
  1017c8:	1a000001 	bne	1017d4 <rt_mq_init+0x30>
  1017cc:	e3a03008 	mov	r3, #8
  1017d0:	ea000019 	b	10183c <rt_mq_init+0x98>
  1017d4:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1017d8:	e59b0004 	ldr	r0, [fp, #4]
  1017dc:	eb00dca4 	bl	138a74 <__udivsi3>
  1017e0:	e1a03000 	mov	r3, r0
  1017e4:	e1a02003 	mov	r2, r3
  1017e8:	e5db3008 	ldrb	r3, [fp, #8]
  1017ec:	e58d3000 	str	r3, [sp]
  1017f0:	e1a03002 	mov	r3, r2
  1017f4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  1017f8:	e51b100c 	ldr	r1, [fp, #-12]
  1017fc:	e3a00023 	mov	r0, #35	; 0x23
  101800:	eb00eb95 	bl	13c65c <syscall>
  101804:	e1a03000 	mov	r3, r0
  101808:	e1a02003 	mov	r2, r3
  10180c:	e51b3008 	ldr	r3, [fp, #-8]
  101810:	e5832004 	str	r2, [r3, #4]
  101814:	e51b3008 	ldr	r3, [fp, #-8]
  101818:	e5933004 	ldr	r3, [r3, #4]
  10181c:	e3530000 	cmp	r3, #0
  101820:	0a000004 	beq	101838 <rt_mq_init+0x94>
  101824:	e51b3008 	ldr	r3, [fp, #-8]
  101828:	e3a02006 	mov	r2, #6
  10182c:	e5832000 	str	r2, [r3]
  101830:	e3a03000 	mov	r3, #0
  101834:	ea000000 	b	10183c <rt_mq_init+0x98>
  101838:	e3a03001 	mov	r3, #1
}
  10183c:	e1a00003 	mov	r0, r3
  101840:	e24bd004 	sub	sp, fp, #4
  101844:	e8bd8800 	pop	{fp, pc}

00101848 <rt_mq_delete>:

rt_err_t rt_mq_delete(rt_mq_t mq)
{
  101848:	e92d4800 	push	{fp, lr}
  10184c:	e28db004 	add	fp, sp, #4
  101850:	e24dd010 	sub	sp, sp, #16
  101854:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DELETE(mq, RT_Object_Class_MessageQueue, _NRSYS_mq_delete);
  101858:	e51b3010 	ldr	r3, [fp, #-16]
  10185c:	e3530000 	cmp	r3, #0
  101860:	0a000003 	beq	101874 <rt_mq_delete+0x2c>
  101864:	e51b3010 	ldr	r3, [fp, #-16]
  101868:	e5933004 	ldr	r3, [r3, #4]
  10186c:	e3530000 	cmp	r3, #0
  101870:	1a000001 	bne	10187c <rt_mq_delete+0x34>
  101874:	e3a03008 	mov	r3, #8
  101878:	ea000013 	b	1018cc <rt_mq_delete+0x84>
  10187c:	e51b3010 	ldr	r3, [fp, #-16]
  101880:	e5933000 	ldr	r3, [r3]
  101884:	e3530006 	cmp	r3, #6
  101888:	0a000001 	beq	101894 <rt_mq_delete+0x4c>
  10188c:	e3a03008 	mov	r3, #8
  101890:	ea00000d 	b	1018cc <rt_mq_delete+0x84>
  101894:	e51b3010 	ldr	r3, [fp, #-16]
  101898:	e5933004 	ldr	r3, [r3, #4]
  10189c:	e1a01003 	mov	r1, r3
  1018a0:	e3a00024 	mov	r0, #36	; 0x24
  1018a4:	eb00eb6c 	bl	13c65c <syscall>
  1018a8:	e50b0008 	str	r0, [fp, #-8]
  1018ac:	e51b3008 	ldr	r3, [fp, #-8]
  1018b0:	e3530000 	cmp	r3, #0
  1018b4:	0a000001 	beq	1018c0 <rt_mq_delete+0x78>
  1018b8:	e51b3008 	ldr	r3, [fp, #-8]
  1018bc:	ea000002 	b	1018cc <rt_mq_delete+0x84>
  1018c0:	e51b0010 	ldr	r0, [fp, #-16]
  1018c4:	eb00f0dd 	bl	13dc40 <free>
  1018c8:	e3a03000 	mov	r3, #0
}
  1018cc:	e1a00003 	mov	r0, r3
  1018d0:	e24bd004 	sub	sp, fp, #4
  1018d4:	e8bd8800 	pop	{fp, pc}

001018d8 <rt_mq_detach>:

rt_err_t rt_mq_detach(rt_mq_t mq)
{
  1018d8:	e92d4800 	push	{fp, lr}
  1018dc:	e28db004 	add	fp, sp, #4
  1018e0:	e24dd010 	sub	sp, sp, #16
  1018e4:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DETACH(mq, RT_Object_Class_MessageQueue, _NRSYS_mq_delete);
  1018e8:	e51b3010 	ldr	r3, [fp, #-16]
  1018ec:	e3530000 	cmp	r3, #0
  1018f0:	0a000003 	beq	101904 <rt_mq_detach+0x2c>
  1018f4:	e51b3010 	ldr	r3, [fp, #-16]
  1018f8:	e5933004 	ldr	r3, [r3, #4]
  1018fc:	e3530000 	cmp	r3, #0
  101900:	1a000001 	bne	10190c <rt_mq_detach+0x34>
  101904:	e3a03008 	mov	r3, #8
  101908:	ea000017 	b	10196c <rt_mq_detach+0x94>
  10190c:	e51b3010 	ldr	r3, [fp, #-16]
  101910:	e5933000 	ldr	r3, [r3]
  101914:	e3530006 	cmp	r3, #6
  101918:	0a000001 	beq	101924 <rt_mq_detach+0x4c>
  10191c:	e3a03008 	mov	r3, #8
  101920:	ea000011 	b	10196c <rt_mq_detach+0x94>
  101924:	e51b3010 	ldr	r3, [fp, #-16]
  101928:	e5933004 	ldr	r3, [r3, #4]
  10192c:	e1a01003 	mov	r1, r3
  101930:	e3a00024 	mov	r0, #36	; 0x24
  101934:	eb00eb48 	bl	13c65c <syscall>
  101938:	e50b0008 	str	r0, [fp, #-8]
  10193c:	e51b3008 	ldr	r3, [fp, #-8]
  101940:	e3530000 	cmp	r3, #0
  101944:	0a000001 	beq	101950 <rt_mq_detach+0x78>
  101948:	e51b3008 	ldr	r3, [fp, #-8]
  10194c:	ea000006 	b	10196c <rt_mq_detach+0x94>
  101950:	e51b3010 	ldr	r3, [fp, #-16]
  101954:	e3a02000 	mov	r2, #0
  101958:	e5832000 	str	r2, [r3]
  10195c:	e51b3010 	ldr	r3, [fp, #-16]
  101960:	e3a02000 	mov	r2, #0
  101964:	e5832004 	str	r2, [r3, #4]
  101968:	e3a03000 	mov	r3, #0
}
  10196c:	e1a00003 	mov	r0, r3
  101970:	e24bd004 	sub	sp, fp, #4
  101974:	e8bd8800 	pop	{fp, pc}

00101978 <rt_mq_send>:

rt_err_t rt_mq_send(rt_mq_t mq, const void *buffer, rt_size_t size)
{
  101978:	e92d4800 	push	{fp, lr}
  10197c:	e28db004 	add	fp, sp, #4
  101980:	e24dd010 	sub	sp, sp, #16
  101984:	e50b0008 	str	r0, [fp, #-8]
  101988:	e50b100c 	str	r1, [fp, #-12]
  10198c:	e50b2010 	str	r2, [fp, #-16]
    RT_USER_IPC_CHECK(mq, RT_Object_Class_MessageQueue);
  101990:	e51b3008 	ldr	r3, [fp, #-8]
  101994:	e3530000 	cmp	r3, #0
  101998:	0a000003 	beq	1019ac <rt_mq_send+0x34>
  10199c:	e51b3008 	ldr	r3, [fp, #-8]
  1019a0:	e5933004 	ldr	r3, [r3, #4]
  1019a4:	e3530000 	cmp	r3, #0
  1019a8:	1a000001 	bne	1019b4 <rt_mq_send+0x3c>
  1019ac:	e3a03008 	mov	r3, #8
  1019b0:	ea00000c 	b	1019e8 <rt_mq_send+0x70>
  1019b4:	e51b3008 	ldr	r3, [fp, #-8]
  1019b8:	e5933000 	ldr	r3, [r3]
  1019bc:	e3530006 	cmp	r3, #6
  1019c0:	0a000001 	beq	1019cc <rt_mq_send+0x54>
  1019c4:	e3a03008 	mov	r3, #8
  1019c8:	ea000006 	b	1019e8 <rt_mq_send+0x70>
    return syscall(_NRSYS_mq_send, mq->data, buffer, size);
  1019cc:	e51b3008 	ldr	r3, [fp, #-8]
  1019d0:	e5931004 	ldr	r1, [r3, #4]
  1019d4:	e51b3010 	ldr	r3, [fp, #-16]
  1019d8:	e51b200c 	ldr	r2, [fp, #-12]
  1019dc:	e3a00025 	mov	r0, #37	; 0x25
  1019e0:	eb00eb1d 	bl	13c65c <syscall>
  1019e4:	e1a03000 	mov	r3, r0
}
  1019e8:	e1a00003 	mov	r0, r3
  1019ec:	e24bd004 	sub	sp, fp, #4
  1019f0:	e8bd8800 	pop	{fp, pc}

001019f4 <rt_mq_urgent>:

rt_err_t rt_mq_urgent(rt_mq_t mq, const void *buffer, rt_size_t size)
{
  1019f4:	e92d4800 	push	{fp, lr}
  1019f8:	e28db004 	add	fp, sp, #4
  1019fc:	e24dd010 	sub	sp, sp, #16
  101a00:	e50b0008 	str	r0, [fp, #-8]
  101a04:	e50b100c 	str	r1, [fp, #-12]
  101a08:	e50b2010 	str	r2, [fp, #-16]
    RT_USER_IPC_CHECK(mq, RT_Object_Class_MessageQueue);
  101a0c:	e51b3008 	ldr	r3, [fp, #-8]
  101a10:	e3530000 	cmp	r3, #0
  101a14:	0a000003 	beq	101a28 <rt_mq_urgent+0x34>
  101a18:	e51b3008 	ldr	r3, [fp, #-8]
  101a1c:	e5933004 	ldr	r3, [r3, #4]
  101a20:	e3530000 	cmp	r3, #0
  101a24:	1a000001 	bne	101a30 <rt_mq_urgent+0x3c>
  101a28:	e3a03008 	mov	r3, #8
  101a2c:	ea00000c 	b	101a64 <rt_mq_urgent+0x70>
  101a30:	e51b3008 	ldr	r3, [fp, #-8]
  101a34:	e5933000 	ldr	r3, [r3]
  101a38:	e3530006 	cmp	r3, #6
  101a3c:	0a000001 	beq	101a48 <rt_mq_urgent+0x54>
  101a40:	e3a03008 	mov	r3, #8
  101a44:	ea000006 	b	101a64 <rt_mq_urgent+0x70>
    return syscall(_NRSYS_mq_urgent, mq->data, buffer, size);
  101a48:	e51b3008 	ldr	r3, [fp, #-8]
  101a4c:	e5931004 	ldr	r1, [r3, #4]
  101a50:	e51b3010 	ldr	r3, [fp, #-16]
  101a54:	e51b200c 	ldr	r2, [fp, #-12]
  101a58:	e3a00026 	mov	r0, #38	; 0x26
  101a5c:	eb00eafe 	bl	13c65c <syscall>
  101a60:	e1a03000 	mov	r3, r0
}
  101a64:	e1a00003 	mov	r0, r3
  101a68:	e24bd004 	sub	sp, fp, #4
  101a6c:	e8bd8800 	pop	{fp, pc}

00101a70 <rt_mq_recv>:

rt_err_t rt_mq_recv(rt_mq_t    mq,
                    void      *buffer,
                    rt_size_t  size,
                    rt_int32_t timeout)
{
  101a70:	e92d4800 	push	{fp, lr}
  101a74:	e28db004 	add	fp, sp, #4
  101a78:	e24dd018 	sub	sp, sp, #24
  101a7c:	e50b0008 	str	r0, [fp, #-8]
  101a80:	e50b100c 	str	r1, [fp, #-12]
  101a84:	e50b2010 	str	r2, [fp, #-16]
  101a88:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    RT_USER_IPC_CHECK(mq, RT_Object_Class_MessageQueue);
  101a8c:	e51b3008 	ldr	r3, [fp, #-8]
  101a90:	e3530000 	cmp	r3, #0
  101a94:	0a000003 	beq	101aa8 <rt_mq_recv+0x38>
  101a98:	e51b3008 	ldr	r3, [fp, #-8]
  101a9c:	e5933004 	ldr	r3, [r3, #4]
  101aa0:	e3530000 	cmp	r3, #0
  101aa4:	1a000001 	bne	101ab0 <rt_mq_recv+0x40>
  101aa8:	e3a03008 	mov	r3, #8
  101aac:	ea00000e 	b	101aec <rt_mq_recv+0x7c>
  101ab0:	e51b3008 	ldr	r3, [fp, #-8]
  101ab4:	e5933000 	ldr	r3, [r3]
  101ab8:	e3530006 	cmp	r3, #6
  101abc:	0a000001 	beq	101ac8 <rt_mq_recv+0x58>
  101ac0:	e3a03008 	mov	r3, #8
  101ac4:	ea000008 	b	101aec <rt_mq_recv+0x7c>
    return syscall(_NRSYS_mq_recv, mq->data, buffer, size, timeout);
  101ac8:	e51b3008 	ldr	r3, [fp, #-8]
  101acc:	e5931004 	ldr	r1, [r3, #4]
  101ad0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  101ad4:	e58d3000 	str	r3, [sp]
  101ad8:	e51b3010 	ldr	r3, [fp, #-16]
  101adc:	e51b200c 	ldr	r2, [fp, #-12]
  101ae0:	e3a00027 	mov	r0, #39	; 0x27
  101ae4:	eb00eadc 	bl	13c65c <syscall>
  101ae8:	e1a03000 	mov	r3, r0
}
  101aec:	e1a00003 	mov	r0, r3
  101af0:	e24bd004 	sub	sp, fp, #4
  101af4:	e8bd8800 	pop	{fp, pc}

00101af8 <rt_event_create>:

rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
{
  101af8:	e92d4800 	push	{fp, lr}
  101afc:	e28db004 	add	fp, sp, #4
  101b00:	e24dd010 	sub	sp, sp, #16
  101b04:	e50b0010 	str	r0, [fp, #-16]
  101b08:	e1a03001 	mov	r3, r1
  101b0c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    RT_USER_IPC_CREATE(RT_Object_Class_Event, _NRSYS_event_create, name, flag);
  101b10:	e3a00008 	mov	r0, #8
  101b14:	eb00ee8d 	bl	13d550 <malloc>
  101b18:	e1a03000 	mov	r3, r0
  101b1c:	e50b3008 	str	r3, [fp, #-8]
  101b20:	e51b3008 	ldr	r3, [fp, #-8]
  101b24:	e3530000 	cmp	r3, #0
  101b28:	1a000001 	bne	101b34 <rt_event_create+0x3c>
  101b2c:	e3a03000 	mov	r3, #0
  101b30:	ea000015 	b	101b8c <rt_event_create+0x94>
  101b34:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  101b38:	e1a02003 	mov	r2, r3
  101b3c:	e51b1010 	ldr	r1, [fp, #-16]
  101b40:	e3a0001a 	mov	r0, #26
  101b44:	eb00eac4 	bl	13c65c <syscall>
  101b48:	e1a03000 	mov	r3, r0
  101b4c:	e1a02003 	mov	r2, r3
  101b50:	e51b3008 	ldr	r3, [fp, #-8]
  101b54:	e5832004 	str	r2, [r3, #4]
  101b58:	e51b3008 	ldr	r3, [fp, #-8]
  101b5c:	e5933004 	ldr	r3, [r3, #4]
  101b60:	e3530000 	cmp	r3, #0
  101b64:	0a000003 	beq	101b78 <rt_event_create+0x80>
  101b68:	e51b3008 	ldr	r3, [fp, #-8]
  101b6c:	e3a02004 	mov	r2, #4
  101b70:	e5832000 	str	r2, [r3]
  101b74:	ea000003 	b	101b88 <rt_event_create+0x90>
  101b78:	e51b0008 	ldr	r0, [fp, #-8]
  101b7c:	eb00f02f 	bl	13dc40 <free>
  101b80:	e3a03000 	mov	r3, #0
  101b84:	e50b3008 	str	r3, [fp, #-8]
  101b88:	e51b3008 	ldr	r3, [fp, #-8]
}
  101b8c:	e1a00003 	mov	r0, r3
  101b90:	e24bd004 	sub	sp, fp, #4
  101b94:	e8bd8800 	pop	{fp, pc}

00101b98 <rt_event_init>:

rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
{
  101b98:	e92d4800 	push	{fp, lr}
  101b9c:	e28db004 	add	fp, sp, #4
  101ba0:	e24dd010 	sub	sp, sp, #16
  101ba4:	e50b0008 	str	r0, [fp, #-8]
  101ba8:	e50b100c 	str	r1, [fp, #-12]
  101bac:	e1a03002 	mov	r3, r2
  101bb0:	e54b300d 	strb	r3, [fp, #-13]
    RT_USER_IPC_INIT(event, RT_Object_Class_Event, _NRSYS_event_create, name, flag);
  101bb4:	e51b3008 	ldr	r3, [fp, #-8]
  101bb8:	e3530000 	cmp	r3, #0
  101bbc:	1a000001 	bne	101bc8 <rt_event_init+0x30>
  101bc0:	e3a03008 	mov	r3, #8
  101bc4:	ea000012 	b	101c14 <rt_event_init+0x7c>
  101bc8:	e55b300d 	ldrb	r3, [fp, #-13]
  101bcc:	e1a02003 	mov	r2, r3
  101bd0:	e51b100c 	ldr	r1, [fp, #-12]
  101bd4:	e3a0001a 	mov	r0, #26
  101bd8:	eb00ea9f 	bl	13c65c <syscall>
  101bdc:	e1a03000 	mov	r3, r0
  101be0:	e1a02003 	mov	r2, r3
  101be4:	e51b3008 	ldr	r3, [fp, #-8]
  101be8:	e5832004 	str	r2, [r3, #4]
  101bec:	e51b3008 	ldr	r3, [fp, #-8]
  101bf0:	e5933004 	ldr	r3, [r3, #4]
  101bf4:	e3530000 	cmp	r3, #0
  101bf8:	0a000004 	beq	101c10 <rt_event_init+0x78>
  101bfc:	e51b3008 	ldr	r3, [fp, #-8]
  101c00:	e3a02004 	mov	r2, #4
  101c04:	e5832000 	str	r2, [r3]
  101c08:	e3a03000 	mov	r3, #0
  101c0c:	ea000000 	b	101c14 <rt_event_init+0x7c>
  101c10:	e3a03001 	mov	r3, #1
}
  101c14:	e1a00003 	mov	r0, r3
  101c18:	e24bd004 	sub	sp, fp, #4
  101c1c:	e8bd8800 	pop	{fp, pc}

00101c20 <rt_event_delete>:

rt_err_t rt_event_delete(rt_event_t event)
{
  101c20:	e92d4800 	push	{fp, lr}
  101c24:	e28db004 	add	fp, sp, #4
  101c28:	e24dd010 	sub	sp, sp, #16
  101c2c:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DELETE(event, RT_Object_Class_Event, _NRSYS_event_delete);
  101c30:	e51b3010 	ldr	r3, [fp, #-16]
  101c34:	e3530000 	cmp	r3, #0
  101c38:	0a000003 	beq	101c4c <rt_event_delete+0x2c>
  101c3c:	e51b3010 	ldr	r3, [fp, #-16]
  101c40:	e5933004 	ldr	r3, [r3, #4]
  101c44:	e3530000 	cmp	r3, #0
  101c48:	1a000001 	bne	101c54 <rt_event_delete+0x34>
  101c4c:	e3a03008 	mov	r3, #8
  101c50:	ea000013 	b	101ca4 <rt_event_delete+0x84>
  101c54:	e51b3010 	ldr	r3, [fp, #-16]
  101c58:	e5933000 	ldr	r3, [r3]
  101c5c:	e3530004 	cmp	r3, #4
  101c60:	0a000001 	beq	101c6c <rt_event_delete+0x4c>
  101c64:	e3a03008 	mov	r3, #8
  101c68:	ea00000d 	b	101ca4 <rt_event_delete+0x84>
  101c6c:	e51b3010 	ldr	r3, [fp, #-16]
  101c70:	e5933004 	ldr	r3, [r3, #4]
  101c74:	e1a01003 	mov	r1, r3
  101c78:	e3a0001b 	mov	r0, #27
  101c7c:	eb00ea76 	bl	13c65c <syscall>
  101c80:	e50b0008 	str	r0, [fp, #-8]
  101c84:	e51b3008 	ldr	r3, [fp, #-8]
  101c88:	e3530000 	cmp	r3, #0
  101c8c:	0a000001 	beq	101c98 <rt_event_delete+0x78>
  101c90:	e51b3008 	ldr	r3, [fp, #-8]
  101c94:	ea000002 	b	101ca4 <rt_event_delete+0x84>
  101c98:	e51b0010 	ldr	r0, [fp, #-16]
  101c9c:	eb00efe7 	bl	13dc40 <free>
  101ca0:	e3a03000 	mov	r3, #0
}
  101ca4:	e1a00003 	mov	r0, r3
  101ca8:	e24bd004 	sub	sp, fp, #4
  101cac:	e8bd8800 	pop	{fp, pc}

00101cb0 <rt_event_detach>:

rt_err_t rt_event_detach(rt_event_t event)
{
  101cb0:	e92d4800 	push	{fp, lr}
  101cb4:	e28db004 	add	fp, sp, #4
  101cb8:	e24dd010 	sub	sp, sp, #16
  101cbc:	e50b0010 	str	r0, [fp, #-16]
    RT_USER_IPC_DETACH(event, RT_Object_Class_Event, _NRSYS_event_delete);
  101cc0:	e51b3010 	ldr	r3, [fp, #-16]
  101cc4:	e3530000 	cmp	r3, #0
  101cc8:	0a000003 	beq	101cdc <rt_event_detach+0x2c>
  101ccc:	e51b3010 	ldr	r3, [fp, #-16]
  101cd0:	e5933004 	ldr	r3, [r3, #4]
  101cd4:	e3530000 	cmp	r3, #0
  101cd8:	1a000001 	bne	101ce4 <rt_event_detach+0x34>
  101cdc:	e3a03008 	mov	r3, #8
  101ce0:	ea000017 	b	101d44 <rt_event_detach+0x94>
  101ce4:	e51b3010 	ldr	r3, [fp, #-16]
  101ce8:	e5933000 	ldr	r3, [r3]
  101cec:	e3530004 	cmp	r3, #4
  101cf0:	0a000001 	beq	101cfc <rt_event_detach+0x4c>
  101cf4:	e3a03008 	mov	r3, #8
  101cf8:	ea000011 	b	101d44 <rt_event_detach+0x94>
  101cfc:	e51b3010 	ldr	r3, [fp, #-16]
  101d00:	e5933004 	ldr	r3, [r3, #4]
  101d04:	e1a01003 	mov	r1, r3
  101d08:	e3a0001b 	mov	r0, #27
  101d0c:	eb00ea52 	bl	13c65c <syscall>
  101d10:	e50b0008 	str	r0, [fp, #-8]
  101d14:	e51b3008 	ldr	r3, [fp, #-8]
  101d18:	e3530000 	cmp	r3, #0
  101d1c:	0a000001 	beq	101d28 <rt_event_detach+0x78>
  101d20:	e51b3008 	ldr	r3, [fp, #-8]
  101d24:	ea000006 	b	101d44 <rt_event_detach+0x94>
  101d28:	e51b3010 	ldr	r3, [fp, #-16]
  101d2c:	e3a02000 	mov	r2, #0
  101d30:	e5832000 	str	r2, [r3]
  101d34:	e51b3010 	ldr	r3, [fp, #-16]
  101d38:	e3a02000 	mov	r2, #0
  101d3c:	e5832004 	str	r2, [r3, #4]
  101d40:	e3a03000 	mov	r3, #0
}
  101d44:	e1a00003 	mov	r0, r3
  101d48:	e24bd004 	sub	sp, fp, #4
  101d4c:	e8bd8800 	pop	{fp, pc}

00101d50 <rt_event_send>:

rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
{
  101d50:	e92d4800 	push	{fp, lr}
  101d54:	e28db004 	add	fp, sp, #4
  101d58:	e24dd008 	sub	sp, sp, #8
  101d5c:	e50b0008 	str	r0, [fp, #-8]
  101d60:	e50b100c 	str	r1, [fp, #-12]
    RT_USER_IPC_CHECK(event, RT_Object_Class_Event);
  101d64:	e51b3008 	ldr	r3, [fp, #-8]
  101d68:	e3530000 	cmp	r3, #0
  101d6c:	0a000003 	beq	101d80 <rt_event_send+0x30>
  101d70:	e51b3008 	ldr	r3, [fp, #-8]
  101d74:	e5933004 	ldr	r3, [r3, #4]
  101d78:	e3530000 	cmp	r3, #0
  101d7c:	1a000001 	bne	101d88 <rt_event_send+0x38>
  101d80:	e3a03008 	mov	r3, #8
  101d84:	ea00000c 	b	101dbc <rt_event_send+0x6c>
  101d88:	e51b3008 	ldr	r3, [fp, #-8]
  101d8c:	e5933000 	ldr	r3, [r3]
  101d90:	e3530004 	cmp	r3, #4
  101d94:	0a000001 	beq	101da0 <rt_event_send+0x50>
  101d98:	e3a03008 	mov	r3, #8
  101d9c:	ea000006 	b	101dbc <rt_event_send+0x6c>
    return syscall(_NRSYS_event_send, event->data, set);
  101da0:	e51b3008 	ldr	r3, [fp, #-8]
  101da4:	e5933004 	ldr	r3, [r3, #4]
  101da8:	e51b200c 	ldr	r2, [fp, #-12]
  101dac:	e1a01003 	mov	r1, r3
  101db0:	e3a0001c 	mov	r0, #28
  101db4:	eb00ea28 	bl	13c65c <syscall>
  101db8:	e1a03000 	mov	r3, r0
}
  101dbc:	e1a00003 	mov	r0, r3
  101dc0:	e24bd004 	sub	sp, fp, #4
  101dc4:	e8bd8800 	pop	{fp, pc}

00101dc8 <rt_event_recv>:
rt_err_t rt_event_recv(rt_event_t   event,
                       rt_uint32_t  set,
                       rt_uint8_t   opt,
                       rt_int32_t   timeout,
                       rt_uint32_t *recved)
{
  101dc8:	e92d4800 	push	{fp, lr}
  101dcc:	e28db004 	add	fp, sp, #4
  101dd0:	e24dd018 	sub	sp, sp, #24
  101dd4:	e50b0008 	str	r0, [fp, #-8]
  101dd8:	e50b100c 	str	r1, [fp, #-12]
  101ddc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  101de0:	e1a03002 	mov	r3, r2
  101de4:	e54b300d 	strb	r3, [fp, #-13]
    RT_USER_IPC_CHECK(event, RT_Object_Class_Event);
  101de8:	e51b3008 	ldr	r3, [fp, #-8]
  101dec:	e3530000 	cmp	r3, #0
  101df0:	0a000003 	beq	101e04 <rt_event_recv+0x3c>
  101df4:	e51b3008 	ldr	r3, [fp, #-8]
  101df8:	e5933004 	ldr	r3, [r3, #4]
  101dfc:	e3530000 	cmp	r3, #0
  101e00:	1a000001 	bne	101e0c <rt_event_recv+0x44>
  101e04:	e3a03008 	mov	r3, #8
  101e08:	ea000011 	b	101e54 <rt_event_recv+0x8c>
  101e0c:	e51b3008 	ldr	r3, [fp, #-8]
  101e10:	e5933000 	ldr	r3, [r3]
  101e14:	e3530004 	cmp	r3, #4
  101e18:	0a000001 	beq	101e24 <rt_event_recv+0x5c>
  101e1c:	e3a03008 	mov	r3, #8
  101e20:	ea00000b 	b	101e54 <rt_event_recv+0x8c>
    return syscall(_NRSYS_event_recv, event->data, set, opt, timeout, recved);
  101e24:	e51b3008 	ldr	r3, [fp, #-8]
  101e28:	e5931004 	ldr	r1, [r3, #4]
  101e2c:	e55b200d 	ldrb	r2, [fp, #-13]
  101e30:	e59b3004 	ldr	r3, [fp, #4]
  101e34:	e58d3004 	str	r3, [sp, #4]
  101e38:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  101e3c:	e58d3000 	str	r3, [sp]
  101e40:	e1a03002 	mov	r3, r2
  101e44:	e51b200c 	ldr	r2, [fp, #-12]
  101e48:	e3a0001d 	mov	r0, #29
  101e4c:	eb00ea02 	bl	13c65c <syscall>
  101e50:	e1a03000 	mov	r3, r0
}
  101e54:	e1a00003 	mov	r0, r3
  101e58:	e24bd004 	sub	sp, fp, #4
  101e5c:	e8bd8800 	pop	{fp, pc}

00101e60 <rt_tick_get>:

rt_tick_t rt_tick_get(void)
{
  101e60:	e92d4800 	push	{fp, lr}
  101e64:	e28db004 	add	fp, sp, #4
    return (rt_tick_t)syscall(_NRSYS_rt_tick_get);
  101e68:	e3a00061 	mov	r0, #97	; 0x61
  101e6c:	eb00e9fa 	bl	13c65c <syscall>
  101e70:	e1a03000 	mov	r3, r0
}
  101e74:	e1a00003 	mov	r0, r3
  101e78:	e8bd8800 	pop	{fp, pc}

00101e7c <rt_thread_mdelay>:

rt_err_t rt_thread_mdelay(rt_int32_t ms)
{
  101e7c:	e92d4800 	push	{fp, lr}
  101e80:	e28db004 	add	fp, sp, #4
  101e84:	e24dd008 	sub	sp, sp, #8
  101e88:	e50b0008 	str	r0, [fp, #-8]
    return (rt_err_t)syscall(_NRSYS_rt_thread_mdelay, ms);
  101e8c:	e51b1008 	ldr	r1, [fp, #-8]
  101e90:	e3a00066 	mov	r0, #102	; 0x66
  101e94:	eb00e9f0 	bl	13c65c <syscall>
  101e98:	e1a03000 	mov	r3, r0
}
  101e9c:	e1a00003 	mov	r0, r3
  101ea0:	e24bd004 	sub	sp, fp, #4
  101ea4:	e8bd8800 	pop	{fp, pc}

00101ea8 <lwp_shmget>:

int lwp_shmget(size_t key, size_t size, int create)
{
  101ea8:	e92d4800 	push	{fp, lr}
  101eac:	e28db004 	add	fp, sp, #4
  101eb0:	e24dd010 	sub	sp, sp, #16
  101eb4:	e50b0008 	str	r0, [fp, #-8]
  101eb8:	e50b100c 	str	r1, [fp, #-12]
  101ebc:	e50b2010 	str	r2, [fp, #-16]
    return (int)syscall(_NRSYS_shmget, key, size, create);
  101ec0:	e51b3010 	ldr	r3, [fp, #-16]
  101ec4:	e51b200c 	ldr	r2, [fp, #-12]
  101ec8:	e51b1008 	ldr	r1, [fp, #-8]
  101ecc:	e3a00037 	mov	r0, #55	; 0x37
  101ed0:	eb00e9e1 	bl	13c65c <syscall>
  101ed4:	e1a03000 	mov	r3, r0
}
  101ed8:	e1a00003 	mov	r0, r3
  101edc:	e24bd004 	sub	sp, fp, #4
  101ee0:	e8bd8800 	pop	{fp, pc}

00101ee4 <lwp_shmrm>:

int lwp_shmrm(int id)
{
  101ee4:	e92d4800 	push	{fp, lr}
  101ee8:	e28db004 	add	fp, sp, #4
  101eec:	e24dd008 	sub	sp, sp, #8
  101ef0:	e50b0008 	str	r0, [fp, #-8]
    return (int)syscall(_NRSYS_shmrm, id);
  101ef4:	e51b1008 	ldr	r1, [fp, #-8]
  101ef8:	e3a00038 	mov	r0, #56	; 0x38
  101efc:	eb00e9d6 	bl	13c65c <syscall>
  101f00:	e1a03000 	mov	r3, r0
}
  101f04:	e1a00003 	mov	r0, r3
  101f08:	e24bd004 	sub	sp, fp, #4
  101f0c:	e8bd8800 	pop	{fp, pc}

00101f10 <lwp_shmat>:

void* lwp_shmat(int id, void* shm_vaddr)
{
  101f10:	e92d4800 	push	{fp, lr}
  101f14:	e28db004 	add	fp, sp, #4
  101f18:	e24dd008 	sub	sp, sp, #8
  101f1c:	e50b0008 	str	r0, [fp, #-8]
  101f20:	e50b100c 	str	r1, [fp, #-12]
    return (void*)syscall(_NRSYS_shmat, id, shm_vaddr);
  101f24:	e51b200c 	ldr	r2, [fp, #-12]
  101f28:	e51b1008 	ldr	r1, [fp, #-8]
  101f2c:	e3a00039 	mov	r0, #57	; 0x39
  101f30:	eb00e9c9 	bl	13c65c <syscall>
  101f34:	e1a03000 	mov	r3, r0
}
  101f38:	e1a00003 	mov	r0, r3
  101f3c:	e24bd004 	sub	sp, fp, #4
  101f40:	e8bd8800 	pop	{fp, pc}

00101f44 <lwp_shmdt>:

int lwp_shmdt(void* shm_vaddr)
{
  101f44:	e92d4800 	push	{fp, lr}
  101f48:	e28db004 	add	fp, sp, #4
  101f4c:	e24dd008 	sub	sp, sp, #8
  101f50:	e50b0008 	str	r0, [fp, #-8]
    return (int)syscall(_NRSYS_shmdt, shm_vaddr);
  101f54:	e51b1008 	ldr	r1, [fp, #-8]
  101f58:	e3a0003a 	mov	r0, #58	; 0x3a
  101f5c:	eb00e9be 	bl	13c65c <syscall>
  101f60:	e1a03000 	mov	r3, r0
}
  101f64:	e1a00003 	mov	r0, r3
  101f68:	e24bd004 	sub	sp, fp, #4
  101f6c:	e8bd8800 	pop	{fp, pc}

00101f70 <exec>:

int exec(char *filename, int argc, char **argv, char **envp)
{
  101f70:	e92d4800 	push	{fp, lr}
  101f74:	e28db004 	add	fp, sp, #4
  101f78:	e24dd018 	sub	sp, sp, #24
  101f7c:	e50b0008 	str	r0, [fp, #-8]
  101f80:	e50b100c 	str	r1, [fp, #-12]
  101f84:	e50b2010 	str	r2, [fp, #-16]
  101f88:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return (int)syscall(_NRSYS_exec, filename, argc, argv, envp);
  101f8c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  101f90:	e58d3000 	str	r3, [sp]
  101f94:	e51b3010 	ldr	r3, [fp, #-16]
  101f98:	e51b200c 	ldr	r2, [fp, #-12]
  101f9c:	e51b1008 	ldr	r1, [fp, #-8]
  101fa0:	e3a0000d 	mov	r0, #13
  101fa4:	eb00e9ac 	bl	13c65c <syscall>
  101fa8:	e1a03000 	mov	r3, r0
}
  101fac:	e1a00003 	mov	r0, r3
  101fb0:	e24bd004 	sub	sp, fp, #4
  101fb4:	e8bd8800 	pop	{fp, pc}

00101fb8 <lwp_kill>:

int lwp_kill(pid_t pid, int sig)
{
  101fb8:	e92d4800 	push	{fp, lr}
  101fbc:	e28db004 	add	fp, sp, #4
  101fc0:	e24dd008 	sub	sp, sp, #8
  101fc4:	e50b0008 	str	r0, [fp, #-8]
  101fc8:	e50b100c 	str	r1, [fp, #-12]
    return (int)syscall(_NRSYS_kill, pid, sig);
  101fcc:	e51b200c 	ldr	r2, [fp, #-12]
  101fd0:	e51b1008 	ldr	r1, [fp, #-8]
  101fd4:	e3a0000e 	mov	r0, #14
  101fd8:	eb00e99f 	bl	13c65c <syscall>
  101fdc:	e1a03000 	mov	r3, r0
}
  101fe0:	e1a00003 	mov	r0, r3
  101fe4:	e24bd004 	sub	sp, fp, #4
  101fe8:	e8bd8800 	pop	{fp, pc}

00101fec <lwp_tkill>:

int lwp_tkill(int tid, int sig)
{
  101fec:	e92d4800 	push	{fp, lr}
  101ff0:	e28db004 	add	fp, sp, #4
  101ff4:	e24dd008 	sub	sp, sp, #8
  101ff8:	e50b0008 	str	r0, [fp, #-8]
  101ffc:	e50b100c 	str	r1, [fp, #-12]
    return (int)syscall(_NRSYS_tkill, tid, sig);
  102000:	e51b200c 	ldr	r2, [fp, #-12]
  102004:	e51b1008 	ldr	r1, [fp, #-8]
  102008:	e3a00069 	mov	r0, #105	; 0x69
  10200c:	eb00e992 	bl	13c65c <syscall>
  102010:	e1a03000 	mov	r3, r0
}
  102014:	e1a00003 	mov	r0, r3
  102018:	e24bd004 	sub	sp, fp, #4
  10201c:	e8bd8800 	pop	{fp, pc}

00102020 <waitpid>:

pid_t waitpid(pid_t pid, int *status, int options)
{
  102020:	e92d4800 	push	{fp, lr}
  102024:	e28db004 	add	fp, sp, #4
  102028:	e24dd010 	sub	sp, sp, #16
  10202c:	e50b0008 	str	r0, [fp, #-8]
  102030:	e50b100c 	str	r1, [fp, #-12]
  102034:	e50b2010 	str	r2, [fp, #-16]
    return (int)syscall(_NRSYS_waitpid, pid, status, options);
  102038:	e51b3010 	ldr	r3, [fp, #-16]
  10203c:	e51b200c 	ldr	r2, [fp, #-12]
  102040:	e51b1008 	ldr	r1, [fp, #-8]
  102044:	e3a0006e 	mov	r0, #110	; 0x6e
  102048:	eb00e983 	bl	13c65c <syscall>
  10204c:	e1a03000 	mov	r3, r0
}
  102050:	e1a00003 	mov	r0, r3
  102054:	e24bd004 	sub	sp, fp, #4
  102058:	e8bd8800 	pop	{fp, pc}

0010205c <rt_get_errno>:

rt_err_t rt_get_errno(void)
{
  10205c:	e92d4800 	push	{fp, lr}
  102060:	e28db004 	add	fp, sp, #4
    return (rt_err_t)syscall(_NRSYS_rt_get_errno);
  102064:	e3a0007a 	mov	r0, #122	; 0x7a
  102068:	eb00e97b 	bl	13c65c <syscall>
  10206c:	e1a03000 	mov	r3, r0
}
  102070:	e1a00003 	mov	r0, r3
  102074:	e8bd8800 	pop	{fp, pc}

00102078 <rt_thread_find>:
#include <pthread.h>

void __pthread_init_run(void (*enter)(void *parameter), void *parameter);

rt_thread_t rt_thread_find(char *name)
{
  102078:	e92d4800 	push	{fp, lr}
  10207c:	e28db004 	add	fp, sp, #4
  102080:	e24dd008 	sub	sp, sp, #8
  102084:	e50b0008 	str	r0, [fp, #-8]
    return (rt_thread_t)syscall(_NRSYS_rt_thread_find, name);
  102088:	e51b1008 	ldr	r1, [fp, #-8]
  10208c:	e3a00044 	mov	r0, #68	; 0x44
  102090:	eb00e971 	bl	13c65c <syscall>
  102094:	e1a03000 	mov	r3, r0
}
  102098:	e1a00003 	mov	r0, r3
  10209c:	e24bd004 	sub	sp, fp, #4
  1020a0:	e8bd8800 	pop	{fp, pc}

001020a4 <rt_thread_user_entry>:
    void (*entry)(void *parameter);
    void *parameter;
};

static void rt_thread_user_entry(void *arg)
{
  1020a4:	e92d4800 	push	{fp, lr}
  1020a8:	e28db004 	add	fp, sp, #4
  1020ac:	e24dd018 	sub	sp, sp, #24
  1020b0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    struct rt_thread_startup_ucontext *ucontext;
    void (*entry)(void *parameter);
    void *parameter;

    ucontext = (struct rt_thread_startup_ucontext *)arg;
  1020b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1020b8:	e50b3008 	str	r3, [fp, #-8]
    entry = ucontext->entry;
  1020bc:	e51b3008 	ldr	r3, [fp, #-8]
  1020c0:	e5933000 	ldr	r3, [r3]
  1020c4:	e50b300c 	str	r3, [fp, #-12]
    parameter = ucontext->parameter;
  1020c8:	e51b3008 	ldr	r3, [fp, #-8]
  1020cc:	e5933004 	ldr	r3, [r3, #4]
  1020d0:	e50b3010 	str	r3, [fp, #-16]
    rt_free(ucontext);
  1020d4:	e51b0008 	ldr	r0, [fp, #-8]
  1020d8:	eb0003b7 	bl	102fbc <rt_free>

    __pthread_init_run(entry, parameter);
  1020dc:	e51b1010 	ldr	r1, [fp, #-16]
  1020e0:	e51b000c 	ldr	r0, [fp, #-12]
  1020e4:	eb010338 	bl	142dcc <__pthread_init_run>
}
  1020e8:	e320f000 	nop	{0}
  1020ec:	e24bd004 	sub	sp, fp, #4
  1020f0:	e8bd8800 	pop	{fp, pc}

001020f4 <rt_thread_create>:
        void (*entry)(void *parameter),
        void       *parameter,
        rt_uint32_t stack_size,
        rt_uint8_t  priority,
        rt_uint32_t tick)
{
  1020f4:	e92d4800 	push	{fp, lr}
  1020f8:	e28db004 	add	fp, sp, #4
  1020fc:	e24dd030 	sub	sp, sp, #48	; 0x30
  102100:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  102104:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  102108:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  10210c:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
    rt_thread_t thread;
    void * arg[] = {(void *)name, (void*)entry, (void*)parameter, (void*)(size_t)stack_size, (void*)(size_t)priority, (void*)(size_t)tick};
  102110:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  102114:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  102118:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10211c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  102120:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  102124:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  102128:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  10212c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  102130:	e5db3004 	ldrb	r3, [fp, #4]
  102134:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  102138:	e59b3008 	ldr	r3, [fp, #8]
  10213c:	e50b3010 	str	r3, [fp, #-16]
    struct rt_thread_startup_ucontext *ucontext;

    ucontext = rt_malloc(sizeof *ucontext);
  102140:	e3a00008 	mov	r0, #8
  102144:	eb000392 	bl	102f94 <rt_malloc>
  102148:	e50b0008 	str	r0, [fp, #-8]
    if (!ucontext)
  10214c:	e51b3008 	ldr	r3, [fp, #-8]
  102150:	e3530000 	cmp	r3, #0
  102154:	1a000001 	bne	102160 <rt_thread_create+0x6c>
    {
        return RT_NULL;
  102158:	e3a03000 	mov	r3, #0
  10215c:	ea000016 	b	1021bc <rt_thread_create+0xc8>
    }
    ucontext->entry = entry;
  102160:	e51b3008 	ldr	r3, [fp, #-8]
  102164:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  102168:	e5832000 	str	r2, [r3]
    ucontext->parameter = parameter;
  10216c:	e51b3008 	ldr	r3, [fp, #-8]
  102170:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  102174:	e5832004 	str	r2, [r3, #4]
    arg[1] = rt_thread_user_entry;
  102178:	e30230a4 	movw	r3, #8356	; 0x20a4
  10217c:	e3403010 	movt	r3, #16
  102180:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    arg[2] = ucontext;
  102184:	e51b3008 	ldr	r3, [fp, #-8]
  102188:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    thread = (rt_thread_t)syscall(_NRSYS_thread_create, arg);
  10218c:	e24b3024 	sub	r3, fp, #36	; 0x24
  102190:	e1a01003 	mov	r1, r3
  102194:	e3a00028 	mov	r0, #40	; 0x28
  102198:	eb00e92f 	bl	13c65c <syscall>
  10219c:	e1a03000 	mov	r3, r0
  1021a0:	e50b300c 	str	r3, [fp, #-12]
    if (!thread)
  1021a4:	e51b300c 	ldr	r3, [fp, #-12]
  1021a8:	e3530000 	cmp	r3, #0
  1021ac:	1a000001 	bne	1021b8 <rt_thread_create+0xc4>
    {
        rt_free(ucontext);
  1021b0:	e51b0008 	ldr	r0, [fp, #-8]
  1021b4:	eb000380 	bl	102fbc <rt_free>
    }
    return thread;
  1021b8:	e51b300c 	ldr	r3, [fp, #-12]
}
  1021bc:	e1a00003 	mov	r0, r3
  1021c0:	e24bd004 	sub	sp, fp, #4
  1021c4:	e8bd8800 	pop	{fp, pc}

001021c8 <rt_thread_startup>:

rt_err_t rt_thread_startup(rt_thread_t thread)
{
  1021c8:	e92d4800 	push	{fp, lr}
  1021cc:	e28db004 	add	fp, sp, #4
  1021d0:	e24dd008 	sub	sp, sp, #8
  1021d4:	e50b0008 	str	r0, [fp, #-8]
    return syscall(_NRSYS_thread_startup, thread);
  1021d8:	e51b1008 	ldr	r1, [fp, #-8]
  1021dc:	e3a0002a 	mov	r0, #42	; 0x2a
  1021e0:	eb00e91d 	bl	13c65c <syscall>
  1021e4:	e1a03000 	mov	r3, r0
}
  1021e8:	e1a00003 	mov	r0, r3
  1021ec:	e24bd004 	sub	sp, fp, #4
  1021f0:	e8bd8800 	pop	{fp, pc}

001021f4 <rt_thread_self>:

rt_thread_t rt_thread_self(void)
{
  1021f4:	e92d4800 	push	{fp, lr}
  1021f8:	e28db004 	add	fp, sp, #4
    return (rt_thread_t)syscall(_NRSYS_thread_self);
  1021fc:	e3a0002b 	mov	r0, #43	; 0x2b
  102200:	eb00e915 	bl	13c65c <syscall>
  102204:	e1a03000 	mov	r3, r0
}
  102208:	e1a00003 	mov	r0, r3
  10220c:	e8bd8800 	pop	{fp, pc}

00102210 <rt_thread_delete>:

rt_err_t rt_thread_delete(rt_thread_t thread)
{
  102210:	e92d4800 	push	{fp, lr}
  102214:	e28db004 	add	fp, sp, #4
  102218:	e24dd008 	sub	sp, sp, #8
  10221c:	e50b0008 	str	r0, [fp, #-8]
    return syscall(_NRSYS_thread_delete, thread);
  102220:	e51b1008 	ldr	r1, [fp, #-8]
  102224:	e3a00029 	mov	r0, #41	; 0x29
  102228:	eb00e90b 	bl	13c65c <syscall>
  10222c:	e1a03000 	mov	r3, r0
}
  102230:	e1a00003 	mov	r0, r3
  102234:	e24bd004 	sub	sp, fp, #4
  102238:	e8bd8800 	pop	{fp, pc}

0010223c <rt_enter_critical>:

void rt_enter_critical(void)
{
  10223c:	e92d4800 	push	{fp, lr}
  102240:	e28db004 	add	fp, sp, #4
    syscall(_NRSYS_enter_critical);
  102244:	e3a00032 	mov	r0, #50	; 0x32
  102248:	eb00e903 	bl	13c65c <syscall>
}
  10224c:	e320f000 	nop	{0}
  102250:	e8bd8800 	pop	{fp, pc}

00102254 <rt_exit_critical>:

void rt_exit_critical(void)
{
  102254:	e92d4800 	push	{fp, lr}
  102258:	e28db004 	add	fp, sp, #4
    syscall(_NRSYS_exit_critical);
  10225c:	e3a00033 	mov	r0, #51	; 0x33
  102260:	eb00e8fd 	bl	13c65c <syscall>
}
  102264:	e320f000 	nop	{0}
  102268:	e8bd8800 	pop	{fp, pc}

0010226c <cacheflush>:

int cacheflush(void *addr, int size, int cache)
{
  10226c:	e92d4800 	push	{fp, lr}
  102270:	e28db004 	add	fp, sp, #4
  102274:	e24dd010 	sub	sp, sp, #16
  102278:	e50b0008 	str	r0, [fp, #-8]
  10227c:	e50b100c 	str	r1, [fp, #-12]
  102280:	e50b2010 	str	r2, [fp, #-16]
    return syscall(_NRSYS_cacheflush, addr, size, cache);
  102284:	e51b3010 	ldr	r3, [fp, #-16]
  102288:	e51b200c 	ldr	r2, [fp, #-12]
  10228c:	e51b1008 	ldr	r1, [fp, #-8]
  102290:	e3a0006b 	mov	r0, #107	; 0x6b
  102294:	eb00e8f0 	bl	13c65c <syscall>
  102298:	e1a03000 	mov	r3, r0
}
  10229c:	e1a00003 	mov	r0, r3
  1022a0:	e24bd004 	sub	sp, fp, #4
  1022a4:	e8bd8800 	pop	{fp, pc}

001022a8 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
  1022a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1022ac:	e28db000 	add	fp, sp, #0
  1022b0:	e24dd00c 	sub	sp, sp, #12
  1022b4:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
  1022b8:	e51b3008 	ldr	r3, [fp, #-8]
  1022bc:	e51b2008 	ldr	r2, [fp, #-8]
  1022c0:	e5832004 	str	r2, [r3, #4]
  1022c4:	e51b3008 	ldr	r3, [fp, #-8]
  1022c8:	e5932004 	ldr	r2, [r3, #4]
  1022cc:	e51b3008 	ldr	r3, [fp, #-8]
  1022d0:	e5832000 	str	r2, [r3]
}
  1022d4:	e320f000 	nop	{0}
  1022d8:	e28bd000 	add	sp, fp, #0
  1022dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1022e0:	e12fff1e 	bx	lr

001022e4 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
  1022e4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1022e8:	e28db000 	add	fp, sp, #0
  1022ec:	e24dd00c 	sub	sp, sp, #12
  1022f0:	e50b0008 	str	r0, [fp, #-8]
  1022f4:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
  1022f8:	e51b3008 	ldr	r3, [fp, #-8]
  1022fc:	e5933000 	ldr	r3, [r3]
  102300:	e51b200c 	ldr	r2, [fp, #-12]
  102304:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
  102308:	e51b3008 	ldr	r3, [fp, #-8]
  10230c:	e5932000 	ldr	r2, [r3]
  102310:	e51b300c 	ldr	r3, [fp, #-12]
  102314:	e5832000 	str	r2, [r3]

    l->next = n;
  102318:	e51b3008 	ldr	r3, [fp, #-8]
  10231c:	e51b200c 	ldr	r2, [fp, #-12]
  102320:	e5832000 	str	r2, [r3]
    n->prev = l;
  102324:	e51b300c 	ldr	r3, [fp, #-12]
  102328:	e51b2008 	ldr	r2, [fp, #-8]
  10232c:	e5832004 	str	r2, [r3, #4]
}
  102330:	e320f000 	nop	{0}
  102334:	e28bd000 	add	sp, fp, #0
  102338:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10233c:	e12fff1e 	bx	lr

00102340 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
  102340:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  102344:	e28db000 	add	fp, sp, #0
  102348:	e24dd00c 	sub	sp, sp, #12
  10234c:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
  102350:	e51b3008 	ldr	r3, [fp, #-8]
  102354:	e5933000 	ldr	r3, [r3]
  102358:	e51b2008 	ldr	r2, [fp, #-8]
  10235c:	e5922004 	ldr	r2, [r2, #4]
  102360:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
  102364:	e51b3008 	ldr	r3, [fp, #-8]
  102368:	e5933004 	ldr	r3, [r3, #4]
  10236c:	e51b2008 	ldr	r2, [fp, #-8]
  102370:	e5922000 	ldr	r2, [r2]
  102374:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
  102378:	e51b3008 	ldr	r3, [fp, #-8]
  10237c:	e51b2008 	ldr	r2, [fp, #-8]
  102380:	e5832004 	str	r2, [r3, #4]
  102384:	e51b3008 	ldr	r3, [fp, #-8]
  102388:	e5932004 	ldr	r2, [r3, #4]
  10238c:	e51b3008 	ldr	r3, [fp, #-8]
  102390:	e5832000 	str	r2, [r3]
}
  102394:	e320f000 	nop	{0}
  102398:	e28bd000 	add	sp, fp, #0
  10239c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1023a0:	e12fff1e 	bx	lr

001023a4 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
  1023a4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1023a8:	e28db000 	add	fp, sp, #0
  1023ac:	e24dd00c 	sub	sp, sp, #12
  1023b0:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
  1023b4:	e51b3008 	ldr	r3, [fp, #-8]
  1023b8:	e5933000 	ldr	r3, [r3]
  1023bc:	e51b2008 	ldr	r2, [fp, #-8]
  1023c0:	e1520003 	cmp	r2, r3
  1023c4:	03a03001 	moveq	r3, #1
  1023c8:	13a03000 	movne	r3, #0
  1023cc:	e6ef3073 	uxtb	r3, r3
}
  1023d0:	e1a00003 	mov	r0, r3
  1023d4:	e28bd000 	add	sp, fp, #0
  1023d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1023dc:	e12fff1e 	bx	lr

001023e0 <_rt_timer_init>:
static void _rt_timer_init(rt_timer_t timer,
                           void (*timeout)(void *parameter),
                           void      *parameter,
                           rt_tick_t  time,
                           rt_uint8_t flag)
{
  1023e0:	e92d4800 	push	{fp, lr}
  1023e4:	e28db004 	add	fp, sp, #4
  1023e8:	e24dd018 	sub	sp, sp, #24
  1023ec:	e50b0010 	str	r0, [fp, #-16]
  1023f0:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1023f4:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  1023f8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    int i;

    /* set flag */
    timer->parent.flag  = flag;
  1023fc:	e51b3010 	ldr	r3, [fp, #-16]
  102400:	e5db2004 	ldrb	r2, [fp, #4]
  102404:	e5c32009 	strb	r2, [r3, #9]

    /* set deactivated */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
  102408:	e51b3010 	ldr	r3, [fp, #-16]
  10240c:	e5d33009 	ldrb	r3, [r3, #9]
  102410:	e3c33001 	bic	r3, r3, #1
  102414:	e6ef2073 	uxtb	r2, r3
  102418:	e51b3010 	ldr	r3, [fp, #-16]
  10241c:	e5c32009 	strb	r2, [r3, #9]

    timer->timeout_func = timeout;
  102420:	e51b3010 	ldr	r3, [fp, #-16]
  102424:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  102428:	e583201c 	str	r2, [r3, #28]
    timer->parameter    = parameter;
  10242c:	e51b3010 	ldr	r3, [fp, #-16]
  102430:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  102434:	e5832020 	str	r2, [r3, #32]

    timer->timeout_tick = 0;
  102438:	e51b3010 	ldr	r3, [fp, #-16]
  10243c:	e3a02000 	mov	r2, #0
  102440:	e5832028 	str	r2, [r3, #40]	; 0x28
    timer->init_tick    = time;
  102444:	e51b3010 	ldr	r3, [fp, #-16]
  102448:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  10244c:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
  102450:	e3a03000 	mov	r3, #0
  102454:	e50b3008 	str	r3, [fp, #-8]
  102458:	ea00000a 	b	102488 <_rt_timer_init+0xa8>
    {
        rt_list_init(&(timer->row[i]));
  10245c:	e51b3008 	ldr	r3, [fp, #-8]
  102460:	e2833002 	add	r3, r3, #2
  102464:	e1a03183 	lsl	r3, r3, #3
  102468:	e51b2010 	ldr	r2, [fp, #-16]
  10246c:	e0823003 	add	r3, r2, r3
  102470:	e2833004 	add	r3, r3, #4
  102474:	e1a00003 	mov	r0, r3
  102478:	ebffff8a 	bl	1022a8 <rt_list_init>
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
  10247c:	e51b3008 	ldr	r3, [fp, #-8]
  102480:	e2833001 	add	r3, r3, #1
  102484:	e50b3008 	str	r3, [fp, #-8]
  102488:	e51b3008 	ldr	r3, [fp, #-8]
  10248c:	e3530000 	cmp	r3, #0
  102490:	dafffff1 	ble	10245c <_rt_timer_init+0x7c>
    }
}
  102494:	e320f000 	nop	{0}
  102498:	e24bd004 	sub	sp, fp, #4
  10249c:	e8bd8800 	pop	{fp, pc}

001024a0 <rt_timer_list_next_timeout>:

/* the fist timer always in the last row */
static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
{
  1024a0:	e92d4800 	push	{fp, lr}
  1024a4:	e28db004 	add	fp, sp, #4
  1024a8:	e24dd010 	sub	sp, sp, #16
  1024ac:	e50b0010 	str	r0, [fp, #-16]
    struct rt_timer *timer;

    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
  1024b0:	e51b0010 	ldr	r0, [fp, #-16]
  1024b4:	ebffffba 	bl	1023a4 <rt_list_isempty>
  1024b8:	e1a03000 	mov	r3, r0
  1024bc:	e3530000 	cmp	r3, #0
  1024c0:	0a000001 	beq	1024cc <rt_timer_list_next_timeout+0x2c>
        return RT_TICK_MAX;
  1024c4:	e3e03000 	mvn	r3, #0
  1024c8:	ea000005 	b	1024e4 <rt_timer_list_next_timeout+0x44>

    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
  1024cc:	e51b3010 	ldr	r3, [fp, #-16]
  1024d0:	e5933000 	ldr	r3, [r3]
  1024d4:	e2433014 	sub	r3, r3, #20
  1024d8:	e50b3008 	str	r3, [fp, #-8]
                          struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);

    return timer->timeout_tick;
  1024dc:	e51b3008 	ldr	r3, [fp, #-8]
  1024e0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
}
  1024e4:	e1a00003 	mov	r0, r3
  1024e8:	e24bd004 	sub	sp, fp, #4
  1024ec:	e8bd8800 	pop	{fp, pc}

001024f0 <_rt_timer_remove>:

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
  1024f0:	e92d4800 	push	{fp, lr}
  1024f4:	e28db004 	add	fp, sp, #4
  1024f8:	e24dd010 	sub	sp, sp, #16
  1024fc:	e50b0010 	str	r0, [fp, #-16]
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
  102500:	e3a03000 	mov	r3, #0
  102504:	e50b3008 	str	r3, [fp, #-8]
  102508:	ea00000a 	b	102538 <_rt_timer_remove+0x48>
    {
        rt_list_remove(&timer->row[i]);
  10250c:	e51b3008 	ldr	r3, [fp, #-8]
  102510:	e2833002 	add	r3, r3, #2
  102514:	e1a03183 	lsl	r3, r3, #3
  102518:	e51b2010 	ldr	r2, [fp, #-16]
  10251c:	e0823003 	add	r3, r2, r3
  102520:	e2833004 	add	r3, r3, #4
  102524:	e1a00003 	mov	r0, r3
  102528:	ebffff84 	bl	102340 <rt_list_remove>
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
  10252c:	e51b3008 	ldr	r3, [fp, #-8]
  102530:	e2833001 	add	r3, r3, #1
  102534:	e50b3008 	str	r3, [fp, #-8]
  102538:	e51b3008 	ldr	r3, [fp, #-8]
  10253c:	e3530000 	cmp	r3, #0
  102540:	dafffff1 	ble	10250c <_rt_timer_remove+0x1c>
    }
}
  102544:	e320f000 	nop	{0}
  102548:	e24bd004 	sub	sp, fp, #4
  10254c:	e8bd8800 	pop	{fp, pc}

00102550 <rt_timer_init>:
                   const char *name,
                   void (*timeout)(void *parameter),
                   void       *parameter,
                   rt_tick_t   time,
                   rt_uint8_t  flag)
{
  102550:	e92d4800 	push	{fp, lr}
  102554:	e28db004 	add	fp, sp, #4
  102558:	e24dd018 	sub	sp, sp, #24
  10255c:	e50b0008 	str	r0, [fp, #-8]
  102560:	e50b100c 	str	r1, [fp, #-12]
  102564:	e50b2010 	str	r2, [fp, #-16]
  102568:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    _rt_timer_init(timer, timeout, parameter, time, flag);
  10256c:	e5db3008 	ldrb	r3, [fp, #8]
  102570:	e58d3000 	str	r3, [sp]
  102574:	e59b3004 	ldr	r3, [fp, #4]
  102578:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  10257c:	e51b1010 	ldr	r1, [fp, #-16]
  102580:	e51b0008 	ldr	r0, [fp, #-8]
  102584:	ebffff95 	bl	1023e0 <_rt_timer_init>
}
  102588:	e320f000 	nop	{0}
  10258c:	e24bd004 	sub	sp, fp, #4
  102590:	e8bd8800 	pop	{fp, pc}

00102594 <rt_timer_detach>:
 * @param timer the static timer object
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_detach(rt_timer_t timer)
{
  102594:	e92d4800 	push	{fp, lr}
  102598:	e28db004 	add	fp, sp, #4
  10259c:	e24dd008 	sub	sp, sp, #8
  1025a0:	e50b0008 	str	r0, [fp, #-8]

    /* make sure take mutex */
    while(rt_mutex_take(mutex, RT_WAITING_FOREVER) != RT_EOK);
  1025a4:	e320f000 	nop	{0}
  1025a8:	e30e3410 	movw	r3, #58384	; 0xe410
  1025ac:	e3403014 	movt	r3, #20
  1025b0:	e5933000 	ldr	r3, [r3]
  1025b4:	e3e01000 	mvn	r1, #0
  1025b8:	e1a00003 	mov	r0, r3
  1025bc:	ebfffa4f 	bl	100f00 <rt_mutex_take>
  1025c0:	e1a03000 	mov	r3, r0
  1025c4:	e3530000 	cmp	r3, #0
  1025c8:	1afffff6 	bne	1025a8 <rt_timer_detach+0x14>

    _rt_timer_remove(timer);
  1025cc:	e51b0008 	ldr	r0, [fp, #-8]
  1025d0:	ebffffc6 	bl	1024f0 <_rt_timer_remove>

    /* release mutex */
    rt_mutex_release(mutex);
  1025d4:	e30e3410 	movw	r3, #58384	; 0xe410
  1025d8:	e3403014 	movt	r3, #20
  1025dc:	e5933000 	ldr	r3, [r3]
  1025e0:	e1a00003 	mov	r0, r3
  1025e4:	ebfffa63 	bl	100f78 <rt_mutex_release>

    return RT_EOK;
  1025e8:	e3a03000 	mov	r3, #0
}
  1025ec:	e1a00003 	mov	r0, r3
  1025f0:	e24bd004 	sub	sp, fp, #4
  1025f4:	e8bd8800 	pop	{fp, pc}

001025f8 <rt_timer_create>:
rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void       *parameter,
                           rt_tick_t   time,
                           rt_uint8_t  flag)
{
  1025f8:	e92d4800 	push	{fp, lr}
  1025fc:	e28db004 	add	fp, sp, #4
  102600:	e24dd020 	sub	sp, sp, #32
  102604:	e50b0010 	str	r0, [fp, #-16]
  102608:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10260c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  102610:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    struct rt_timer *timer;

    /* allocate a timer object */
    timer = (struct rt_timer *)malloc(sizeof(struct rt_timer));
  102614:	e3a0002c 	mov	r0, #44	; 0x2c
  102618:	eb00ebcc 	bl	13d550 <malloc>
  10261c:	e1a03000 	mov	r3, r0
  102620:	e50b3008 	str	r3, [fp, #-8]
    if (timer == RT_NULL)
  102624:	e51b3008 	ldr	r3, [fp, #-8]
  102628:	e3530000 	cmp	r3, #0
  10262c:	1a000001 	bne	102638 <rt_timer_create+0x40>
    {
        return RT_NULL;
  102630:	e3a03000 	mov	r3, #0
  102634:	ea000007 	b	102658 <rt_timer_create+0x60>
    }

    _rt_timer_init(timer, timeout, parameter, time, flag);
  102638:	e5db3004 	ldrb	r3, [fp, #4]
  10263c:	e58d3000 	str	r3, [sp]
  102640:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  102644:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  102648:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10264c:	e51b0008 	ldr	r0, [fp, #-8]
  102650:	ebffff62 	bl	1023e0 <_rt_timer_init>

    return timer;
  102654:	e51b3008 	ldr	r3, [fp, #-8]
}
  102658:	e1a00003 	mov	r0, r3
  10265c:	e24bd004 	sub	sp, fp, #4
  102660:	e8bd8800 	pop	{fp, pc}

00102664 <rt_timer_delete>:
 * @param timer the timer to be deleted
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_delete(rt_timer_t timer)
{
  102664:	e92d4800 	push	{fp, lr}
  102668:	e28db004 	add	fp, sp, #4
  10266c:	e24dd008 	sub	sp, sp, #8
  102670:	e50b0008 	str	r0, [fp, #-8]

    /* make sure take mutex */
    while(rt_mutex_take(mutex, RT_WAITING_FOREVER) != RT_EOK);
  102674:	e320f000 	nop	{0}
  102678:	e30e3410 	movw	r3, #58384	; 0xe410
  10267c:	e3403014 	movt	r3, #20
  102680:	e5933000 	ldr	r3, [r3]
  102684:	e3e01000 	mvn	r1, #0
  102688:	e1a00003 	mov	r0, r3
  10268c:	ebfffa1b 	bl	100f00 <rt_mutex_take>
  102690:	e1a03000 	mov	r3, r0
  102694:	e3530000 	cmp	r3, #0
  102698:	1afffff6 	bne	102678 <rt_timer_delete+0x14>

    _rt_timer_remove(timer);
  10269c:	e51b0008 	ldr	r0, [fp, #-8]
  1026a0:	ebffff92 	bl	1024f0 <_rt_timer_remove>

    /*free timer object */
    free(timer);
  1026a4:	e51b0008 	ldr	r0, [fp, #-8]
  1026a8:	eb00ed64 	bl	13dc40 <free>

    /* release mutex */
    rt_mutex_release(mutex);
  1026ac:	e30e3410 	movw	r3, #58384	; 0xe410
  1026b0:	e3403014 	movt	r3, #20
  1026b4:	e5933000 	ldr	r3, [r3]
  1026b8:	e1a00003 	mov	r0, r3
  1026bc:	ebfffa2d 	bl	100f78 <rt_mutex_release>

    return RT_EOK;
  1026c0:	e3a03000 	mov	r3, #0
}
  1026c4:	e1a00003 	mov	r0, r3
  1026c8:	e24bd004 	sub	sp, fp, #4
  1026cc:	e8bd8800 	pop	{fp, pc}

001026d0 <rt_timer_start>:
 * @param timer the timer to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_start(rt_timer_t timer)
{
  1026d0:	e92d4800 	push	{fp, lr}
  1026d4:	e28db004 	add	fp, sp, #4
  1026d8:	e24dd020 	sub	sp, sp, #32
  1026dc:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
    unsigned int tst_nr;
    static unsigned int random_nr;

    /* make sure take mutex */
    while(rt_mutex_take(mutex, RT_WAITING_FOREVER) != RT_EOK);
  1026e0:	e320f000 	nop	{0}
  1026e4:	e30e3410 	movw	r3, #58384	; 0xe410
  1026e8:	e3403014 	movt	r3, #20
  1026ec:	e5933000 	ldr	r3, [r3]
  1026f0:	e3e01000 	mvn	r1, #0
  1026f4:	e1a00003 	mov	r0, r3
  1026f8:	ebfffa00 	bl	100f00 <rt_mutex_take>
  1026fc:	e1a03000 	mov	r3, r0
  102700:	e3530000 	cmp	r3, #0
  102704:	1afffff6 	bne	1026e4 <rt_timer_start+0x14>
    /* remove timer from list */
    _rt_timer_remove(timer);
  102708:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10270c:	ebffff77 	bl	1024f0 <_rt_timer_remove>
    /* change status of timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
  102710:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  102714:	e5d33009 	ldrb	r3, [r3, #9]
  102718:	e3c33001 	bic	r3, r3, #1
  10271c:	e6ef2073 	uxtb	r2, r3
  102720:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  102724:	e5c32009 	strb	r2, [r3, #9]
    /* release mutex */
    rt_mutex_release(mutex);
  102728:	e30e3410 	movw	r3, #58384	; 0xe410
  10272c:	e3403014 	movt	r3, #20
  102730:	e5933000 	ldr	r3, [r3]
  102734:	e1a00003 	mov	r0, r3
  102738:	ebfffa0e 	bl	100f78 <rt_mutex_release>

    /*
     * get timeout tick,
     * the max timeout tick shall not great than RT_TICK_MAX/2
     */
    timer->timeout_tick = rt_tick_get() + timer->init_tick;
  10273c:	ebfffdc7 	bl	101e60 <rt_tick_get>
  102740:	e1a02000 	mov	r2, r0
  102744:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  102748:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  10274c:	e0822003 	add	r2, r2, r3
  102750:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  102754:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* make sure take mutex */
    while(rt_mutex_take(mutex, RT_WAITING_FOREVER) != RT_EOK);
  102758:	e320f000 	nop	{0}
  10275c:	e30e3410 	movw	r3, #58384	; 0xe410
  102760:	e3403014 	movt	r3, #20
  102764:	e5933000 	ldr	r3, [r3]
  102768:	e3e01000 	mvn	r1, #0
  10276c:	e1a00003 	mov	r0, r3
  102770:	ebfff9e2 	bl	100f00 <rt_mutex_take>
  102774:	e1a03000 	mov	r3, r0
  102778:	e3530000 	cmp	r3, #0
  10277c:	1afffff6 	bne	10275c <rt_timer_start+0x8c>

    /* insert timer to soft timer list */
    timer_list = rt_soft_timer_list;
  102780:	e30e3418 	movw	r3, #58392	; 0xe418
  102784:	e3403014 	movt	r3, #20
  102788:	e50b3010 	str	r3, [fp, #-16]

    row_head[0]  = &timer_list[0];
  10278c:	e51b3010 	ldr	r3, [fp, #-16]
  102790:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
  102794:	e3a03000 	mov	r3, #0
  102798:	e50b3008 	str	r3, [fp, #-8]
  10279c:	ea000047 	b	1028c0 <rt_timer_start+0x1f0>
    {
        for (; row_head[row_lvl] != timer_list[row_lvl].prev;
             row_head[row_lvl]  = row_head[row_lvl]->next)
        {
            struct rt_timer *t;
            rt_list_t *p = row_head[row_lvl]->next;
  1027a0:	e51b3008 	ldr	r3, [fp, #-8]
  1027a4:	e1a03103 	lsl	r3, r3, #2
  1027a8:	e24b2004 	sub	r2, fp, #4
  1027ac:	e0823003 	add	r3, r2, r3
  1027b0:	e5133018 	ldr	r3, [r3, #-24]	; 0xffffffe8
  1027b4:	e5933000 	ldr	r3, [r3]
  1027b8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

            /* fix up the entry pointer */
            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
  1027bc:	e51b3008 	ldr	r3, [fp, #-8]
  1027c0:	e1a03183 	lsl	r3, r3, #3
  1027c4:	e2833014 	add	r3, r3, #20
  1027c8:	e2633000 	rsb	r3, r3, #0
  1027cc:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  1027d0:	e0823003 	add	r3, r2, r3
  1027d4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
            /* If we have two timers that timeout at the same time, it's
             * preferred that the timer inserted early get called early.
             * So insert the new timer to the end the the some-timeout timer
             * list.
             */
            if ((t->timeout_tick - timer->timeout_tick) == 0)
  1027d8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1027dc:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  1027e0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1027e4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  1027e8:	e1520003 	cmp	r2, r3
  1027ec:	0a000007 	beq	102810 <rt_timer_start+0x140>
            {
                continue;
            }
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
  1027f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1027f4:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  1027f8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1027fc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  102800:	e0423003 	sub	r3, r2, r3
  102804:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
  102808:	9a000019 	bls	102874 <rt_timer_start+0x1a4>
  10280c:	ea000000 	b	102814 <rt_timer_start+0x144>
                continue;
  102810:	e320f000 	nop	{0}
             row_head[row_lvl]  = row_head[row_lvl]->next)
  102814:	e51b3008 	ldr	r3, [fp, #-8]
  102818:	e1a03103 	lsl	r3, r3, #2
  10281c:	e24b2004 	sub	r2, fp, #4
  102820:	e0823003 	add	r3, r2, r3
  102824:	e5133018 	ldr	r3, [r3, #-24]	; 0xffffffe8
  102828:	e5932000 	ldr	r2, [r3]
  10282c:	e51b3008 	ldr	r3, [fp, #-8]
  102830:	e1a03103 	lsl	r3, r3, #2
  102834:	e24b1004 	sub	r1, fp, #4
  102838:	e0813003 	add	r3, r1, r3
  10283c:	e5032018 	str	r2, [r3, #-24]	; 0xffffffe8
        for (; row_head[row_lvl] != timer_list[row_lvl].prev;
  102840:	e51b3008 	ldr	r3, [fp, #-8]
  102844:	e1a03103 	lsl	r3, r3, #2
  102848:	e24b2004 	sub	r2, fp, #4
  10284c:	e0823003 	add	r3, r2, r3
  102850:	e5132018 	ldr	r2, [r3, #-24]	; 0xffffffe8
  102854:	e51b3008 	ldr	r3, [fp, #-8]
  102858:	e1a03183 	lsl	r3, r3, #3
  10285c:	e51b1010 	ldr	r1, [fp, #-16]
  102860:	e0813003 	add	r3, r1, r3
  102864:	e5933004 	ldr	r3, [r3, #4]
  102868:	e1520003 	cmp	r2, r3
  10286c:	1affffcb 	bne	1027a0 <rt_timer_start+0xd0>
  102870:	ea000000 	b	102878 <rt_timer_start+0x1a8>
            {
                break;
  102874:	e320f000 	nop	{0}
            }
        }
        if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
  102878:	e51b3008 	ldr	r3, [fp, #-8]
  10287c:	e3530000 	cmp	r3, #0
  102880:	0a00000b 	beq	1028b4 <rt_timer_start+0x1e4>
            row_head[row_lvl + 1] = row_head[row_lvl] + 1;
  102884:	e51b3008 	ldr	r3, [fp, #-8]
  102888:	e1a03103 	lsl	r3, r3, #2
  10288c:	e24b2004 	sub	r2, fp, #4
  102890:	e0823003 	add	r3, r2, r3
  102894:	e5132018 	ldr	r2, [r3, #-24]	; 0xffffffe8
  102898:	e51b3008 	ldr	r3, [fp, #-8]
  10289c:	e2833001 	add	r3, r3, #1
  1028a0:	e2822008 	add	r2, r2, #8
  1028a4:	e1a03103 	lsl	r3, r3, #2
  1028a8:	e24b1004 	sub	r1, fp, #4
  1028ac:	e0813003 	add	r3, r1, r3
  1028b0:	e5032018 	str	r2, [r3, #-24]	; 0xffffffe8
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
  1028b4:	e51b3008 	ldr	r3, [fp, #-8]
  1028b8:	e2833001 	add	r3, r3, #1
  1028bc:	e50b3008 	str	r3, [fp, #-8]
  1028c0:	e51b3008 	ldr	r3, [fp, #-8]
  1028c4:	e3530000 	cmp	r3, #0
  1028c8:	0affffdc 	beq	102840 <rt_timer_start+0x170>

    /* Interestingly, this super simple timer insert counter works very very
     * well on distributing the list height uniformly. By means of "very very
     * well", I mean it beats the randomness of timer->timeout_tick very easily
     * (actually, the timeout_tick is not random and easy to be attacked). */
    random_nr++;
  1028cc:	e30e3420 	movw	r3, #58400	; 0xe420
  1028d0:	e3403014 	movt	r3, #20
  1028d4:	e5933000 	ldr	r3, [r3]
  1028d8:	e2832001 	add	r2, r3, #1
  1028dc:	e30e3420 	movw	r3, #58400	; 0xe420
  1028e0:	e3403014 	movt	r3, #20
  1028e4:	e5832000 	str	r2, [r3]
    tst_nr = random_nr;
  1028e8:	e30e3420 	movw	r3, #58400	; 0xe420
  1028ec:	e3403014 	movt	r3, #20
  1028f0:	e5933000 	ldr	r3, [r3]
  1028f4:	e50b300c 	str	r3, [fp, #-12]

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - 1],
  1028f8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1028fc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  102900:	e2833014 	add	r3, r3, #20
  102904:	e1a01003 	mov	r1, r3
  102908:	e1a00002 	mov	r0, r2
  10290c:	ebfffe74 	bl	1022e4 <rt_list_insert_after>
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
  102910:	e3a03002 	mov	r3, #2
  102914:	e50b3008 	str	r3, [fp, #-8]
  102918:	ea000018 	b	102980 <rt_timer_start+0x2b0>
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
  10291c:	e51b300c 	ldr	r3, [fp, #-12]
  102920:	e2033003 	and	r3, r3, #3
  102924:	e3530000 	cmp	r3, #0
  102928:	1a000018 	bne	102990 <rt_timer_start+0x2c0>
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
  10292c:	e51b3008 	ldr	r3, [fp, #-8]
  102930:	e2633001 	rsb	r3, r3, #1
  102934:	e1a03103 	lsl	r3, r3, #2
  102938:	e24b2004 	sub	r2, fp, #4
  10293c:	e0823003 	add	r3, r2, r3
  102940:	e5130018 	ldr	r0, [r3, #-24]	; 0xffffffe8
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
  102944:	e51b3008 	ldr	r3, [fp, #-8]
  102948:	e2633001 	rsb	r3, r3, #1
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
  10294c:	e2833002 	add	r3, r3, #2
  102950:	e1a03183 	lsl	r3, r3, #3
  102954:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  102958:	e0823003 	add	r3, r2, r3
  10295c:	e2833004 	add	r3, r3, #4
  102960:	e1a01003 	mov	r1, r3
  102964:	ebfffe5e 	bl	1022e4 <rt_list_insert_after>
        else
            break;
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK + 1) >> 1;
  102968:	e51b300c 	ldr	r3, [fp, #-12]
  10296c:	e1a03123 	lsr	r3, r3, #2
  102970:	e50b300c 	str	r3, [fp, #-12]
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
  102974:	e51b3008 	ldr	r3, [fp, #-8]
  102978:	e2833001 	add	r3, r3, #1
  10297c:	e50b3008 	str	r3, [fp, #-8]
  102980:	e51b3008 	ldr	r3, [fp, #-8]
  102984:	e3530001 	cmp	r3, #1
  102988:	9affffe3 	bls	10291c <rt_timer_start+0x24c>
  10298c:	ea000000 	b	102994 <rt_timer_start+0x2c4>
            break;
  102990:	e320f000 	nop	{0}
    }

    timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
  102994:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  102998:	e5d33009 	ldrb	r3, [r3, #9]
  10299c:	e3833001 	orr	r3, r3, #1
  1029a0:	e6ef2073 	uxtb	r2, r3
  1029a4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1029a8:	e5c32009 	strb	r2, [r3, #9]

    /* release mutex */
    rt_mutex_release(mutex);
  1029ac:	e30e3410 	movw	r3, #58384	; 0xe410
  1029b0:	e3403014 	movt	r3, #20
  1029b4:	e5933000 	ldr	r3, [r3]
  1029b8:	e1a00003 	mov	r0, r3
  1029bc:	ebfff96d 	bl	100f78 <rt_mutex_release>

    /* update hardware timer */
    rt_hw_timer_update();
  1029c0:	eb0000cc 	bl	102cf8 <rt_hw_timer_update>

    return RT_EOK;
  1029c4:	e3a03000 	mov	r3, #0
}
  1029c8:	e1a00003 	mov	r0, r3
  1029cc:	e24bd004 	sub	sp, fp, #4
  1029d0:	e8bd8800 	pop	{fp, pc}

001029d4 <rt_timer_stop>:
 * @param timer the timer to be stopped
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_stop(rt_timer_t timer)
{
  1029d4:	e92d4800 	push	{fp, lr}
  1029d8:	e28db004 	add	fp, sp, #4
  1029dc:	e24dd008 	sub	sp, sp, #8
  1029e0:	e50b0008 	str	r0, [fp, #-8]
    if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
  1029e4:	e51b3008 	ldr	r3, [fp, #-8]
  1029e8:	e5d33009 	ldrb	r3, [r3, #9]
  1029ec:	e2033001 	and	r3, r3, #1
  1029f0:	e3530000 	cmp	r3, #0
  1029f4:	1a000001 	bne	102a00 <rt_timer_stop+0x2c>
        return -RT_ERROR;
  1029f8:	e3e03000 	mvn	r3, #0
  1029fc:	ea000017 	b	102a60 <rt_timer_stop+0x8c>

    /* make sure take mutex */
    while(rt_mutex_take(mutex, RT_WAITING_FOREVER) != RT_EOK);
  102a00:	e320f000 	nop	{0}
  102a04:	e30e3410 	movw	r3, #58384	; 0xe410
  102a08:	e3403014 	movt	r3, #20
  102a0c:	e5933000 	ldr	r3, [r3]
  102a10:	e3e01000 	mvn	r1, #0
  102a14:	e1a00003 	mov	r0, r3
  102a18:	ebfff938 	bl	100f00 <rt_mutex_take>
  102a1c:	e1a03000 	mov	r3, r0
  102a20:	e3530000 	cmp	r3, #0
  102a24:	1afffff6 	bne	102a04 <rt_timer_stop+0x30>

    _rt_timer_remove(timer);
  102a28:	e51b0008 	ldr	r0, [fp, #-8]
  102a2c:	ebfffeaf 	bl	1024f0 <_rt_timer_remove>

    /* release mutex */
    rt_mutex_release(mutex);
  102a30:	e30e3410 	movw	r3, #58384	; 0xe410
  102a34:	e3403014 	movt	r3, #20
  102a38:	e5933000 	ldr	r3, [r3]
  102a3c:	e1a00003 	mov	r0, r3
  102a40:	ebfff94c 	bl	100f78 <rt_mutex_release>

    /* change stat */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
  102a44:	e51b3008 	ldr	r3, [fp, #-8]
  102a48:	e5d33009 	ldrb	r3, [r3, #9]
  102a4c:	e3c33001 	bic	r3, r3, #1
  102a50:	e6ef2073 	uxtb	r2, r3
  102a54:	e51b3008 	ldr	r3, [fp, #-8]
  102a58:	e5c32009 	strb	r2, [r3, #9]

    return RT_EOK;
  102a5c:	e3a03000 	mov	r3, #0
}
  102a60:	e1a00003 	mov	r0, r3
  102a64:	e24bd004 	sub	sp, fp, #4
  102a68:	e8bd8800 	pop	{fp, pc}

00102a6c <rt_timer_control>:
 * @param arg the argument
 *
 * @return RT_EOK
 */
rt_err_t rt_timer_control(rt_timer_t timer, int cmd, void *arg)
{
  102a6c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  102a70:	e28db000 	add	fp, sp, #0
  102a74:	e24dd014 	sub	sp, sp, #20
  102a78:	e50b0008 	str	r0, [fp, #-8]
  102a7c:	e50b100c 	str	r1, [fp, #-12]
  102a80:	e50b2010 	str	r2, [fp, #-16]
    switch (cmd)
  102a84:	e51b300c 	ldr	r3, [fp, #-12]
  102a88:	e3530008 	cmp	r3, #8
  102a8c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  102a90:	ea000032 	b	102b60 <rt_timer_control+0xf4>
  102a94:	00102acc 	.word	0x00102acc
  102a98:	00102ab8 	.word	0x00102ab8
  102a9c:	00102ae0 	.word	0x00102ae0
  102aa0:	00102afc 	.word	0x00102afc
  102aa4:	00102b60 	.word	0x00102b60
  102aa8:	00102b18 	.word	0x00102b18
  102aac:	00102b2c 	.word	0x00102b2c
  102ab0:	00102b3c 	.word	0x00102b3c
  102ab4:	00102b50 	.word	0x00102b50
    {
    case RT_TIMER_CTRL_GET_TIME:
        *(rt_tick_t *)arg = timer->init_tick;
  102ab8:	e51b3008 	ldr	r3, [fp, #-8]
  102abc:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  102ac0:	e51b3010 	ldr	r3, [fp, #-16]
  102ac4:	e5832000 	str	r2, [r3]
        break;
  102ac8:	ea000024 	b	102b60 <rt_timer_control+0xf4>

    case RT_TIMER_CTRL_SET_TIME:
        timer->init_tick = *(rt_tick_t *)arg;
  102acc:	e51b3010 	ldr	r3, [fp, #-16]
  102ad0:	e5932000 	ldr	r2, [r3]
  102ad4:	e51b3008 	ldr	r3, [fp, #-8]
  102ad8:	e5832024 	str	r2, [r3, #36]	; 0x24
        break;
  102adc:	ea00001f 	b	102b60 <rt_timer_control+0xf4>

    case RT_TIMER_CTRL_SET_ONESHOT:
        timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
  102ae0:	e51b3008 	ldr	r3, [fp, #-8]
  102ae4:	e5d33009 	ldrb	r3, [r3, #9]
  102ae8:	e3c33002 	bic	r3, r3, #2
  102aec:	e6ef2073 	uxtb	r2, r3
  102af0:	e51b3008 	ldr	r3, [fp, #-8]
  102af4:	e5c32009 	strb	r2, [r3, #9]
        break;
  102af8:	ea000018 	b	102b60 <rt_timer_control+0xf4>

    case RT_TIMER_CTRL_SET_PERIODIC:
        timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
  102afc:	e51b3008 	ldr	r3, [fp, #-8]
  102b00:	e5d33009 	ldrb	r3, [r3, #9]
  102b04:	e3833002 	orr	r3, r3, #2
  102b08:	e6ef2073 	uxtb	r2, r3
  102b0c:	e51b3008 	ldr	r3, [fp, #-8]
  102b10:	e5c32009 	strb	r2, [r3, #9]
        break;
  102b14:	ea000011 	b	102b60 <rt_timer_control+0xf4>

    case RT_TIMER_CTRL_GET_FUNC:
        *(void **)arg = timer->timeout_func;
  102b18:	e51b3008 	ldr	r3, [fp, #-8]
  102b1c:	e593201c 	ldr	r2, [r3, #28]
  102b20:	e51b3010 	ldr	r3, [fp, #-16]
  102b24:	e5832000 	str	r2, [r3]
        break;
  102b28:	ea00000c 	b	102b60 <rt_timer_control+0xf4>

    case RT_TIMER_CTRL_SET_FUNC:
        timer->timeout_func = (void (*)(void*))arg;
  102b2c:	e51b2010 	ldr	r2, [fp, #-16]
  102b30:	e51b3008 	ldr	r3, [fp, #-8]
  102b34:	e583201c 	str	r2, [r3, #28]
        break;
  102b38:	ea000008 	b	102b60 <rt_timer_control+0xf4>

    case RT_TIMER_CTRL_GET_PARM:
        *(void **)arg = timer->parameter;
  102b3c:	e51b3008 	ldr	r3, [fp, #-8]
  102b40:	e5932020 	ldr	r2, [r3, #32]
  102b44:	e51b3010 	ldr	r3, [fp, #-16]
  102b48:	e5832000 	str	r2, [r3]
        break;
  102b4c:	ea000003 	b	102b60 <rt_timer_control+0xf4>

    case RT_TIMER_CTRL_SET_PARM:
        timer->parameter = arg;
  102b50:	e51b3008 	ldr	r3, [fp, #-8]
  102b54:	e51b2010 	ldr	r2, [fp, #-16]
  102b58:	e5832020 	str	r2, [r3, #32]
        break;
  102b5c:	e320f000 	nop	{0}
    }

    return RT_EOK;
  102b60:	e3a03000 	mov	r3, #0
}
  102b64:	e1a00003 	mov	r0, r3
  102b68:	e28bd000 	add	sp, fp, #0
  102b6c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  102b70:	e12fff1e 	bx	lr

00102b74 <rt_soft_timer_check>:
/**
 * This function will check timer list, if a timeout event happens, the
 * corresponding timeout function will be invoked.
 */
void rt_soft_timer_check(void)
{
  102b74:	e92d4800 	push	{fp, lr}
  102b78:	e28db004 	add	fp, sp, #4
  102b7c:	e24dd010 	sub	sp, sp, #16
    rt_list_t *n;
    struct rt_timer *t;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check enter\n"));

    current_tick = rt_tick_get();
  102b80:	ebfffcb6 	bl	101e60 <rt_tick_get>
  102b84:	e50b0008 	str	r0, [fp, #-8]

    /* make sure take mutex */
    while(rt_mutex_take(mutex, RT_WAITING_FOREVER) != RT_EOK);
  102b88:	e320f000 	nop	{0}
  102b8c:	e30e3410 	movw	r3, #58384	; 0xe410
  102b90:	e3403014 	movt	r3, #20
  102b94:	e5933000 	ldr	r3, [r3]
  102b98:	e3e01000 	mvn	r1, #0
  102b9c:	e1a00003 	mov	r0, r3
  102ba0:	ebfff8d6 	bl	100f00 <rt_mutex_take>
  102ba4:	e1a03000 	mov	r3, r0
  102ba8:	e3530000 	cmp	r3, #0
  102bac:	1afffff6 	bne	102b8c <rt_soft_timer_check+0x18>

    for (n = rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next;
  102bb0:	e30e3418 	movw	r3, #58392	; 0xe418
  102bb4:	e3403014 	movt	r3, #20
  102bb8:	e5933000 	ldr	r3, [r3]
  102bbc:	e50b300c 	str	r3, [fp, #-12]
  102bc0:	ea00003d 	b	102cbc <rt_soft_timer_check+0x148>
         n != &(rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]);)
    {
        t = rt_list_entry(n, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
  102bc4:	e51b300c 	ldr	r3, [fp, #-12]
  102bc8:	e2433014 	sub	r3, r3, #20
  102bcc:	e50b3010 	str	r3, [fp, #-16]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
  102bd0:	e51b3010 	ldr	r3, [fp, #-16]
  102bd4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  102bd8:	e51b2008 	ldr	r2, [fp, #-8]
  102bdc:	e0423003 	sub	r3, r2, r3
  102be0:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
  102be4:	8a00003a 	bhi	102cd4 <rt_soft_timer_check+0x160>
        {
            /* move node to the next */
            n = n->next;
  102be8:	e51b300c 	ldr	r3, [fp, #-12]
  102bec:	e5933000 	ldr	r3, [r3]
  102bf0:	e50b300c 	str	r3, [fp, #-12]

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
  102bf4:	e51b0010 	ldr	r0, [fp, #-16]
  102bf8:	ebfffe3c 	bl	1024f0 <_rt_timer_remove>

            /* release mutex */
            rt_mutex_release(mutex);
  102bfc:	e30e3410 	movw	r3, #58384	; 0xe410
  102c00:	e3403014 	movt	r3, #20
  102c04:	e5933000 	ldr	r3, [r3]
  102c08:	e1a00003 	mov	r0, r3
  102c0c:	ebfff8d9 	bl	100f78 <rt_mutex_release>
            /* call timeout function */
            t->timeout_func(t->parameter);
  102c10:	e51b3010 	ldr	r3, [fp, #-16]
  102c14:	e593301c 	ldr	r3, [r3, #28]
  102c18:	e51b2010 	ldr	r2, [fp, #-16]
  102c1c:	e5922020 	ldr	r2, [r2, #32]
  102c20:	e1a00002 	mov	r0, r2
  102c24:	e12fff33 	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
  102c28:	ebfffc8c 	bl	101e60 <rt_tick_get>
  102c2c:	e50b0008 	str	r0, [fp, #-8]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            /* make sure take mutex */
            while(rt_mutex_take(mutex, RT_WAITING_FOREVER) != RT_EOK);
  102c30:	e320f000 	nop	{0}
  102c34:	e30e3410 	movw	r3, #58384	; 0xe410
  102c38:	e3403014 	movt	r3, #20
  102c3c:	e5933000 	ldr	r3, [r3]
  102c40:	e3e01000 	mvn	r1, #0
  102c44:	e1a00003 	mov	r0, r3
  102c48:	ebfff8ac 	bl	100f00 <rt_mutex_take>
  102c4c:	e1a03000 	mov	r3, r0
  102c50:	e3530000 	cmp	r3, #0
  102c54:	1afffff6 	bne	102c34 <rt_soft_timer_check+0xc0>


            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
  102c58:	e51b3010 	ldr	r3, [fp, #-16]
  102c5c:	e5d33009 	ldrb	r3, [r3, #9]
  102c60:	e2033002 	and	r3, r3, #2
  102c64:	e3530000 	cmp	r3, #0
  102c68:	0a00000d 	beq	102ca4 <rt_soft_timer_check+0x130>
                    (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
  102c6c:	e51b3010 	ldr	r3, [fp, #-16]
  102c70:	e5d33009 	ldrb	r3, [r3, #9]
  102c74:	e2033001 	and	r3, r3, #1
            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
  102c78:	e3530000 	cmp	r3, #0
  102c7c:	0a000008 	beq	102ca4 <rt_soft_timer_check+0x130>
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
  102c80:	e51b3010 	ldr	r3, [fp, #-16]
  102c84:	e5d33009 	ldrb	r3, [r3, #9]
  102c88:	e3c33001 	bic	r3, r3, #1
  102c8c:	e6ef2073 	uxtb	r2, r3
  102c90:	e51b3010 	ldr	r3, [fp, #-16]
  102c94:	e5c32009 	strb	r2, [r3, #9]
                rt_timer_start(t);
  102c98:	e51b0010 	ldr	r0, [fp, #-16]
  102c9c:	ebfffe8b 	bl	1026d0 <rt_timer_start>
  102ca0:	ea000005 	b	102cbc <rt_soft_timer_check+0x148>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
  102ca4:	e51b3010 	ldr	r3, [fp, #-16]
  102ca8:	e5d33009 	ldrb	r3, [r3, #9]
  102cac:	e3c33001 	bic	r3, r3, #1
  102cb0:	e6ef2073 	uxtb	r2, r3
  102cb4:	e51b3010 	ldr	r3, [fp, #-16]
  102cb8:	e5c32009 	strb	r2, [r3, #9]
    for (n = rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next;
  102cbc:	e51b200c 	ldr	r2, [fp, #-12]
  102cc0:	e30e3418 	movw	r3, #58392	; 0xe418
  102cc4:	e3403014 	movt	r3, #20
  102cc8:	e1520003 	cmp	r2, r3
  102ccc:	1affffbc 	bne	102bc4 <rt_soft_timer_check+0x50>
  102cd0:	ea000000 	b	102cd8 <rt_soft_timer_check+0x164>
            }
        }
        else break; /* not check anymore */
  102cd4:	e320f000 	nop	{0}
    }

    /* release mutex */
    rt_mutex_release(mutex);
  102cd8:	e30e3410 	movw	r3, #58384	; 0xe410
  102cdc:	e3403014 	movt	r3, #20
  102ce0:	e5933000 	ldr	r3, [r3]
  102ce4:	e1a00003 	mov	r0, r3
  102ce8:	ebfff8a2 	bl	100f78 <rt_mutex_release>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check leave\n"));
}
  102cec:	e320f000 	nop	{0}
  102cf0:	e24bd004 	sub	sp, fp, #4
  102cf4:	e8bd8800 	pop	{fp, pc}

00102cf8 <rt_hw_timer_update>:

/* update hardware timer */
static void rt_hw_timer_update(void)
{
  102cf8:	e92d4800 	push	{fp, lr}
  102cfc:	e28db004 	add	fp, sp, #4
  102d00:	e24dd008 	sub	sp, sp, #8
    rt_tick_t next_timeout;
    rt_tick_t current_tick;

    /* get the next timeout tick */
    next_timeout = rt_timer_list_next_timeout(rt_soft_timer_list);
  102d04:	e30e0418 	movw	r0, #58392	; 0xe418
  102d08:	e3400014 	movt	r0, #20
  102d0c:	ebfffde3 	bl	1024a0 <rt_timer_list_next_timeout>
  102d10:	e1a03000 	mov	r3, r0
  102d14:	e50b300c 	str	r3, [fp, #-12]
    if (next_timeout == RT_TICK_MAX)
  102d18:	e51b300c 	ldr	r3, [fp, #-12]
  102d1c:	e3730001 	cmn	r3, #1
  102d20:	0a00001f 	beq	102da4 <rt_hw_timer_update+0xac>
        /* no software timer exist, return. */
        return;
    }

    /* get current tick */
    current_tick = rt_tick_get();
  102d24:	ebfffc4d 	bl	101e60 <rt_tick_get>
  102d28:	e50b0008 	str	r0, [fp, #-8]

    if ((next_timeout - current_tick) < RT_TICK_MAX / 2)
  102d2c:	e51b200c 	ldr	r2, [fp, #-12]
  102d30:	e51b3008 	ldr	r3, [fp, #-8]
  102d34:	e0423003 	sub	r3, r2, r3
  102d38:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
  102d3c:	8a00001a 	bhi	102dac <rt_hw_timer_update+0xb4>
    {
        syscall(_NRSYS_timer_stop, hw_timer);
  102d40:	e30e340c 	movw	r3, #58380	; 0xe40c
  102d44:	e3403014 	movt	r3, #20
  102d48:	e5933000 	ldr	r3, [r3]
  102d4c:	e1a01003 	mov	r1, r3
  102d50:	e3a00072 	mov	r0, #114	; 0x72
  102d54:	eb00e640 	bl	13c65c <syscall>
        /* get the delta timeout tick */
        next_timeout = next_timeout - current_tick;
  102d58:	e51b200c 	ldr	r2, [fp, #-12]
  102d5c:	e51b3008 	ldr	r3, [fp, #-8]
  102d60:	e0423003 	sub	r3, r2, r3
  102d64:	e50b300c 	str	r3, [fp, #-12]
        syscall(_NRSYS_timer_control,
  102d68:	e30e340c 	movw	r3, #58380	; 0xe40c
  102d6c:	e3403014 	movt	r3, #20
  102d70:	e5931000 	ldr	r1, [r3]
  102d74:	e24b300c 	sub	r3, fp, #12
  102d78:	e3a02000 	mov	r2, #0
  102d7c:	e3a00073 	mov	r0, #115	; 0x73
  102d80:	eb00e635 	bl	13c65c <syscall>
                hw_timer,
                RT_TIMER_CTRL_SET_TIME,
                &next_timeout);
        syscall(_NRSYS_timer_start, hw_timer);
  102d84:	e30e340c 	movw	r3, #58380	; 0xe40c
  102d88:	e3403014 	movt	r3, #20
  102d8c:	e5933000 	ldr	r3, [r3]
  102d90:	e1a01003 	mov	r1, r3
  102d94:	e3a00071 	mov	r0, #113	; 0x71
  102d98:	eb00e62f 	bl	13c65c <syscall>
    }
    return;
  102d9c:	e320f000 	nop	{0}
  102da0:	ea000001 	b	102dac <rt_hw_timer_update+0xb4>
        return;
  102da4:	e320f000 	nop	{0}
  102da8:	ea000000 	b	102db0 <rt_hw_timer_update+0xb8>
    return;
  102dac:	e320f000 	nop	{0}
}
  102db0:	e24bd004 	sub	sp, fp, #4
  102db4:	e8bd8800 	pop	{fp, pc}

00102db8 <rt_thread_timer_handler>:

/* timer signal handler */
static void rt_thread_timer_handler(void)
{
  102db8:	e92d4800 	push	{fp, lr}
  102dbc:	e28db004 	add	fp, sp, #4
    /* update hardware timer */
    rt_hw_timer_update();
  102dc0:	ebffffcc 	bl	102cf8 <rt_hw_timer_update>
    /* check software timer */
    rt_soft_timer_check();
  102dc4:	ebffff6a 	bl	102b74 <rt_soft_timer_check>
}
  102dc8:	e320f000 	nop	{0}
  102dcc:	e8bd8800 	pop	{fp, pc}

00102dd0 <timer_thread_entry>:

static void timer_thread_entry(void* parameter)
{
  102dd0:	e92d4800 	push	{fp, lr}
  102dd4:	e28db004 	add	fp, sp, #4
  102dd8:	e24dd010 	sub	sp, sp, #16
  102ddc:	e50b0010 	str	r0, [fp, #-16]
    while (1)
    {
        rt_err_t ret;
        ret = rt_sem_take(sem, RT_WAITING_FOREVER);
  102de0:	e30e3414 	movw	r3, #58388	; 0xe414
  102de4:	e3403014 	movt	r3, #20
  102de8:	e5933000 	ldr	r3, [r3]
  102dec:	e3e01000 	mvn	r1, #0
  102df0:	e1a00003 	mov	r0, r3
  102df4:	ebfff92e 	bl	1012b4 <rt_sem_take>
  102df8:	e50b0008 	str	r0, [fp, #-8]
        if (ret != RT_EOK)
  102dfc:	e51b3008 	ldr	r3, [fp, #-8]
  102e00:	e3530000 	cmp	r3, #0
  102e04:	1a000001 	bne	102e10 <timer_thread_entry+0x40>
        {
            break;
        }
        rt_thread_timer_handler();
  102e08:	ebffffea 	bl	102db8 <rt_thread_timer_handler>
    {
  102e0c:	eafffff3 	b	102de0 <timer_thread_entry+0x10>
            break;
  102e10:	e320f000 	nop	{0}
    }
}
  102e14:	e320f000 	nop	{0}
  102e18:	e24bd004 	sub	sp, fp, #4
  102e1c:	e8bd8800 	pop	{fp, pc}

00102e20 <rt_system_timer_init>:

void rt_system_timer_init(rt_uint32_t timer_stack_size)
{
  102e20:	e92d4800 	push	{fp, lr}
  102e24:	e28db004 	add	fp, sp, #4
  102e28:	e24dd018 	sub	sp, sp, #24
  102e2c:	e50b0010 	str	r0, [fp, #-16]
    int i;
    rt_thread_t tid;

    if (!sem)
  102e30:	e30e3414 	movw	r3, #58388	; 0xe414
  102e34:	e3403014 	movt	r3, #20
  102e38:	e5933000 	ldr	r3, [r3]
  102e3c:	e3530000 	cmp	r3, #0
  102e40:	1a000008 	bne	102e68 <rt_system_timer_init+0x48>
    {
        sem = rt_sem_create("u_timer", 0, RT_IPC_FLAG_FIFO);
  102e44:	e3a02000 	mov	r2, #0
  102e48:	e3a01000 	mov	r1, #0
  102e4c:	e30506ac 	movw	r0, #22188	; 0x56ac
  102e50:	e3400014 	movt	r0, #20
  102e54:	ebfff863 	bl	100fe8 <rt_sem_create>
  102e58:	e1a02000 	mov	r2, r0
  102e5c:	e30e3414 	movw	r3, #58388	; 0xe414
  102e60:	e3403014 	movt	r3, #20
  102e64:	e5832000 	str	r2, [r3]
    }

    if (!mutex)
  102e68:	e30e3410 	movw	r3, #58384	; 0xe410
  102e6c:	e3403014 	movt	r3, #20
  102e70:	e5933000 	ldr	r3, [r3]
  102e74:	e3530000 	cmp	r3, #0
  102e78:	1a000007 	bne	102e9c <rt_system_timer_init+0x7c>
    {
        mutex = rt_mutex_create("utm_mutex", RT_IPC_FLAG_FIFO);
  102e7c:	e3a01000 	mov	r1, #0
  102e80:	e30506b4 	movw	r0, #22196	; 0x56b4
  102e84:	e3400014 	movt	r0, #20
  102e88:	ebfff786 	bl	100ca8 <rt_mutex_create>
  102e8c:	e1a02000 	mov	r2, r0
  102e90:	e30e3410 	movw	r3, #58384	; 0xe410
  102e94:	e3403014 	movt	r3, #20
  102e98:	e5832000 	str	r2, [r3]
    }

    for (i = 0;
  102e9c:	e3a03000 	mov	r3, #0
  102ea0:	e50b3008 	str	r3, [fp, #-8]
  102ea4:	ea000009 	b	102ed0 <rt_system_timer_init+0xb0>
         i < sizeof(rt_soft_timer_list) / sizeof(rt_soft_timer_list[0]);
         i++)
    {
        rt_list_init(rt_soft_timer_list + i);
  102ea8:	e51b3008 	ldr	r3, [fp, #-8]
  102eac:	e1a02183 	lsl	r2, r3, #3
  102eb0:	e30e3418 	movw	r3, #58392	; 0xe418
  102eb4:	e3403014 	movt	r3, #20
  102eb8:	e0823003 	add	r3, r2, r3
  102ebc:	e1a00003 	mov	r0, r3
  102ec0:	ebfffcf8 	bl	1022a8 <rt_list_init>
         i++)
  102ec4:	e51b3008 	ldr	r3, [fp, #-8]
  102ec8:	e2833001 	add	r3, r3, #1
  102ecc:	e50b3008 	str	r3, [fp, #-8]
    for (i = 0;
  102ed0:	e51b3008 	ldr	r3, [fp, #-8]
  102ed4:	e3530000 	cmp	r3, #0
  102ed8:	0afffff2 	beq	102ea8 <rt_system_timer_init+0x88>
    }

    /* initial hardware timer */
    if (!hw_timer)
  102edc:	e30e340c 	movw	r3, #58380	; 0xe40c
  102ee0:	e3403014 	movt	r3, #20
  102ee4:	e5933000 	ldr	r3, [r3]
  102ee8:	e3530000 	cmp	r3, #0
  102eec:	1a00000f 	bne	102f30 <rt_system_timer_init+0x110>
    {
        hw_timer = (rt_timer_t)syscall(_NRSYS_timer_create,
                "u_timer",
                sem->data, //SIG_HW_TIMER,
  102ef0:	e30e3414 	movw	r3, #58388	; 0xe414
  102ef4:	e3403014 	movt	r3, #20
  102ef8:	e5933000 	ldr	r3, [r3]
        hw_timer = (rt_timer_t)syscall(_NRSYS_timer_create,
  102efc:	e5932004 	ldr	r2, [r3, #4]
  102f00:	e3a03000 	mov	r3, #0
  102f04:	e58d3000 	str	r3, [sp]
  102f08:	e3a03000 	mov	r3, #0
  102f0c:	e30516ac 	movw	r1, #22188	; 0x56ac
  102f10:	e3401014 	movt	r1, #20
  102f14:	e3a0006f 	mov	r0, #111	; 0x6f
  102f18:	eb00e5cf 	bl	13c65c <syscall>
  102f1c:	e1a03000 	mov	r3, r0
  102f20:	e1a02003 	mov	r2, r3
  102f24:	e30e340c 	movw	r3, #58380	; 0xe40c
  102f28:	e3403014 	movt	r3, #20
  102f2c:	e5832000 	str	r2, [r3]
                0,
                RT_TIMER_FLAG_ONE_SHOT|RT_TIMER_FLAG_HARD_TIMER);
    }

    if (timer_stack_size < 4096)
  102f30:	e51b3010 	ldr	r3, [fp, #-16]
  102f34:	e3530a01 	cmp	r3, #4096	; 0x1000
  102f38:	2a000001 	bcs	102f44 <rt_system_timer_init+0x124>
    {
        timer_stack_size = 4096;
  102f3c:	e3a03a01 	mov	r3, #4096	; 0x1000
  102f40:	e50b3010 	str	r3, [fp, #-16]
    }

    tid = rt_thread_create("u_timer", timer_thread_entry, RT_NULL,
  102f44:	e3a0300a 	mov	r3, #10
  102f48:	e58d3004 	str	r3, [sp, #4]
  102f4c:	e3a03002 	mov	r3, #2
  102f50:	e58d3000 	str	r3, [sp]
  102f54:	e51b3010 	ldr	r3, [fp, #-16]
  102f58:	e3a02000 	mov	r2, #0
  102f5c:	e3021dd0 	movw	r1, #11728	; 0x2dd0
  102f60:	e3401010 	movt	r1, #16
  102f64:	e30506ac 	movw	r0, #22188	; 0x56ac
  102f68:	e3400014 	movt	r0, #20
  102f6c:	ebfffc60 	bl	1020f4 <rt_thread_create>
  102f70:	e50b000c 	str	r0, [fp, #-12]
            timer_stack_size, 2, 10);
    if (tid)
  102f74:	e51b300c 	ldr	r3, [fp, #-12]
  102f78:	e3530000 	cmp	r3, #0
  102f7c:	0a000001 	beq	102f88 <rt_system_timer_init+0x168>
    {
        rt_thread_startup(tid);
  102f80:	e51b000c 	ldr	r0, [fp, #-12]
  102f84:	ebfffc8f 	bl	1021c8 <rt_thread_startup>
    }
}
  102f88:	e320f000 	nop	{0}
  102f8c:	e24bd004 	sub	sp, fp, #4
  102f90:	e8bd8800 	pop	{fp, pc}

00102f94 <rt_malloc>:
#include <stdarg.h>

#include <rtthread.h>

void *rt_malloc(rt_size_t nbytes)
{
  102f94:	e92d4800 	push	{fp, lr}
  102f98:	e28db004 	add	fp, sp, #4
  102f9c:	e24dd008 	sub	sp, sp, #8
  102fa0:	e50b0008 	str	r0, [fp, #-8]
    return malloc(nbytes);
  102fa4:	e51b0008 	ldr	r0, [fp, #-8]
  102fa8:	eb00e968 	bl	13d550 <malloc>
  102fac:	e1a03000 	mov	r3, r0
}
  102fb0:	e1a00003 	mov	r0, r3
  102fb4:	e24bd004 	sub	sp, fp, #4
  102fb8:	e8bd8800 	pop	{fp, pc}

00102fbc <rt_free>:

void rt_free(void *ptr)
{
  102fbc:	e92d4800 	push	{fp, lr}
  102fc0:	e28db004 	add	fp, sp, #4
  102fc4:	e24dd008 	sub	sp, sp, #8
  102fc8:	e50b0008 	str	r0, [fp, #-8]
    return free(ptr);
  102fcc:	e51b0008 	ldr	r0, [fp, #-8]
  102fd0:	eb00eb1a 	bl	13dc40 <free>
}
  102fd4:	e24bd004 	sub	sp, fp, #4
  102fd8:	e8bd8800 	pop	{fp, pc}

00102fdc <rt_realloc>:

void *rt_realloc(void *ptr, rt_size_t nbytes)
{
  102fdc:	e92d4800 	push	{fp, lr}
  102fe0:	e28db004 	add	fp, sp, #4
  102fe4:	e24dd008 	sub	sp, sp, #8
  102fe8:	e50b0008 	str	r0, [fp, #-8]
  102fec:	e50b100c 	str	r1, [fp, #-12]
    return realloc(ptr, nbytes);
  102ff0:	e51b100c 	ldr	r1, [fp, #-12]
  102ff4:	e51b0008 	ldr	r0, [fp, #-8]
  102ff8:	eb00eb1f 	bl	13dc7c <realloc>
  102ffc:	e1a03000 	mov	r3, r0
}
  103000:	e1a00003 	mov	r0, r3
  103004:	e24bd004 	sub	sp, fp, #4
  103008:	e8bd8800 	pop	{fp, pc}

0010300c <rt_calloc>:

void *rt_calloc(rt_size_t count, rt_size_t size)
{
  10300c:	e92d4800 	push	{fp, lr}
  103010:	e28db004 	add	fp, sp, #4
  103014:	e24dd008 	sub	sp, sp, #8
  103018:	e50b0008 	str	r0, [fp, #-8]
  10301c:	e50b100c 	str	r1, [fp, #-12]
    return calloc(count, size);
  103020:	e51b100c 	ldr	r1, [fp, #-12]
  103024:	e51b0008 	ldr	r0, [fp, #-8]
  103028:	eb00eacd 	bl	13db64 <calloc>
  10302c:	e1a03000 	mov	r3, r0
}
  103030:	e1a00003 	mov	r0, r3
  103034:	e24bd004 	sub	sp, fp, #4
  103038:	e8bd8800 	pop	{fp, pc}

0010303c <rt_snprintf>:

rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *format, ...)
{
  10303c:	e92d000c 	push	{r2, r3}
  103040:	e92d4800 	push	{fp, lr}
  103044:	e28db004 	add	fp, sp, #4
  103048:	e24dd010 	sub	sp, sp, #16
  10304c:	e50b0010 	str	r0, [fp, #-16]
  103050:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    int ret;
    va_list ap;
    va_start(ap, format);
  103054:	e28b3008 	add	r3, fp, #8
  103058:	e50b300c 	str	r3, [fp, #-12]
    ret = vsnprintf(buf, size, format, ap);
  10305c:	e51b300c 	ldr	r3, [fp, #-12]
  103060:	e59b2004 	ldr	r2, [fp, #4]
  103064:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  103068:	e51b0010 	ldr	r0, [fp, #-16]
  10306c:	eb00f761 	bl	140df8 <vsnprintf>
  103070:	e50b0008 	str	r0, [fp, #-8]
    va_end(ap);
    return ret;
  103074:	e51b3008 	ldr	r3, [fp, #-8]
}
  103078:	e1a00003 	mov	r0, r3
  10307c:	e24bd004 	sub	sp, fp, #4
  103080:	e8bd4800 	pop	{fp, lr}
  103084:	e28dd008 	add	sp, sp, #8
  103088:	e12fff1e 	bx	lr

0010308c <rt_sprintf>:

rt_int32_t rt_sprintf(char *buf, const char *format, ...)
{
  10308c:	e92d000e 	push	{r1, r2, r3}
  103090:	e92d4800 	push	{fp, lr}
  103094:	e28db004 	add	fp, sp, #4
  103098:	e24dd014 	sub	sp, sp, #20
  10309c:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
    int ret;
    va_list ap;
    va_start(ap, format);
  1030a0:	e28b3008 	add	r3, fp, #8
  1030a4:	e50b3010 	str	r3, [fp, #-16]
    ret = vsprintf(buf, format, ap);
  1030a8:	e51b2010 	ldr	r2, [fp, #-16]
  1030ac:	e59b1004 	ldr	r1, [fp, #4]
  1030b0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1030b4:	eb00f786 	bl	140ed4 <vsprintf>
  1030b8:	e50b000c 	str	r0, [fp, #-12]
    va_end(ap);
    return ret;
  1030bc:	e51b300c 	ldr	r3, [fp, #-12]
}
  1030c0:	e1a00003 	mov	r0, r3
  1030c4:	e24bd004 	sub	sp, fp, #4
  1030c8:	e8bd4800 	pop	{fp, lr}
  1030cc:	e28dd00c 	add	sp, sp, #12
  1030d0:	e12fff1e 	bx	lr

001030d4 <rt_vsnprintf>:

rt_int32_t rt_vsnprintf(char *buf,
    rt_size_t size,
    const char *fmt,
    va_list args)
{
  1030d4:	e92d4800 	push	{fp, lr}
  1030d8:	e28db004 	add	fp, sp, #4
  1030dc:	e24dd010 	sub	sp, sp, #16
  1030e0:	e50b0008 	str	r0, [fp, #-8]
  1030e4:	e50b100c 	str	r1, [fp, #-12]
  1030e8:	e50b2010 	str	r2, [fp, #-16]
  1030ec:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return (rt_int32_t)vsnprintf(buf, size, fmt, args);
  1030f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1030f4:	e51b2010 	ldr	r2, [fp, #-16]
  1030f8:	e51b100c 	ldr	r1, [fp, #-12]
  1030fc:	e51b0008 	ldr	r0, [fp, #-8]
  103100:	eb00f73c 	bl	140df8 <vsnprintf>
  103104:	e1a03000 	mov	r3, r0
}
  103108:	e1a00003 	mov	r0, r3
  10310c:	e24bd004 	sub	sp, fp, #4
  103110:	e8bd8800 	pop	{fp, pc}

00103114 <rt_kprintf>:

void rt_kprintf(const char *fmt, ...)
{
  103114:	e92d000f 	push	{r0, r1, r2, r3}
  103118:	e92d4800 	push	{fp, lr}
  10311c:	e28db004 	add	fp, sp, #4
  103120:	e24dd060 	sub	sp, sp, #96	; 0x60
    int ret;
    va_list ap;
    char buf[81];

    va_start(ap, fmt);
  103124:	e28b3008 	add	r3, fp, #8
  103128:	e50b300c 	str	r3, [fp, #-12]
    ret = vsnprintf(buf, 81, fmt, ap);
  10312c:	e24b0060 	sub	r0, fp, #96	; 0x60
  103130:	e51b300c 	ldr	r3, [fp, #-12]
  103134:	e59b2004 	ldr	r2, [fp, #4]
  103138:	e3a01051 	mov	r1, #81	; 0x51
  10313c:	eb00f72d 	bl	140df8 <vsnprintf>
  103140:	e50b0008 	str	r0, [fp, #-8]
    va_end(ap);
    if (ret > 0)
  103144:	e51b3008 	ldr	r3, [fp, #-8]
  103148:	e3530000 	cmp	r3, #0
  10314c:	da000004 	ble	103164 <rt_kprintf+0x50>
        printf("%s", buf);
  103150:	e24b3060 	sub	r3, fp, #96	; 0x60
  103154:	e1a01003 	mov	r1, r3
  103158:	e30506c0 	movw	r0, #22208	; 0x56c0
  10315c:	e3400014 	movt	r0, #20
  103160:	eb00ed94 	bl	13e7b8 <printf>
}
  103164:	e320f000 	nop	{0}
  103168:	e24bd004 	sub	sp, fp, #4
  10316c:	e8bd4800 	pop	{fp, lr}
  103170:	e28dd010 	add	sp, sp, #16
  103174:	e12fff1e 	bx	lr

00103178 <rt_strdup>:

char *rt_strdup(const char* s)
{
  103178:	e92d4800 	push	{fp, lr}
  10317c:	e28db004 	add	fp, sp, #4
  103180:	e24dd008 	sub	sp, sp, #8
  103184:	e50b0008 	str	r0, [fp, #-8]
    return strdup(s);
  103188:	e51b0008 	ldr	r0, [fp, #-8]
  10318c:	eb00f93d 	bl	141688 <strdup>
  103190:	e1a03000 	mov	r3, r0
}
  103194:	e1a00003 	mov	r0, r3
  103198:	e24bd004 	sub	sp, fp, #4
  10319c:	e8bd8800 	pop	{fp, pc}

001031a0 <rt_strstr>:

char *rt_strstr(const char *s1, const char *s2)
{
  1031a0:	e92d4800 	push	{fp, lr}
  1031a4:	e28db004 	add	fp, sp, #4
  1031a8:	e24dd008 	sub	sp, sp, #8
  1031ac:	e50b0008 	str	r0, [fp, #-8]
  1031b0:	e50b100c 	str	r1, [fp, #-12]
    return strstr(s1, s2);
  1031b4:	e51b100c 	ldr	r1, [fp, #-12]
  1031b8:	e51b0008 	ldr	r0, [fp, #-8]
  1031bc:	eb00fa78 	bl	141ba4 <strstr>
  1031c0:	e1a03000 	mov	r3, r0
}
  1031c4:	e1a00003 	mov	r0, r3
  1031c8:	e24bd004 	sub	sp, fp, #4
  1031cc:	e8bd8800 	pop	{fp, pc}

001031d0 <rt_strcmp>:

rt_int32_t rt_strcmp(const char *cs, const char *ct)
{
  1031d0:	e92d4800 	push	{fp, lr}
  1031d4:	e28db004 	add	fp, sp, #4
  1031d8:	e24dd008 	sub	sp, sp, #8
  1031dc:	e50b0008 	str	r0, [fp, #-8]
  1031e0:	e50b100c 	str	r1, [fp, #-12]
    return (rt_int32_t)strcmp(cs, ct);
  1031e4:	e51b100c 	ldr	r1, [fp, #-12]
  1031e8:	e51b0008 	ldr	r0, [fp, #-8]
  1031ec:	eb00f90f 	bl	141630 <strcmp>
  1031f0:	e1a03000 	mov	r3, r0
}
  1031f4:	e1a00003 	mov	r0, r3
  1031f8:	e24bd004 	sub	sp, fp, #4
  1031fc:	e8bd8800 	pop	{fp, pc}

00103200 <rt_strlen>:

rt_size_t rt_strlen(const char *src)
{
  103200:	e92d4800 	push	{fp, lr}
  103204:	e28db004 	add	fp, sp, #4
  103208:	e24dd008 	sub	sp, sp, #8
  10320c:	e50b0008 	str	r0, [fp, #-8]
    return strlen(src);
  103210:	e51b0008 	ldr	r0, [fp, #-8]
  103214:	eb00f927 	bl	1416b8 <strlen>
  103218:	e1a03000 	mov	r3, r0
}
  10321c:	e1a00003 	mov	r0, r3
  103220:	e24bd004 	sub	sp, fp, #4
  103224:	e8bd8800 	pop	{fp, pc}

00103228 <rt_strncmp>:

rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
  103228:	e92d4800 	push	{fp, lr}
  10322c:	e28db004 	add	fp, sp, #4
  103230:	e24dd010 	sub	sp, sp, #16
  103234:	e50b0008 	str	r0, [fp, #-8]
  103238:	e50b100c 	str	r1, [fp, #-12]
  10323c:	e50b2010 	str	r2, [fp, #-16]
    return strncmp(cs, ct, count);
  103240:	e51b2010 	ldr	r2, [fp, #-16]
  103244:	e51b100c 	ldr	r1, [fp, #-12]
  103248:	e51b0008 	ldr	r0, [fp, #-8]
  10324c:	eb00f945 	bl	141768 <strncmp>
  103250:	e1a03000 	mov	r3, r0
}
  103254:	e1a00003 	mov	r0, r3
  103258:	e24bd004 	sub	sp, fp, #4
  10325c:	e8bd8800 	pop	{fp, pc}

00103260 <rt_strncpy>:

char *rt_strncpy(char *dest, const char *src, rt_ubase_t n)
{
  103260:	e92d4800 	push	{fp, lr}
  103264:	e28db004 	add	fp, sp, #4
  103268:	e24dd010 	sub	sp, sp, #16
  10326c:	e50b0008 	str	r0, [fp, #-8]
  103270:	e50b100c 	str	r1, [fp, #-12]
  103274:	e50b2010 	str	r2, [fp, #-16]
    return strncpy(dest, src, n);
  103278:	e51b2010 	ldr	r2, [fp, #-16]
  10327c:	e51b100c 	ldr	r1, [fp, #-12]
  103280:	e51b0008 	ldr	r0, [fp, #-8]
  103284:	eb00f95c 	bl	1417fc <strncpy>
  103288:	e1a03000 	mov	r3, r0
}
  10328c:	e1a00003 	mov	r0, r3
  103290:	e24bd004 	sub	sp, fp, #4
  103294:	e8bd8800 	pop	{fp, pc}

00103298 <rt_strcasecmp>:

rt_uint32_t rt_strcasecmp(const char *a, const char *b)
{
  103298:	e92d4800 	push	{fp, lr}
  10329c:	e28db004 	add	fp, sp, #4
  1032a0:	e24dd008 	sub	sp, sp, #8
  1032a4:	e50b0008 	str	r0, [fp, #-8]
  1032a8:	e50b100c 	str	r1, [fp, #-12]
    return strcasecmp(a, b);
  1032ac:	e51b100c 	ldr	r1, [fp, #-12]
  1032b0:	e51b0008 	ldr	r0, [fp, #-8]
  1032b4:	eb00f8b5 	bl	141590 <strcasecmp>
  1032b8:	e1a03000 	mov	r3, r0
}
  1032bc:	e1a00003 	mov	r0, r3
  1032c0:	e24bd004 	sub	sp, fp, #4
  1032c4:	e8bd8800 	pop	{fp, pc}

001032c8 <rt_memset>:

void *rt_memset(void *src, int c, rt_ubase_t n)
{
  1032c8:	e92d4800 	push	{fp, lr}
  1032cc:	e28db004 	add	fp, sp, #4
  1032d0:	e24dd010 	sub	sp, sp, #16
  1032d4:	e50b0008 	str	r0, [fp, #-8]
  1032d8:	e50b100c 	str	r1, [fp, #-12]
  1032dc:	e50b2010 	str	r2, [fp, #-16]
    return memset(src, c, n);
  1032e0:	e51b2010 	ldr	r2, [fp, #-16]
  1032e4:	e51b100c 	ldr	r1, [fp, #-12]
  1032e8:	e51b0008 	ldr	r0, [fp, #-8]
  1032ec:	eb00f860 	bl	141474 <memset>
  1032f0:	e1a03000 	mov	r3, r0
}
  1032f4:	e1a00003 	mov	r0, r3
  1032f8:	e24bd004 	sub	sp, fp, #4
  1032fc:	e8bd8800 	pop	{fp, pc}

00103300 <rt_memcpy>:

void *rt_memcpy(void *dest, const void *src, rt_ubase_t n)
{
  103300:	e92d4800 	push	{fp, lr}
  103304:	e28db004 	add	fp, sp, #4
  103308:	e24dd010 	sub	sp, sp, #16
  10330c:	e50b0008 	str	r0, [fp, #-8]
  103310:	e50b100c 	str	r1, [fp, #-12]
  103314:	e50b2010 	str	r2, [fp, #-16]
    return memcpy(dest, src, n);
  103318:	e51b2010 	ldr	r2, [fp, #-16]
  10331c:	e51b100c 	ldr	r1, [fp, #-12]
  103320:	e51b0008 	ldr	r0, [fp, #-8]
  103324:	eb00f71a 	bl	140f94 <memcpy>
  103328:	e1a03000 	mov	r3, r0
}
  10332c:	e1a00003 	mov	r0, r3
  103330:	e24bd004 	sub	sp, fp, #4
  103334:	e8bd8800 	pop	{fp, pc}

00103338 <rt_memcmp>:

rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
{
  103338:	e92d4800 	push	{fp, lr}
  10333c:	e28db004 	add	fp, sp, #4
  103340:	e24dd010 	sub	sp, sp, #16
  103344:	e50b0008 	str	r0, [fp, #-8]
  103348:	e50b100c 	str	r1, [fp, #-12]
  10334c:	e50b2010 	str	r2, [fp, #-16]
    return memcmp(cs, ct, count);
  103350:	e51b2010 	ldr	r2, [fp, #-16]
  103354:	e51b100c 	ldr	r1, [fp, #-12]
  103358:	e51b0008 	ldr	r0, [fp, #-8]
  10335c:	eb00f7cb 	bl	141290 <memcmp>
  103360:	e1a03000 	mov	r3, r0
}
  103364:	e1a00003 	mov	r0, r3
  103368:	e24bd004 	sub	sp, fp, #4
  10336c:	e8bd8800 	pop	{fp, pc}

00103370 <rt_memmove>:

void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
  103370:	e92d4800 	push	{fp, lr}
  103374:	e28db004 	add	fp, sp, #4
  103378:	e24dd010 	sub	sp, sp, #16
  10337c:	e50b0008 	str	r0, [fp, #-8]
  103380:	e50b100c 	str	r1, [fp, #-12]
  103384:	e50b2010 	str	r2, [fp, #-16]
    return memmove(dest, src, n);
  103388:	e51b2010 	ldr	r2, [fp, #-16]
  10338c:	e51b100c 	ldr	r1, [fp, #-12]
  103390:	e51b0008 	ldr	r0, [fp, #-8]
  103394:	eb00f7d0 	bl	1412dc <memmove>
  103398:	e1a03000 	mov	r3, r0
}
  10339c:	e1a00003 	mov	r0, r3
  1033a0:	e24bd004 	sub	sp, fp, #4
  1033a4:	e8bd8800 	pop	{fp, pc}

001033a8 <rt_tick_from_millisecond>:

rt_tick_t rt_tick_from_millisecond(rt_int32_t ms)
{
  1033a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1033ac:	e28db000 	add	fp, sp, #0
  1033b0:	e24dd014 	sub	sp, sp, #20
  1033b4:	e50b0010 	str	r0, [fp, #-16]
    rt_tick_t tick;

    if (ms < 0)
  1033b8:	e51b3010 	ldr	r3, [fp, #-16]
  1033bc:	e3530000 	cmp	r3, #0
  1033c0:	aa000002 	bge	1033d0 <rt_tick_from_millisecond+0x28>
    {
        tick = (rt_tick_t)RT_WAITING_FOREVER;
  1033c4:	e3e03000 	mvn	r3, #0
  1033c8:	e50b3008 	str	r3, [fp, #-8]
  1033cc:	ea000021 	b	103458 <rt_tick_from_millisecond+0xb0>
    }
    else
    {
        tick = RT_TICK_PER_SECOND * (ms / 1000);
  1033d0:	e51b1010 	ldr	r1, [fp, #-16]
  1033d4:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  1033d8:	e3413062 	movt	r3, #4194	; 0x1062
  1033dc:	e0c32391 	smull	r2, r3, r1, r3
  1033e0:	e1a02343 	asr	r2, r3, #6
  1033e4:	e1a03fc1 	asr	r3, r1, #31
  1033e8:	e0423003 	sub	r3, r2, r3
  1033ec:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  1033f0:	e0030392 	mul	r3, r2, r3
  1033f4:	e50b3008 	str	r3, [fp, #-8]
        tick += (RT_TICK_PER_SECOND * (ms % 1000) + 999) / 1000;
  1033f8:	e51b2010 	ldr	r2, [fp, #-16]
  1033fc:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  103400:	e3413062 	movt	r3, #4194	; 0x1062
  103404:	e0c10392 	smull	r0, r1, r2, r3
  103408:	e1a01341 	asr	r1, r1, #6
  10340c:	e1a03fc2 	asr	r3, r2, #31
  103410:	e0413003 	sub	r3, r1, r3
  103414:	e3a01ffa 	mov	r1, #1000	; 0x3e8
  103418:	e0030391 	mul	r3, r1, r3
  10341c:	e0423003 	sub	r3, r2, r3
  103420:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  103424:	e0030392 	mul	r3, r2, r3
  103428:	e2833ff9 	add	r3, r3, #996	; 0x3e4
  10342c:	e2833003 	add	r3, r3, #3
  103430:	e3042dd3 	movw	r2, #19923	; 0x4dd3
  103434:	e3412062 	movt	r2, #4194	; 0x1062
  103438:	e0c10293 	smull	r0, r1, r3, r2
  10343c:	e1a02341 	asr	r2, r1, #6
  103440:	e1a03fc3 	asr	r3, r3, #31
  103444:	e0423003 	sub	r3, r2, r3
  103448:	e1a02003 	mov	r2, r3
  10344c:	e51b3008 	ldr	r3, [fp, #-8]
  103450:	e0833002 	add	r3, r3, r2
  103454:	e50b3008 	str	r3, [fp, #-8]
    }

    /* return the calculated tick */
    return tick;
  103458:	e51b3008 	ldr	r3, [fp, #-8]
}
  10345c:	e1a00003 	mov	r0, r3
  103460:	e28bd000 	add	sp, fp, #0
  103464:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  103468:	e12fff1e 	bx	lr

0010346c <rt_malloc_align>:
 * @param align the alignment size
 *
 * @return the allocated memory block on successful, otherwise returns RT_NULL
 */
void *rt_malloc_align(rt_size_t size, rt_size_t align)
{
  10346c:	e92d4800 	push	{fp, lr}
  103470:	e28db004 	add	fp, sp, #4
  103474:	e24dd018 	sub	sp, sp, #24
  103478:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10347c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    void *align_ptr;
    int uintptr_size;
    rt_size_t align_size;

    /* sizeof pointer */
    uintptr_size = sizeof(void*);
  103480:	e3a03004 	mov	r3, #4
  103484:	e50b3010 	str	r3, [fp, #-16]
    uintptr_size -= 1;
  103488:	e51b3010 	ldr	r3, [fp, #-16]
  10348c:	e2433001 	sub	r3, r3, #1
  103490:	e50b3010 	str	r3, [fp, #-16]

    /* align the alignment size to uintptr size byte */
    align = ((align + uintptr_size) & ~uintptr_size);
  103494:	e51b2010 	ldr	r2, [fp, #-16]
  103498:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10349c:	e0823003 	add	r3, r2, r3
  1034a0:	e51b2010 	ldr	r2, [fp, #-16]
  1034a4:	e1e02002 	mvn	r2, r2
  1034a8:	e0033002 	and	r3, r3, r2
  1034ac:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    /* get total aligned size */
    align_size = ((size + uintptr_size) & ~uintptr_size) + align;
  1034b0:	e51b2010 	ldr	r2, [fp, #-16]
  1034b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1034b8:	e0823003 	add	r3, r2, r3
  1034bc:	e51b2010 	ldr	r2, [fp, #-16]
  1034c0:	e1e02002 	mvn	r2, r2
  1034c4:	e0033002 	and	r3, r3, r2
  1034c8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1034cc:	e0823003 	add	r3, r2, r3
  1034d0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    /* allocate memory block from heap */
    ptr = rt_malloc(align_size);
  1034d4:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1034d8:	ebfffead 	bl	102f94 <rt_malloc>
  1034dc:	e50b0008 	str	r0, [fp, #-8]
    if (ptr != RT_NULL)
  1034e0:	e51b3008 	ldr	r3, [fp, #-8]
  1034e4:	e3530000 	cmp	r3, #0
  1034e8:	0a000019 	beq	103554 <rt_malloc_align+0xe8>
    {
        /* the allocated memory block is aligned */
        if (((rt_ubase_t)ptr & (align - 1)) == 0)
  1034ec:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1034f0:	e2432001 	sub	r2, r3, #1
  1034f4:	e51b3008 	ldr	r3, [fp, #-8]
  1034f8:	e0033002 	and	r3, r3, r2
  1034fc:	e3530000 	cmp	r3, #0
  103500:	1a000004 	bne	103518 <rt_malloc_align+0xac>
        {
            align_ptr = (void *)((rt_ubase_t)ptr + align);
  103504:	e51b2008 	ldr	r2, [fp, #-8]
  103508:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10350c:	e0823003 	add	r3, r2, r3
  103510:	e50b300c 	str	r3, [fp, #-12]
  103514:	ea000007 	b	103538 <rt_malloc_align+0xcc>
        }
        else
        {
            align_ptr = (void *)(((rt_ubase_t)ptr + (align - 1)) & ~(align - 1));
  103518:	e51b2008 	ldr	r2, [fp, #-8]
  10351c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  103520:	e0823003 	add	r3, r2, r3
  103524:	e2432001 	sub	r2, r3, #1
  103528:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10352c:	e2633000 	rsb	r3, r3, #0
  103530:	e0033002 	and	r3, r3, r2
  103534:	e50b300c 	str	r3, [fp, #-12]
        }

        /* set the pointer before alignment pointer to the real pointer */
        *((rt_ubase_t *)((rt_ubase_t)align_ptr - sizeof(void *))) = (rt_ubase_t)ptr;
  103538:	e51b300c 	ldr	r3, [fp, #-12]
  10353c:	e2433004 	sub	r3, r3, #4
  103540:	e1a02003 	mov	r2, r3
  103544:	e51b3008 	ldr	r3, [fp, #-8]
  103548:	e5823000 	str	r3, [r2]

        ptr = align_ptr;
  10354c:	e51b300c 	ldr	r3, [fp, #-12]
  103550:	e50b3008 	str	r3, [fp, #-8]
    }

    return ptr;
  103554:	e51b3008 	ldr	r3, [fp, #-8]
}
  103558:	e1a00003 	mov	r0, r3
  10355c:	e24bd004 	sub	sp, fp, #4
  103560:	e8bd8800 	pop	{fp, pc}

00103564 <rt_free_align>:
 * rt_malloc_align function and address is aligned.
 *
 * @param ptr the memory block pointer
 */
void rt_free_align(void *ptr)
{
  103564:	e92d4800 	push	{fp, lr}
  103568:	e28db004 	add	fp, sp, #4
  10356c:	e24dd010 	sub	sp, sp, #16
  103570:	e50b0010 	str	r0, [fp, #-16]
    void *real_ptr;

    real_ptr = (void *) * (rt_ubase_t *)((rt_ubase_t)ptr - sizeof(void *));
  103574:	e51b3010 	ldr	r3, [fp, #-16]
  103578:	e2433004 	sub	r3, r3, #4
  10357c:	e5933000 	ldr	r3, [r3]
  103580:	e50b3008 	str	r3, [fp, #-8]
    rt_free(real_ptr);
  103584:	e51b0008 	ldr	r0, [fp, #-8]
  103588:	ebfffe8b 	bl	102fbc <rt_free>
}
  10358c:	e320f000 	nop	{0}
  103590:	e24bd004 	sub	sp, fp, #4
  103594:	e8bd8800 	pop	{fp, pc}

00103598 <rt_assert_handler>:

void rt_assert_handler(const char *ex_string, const char *func, rt_size_t line)
{
  103598:	e92d4800 	push	{fp, lr}
  10359c:	e28db004 	add	fp, sp, #4
  1035a0:	e24dd010 	sub	sp, sp, #16
  1035a4:	e50b0008 	str	r0, [fp, #-8]
  1035a8:	e50b100c 	str	r1, [fp, #-12]
  1035ac:	e50b2010 	str	r2, [fp, #-16]
    printf("UserAPP: (%s) assertion failed at function:%s, line number:%d \n", ex_string, func, (int)line);
  1035b0:	e51b3010 	ldr	r3, [fp, #-16]
  1035b4:	e51b200c 	ldr	r2, [fp, #-12]
  1035b8:	e51b1008 	ldr	r1, [fp, #-8]
  1035bc:	e30506c4 	movw	r0, #22212	; 0x56c4
  1035c0:	e3400014 	movt	r0, #20
  1035c4:	eb00ec7b 	bl	13e7b8 <printf>
    exit(-1);
  1035c8:	e3e00000 	mvn	r0, #0
  1035cc:	eb00d709 	bl	1391f8 <exit>

001035d0 <channel_cmd_send>:
    /* Watch this, we use a void pointer to transfer the returned value. */
    return chn_msg.u.d;
}

rt_inline void channel_cmd_send(int channel, void *cmd)
{
  1035d0:	e92d4800 	push	{fp, lr}
  1035d4:	e28db004 	add	fp, sp, #4
  1035d8:	e24dd018 	sub	sp, sp, #24
  1035dc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1035e0:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(channel >= 0);
  1035e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1035e8:	e3530000 	cmp	r3, #0
  1035ec:	aa000005 	bge	103608 <channel_cmd_send+0x38>
  1035f0:	e3a0201a 	mov	r2, #26
  1035f4:	e3051a64 	movw	r1, #23140	; 0x5a64
  1035f8:	e3401014 	movt	r1, #20
  1035fc:	e3050704 	movw	r0, #22276	; 0x5704
  103600:	e3400014 	movt	r0, #20
  103604:	ebffffe3 	bl	103598 <rt_assert_handler>

    /* wrap the command and data into an IPC message */
    struct rt_channel_msg chn_msg;
    chn_msg.type   = RT_CHANNEL_RAW;
  103608:	e3a03000 	mov	r3, #0
  10360c:	e50b3010 	str	r3, [fp, #-16]
    chn_msg.u.d    = cmd;
  103610:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  103614:	e50b300c 	str	r3, [fp, #-12]

    /* send the command and not wait for the result */
    rt_channel_send(channel, &chn_msg);
  103618:	e24b3014 	sub	r3, fp, #20
  10361c:	e1a01003 	mov	r1, r3
  103620:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  103624:	ebfff2f6 	bl	100204 <rt_channel_send>
}
  103628:	e320f000 	nop	{0}
  10362c:	e24bd004 	sub	sp, fp, #4
  103630:	e8bd8800 	pop	{fp, pc}

00103634 <channel_cmd_recv>:

rt_inline void *channel_cmd_recv(int channel)
{
  103634:	e92d4800 	push	{fp, lr}
  103638:	e28db004 	add	fp, sp, #4
  10363c:	e24dd018 	sub	sp, sp, #24
  103640:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    RT_ASSERT(channel >= 0);
  103644:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  103648:	e3530000 	cmp	r3, #0
  10364c:	aa000005 	bge	103668 <channel_cmd_recv+0x34>
  103650:	e3a02027 	mov	r2, #39	; 0x27
  103654:	e3051a3c 	movw	r1, #23100	; 0x5a3c
  103658:	e3401014 	movt	r1, #20
  10365c:	e3050704 	movw	r0, #22276	; 0x5704
  103660:	e3400014 	movt	r0, #20
  103664:	ebffffcb 	bl	103598 <rt_assert_handler>

    struct rt_channel_msg chn_msg;
    chn_msg.type = RT_CHANNEL_RAW;
  103668:	e3a03000 	mov	r3, #0
  10366c:	e50b3010 	str	r3, [fp, #-16]
    rt_channel_recv(channel, &chn_msg);
  103670:	e24b3014 	sub	r3, fp, #20
  103674:	e1a01003 	mov	r1, r3
  103678:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  10367c:	ebfff2fa 	bl	10026c <rt_channel_recv>

    return chn_msg.u.d;
  103680:	e51b300c 	ldr	r3, [fp, #-12]
}
  103684:	e1a00003 	mov	r0, r3
  103688:	e24bd004 	sub	sp, fp, #4
  10368c:	e8bd8800 	pop	{fp, pc}

00103690 <channel_cmd_reply>:

rt_inline void channel_cmd_reply(int channel, void *cmd)
{
  103690:	e92d4800 	push	{fp, lr}
  103694:	e28db004 	add	fp, sp, #4
  103698:	e24dd018 	sub	sp, sp, #24
  10369c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1036a0:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(channel >= 0);
  1036a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1036a8:	e3530000 	cmp	r3, #0
  1036ac:	aa000005 	bge	1036c8 <channel_cmd_reply+0x38>
  1036b0:	e3a02032 	mov	r2, #50	; 0x32
  1036b4:	e3051a50 	movw	r1, #23120	; 0x5a50
  1036b8:	e3401014 	movt	r1, #20
  1036bc:	e3050704 	movw	r0, #22276	; 0x5704
  1036c0:	e3400014 	movt	r0, #20
  1036c4:	ebffffb3 	bl	103598 <rt_assert_handler>

    struct rt_channel_msg chn_msg;
    chn_msg.type = RT_CHANNEL_RAW;
  1036c8:	e3a03000 	mov	r3, #0
  1036cc:	e50b3010 	str	r3, [fp, #-16]
    chn_msg.u.d = cmd;
  1036d0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1036d4:	e50b300c 	str	r3, [fp, #-12]

    rt_channel_reply(channel, &chn_msg);
  1036d8:	e24b3014 	sub	r3, fp, #20
  1036dc:	e1a01003 	mov	r1, r3
  1036e0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1036e4:	ebfff2d3 	bl	100238 <rt_channel_reply>
}
  1036e8:	e320f000 	nop	{0}
  1036ec:	e24bd004 	sub	sp, fp, #4
  1036f0:	e8bd8800 	pop	{fp, pc}

001036f4 <stack_init>:
 *  0: initialization completes successfully, further actions can be carried on
 *  1: initialization has been done before, we could do anything but another
 *  initialization
 */
int stack_init(void)
{
  1036f4:	e92d4800 	push	{fp, lr}
  1036f8:	e28db004 	add	fp, sp, #4
    /* stack channel as a flag whether the stack has been initialized */
    stack_channel = rt_channel_open(chn_name, O_CREAT);
  1036fc:	e30e3014 	movw	r3, #57364	; 0xe014
  103700:	e3403014 	movt	r3, #20
  103704:	e5933000 	ldr	r3, [r3]
  103708:	e3a01040 	mov	r1, #64	; 0x40
  10370c:	e1a00003 	mov	r0, r3
  103710:	ebfff280 	bl	100118 <rt_channel_open>
  103714:	e1a02000 	mov	r2, r0
  103718:	e30e3010 	movw	r3, #57360	; 0xe010
  10371c:	e3403014 	movt	r3, #20
  103720:	e5832000 	str	r2, [r3]
    if (stack_channel < 0) return 1;    /* initialization has been done */
  103724:	e30e3010 	movw	r3, #57360	; 0xe010
  103728:	e3403014 	movt	r3, #20
  10372c:	e5933000 	ldr	r3, [r3]
  103730:	e3530000 	cmp	r3, #0
  103734:	aa000001 	bge	103740 <stack_init+0x4c>
  103738:	e3a03001 	mov	r3, #1
  10373c:	ea000001 	b	103748 <stack_init+0x54>
    //     printf("attach stack failed!\n");
    //     goto close_unet_channel;
    // }

    /* start the TCPIP thread */
    lwip_system_init();
  103740:	eb001b63 	bl	10a4d4 <lwip_system_init>
    return 0;
  103744:	e3a03000 	mov	r3, #0
//     data_channel = -1;
// close_stack_channel:
//     rt_channel_close(stack_channel);
//     stack_channel = -1;
//     return -1;      /* initialization fails */
}
  103748:	e1a00003 	mov	r0, r3
  10374c:	e8bd8800 	pop	{fp, pc}

00103750 <stack_run>:
};
extern struct lwip_sock *lwip_tryget_socket(int s);
extern struct lwip_sock * get_socket(int s);
extern int access_is_blocking(u32_t flags, struct lwip_sock *sock);
int stack_run(void)
{
  103750:	e92d4800 	push	{fp, lr}
  103754:	e28db004 	add	fp, sp, #4
  103758:	e24dd050 	sub	sp, sp, #80	; 0x50
    // struct lwip_sock *sock = RT_NULL;

    /* run stack event loop */
    while (1)
    {
        int shmid = (int)(size_t)channel_cmd_recv(stack_channel);
  10375c:	e30e3010 	movw	r3, #57360	; 0xe010
  103760:	e3403014 	movt	r3, #20
  103764:	e5933000 	ldr	r3, [r3]
  103768:	e1a00003 	mov	r0, r3
  10376c:	ebffffb0 	bl	103634 <channel_cmd_recv>
  103770:	e1a03000 	mov	r3, r0
  103774:	e50b300c 	str	r3, [fp, #-12]
        if (shmid >= 0)
  103778:	e51b300c 	ldr	r3, [fp, #-12]
  10377c:	e3530000 	cmp	r3, #0
  103780:	ba000124 	blt	103c18 <stack_run+0x4c8>
        {
            cmd = lwp_shmat(shmid, NULL);
  103784:	e3a01000 	mov	r1, #0
  103788:	e51b000c 	ldr	r0, [fp, #-12]
  10378c:	ebfff9df 	bl	101f10 <lwp_shmat>
  103790:	e50b0010 	str	r0, [fp, #-16]
            if (!cmd)
  103794:	e51b3010 	ldr	r3, [fp, #-16]
  103798:	e3530000 	cmp	r3, #0
  10379c:	1a000002 	bne	1037ac <stack_run+0x5c>
            {
                lwp_shmrm(shmid);
  1037a0:	e51b000c 	ldr	r0, [fp, #-12]
  1037a4:	ebfff9ce 	bl	101ee4 <lwp_shmrm>
                continue;
  1037a8:	ea00011d 	b	103c24 <stack_run+0x4d4>
            }

            switch (cmd->cmd)
  1037ac:	e51b3010 	ldr	r3, [fp, #-16]
  1037b0:	e5933000 	ldr	r3, [r3]
  1037b4:	e2433014 	sub	r3, r3, #20
  1037b8:	e3530009 	cmp	r3, #9
  1037bc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  1037c0:	ea000116 	b	103c20 <stack_run+0x4d0>
  1037c4:	001037ec 	.word	0x001037ec
  1037c8:	00103c20 	.word	0x00103c20
  1037cc:	0010384c 	.word	0x0010384c
  1037d0:	001038b0 	.word	0x001038b0
  1037d4:	001038fc 	.word	0x001038fc
  1037d8:	00103960 	.word	0x00103960
  1037dc:	001039bc 	.word	0x001039bc
  1037e0:	00103ac8 	.word	0x00103ac8
  1037e4:	00103c20 	.word	0x00103c20
  1037e8:	00103b94 	.word	0x00103b94
            {
            /* handle socket requests */
            case UNET_SRV_CMD_SOCKET:
                domain = (int)(size_t)cmd->argv[0];
  1037ec:	e51b3010 	ldr	r3, [fp, #-16]
  1037f0:	e5933004 	ldr	r3, [r3, #4]
  1037f4:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc
                type = (int)(size_t)cmd->argv[1];
  1037f8:	e51b3010 	ldr	r3, [fp, #-16]
  1037fc:	e5933008 	ldr	r3, [r3, #8]
  103800:	e50b3048 	str	r3, [fp, #-72]	; 0xffffffb8
                protocol = (int)(size_t)cmd->argv[2];
  103804:	e51b3010 	ldr	r3, [fp, #-16]
  103808:	e593300c 	ldr	r3, [r3, #12]
  10380c:	e50b304c 	str	r3, [fp, #-76]	; 0xffffffb4
                socket = socket_internal(domain, type, protocol);
  103810:	e51b204c 	ldr	r2, [fp, #-76]	; 0xffffffb4
  103814:	e51b1048 	ldr	r1, [fp, #-72]	; 0xffffffb8
  103818:	e51b0044 	ldr	r0, [fp, #-68]	; 0xffffffbc
  10381c:	eb001829 	bl	1098c8 <socket_internal>
  103820:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
                lwp_shmdt(cmd);
  103824:	e51b0010 	ldr	r0, [fp, #-16]
  103828:	ebfff9c5 	bl	101f44 <lwp_shmdt>
                channel_cmd_reply(stack_channel, (void *)(size_t)socket);
  10382c:	e30e3010 	movw	r3, #57360	; 0xe010
  103830:	e3403014 	movt	r3, #20
  103834:	e5933000 	ldr	r3, [r3]
  103838:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  10383c:	e1a01002 	mov	r1, r2
  103840:	e1a00003 	mov	r0, r3
  103844:	ebffff91 	bl	103690 <channel_cmd_reply>
                break;
  103848:	ea0000f5 	b	103c24 <stack_run+0x4d4>
            //     lwp_shmdt(cmd);
            //     channel_cmd_reply(stack_channel, (void *)(size_t)result);
            //     break;

            case UNET_SRV_CMD_BIND:
                socket = (int)(size_t)cmd->argv[0];
  10384c:	e51b3010 	ldr	r3, [fp, #-16]
  103850:	e5933004 	ldr	r3, [r3, #4]
  103854:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
                psockaddr = (void *)(size_t)cmd + UNET_CMD_OFFSET;
  103858:	e51b3010 	ldr	r3, [fp, #-16]
  10385c:	e283301c 	add	r3, r3, #28
  103860:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
                len = (int)(size_t)cmd->argv[1];
  103864:	e51b3010 	ldr	r3, [fp, #-16]
  103868:	e5933008 	ldr	r3, [r3, #8]
  10386c:	e50b3040 	str	r3, [fp, #-64]	; 0xffffffc0

                result = bind_internal(socket, psockaddr, len);
  103870:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  103874:	e1a02003 	mov	r2, r3
  103878:	e51b1038 	ldr	r1, [fp, #-56]	; 0xffffffc8
  10387c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  103880:	eb00176e 	bl	109640 <bind_internal>
  103884:	e50b0008 	str	r0, [fp, #-8]

                lwp_shmdt(cmd);
  103888:	e51b0010 	ldr	r0, [fp, #-16]
  10388c:	ebfff9ac 	bl	101f44 <lwp_shmdt>
                channel_cmd_reply(stack_channel, (void *)(size_t)result);
  103890:	e30e3010 	movw	r3, #57360	; 0xe010
  103894:	e3403014 	movt	r3, #20
  103898:	e5933000 	ldr	r3, [r3]
  10389c:	e51b2008 	ldr	r2, [fp, #-8]
  1038a0:	e1a01002 	mov	r1, r2
  1038a4:	e1a00003 	mov	r0, r3
  1038a8:	ebffff78 	bl	103690 <channel_cmd_reply>
                break;
  1038ac:	ea0000dc 	b	103c24 <stack_run+0x4d4>

            case UNET_SRV_CMD_LISTEN:
                socket = (int)(size_t)cmd->argv[0];
  1038b0:	e51b3010 	ldr	r3, [fp, #-16]
  1038b4:	e5933004 	ldr	r3, [r3, #4]
  1038b8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

                result = listen_internal(socket, (int)(size_t)cmd->argv[1]);
  1038bc:	e51b3010 	ldr	r3, [fp, #-16]
  1038c0:	e5933008 	ldr	r3, [r3, #8]
  1038c4:	e1a01003 	mov	r1, r3
  1038c8:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1038cc:	eb001792 	bl	10971c <listen_internal>
  1038d0:	e50b0008 	str	r0, [fp, #-8]

                lwp_shmdt(cmd);
  1038d4:	e51b0010 	ldr	r0, [fp, #-16]
  1038d8:	ebfff999 	bl	101f44 <lwp_shmdt>
                channel_cmd_reply(stack_channel, (void *)(size_t)result);
  1038dc:	e30e3010 	movw	r3, #57360	; 0xe010
  1038e0:	e3403014 	movt	r3, #20
  1038e4:	e5933000 	ldr	r3, [r3]
  1038e8:	e51b2008 	ldr	r2, [fp, #-8]
  1038ec:	e1a01002 	mov	r1, r2
  1038f0:	e1a00003 	mov	r0, r3
  1038f4:	ebffff65 	bl	103690 <channel_cmd_reply>
                break;
  1038f8:	ea0000c9 	b	103c24 <stack_run+0x4d4>

            case UNET_SRV_CMD_CONNECT:
                socket = (int)(size_t)cmd->argv[0];
  1038fc:	e51b3010 	ldr	r3, [fp, #-16]
  103900:	e5933004 	ldr	r3, [r3, #4]
  103904:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
                psockaddr = (void *)(size_t)cmd + UNET_CMD_OFFSET;
  103908:	e51b3010 	ldr	r3, [fp, #-16]
  10390c:	e283301c 	add	r3, r3, #28
  103910:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
                len = (int)(size_t)cmd->argv[1];
  103914:	e51b3010 	ldr	r3, [fp, #-16]
  103918:	e5933008 	ldr	r3, [r3, #8]
  10391c:	e50b3040 	str	r3, [fp, #-64]	; 0xffffffc0

                result = connect_internal(socket, psockaddr, len);
  103920:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  103924:	e1a02003 	mov	r2, r3
  103928:	e51b1038 	ldr	r1, [fp, #-56]	; 0xffffffc8
  10392c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  103930:	eb001753 	bl	109684 <connect_internal>
  103934:	e50b0008 	str	r0, [fp, #-8]

                lwp_shmdt(cmd);
  103938:	e51b0010 	ldr	r0, [fp, #-16]
  10393c:	ebfff980 	bl	101f44 <lwp_shmdt>
                channel_cmd_reply(stack_channel, (void *)(size_t)result);
  103940:	e30e3010 	movw	r3, #57360	; 0xe010
  103944:	e3403014 	movt	r3, #20
  103948:	e5933000 	ldr	r3, [r3]
  10394c:	e51b2008 	ldr	r2, [fp, #-8]
  103950:	e1a01002 	mov	r1, r2
  103954:	e1a00003 	mov	r0, r3
  103958:	ebffff4c 	bl	103690 <channel_cmd_reply>
                break;
  10395c:	ea0000b0 	b	103c24 <stack_run+0x4d4>

            case UNET_SRV_CMD_ACCEPT:
                socket = (int)(size_t)cmd->argv[0];
  103960:	e51b3010 	ldr	r3, [fp, #-16]
  103964:	e5933004 	ldr	r3, [r3, #4]
  103968:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
                psockaddr = (void *)(size_t)cmd + UNET_CMD_OFFSET;
  10396c:	e51b3010 	ldr	r3, [fp, #-16]
  103970:	e283301c 	add	r3, r3, #28
  103974:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
                result = accept_internal(socket, psockaddr, (socklen_t *)&cmd->argv[1]);
  103978:	e51b3010 	ldr	r3, [fp, #-16]
  10397c:	e2833008 	add	r3, r3, #8
  103980:	e1a02003 	mov	r2, r3
  103984:	e51b1038 	ldr	r1, [fp, #-56]	; 0xffffffc8
  103988:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  10398c:	eb0016c3 	bl	1094a0 <accept_internal>
  103990:	e50b0008 	str	r0, [fp, #-8]
                lwp_shmdt(cmd);
  103994:	e51b0010 	ldr	r0, [fp, #-16]
  103998:	ebfff969 	bl	101f44 <lwp_shmdt>
                channel_cmd_reply(stack_channel, (void *)(size_t)result);
  10399c:	e30e3010 	movw	r3, #57360	; 0xe010
  1039a0:	e3403014 	movt	r3, #20
  1039a4:	e5933000 	ldr	r3, [r3]
  1039a8:	e51b2008 	ldr	r2, [fp, #-8]
  1039ac:	e1a01002 	mov	r1, r2
  1039b0:	e1a00003 	mov	r0, r3
  1039b4:	ebffff35 	bl	103690 <channel_cmd_reply>
                break;
  1039b8:	ea000099 	b	103c24 <stack_run+0x4d4>

            case UNET_SRV_CMD_SENDTO:
                socket = (int)(size_t)cmd->argv[0];
  1039bc:	e51b3010 	ldr	r3, [fp, #-16]
  1039c0:	e5933004 	ldr	r3, [r3, #4]
  1039c4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
                size = (size_t)cmd->argv[1];
  1039c8:	e51b3010 	ldr	r3, [fp, #-16]
  1039cc:	e5933008 	ldr	r3, [r3, #8]
  1039d0:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
                flags = (int)(size_t)cmd->argv[2];
  1039d4:	e51b3010 	ldr	r3, [fp, #-16]
  1039d8:	e593300c 	ldr	r3, [r3, #12]
  1039dc:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
                tolen = (int)(size_t)cmd->argv[3];
  1039e0:	e51b3010 	ldr	r3, [fp, #-16]
  1039e4:	e5933010 	ldr	r3, [r3, #16]
  1039e8:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
                data = (void *)(size_t)cmd + UNET_CMD_OFFSET;
  1039ec:	e51b3010 	ldr	r3, [fp, #-16]
  1039f0:	e283301c 	add	r3, r3, #28
  1039f4:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc

                lwip_send_count++;
  1039f8:	e30e3424 	movw	r3, #58404	; 0xe424
  1039fc:	e3403014 	movt	r3, #20
  103a00:	e5933000 	ldr	r3, [r3]
  103a04:	e2832001 	add	r2, r3, #1
  103a08:	e30e3424 	movw	r3, #58404	; 0xe424
  103a0c:	e3403014 	movt	r3, #20
  103a10:	e5832000 	str	r2, [r3]
                if(tolen  == 0)
  103a14:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  103a18:	e3530000 	cmp	r3, #0
  103a1c:	1a000006 	bne	103a3c <stack_run+0x2ec>
                {
                    result = send_internal(socket, data, size, flags);
  103a20:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103a24:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  103a28:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  103a2c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  103a30:	eb001776 	bl	109810 <send_internal>
  103a34:	e50b0008 	str	r0, [fp, #-8]
  103a38:	ea00000f 	b	103a7c <stack_run+0x32c>
                }
                else
                {
                    psockaddr = (void *)(size_t)cmd + UNET_CMD_OFFSET + size;
  103a3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  103a40:	e283301c 	add	r3, r3, #28
  103a44:	e51b2010 	ldr	r2, [fp, #-16]
  103a48:	e0823003 	add	r3, r2, r3
  103a4c:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
                    result = sendto_internal(socket, data, size, flags, psockaddr, tolen);
  103a50:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  103a54:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  103a58:	e58d3004 	str	r3, [sp, #4]
  103a5c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  103a60:	e58d3000 	str	r3, [sp]
  103a64:	e1a03002 	mov	r3, r2
  103a68:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  103a6c:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  103a70:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  103a74:	eb00177c 	bl	10986c <sendto_internal>
  103a78:	e50b0008 	str	r0, [fp, #-8]
                }
                if(result <= 0)
  103a7c:	e51b3008 	ldr	r3, [fp, #-8]
  103a80:	e3530000 	cmp	r3, #0
  103a84:	ca000005 	bgt	103aa0 <stack_run+0x350>
                {
                    rt_kprintf("%s line %d sendto error\n",__func__,__LINE__);
  103a88:	e300214d 	movw	r2, #333	; 0x14d
  103a8c:	e3051a30 	movw	r1, #23088	; 0x5a30
  103a90:	e3401014 	movt	r1, #20
  103a94:	e3050724 	movw	r0, #22308	; 0x5724
  103a98:	e3400014 	movt	r0, #20
  103a9c:	ebfffd9c 	bl	103114 <rt_kprintf>
                }
                lwp_shmdt(cmd);
  103aa0:	e51b0010 	ldr	r0, [fp, #-16]
  103aa4:	ebfff926 	bl	101f44 <lwp_shmdt>
                channel_cmd_reply(stack_channel, (void *)(size_t)result);
  103aa8:	e30e3010 	movw	r3, #57360	; 0xe010
  103aac:	e3403014 	movt	r3, #20
  103ab0:	e5933000 	ldr	r3, [r3]
  103ab4:	e51b2008 	ldr	r2, [fp, #-8]
  103ab8:	e1a01002 	mov	r1, r2
  103abc:	e1a00003 	mov	r0, r3
  103ac0:	ebfffef2 	bl	103690 <channel_cmd_reply>
                break;
  103ac4:	ea000056 	b	103c24 <stack_run+0x4d4>

            case UNET_SRV_CMD_RECVFROM:
                socket = (int)(size_t)cmd->argv[0];
  103ac8:	e51b3010 	ldr	r3, [fp, #-16]
  103acc:	e5933004 	ldr	r3, [r3, #4]
  103ad0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
                size = (size_t)cmd->argv[1];
  103ad4:	e51b3010 	ldr	r3, [fp, #-16]
  103ad8:	e5933008 	ldr	r3, [r3, #8]
  103adc:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
                flags = (int)(size_t)cmd->argv[2];
  103ae0:	e51b3010 	ldr	r3, [fp, #-16]
  103ae4:	e593300c 	ldr	r3, [r3, #12]
  103ae8:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
                fromlen = (socklen_t*)cmd->argv[3];
  103aec:	e51b3010 	ldr	r3, [fp, #-16]
  103af0:	e5933010 	ldr	r3, [r3, #16]
  103af4:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
                data = (void *)(size_t)cmd + UNET_CMD_OFFSET;
  103af8:	e51b3010 	ldr	r3, [fp, #-16]
  103afc:	e283301c 	add	r3, r3, #28
  103b00:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc

                if(fromlen == RT_NULL)
  103b04:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  103b08:	e3530000 	cmp	r3, #0
  103b0c:	1a000006 	bne	103b2c <stack_run+0x3dc>
                {
                    result = recv_internal(socket, data, size, flags);
  103b10:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103b14:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  103b18:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  103b1c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  103b20:	eb00170c 	bl	109758 <recv_internal>
  103b24:	e50b0008 	str	r0, [fp, #-8]
  103b28:	ea00000f 	b	103b6c <stack_run+0x41c>
                }
                else
                {
                    psockaddr =  (void *)(size_t)cmd + UNET_CMD_OFFSET + size;
  103b2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  103b30:	e283301c 	add	r3, r3, #28
  103b34:	e51b2010 	ldr	r2, [fp, #-16]
  103b38:	e0823003 	add	r3, r2, r3
  103b3c:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
                    result = recvfrom_internal(socket, data, size, flags , psockaddr, fromlen);
  103b40:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  103b44:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  103b48:	e58d3004 	str	r3, [sp, #4]
  103b4c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  103b50:	e58d3000 	str	r3, [sp]
  103b54:	e1a03002 	mov	r3, r2
  103b58:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  103b5c:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  103b60:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  103b64:	eb001712 	bl	1097b4 <recvfrom_internal>
  103b68:	e50b0008 	str	r0, [fp, #-8]
                }

                lwp_shmdt(cmd);
  103b6c:	e51b0010 	ldr	r0, [fp, #-16]
  103b70:	ebfff8f3 	bl	101f44 <lwp_shmdt>
                channel_cmd_reply(stack_channel, (void *)(size_t)result);
  103b74:	e30e3010 	movw	r3, #57360	; 0xe010
  103b78:	e3403014 	movt	r3, #20
  103b7c:	e5933000 	ldr	r3, [r3]
  103b80:	e51b2008 	ldr	r2, [fp, #-8]
  103b84:	e1a01002 	mov	r1, r2
  103b88:	e1a00003 	mov	r0, r3
  103b8c:	ebfffebf 	bl	103690 <channel_cmd_reply>
                break;
  103b90:	ea000023 	b	103c24 <stack_run+0x4d4>
            //     channel_cmd_reply(stack_channel, (void *)(size_t)result);
            //     break;

            case UNET_SRV_CMD_SETSOCKOPT:
            {
                socket = (int)(size_t)cmd->argv[0];
  103b94:	e51b3010 	ldr	r3, [fp, #-16]
  103b98:	e5933004 	ldr	r3, [r3, #4]
  103b9c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
                int level = (int)(size_t)cmd->argv[1];
  103ba0:	e51b3010 	ldr	r3, [fp, #-16]
  103ba4:	e5933008 	ldr	r3, [r3, #8]
  103ba8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
                int opt = (int)(size_t)cmd->argv[2];
  103bac:	e51b3010 	ldr	r3, [fp, #-16]
  103bb0:	e593300c 	ldr	r3, [r3, #12]
  103bb4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
                socklen = (socklen_t)(size_t)cmd->argv[3];
  103bb8:	e51b3010 	ldr	r3, [fp, #-16]
  103bbc:	e5933010 	ldr	r3, [r3, #16]
  103bc0:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
                void *optval =  (void *)(size_t)cmd + UNET_CMD_OFFSET;
  103bc4:	e51b3010 	ldr	r3, [fp, #-16]
  103bc8:	e283301c 	add	r3, r3, #28
  103bcc:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc

                result = setsockopt_internal(socket, level, opt, optval, socklen);
  103bd0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  103bd4:	e58d3000 	str	r3, [sp]
  103bd8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  103bdc:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  103be0:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  103be4:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  103be8:	eb0016b6 	bl	1096c8 <setsockopt_internal>
  103bec:	e50b0008 	str	r0, [fp, #-8]

                lwp_shmdt(cmd);
  103bf0:	e51b0010 	ldr	r0, [fp, #-16]
  103bf4:	ebfff8d2 	bl	101f44 <lwp_shmdt>
                channel_cmd_reply(stack_channel, (void *)(size_t)result);
  103bf8:	e30e3010 	movw	r3, #57360	; 0xe010
  103bfc:	e3403014 	movt	r3, #20
  103c00:	e5933000 	ldr	r3, [r3]
  103c04:	e51b2008 	ldr	r2, [fp, #-8]
  103c08:	e1a01002 	mov	r1, r2
  103c0c:	e1a00003 	mov	r0, r3
  103c10:	ebfffe9e 	bl	103690 <channel_cmd_reply>
                break;
  103c14:	ea000002 	b	103c24 <stack_run+0x4d4>
    //             break;

            default :
                break;
            }
        }
  103c18:	e320f000 	nop	{0}
  103c1c:	eafffece 	b	10375c <stack_run+0xc>
                break;
  103c20:	e320f000 	nop	{0}
    {
  103c24:	eafffecc 	b	10375c <stack_run+0xc>

00103c28 <lwipkit_status>:

    return 0;
}

static void lwipkit_status(void)
{
  103c28:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  103c2c:	e28db000 	add	fp, sp, #0
}
  103c30:	e320f000 	nop	{0}
  103c34:	e28bd000 	add	sp, fp, #0
  103c38:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  103c3c:	e12fff1e 	bx	lr

00103c40 <lwipkit_usage>:

/* lwIPKit initialization should be done once at most */
static void lwipkit_usage(void)
{
  103c40:	e92d4800 	push	{fp, lr}
  103c44:	e28db004 	add	fp, sp, #4
    printf("lwIPKit Usage:\n"
  103c48:	e3050740 	movw	r0, #22336	; 0x5740
  103c4c:	e3400014 	movt	r0, #20
  103c50:	eb00eae6 	bl	13e7f0 <puts>
            "\tlwIPKit               :  run lwIPKit, wait for ethdev to attach\n"
            "\tlwIPKit attach   <eth>:  attach the device <eth> to lwIPKit\n"
            "\tlwIPKit deattach <eth>:  de-attach the device <eth> from lwIPKit\n"
            "\tlwIPKit default  <eth>:  set <eth> as the default device\n"
            "\tlwIPKit status        :  show the status of running lwIPKIt\n");
}
  103c54:	e320f000 	nop	{0}
  103c58:	e8bd8800 	pop	{fp, pc}

00103c5c <main>:

/* entry point */
extern void sal_init(void);
extern int dfs_init(void);
int main(int argc, char **argv)
{
  103c5c:	e92d4810 	push	{r4, fp, lr}
  103c60:	e28db008 	add	fp, sp, #8
  103c64:	e24dd034 	sub	sp, sp, #52	; 0x34
  103c68:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  103c6c:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
    printf("lwipkit pid = %d\n", getpid());
  103c70:	eb00fcd0 	bl	142fb8 <getpid>
  103c74:	e1a03000 	mov	r3, r0
  103c78:	e1a01003 	mov	r1, r3
  103c7c:	e3050888 	movw	r0, #22664	; 0x5888
  103c80:	e3400014 	movt	r0, #20
  103c84:	eb00eacb 	bl	13e7b8 <printf>
    int initialized = 0;
  103c88:	e3a03000 	mov	r3, #0
  103c8c:	e50b3010 	str	r3, [fp, #-16]

    int data_channel = -1;  /* local variable, not the global one */
  103c90:	e3e03000 	mvn	r3, #0
  103c94:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    int shmid = -1;
  103c98:	e3e03000 	mvn	r3, #0
  103c9c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    struct channel_cmd *cmd = NULL;
  103ca0:	e3a03000 	mov	r3, #0
  103ca4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    /* no arguments, we want to run lwIPKit as a server */
    if (argc < 2)
  103ca8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  103cac:	e3530001 	cmp	r3, #1
  103cb0:	ca000035 	bgt	103d8c <main+0x130>
    {        
        printf("lwIPKit: starts to run as the server");
  103cb4:	e305089c 	movw	r0, #22684	; 0x589c
  103cb8:	e3400014 	movt	r0, #20
  103cbc:	eb00eabd 	bl	13e7b8 <printf>
        initialized = stack_init();
  103cc0:	ebfffe8b 	bl	1036f4 <stack_init>
  103cc4:	e50b0010 	str	r0, [fp, #-16]
        if (initialized < 0)
  103cc8:	e51b3010 	ldr	r3, [fp, #-16]
  103ccc:	e3530000 	cmp	r3, #0
  103cd0:	aa000004 	bge	103ce8 <main+0x8c>
        {
            printf(" ...failed!\n");
  103cd4:	e30508c4 	movw	r0, #22724	; 0x58c4
  103cd8:	e3400014 	movt	r0, #20
  103cdc:	eb00eac3 	bl	13e7f0 <puts>
            return -1;
  103ce0:	e3e03000 	mvn	r3, #0
  103ce4:	ea0000f7 	b	1040c8 <main+0x46c>
        }
        else if (initialized > 0)   /* valid lwIPKit process exists */
  103ce8:	e51b3010 	ldr	r3, [fp, #-16]
  103cec:	e3530000 	cmp	r3, #0
  103cf0:	da000004 	ble	103d08 <main+0xac>
        {
            printf(" ...skipped! Already initialized\n");
  103cf4:	e30508d0 	movw	r0, #22736	; 0x58d0
  103cf8:	e3400014 	movt	r0, #20
  103cfc:	eb00eabb 	bl	13e7f0 <puts>
            return 0;
  103d00:	e3a03000 	mov	r3, #0
  103d04:	ea0000ef 	b	1040c8 <main+0x46c>
        }
        else
        {
            // netdev_list_init();
            printf(" ...succeeded!\n");
  103d08:	e30508f4 	movw	r0, #22772	; 0x58f4
  103d0c:	e3400014 	movt	r0, #20
  103d10:	eb00eab6 	bl	13e7f0 <puts>

            // rt_thread_t tid = rt_thread_create("ipdata", stack_data_input, NULL, 8192,
            //     25, 10);            /* handle the input data */
            // if (tid) rt_thread_startup(tid);

            printf("lwIPKit: init eth dev...");
  103d14:	e3050904 	movw	r0, #22788	; 0x5904
  103d18:	e3400014 	movt	r0, #20
  103d1c:	eb00eaa5 	bl	13e7b8 <printf>
            const char * eth_name;
            initialized = imx6ul_eth_init(0, &eth_name);
  103d20:	e24b3024 	sub	r3, fp, #36	; 0x24
  103d24:	e1a01003 	mov	r1, r3
  103d28:	e3a00000 	mov	r0, #0
  103d2c:	eb00c72a 	bl	1359dc <imx6ul_eth_init>
  103d30:	e50b0010 	str	r0, [fp, #-16]
            if (initialized < 0)
  103d34:	e51b3010 	ldr	r3, [fp, #-16]
  103d38:	e3530000 	cmp	r3, #0
  103d3c:	aa000004 	bge	103d54 <main+0xf8>
            {
                printf(" ...failed!\n");
  103d40:	e30508c4 	movw	r0, #22724	; 0x58c4
  103d44:	e3400014 	movt	r0, #20
  103d48:	eb00eaa8 	bl	13e7f0 <puts>
                return -1;
  103d4c:	e3e03000 	mvn	r3, #0
  103d50:	ea0000dc 	b	1040c8 <main+0x46c>
            }
            else if (initialized > 0)   /* valid lwIPKit process exists */
  103d54:	e51b3010 	ldr	r3, [fp, #-16]
  103d58:	e3530000 	cmp	r3, #0
  103d5c:	da000004 	ble	103d74 <main+0x118>
            {
                printf(" ...skipped! Already initialized\n");
  103d60:	e30508d0 	movw	r0, #22736	; 0x58d0
  103d64:	e3400014 	movt	r0, #20
  103d68:	eb00eaa0 	bl	13e7f0 <puts>
                return 0;
  103d6c:	e3a03000 	mov	r3, #0
  103d70:	ea0000d4 	b	1040c8 <main+0x46c>
            } 
            else 
            {
                printf("succeeded\n");
  103d74:	e3050920 	movw	r0, #22816	; 0x5920
  103d78:	e3400014 	movt	r0, #20
  103d7c:	eb00ea9b 	bl	13e7f0 <puts>
                dfs_init();
  103d80:	eb001730 	bl	109a48 <dfs_init>
                sal_init();
  103d84:	eb000c20 	bl	106e0c <sal_init>
                // netdev_init(eth_name);
            }

            stack_run();            /* handle network requests, never return */
  103d88:	ebfffe70 	bl	103750 <stack_run>
        }
    }

    /* attach the device */
    if (argc >= 3 && strncmp(argv[1], "attach", 6) == 0)
  103d8c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  103d90:	e3530002 	cmp	r3, #2
  103d94:	da000050 	ble	103edc <main+0x280>
  103d98:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103d9c:	e2833004 	add	r3, r3, #4
  103da0:	e5933000 	ldr	r3, [r3]
  103da4:	e3a02006 	mov	r2, #6
  103da8:	e305192c 	movw	r1, #22828	; 0x592c
  103dac:	e3401014 	movt	r1, #20
  103db0:	e1a00003 	mov	r0, r3
  103db4:	eb00f66b 	bl	141768 <strncmp>
  103db8:	e1a03000 	mov	r3, r0
  103dbc:	e3530000 	cmp	r3, #0
  103dc0:	1a000045 	bne	103edc <main+0x280>
    {
        int static_ip = 0;
  103dc4:	e3a03000 	mov	r3, #0
  103dc8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
        printf("lwIPKit: attach device %s\n", argv[2]);
  103dcc:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103dd0:	e2833008 	add	r3, r3, #8
  103dd4:	e5933000 	ldr	r3, [r3]
  103dd8:	e1a01003 	mov	r1, r3
  103ddc:	e3050934 	movw	r0, #22836	; 0x5934
  103de0:	e3400014 	movt	r0, #20
  103de4:	eb00ea73 	bl	13e7b8 <printf>

        data_channel = rt_channel_open(data_name, O_RDWR);
  103de8:	e30e3018 	movw	r3, #57368	; 0xe018
  103dec:	e3403014 	movt	r3, #20
  103df0:	e5933000 	ldr	r3, [r3]
  103df4:	e3a01002 	mov	r1, #2
  103df8:	e1a00003 	mov	r0, r3
  103dfc:	ebfff0c5 	bl	100118 <rt_channel_open>
  103e00:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
        if (data_channel < 0)
  103e04:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  103e08:	e3530000 	cmp	r3, #0
  103e0c:	aa000004 	bge	103e24 <main+0x1c8>
        {
            printf("cannot open data_channel, please make sure lwIPKit server is running!\n");
  103e10:	e3050950 	movw	r0, #22864	; 0x5950
  103e14:	e3400014 	movt	r0, #20
  103e18:	eb00ea74 	bl	13e7f0 <puts>
            return -1;
  103e1c:	e3e03000 	mvn	r3, #0
  103e20:	ea0000a8 	b	1040c8 <main+0x46c>
        }

        shmid = channel_compose_cmd1(UNET_NETDEV_REQ_ATTACH, (void *)(size_t)static_ip, strlen(argv[2]) + 1);
  103e24:	e51b4020 	ldr	r4, [fp, #-32]	; 0xffffffe0
  103e28:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103e2c:	e2833008 	add	r3, r3, #8
  103e30:	e5933000 	ldr	r3, [r3]
  103e34:	e1a00003 	mov	r0, r3
  103e38:	eb00f61e 	bl	1416b8 <strlen>
  103e3c:	e1a03000 	mov	r3, r0
  103e40:	e2833001 	add	r3, r3, #1
  103e44:	e58d300c 	str	r3, [sp, #12]
  103e48:	e3a03000 	mov	r3, #0
  103e4c:	e58d3008 	str	r3, [sp, #8]
  103e50:	e3a03000 	mov	r3, #0
  103e54:	e58d3004 	str	r3, [sp, #4]
  103e58:	e3a03000 	mov	r3, #0
  103e5c:	e58d3000 	str	r3, [sp]
  103e60:	e3a03000 	mov	r3, #0
  103e64:	e3a02000 	mov	r2, #0
  103e68:	e1a01004 	mov	r1, r4
  103e6c:	e3a00065 	mov	r0, #101	; 0x65
  103e70:	eb000097 	bl	1040d4 <channel_compose_cmd>
  103e74:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
        cmd = (struct channel_cmd*)lwp_shmat(shmid, NULL);
  103e78:	e3a01000 	mov	r1, #0
  103e7c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  103e80:	ebfff822 	bl	101f10 <lwp_shmat>
  103e84:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
        if (cmd)
  103e88:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  103e8c:	e3530000 	cmp	r3, #0
  103e90:	0a000009 	beq	103ebc <main+0x260>
        {
            strcpy(CHANNEL_CMD_DATA(cmd), argv[2]);
  103e94:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  103e98:	e283201c 	add	r2, r3, #28
  103e9c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103ea0:	e2833008 	add	r3, r3, #8
  103ea4:	e5933000 	ldr	r3, [r3]
  103ea8:	e1a01003 	mov	r1, r3
  103eac:	e1a00002 	mov	r0, r2
  103eb0:	eb00f5ef 	bl	141674 <strcpy>
            lwp_shmdt(cmd);
  103eb4:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  103eb8:	ebfff821 	bl	101f44 <lwp_shmdt>
        }
        channel_cmd_send(data_channel, (void *)(size_t)shmid);
  103ebc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  103ec0:	e1a01003 	mov	r1, r3
  103ec4:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  103ec8:	ebfffdc0 	bl	1035d0 <channel_cmd_send>
        rt_channel_close(data_channel);
  103ecc:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  103ed0:	ebfff09d 	bl	10014c <rt_channel_close>

        return 0;
  103ed4:	e3a03000 	mov	r3, #0
  103ed8:	ea00007a 	b	1040c8 <main+0x46c>
    }

    /* deattach the device and restore it to the uninitialized state */
    if (argc == 3)
  103edc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  103ee0:	e3530003 	cmp	r3, #3
  103ee4:	1a000061 	bne	104070 <main+0x414>
    {
        if (strncmp(argv[1], "deattach", 8) == 0)
  103ee8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103eec:	e2833004 	add	r3, r3, #4
  103ef0:	e5933000 	ldr	r3, [r3]
  103ef4:	e3a02008 	mov	r2, #8
  103ef8:	e3051998 	movw	r1, #22936	; 0x5998
  103efc:	e3401014 	movt	r1, #20
  103f00:	e1a00003 	mov	r0, r3
  103f04:	eb00f617 	bl	141768 <strncmp>
  103f08:	e1a03000 	mov	r3, r0
  103f0c:	e3530000 	cmp	r3, #0
  103f10:	1a000042 	bne	104020 <main+0x3c4>
        {
            printf("lwIPKit: de-attach device %s\n", argv[2]);
  103f14:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103f18:	e2833008 	add	r3, r3, #8
  103f1c:	e5933000 	ldr	r3, [r3]
  103f20:	e1a01003 	mov	r1, r3
  103f24:	e30509a4 	movw	r0, #22948	; 0x59a4
  103f28:	e3400014 	movt	r0, #20
  103f2c:	eb00ea21 	bl	13e7b8 <printf>

            data_channel = rt_channel_open(data_name, O_RDWR);
  103f30:	e30e3018 	movw	r3, #57368	; 0xe018
  103f34:	e3403014 	movt	r3, #20
  103f38:	e5933000 	ldr	r3, [r3]
  103f3c:	e3a01002 	mov	r1, #2
  103f40:	e1a00003 	mov	r0, r3
  103f44:	ebfff073 	bl	100118 <rt_channel_open>
  103f48:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
            if (data_channel < 0)
  103f4c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  103f50:	e3530000 	cmp	r3, #0
  103f54:	aa000004 	bge	103f6c <main+0x310>
            {
                printf("cannot open data_channel, please make sure lwIPKit server is running!\n");
  103f58:	e3050950 	movw	r0, #22864	; 0x5950
  103f5c:	e3400014 	movt	r0, #20
  103f60:	eb00ea22 	bl	13e7f0 <puts>
                return -1;
  103f64:	e3e03000 	mvn	r3, #0
  103f68:	ea000056 	b	1040c8 <main+0x46c>
            }

            shmid = channel_compose_cmd0(UNET_NETDEV_REQ_DETACH, strlen(argv[2]) + 1);
  103f6c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103f70:	e2833008 	add	r3, r3, #8
  103f74:	e5933000 	ldr	r3, [r3]
  103f78:	e1a00003 	mov	r0, r3
  103f7c:	eb00f5cd 	bl	1416b8 <strlen>
  103f80:	e1a03000 	mov	r3, r0
  103f84:	e2833001 	add	r3, r3, #1
  103f88:	e58d300c 	str	r3, [sp, #12]
  103f8c:	e3a03000 	mov	r3, #0
  103f90:	e58d3008 	str	r3, [sp, #8]
  103f94:	e3a03000 	mov	r3, #0
  103f98:	e58d3004 	str	r3, [sp, #4]
  103f9c:	e3a03000 	mov	r3, #0
  103fa0:	e58d3000 	str	r3, [sp]
  103fa4:	e3a03000 	mov	r3, #0
  103fa8:	e3a02000 	mov	r2, #0
  103fac:	e3a01000 	mov	r1, #0
  103fb0:	e3a00066 	mov	r0, #102	; 0x66
  103fb4:	eb000046 	bl	1040d4 <channel_compose_cmd>
  103fb8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
            cmd = (struct channel_cmd*)lwp_shmat(shmid, NULL);
  103fbc:	e3a01000 	mov	r1, #0
  103fc0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  103fc4:	ebfff7d1 	bl	101f10 <lwp_shmat>
  103fc8:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
            if (cmd)
  103fcc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  103fd0:	e3530000 	cmp	r3, #0
  103fd4:	0a000009 	beq	104000 <main+0x3a4>
            {
                strcpy(CHANNEL_CMD_DATA(cmd), argv[2]);
  103fd8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  103fdc:	e283201c 	add	r2, r3, #28
  103fe0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  103fe4:	e2833008 	add	r3, r3, #8
  103fe8:	e5933000 	ldr	r3, [r3]
  103fec:	e1a01003 	mov	r1, r3
  103ff0:	e1a00002 	mov	r0, r2
  103ff4:	eb00f59e 	bl	141674 <strcpy>
                lwp_shmdt(cmd);
  103ff8:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  103ffc:	ebfff7d0 	bl	101f44 <lwp_shmdt>
            }
            channel_cmd_send(data_channel, (void *)(size_t)shmid);
  104000:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  104004:	e1a01003 	mov	r1, r3
  104008:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  10400c:	ebfffd6f 	bl	1035d0 <channel_cmd_send>
            rt_channel_close(data_channel);
  104010:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  104014:	ebfff04c 	bl	10014c <rt_channel_close>

            return 0;
  104018:	e3a03000 	mov	r3, #0
  10401c:	ea000029 	b	1040c8 <main+0x46c>
        }


        if (strncmp(argv[1], "default", 8) == 0)
  104020:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  104024:	e2833004 	add	r3, r3, #4
  104028:	e5933000 	ldr	r3, [r3]
  10402c:	e3a02008 	mov	r2, #8
  104030:	e30519c4 	movw	r1, #22980	; 0x59c4
  104034:	e3401014 	movt	r1, #20
  104038:	e1a00003 	mov	r0, r3
  10403c:	eb00f5c9 	bl	141768 <strncmp>
  104040:	e1a03000 	mov	r3, r0
  104044:	e3530000 	cmp	r3, #0
  104048:	1a000008 	bne	104070 <main+0x414>
        {
            printf("lwIPKit: set the default device %s", argv[2]);
  10404c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  104050:	e2833008 	add	r3, r3, #8
  104054:	e5933000 	ldr	r3, [r3]
  104058:	e1a01003 	mov	r1, r3
  10405c:	e30509cc 	movw	r0, #22988	; 0x59cc
  104060:	e3400014 	movt	r0, #20
  104064:	eb00e9d3 	bl	13e7b8 <printf>
            //eth_set_default(argv[2]);
            return 0;
  104068:	e3a03000 	mov	r3, #0
  10406c:	ea000015 	b	1040c8 <main+0x46c>
        }
    }

    /* show the status */
    if (argc == 2 && strncmp(argv[1], "status", 6) == 0)
  104070:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  104074:	e3530002 	cmp	r3, #2
  104078:	1a000010 	bne	1040c0 <main+0x464>
  10407c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  104080:	e2833004 	add	r3, r3, #4
  104084:	e5933000 	ldr	r3, [r3]
  104088:	e3a02006 	mov	r2, #6
  10408c:	e30519f0 	movw	r1, #23024	; 0x59f0
  104090:	e3401014 	movt	r1, #20
  104094:	e1a00003 	mov	r0, r3
  104098:	eb00f5b2 	bl	141768 <strncmp>
  10409c:	e1a03000 	mov	r3, r0
  1040a0:	e3530000 	cmp	r3, #0
  1040a4:	1a000005 	bne	1040c0 <main+0x464>
    {
        printf("lwIPKit: the status of the attached devices as follows\n");
  1040a8:	e30509f8 	movw	r0, #23032	; 0x59f8
  1040ac:	e3400014 	movt	r0, #20
  1040b0:	eb00e9ce 	bl	13e7f0 <puts>
        lwipkit_status();
  1040b4:	ebfffedb 	bl	103c28 <lwipkit_status>
        return 0;
  1040b8:	e3a03000 	mov	r3, #0
  1040bc:	ea000001 	b	1040c8 <main+0x46c>
    }

    lwipkit_usage();
  1040c0:	ebfffede 	bl	103c40 <lwipkit_usage>
    return -1;
  1040c4:	e3e03000 	mvn	r3, #0
}
  1040c8:	e1a00003 	mov	r0, r3
  1040cc:	e24bd008 	sub	sp, fp, #8
  1040d0:	e8bd8810 	pop	{r4, fp, pc}

001040d4 <channel_compose_cmd>:
#include "channel.h"

static int _shm_key = -1;
int channel_compose_cmd(uint32_t cmd, void *arg0, void *arg1, void *arg2,
    void *arg3, void *arg4, void *arg5, size_t datalen)
{
  1040d4:	e92d4800 	push	{fp, lr}
  1040d8:	e28db004 	add	fp, sp, #4
  1040dc:	e24dd020 	sub	sp, sp, #32
  1040e0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1040e4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  1040e8:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  1040ec:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    int shmid;
    void *shm_vaddr = NULL;
  1040f0:	e3a03000 	mov	r3, #0
  1040f4:	e50b3008 	str	r3, [fp, #-8]
    struct channel_cmd *pcmd = NULL;
  1040f8:	e3a03000 	mov	r3, #0
  1040fc:	e50b300c 	str	r3, [fp, #-12]

    /* the shared memory includes the command and the possible data */
    size_t len = datalen + CHANNEL_CMD_OFFSET;
  104100:	e59b3010 	ldr	r3, [fp, #16]
  104104:	e283301c 	add	r3, r3, #28
  104108:	e50b3010 	str	r3, [fp, #-16]

    /* use the current thread ID to label the shared memory */
    if (_shm_key == -1)_shm_key = (int)(unsigned long)rt_thread_self();
  10410c:	e30e301c 	movw	r3, #57372	; 0xe01c
  104110:	e3403014 	movt	r3, #20
  104114:	e5933000 	ldr	r3, [r3]
  104118:	e3730001 	cmn	r3, #1
  10411c:	1a000005 	bne	104138 <channel_compose_cmd+0x64>
  104120:	ebfff833 	bl	1021f4 <rt_thread_self>
  104124:	e1a03000 	mov	r3, r0
  104128:	e1a02003 	mov	r2, r3
  10412c:	e30e301c 	movw	r3, #57372	; 0xe01c
  104130:	e3403014 	movt	r3, #20
  104134:	e5832000 	str	r2, [r3]
    _shm_key = _shm_key + 2;
  104138:	e30e301c 	movw	r3, #57372	; 0xe01c
  10413c:	e3403014 	movt	r3, #20
  104140:	e5933000 	ldr	r3, [r3]
  104144:	e2832002 	add	r2, r3, #2
  104148:	e30e301c 	movw	r3, #57372	; 0xe01c
  10414c:	e3403014 	movt	r3, #20
  104150:	e5832000 	str	r2, [r3]

    shmid = lwp_shmget(_shm_key, len, 1);    /* create a new shared-memory */
  104154:	e30e301c 	movw	r3, #57372	; 0xe01c
  104158:	e3403014 	movt	r3, #20
  10415c:	e5933000 	ldr	r3, [r3]
  104160:	e3a02001 	mov	r2, #1
  104164:	e51b1010 	ldr	r1, [fp, #-16]
  104168:	e1a00003 	mov	r0, r3
  10416c:	ebfff74d 	bl	101ea8 <lwp_shmget>
  104170:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
    if (shmid == -1)
  104174:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  104178:	e3730001 	cmn	r3, #1
  10417c:	1a00000a 	bne	1041ac <channel_compose_cmd+0xd8>
    {
        rt_kprintf("%s :Fail to allocate a shared memory! _shm_key %ld\n",__func__,_shm_key);
  104180:	e30e301c 	movw	r3, #57372	; 0xe01c
  104184:	e3403014 	movt	r3, #20
  104188:	e5933000 	ldr	r3, [r3]
  10418c:	e1a02003 	mov	r2, r3
  104190:	e3051ae8 	movw	r1, #23272	; 0x5ae8
  104194:	e3401014 	movt	r1, #20
  104198:	e3050a78 	movw	r0, #23160	; 0x5a78
  10419c:	e3400014 	movt	r0, #20
  1041a0:	ebfffbdb 	bl	103114 <rt_kprintf>
        return -1;
  1041a4:	e3e03000 	mvn	r3, #0
  1041a8:	ea000027 	b	10424c <channel_compose_cmd+0x178>
    }

    /* get the start address of the shared memory */
    shm_vaddr = lwp_shmat(shmid, NULL);
  1041ac:	e3a01000 	mov	r1, #0
  1041b0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1041b4:	ebfff755 	bl	101f10 <lwp_shmat>
  1041b8:	e50b0008 	str	r0, [fp, #-8]
    if (shm_vaddr == NULL)
  1041bc:	e51b3008 	ldr	r3, [fp, #-8]
  1041c0:	e3530000 	cmp	r3, #0
  1041c4:	1a000006 	bne	1041e4 <channel_compose_cmd+0x110>
    {
        printf("The allocated shared memory doesn't have a valid address!\n");
  1041c8:	e3050aac 	movw	r0, #23212	; 0x5aac
  1041cc:	e3400014 	movt	r0, #20
  1041d0:	eb00e986 	bl	13e7f0 <puts>
        lwp_shmrm(shmid);
  1041d4:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1041d8:	ebfff741 	bl	101ee4 <lwp_shmrm>
        return -1;
  1041dc:	e3e03000 	mvn	r3, #0
  1041e0:	ea000019 	b	10424c <channel_compose_cmd+0x178>
    }

    /* prepare the command structure */
    pcmd = (struct channel_cmd *) shm_vaddr;
  1041e4:	e51b3008 	ldr	r3, [fp, #-8]
  1041e8:	e50b300c 	str	r3, [fp, #-12]

    pcmd->cmd = cmd;
  1041ec:	e51b300c 	ldr	r3, [fp, #-12]
  1041f0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1041f4:	e5832000 	str	r2, [r3]
    pcmd->argv[0] = arg0;
  1041f8:	e51b300c 	ldr	r3, [fp, #-12]
  1041fc:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  104200:	e5832004 	str	r2, [r3, #4]
    pcmd->argv[1] = arg1;
  104204:	e51b300c 	ldr	r3, [fp, #-12]
  104208:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  10420c:	e5832008 	str	r2, [r3, #8]
    pcmd->argv[2] = arg2;
  104210:	e51b300c 	ldr	r3, [fp, #-12]
  104214:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  104218:	e583200c 	str	r2, [r3, #12]
    pcmd->argv[3] = arg3;
  10421c:	e51b300c 	ldr	r3, [fp, #-12]
  104220:	e59b2004 	ldr	r2, [fp, #4]
  104224:	e5832010 	str	r2, [r3, #16]
    pcmd->argv[4] = arg4;
  104228:	e51b300c 	ldr	r3, [fp, #-12]
  10422c:	e59b2008 	ldr	r2, [fp, #8]
  104230:	e5832014 	str	r2, [r3, #20]
    pcmd->argv[5] = arg5;
  104234:	e51b300c 	ldr	r3, [fp, #-12]
  104238:	e59b200c 	ldr	r2, [fp, #12]
  10423c:	e5832018 	str	r2, [r3, #24]

    lwp_shmdt(shm_vaddr);
  104240:	e51b0008 	ldr	r0, [fp, #-8]
  104244:	ebfff73e 	bl	101f44 <lwp_shmdt>

    return shmid;
  104248:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
  10424c:	e1a00003 	mov	r0, r3
  104250:	e24bd004 	sub	sp, fp, #4
  104254:	e8bd8800 	pop	{fp, pc}

00104258 <channel_cmd_send_recv>:
{
  104258:	e92d4800 	push	{fp, lr}
  10425c:	e28db004 	add	fp, sp, #4
  104260:	e24dd018 	sub	sp, sp, #24
  104264:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  104268:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(channel >= 0);
  10426c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  104270:	e3530000 	cmp	r3, #0
  104274:	aa000005 	bge	104290 <channel_cmd_send_recv+0x38>
  104278:	e3a0200a 	mov	r2, #10
  10427c:	e3051b48 	movw	r1, #23368	; 0x5b48
  104280:	e3401014 	movt	r1, #20
  104284:	e3050afc 	movw	r0, #23292	; 0x5afc
  104288:	e3400014 	movt	r0, #20
  10428c:	ebfffcc1 	bl	103598 <rt_assert_handler>
    chn_msg.type   = RT_CHANNEL_RAW;
  104290:	e3a03000 	mov	r3, #0
  104294:	e50b3010 	str	r3, [fp, #-16]
    chn_msg.u.d    = cmd;
  104298:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10429c:	e50b300c 	str	r3, [fp, #-12]
    rt_channel_send_recv(channel, &chn_msg, &chn_msg);
  1042a0:	e24b2014 	sub	r2, fp, #20
  1042a4:	e24b3014 	sub	r3, fp, #20
  1042a8:	e1a01003 	mov	r1, r3
  1042ac:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1042b0:	ebffefb0 	bl	100178 <rt_channel_send_recv>
    return chn_msg.u.d;
  1042b4:	e51b300c 	ldr	r3, [fp, #-12]
}
  1042b8:	e1a00003 	mov	r0, r3
  1042bc:	e24bd004 	sub	sp, fp, #4
  1042c0:	e8bd8800 	pop	{fp, pc}

001042c4 <channel_cmd_recv>:
{
  1042c4:	e92d4800 	push	{fp, lr}
  1042c8:	e28db004 	add	fp, sp, #4
  1042cc:	e24dd018 	sub	sp, sp, #24
  1042d0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    RT_ASSERT(channel >= 0);
  1042d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1042d8:	e3530000 	cmp	r3, #0
  1042dc:	aa000005 	bge	1042f8 <channel_cmd_recv+0x34>
  1042e0:	e3a02027 	mov	r2, #39	; 0x27
  1042e4:	e3051b34 	movw	r1, #23348	; 0x5b34
  1042e8:	e3401014 	movt	r1, #20
  1042ec:	e3050afc 	movw	r0, #23292	; 0x5afc
  1042f0:	e3400014 	movt	r0, #20
  1042f4:	ebfffca7 	bl	103598 <rt_assert_handler>
    chn_msg.type = RT_CHANNEL_RAW;
  1042f8:	e3a03000 	mov	r3, #0
  1042fc:	e50b3010 	str	r3, [fp, #-16]
    rt_channel_recv(channel, &chn_msg);
  104300:	e24b3014 	sub	r3, fp, #20
  104304:	e1a01003 	mov	r1, r3
  104308:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  10430c:	ebffefd6 	bl	10026c <rt_channel_recv>
    return chn_msg.u.d;
  104310:	e51b300c 	ldr	r3, [fp, #-12]
}
  104314:	e1a00003 	mov	r0, r3
  104318:	e24bd004 	sub	sp, fp, #4
  10431c:	e8bd8800 	pop	{fp, pc}

00104320 <ipc_service_init>:
const char *ueth_srv_name = "ueth_srv";
static int ueth_int_channel = -1;
const char *ueth_int_name = "ueth_int";

rt_err_t ipc_service_init()
{
  104320:	e92d4800 	push	{fp, lr}
  104324:	e28db004 	add	fp, sp, #4
    ueth_ueth_srv_channel = rt_channel_open(ueth_srv_name, O_RDWR);
  104328:	e30e3024 	movw	r3, #57380	; 0xe024
  10432c:	e3403014 	movt	r3, #20
  104330:	e5933000 	ldr	r3, [r3]
  104334:	e3a01002 	mov	r1, #2
  104338:	e1a00003 	mov	r0, r3
  10433c:	ebffef75 	bl	100118 <rt_channel_open>
  104340:	e1a02000 	mov	r2, r0
  104344:	e30e3020 	movw	r3, #57376	; 0xe020
  104348:	e3403014 	movt	r3, #20
  10434c:	e5832000 	str	r2, [r3]
    if (ueth_ueth_srv_channel < 0)
  104350:	e30e3020 	movw	r3, #57376	; 0xe020
  104354:	e3403014 	movt	r3, #20
  104358:	e5933000 	ldr	r3, [r3]
  10435c:	e3530000 	cmp	r3, #0
  104360:	aa000008 	bge	104388 <ipc_service_init+0x68>
    {
        printf("open %s failed\n", ueth_srv_name);
  104364:	e30e3024 	movw	r3, #57380	; 0xe024
  104368:	e3403014 	movt	r3, #20
  10436c:	e5933000 	ldr	r3, [r3]
  104370:	e1a01003 	mov	r1, r3
  104374:	e3050b24 	movw	r0, #23332	; 0x5b24
  104378:	e3400014 	movt	r0, #20
  10437c:	eb00e90d 	bl	13e7b8 <printf>
        return RT_ERROR;
  104380:	e3a03001 	mov	r3, #1
  104384:	ea000018 	b	1043ec <ipc_service_init+0xcc>
    }

    ueth_int_channel = rt_channel_open(ueth_int_name, O_RDWR);
  104388:	e30e302c 	movw	r3, #57388	; 0xe02c
  10438c:	e3403014 	movt	r3, #20
  104390:	e5933000 	ldr	r3, [r3]
  104394:	e3a01002 	mov	r1, #2
  104398:	e1a00003 	mov	r0, r3
  10439c:	ebffef5d 	bl	100118 <rt_channel_open>
  1043a0:	e1a02000 	mov	r2, r0
  1043a4:	e30e3028 	movw	r3, #57384	; 0xe028
  1043a8:	e3403014 	movt	r3, #20
  1043ac:	e5832000 	str	r2, [r3]
    if (ueth_int_channel < 0)
  1043b0:	e30e3028 	movw	r3, #57384	; 0xe028
  1043b4:	e3403014 	movt	r3, #20
  1043b8:	e5933000 	ldr	r3, [r3]
  1043bc:	e3530000 	cmp	r3, #0
  1043c0:	aa000008 	bge	1043e8 <ipc_service_init+0xc8>
    {
        printf("open %s failed\n", ueth_int_name);
  1043c4:	e30e302c 	movw	r3, #57388	; 0xe02c
  1043c8:	e3403014 	movt	r3, #20
  1043cc:	e5933000 	ldr	r3, [r3]
  1043d0:	e1a01003 	mov	r1, r3
  1043d4:	e3050b24 	movw	r0, #23332	; 0x5b24
  1043d8:	e3400014 	movt	r0, #20
  1043dc:	eb00e8f5 	bl	13e7b8 <printf>
        return RT_ERROR;
  1043e0:	e3a03001 	mov	r3, #1
  1043e4:	ea000000 	b	1043ec <ipc_service_init+0xcc>
    }

    return RT_EOK;
  1043e8:	e3a03000 	mov	r3, #0
}
  1043ec:	e1a00003 	mov	r0, r3
  1043f0:	e8bd8800 	pop	{fp, pc}

001043f4 <ueth_int_recv>:

void ueth_int_recv(void)
{
  1043f4:	e92d4800 	push	{fp, lr}
  1043f8:	e28db004 	add	fp, sp, #4
    channel_cmd_recv(ueth_int_channel);
  1043fc:	e30e3028 	movw	r3, #57384	; 0xe028
  104400:	e3403014 	movt	r3, #20
  104404:	e5933000 	ldr	r3, [r3]
  104408:	e1a00003 	mov	r0, r3
  10440c:	ebffffac 	bl	1042c4 <channel_cmd_recv>
}
  104410:	e320f000 	nop	{0}
  104414:	e8bd8800 	pop	{fp, pc}

00104418 <ueth_v2p>:

void *ueth_v2p(void * addr)
{
  104418:	e92d4800 	push	{fp, lr}
  10441c:	e28db004 	add	fp, sp, #4
  104420:	e24dd028 	sub	sp, sp, #40	; 0x28
  104424:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    void* thread_self = rt_thread_self();
  104428:	ebfff771 	bl	1021f4 <rt_thread_self>
  10442c:	e50b000c 	str	r0, [fp, #-12]
    int shmid = channel_compose_cmd3(UETH_V2P_REQ, (void*)0, thread_self, addr, 0);
  104430:	e3a03000 	mov	r3, #0
  104434:	e58d300c 	str	r3, [sp, #12]
  104438:	e3a03000 	mov	r3, #0
  10443c:	e58d3008 	str	r3, [sp, #8]
  104440:	e3a03000 	mov	r3, #0
  104444:	e58d3004 	str	r3, [sp, #4]
  104448:	e3a03000 	mov	r3, #0
  10444c:	e58d3000 	str	r3, [sp]
  104450:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  104454:	e51b200c 	ldr	r2, [fp, #-12]
  104458:	e3a01000 	mov	r1, #0
  10445c:	e3a00005 	mov	r0, #5
  104460:	ebffff1b 	bl	1040d4 <channel_compose_cmd>
  104464:	e50b0010 	str	r0, [fp, #-16]
    void *res = RT_NULL;
  104468:	e3a03000 	mov	r3, #0
  10446c:	e50b3008 	str	r3, [fp, #-8]
    struct channel_cmd *cmd  = (struct channel_cmd *)lwp_shmat(shmid, NULL);
  104470:	e3a01000 	mov	r1, #0
  104474:	e51b0010 	ldr	r0, [fp, #-16]
  104478:	ebfff6a4 	bl	101f10 <lwp_shmat>
  10447c:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
    if (cmd) 
  104480:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  104484:	e3530000 	cmp	r3, #0
  104488:	0a000009 	beq	1044b4 <ueth_v2p+0x9c>
    {
        res = channel_cmd_send_recv(ueth_ueth_srv_channel, (void*)(size_t)shmid);
  10448c:	e30e3020 	movw	r3, #57376	; 0xe020
  104490:	e3403014 	movt	r3, #20
  104494:	e5933000 	ldr	r3, [r3]
  104498:	e51b2010 	ldr	r2, [fp, #-16]
  10449c:	e1a01002 	mov	r1, r2
  1044a0:	e1a00003 	mov	r0, r3
  1044a4:	ebffff6b 	bl	104258 <channel_cmd_send_recv>
  1044a8:	e50b0008 	str	r0, [fp, #-8]
        lwp_shmdt(cmd);
  1044ac:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1044b0:	ebfff6a3 	bl	101f44 <lwp_shmdt>
    }

    lwp_shmrm(shmid);
  1044b4:	e51b0010 	ldr	r0, [fp, #-16]
  1044b8:	ebfff689 	bl	101ee4 <lwp_shmrm>
    return res;
  1044bc:	e51b3008 	ldr	r3, [fp, #-8]

}
  1044c0:	e1a00003 	mov	r0, r3
  1044c4:	e24bd004 	sub	sp, fp, #4
  1044c8:	e8bd8800 	pop	{fp, pc}

001044cc <ueth_remap>:

void *ueth_remap(void * addr, int type, size_t size) 
{
  1044cc:	e92d4800 	push	{fp, lr}
  1044d0:	e28db004 	add	fp, sp, #4
  1044d4:	e24dd030 	sub	sp, sp, #48	; 0x30
  1044d8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1044dc:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  1044e0:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
    void* thread_self = rt_thread_self();
  1044e4:	ebfff742 	bl	1021f4 <rt_thread_self>
  1044e8:	e50b000c 	str	r0, [fp, #-12]
    int shmid = channel_compose_cmd4(UETH_REMAP_REQ, (void*)0, thread_self, (void*)type, addr, sizeof(size_t));
  1044ec:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1044f0:	e3a03004 	mov	r3, #4
  1044f4:	e58d300c 	str	r3, [sp, #12]
  1044f8:	e3a03000 	mov	r3, #0
  1044fc:	e58d3008 	str	r3, [sp, #8]
  104500:	e3a03000 	mov	r3, #0
  104504:	e58d3004 	str	r3, [sp, #4]
  104508:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10450c:	e58d3000 	str	r3, [sp]
  104510:	e1a03002 	mov	r3, r2
  104514:	e51b200c 	ldr	r2, [fp, #-12]
  104518:	e3a01000 	mov	r1, #0
  10451c:	e3a00001 	mov	r0, #1
  104520:	ebfffeeb 	bl	1040d4 <channel_compose_cmd>
  104524:	e50b0010 	str	r0, [fp, #-16]
    void *res = RT_NULL;
  104528:	e3a03000 	mov	r3, #0
  10452c:	e50b3008 	str	r3, [fp, #-8]
    struct channel_cmd *cmd  = (struct channel_cmd *)lwp_shmat(shmid, NULL);
  104530:	e3a01000 	mov	r1, #0
  104534:	e51b0010 	ldr	r0, [fp, #-16]
  104538:	ebfff674 	bl	101f10 <lwp_shmat>
  10453c:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
    if (cmd) 
  104540:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  104544:	e3530000 	cmp	r3, #0
  104548:	0a00000d 	beq	104584 <ueth_remap+0xb8>
    {
        memcpy(CHANNEL_CMD_DATA(cmd), (void*)&size, sizeof(size_t));
  10454c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  104550:	e283301c 	add	r3, r3, #28
  104554:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  104558:	e5832000 	str	r2, [r3]
        res = channel_cmd_send_recv(ueth_ueth_srv_channel, (void*)(size_t)shmid);
  10455c:	e30e3020 	movw	r3, #57376	; 0xe020
  104560:	e3403014 	movt	r3, #20
  104564:	e5933000 	ldr	r3, [r3]
  104568:	e51b2010 	ldr	r2, [fp, #-16]
  10456c:	e1a01002 	mov	r1, r2
  104570:	e1a00003 	mov	r0, r3
  104574:	ebffff37 	bl	104258 <channel_cmd_send_recv>
  104578:	e50b0008 	str	r0, [fp, #-8]
        lwp_shmdt(cmd);
  10457c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  104580:	ebfff66f 	bl	101f44 <lwp_shmdt>
    }

    lwp_shmrm(shmid);
  104584:	e51b0010 	ldr	r0, [fp, #-16]
  104588:	ebfff655 	bl	101ee4 <lwp_shmrm>
    return res;
  10458c:	e51b3008 	ldr	r3, [fp, #-8]
}
  104590:	e1a00003 	mov	r0, r3
  104594:	e24bd004 	sub	sp, fp, #4
  104598:	e8bd8800 	pop	{fp, pc}

0010459c <ueth_gpioinit>:

void ueth_gpioinit(void *gpio, size_t size) 
{
  10459c:	e92d4800 	push	{fp, lr}
  1045a0:	e28db004 	add	fp, sp, #4
  1045a4:	e24dd020 	sub	sp, sp, #32
  1045a8:	e50b0010 	str	r0, [fp, #-16]
  1045ac:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    int shmid = channel_compose_cmd1(UETH_GPIOINIT_REQ, (void*)0, size);
  1045b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1045b4:	e58d300c 	str	r3, [sp, #12]
  1045b8:	e3a03000 	mov	r3, #0
  1045bc:	e58d3008 	str	r3, [sp, #8]
  1045c0:	e3a03000 	mov	r3, #0
  1045c4:	e58d3004 	str	r3, [sp, #4]
  1045c8:	e3a03000 	mov	r3, #0
  1045cc:	e58d3000 	str	r3, [sp]
  1045d0:	e3a03000 	mov	r3, #0
  1045d4:	e3a02000 	mov	r2, #0
  1045d8:	e3a01000 	mov	r1, #0
  1045dc:	e3a00002 	mov	r0, #2
  1045e0:	ebfffebb 	bl	1040d4 <channel_compose_cmd>
  1045e4:	e50b0008 	str	r0, [fp, #-8]
    struct channel_cmd *cmd = (struct channel_cmd*)lwp_shmat(shmid, NULL);
  1045e8:	e3a01000 	mov	r1, #0
  1045ec:	e51b0008 	ldr	r0, [fp, #-8]
  1045f0:	ebfff646 	bl	101f10 <lwp_shmat>
  1045f4:	e50b000c 	str	r0, [fp, #-12]
    if (cmd)
  1045f8:	e51b300c 	ldr	r3, [fp, #-12]
  1045fc:	e3530000 	cmp	r3, #0
  104600:	0a00000e 	beq	104640 <ueth_gpioinit+0xa4>
    {
        memcpy(CHANNEL_CMD_DATA(cmd), gpio, size);
  104604:	e51b300c 	ldr	r3, [fp, #-12]
  104608:	e283301c 	add	r3, r3, #28
  10460c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  104610:	e51b1010 	ldr	r1, [fp, #-16]
  104614:	e1a00003 	mov	r0, r3
  104618:	eb00f25d 	bl	140f94 <memcpy>
        channel_cmd_send_recv(ueth_ueth_srv_channel, (void *)(size_t)shmid);
  10461c:	e30e3020 	movw	r3, #57376	; 0xe020
  104620:	e3403014 	movt	r3, #20
  104624:	e5933000 	ldr	r3, [r3]
  104628:	e51b2008 	ldr	r2, [fp, #-8]
  10462c:	e1a01002 	mov	r1, r2
  104630:	e1a00003 	mov	r0, r3
  104634:	ebffff07 	bl	104258 <channel_cmd_send_recv>
        lwp_shmdt(cmd);
  104638:	e51b000c 	ldr	r0, [fp, #-12]
  10463c:	ebfff640 	bl	101f44 <lwp_shmdt>
    }

    lwp_shmrm(shmid);
  104640:	e51b0008 	ldr	r0, [fp, #-8]
  104644:	ebfff626 	bl	101ee4 <lwp_shmrm>
}
  104648:	e320f000 	nop	{0}
  10464c:	e24bd004 	sub	sp, fp, #4
  104650:	e8bd8800 	pop	{fp, pc}

00104654 <ueth_init_clock>:

void ueth_init_clock() 
{
  104654:	e92d4800 	push	{fp, lr}
  104658:	e28db004 	add	fp, sp, #4
  10465c:	e24dd018 	sub	sp, sp, #24
    int shmid = channel_compose_cmd1(UETH_CLOCKINIT_REQ, (void*)0, 0);
  104660:	e3a03000 	mov	r3, #0
  104664:	e58d300c 	str	r3, [sp, #12]
  104668:	e3a03000 	mov	r3, #0
  10466c:	e58d3008 	str	r3, [sp, #8]
  104670:	e3a03000 	mov	r3, #0
  104674:	e58d3004 	str	r3, [sp, #4]
  104678:	e3a03000 	mov	r3, #0
  10467c:	e58d3000 	str	r3, [sp]
  104680:	e3a03000 	mov	r3, #0
  104684:	e3a02000 	mov	r2, #0
  104688:	e3a01000 	mov	r1, #0
  10468c:	e3a00003 	mov	r0, #3
  104690:	ebfffe8f 	bl	1040d4 <channel_compose_cmd>
  104694:	e50b0008 	str	r0, [fp, #-8]
    struct channel_cmd *cmd = (struct channel_cmd*)lwp_shmat(shmid, NULL);
  104698:	e3a01000 	mov	r1, #0
  10469c:	e51b0008 	ldr	r0, [fp, #-8]
  1046a0:	ebfff61a 	bl	101f10 <lwp_shmat>
  1046a4:	e50b000c 	str	r0, [fp, #-12]
    if (cmd)
  1046a8:	e51b300c 	ldr	r3, [fp, #-12]
  1046ac:	e3530000 	cmp	r3, #0
  1046b0:	0a000008 	beq	1046d8 <ueth_init_clock+0x84>
    {
        channel_cmd_send_recv(ueth_ueth_srv_channel, (void *)(size_t)shmid);
  1046b4:	e30e3020 	movw	r3, #57376	; 0xe020
  1046b8:	e3403014 	movt	r3, #20
  1046bc:	e5933000 	ldr	r3, [r3]
  1046c0:	e51b2008 	ldr	r2, [fp, #-8]
  1046c4:	e1a01002 	mov	r1, r2
  1046c8:	e1a00003 	mov	r0, r3
  1046cc:	ebfffee1 	bl	104258 <channel_cmd_send_recv>
        lwp_shmdt(cmd);
  1046d0:	e51b000c 	ldr	r0, [fp, #-12]
  1046d4:	ebfff61a 	bl	101f44 <lwp_shmdt>
    }

    lwp_shmrm(shmid);
  1046d8:	e51b0008 	ldr	r0, [fp, #-8]
  1046dc:	ebfff600 	bl	101ee4 <lwp_shmrm>
}
  1046e0:	e320f000 	nop	{0}
  1046e4:	e24bd004 	sub	sp, fp, #4
  1046e8:	e8bd8800 	pop	{fp, pc}

001046ec <ueth_dcache_clean>:

void ueth_dcache_clean(void *paddr, size_t size)
{
  1046ec:	e92d4800 	push	{fp, lr}
  1046f0:	e28db004 	add	fp, sp, #4
  1046f4:	e24dd020 	sub	sp, sp, #32
  1046f8:	e50b0010 	str	r0, [fp, #-16]
  1046fc:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    int shmid = channel_compose_cmd3(UETH_DCACHE_REQ, (void*)0, (void*)UETH_DCACHE_CLEAN, paddr, sizeof(size_t));
  104700:	e3a03004 	mov	r3, #4
  104704:	e58d300c 	str	r3, [sp, #12]
  104708:	e3a03000 	mov	r3, #0
  10470c:	e58d3008 	str	r3, [sp, #8]
  104710:	e3a03000 	mov	r3, #0
  104714:	e58d3004 	str	r3, [sp, #4]
  104718:	e3a03000 	mov	r3, #0
  10471c:	e58d3000 	str	r3, [sp]
  104720:	e51b3010 	ldr	r3, [fp, #-16]
  104724:	e3a02001 	mov	r2, #1
  104728:	e3a01000 	mov	r1, #0
  10472c:	e3a00004 	mov	r0, #4
  104730:	ebfffe67 	bl	1040d4 <channel_compose_cmd>
  104734:	e50b0008 	str	r0, [fp, #-8]
    struct channel_cmd *cmd = (struct channel_cmd*)lwp_shmat(shmid, NULL);
  104738:	e3a01000 	mov	r1, #0
  10473c:	e51b0008 	ldr	r0, [fp, #-8]
  104740:	ebfff5f2 	bl	101f10 <lwp_shmat>
  104744:	e50b000c 	str	r0, [fp, #-12]
    if (cmd)
  104748:	e51b300c 	ldr	r3, [fp, #-12]
  10474c:	e3530000 	cmp	r3, #0
  104750:	0a00000c 	beq	104788 <ueth_dcache_clean+0x9c>
    {
        memcpy(CHANNEL_CMD_DATA(cmd), (void*)&size, sizeof(size_t));
  104754:	e51b300c 	ldr	r3, [fp, #-12]
  104758:	e283301c 	add	r3, r3, #28
  10475c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  104760:	e5832000 	str	r2, [r3]
        channel_cmd_send_recv(ueth_ueth_srv_channel, (void *)(size_t)shmid);
  104764:	e30e3020 	movw	r3, #57376	; 0xe020
  104768:	e3403014 	movt	r3, #20
  10476c:	e5933000 	ldr	r3, [r3]
  104770:	e51b2008 	ldr	r2, [fp, #-8]
  104774:	e1a01002 	mov	r1, r2
  104778:	e1a00003 	mov	r0, r3
  10477c:	ebfffeb5 	bl	104258 <channel_cmd_send_recv>
        lwp_shmdt(cmd);
  104780:	e51b000c 	ldr	r0, [fp, #-12]
  104784:	ebfff5ee 	bl	101f44 <lwp_shmdt>
    }

    lwp_shmrm(shmid);
  104788:	e51b0008 	ldr	r0, [fp, #-8]
  10478c:	ebfff5d4 	bl	101ee4 <lwp_shmrm>
    return;
  104790:	e320f000 	nop	{0}
}
  104794:	e24bd004 	sub	sp, fp, #4
  104798:	e8bd8800 	pop	{fp, pc}

0010479c <ueth_dcache_invalid>:

void ueth_dcache_invalid(void *paddr, size_t size)
{
  10479c:	e92d4800 	push	{fp, lr}
  1047a0:	e28db004 	add	fp, sp, #4
  1047a4:	e24dd020 	sub	sp, sp, #32
  1047a8:	e50b0010 	str	r0, [fp, #-16]
  1047ac:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    int shmid = channel_compose_cmd3(UETH_DCACHE_REQ, (void*)0, (void*)UETH_DCACHE_INVALID, paddr, sizeof(size_t));
  1047b0:	e3a03004 	mov	r3, #4
  1047b4:	e58d300c 	str	r3, [sp, #12]
  1047b8:	e3a03000 	mov	r3, #0
  1047bc:	e58d3008 	str	r3, [sp, #8]
  1047c0:	e3a03000 	mov	r3, #0
  1047c4:	e58d3004 	str	r3, [sp, #4]
  1047c8:	e3a03000 	mov	r3, #0
  1047cc:	e58d3000 	str	r3, [sp]
  1047d0:	e51b3010 	ldr	r3, [fp, #-16]
  1047d4:	e3a02002 	mov	r2, #2
  1047d8:	e3a01000 	mov	r1, #0
  1047dc:	e3a00004 	mov	r0, #4
  1047e0:	ebfffe3b 	bl	1040d4 <channel_compose_cmd>
  1047e4:	e50b0008 	str	r0, [fp, #-8]
    struct channel_cmd *cmd = (struct channel_cmd*)lwp_shmat(shmid, NULL);
  1047e8:	e3a01000 	mov	r1, #0
  1047ec:	e51b0008 	ldr	r0, [fp, #-8]
  1047f0:	ebfff5c6 	bl	101f10 <lwp_shmat>
  1047f4:	e50b000c 	str	r0, [fp, #-12]
    if (cmd)
  1047f8:	e51b300c 	ldr	r3, [fp, #-12]
  1047fc:	e3530000 	cmp	r3, #0
  104800:	0a00000c 	beq	104838 <ueth_dcache_invalid+0x9c>
    {
        memcpy(CHANNEL_CMD_DATA(cmd), (void*)&size, sizeof(size_t));
  104804:	e51b300c 	ldr	r3, [fp, #-12]
  104808:	e283301c 	add	r3, r3, #28
  10480c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  104810:	e5832000 	str	r2, [r3]
        channel_cmd_send_recv(ueth_ueth_srv_channel, (void *)(size_t)shmid);
  104814:	e30e3020 	movw	r3, #57376	; 0xe020
  104818:	e3403014 	movt	r3, #20
  10481c:	e5933000 	ldr	r3, [r3]
  104820:	e51b2008 	ldr	r2, [fp, #-8]
  104824:	e1a01002 	mov	r1, r2
  104828:	e1a00003 	mov	r0, r3
  10482c:	ebfffe89 	bl	104258 <channel_cmd_send_recv>
        lwp_shmdt(cmd);
  104830:	e51b000c 	ldr	r0, [fp, #-12]
  104834:	ebfff5c2 	bl	101f44 <lwp_shmdt>
    }

    lwp_shmrm(shmid);
  104838:	e51b0008 	ldr	r0, [fp, #-8]
  10483c:	ebfff5a8 	bl	101ee4 <lwp_shmrm>
    return;
  104840:	e320f000 	nop	{0}
}
  104844:	e24bd004 	sub	sp, fp, #4
  104848:	e8bd8800 	pop	{fp, pc}

0010484c <ueth_hw_interrupt_install>:

void ueth_hw_interrupt_install(int vector, void * param) {
  10484c:	e92d4800 	push	{fp, lr}
  104850:	e28db004 	add	fp, sp, #4
  104854:	e24dd020 	sub	sp, sp, #32
  104858:	e50b0010 	str	r0, [fp, #-16]
  10485c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    int shmid = channel_compose_cmd3(UETH_INSTALL_INTERRUPT_REQ, (void*)0, (void*)vector, param, 0);
  104860:	e51b2010 	ldr	r2, [fp, #-16]
  104864:	e3a03000 	mov	r3, #0
  104868:	e58d300c 	str	r3, [sp, #12]
  10486c:	e3a03000 	mov	r3, #0
  104870:	e58d3008 	str	r3, [sp, #8]
  104874:	e3a03000 	mov	r3, #0
  104878:	e58d3004 	str	r3, [sp, #4]
  10487c:	e3a03000 	mov	r3, #0
  104880:	e58d3000 	str	r3, [sp]
  104884:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  104888:	e3a01000 	mov	r1, #0
  10488c:	e3a00006 	mov	r0, #6
  104890:	ebfffe0f 	bl	1040d4 <channel_compose_cmd>
  104894:	e50b0008 	str	r0, [fp, #-8]
    struct channel_cmd *cmd = (struct channel_cmd*)lwp_shmat(shmid, NULL);
  104898:	e3a01000 	mov	r1, #0
  10489c:	e51b0008 	ldr	r0, [fp, #-8]
  1048a0:	ebfff59a 	bl	101f10 <lwp_shmat>
  1048a4:	e50b000c 	str	r0, [fp, #-12]
    if (cmd)
  1048a8:	e51b300c 	ldr	r3, [fp, #-12]
  1048ac:	e3530000 	cmp	r3, #0
  1048b0:	0a000008 	beq	1048d8 <ueth_hw_interrupt_install+0x8c>
    {
        channel_cmd_send_recv(ueth_ueth_srv_channel, (void *)(size_t)shmid);
  1048b4:	e30e3020 	movw	r3, #57376	; 0xe020
  1048b8:	e3403014 	movt	r3, #20
  1048bc:	e5933000 	ldr	r3, [r3]
  1048c0:	e51b2008 	ldr	r2, [fp, #-8]
  1048c4:	e1a01002 	mov	r1, r2
  1048c8:	e1a00003 	mov	r0, r3
  1048cc:	ebfffe61 	bl	104258 <channel_cmd_send_recv>
        lwp_shmdt(cmd);
  1048d0:	e51b000c 	ldr	r0, [fp, #-12]
  1048d4:	ebfff59a 	bl	101f44 <lwp_shmdt>
        
    }
    
    lwp_shmrm(shmid);
  1048d8:	e51b0008 	ldr	r0, [fp, #-8]
  1048dc:	ebfff580 	bl	101ee4 <lwp_shmrm>
  1048e0:	e320f000 	nop	{0}
  1048e4:	e24bd004 	sub	sp, fp, #4
  1048e8:	e8bd8800 	pop	{fp, pc}

001048ec <inet_ioctlsocket>:
// #include "af_inet.h"

#include "netdev.h"

int inet_ioctlsocket(int socket, long cmd, void *arg)
{
  1048ec:	e92d4800 	push	{fp, lr}
  1048f0:	e28db004 	add	fp, sp, #4
  1048f4:	e24dd010 	sub	sp, sp, #16
  1048f8:	e50b0008 	str	r0, [fp, #-8]
  1048fc:	e50b100c 	str	r1, [fp, #-12]
  104900:	e50b2010 	str	r2, [fp, #-16]
    switch (cmd)
  104904:	e51b300c 	ldr	r3, [fp, #-12]
  104908:	e2433003 	sub	r3, r3, #3
  10490c:	e3530001 	cmp	r3, #1
  104910:	8a000006 	bhi	104930 <inet_ioctlsocket+0x44>
    {
    case F_GETFL:
    case F_SETFL:
        return unet_fcntl(socket, cmd, (int)(unsigned long) arg);
  104914:	e51b3010 	ldr	r3, [fp, #-16]
  104918:	e1a02003 	mov	r2, r3
  10491c:	e51b100c 	ldr	r1, [fp, #-12]
  104920:	e51b0008 	ldr	r0, [fp, #-8]
  104924:	eb00123d 	bl	109220 <unet_fcntl>
  104928:	e1a03000 	mov	r3, r0
  10492c:	ea000004 	b	104944 <inet_ioctlsocket+0x58>

    default:
        return unet_ioctl(socket, cmd, arg);
  104930:	e51b2010 	ldr	r2, [fp, #-16]
  104934:	e51b100c 	ldr	r1, [fp, #-12]
  104938:	e51b0008 	ldr	r0, [fp, #-8]
  10493c:	eb001245 	bl	109258 <unet_ioctl>
  104940:	e1a03000 	mov	r3, r0
    }
}
  104944:	e1a00003 	mov	r0, r3
  104948:	e24bd004 	sub	sp, fp, #4
  10494c:	e8bd8800 	pop	{fp, pc}

00104950 <sal_unet_netdev_set_pf_info>:
    &unet_netdb_ops,
};

/* Set lwIP network interface device protocol family information */
int sal_unet_netdev_set_pf_info(struct netdev *netdev)
{
  104950:	e92d4800 	push	{fp, lr}
  104954:	e28db004 	add	fp, sp, #4
  104958:	e24dd008 	sub	sp, sp, #8
  10495c:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(netdev);
  104960:	e51b3008 	ldr	r3, [fp, #-8]
  104964:	e3530000 	cmp	r3, #0
  104968:	1a000005 	bne	104984 <sal_unet_netdev_set_pf_info+0x34>
  10496c:	e3a02086 	mov	r2, #134	; 0x86
  104970:	e3051bc4 	movw	r1, #23492	; 0x5bc4
  104974:	e3401014 	movt	r1, #20
  104978:	e3050bbc 	movw	r0, #23484	; 0x5bbc
  10497c:	e3400014 	movt	r0, #20
  104980:	ebfffb04 	bl	103598 <rt_assert_handler>

    netdev->sal_user_data = (void *)(unsigned long) &unet_inet_family;
  104984:	e51b2008 	ldr	r2, [fp, #-8]
  104988:	e3053bac 	movw	r3, #23468	; 0x5bac
  10498c:	e3403014 	movt	r3, #20
  104990:	e582303c 	str	r3, [r2, #60]	; 0x3c
    return 0;
  104994:	e3a03000 	mov	r3, #0
}
  104998:	e1a00003 	mov	r0, r3
  10499c:	e24bd004 	sub	sp, fp, #4
  1049a0:	e8bd8800 	pop	{fp, pc}

001049a4 <ueth_device_find>:
#define MAX_DEV_NUM 3
static eth_device_node ueth_dev_list[MAX_DEV_NUM];
static char ueth_dev_list_valid[MAX_DEV_NUM];

rt_device_t ueth_device_find(const char *name)
{
  1049a4:	e92d4800 	push	{fp, lr}
  1049a8:	e28db004 	add	fp, sp, #4
  1049ac:	e24dd010 	sub	sp, sp, #16
  1049b0:	e50b0010 	str	r0, [fp, #-16]
    for (int i = 0; i < MAX_DEV_NUM; i++)
  1049b4:	e3a03000 	mov	r3, #0
  1049b8:	e50b3008 	str	r3, [fp, #-8]
  1049bc:	ea00001f 	b	104a40 <ueth_device_find+0x9c>
    {
        if (ueth_dev_list_valid[i])
  1049c0:	e30e344c 	movw	r3, #58444	; 0xe44c
  1049c4:	e3403014 	movt	r3, #20
  1049c8:	e51b2008 	ldr	r2, [fp, #-8]
  1049cc:	e0833002 	add	r3, r3, r2
  1049d0:	e5d33000 	ldrb	r3, [r3]
  1049d4:	e3530000 	cmp	r3, #0
  1049d8:	0a000015 	beq	104a34 <ueth_device_find+0x90>
        {
            if (strncmp(ueth_dev_list[i].name, name, 8) == 0)
  1049dc:	e51b3008 	ldr	r3, [fp, #-8]
  1049e0:	e3a0200c 	mov	r2, #12
  1049e4:	e0020392 	mul	r2, r2, r3
  1049e8:	e30e3428 	movw	r3, #58408	; 0xe428
  1049ec:	e3403014 	movt	r3, #20
  1049f0:	e0823003 	add	r3, r2, r3
  1049f4:	e2833004 	add	r3, r3, #4
  1049f8:	e3a02008 	mov	r2, #8
  1049fc:	e51b1010 	ldr	r1, [fp, #-16]
  104a00:	e1a00003 	mov	r0, r3
  104a04:	eb00f357 	bl	141768 <strncmp>
  104a08:	e1a03000 	mov	r3, r0
  104a0c:	e3530000 	cmp	r3, #0
  104a10:	1a000007 	bne	104a34 <ueth_device_find+0x90>
            {  
                return ueth_dev_list[i].dev;
  104a14:	e30e3428 	movw	r3, #58408	; 0xe428
  104a18:	e3403014 	movt	r3, #20
  104a1c:	e51b2008 	ldr	r2, [fp, #-8]
  104a20:	e3a0100c 	mov	r1, #12
  104a24:	e0020291 	mul	r2, r1, r2
  104a28:	e0833002 	add	r3, r3, r2
  104a2c:	e5933000 	ldr	r3, [r3]
  104a30:	ea000006 	b	104a50 <ueth_device_find+0xac>
    for (int i = 0; i < MAX_DEV_NUM; i++)
  104a34:	e51b3008 	ldr	r3, [fp, #-8]
  104a38:	e2833001 	add	r3, r3, #1
  104a3c:	e50b3008 	str	r3, [fp, #-8]
  104a40:	e51b3008 	ldr	r3, [fp, #-8]
  104a44:	e3530002 	cmp	r3, #2
  104a48:	daffffdc 	ble	1049c0 <ueth_device_find+0x1c>
            }
        }
    }

    return RT_NULL;
  104a4c:	e3a03000 	mov	r3, #0
}
  104a50:	e1a00003 	mov	r0, r3
  104a54:	e24bd004 	sub	sp, fp, #4
  104a58:	e8bd8800 	pop	{fp, pc}

00104a5c <ueth_device_register>:

rt_err_t ueth_device_register(rt_device_t dev, const char *name, rt_uint16_t flags)
{
  104a5c:	e92d4800 	push	{fp, lr}
  104a60:	e28db004 	add	fp, sp, #4
  104a64:	e24dd018 	sub	sp, sp, #24
  104a68:	e50b0010 	str	r0, [fp, #-16]
  104a6c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  104a70:	e1a03002 	mov	r3, r2
  104a74:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
    if (dev == RT_NULL)
  104a78:	e51b3010 	ldr	r3, [fp, #-16]
  104a7c:	e3530000 	cmp	r3, #0
  104a80:	1a000001 	bne	104a8c <ueth_device_register+0x30>
        return -RT_ERROR;
  104a84:	e3e03000 	mvn	r3, #0
  104a88:	ea000042 	b	104b98 <ueth_device_register+0x13c>

    if (ueth_device_find(name) != RT_NULL)
  104a8c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  104a90:	ebffffc3 	bl	1049a4 <ueth_device_find>
  104a94:	e1a03000 	mov	r3, r0
  104a98:	e3530000 	cmp	r3, #0
  104a9c:	0a000001 	beq	104aa8 <ueth_device_register+0x4c>
        return -RT_ERROR;
  104aa0:	e3e03000 	mvn	r3, #0
  104aa4:	ea00003b 	b	104b98 <ueth_device_register+0x13c>

    int ueth_dev_list_index = 0;
  104aa8:	e3a03000 	mov	r3, #0
  104aac:	e50b3008 	str	r3, [fp, #-8]
    while (ueth_dev_list_index < MAX_DEV_NUM)
  104ab0:	ea000009 	b	104adc <ueth_device_register+0x80>
    {
        if (!ueth_dev_list_valid[ueth_dev_list_index])
  104ab4:	e30e344c 	movw	r3, #58444	; 0xe44c
  104ab8:	e3403014 	movt	r3, #20
  104abc:	e51b2008 	ldr	r2, [fp, #-8]
  104ac0:	e0833002 	add	r3, r3, r2
  104ac4:	e5d33000 	ldrb	r3, [r3]
  104ac8:	e3530000 	cmp	r3, #0
  104acc:	0a000006 	beq	104aec <ueth_device_register+0x90>
        {
            break;
        }
        ueth_dev_list_index++;
  104ad0:	e51b3008 	ldr	r3, [fp, #-8]
  104ad4:	e2833001 	add	r3, r3, #1
  104ad8:	e50b3008 	str	r3, [fp, #-8]
    while (ueth_dev_list_index < MAX_DEV_NUM)
  104adc:	e51b3008 	ldr	r3, [fp, #-8]
  104ae0:	e3530002 	cmp	r3, #2
  104ae4:	dafffff2 	ble	104ab4 <ueth_device_register+0x58>
  104ae8:	ea000000 	b	104af0 <ueth_device_register+0x94>
            break;
  104aec:	e320f000 	nop	{0}
    }

    if (ueth_dev_list_index == MAX_DEV_NUM)
  104af0:	e51b3008 	ldr	r3, [fp, #-8]
  104af4:	e3530003 	cmp	r3, #3
  104af8:	1a000001 	bne	104b04 <ueth_device_register+0xa8>
    {
        return -RT_ERROR;
  104afc:	e3e03000 	mvn	r3, #0
  104b00:	ea000024 	b	104b98 <ueth_device_register+0x13c>
    }
    
    strcpy(ueth_dev_list[ueth_dev_list_index].name, name);
  104b04:	e51b3008 	ldr	r3, [fp, #-8]
  104b08:	e3a0200c 	mov	r2, #12
  104b0c:	e0020392 	mul	r2, r2, r3
  104b10:	e30e3428 	movw	r3, #58408	; 0xe428
  104b14:	e3403014 	movt	r3, #20
  104b18:	e0823003 	add	r3, r2, r3
  104b1c:	e2833004 	add	r3, r3, #4
  104b20:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  104b24:	e1a00003 	mov	r0, r3
  104b28:	eb00f2d1 	bl	141674 <strcpy>
    ueth_dev_list[ueth_dev_list_index].dev = dev;
  104b2c:	e30e3428 	movw	r3, #58408	; 0xe428
  104b30:	e3403014 	movt	r3, #20
  104b34:	e51b2008 	ldr	r2, [fp, #-8]
  104b38:	e3a0100c 	mov	r1, #12
  104b3c:	e0020291 	mul	r2, r1, r2
  104b40:	e0833002 	add	r3, r3, r2
  104b44:	e51b2010 	ldr	r2, [fp, #-16]
  104b48:	e5832000 	str	r2, [r3]
    ueth_dev_list_valid[ueth_dev_list_index] = 1;
  104b4c:	e30e344c 	movw	r3, #58444	; 0xe44c
  104b50:	e3403014 	movt	r3, #20
  104b54:	e51b2008 	ldr	r2, [fp, #-8]
  104b58:	e0833002 	add	r3, r3, r2
  104b5c:	e3a02001 	mov	r2, #1
  104b60:	e5c32000 	strb	r2, [r3]
    dev->flag = flags;
  104b64:	e51b3010 	ldr	r3, [fp, #-16]
  104b68:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  104b6c:	e1c321bc 	strh	r2, [r3, #28]
    dev->ref_count = 0;
  104b70:	e51b3010 	ldr	r3, [fp, #-16]
  104b74:	e3a02000 	mov	r2, #0
  104b78:	e5c32020 	strb	r2, [r3, #32]
    dev->open_flag = 0;
  104b7c:	e51b3010 	ldr	r3, [fp, #-16]
  104b80:	e3a02000 	mov	r2, #0
  104b84:	e1c321be 	strh	r2, [r3, #30]

    dev->parent.type = RT_Object_Class_Device;
  104b88:	e51b3010 	ldr	r3, [fp, #-16]
  104b8c:	e3a02009 	mov	r2, #9
  104b90:	e5c32008 	strb	r2, [r3, #8]

    return RT_EOK;
  104b94:	e3a03000 	mov	r3, #0
}
  104b98:	e1a00003 	mov	r0, r3
  104b9c:	e24bd004 	sub	sp, fp, #4
  104ba0:	e8bd8800 	pop	{fp, pc}

00104ba4 <ueth_device_unregister>:

rt_err_t ueth_device_unregister(rt_device_t dev)
{
  104ba4:	e92d4800 	push	{fp, lr}
  104ba8:	e28db004 	add	fp, sp, #4
  104bac:	e24dd010 	sub	sp, sp, #16
  104bb0:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(dev != RT_NULL);
  104bb4:	e51b3010 	ldr	r3, [fp, #-16]
  104bb8:	e3530000 	cmp	r3, #0
  104bbc:	1a000005 	bne	104bd8 <ueth_device_unregister+0x34>
  104bc0:	e3a02048 	mov	r2, #72	; 0x48
  104bc4:	e3051c54 	movw	r1, #23636	; 0x5c54
  104bc8:	e3401014 	movt	r1, #20
  104bcc:	e3050be0 	movw	r0, #23520	; 0x5be0
  104bd0:	e3400014 	movt	r0, #20
  104bd4:	ebfffa6f 	bl	103598 <rt_assert_handler>
    RT_ASSERT(dev->parent.type == RT_Object_Class_Device);
  104bd8:	e51b3010 	ldr	r3, [fp, #-16]
  104bdc:	e5d33008 	ldrb	r3, [r3, #8]
  104be0:	e3530009 	cmp	r3, #9
  104be4:	0a000005 	beq	104c00 <ueth_device_unregister+0x5c>
  104be8:	e3a02049 	mov	r2, #73	; 0x49
  104bec:	e3051c54 	movw	r1, #23636	; 0x5c54
  104bf0:	e3401014 	movt	r1, #20
  104bf4:	e3050bf0 	movw	r0, #23536	; 0x5bf0
  104bf8:	e3400014 	movt	r0, #20
  104bfc:	ebfffa65 	bl	103598 <rt_assert_handler>

    for (int i = 0; i < MAX_DEV_NUM; i++)
  104c00:	e3a03000 	mov	r3, #0
  104c04:	e50b3008 	str	r3, [fp, #-8]
  104c08:	ea000019 	b	104c74 <ueth_device_unregister+0xd0>
    {
        if (ueth_dev_list_valid[i] && dev == ueth_dev_list[i].dev)
  104c0c:	e30e344c 	movw	r3, #58444	; 0xe44c
  104c10:	e3403014 	movt	r3, #20
  104c14:	e51b2008 	ldr	r2, [fp, #-8]
  104c18:	e0833002 	add	r3, r3, r2
  104c1c:	e5d33000 	ldrb	r3, [r3]
  104c20:	e3530000 	cmp	r3, #0
  104c24:	0a00000f 	beq	104c68 <ueth_device_unregister+0xc4>
  104c28:	e30e3428 	movw	r3, #58408	; 0xe428
  104c2c:	e3403014 	movt	r3, #20
  104c30:	e51b2008 	ldr	r2, [fp, #-8]
  104c34:	e3a0100c 	mov	r1, #12
  104c38:	e0020291 	mul	r2, r1, r2
  104c3c:	e0833002 	add	r3, r3, r2
  104c40:	e5933000 	ldr	r3, [r3]
  104c44:	e51b2010 	ldr	r2, [fp, #-16]
  104c48:	e1520003 	cmp	r2, r3
  104c4c:	1a000005 	bne	104c68 <ueth_device_unregister+0xc4>
        {
            ueth_dev_list_valid[i] = 0;
  104c50:	e30e344c 	movw	r3, #58444	; 0xe44c
  104c54:	e3403014 	movt	r3, #20
  104c58:	e51b2008 	ldr	r2, [fp, #-8]
  104c5c:	e0833002 	add	r3, r3, r2
  104c60:	e3a02000 	mov	r2, #0
  104c64:	e5c32000 	strb	r2, [r3]
    for (int i = 0; i < MAX_DEV_NUM; i++)
  104c68:	e51b3008 	ldr	r3, [fp, #-8]
  104c6c:	e2833001 	add	r3, r3, #1
  104c70:	e50b3008 	str	r3, [fp, #-8]
  104c74:	e51b3008 	ldr	r3, [fp, #-8]
  104c78:	e3530002 	cmp	r3, #2
  104c7c:	daffffe2 	ble	104c0c <ueth_device_unregister+0x68>
        }
    }

    return RT_EOK;
  104c80:	e3a03000 	mov	r3, #0
}
  104c84:	e1a00003 	mov	r0, r3
  104c88:	e24bd004 	sub	sp, fp, #4
  104c8c:	e8bd8800 	pop	{fp, pc}

00104c90 <ueth_device_init>:

rt_err_t ueth_device_init(rt_device_t dev)
{
  104c90:	e92d4800 	push	{fp, lr}
  104c94:	e28db004 	add	fp, sp, #4
  104c98:	e24dd010 	sub	sp, sp, #16
  104c9c:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
  104ca0:	e3a03000 	mov	r3, #0
  104ca4:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
  104ca8:	e51b3010 	ldr	r3, [fp, #-16]
  104cac:	e3530000 	cmp	r3, #0
  104cb0:	1a000005 	bne	104ccc <ueth_device_init+0x3c>
  104cb4:	e3a0205a 	mov	r2, #90	; 0x5a
  104cb8:	e3051c6c 	movw	r1, #23660	; 0x5c6c
  104cbc:	e3401014 	movt	r1, #20
  104cc0:	e3050be0 	movw	r0, #23520	; 0x5be0
  104cc4:	e3400014 	movt	r0, #20
  104cc8:	ebfffa32 	bl	103598 <rt_assert_handler>
    RT_ASSERT(dev->parent.type == RT_Object_Class_Device);
  104ccc:	e51b3010 	ldr	r3, [fp, #-16]
  104cd0:	e5d33008 	ldrb	r3, [r3, #8]
  104cd4:	e3530009 	cmp	r3, #9
  104cd8:	0a000005 	beq	104cf4 <ueth_device_init+0x64>
  104cdc:	e3a0205b 	mov	r2, #91	; 0x5b
  104ce0:	e3051c6c 	movw	r1, #23660	; 0x5c6c
  104ce4:	e3401014 	movt	r1, #20
  104ce8:	e3050bf0 	movw	r0, #23536	; 0x5bf0
  104cec:	e3400014 	movt	r0, #20
  104cf0:	ebfffa28 	bl	103598 <rt_assert_handler>

    /* get device_init handler */
    if (DEV_INIT != RT_NULL)
  104cf4:	e51b3010 	ldr	r3, [fp, #-16]
  104cf8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  104cfc:	e5933000 	ldr	r3, [r3]
  104d00:	e3530000 	cmp	r3, #0
  104d04:	0a00001a 	beq	104d74 <ueth_device_init+0xe4>
    {
        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
  104d08:	e51b3010 	ldr	r3, [fp, #-16]
  104d0c:	e1d331bc 	ldrh	r3, [r3, #28]
  104d10:	e2033010 	and	r3, r3, #16
  104d14:	e3530000 	cmp	r3, #0
  104d18:	1a000015 	bne	104d74 <ueth_device_init+0xe4>
        {
            result = DEV_INIT(dev);
  104d1c:	e51b3010 	ldr	r3, [fp, #-16]
  104d20:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  104d24:	e5933000 	ldr	r3, [r3]
  104d28:	e51b0010 	ldr	r0, [fp, #-16]
  104d2c:	e12fff33 	blx	r3
  104d30:	e50b0008 	str	r0, [fp, #-8]
            if (result != RT_EOK)
  104d34:	e51b3008 	ldr	r3, [fp, #-8]
  104d38:	e3530000 	cmp	r3, #0
  104d3c:	0a000006 	beq	104d5c <ueth_device_init+0xcc>
            {
                printf("To initialize device:%s failed. The error code is %ld\n",
                           dev->parent.name, result);
  104d40:	e51b3010 	ldr	r3, [fp, #-16]
                printf("To initialize device:%s failed. The error code is %ld\n",
  104d44:	e51b2008 	ldr	r2, [fp, #-8]
  104d48:	e1a01003 	mov	r1, r3
  104d4c:	e3050c1c 	movw	r0, #23580	; 0x5c1c
  104d50:	e3400014 	movt	r0, #20
  104d54:	eb00e697 	bl	13e7b8 <printf>
  104d58:	ea000005 	b	104d74 <ueth_device_init+0xe4>
            }
            else
            {
                dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
  104d5c:	e51b3010 	ldr	r3, [fp, #-16]
  104d60:	e1d331bc 	ldrh	r3, [r3, #28]
  104d64:	e3833010 	orr	r3, r3, #16
  104d68:	e6ff2073 	uxth	r2, r3
  104d6c:	e51b3010 	ldr	r3, [fp, #-16]
  104d70:	e1c321bc 	strh	r2, [r3, #28]
            }
        }
    }

    return result;
  104d74:	e51b3008 	ldr	r3, [fp, #-8]
}
  104d78:	e1a00003 	mov	r0, r3
  104d7c:	e24bd004 	sub	sp, fp, #4
  104d80:	e8bd8800 	pop	{fp, pc}

00104d84 <ueth_device_close>:

rt_err_t ueth_device_close(rt_device_t dev)
{
  104d84:	e92d4800 	push	{fp, lr}
  104d88:	e28db004 	add	fp, sp, #4
  104d8c:	e24dd010 	sub	sp, sp, #16
  104d90:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
  104d94:	e3a03000 	mov	r3, #0
  104d98:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
  104d9c:	e51b3010 	ldr	r3, [fp, #-16]
  104da0:	e3530000 	cmp	r3, #0
  104da4:	1a000005 	bne	104dc0 <ueth_device_close+0x3c>
  104da8:	e3a02076 	mov	r2, #118	; 0x76
  104dac:	e3051c80 	movw	r1, #23680	; 0x5c80
  104db0:	e3401014 	movt	r1, #20
  104db4:	e3050be0 	movw	r0, #23520	; 0x5be0
  104db8:	e3400014 	movt	r0, #20
  104dbc:	ebfff9f5 	bl	103598 <rt_assert_handler>
    RT_ASSERT(dev->parent.type == RT_Object_Class_Device);
  104dc0:	e51b3010 	ldr	r3, [fp, #-16]
  104dc4:	e5d33008 	ldrb	r3, [r3, #8]
  104dc8:	e3530009 	cmp	r3, #9
  104dcc:	0a000005 	beq	104de8 <ueth_device_close+0x64>
  104dd0:	e3a02077 	mov	r2, #119	; 0x77
  104dd4:	e3051c80 	movw	r1, #23680	; 0x5c80
  104dd8:	e3401014 	movt	r1, #20
  104ddc:	e3050bf0 	movw	r0, #23536	; 0x5bf0
  104de0:	e3400014 	movt	r0, #20
  104de4:	ebfff9eb 	bl	103598 <rt_assert_handler>

    if (dev->ref_count == 0)
  104de8:	e51b3010 	ldr	r3, [fp, #-16]
  104dec:	e5d33020 	ldrb	r3, [r3, #32]
  104df0:	e3530000 	cmp	r3, #0
  104df4:	1a000001 	bne	104e00 <ueth_device_close+0x7c>
        return -RT_ERROR;
  104df8:	e3e03000 	mvn	r3, #0
  104dfc:	ea000020 	b	104e84 <ueth_device_close+0x100>

    dev->ref_count--;
  104e00:	e51b3010 	ldr	r3, [fp, #-16]
  104e04:	e5d33020 	ldrb	r3, [r3, #32]
  104e08:	e2433001 	sub	r3, r3, #1
  104e0c:	e6ef2073 	uxtb	r2, r3
  104e10:	e51b3010 	ldr	r3, [fp, #-16]
  104e14:	e5c32020 	strb	r2, [r3, #32]

    if (dev->ref_count != 0)
  104e18:	e51b3010 	ldr	r3, [fp, #-16]
  104e1c:	e5d33020 	ldrb	r3, [r3, #32]
  104e20:	e3530000 	cmp	r3, #0
  104e24:	0a000001 	beq	104e30 <ueth_device_close+0xac>
        return RT_EOK;
  104e28:	e3a03000 	mov	r3, #0
  104e2c:	ea000014 	b	104e84 <ueth_device_close+0x100>

    /* call device_close interface */
    if (DEV_CLOSE != RT_NULL)
  104e30:	e51b3010 	ldr	r3, [fp, #-16]
  104e34:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  104e38:	e5933008 	ldr	r3, [r3, #8]
  104e3c:	e3530000 	cmp	r3, #0
  104e40:	0a000005 	beq	104e5c <ueth_device_close+0xd8>
    {
        result = DEV_CLOSE(dev);
  104e44:	e51b3010 	ldr	r3, [fp, #-16]
  104e48:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  104e4c:	e5933008 	ldr	r3, [r3, #8]
  104e50:	e51b0010 	ldr	r0, [fp, #-16]
  104e54:	e12fff33 	blx	r3
  104e58:	e50b0008 	str	r0, [fp, #-8]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
  104e5c:	e51b3008 	ldr	r3, [fp, #-8]
  104e60:	e3530000 	cmp	r3, #0
  104e64:	0a000002 	beq	104e74 <ueth_device_close+0xf0>
  104e68:	e51b3008 	ldr	r3, [fp, #-8]
  104e6c:	e3730006 	cmn	r3, #6
  104e70:	1a000002 	bne	104e80 <ueth_device_close+0xfc>
        dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
  104e74:	e51b3010 	ldr	r3, [fp, #-16]
  104e78:	e3a02000 	mov	r2, #0
  104e7c:	e1c321be 	strh	r2, [r3, #30]

    return result;
  104e80:	e51b3008 	ldr	r3, [fp, #-8]
}
  104e84:	e1a00003 	mov	r0, r3
  104e88:	e24bd004 	sub	sp, fp, #4
  104e8c:	e8bd8800 	pop	{fp, pc}

00104e90 <ueth_device_control>:

rt_err_t ueth_device_control(rt_device_t dev, int cmd, void *arg)
{
  104e90:	e92d4800 	push	{fp, lr}
  104e94:	e28db004 	add	fp, sp, #4
  104e98:	e24dd010 	sub	sp, sp, #16
  104e9c:	e50b0008 	str	r0, [fp, #-8]
  104ea0:	e50b100c 	str	r1, [fp, #-12]
  104ea4:	e50b2010 	str	r2, [fp, #-16]
    RT_ASSERT(dev != RT_NULL);
  104ea8:	e51b3008 	ldr	r3, [fp, #-8]
  104eac:	e3530000 	cmp	r3, #0
  104eb0:	1a000005 	bne	104ecc <ueth_device_control+0x3c>
  104eb4:	e3a02090 	mov	r2, #144	; 0x90
  104eb8:	e3051c94 	movw	r1, #23700	; 0x5c94
  104ebc:	e3401014 	movt	r1, #20
  104ec0:	e3050be0 	movw	r0, #23520	; 0x5be0
  104ec4:	e3400014 	movt	r0, #20
  104ec8:	ebfff9b2 	bl	103598 <rt_assert_handler>
    RT_ASSERT(dev->parent.type == RT_Object_Class_Device);
  104ecc:	e51b3008 	ldr	r3, [fp, #-8]
  104ed0:	e5d33008 	ldrb	r3, [r3, #8]
  104ed4:	e3530009 	cmp	r3, #9
  104ed8:	0a000005 	beq	104ef4 <ueth_device_control+0x64>
  104edc:	e3a02091 	mov	r2, #145	; 0x91
  104ee0:	e3051c94 	movw	r1, #23700	; 0x5c94
  104ee4:	e3401014 	movt	r1, #20
  104ee8:	e3050bf0 	movw	r0, #23536	; 0x5bf0
  104eec:	e3400014 	movt	r0, #20
  104ef0:	ebfff9a8 	bl	103598 <rt_assert_handler>

    /* call device_write interface */
    if (DEV_CONTROL != RT_NULL)
  104ef4:	e51b3008 	ldr	r3, [fp, #-8]
  104ef8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  104efc:	e5933014 	ldr	r3, [r3, #20]
  104f00:	e3530000 	cmp	r3, #0
  104f04:	0a000008 	beq	104f2c <ueth_device_control+0x9c>
    {
        return DEV_CONTROL(dev, cmd, arg);
  104f08:	e51b3008 	ldr	r3, [fp, #-8]
  104f0c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  104f10:	e5933014 	ldr	r3, [r3, #20]
  104f14:	e51b2010 	ldr	r2, [fp, #-16]
  104f18:	e51b100c 	ldr	r1, [fp, #-12]
  104f1c:	e51b0008 	ldr	r0, [fp, #-8]
  104f20:	e12fff33 	blx	r3
  104f24:	e1a03000 	mov	r3, r0
  104f28:	ea000000 	b	104f30 <ueth_device_control+0xa0>
    }

    return -RT_ENOSYS;
  104f2c:	e3e03005 	mvn	r3, #5
  104f30:	e1a00003 	mov	r0, r3
  104f34:	e24bd004 	sub	sp, fp, #4
  104f38:	e8bd8800 	pop	{fp, pc}

00104f3c <rt_slist_init>:
 * @brief initialize a single list
 *
 * @param l the single list to be initialized
 */
rt_inline void rt_slist_init(rt_slist_t *l)
{
  104f3c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  104f40:	e28db000 	add	fp, sp, #0
  104f44:	e24dd00c 	sub	sp, sp, #12
  104f48:	e50b0008 	str	r0, [fp, #-8]
    l->next = RT_NULL;
  104f4c:	e51b3008 	ldr	r3, [fp, #-8]
  104f50:	e3a02000 	mov	r2, #0
  104f54:	e5832000 	str	r2, [r3]
}
  104f58:	e320f000 	nop	{0}
  104f5c:	e28bd000 	add	sp, fp, #0
  104f60:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  104f64:	e12fff1e 	bx	lr

00104f68 <rt_slist_append>:

rt_inline void rt_slist_append(rt_slist_t *l, rt_slist_t *n)
{
  104f68:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  104f6c:	e28db000 	add	fp, sp, #0
  104f70:	e24dd014 	sub	sp, sp, #20
  104f74:	e50b0010 	str	r0, [fp, #-16]
  104f78:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    struct rt_slist_node *node;

    node = l;
  104f7c:	e51b3010 	ldr	r3, [fp, #-16]
  104f80:	e50b3008 	str	r3, [fp, #-8]
    while (node->next) node = node->next;
  104f84:	ea000002 	b	104f94 <rt_slist_append+0x2c>
  104f88:	e51b3008 	ldr	r3, [fp, #-8]
  104f8c:	e5933000 	ldr	r3, [r3]
  104f90:	e50b3008 	str	r3, [fp, #-8]
  104f94:	e51b3008 	ldr	r3, [fp, #-8]
  104f98:	e5933000 	ldr	r3, [r3]
  104f9c:	e3530000 	cmp	r3, #0
  104fa0:	1afffff8 	bne	104f88 <rt_slist_append+0x20>

    /* append the node to the tail */
    node->next = n;
  104fa4:	e51b3008 	ldr	r3, [fp, #-8]
  104fa8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  104fac:	e5832000 	str	r2, [r3]
    n->next = RT_NULL;
  104fb0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  104fb4:	e3a02000 	mov	r2, #0
  104fb8:	e5832000 	str	r2, [r3]
}
  104fbc:	e320f000 	nop	{0}
  104fc0:	e28bd000 	add	sp, fp, #0
  104fc4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  104fc8:	e12fff1e 	bx	lr

00104fcc <rt_slist_remove>:

    return len;
}

rt_inline rt_slist_t *rt_slist_remove(rt_slist_t *l, rt_slist_t *n)
{
  104fcc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  104fd0:	e28db000 	add	fp, sp, #0
  104fd4:	e24dd014 	sub	sp, sp, #20
  104fd8:	e50b0010 	str	r0, [fp, #-16]
  104fdc:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    /* remove slist head */
    struct rt_slist_node *node = l;
  104fe0:	e51b3010 	ldr	r3, [fp, #-16]
  104fe4:	e50b3008 	str	r3, [fp, #-8]
    while (node->next && node->next != n) node = node->next;
  104fe8:	ea000002 	b	104ff8 <rt_slist_remove+0x2c>
  104fec:	e51b3008 	ldr	r3, [fp, #-8]
  104ff0:	e5933000 	ldr	r3, [r3]
  104ff4:	e50b3008 	str	r3, [fp, #-8]
  104ff8:	e51b3008 	ldr	r3, [fp, #-8]
  104ffc:	e5933000 	ldr	r3, [r3]
  105000:	e3530000 	cmp	r3, #0
  105004:	0a000004 	beq	10501c <rt_slist_remove+0x50>
  105008:	e51b3008 	ldr	r3, [fp, #-8]
  10500c:	e5933000 	ldr	r3, [r3]
  105010:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  105014:	e1520003 	cmp	r2, r3
  105018:	1afffff3 	bne	104fec <rt_slist_remove+0x20>

    /* remove node */
    if (node->next != (rt_slist_t *)0) node->next = node->next->next;
  10501c:	e51b3008 	ldr	r3, [fp, #-8]
  105020:	e5933000 	ldr	r3, [r3]
  105024:	e3530000 	cmp	r3, #0
  105028:	0a000004 	beq	105040 <rt_slist_remove+0x74>
  10502c:	e51b3008 	ldr	r3, [fp, #-8]
  105030:	e5933000 	ldr	r3, [r3]
  105034:	e5932000 	ldr	r2, [r3]
  105038:	e51b3008 	ldr	r3, [fp, #-8]
  10503c:	e5832000 	str	r2, [r3]

    return l;
  105040:	e51b3010 	ldr	r3, [fp, #-16]
}
  105044:	e1a00003 	mov	r0, r3
  105048:	e28bd000 	add	sp, fp, #0
  10504c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  105050:	e12fff1e 	bx	lr

00105054 <rt_slist_next>:

    return l;
}

rt_inline rt_slist_t *rt_slist_next(rt_slist_t *n)
{
  105054:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  105058:	e28db000 	add	fp, sp, #0
  10505c:	e24dd00c 	sub	sp, sp, #12
  105060:	e50b0008 	str	r0, [fp, #-8]
    return n->next;
  105064:	e51b3008 	ldr	r3, [fp, #-8]
  105068:	e5933000 	ldr	r3, [r3]
}
  10506c:	e1a00003 	mov	r0, r3
  105070:	e28bd000 	add	sp, fp, #0
  105074:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  105078:	e12fff1e 	bx	lr

0010507c <netdev_register>:
 *
 * @return  0: registered successfully
 *         -1: registered failed
 */
int netdev_register(struct netdev *netdev, const char *name, void *user_data)
{
  10507c:	e92d4810 	push	{r4, fp, lr}
  105080:	e28db008 	add	fp, sp, #8
  105084:	e24dd01c 	sub	sp, sp, #28
  105088:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10508c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  105090:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
    // rt_base_t level;
    uint16_t flags_mask;
    int index;

    RT_ASSERT(netdev);
  105094:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  105098:	e3530000 	cmp	r3, #0
  10509c:	1a000005 	bne	1050b8 <netdev_register+0x3c>
  1050a0:	e3a02032 	mov	r2, #50	; 0x32
  1050a4:	e3061008 	movw	r1, #24584	; 0x6008
  1050a8:	e3401014 	movt	r1, #20
  1050ac:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  1050b0:	e3400014 	movt	r0, #20
  1050b4:	ebfff937 	bl	103598 <rt_assert_handler>
    RT_ASSERT(name);
  1050b8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1050bc:	e3530000 	cmp	r3, #0
  1050c0:	1a000005 	bne	1050dc <netdev_register+0x60>
  1050c4:	e3a02033 	mov	r2, #51	; 0x33
  1050c8:	e3061008 	movw	r1, #24584	; 0x6008
  1050cc:	e3401014 	movt	r1, #20
  1050d0:	e3050cb0 	movw	r0, #23728	; 0x5cb0
  1050d4:	e3400014 	movt	r0, #20
  1050d8:	ebfff92e 	bl	103598 <rt_assert_handler>

    /* clean network interface device */
    flags_mask = NETDEV_FLAG_UP | NETDEV_FLAG_LINK_UP | NETDEV_FLAG_INTERNET_UP | NETDEV_FLAG_DHCP;
  1050dc:	e3003185 	movw	r3, #389	; 0x185
  1050e0:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    netdev->flags &= ~flags_mask;
  1050e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1050e8:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1050ec:	e6bf2073 	sxth	r2, r3
  1050f0:	e15b31f2 	ldrsh	r3, [fp, #-18]	; 0xffffffee
  1050f4:	e1e03003 	mvn	r3, r3
  1050f8:	e6bf3073 	sxth	r3, r3
  1050fc:	e0033002 	and	r3, r3, r2
  105100:	e6bf3073 	sxth	r3, r3
  105104:	e6ff2073 	uxth	r2, r3
  105108:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10510c:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a

    ip_addr_set_zero(&(netdev->ip_addr));
  105110:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  105114:	e3a02000 	mov	r2, #0
  105118:	e583200c 	str	r2, [r3, #12]
    ip_addr_set_zero(&(netdev->netmask));
  10511c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  105120:	e3a02000 	mov	r2, #0
  105124:	e5832010 	str	r2, [r3, #16]
    ip_addr_set_zero(&(netdev->gw));
  105128:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10512c:	e3a02000 	mov	r2, #0
  105130:	e5832014 	str	r2, [r3, #20]
    {
        ip_addr_set_zero(&(netdev->ip6_addr[index]));
        IP_SET_TYPE_VAL(netdev->ip_addr, IPADDR_TYPE_V6);
    }
#endif /* NETDEV_IPV6 */
    for (index = 0; index < NETDEV_DNS_SERVERS_NUM; index++)
  105134:	e3a03000 	mov	r3, #0
  105138:	e50b3010 	str	r3, [fp, #-16]
  10513c:	ea000007 	b	105160 <netdev_register+0xe4>
    {
        ip_addr_set_zero(&(netdev->dns_servers[index]));
  105140:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  105144:	e51b2010 	ldr	r2, [fp, #-16]
  105148:	e2822006 	add	r2, r2, #6
  10514c:	e3a01000 	mov	r1, #0
  105150:	e7831102 	str	r1, [r3, r2, lsl #2]
    for (index = 0; index < NETDEV_DNS_SERVERS_NUM; index++)
  105154:	e51b3010 	ldr	r3, [fp, #-16]
  105158:	e2833001 	add	r3, r3, #1
  10515c:	e50b3010 	str	r3, [fp, #-16]
  105160:	e51b3010 	ldr	r3, [fp, #-16]
  105164:	e3530001 	cmp	r3, #1
  105168:	9afffff4 	bls	105140 <netdev_register+0xc4>
        IP_SET_TYPE_VAL(netdev->ip_addr, IPADDR_TYPE_V4);
    }
    netdev->status_callback = RT_NULL;
  10516c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  105170:	e3a02000 	mov	r2, #0
  105174:	e5832034 	str	r2, [r3, #52]	; 0x34
    netdev->addr_callback = RT_NULL;
  105178:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10517c:	e3a02000 	mov	r2, #0
  105180:	e5832038 	str	r2, [r3, #56]	; 0x38

    /* fill network interface device */
    rt_strncpy(netdev->name, name, rt_strlen(name));
  105184:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  105188:	e2834004 	add	r4, r3, #4
  10518c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  105190:	ebfff81a 	bl	103200 <rt_strlen>
  105194:	e1a03000 	mov	r3, r0
  105198:	e1a02003 	mov	r2, r3
  10519c:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  1051a0:	e1a00004 	mov	r0, r4
  1051a4:	ebfff82d 	bl	103260 <rt_strncpy>
    netdev->user_data = user_data;
  1051a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1051ac:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1051b0:	e5832040 	str	r2, [r3, #64]	; 0x40

    /* initialize current network interface device single list */
    rt_slist_init(&(netdev->list));
  1051b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1051b8:	e1a00003 	mov	r0, r3
  1051bc:	ebffff5e 	bl	104f3c <rt_slist_init>

    // level = rt_hw_interrupt_disable();

    if (netdev_list == RT_NULL)
  1051c0:	e3003568 	movw	r3, #1384	; 0x568
  1051c4:	e3403015 	movt	r3, #21
  1051c8:	e5933000 	ldr	r3, [r3]
  1051cc:	e3530000 	cmp	r3, #0
  1051d0:	1a000008 	bne	1051f8 <netdev_register+0x17c>
    {
        netdev_list = netdev;
  1051d4:	e3003568 	movw	r3, #1384	; 0x568
  1051d8:	e3403015 	movt	r3, #21
  1051dc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1051e0:	e5832000 	str	r2, [r3]
        netdev_default = netdev;
  1051e4:	e3003564 	movw	r3, #1380	; 0x564
  1051e8:	e3403015 	movt	r3, #21
  1051ec:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1051f0:	e5832000 	str	r2, [r3]
  1051f4:	ea000007 	b	105218 <netdev_register+0x19c>
    }
    else
    {
        /* tail insertion */
        rt_slist_append(&(netdev_list->list), &(netdev->list));
  1051f8:	e3003568 	movw	r3, #1384	; 0x568
  1051fc:	e3403015 	movt	r3, #21
  105200:	e5933000 	ldr	r3, [r3]
  105204:	e1a02003 	mov	r2, r3
  105208:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10520c:	e1a01003 	mov	r1, r3
  105210:	e1a00002 	mov	r0, r2
  105214:	ebffff53 	bl	104f68 <rt_slist_append>
    }

    // rt_hw_interrupt_enable(level);

    return RT_EOK;
  105218:	e3a03000 	mov	r3, #0
}
  10521c:	e1a00003 	mov	r0, r3
  105220:	e24bd008 	sub	sp, fp, #8
  105224:	e8bd8810 	pop	{r4, fp, pc}

00105228 <netdev_unregister>:
 *
 * @return  0: unregistered successfully
 *         -1: unregistered failed
 */
int netdev_unregister(struct netdev *netdev)
{
  105228:	e92d4800 	push	{fp, lr}
  10522c:	e28db004 	add	fp, sp, #4
  105230:	e24dd010 	sub	sp, sp, #16
  105234:	e50b0010 	str	r0, [fp, #-16]
    // rt_base_t level;
    rt_slist_t *node = RT_NULL;
  105238:	e3a03000 	mov	r3, #0
  10523c:	e50b3008 	str	r3, [fp, #-8]
    struct netdev *cur_netdev = RT_NULL;
  105240:	e3a03000 	mov	r3, #0
  105244:	e50b300c 	str	r3, [fp, #-12]

    RT_ASSERT(netdev);
  105248:	e51b3010 	ldr	r3, [fp, #-16]
  10524c:	e3530000 	cmp	r3, #0
  105250:	1a000005 	bne	10526c <netdev_unregister+0x44>
  105254:	e3a02077 	mov	r2, #119	; 0x77
  105258:	e3061018 	movw	r1, #24600	; 0x6018
  10525c:	e3401014 	movt	r1, #20
  105260:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  105264:	e3400014 	movt	r0, #20
  105268:	ebfff8ca 	bl	103598 <rt_assert_handler>

    if (netdev_list == RT_NULL)
  10526c:	e3003568 	movw	r3, #1384	; 0x568
  105270:	e3403015 	movt	r3, #21
  105274:	e5933000 	ldr	r3, [r3]
  105278:	e3530000 	cmp	r3, #0
  10527c:	1a000001 	bne	105288 <netdev_unregister+0x60>
    {
        return -RT_ERROR;
  105280:	e3e03000 	mvn	r3, #0
  105284:	ea000045 	b	1053a0 <netdev_unregister+0x178>
    }

    // level = rt_hw_interrupt_disable();

    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  105288:	e3003568 	movw	r3, #1384	; 0x568
  10528c:	e3403015 	movt	r3, #21
  105290:	e5933000 	ldr	r3, [r3]
  105294:	e50b3008 	str	r3, [fp, #-8]
  105298:	ea000030 	b	105360 <netdev_unregister+0x138>
    {
        cur_netdev = rt_slist_entry(node, struct netdev, list);
  10529c:	e51b3008 	ldr	r3, [fp, #-8]
  1052a0:	e50b300c 	str	r3, [fp, #-12]
        if (cur_netdev == netdev)
  1052a4:	e51b200c 	ldr	r2, [fp, #-12]
  1052a8:	e51b3010 	ldr	r3, [fp, #-16]
  1052ac:	e1520003 	cmp	r2, r3
  1052b0:	1a000027 	bne	105354 <netdev_unregister+0x12c>
        {
            /* find this network interface device in network interface device list */
            if (netdev_list == netdev && rt_slist_next(&netdev_list->list) == RT_NULL)
  1052b4:	e3003568 	movw	r3, #1384	; 0x568
  1052b8:	e3403015 	movt	r3, #21
  1052bc:	e5933000 	ldr	r3, [r3]
  1052c0:	e51b2010 	ldr	r2, [fp, #-16]
  1052c4:	e1520003 	cmp	r2, r3
  1052c8:	1a00000c 	bne	105300 <netdev_unregister+0xd8>
  1052cc:	e3003568 	movw	r3, #1384	; 0x568
  1052d0:	e3403015 	movt	r3, #21
  1052d4:	e5933000 	ldr	r3, [r3]
  1052d8:	e1a00003 	mov	r0, r3
  1052dc:	ebffff5c 	bl	105054 <rt_slist_next>
  1052e0:	e1a03000 	mov	r3, r0
  1052e4:	e3530000 	cmp	r3, #0
  1052e8:	1a000004 	bne	105300 <netdev_unregister+0xd8>
            {
                netdev_list = RT_NULL;
  1052ec:	e3003568 	movw	r3, #1384	; 0x568
  1052f0:	e3403015 	movt	r3, #21
  1052f4:	e3a02000 	mov	r2, #0
  1052f8:	e5832000 	str	r2, [r3]
  1052fc:	ea000007 	b	105320 <netdev_unregister+0xf8>
            }
            else
            {
                rt_slist_remove(&(netdev_list->list), &(cur_netdev->list));
  105300:	e3003568 	movw	r3, #1384	; 0x568
  105304:	e3403015 	movt	r3, #21
  105308:	e5933000 	ldr	r3, [r3]
  10530c:	e1a02003 	mov	r2, r3
  105310:	e51b300c 	ldr	r3, [fp, #-12]
  105314:	e1a01003 	mov	r1, r3
  105318:	e1a00002 	mov	r0, r2
  10531c:	ebffff2a 	bl	104fcc <rt_slist_remove>
            }
            if (netdev_default == netdev)
  105320:	e3003564 	movw	r3, #1380	; 0x564
  105324:	e3403015 	movt	r3, #21
  105328:	e5933000 	ldr	r3, [r3]
  10532c:	e51b2010 	ldr	r2, [fp, #-16]
  105330:	e1520003 	cmp	r2, r3
  105334:	1a00000d 	bne	105370 <netdev_unregister+0x148>
            {
                netdev_default = netdev_list;
  105338:	e3003568 	movw	r3, #1384	; 0x568
  10533c:	e3403015 	movt	r3, #21
  105340:	e5932000 	ldr	r2, [r3]
  105344:	e3003564 	movw	r3, #1380	; 0x564
  105348:	e3403015 	movt	r3, #21
  10534c:	e5832000 	str	r2, [r3]
            }
            break;
  105350:	ea000006 	b	105370 <netdev_unregister+0x148>
    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  105354:	e51b0008 	ldr	r0, [fp, #-8]
  105358:	ebffff3d 	bl	105054 <rt_slist_next>
  10535c:	e50b0008 	str	r0, [fp, #-8]
  105360:	e51b3008 	ldr	r3, [fp, #-8]
  105364:	e3530000 	cmp	r3, #0
  105368:	1affffcb 	bne	10529c <netdev_unregister+0x74>
  10536c:	ea000000 	b	105374 <netdev_unregister+0x14c>
            break;
  105370:	e320f000 	nop	{0}
        }
    }
    // rt_hw_interrupt_enable(level);

    if (cur_netdev == netdev)
  105374:	e51b200c 	ldr	r2, [fp, #-12]
  105378:	e51b3010 	ldr	r3, [fp, #-16]
  10537c:	e1520003 	cmp	r2, r3
  105380:	1a000005 	bne	10539c <netdev_unregister+0x174>
    {
#ifdef RT_USING_SAL
        extern int sal_netdev_cleanup(struct netdev *netdev);
        sal_netdev_cleanup(netdev);
  105384:	e51b0010 	ldr	r0, [fp, #-16]
  105388:	eb000823 	bl	10741c <sal_netdev_cleanup>
#endif
        rt_memset(netdev, 0, sizeof(*netdev));
  10538c:	e3a02044 	mov	r2, #68	; 0x44
  105390:	e3a01000 	mov	r1, #0
  105394:	e51b0010 	ldr	r0, [fp, #-16]
  105398:	ebfff7ca 	bl	1032c8 <rt_memset>
    }

    return -RT_ERROR;
  10539c:	e3e03000 	mvn	r3, #0
}
  1053a0:	e1a00003 	mov	r0, r3
  1053a4:	e24bd004 	sub	sp, fp, #4
  1053a8:	e8bd8800 	pop	{fp, pc}

001053ac <netdev_get_first_by_flags>:
 *
 * @return != NULL: network interface device object
 *            NULL: get failed
 */
struct netdev *netdev_get_first_by_flags(uint16_t flags)
{
  1053ac:	e92d4800 	push	{fp, lr}
  1053b0:	e28db004 	add	fp, sp, #4
  1053b4:	e24dd010 	sub	sp, sp, #16
  1053b8:	e1a03000 	mov	r3, r0
  1053bc:	e14b30be 	strh	r3, [fp, #-14]
    // rt_base_t level;
    rt_slist_t *node = RT_NULL;
  1053c0:	e3a03000 	mov	r3, #0
  1053c4:	e50b3008 	str	r3, [fp, #-8]
    struct netdev *netdev = RT_NULL;
  1053c8:	e3a03000 	mov	r3, #0
  1053cc:	e50b300c 	str	r3, [fp, #-12]

    if (netdev_list == RT_NULL)
  1053d0:	e3003568 	movw	r3, #1384	; 0x568
  1053d4:	e3403015 	movt	r3, #21
  1053d8:	e5933000 	ldr	r3, [r3]
  1053dc:	e3530000 	cmp	r3, #0
  1053e0:	1a000001 	bne	1053ec <netdev_get_first_by_flags+0x40>
    {
        return RT_NULL;
  1053e4:	e3a03000 	mov	r3, #0
  1053e8:	ea000019 	b	105454 <netdev_get_first_by_flags+0xa8>
    }

    // level = rt_hw_interrupt_disable();

    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  1053ec:	e3003568 	movw	r3, #1384	; 0x568
  1053f0:	e3403015 	movt	r3, #21
  1053f4:	e5933000 	ldr	r3, [r3]
  1053f8:	e50b3008 	str	r3, [fp, #-8]
  1053fc:	ea000010 	b	105444 <netdev_get_first_by_flags+0x98>
    {
        netdev = rt_slist_entry(node, struct netdev, list);
  105400:	e51b3008 	ldr	r3, [fp, #-8]
  105404:	e50b300c 	str	r3, [fp, #-12]
        if (netdev && (netdev->flags & flags) != 0)
  105408:	e51b300c 	ldr	r3, [fp, #-12]
  10540c:	e3530000 	cmp	r3, #0
  105410:	0a000008 	beq	105438 <netdev_get_first_by_flags+0x8c>
  105414:	e51b300c 	ldr	r3, [fp, #-12]
  105418:	e1d322ba 	ldrh	r2, [r3, #42]	; 0x2a
  10541c:	e15b30be 	ldrh	r3, [fp, #-14]
  105420:	e0033002 	and	r3, r3, r2
  105424:	e6ff3073 	uxth	r3, r3
  105428:	e3530000 	cmp	r3, #0
  10542c:	0a000001 	beq	105438 <netdev_get_first_by_flags+0x8c>
        {
            // rt_hw_interrupt_enable(level);
            return netdev;
  105430:	e51b300c 	ldr	r3, [fp, #-12]
  105434:	ea000006 	b	105454 <netdev_get_first_by_flags+0xa8>
    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  105438:	e51b0008 	ldr	r0, [fp, #-8]
  10543c:	ebffff04 	bl	105054 <rt_slist_next>
  105440:	e50b0008 	str	r0, [fp, #-8]
  105444:	e51b3008 	ldr	r3, [fp, #-8]
  105448:	e3530000 	cmp	r3, #0
  10544c:	1affffeb 	bne	105400 <netdev_get_first_by_flags+0x54>
        }
    }

    // rt_hw_interrupt_enable(level);

    return RT_NULL;
  105450:	e3a03000 	mov	r3, #0
}
  105454:	e1a00003 	mov	r0, r3
  105458:	e24bd004 	sub	sp, fp, #4
  10545c:	e8bd8800 	pop	{fp, pc}

00105460 <netdev_get_by_ipaddr>:
 *
 * @return != NULL: network interface device object
 *            NULL: get failed
 */
struct netdev *netdev_get_by_ipaddr(ip_addr_t *ip_addr)
{
  105460:	e92d4800 	push	{fp, lr}
  105464:	e28db004 	add	fp, sp, #4
  105468:	e24dd010 	sub	sp, sp, #16
  10546c:	e50b0010 	str	r0, [fp, #-16]
    // rt_base_t level;
    rt_slist_t *node = RT_NULL;
  105470:	e3a03000 	mov	r3, #0
  105474:	e50b3008 	str	r3, [fp, #-8]
    struct netdev *netdev = RT_NULL;
  105478:	e3a03000 	mov	r3, #0
  10547c:	e50b300c 	str	r3, [fp, #-12]

    if (netdev_list == RT_NULL)
  105480:	e3003568 	movw	r3, #1384	; 0x568
  105484:	e3403015 	movt	r3, #21
  105488:	e5933000 	ldr	r3, [r3]
  10548c:	e3530000 	cmp	r3, #0
  105490:	1a000001 	bne	10549c <netdev_get_by_ipaddr+0x3c>
    {
        return RT_NULL;
  105494:	e3a03000 	mov	r3, #0
  105498:	ea000018 	b	105500 <netdev_get_by_ipaddr+0xa0>
    }

    // level = rt_hw_interrupt_disable();

    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  10549c:	e3003568 	movw	r3, #1384	; 0x568
  1054a0:	e3403015 	movt	r3, #21
  1054a4:	e5933000 	ldr	r3, [r3]
  1054a8:	e50b3008 	str	r3, [fp, #-8]
  1054ac:	ea00000f 	b	1054f0 <netdev_get_by_ipaddr+0x90>
    {
        netdev = rt_slist_entry(node, struct netdev, list);
  1054b0:	e51b3008 	ldr	r3, [fp, #-8]
  1054b4:	e50b300c 	str	r3, [fp, #-12]
        if (netdev && ip_addr_cmp(&(netdev->ip_addr), ip_addr))
  1054b8:	e51b300c 	ldr	r3, [fp, #-12]
  1054bc:	e3530000 	cmp	r3, #0
  1054c0:	0a000007 	beq	1054e4 <netdev_get_by_ipaddr+0x84>
  1054c4:	e51b300c 	ldr	r3, [fp, #-12]
  1054c8:	e593200c 	ldr	r2, [r3, #12]
  1054cc:	e51b3010 	ldr	r3, [fp, #-16]
  1054d0:	e5933000 	ldr	r3, [r3]
  1054d4:	e1520003 	cmp	r2, r3
  1054d8:	1a000001 	bne	1054e4 <netdev_get_by_ipaddr+0x84>
        {
            // rt_hw_interrupt_enable(level);
            return netdev;
  1054dc:	e51b300c 	ldr	r3, [fp, #-12]
  1054e0:	ea000006 	b	105500 <netdev_get_by_ipaddr+0xa0>
    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  1054e4:	e51b0008 	ldr	r0, [fp, #-8]
  1054e8:	ebfffed9 	bl	105054 <rt_slist_next>
  1054ec:	e50b0008 	str	r0, [fp, #-8]
  1054f0:	e51b3008 	ldr	r3, [fp, #-8]
  1054f4:	e3530000 	cmp	r3, #0
  1054f8:	1affffec 	bne	1054b0 <netdev_get_by_ipaddr+0x50>
        }
    }

    // rt_hw_interrupt_enable(level);

    return RT_NULL;
  1054fc:	e3a03000 	mov	r3, #0
}
  105500:	e1a00003 	mov	r0, r3
  105504:	e24bd004 	sub	sp, fp, #4
  105508:	e8bd8800 	pop	{fp, pc}

0010550c <netdev_get_by_name>:
 *
 * @return != NULL: network interface device object
 *            NULL: get failed
 */
struct netdev *netdev_get_by_name(const char *name)
{
  10550c:	e92d4810 	push	{r4, fp, lr}
  105510:	e28db008 	add	fp, sp, #8
  105514:	e24dd014 	sub	sp, sp, #20
  105518:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    // rt_base_t level;
    rt_slist_t *node = RT_NULL;
  10551c:	e3a03000 	mov	r3, #0
  105520:	e50b3010 	str	r3, [fp, #-16]
    struct netdev *netdev = RT_NULL;
  105524:	e3a03000 	mov	r3, #0
  105528:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

    if (netdev_list == RT_NULL)
  10552c:	e3003568 	movw	r3, #1384	; 0x568
  105530:	e3403015 	movt	r3, #21
  105534:	e5933000 	ldr	r3, [r3]
  105538:	e3530000 	cmp	r3, #0
  10553c:	1a000001 	bne	105548 <netdev_get_by_name+0x3c>
    {
        return RT_NULL;
  105540:	e3a03000 	mov	r3, #0
  105544:	ea000020 	b	1055cc <netdev_get_by_name+0xc0>
    }

    // level = rt_hw_interrupt_disable();

    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  105548:	e3003568 	movw	r3, #1384	; 0x568
  10554c:	e3403015 	movt	r3, #21
  105550:	e5933000 	ldr	r3, [r3]
  105554:	e50b3010 	str	r3, [fp, #-16]
  105558:	ea000017 	b	1055bc <netdev_get_by_name+0xb0>
    {
        netdev = rt_slist_entry(node, struct netdev, list);
  10555c:	e51b3010 	ldr	r3, [fp, #-16]
  105560:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        if (netdev && (rt_strncmp(netdev->name, name, rt_strlen(netdev->name)) == 0))
  105564:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  105568:	e3530000 	cmp	r3, #0
  10556c:	0a00000f 	beq	1055b0 <netdev_get_by_name+0xa4>
  105570:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  105574:	e2834004 	add	r4, r3, #4
  105578:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10557c:	e2833004 	add	r3, r3, #4
  105580:	e1a00003 	mov	r0, r3
  105584:	ebfff71d 	bl	103200 <rt_strlen>
  105588:	e1a03000 	mov	r3, r0
  10558c:	e1a02003 	mov	r2, r3
  105590:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  105594:	e1a00004 	mov	r0, r4
  105598:	ebfff722 	bl	103228 <rt_strncmp>
  10559c:	e1a03000 	mov	r3, r0
  1055a0:	e3530000 	cmp	r3, #0
  1055a4:	1a000001 	bne	1055b0 <netdev_get_by_name+0xa4>
        {
            // rt_hw_interrupt_enable(level);
            return netdev;
  1055a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1055ac:	ea000006 	b	1055cc <netdev_get_by_name+0xc0>
    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  1055b0:	e51b0010 	ldr	r0, [fp, #-16]
  1055b4:	ebfffea6 	bl	105054 <rt_slist_next>
  1055b8:	e50b0010 	str	r0, [fp, #-16]
  1055bc:	e51b3010 	ldr	r3, [fp, #-16]
  1055c0:	e3530000 	cmp	r3, #0
  1055c4:	1affffe4 	bne	10555c <netdev_get_by_name+0x50>
        }
    }

    // rt_hw_interrupt_enable(level);

    return RT_NULL;
  1055c8:	e3a03000 	mov	r3, #0
}
  1055cc:	e1a00003 	mov	r0, r3
  1055d0:	e24bd008 	sub	sp, fp, #8
  1055d4:	e8bd8810 	pop	{r4, fp, pc}

001055d8 <netdev_get_by_family>:
 *
 * @return != NULL: network interface device object
 *            NULL: get failed
 */
struct netdev *netdev_get_by_family(int family)
{
  1055d8:	e92d4800 	push	{fp, lr}
  1055dc:	e28db004 	add	fp, sp, #4
  1055e0:	e24dd018 	sub	sp, sp, #24
  1055e4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    // rt_base_t level;
    rt_slist_t *node = RT_NULL;
  1055e8:	e3a03000 	mov	r3, #0
  1055ec:	e50b3008 	str	r3, [fp, #-8]
    struct netdev *netdev = RT_NULL;
  1055f0:	e3a03000 	mov	r3, #0
  1055f4:	e50b300c 	str	r3, [fp, #-12]
    struct sal_proto_family *pf = RT_NULL;
  1055f8:	e3a03000 	mov	r3, #0
  1055fc:	e50b3010 	str	r3, [fp, #-16]

    if (netdev_list == RT_NULL)
  105600:	e3003568 	movw	r3, #1384	; 0x568
  105604:	e3403015 	movt	r3, #21
  105608:	e5933000 	ldr	r3, [r3]
  10560c:	e3530000 	cmp	r3, #0
  105610:	1a000001 	bne	10561c <netdev_get_by_family+0x44>
    {
        return RT_NULL;
  105614:	e3a03000 	mov	r3, #0
  105618:	ea000048 	b	105740 <netdev_get_by_family+0x168>
    }

    // level = rt_hw_interrupt_disable();

    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  10561c:	e3003568 	movw	r3, #1384	; 0x568
  105620:	e3403015 	movt	r3, #21
  105624:	e5933000 	ldr	r3, [r3]
  105628:	e50b3008 	str	r3, [fp, #-8]
  10562c:	ea00001b 	b	1056a0 <netdev_get_by_family+0xc8>
    {
        netdev = rt_slist_entry(node, struct netdev, list);
  105630:	e51b3008 	ldr	r3, [fp, #-8]
  105634:	e50b300c 	str	r3, [fp, #-12]
        pf = (struct sal_proto_family *) netdev->sal_user_data;
  105638:	e51b300c 	ldr	r3, [fp, #-12]
  10563c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  105640:	e50b3010 	str	r3, [fp, #-16]
        if (pf && pf->skt_ops && pf->family == family && netdev_is_up(netdev))
  105644:	e51b3010 	ldr	r3, [fp, #-16]
  105648:	e3530000 	cmp	r3, #0
  10564c:	0a000010 	beq	105694 <netdev_get_by_family+0xbc>
  105650:	e51b3010 	ldr	r3, [fp, #-16]
  105654:	e5933008 	ldr	r3, [r3, #8]
  105658:	e3530000 	cmp	r3, #0
  10565c:	0a00000c 	beq	105694 <netdev_get_by_family+0xbc>
  105660:	e51b3010 	ldr	r3, [fp, #-16]
  105664:	e5933000 	ldr	r3, [r3]
  105668:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  10566c:	e1520003 	cmp	r2, r3
  105670:	1a000007 	bne	105694 <netdev_get_by_family+0xbc>
  105674:	e51b300c 	ldr	r3, [fp, #-12]
  105678:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  10567c:	e2033001 	and	r3, r3, #1
  105680:	e6ef3073 	uxtb	r3, r3
  105684:	e3530000 	cmp	r3, #0
  105688:	0a000001 	beq	105694 <netdev_get_by_family+0xbc>
        {
            // rt_hw_interrupt_enable(level);
            return netdev;
  10568c:	e51b300c 	ldr	r3, [fp, #-12]
  105690:	ea00002a 	b	105740 <netdev_get_by_family+0x168>
    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  105694:	e51b0008 	ldr	r0, [fp, #-8]
  105698:	ebfffe6d 	bl	105054 <rt_slist_next>
  10569c:	e50b0008 	str	r0, [fp, #-8]
  1056a0:	e51b3008 	ldr	r3, [fp, #-8]
  1056a4:	e3530000 	cmp	r3, #0
  1056a8:	1affffe0 	bne	105630 <netdev_get_by_family+0x58>
        }
    }

    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  1056ac:	e3003568 	movw	r3, #1384	; 0x568
  1056b0:	e3403015 	movt	r3, #21
  1056b4:	e5933000 	ldr	r3, [r3]
  1056b8:	e50b3008 	str	r3, [fp, #-8]
  1056bc:	ea00001b 	b	105730 <netdev_get_by_family+0x158>
    {
        netdev = rt_slist_entry(node, struct netdev, list);
  1056c0:	e51b3008 	ldr	r3, [fp, #-8]
  1056c4:	e50b300c 	str	r3, [fp, #-12]
        pf = (struct sal_proto_family *) netdev->sal_user_data;
  1056c8:	e51b300c 	ldr	r3, [fp, #-12]
  1056cc:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  1056d0:	e50b3010 	str	r3, [fp, #-16]
        if (pf && pf->skt_ops && pf->sec_family == family && netdev_is_up(netdev))
  1056d4:	e51b3010 	ldr	r3, [fp, #-16]
  1056d8:	e3530000 	cmp	r3, #0
  1056dc:	0a000010 	beq	105724 <netdev_get_by_family+0x14c>
  1056e0:	e51b3010 	ldr	r3, [fp, #-16]
  1056e4:	e5933008 	ldr	r3, [r3, #8]
  1056e8:	e3530000 	cmp	r3, #0
  1056ec:	0a00000c 	beq	105724 <netdev_get_by_family+0x14c>
  1056f0:	e51b3010 	ldr	r3, [fp, #-16]
  1056f4:	e5933004 	ldr	r3, [r3, #4]
  1056f8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1056fc:	e1520003 	cmp	r2, r3
  105700:	1a000007 	bne	105724 <netdev_get_by_family+0x14c>
  105704:	e51b300c 	ldr	r3, [fp, #-12]
  105708:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  10570c:	e2033001 	and	r3, r3, #1
  105710:	e6ef3073 	uxtb	r3, r3
  105714:	e3530000 	cmp	r3, #0
  105718:	0a000001 	beq	105724 <netdev_get_by_family+0x14c>
        {
            // rt_hw_interrupt_enable(level);
            return netdev;
  10571c:	e51b300c 	ldr	r3, [fp, #-12]
  105720:	ea000006 	b	105740 <netdev_get_by_family+0x168>
    for (node = &(netdev_list->list); node; node = rt_slist_next(node))
  105724:	e51b0008 	ldr	r0, [fp, #-8]
  105728:	ebfffe49 	bl	105054 <rt_slist_next>
  10572c:	e50b0008 	str	r0, [fp, #-8]
  105730:	e51b3008 	ldr	r3, [fp, #-8]
  105734:	e3530000 	cmp	r3, #0
  105738:	1affffe0 	bne	1056c0 <netdev_get_by_family+0xe8>
        }
    }

    // rt_hw_interrupt_enable(level);

    return RT_NULL;
  10573c:	e3a03000 	mov	r3, #0
}
  105740:	e1a00003 	mov	r0, r3
  105744:	e24bd004 	sub	sp, fp, #4
  105748:	e8bd8800 	pop	{fp, pc}

0010574c <netdev_family_get>:
 * @param netdev network interface device object
 *
 * @return the network interface device family type
 */
int netdev_family_get(struct netdev *netdev)
{
  10574c:	e92d4800 	push	{fp, lr}
  105750:	e28db004 	add	fp, sp, #4
  105754:	e24dd008 	sub	sp, sp, #8
  105758:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(netdev);
  10575c:	e51b3008 	ldr	r3, [fp, #-8]
  105760:	e3530000 	cmp	r3, #0
  105764:	1a000005 	bne	105780 <netdev_family_get+0x34>
  105768:	e300214e 	movw	r2, #334	; 0x14e
  10576c:	e306102c 	movw	r1, #24620	; 0x602c
  105770:	e3401014 	movt	r1, #20
  105774:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  105778:	e3400014 	movt	r0, #20
  10577c:	ebfff785 	bl	103598 <rt_assert_handler>

    return ((struct sal_proto_family *)netdev->sal_user_data)->family;
  105780:	e51b3008 	ldr	r3, [fp, #-8]
  105784:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  105788:	e5933000 	ldr	r3, [r3]
}
  10578c:	e1a00003 	mov	r0, r3
  105790:	e24bd004 	sub	sp, fp, #4
  105794:	e8bd8800 	pop	{fp, pc}

00105798 <netdev_set_default>:
 * This function will set default network interface device.
 *
 * @param netdev the network interface device to change
 */
void netdev_set_default(struct netdev *netdev)
{
  105798:	e92d4800 	push	{fp, lr}
  10579c:	e28db004 	add	fp, sp, #4
  1057a0:	e24dd008 	sub	sp, sp, #8
  1057a4:	e50b0008 	str	r0, [fp, #-8]
    if (netdev)
  1057a8:	e51b3008 	ldr	r3, [fp, #-8]
  1057ac:	e3530000 	cmp	r3, #0
  1057b0:	0a00000d 	beq	1057ec <netdev_set_default+0x54>
    {
        netdev_default = netdev;
  1057b4:	e3003564 	movw	r3, #1380	; 0x564
  1057b8:	e3403015 	movt	r3, #21
  1057bc:	e51b2008 	ldr	r2, [fp, #-8]
  1057c0:	e5832000 	str	r2, [r3]

        if (netdev->ops->set_default)
  1057c4:	e51b3008 	ldr	r3, [fp, #-8]
  1057c8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  1057cc:	e593301c 	ldr	r3, [r3, #28]
  1057d0:	e3530000 	cmp	r3, #0
  1057d4:	0a000004 	beq	1057ec <netdev_set_default+0x54>
        {
            /* set default network interface device in the current network stack */
            netdev->ops->set_default(netdev);
  1057d8:	e51b3008 	ldr	r3, [fp, #-8]
  1057dc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  1057e0:	e593301c 	ldr	r3, [r3, #28]
  1057e4:	e51b0008 	ldr	r0, [fp, #-8]
  1057e8:	e12fff33 	blx	r3
        }
        LOG_D("Setting default network interface device name(%s) successfully.", netdev->name);
    }
}
  1057ec:	e320f000 	nop	{0}
  1057f0:	e24bd004 	sub	sp, fp, #4
  1057f4:	e8bd8800 	pop	{fp, pc}

001057f8 <netdev_set_up>:
 *
 * @return  0: set status successfully
 *         -1: set status failed
 */
int netdev_set_up(struct netdev *netdev)
{
  1057f8:	e92d4800 	push	{fp, lr}
  1057fc:	e28db004 	add	fp, sp, #4
  105800:	e24dd008 	sub	sp, sp, #8
  105804:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(netdev);
  105808:	e51b3008 	ldr	r3, [fp, #-8]
  10580c:	e3530000 	cmp	r3, #0
  105810:	1a000005 	bne	10582c <netdev_set_up+0x34>
  105814:	e3002173 	movw	r2, #371	; 0x173
  105818:	e3061040 	movw	r1, #24640	; 0x6040
  10581c:	e3401014 	movt	r1, #20
  105820:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  105824:	e3400014 	movt	r0, #20
  105828:	ebfff75a 	bl	103598 <rt_assert_handler>

    if (!netdev->ops || !netdev->ops->set_up)
  10582c:	e51b3008 	ldr	r3, [fp, #-8]
  105830:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105834:	e3530000 	cmp	r3, #0
  105838:	0a000004 	beq	105850 <netdev_set_up+0x58>
  10583c:	e51b3008 	ldr	r3, [fp, #-8]
  105840:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105844:	e5933000 	ldr	r3, [r3]
  105848:	e3530000 	cmp	r3, #0
  10584c:	1a00000d 	bne	105888 <netdev_set_up+0x90>
    {
        LOG_E("The network interface device(%s) not support to set status.", netdev->name);
  105850:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105854:	e3400014 	movt	r0, #20
  105858:	ebfff62d 	bl	103114 <rt_kprintf>
  10585c:	e51b3008 	ldr	r3, [fp, #-8]
  105860:	e2833004 	add	r3, r3, #4
  105864:	e1a01003 	mov	r1, r3
  105868:	e3050ccc 	movw	r0, #23756	; 0x5ccc
  10586c:	e3400014 	movt	r0, #20
  105870:	ebfff627 	bl	103114 <rt_kprintf>
  105874:	e3050d08 	movw	r0, #23816	; 0x5d08
  105878:	e3400014 	movt	r0, #20
  10587c:	ebfff624 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105880:	e3e03000 	mvn	r3, #0
  105884:	ea00000d 	b	1058c0 <netdev_set_up+0xc8>
    }

    /* network interface device status flags check */
    if (netdev_is_up(netdev))
  105888:	e51b3008 	ldr	r3, [fp, #-8]
  10588c:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  105890:	e2033001 	and	r3, r3, #1
  105894:	e6ef3073 	uxtb	r3, r3
  105898:	e3530000 	cmp	r3, #0
  10589c:	0a000001 	beq	1058a8 <netdev_set_up+0xb0>
    {
        return RT_EOK;
  1058a0:	e3a03000 	mov	r3, #0
  1058a4:	ea000005 	b	1058c0 <netdev_set_up+0xc8>
    }

    /* execute enable network interface device operations by network interface device driver */
    return netdev->ops->set_up(netdev);
  1058a8:	e51b3008 	ldr	r3, [fp, #-8]
  1058ac:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  1058b0:	e5933000 	ldr	r3, [r3]
  1058b4:	e51b0008 	ldr	r0, [fp, #-8]
  1058b8:	e12fff33 	blx	r3
  1058bc:	e1a03000 	mov	r3, r0
}
  1058c0:	e1a00003 	mov	r0, r3
  1058c4:	e24bd004 	sub	sp, fp, #4
  1058c8:	e8bd8800 	pop	{fp, pc}

001058cc <netdev_set_down>:
 *
 * @return  0: set status successfully
 *         -1: set sttaus failed
 */
int netdev_set_down(struct netdev *netdev)
{
  1058cc:	e92d4800 	push	{fp, lr}
  1058d0:	e28db004 	add	fp, sp, #4
  1058d4:	e24dd008 	sub	sp, sp, #8
  1058d8:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(netdev);
  1058dc:	e51b3008 	ldr	r3, [fp, #-8]
  1058e0:	e3530000 	cmp	r3, #0
  1058e4:	1a000005 	bne	105900 <netdev_set_down+0x34>
  1058e8:	e300218e 	movw	r2, #398	; 0x18e
  1058ec:	e3061050 	movw	r1, #24656	; 0x6050
  1058f0:	e3401014 	movt	r1, #20
  1058f4:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  1058f8:	e3400014 	movt	r0, #20
  1058fc:	ebfff725 	bl	103598 <rt_assert_handler>

    if (!netdev->ops || !netdev->ops->set_down)
  105900:	e51b3008 	ldr	r3, [fp, #-8]
  105904:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105908:	e3530000 	cmp	r3, #0
  10590c:	0a000004 	beq	105924 <netdev_set_down+0x58>
  105910:	e51b3008 	ldr	r3, [fp, #-8]
  105914:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105918:	e5933004 	ldr	r3, [r3, #4]
  10591c:	e3530000 	cmp	r3, #0
  105920:	1a00000d 	bne	10595c <netdev_set_down+0x90>
    {
        LOG_E("The network interface device(%s) not support to set status.", netdev->name);
  105924:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105928:	e3400014 	movt	r0, #20
  10592c:	ebfff5f8 	bl	103114 <rt_kprintf>
  105930:	e51b3008 	ldr	r3, [fp, #-8]
  105934:	e2833004 	add	r3, r3, #4
  105938:	e1a01003 	mov	r1, r3
  10593c:	e3050ccc 	movw	r0, #23756	; 0x5ccc
  105940:	e3400014 	movt	r0, #20
  105944:	ebfff5f2 	bl	103114 <rt_kprintf>
  105948:	e3050d08 	movw	r0, #23816	; 0x5d08
  10594c:	e3400014 	movt	r0, #20
  105950:	ebfff5ef 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105954:	e3e03000 	mvn	r3, #0
  105958:	ea00000c 	b	105990 <netdev_set_down+0xc4>
    }

    /* network interface device status flags check */
    if (!netdev_is_up(netdev))
  10595c:	e51b3008 	ldr	r3, [fp, #-8]
  105960:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  105964:	e2033001 	and	r3, r3, #1
  105968:	e3530000 	cmp	r3, #0
  10596c:	1a000001 	bne	105978 <netdev_set_down+0xac>
    {
        return RT_EOK;
  105970:	e3a03000 	mov	r3, #0
  105974:	ea000005 	b	105990 <netdev_set_down+0xc4>
    }

    /* execute disable network interface device operations by network interface driver */
    return netdev->ops->set_down(netdev);
  105978:	e51b3008 	ldr	r3, [fp, #-8]
  10597c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105980:	e5933004 	ldr	r3, [r3, #4]
  105984:	e51b0008 	ldr	r0, [fp, #-8]
  105988:	e12fff33 	blx	r3
  10598c:	e1a03000 	mov	r3, r0
}
  105990:	e1a00003 	mov	r0, r3
  105994:	e24bd004 	sub	sp, fp, #4
  105998:	e8bd8800 	pop	{fp, pc}

0010599c <netdev_dhcp_enabled>:
 *
 * @return  0: set DHCP status successfully
 *         -1: set DHCP status failed
 */
int netdev_dhcp_enabled(struct netdev *netdev, rt_bool_t is_enabled)
{
  10599c:	e92d4800 	push	{fp, lr}
  1059a0:	e28db004 	add	fp, sp, #4
  1059a4:	e24dd008 	sub	sp, sp, #8
  1059a8:	e50b0008 	str	r0, [fp, #-8]
  1059ac:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(netdev);
  1059b0:	e51b3008 	ldr	r3, [fp, #-8]
  1059b4:	e3530000 	cmp	r3, #0
  1059b8:	1a000005 	bne	1059d4 <netdev_dhcp_enabled+0x38>
  1059bc:	e30021ab 	movw	r2, #427	; 0x1ab
  1059c0:	e3061060 	movw	r1, #24672	; 0x6060
  1059c4:	e3401014 	movt	r1, #20
  1059c8:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  1059cc:	e3400014 	movt	r0, #20
  1059d0:	ebfff6f0 	bl	103598 <rt_assert_handler>

    if (!netdev->ops || !netdev->ops->set_dhcp)
  1059d4:	e51b3008 	ldr	r3, [fp, #-8]
  1059d8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  1059dc:	e3530000 	cmp	r3, #0
  1059e0:	0a000004 	beq	1059f8 <netdev_dhcp_enabled+0x5c>
  1059e4:	e51b3008 	ldr	r3, [fp, #-8]
  1059e8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  1059ec:	e5933010 	ldr	r3, [r3, #16]
  1059f0:	e3530000 	cmp	r3, #0
  1059f4:	1a00000d 	bne	105a30 <netdev_dhcp_enabled+0x94>
    {
        LOG_E("The network interface device(%s) not support to set DHCP status.", netdev->name);
  1059f8:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  1059fc:	e3400014 	movt	r0, #20
  105a00:	ebfff5c3 	bl	103114 <rt_kprintf>
  105a04:	e51b3008 	ldr	r3, [fp, #-8]
  105a08:	e2833004 	add	r3, r3, #4
  105a0c:	e1a01003 	mov	r1, r3
  105a10:	e3050d10 	movw	r0, #23824	; 0x5d10
  105a14:	e3400014 	movt	r0, #20
  105a18:	ebfff5bd 	bl	103114 <rt_kprintf>
  105a1c:	e3050d08 	movw	r0, #23816	; 0x5d08
  105a20:	e3400014 	movt	r0, #20
  105a24:	ebfff5ba 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105a28:	e3e03000 	mvn	r3, #0
  105a2c:	ea00000f 	b	105a70 <netdev_dhcp_enabled+0xd4>
    }

    /* network interface device DHCP flags check */
    if (netdev_is_dhcp_enabled(netdev) == is_enabled)
  105a30:	e51b3008 	ldr	r3, [fp, #-8]
  105a34:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  105a38:	e1a03423 	lsr	r3, r3, #8
  105a3c:	e2033001 	and	r3, r3, #1
  105a40:	e51b200c 	ldr	r2, [fp, #-12]
  105a44:	e1520003 	cmp	r2, r3
  105a48:	1a000001 	bne	105a54 <netdev_dhcp_enabled+0xb8>
    {
        return RT_EOK;
  105a4c:	e3a03000 	mov	r3, #0
  105a50:	ea000006 	b	105a70 <netdev_dhcp_enabled+0xd4>
    }

    /* execute network interface device DHCP capability control operations */
    return netdev->ops->set_dhcp(netdev, is_enabled);
  105a54:	e51b3008 	ldr	r3, [fp, #-8]
  105a58:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105a5c:	e5933010 	ldr	r3, [r3, #16]
  105a60:	e51b100c 	ldr	r1, [fp, #-12]
  105a64:	e51b0008 	ldr	r0, [fp, #-8]
  105a68:	e12fff33 	blx	r3
  105a6c:	e1a03000 	mov	r3, r0
}
  105a70:	e1a00003 	mov	r0, r3
  105a74:	e24bd004 	sub	sp, fp, #4
  105a78:	e8bd8800 	pop	{fp, pc}

00105a7c <netdev_set_ipaddr>:
 *
 * @return  0: set IP address successfully
 *         -1: set IP address failed
 */
int netdev_set_ipaddr(struct netdev *netdev, const ip_addr_t *ip_addr)
{
  105a7c:	e92d4810 	push	{r4, fp, lr}
  105a80:	e28db008 	add	fp, sp, #8
  105a84:	e24dd00c 	sub	sp, sp, #12
  105a88:	e50b0010 	str	r0, [fp, #-16]
  105a8c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    RT_ASSERT(netdev);
  105a90:	e51b3010 	ldr	r3, [fp, #-16]
  105a94:	e3530000 	cmp	r3, #0
  105a98:	1a000005 	bne	105ab4 <netdev_set_ipaddr+0x38>
  105a9c:	e3a02f72 	mov	r2, #456	; 0x1c8
  105aa0:	e3061074 	movw	r1, #24692	; 0x6074
  105aa4:	e3401014 	movt	r1, #20
  105aa8:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  105aac:	e3400014 	movt	r0, #20
  105ab0:	ebfff6b8 	bl	103598 <rt_assert_handler>
    RT_ASSERT(ip_addr);
  105ab4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  105ab8:	e3530000 	cmp	r3, #0
  105abc:	1a000005 	bne	105ad8 <netdev_set_ipaddr+0x5c>
  105ac0:	e30021c9 	movw	r2, #457	; 0x1c9
  105ac4:	e3061074 	movw	r1, #24692	; 0x6074
  105ac8:	e3401014 	movt	r1, #20
  105acc:	e3050d54 	movw	r0, #23892	; 0x5d54
  105ad0:	e3400014 	movt	r0, #20
  105ad4:	ebfff6af 	bl	103598 <rt_assert_handler>

    if (!netdev->ops || !netdev->ops->set_addr_info)
  105ad8:	e51b3010 	ldr	r3, [fp, #-16]
  105adc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105ae0:	e3530000 	cmp	r3, #0
  105ae4:	0a000004 	beq	105afc <netdev_set_ipaddr+0x80>
  105ae8:	e51b3010 	ldr	r3, [fp, #-16]
  105aec:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105af0:	e5933008 	ldr	r3, [r3, #8]
  105af4:	e3530000 	cmp	r3, #0
  105af8:	1a00000d 	bne	105b34 <netdev_set_ipaddr+0xb8>
    {
        LOG_E("The network interface device(%s) not support to set IP address.", netdev->name);
  105afc:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105b00:	e3400014 	movt	r0, #20
  105b04:	ebfff582 	bl	103114 <rt_kprintf>
  105b08:	e51b3010 	ldr	r3, [fp, #-16]
  105b0c:	e2833004 	add	r3, r3, #4
  105b10:	e1a01003 	mov	r1, r3
  105b14:	e3050d5c 	movw	r0, #23900	; 0x5d5c
  105b18:	e3400014 	movt	r0, #20
  105b1c:	ebfff57c 	bl	103114 <rt_kprintf>
  105b20:	e3050d08 	movw	r0, #23816	; 0x5d08
  105b24:	e3400014 	movt	r0, #20
  105b28:	ebfff579 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105b2c:	e3e03000 	mvn	r3, #0
  105b30:	ea00001d 	b	105bac <netdev_set_ipaddr+0x130>
    }

    if (netdev_is_dhcp_enabled(netdev))
  105b34:	e51b3010 	ldr	r3, [fp, #-16]
  105b38:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  105b3c:	e1a03423 	lsr	r3, r3, #8
  105b40:	e2033001 	and	r3, r3, #1
  105b44:	e6ef3073 	uxtb	r3, r3
  105b48:	e3530000 	cmp	r3, #0
  105b4c:	0a00000d 	beq	105b88 <netdev_set_ipaddr+0x10c>
    {
        LOG_E("The network interface device(%s) DHCP capability is enable, not support set IP address.", netdev->name);
  105b50:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105b54:	e3400014 	movt	r0, #20
  105b58:	ebfff56d 	bl	103114 <rt_kprintf>
  105b5c:	e51b3010 	ldr	r3, [fp, #-16]
  105b60:	e2833004 	add	r3, r3, #4
  105b64:	e1a01003 	mov	r1, r3
  105b68:	e3050d9c 	movw	r0, #23964	; 0x5d9c
  105b6c:	e3400014 	movt	r0, #20
  105b70:	ebfff567 	bl	103114 <rt_kprintf>
  105b74:	e3050d08 	movw	r0, #23816	; 0x5d08
  105b78:	e3400014 	movt	r0, #20
  105b7c:	ebfff564 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105b80:	e3e03000 	mvn	r3, #0
  105b84:	ea000008 	b	105bac <netdev_set_ipaddr+0x130>
    }

     /* execute network interface device set IP address operations */
    return netdev->ops->set_addr_info(netdev, (ip_addr_t *)ip_addr, RT_NULL, RT_NULL);
  105b88:	e51b3010 	ldr	r3, [fp, #-16]
  105b8c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105b90:	e5934008 	ldr	r4, [r3, #8]
  105b94:	e3a03000 	mov	r3, #0
  105b98:	e3a02000 	mov	r2, #0
  105b9c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  105ba0:	e51b0010 	ldr	r0, [fp, #-16]
  105ba4:	e12fff34 	blx	r4
  105ba8:	e1a03000 	mov	r3, r0
}
  105bac:	e1a00003 	mov	r0, r3
  105bb0:	e24bd008 	sub	sp, fp, #8
  105bb4:	e8bd8810 	pop	{r4, fp, pc}

00105bb8 <netdev_set_netmask>:
 *
 * @return  0: set netmask address successfully
 *         -1: set netmask address failed
 */
int netdev_set_netmask(struct netdev *netdev, const ip_addr_t *netmask)
{
  105bb8:	e92d4810 	push	{r4, fp, lr}
  105bbc:	e28db008 	add	fp, sp, #8
  105bc0:	e24dd00c 	sub	sp, sp, #12
  105bc4:	e50b0010 	str	r0, [fp, #-16]
  105bc8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    RT_ASSERT(netdev);
  105bcc:	e51b3010 	ldr	r3, [fp, #-16]
  105bd0:	e3530000 	cmp	r3, #0
  105bd4:	1a000005 	bne	105bf0 <netdev_set_netmask+0x38>
  105bd8:	e30021e6 	movw	r2, #486	; 0x1e6
  105bdc:	e3061088 	movw	r1, #24712	; 0x6088
  105be0:	e3401014 	movt	r1, #20
  105be4:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  105be8:	e3400014 	movt	r0, #20
  105bec:	ebfff669 	bl	103598 <rt_assert_handler>
    RT_ASSERT(netmask);
  105bf0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  105bf4:	e3530000 	cmp	r3, #0
  105bf8:	1a000005 	bne	105c14 <netdev_set_netmask+0x5c>
  105bfc:	e30021e7 	movw	r2, #487	; 0x1e7
  105c00:	e3061088 	movw	r1, #24712	; 0x6088
  105c04:	e3401014 	movt	r1, #20
  105c08:	e3050df4 	movw	r0, #24052	; 0x5df4
  105c0c:	e3400014 	movt	r0, #20
  105c10:	ebfff660 	bl	103598 <rt_assert_handler>

    if (!netdev->ops || !netdev->ops->set_addr_info)
  105c14:	e51b3010 	ldr	r3, [fp, #-16]
  105c18:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105c1c:	e3530000 	cmp	r3, #0
  105c20:	0a000004 	beq	105c38 <netdev_set_netmask+0x80>
  105c24:	e51b3010 	ldr	r3, [fp, #-16]
  105c28:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105c2c:	e5933008 	ldr	r3, [r3, #8]
  105c30:	e3530000 	cmp	r3, #0
  105c34:	1a00000d 	bne	105c70 <netdev_set_netmask+0xb8>
    {
        LOG_E("The network interface device(%s) not support to set netmask address.", netdev->name);
  105c38:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105c3c:	e3400014 	movt	r0, #20
  105c40:	ebfff533 	bl	103114 <rt_kprintf>
  105c44:	e51b3010 	ldr	r3, [fp, #-16]
  105c48:	e2833004 	add	r3, r3, #4
  105c4c:	e1a01003 	mov	r1, r3
  105c50:	e3050dfc 	movw	r0, #24060	; 0x5dfc
  105c54:	e3400014 	movt	r0, #20
  105c58:	ebfff52d 	bl	103114 <rt_kprintf>
  105c5c:	e3050d08 	movw	r0, #23816	; 0x5d08
  105c60:	e3400014 	movt	r0, #20
  105c64:	ebfff52a 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105c68:	e3e03000 	mvn	r3, #0
  105c6c:	ea00001d 	b	105ce8 <netdev_set_netmask+0x130>
    }

    if (netdev_is_dhcp_enabled(netdev))
  105c70:	e51b3010 	ldr	r3, [fp, #-16]
  105c74:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  105c78:	e1a03423 	lsr	r3, r3, #8
  105c7c:	e2033001 	and	r3, r3, #1
  105c80:	e6ef3073 	uxtb	r3, r3
  105c84:	e3530000 	cmp	r3, #0
  105c88:	0a00000d 	beq	105cc4 <netdev_set_netmask+0x10c>
    {
        LOG_E("The network interface device(%s) DHCP capability is enable, not support set netmask address.", netdev->name);
  105c8c:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105c90:	e3400014 	movt	r0, #20
  105c94:	ebfff51e 	bl	103114 <rt_kprintf>
  105c98:	e51b3010 	ldr	r3, [fp, #-16]
  105c9c:	e2833004 	add	r3, r3, #4
  105ca0:	e1a01003 	mov	r1, r3
  105ca4:	e3050e44 	movw	r0, #24132	; 0x5e44
  105ca8:	e3400014 	movt	r0, #20
  105cac:	ebfff518 	bl	103114 <rt_kprintf>
  105cb0:	e3050d08 	movw	r0, #23816	; 0x5d08
  105cb4:	e3400014 	movt	r0, #20
  105cb8:	ebfff515 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105cbc:	e3e03000 	mvn	r3, #0
  105cc0:	ea000008 	b	105ce8 <netdev_set_netmask+0x130>
    }

    /* execute network interface device set netmask address operations */
    return netdev->ops->set_addr_info(netdev, RT_NULL, (ip_addr_t *)netmask, RT_NULL);
  105cc4:	e51b3010 	ldr	r3, [fp, #-16]
  105cc8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105ccc:	e5934008 	ldr	r4, [r3, #8]
  105cd0:	e3a03000 	mov	r3, #0
  105cd4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  105cd8:	e3a01000 	mov	r1, #0
  105cdc:	e51b0010 	ldr	r0, [fp, #-16]
  105ce0:	e12fff34 	blx	r4
  105ce4:	e1a03000 	mov	r3, r0
}
  105ce8:	e1a00003 	mov	r0, r3
  105cec:	e24bd008 	sub	sp, fp, #8
  105cf0:	e8bd8810 	pop	{r4, fp, pc}

00105cf4 <netdev_set_gw>:
 *
 * @return  0: set gateway address successfully
 *         -1: set gateway address failed
 */
int netdev_set_gw(struct netdev *netdev, const ip_addr_t *gw)
{
  105cf4:	e92d4810 	push	{r4, fp, lr}
  105cf8:	e28db008 	add	fp, sp, #8
  105cfc:	e24dd00c 	sub	sp, sp, #12
  105d00:	e50b0010 	str	r0, [fp, #-16]
  105d04:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    RT_ASSERT(netdev);
  105d08:	e51b3010 	ldr	r3, [fp, #-16]
  105d0c:	e3530000 	cmp	r3, #0
  105d10:	1a000005 	bne	105d2c <netdev_set_gw+0x38>
  105d14:	e3a02f81 	mov	r2, #516	; 0x204
  105d18:	e306109c 	movw	r1, #24732	; 0x609c
  105d1c:	e3401014 	movt	r1, #20
  105d20:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  105d24:	e3400014 	movt	r0, #20
  105d28:	ebfff61a 	bl	103598 <rt_assert_handler>
    RT_ASSERT(gw);
  105d2c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  105d30:	e3530000 	cmp	r3, #0
  105d34:	1a000005 	bne	105d50 <netdev_set_gw+0x5c>
  105d38:	e3002205 	movw	r2, #517	; 0x205
  105d3c:	e306109c 	movw	r1, #24732	; 0x609c
  105d40:	e3401014 	movt	r1, #20
  105d44:	e3050ea4 	movw	r0, #24228	; 0x5ea4
  105d48:	e3400014 	movt	r0, #20
  105d4c:	ebfff611 	bl	103598 <rt_assert_handler>

    if (!netdev->ops || !netdev->ops->set_addr_info)
  105d50:	e51b3010 	ldr	r3, [fp, #-16]
  105d54:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105d58:	e3530000 	cmp	r3, #0
  105d5c:	0a000004 	beq	105d74 <netdev_set_gw+0x80>
  105d60:	e51b3010 	ldr	r3, [fp, #-16]
  105d64:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105d68:	e5933008 	ldr	r3, [r3, #8]
  105d6c:	e3530000 	cmp	r3, #0
  105d70:	1a00000d 	bne	105dac <netdev_set_gw+0xb8>
    {
        LOG_E("The network interface device(%s) not support to set gateway address.", netdev->name);
  105d74:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105d78:	e3400014 	movt	r0, #20
  105d7c:	ebfff4e4 	bl	103114 <rt_kprintf>
  105d80:	e51b3010 	ldr	r3, [fp, #-16]
  105d84:	e2833004 	add	r3, r3, #4
  105d88:	e1a01003 	mov	r1, r3
  105d8c:	e3050ea8 	movw	r0, #24232	; 0x5ea8
  105d90:	e3400014 	movt	r0, #20
  105d94:	ebfff4de 	bl	103114 <rt_kprintf>
  105d98:	e3050d08 	movw	r0, #23816	; 0x5d08
  105d9c:	e3400014 	movt	r0, #20
  105da0:	ebfff4db 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105da4:	e3e03000 	mvn	r3, #0
  105da8:	ea00001d 	b	105e24 <netdev_set_gw+0x130>
    }

    if (netdev_is_dhcp_enabled(netdev))
  105dac:	e51b3010 	ldr	r3, [fp, #-16]
  105db0:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  105db4:	e1a03423 	lsr	r3, r3, #8
  105db8:	e2033001 	and	r3, r3, #1
  105dbc:	e6ef3073 	uxtb	r3, r3
  105dc0:	e3530000 	cmp	r3, #0
  105dc4:	0a00000d 	beq	105e00 <netdev_set_gw+0x10c>
    {
        LOG_E("The network interface device(%s) DHCP capability is enable, not support set gateway address.", netdev->name);
  105dc8:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105dcc:	e3400014 	movt	r0, #20
  105dd0:	ebfff4cf 	bl	103114 <rt_kprintf>
  105dd4:	e51b3010 	ldr	r3, [fp, #-16]
  105dd8:	e2833004 	add	r3, r3, #4
  105ddc:	e1a01003 	mov	r1, r3
  105de0:	e3050ef0 	movw	r0, #24304	; 0x5ef0
  105de4:	e3400014 	movt	r0, #20
  105de8:	ebfff4c9 	bl	103114 <rt_kprintf>
  105dec:	e3050d08 	movw	r0, #23816	; 0x5d08
  105df0:	e3400014 	movt	r0, #20
  105df4:	ebfff4c6 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105df8:	e3e03000 	mvn	r3, #0
  105dfc:	ea000008 	b	105e24 <netdev_set_gw+0x130>
    }

    /* execute network interface device set gateway address operations */
    return netdev->ops->set_addr_info(netdev, RT_NULL, RT_NULL, (ip_addr_t *)gw);
  105e00:	e51b3010 	ldr	r3, [fp, #-16]
  105e04:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105e08:	e5934008 	ldr	r4, [r3, #8]
  105e0c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  105e10:	e3a02000 	mov	r2, #0
  105e14:	e3a01000 	mov	r1, #0
  105e18:	e51b0010 	ldr	r0, [fp, #-16]
  105e1c:	e12fff34 	blx	r4
  105e20:	e1a03000 	mov	r3, r0
}
  105e24:	e1a00003 	mov	r0, r3
  105e28:	e24bd008 	sub	sp, fp, #8
  105e2c:	e8bd8810 	pop	{r4, fp, pc}

00105e30 <netdev_set_dns_server>:
 *
 * @return  0: set netmask address successfully
 *         -1: set netmask address failed
 */
int netdev_set_dns_server(struct netdev *netdev, uint8_t dns_num, const ip_addr_t *dns_server)
{
  105e30:	e92d4800 	push	{fp, lr}
  105e34:	e28db004 	add	fp, sp, #4
  105e38:	e24dd010 	sub	sp, sp, #16
  105e3c:	e50b0008 	str	r0, [fp, #-8]
  105e40:	e1a03001 	mov	r3, r1
  105e44:	e50b2010 	str	r2, [fp, #-16]
  105e48:	e54b3009 	strb	r3, [fp, #-9]
    RT_ASSERT(netdev);
  105e4c:	e51b3008 	ldr	r3, [fp, #-8]
  105e50:	e3530000 	cmp	r3, #0
  105e54:	1a000005 	bne	105e70 <netdev_set_dns_server+0x40>
  105e58:	e3002222 	movw	r2, #546	; 0x222
  105e5c:	e30610ac 	movw	r1, #24748	; 0x60ac
  105e60:	e3401014 	movt	r1, #20
  105e64:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  105e68:	e3400014 	movt	r0, #20
  105e6c:	ebfff5c9 	bl	103598 <rt_assert_handler>
    RT_ASSERT(dns_server);
  105e70:	e51b3010 	ldr	r3, [fp, #-16]
  105e74:	e3530000 	cmp	r3, #0
  105e78:	1a000005 	bne	105e94 <netdev_set_dns_server+0x64>
  105e7c:	e3002223 	movw	r2, #547	; 0x223
  105e80:	e30610ac 	movw	r1, #24748	; 0x60ac
  105e84:	e3401014 	movt	r1, #20
  105e88:	e3050f50 	movw	r0, #24400	; 0x5f50
  105e8c:	e3400014 	movt	r0, #20
  105e90:	ebfff5c0 	bl	103598 <rt_assert_handler>

    if (dns_num >= NETDEV_DNS_SERVERS_NUM)
  105e94:	e55b3009 	ldrb	r3, [fp, #-9]
  105e98:	e3530001 	cmp	r3, #1
  105e9c:	9a00000e 	bls	105edc <netdev_set_dns_server+0xac>
    {
        LOG_E("The number of DNS servers(%d) set exceeds the maximum number(%d).", dns_num + 1, NETDEV_DNS_SERVERS_NUM);
  105ea0:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105ea4:	e3400014 	movt	r0, #20
  105ea8:	ebfff499 	bl	103114 <rt_kprintf>
  105eac:	e55b3009 	ldrb	r3, [fp, #-9]
  105eb0:	e2833001 	add	r3, r3, #1
  105eb4:	e3a02002 	mov	r2, #2
  105eb8:	e1a01003 	mov	r1, r3
  105ebc:	e3050f5c 	movw	r0, #24412	; 0x5f5c
  105ec0:	e3400014 	movt	r0, #20
  105ec4:	ebfff492 	bl	103114 <rt_kprintf>
  105ec8:	e3050d08 	movw	r0, #23816	; 0x5d08
  105ecc:	e3400014 	movt	r0, #20
  105ed0:	ebfff48f 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105ed4:	e3e03000 	mvn	r3, #0
  105ed8:	ea00001e 	b	105f58 <netdev_set_dns_server+0x128>
    }

    if (!netdev->ops || !netdev->ops->set_dns_server)
  105edc:	e51b3008 	ldr	r3, [fp, #-8]
  105ee0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105ee4:	e3530000 	cmp	r3, #0
  105ee8:	0a000004 	beq	105f00 <netdev_set_dns_server+0xd0>
  105eec:	e51b3008 	ldr	r3, [fp, #-8]
  105ef0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105ef4:	e593300c 	ldr	r3, [r3, #12]
  105ef8:	e3530000 	cmp	r3, #0
  105efc:	1a00000d 	bne	105f38 <netdev_set_dns_server+0x108>
    {
        LOG_E("The network interface device(%s) not support to set DNS server address.", netdev->name);
  105f00:	e3050cb8 	movw	r0, #23736	; 0x5cb8
  105f04:	e3400014 	movt	r0, #20
  105f08:	ebfff481 	bl	103114 <rt_kprintf>
  105f0c:	e51b3008 	ldr	r3, [fp, #-8]
  105f10:	e2833004 	add	r3, r3, #4
  105f14:	e1a01003 	mov	r1, r3
  105f18:	e3050fa0 	movw	r0, #24480	; 0x5fa0
  105f1c:	e3400014 	movt	r0, #20
  105f20:	ebfff47b 	bl	103114 <rt_kprintf>
  105f24:	e3050d08 	movw	r0, #23816	; 0x5d08
  105f28:	e3400014 	movt	r0, #20
  105f2c:	ebfff478 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  105f30:	e3e03000 	mvn	r3, #0
  105f34:	ea000007 	b	105f58 <netdev_set_dns_server+0x128>
    }

    /* execute network interface device set DNS server address operations */
    return netdev->ops->set_dns_server(netdev, dns_num, (ip_addr_t *)dns_server);
  105f38:	e51b3008 	ldr	r3, [fp, #-8]
  105f3c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  105f40:	e593300c 	ldr	r3, [r3, #12]
  105f44:	e55b1009 	ldrb	r1, [fp, #-9]
  105f48:	e51b2010 	ldr	r2, [fp, #-16]
  105f4c:	e51b0008 	ldr	r0, [fp, #-8]
  105f50:	e12fff33 	blx	r3
  105f54:	e1a03000 	mov	r3, r0
}
  105f58:	e1a00003 	mov	r0, r3
  105f5c:	e24bd004 	sub	sp, fp, #4
  105f60:	e8bd8800 	pop	{fp, pc}

00105f64 <netdev_set_status_callback>:
 *
 * @param netdev the network interface device to change
 * @param status_callback the callback be called when the status has been changed.
 */
void netdev_set_status_callback(struct netdev *netdev, netdev_callback_fn status_callback)
{
  105f64:	e92d4800 	push	{fp, lr}
  105f68:	e28db004 	add	fp, sp, #4
  105f6c:	e24dd008 	sub	sp, sp, #8
  105f70:	e50b0008 	str	r0, [fp, #-8]
  105f74:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(netdev);
  105f78:	e51b3008 	ldr	r3, [fp, #-8]
  105f7c:	e3530000 	cmp	r3, #0
  105f80:	1a000005 	bne	105f9c <netdev_set_status_callback+0x38>
  105f84:	e300223d 	movw	r2, #573	; 0x23d
  105f88:	e30610c4 	movw	r1, #24772	; 0x60c4
  105f8c:	e3401014 	movt	r1, #20
  105f90:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  105f94:	e3400014 	movt	r0, #20
  105f98:	ebfff57e 	bl	103598 <rt_assert_handler>
    RT_ASSERT(status_callback);
  105f9c:	e51b300c 	ldr	r3, [fp, #-12]
  105fa0:	e3530000 	cmp	r3, #0
  105fa4:	1a000005 	bne	105fc0 <netdev_set_status_callback+0x5c>
  105fa8:	e300223e 	movw	r2, #574	; 0x23e
  105fac:	e30610c4 	movw	r1, #24772	; 0x60c4
  105fb0:	e3401014 	movt	r1, #20
  105fb4:	e3050fe8 	movw	r0, #24552	; 0x5fe8
  105fb8:	e3400014 	movt	r0, #20
  105fbc:	ebfff575 	bl	103598 <rt_assert_handler>

    netdev->status_callback = status_callback;
  105fc0:	e51b3008 	ldr	r3, [fp, #-8]
  105fc4:	e51b200c 	ldr	r2, [fp, #-12]
  105fc8:	e5832034 	str	r2, [r3, #52]	; 0x34
}
  105fcc:	e320f000 	nop	{0}
  105fd0:	e24bd004 	sub	sp, fp, #4
  105fd4:	e8bd8800 	pop	{fp, pc}

00105fd8 <netdev_set_addr_callback>:
 *
 * @param netdev the network interface device to change
 * @param addr_callback the callback be called when the address has been changed.
 */
void netdev_set_addr_callback(struct netdev *netdev, netdev_callback_fn addr_callback)
{
  105fd8:	e92d4800 	push	{fp, lr}
  105fdc:	e28db004 	add	fp, sp, #4
  105fe0:	e24dd008 	sub	sp, sp, #8
  105fe4:	e50b0008 	str	r0, [fp, #-8]
  105fe8:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(netdev);
  105fec:	e51b3008 	ldr	r3, [fp, #-8]
  105ff0:	e3530000 	cmp	r3, #0
  105ff4:	1a000005 	bne	106010 <netdev_set_addr_callback+0x38>
  105ff8:	e300224b 	movw	r2, #587	; 0x24b
  105ffc:	e30610e0 	movw	r1, #24800	; 0x60e0
  106000:	e3401014 	movt	r1, #20
  106004:	e3050ca8 	movw	r0, #23720	; 0x5ca8
  106008:	e3400014 	movt	r0, #20
  10600c:	ebfff561 	bl	103598 <rt_assert_handler>
    RT_ASSERT(addr_callback);
  106010:	e51b300c 	ldr	r3, [fp, #-12]
  106014:	e3530000 	cmp	r3, #0
  106018:	1a000005 	bne	106034 <netdev_set_addr_callback+0x5c>
  10601c:	e3a02f93 	mov	r2, #588	; 0x24c
  106020:	e30610e0 	movw	r1, #24800	; 0x60e0
  106024:	e3401014 	movt	r1, #20
  106028:	e3050ff8 	movw	r0, #24568	; 0x5ff8
  10602c:	e3400014 	movt	r0, #20
  106030:	ebfff558 	bl	103598 <rt_assert_handler>

    netdev->addr_callback = addr_callback;
  106034:	e51b3008 	ldr	r3, [fp, #-8]
  106038:	e51b200c 	ldr	r2, [fp, #-12]
  10603c:	e5832038 	str	r2, [r3, #56]	; 0x38
}
  106040:	e320f000 	nop	{0}
  106044:	e24bd004 	sub	sp, fp, #4
  106048:	e8bd8800 	pop	{fp, pc}

0010604c <netdev_low_level_set_ipaddr>:
 *
 * @param netdev the network interface device to change
 * @param ipaddr the new IP address
 */
void netdev_low_level_set_ipaddr(struct netdev *netdev, const ip_addr_t *ip_addr)
{
  10604c:	e92d4800 	push	{fp, lr}
  106050:	e28db004 	add	fp, sp, #4
  106054:	e24dd008 	sub	sp, sp, #8
  106058:	e50b0008 	str	r0, [fp, #-8]
  10605c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(ip_addr);
  106060:	e51b300c 	ldr	r3, [fp, #-12]
  106064:	e3530000 	cmp	r3, #0
  106068:	1a000005 	bne	106084 <netdev_low_level_set_ipaddr+0x38>
  10606c:	e300225b 	movw	r2, #603	; 0x25b
  106070:	e30610fc 	movw	r1, #24828	; 0x60fc
  106074:	e3401014 	movt	r1, #20
  106078:	e3050d54 	movw	r0, #23892	; 0x5d54
  10607c:	e3400014 	movt	r0, #20
  106080:	ebfff544 	bl	103598 <rt_assert_handler>

    if (netdev && ip_addr_cmp(&(netdev->ip_addr), ip_addr) == 0)
  106084:	e51b3008 	ldr	r3, [fp, #-8]
  106088:	e3530000 	cmp	r3, #0
  10608c:	0a000025 	beq	106128 <netdev_low_level_set_ipaddr+0xdc>
  106090:	e51b3008 	ldr	r3, [fp, #-8]
  106094:	e593200c 	ldr	r2, [r3, #12]
  106098:	e51b300c 	ldr	r3, [fp, #-12]
  10609c:	e5933000 	ldr	r3, [r3]
  1060a0:	e1520003 	cmp	r2, r3
  1060a4:	0a00001f 	beq	106128 <netdev_low_level_set_ipaddr+0xdc>
    {
        ip_addr_copy(netdev->ip_addr, *ip_addr);
  1060a8:	e51b300c 	ldr	r3, [fp, #-12]
  1060ac:	e5932000 	ldr	r2, [r3]
  1060b0:	e51b3008 	ldr	r3, [fp, #-8]
  1060b4:	e583200c 	str	r2, [r3, #12]

#ifdef RT_USING_SAL
        /* set network interface device flags to internet up */
        if (netdev_is_up(netdev) && netdev_is_link_up(netdev))
  1060b8:	e51b3008 	ldr	r3, [fp, #-8]
  1060bc:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1060c0:	e2033001 	and	r3, r3, #1
  1060c4:	e6ef3073 	uxtb	r3, r3
  1060c8:	e3530000 	cmp	r3, #0
  1060cc:	0a00000c 	beq	106104 <netdev_low_level_set_ipaddr+0xb8>
  1060d0:	e51b3008 	ldr	r3, [fp, #-8]
  1060d4:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1060d8:	e1a03123 	lsr	r3, r3, #2
  1060dc:	e2033001 	and	r3, r3, #1
  1060e0:	e6ef3073 	uxtb	r3, r3
  1060e4:	e3530000 	cmp	r3, #0
  1060e8:	0a000005 	beq	106104 <netdev_low_level_set_ipaddr+0xb8>
        {
            // sal_check_netdev_internet_up(netdev);
            // check_netdev_internet_up_work(netdev);
            netdev->flags |= NETDEV_FLAG_INTERNET_UP;
  1060ec:	e51b3008 	ldr	r3, [fp, #-8]
  1060f0:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1060f4:	e3833080 	orr	r3, r3, #128	; 0x80
  1060f8:	e6ff2073 	uxth	r2, r3
  1060fc:	e51b3008 	ldr	r3, [fp, #-8]
  106100:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
        }
#endif /* RT_USING_SAL */

        /* execute IP address change callback function */
        if (netdev->addr_callback)
  106104:	e51b3008 	ldr	r3, [fp, #-8]
  106108:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10610c:	e3530000 	cmp	r3, #0
  106110:	0a000004 	beq	106128 <netdev_low_level_set_ipaddr+0xdc>
        {
            netdev->addr_callback(netdev, NETDEV_CB_ADDR_IP);
  106114:	e51b3008 	ldr	r3, [fp, #-8]
  106118:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10611c:	e3a01000 	mov	r1, #0
  106120:	e51b0008 	ldr	r0, [fp, #-8]
  106124:	e12fff33 	blx	r3
        }
    }
}
  106128:	e320f000 	nop	{0}
  10612c:	e24bd004 	sub	sp, fp, #4
  106130:	e8bd8800 	pop	{fp, pc}

00106134 <netdev_low_level_set_netmask>:
 *
 * @param netdev the network interface device to change
 * @param netmask the new netmask address
 */
void netdev_low_level_set_netmask(struct netdev *netdev, const ip_addr_t *netmask)
{
  106134:	e92d4800 	push	{fp, lr}
  106138:	e28db004 	add	fp, sp, #4
  10613c:	e24dd008 	sub	sp, sp, #8
  106140:	e50b0008 	str	r0, [fp, #-8]
  106144:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(netmask);
  106148:	e51b300c 	ldr	r3, [fp, #-12]
  10614c:	e3530000 	cmp	r3, #0
  106150:	1a000005 	bne	10616c <netdev_low_level_set_netmask+0x38>
  106154:	e3a02f9f 	mov	r2, #636	; 0x27c
  106158:	e3061118 	movw	r1, #24856	; 0x6118
  10615c:	e3401014 	movt	r1, #20
  106160:	e3050df4 	movw	r0, #24052	; 0x5df4
  106164:	e3400014 	movt	r0, #20
  106168:	ebfff50a 	bl	103598 <rt_assert_handler>

    if (netdev && ip_addr_cmp(&(netdev->netmask), netmask) == 0)
  10616c:	e51b3008 	ldr	r3, [fp, #-8]
  106170:	e3530000 	cmp	r3, #0
  106174:	0a00002d 	beq	106230 <netdev_low_level_set_netmask+0xfc>
  106178:	e51b3008 	ldr	r3, [fp, #-8]
  10617c:	e5932010 	ldr	r2, [r3, #16]
  106180:	e51b300c 	ldr	r3, [fp, #-12]
  106184:	e5933000 	ldr	r3, [r3]
  106188:	e1520003 	cmp	r2, r3
  10618c:	0a000027 	beq	106230 <netdev_low_level_set_netmask+0xfc>
    {
        ip_addr_copy(netdev->netmask, *netmask);
  106190:	e51b300c 	ldr	r3, [fp, #-12]
  106194:	e5932000 	ldr	r2, [r3]
  106198:	e51b3008 	ldr	r3, [fp, #-8]
  10619c:	e5832010 	str	r2, [r3, #16]

#ifdef RT_USING_SAL
        /* set network interface device flags to internet up */
        if (netdev_is_up(netdev) && netdev_is_link_up(netdev) &&
  1061a0:	e51b3008 	ldr	r3, [fp, #-8]
  1061a4:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1061a8:	e2033001 	and	r3, r3, #1
  1061ac:	e6ef3073 	uxtb	r3, r3
  1061b0:	e3530000 	cmp	r3, #0
  1061b4:	0a000014 	beq	10620c <netdev_low_level_set_netmask+0xd8>
  1061b8:	e51b3008 	ldr	r3, [fp, #-8]
  1061bc:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1061c0:	e1a03123 	lsr	r3, r3, #2
  1061c4:	e2033001 	and	r3, r3, #1
  1061c8:	e6ef3073 	uxtb	r3, r3
  1061cc:	e3530000 	cmp	r3, #0
  1061d0:	0a00000d 	beq	10620c <netdev_low_level_set_netmask+0xd8>
                !ip_addr_isany(&(netdev->ip_addr)))
  1061d4:	e51b3008 	ldr	r3, [fp, #-8]
  1061d8:	e283300c 	add	r3, r3, #12
        if (netdev_is_up(netdev) && netdev_is_link_up(netdev) &&
  1061dc:	e3530000 	cmp	r3, #0
  1061e0:	0a000009 	beq	10620c <netdev_low_level_set_netmask+0xd8>
                !ip_addr_isany(&(netdev->ip_addr)))
  1061e4:	e51b3008 	ldr	r3, [fp, #-8]
  1061e8:	e593300c 	ldr	r3, [r3, #12]
  1061ec:	e3530000 	cmp	r3, #0
  1061f0:	0a000005 	beq	10620c <netdev_low_level_set_netmask+0xd8>
        {
            // sal_check_netdev_internet_up(netdev);
            // check_netdev_internet_up_work(netdev);
            netdev->flags |= NETDEV_FLAG_INTERNET_UP;
  1061f4:	e51b3008 	ldr	r3, [fp, #-8]
  1061f8:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1061fc:	e3833080 	orr	r3, r3, #128	; 0x80
  106200:	e6ff2073 	uxth	r2, r3
  106204:	e51b3008 	ldr	r3, [fp, #-8]
  106208:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
        }
#endif /* RT_USING_SAL */

        /* execute netmask address change callback function */
        if (netdev->addr_callback)
  10620c:	e51b3008 	ldr	r3, [fp, #-8]
  106210:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  106214:	e3530000 	cmp	r3, #0
  106218:	0a000004 	beq	106230 <netdev_low_level_set_netmask+0xfc>
        {
            netdev->addr_callback(netdev, NETDEV_CB_ADDR_NETMASK);
  10621c:	e51b3008 	ldr	r3, [fp, #-8]
  106220:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  106224:	e3a01001 	mov	r1, #1
  106228:	e51b0008 	ldr	r0, [fp, #-8]
  10622c:	e12fff33 	blx	r3
        }
    }
}
  106230:	e320f000 	nop	{0}
  106234:	e24bd004 	sub	sp, fp, #4
  106238:	e8bd8800 	pop	{fp, pc}

0010623c <netdev_low_level_set_gw>:
 *
 * @param netdev the network interface device to change
 * @param gateway the new gateway address
 */
void netdev_low_level_set_gw(struct netdev *netdev, const ip_addr_t *gw)
{
  10623c:	e92d4800 	push	{fp, lr}
  106240:	e28db004 	add	fp, sp, #4
  106244:	e24dd008 	sub	sp, sp, #8
  106248:	e50b0008 	str	r0, [fp, #-8]
  10624c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(gw);
  106250:	e51b300c 	ldr	r3, [fp, #-12]
  106254:	e3530000 	cmp	r3, #0
  106258:	1a000005 	bne	106274 <netdev_low_level_set_gw+0x38>
  10625c:	e300229e 	movw	r2, #670	; 0x29e
  106260:	e3061138 	movw	r1, #24888	; 0x6138
  106264:	e3401014 	movt	r1, #20
  106268:	e3050ea4 	movw	r0, #24228	; 0x5ea4
  10626c:	e3400014 	movt	r0, #20
  106270:	ebfff4c8 	bl	103598 <rt_assert_handler>

    if (netdev && ip_addr_cmp(&(netdev->gw), gw) == 0)
  106274:	e51b3008 	ldr	r3, [fp, #-8]
  106278:	e3530000 	cmp	r3, #0
  10627c:	0a00002d 	beq	106338 <netdev_low_level_set_gw+0xfc>
  106280:	e51b3008 	ldr	r3, [fp, #-8]
  106284:	e5932014 	ldr	r2, [r3, #20]
  106288:	e51b300c 	ldr	r3, [fp, #-12]
  10628c:	e5933000 	ldr	r3, [r3]
  106290:	e1520003 	cmp	r2, r3
  106294:	0a000027 	beq	106338 <netdev_low_level_set_gw+0xfc>
    {
        ip_addr_copy(netdev->gw, *gw);
  106298:	e51b300c 	ldr	r3, [fp, #-12]
  10629c:	e5932000 	ldr	r2, [r3]
  1062a0:	e51b3008 	ldr	r3, [fp, #-8]
  1062a4:	e5832014 	str	r2, [r3, #20]

#ifdef RT_USING_SAL
        /* set network interface device flags to internet up */
        if (netdev_is_up(netdev) && netdev_is_link_up(netdev) &&
  1062a8:	e51b3008 	ldr	r3, [fp, #-8]
  1062ac:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1062b0:	e2033001 	and	r3, r3, #1
  1062b4:	e6ef3073 	uxtb	r3, r3
  1062b8:	e3530000 	cmp	r3, #0
  1062bc:	0a000014 	beq	106314 <netdev_low_level_set_gw+0xd8>
  1062c0:	e51b3008 	ldr	r3, [fp, #-8]
  1062c4:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1062c8:	e1a03123 	lsr	r3, r3, #2
  1062cc:	e2033001 	and	r3, r3, #1
  1062d0:	e6ef3073 	uxtb	r3, r3
  1062d4:	e3530000 	cmp	r3, #0
  1062d8:	0a00000d 	beq	106314 <netdev_low_level_set_gw+0xd8>
                !ip_addr_isany(&(netdev->ip_addr)))
  1062dc:	e51b3008 	ldr	r3, [fp, #-8]
  1062e0:	e283300c 	add	r3, r3, #12
        if (netdev_is_up(netdev) && netdev_is_link_up(netdev) &&
  1062e4:	e3530000 	cmp	r3, #0
  1062e8:	0a000009 	beq	106314 <netdev_low_level_set_gw+0xd8>
                !ip_addr_isany(&(netdev->ip_addr)))
  1062ec:	e51b3008 	ldr	r3, [fp, #-8]
  1062f0:	e593300c 	ldr	r3, [r3, #12]
  1062f4:	e3530000 	cmp	r3, #0
  1062f8:	0a000005 	beq	106314 <netdev_low_level_set_gw+0xd8>
        {
            // sal_check_netdev_internet_up(netdev);
            // check_netdev_internet_up_work(netdev);
            netdev->flags |= NETDEV_FLAG_INTERNET_UP;
  1062fc:	e51b3008 	ldr	r3, [fp, #-8]
  106300:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  106304:	e3833080 	orr	r3, r3, #128	; 0x80
  106308:	e6ff2073 	uxth	r2, r3
  10630c:	e51b3008 	ldr	r3, [fp, #-8]
  106310:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
        }
#endif /* RT_USING_SAL */

        /* execute gateway address change callback function */
        if (netdev->addr_callback)
  106314:	e51b3008 	ldr	r3, [fp, #-8]
  106318:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10631c:	e3530000 	cmp	r3, #0
  106320:	0a000004 	beq	106338 <netdev_low_level_set_gw+0xfc>
        {
            netdev->addr_callback(netdev, NETDEV_CB_ADDR_GATEWAY);
  106324:	e51b3008 	ldr	r3, [fp, #-8]
  106328:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10632c:	e3a01002 	mov	r1, #2
  106330:	e51b0008 	ldr	r0, [fp, #-8]
  106334:	e12fff33 	blx	r3
        }
    }
}
  106338:	e320f000 	nop	{0}
  10633c:	e24bd004 	sub	sp, fp, #4
  106340:	e8bd8800 	pop	{fp, pc}

00106344 <netdev_low_level_set_dns_server>:
 * @param netdev the network interface device to change
 * @param dns_server the new DNS server address
 *
 */
void netdev_low_level_set_dns_server(struct netdev *netdev, uint8_t dns_num, const ip_addr_t *dns_server)
{
  106344:	e92d4800 	push	{fp, lr}
  106348:	e28db004 	add	fp, sp, #4
  10634c:	e24dd018 	sub	sp, sp, #24
  106350:	e50b0010 	str	r0, [fp, #-16]
  106354:	e1a03001 	mov	r3, r1
  106358:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  10635c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    int index;

    RT_ASSERT(dns_server);
  106360:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  106364:	e3530000 	cmp	r3, #0
  106368:	1a000005 	bne	106384 <netdev_low_level_set_dns_server+0x40>
  10636c:	e30022c3 	movw	r2, #707	; 0x2c3
  106370:	e3061150 	movw	r1, #24912	; 0x6150
  106374:	e3401014 	movt	r1, #20
  106378:	e3050f50 	movw	r0, #24400	; 0x5f50
  10637c:	e3400014 	movt	r0, #20
  106380:	ebfff484 	bl	103598 <rt_assert_handler>

    if (netdev == RT_NULL)
  106384:	e51b3010 	ldr	r3, [fp, #-16]
  106388:	e3530000 	cmp	r3, #0
  10638c:	0a000023 	beq	106420 <netdev_low_level_set_dns_server+0xdc>
    {
        return;
    }
    /* check DNS servers is exist */
    for (index = 0; index < NETDEV_DNS_SERVERS_NUM; index++)
  106390:	e3a03000 	mov	r3, #0
  106394:	e50b3008 	str	r3, [fp, #-8]
  106398:	ea00000a 	b	1063c8 <netdev_low_level_set_dns_server+0x84>
    {
        if (ip_addr_cmp(&(netdev->dns_servers[index]), dns_server))
  10639c:	e51b3010 	ldr	r3, [fp, #-16]
  1063a0:	e51b2008 	ldr	r2, [fp, #-8]
  1063a4:	e2822006 	add	r2, r2, #6
  1063a8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  1063ac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1063b0:	e5933000 	ldr	r3, [r3]
  1063b4:	e1520003 	cmp	r2, r3
  1063b8:	0a00001a 	beq	106428 <netdev_low_level_set_dns_server+0xe4>
    for (index = 0; index < NETDEV_DNS_SERVERS_NUM; index++)
  1063bc:	e51b3008 	ldr	r3, [fp, #-8]
  1063c0:	e2833001 	add	r3, r3, #1
  1063c4:	e50b3008 	str	r3, [fp, #-8]
  1063c8:	e51b3008 	ldr	r3, [fp, #-8]
  1063cc:	e3530001 	cmp	r3, #1
  1063d0:	9afffff1 	bls	10639c <netdev_low_level_set_dns_server+0x58>
        {
            return;
        }
    }

    if (dns_num < NETDEV_DNS_SERVERS_NUM)
  1063d4:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  1063d8:	e3530001 	cmp	r3, #1
  1063dc:	8a000012 	bhi	10642c <netdev_low_level_set_dns_server+0xe8>
    {
        ip_addr_copy(netdev->dns_servers[dns_num], *dns_server);
  1063e0:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  1063e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1063e8:	e5931000 	ldr	r1, [r3]
  1063ec:	e51b3010 	ldr	r3, [fp, #-16]
  1063f0:	e2822006 	add	r2, r2, #6
  1063f4:	e7831102 	str	r1, [r3, r2, lsl #2]

        /* execute DNS servers address change callback function */
        if (netdev->addr_callback)
  1063f8:	e51b3010 	ldr	r3, [fp, #-16]
  1063fc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  106400:	e3530000 	cmp	r3, #0
  106404:	0a000008 	beq	10642c <netdev_low_level_set_dns_server+0xe8>
        {
            netdev->addr_callback(netdev, NETDEV_CB_ADDR_DNS_SERVER);
  106408:	e51b3010 	ldr	r3, [fp, #-16]
  10640c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  106410:	e3a01003 	mov	r1, #3
  106414:	e51b0010 	ldr	r0, [fp, #-16]
  106418:	e12fff33 	blx	r3
  10641c:	ea000002 	b	10642c <netdev_low_level_set_dns_server+0xe8>
        return;
  106420:	e320f000 	nop	{0}
  106424:	ea000000 	b	10642c <netdev_low_level_set_dns_server+0xe8>
            return;
  106428:	e320f000 	nop	{0}
        }
    }
}
  10642c:	e24bd004 	sub	sp, fp, #4
  106430:	e8bd8800 	pop	{fp, pc}

00106434 <netdev_low_level_set_status>:
 *
 * @param netdev the network interface device to change
 * @param is_up the new status
 */
void netdev_low_level_set_status(struct netdev *netdev, rt_bool_t is_up)
{
  106434:	e92d4800 	push	{fp, lr}
  106438:	e28db004 	add	fp, sp, #4
  10643c:	e24dd008 	sub	sp, sp, #8
  106440:	e50b0008 	str	r0, [fp, #-8]
  106444:	e50b100c 	str	r1, [fp, #-12]
    if (netdev && netdev_is_up(netdev) != is_up)
  106448:	e51b3008 	ldr	r3, [fp, #-8]
  10644c:	e3530000 	cmp	r3, #0
  106450:	0a000024 	beq	1064e8 <netdev_low_level_set_status+0xb4>
  106454:	e51b3008 	ldr	r3, [fp, #-8]
  106458:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  10645c:	e2033001 	and	r3, r3, #1
  106460:	e51b200c 	ldr	r2, [fp, #-12]
  106464:	e1520003 	cmp	r2, r3
  106468:	0a00001e 	beq	1064e8 <netdev_low_level_set_status+0xb4>
    {
        if (is_up)
  10646c:	e51b300c 	ldr	r3, [fp, #-12]
  106470:	e3530000 	cmp	r3, #0
  106474:	0a000006 	beq	106494 <netdev_low_level_set_status+0x60>
        {
            netdev->flags |= NETDEV_FLAG_UP;
  106478:	e51b3008 	ldr	r3, [fp, #-8]
  10647c:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  106480:	e3833001 	orr	r3, r3, #1
  106484:	e6ff2073 	uxth	r2, r3
  106488:	e51b3008 	ldr	r3, [fp, #-8]
  10648c:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
  106490:	ea000005 	b	1064ac <netdev_low_level_set_status+0x78>
        }
        else
        {
            netdev->flags &= ~NETDEV_FLAG_UP;
  106494:	e51b3008 	ldr	r3, [fp, #-8]
  106498:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  10649c:	e3c33001 	bic	r3, r3, #1
  1064a0:	e6ff2073 	uxth	r2, r3
  1064a4:	e51b3008 	ldr	r3, [fp, #-8]
  1064a8:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
            netdev_auto_change_default(netdev);
#endif /* NETDEV_USING_AUTO_DEFAULT */
        }

        /* execute  network interface device status change callback function */
        if (netdev->status_callback)
  1064ac:	e51b3008 	ldr	r3, [fp, #-8]
  1064b0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  1064b4:	e3530000 	cmp	r3, #0
  1064b8:	0a00000a 	beq	1064e8 <netdev_low_level_set_status+0xb4>
        {
            netdev->status_callback(netdev, is_up ? NETDEV_CB_STATUS_UP : NETDEV_CB_STATUS_DOWN);
  1064bc:	e51b3008 	ldr	r3, [fp, #-8]
  1064c0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  1064c4:	e51b200c 	ldr	r2, [fp, #-12]
  1064c8:	e3520000 	cmp	r2, #0
  1064cc:	0a000001 	beq	1064d8 <netdev_low_level_set_status+0xa4>
  1064d0:	e3a02004 	mov	r2, #4
  1064d4:	ea000000 	b	1064dc <netdev_low_level_set_status+0xa8>
  1064d8:	e3a02005 	mov	r2, #5
  1064dc:	e1a01002 	mov	r1, r2
  1064e0:	e51b0008 	ldr	r0, [fp, #-8]
  1064e4:	e12fff33 	blx	r3
        }
    }
}
  1064e8:	e320f000 	nop	{0}
  1064ec:	e24bd004 	sub	sp, fp, #4
  1064f0:	e8bd8800 	pop	{fp, pc}

001064f4 <netdev_low_level_set_link_status>:
 *
 * @param netdev the network interface device to change
 * @param is_up the new link status
 */
void netdev_low_level_set_link_status(struct netdev *netdev, rt_bool_t is_up)
{
  1064f4:	e92d4800 	push	{fp, lr}
  1064f8:	e28db004 	add	fp, sp, #4
  1064fc:	e24dd008 	sub	sp, sp, #8
  106500:	e50b0008 	str	r0, [fp, #-8]
  106504:	e50b100c 	str	r1, [fp, #-12]
    if (netdev && netdev_is_link_up(netdev) != is_up)
  106508:	e51b3008 	ldr	r3, [fp, #-8]
  10650c:	e3530000 	cmp	r3, #0
  106510:	0a00003f 	beq	106614 <netdev_low_level_set_link_status+0x120>
  106514:	e51b3008 	ldr	r3, [fp, #-8]
  106518:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  10651c:	e1a03123 	lsr	r3, r3, #2
  106520:	e2033001 	and	r3, r3, #1
  106524:	e51b200c 	ldr	r2, [fp, #-12]
  106528:	e1520003 	cmp	r2, r3
  10652c:	0a000038 	beq	106614 <netdev_low_level_set_link_status+0x120>
    {
        if (is_up)
  106530:	e51b300c 	ldr	r3, [fp, #-12]
  106534:	e3530000 	cmp	r3, #0
  106538:	0a00001a 	beq	1065a8 <netdev_low_level_set_link_status+0xb4>
        {
            netdev->flags |= NETDEV_FLAG_LINK_UP;
  10653c:	e51b3008 	ldr	r3, [fp, #-8]
  106540:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  106544:	e3833004 	orr	r3, r3, #4
  106548:	e6ff2073 	uxth	r2, r3
  10654c:	e51b3008 	ldr	r3, [fp, #-8]
  106550:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a

#ifdef RT_USING_SAL
            /* set network interface device flags to internet up */
            if (netdev_is_up(netdev) && !ip_addr_isany(&(netdev->ip_addr)))
  106554:	e51b3008 	ldr	r3, [fp, #-8]
  106558:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  10655c:	e2033001 	and	r3, r3, #1
  106560:	e6ef3073 	uxtb	r3, r3
  106564:	e3530000 	cmp	r3, #0
  106568:	0a00001a 	beq	1065d8 <netdev_low_level_set_link_status+0xe4>
  10656c:	e51b3008 	ldr	r3, [fp, #-8]
  106570:	e283300c 	add	r3, r3, #12
  106574:	e3530000 	cmp	r3, #0
  106578:	0a000016 	beq	1065d8 <netdev_low_level_set_link_status+0xe4>
  10657c:	e51b3008 	ldr	r3, [fp, #-8]
  106580:	e593300c 	ldr	r3, [r3, #12]
  106584:	e3530000 	cmp	r3, #0
  106588:	0a000012 	beq	1065d8 <netdev_low_level_set_link_status+0xe4>
            {
                // sal_check_netdev_internet_up(netdev);
                // check_netdev_internet_up_work(netdev);
                netdev->flags |= NETDEV_FLAG_INTERNET_UP;
  10658c:	e51b3008 	ldr	r3, [fp, #-8]
  106590:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  106594:	e3833080 	orr	r3, r3, #128	; 0x80
  106598:	e6ff2073 	uxth	r2, r3
  10659c:	e51b3008 	ldr	r3, [fp, #-8]
  1065a0:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
  1065a4:	ea00000b 	b	1065d8 <netdev_low_level_set_link_status+0xe4>
            }
#endif /* RT_USING_SAL */
        }
        else
        {
            netdev->flags &= ~NETDEV_FLAG_LINK_UP;
  1065a8:	e51b3008 	ldr	r3, [fp, #-8]
  1065ac:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1065b0:	e3c33004 	bic	r3, r3, #4
  1065b4:	e6ff2073 	uxth	r2, r3
  1065b8:	e51b3008 	ldr	r3, [fp, #-8]
  1065bc:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a

            /* set network interface device flags to internet down */
            netdev->flags &= ~NETDEV_FLAG_INTERNET_UP;
  1065c0:	e51b3008 	ldr	r3, [fp, #-8]
  1065c4:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1065c8:	e3c33080 	bic	r3, r3, #128	; 0x80
  1065cc:	e6ff2073 	uxth	r2, r3
  1065d0:	e51b3008 	ldr	r3, [fp, #-8]
  1065d4:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
            /* change to the first link_up network interface device automatically */
            netdev_auto_change_default(netdev);
#endif /* NETDEV_USING_AUTO_DEFAULT */

        /* execute link status change callback function */
        if (netdev->status_callback)
  1065d8:	e51b3008 	ldr	r3, [fp, #-8]
  1065dc:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  1065e0:	e3530000 	cmp	r3, #0
  1065e4:	0a00000a 	beq	106614 <netdev_low_level_set_link_status+0x120>
        {
            netdev->status_callback(netdev, is_up ? NETDEV_CB_STATUS_LINK_UP : NETDEV_CB_STATUS_LINK_DOWN);
  1065e8:	e51b3008 	ldr	r3, [fp, #-8]
  1065ec:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  1065f0:	e51b200c 	ldr	r2, [fp, #-12]
  1065f4:	e3520000 	cmp	r2, #0
  1065f8:	0a000001 	beq	106604 <netdev_low_level_set_link_status+0x110>
  1065fc:	e3a02006 	mov	r2, #6
  106600:	ea000000 	b	106608 <netdev_low_level_set_link_status+0x114>
  106604:	e3a02007 	mov	r2, #7
  106608:	e1a01002 	mov	r1, r2
  10660c:	e51b0008 	ldr	r0, [fp, #-8]
  106610:	e12fff33 	blx	r3
        }
    }
}
  106614:	e320f000 	nop	{0}
  106618:	e24bd004 	sub	sp, fp, #4
  10661c:	e8bd8800 	pop	{fp, pc}

00106620 <netdev_low_level_set_dhcp_status>:
 *
 * @param netdev the network interface device to change
 * @param is_up the new DHCP status
 */
void netdev_low_level_set_dhcp_status(struct netdev *netdev, rt_bool_t is_enable)
{
  106620:	e92d4800 	push	{fp, lr}
  106624:	e28db004 	add	fp, sp, #4
  106628:	e24dd008 	sub	sp, sp, #8
  10662c:	e50b0008 	str	r0, [fp, #-8]
  106630:	e50b100c 	str	r1, [fp, #-12]
    if (netdev && netdev_is_dhcp_enabled(netdev) != is_enable)
  106634:	e51b3008 	ldr	r3, [fp, #-8]
  106638:	e3530000 	cmp	r3, #0
  10663c:	0a000025 	beq	1066d8 <netdev_low_level_set_dhcp_status+0xb8>
  106640:	e51b3008 	ldr	r3, [fp, #-8]
  106644:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  106648:	e1a03423 	lsr	r3, r3, #8
  10664c:	e2033001 	and	r3, r3, #1
  106650:	e51b200c 	ldr	r2, [fp, #-12]
  106654:	e1520003 	cmp	r2, r3
  106658:	0a00001e 	beq	1066d8 <netdev_low_level_set_dhcp_status+0xb8>
    {
        if (is_enable)
  10665c:	e51b300c 	ldr	r3, [fp, #-12]
  106660:	e3530000 	cmp	r3, #0
  106664:	0a000006 	beq	106684 <netdev_low_level_set_dhcp_status+0x64>
        {
            netdev->flags |= NETDEV_FLAG_DHCP;
  106668:	e51b3008 	ldr	r3, [fp, #-8]
  10666c:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  106670:	e3833c01 	orr	r3, r3, #256	; 0x100
  106674:	e6ff2073 	uxth	r2, r3
  106678:	e51b3008 	ldr	r3, [fp, #-8]
  10667c:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
  106680:	ea000005 	b	10669c <netdev_low_level_set_dhcp_status+0x7c>
        }
        else
        {
            netdev->flags &= ~NETDEV_FLAG_DHCP;
  106684:	e51b3008 	ldr	r3, [fp, #-8]
  106688:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  10668c:	e3c33c01 	bic	r3, r3, #256	; 0x100
  106690:	e6ff2073 	uxth	r2, r3
  106694:	e51b3008 	ldr	r3, [fp, #-8]
  106698:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
        }

        /* execute DHCP status change callback function */
        if (netdev->status_callback)
  10669c:	e51b3008 	ldr	r3, [fp, #-8]
  1066a0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  1066a4:	e3530000 	cmp	r3, #0
  1066a8:	0a00000a 	beq	1066d8 <netdev_low_level_set_dhcp_status+0xb8>
        {
            netdev->status_callback(netdev, is_enable ? NETDEV_CB_STATUS_DHCP_ENABLE : NETDEV_CB_STATUS_DHCP_DISABLE);
  1066ac:	e51b3008 	ldr	r3, [fp, #-8]
  1066b0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  1066b4:	e51b200c 	ldr	r2, [fp, #-12]
  1066b8:	e3520000 	cmp	r2, #0
  1066bc:	0a000001 	beq	1066c8 <netdev_low_level_set_dhcp_status+0xa8>
  1066c0:	e3a0200a 	mov	r2, #10
  1066c4:	ea000000 	b	1066cc <netdev_low_level_set_dhcp_status+0xac>
  1066c8:	e3a0200b 	mov	r2, #11
  1066cc:	e1a01002 	mov	r1, r2
  1066d0:	e51b0008 	ldr	r0, [fp, #-8]
  1066d4:	e12fff33 	blx	r3
        }
    }
}
  1066d8:	e320f000 	nop	{0}
  1066dc:	e24bd004 	sub	sp, fp, #4
  1066e0:	e8bd8800 	pop	{fp, pc}

001066e4 <netdev_ip4addr_aton>:
 * @param cp IP address in ascii representation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int netdev_ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
  1066e4:	e92d4800 	push	{fp, lr}
  1066e8:	e28db004 	add	fp, sp, #4
  1066ec:	e24dd028 	sub	sp, sp, #40	; 0x28
  1066f0:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  1066f4:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
    uint32_t val;
    uint8_t base;
    char c;
    uint32_t parts[4];
    uint32_t *pp = parts;
  1066f8:	e24b3020 	sub	r3, fp, #32
  1066fc:	e50b3010 	str	r3, [fp, #-16]

    c = *cp;
  106700:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106704:	e5d33000 	ldrb	r3, [r3]
  106708:	e54b300a 	strb	r3, [fp, #-10]
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, 1-9=decimal.
         */
        if (!isdigit(c))
  10670c:	e55b300a 	ldrb	r3, [fp, #-10]
  106710:	e353002f 	cmp	r3, #47	; 0x2f
  106714:	9a000002 	bls	106724 <netdev_ip4addr_aton+0x40>
  106718:	e55b300a 	ldrb	r3, [fp, #-10]
  10671c:	e3530039 	cmp	r3, #57	; 0x39
  106720:	9a000001 	bls	10672c <netdev_ip4addr_aton+0x48>
        {
            return 0;
  106724:	e3a03000 	mov	r3, #0
  106728:	ea0000f7 	b	106b0c <netdev_ip4addr_aton+0x428>
        }
        val = 0;
  10672c:	e3a03000 	mov	r3, #0
  106730:	e50b3008 	str	r3, [fp, #-8]
        base = 10;
  106734:	e3a0300a 	mov	r3, #10
  106738:	e54b3009 	strb	r3, [fp, #-9]
        if (c == '0')
  10673c:	e55b300a 	ldrb	r3, [fp, #-10]
  106740:	e3530030 	cmp	r3, #48	; 0x30
  106744:	1a000016 	bne	1067a4 <netdev_ip4addr_aton+0xc0>
        {
            c = *++cp;
  106748:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10674c:	e2833001 	add	r3, r3, #1
  106750:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  106754:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106758:	e5d33000 	ldrb	r3, [r3]
  10675c:	e54b300a 	strb	r3, [fp, #-10]
            if (c == 'x' || c == 'X')
  106760:	e55b300a 	ldrb	r3, [fp, #-10]
  106764:	e3530078 	cmp	r3, #120	; 0x78
  106768:	0a000002 	beq	106778 <netdev_ip4addr_aton+0x94>
  10676c:	e55b300a 	ldrb	r3, [fp, #-10]
  106770:	e3530058 	cmp	r3, #88	; 0x58
  106774:	1a000008 	bne	10679c <netdev_ip4addr_aton+0xb8>
            {
                base = 16;
  106778:	e3a03010 	mov	r3, #16
  10677c:	e54b3009 	strb	r3, [fp, #-9]
                c = *++cp;
  106780:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106784:	e2833001 	add	r3, r3, #1
  106788:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  10678c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106790:	e5d33000 	ldrb	r3, [r3]
  106794:	e54b300a 	strb	r3, [fp, #-10]
  106798:	ea000001 	b	1067a4 <netdev_ip4addr_aton+0xc0>
            }
            else
            {
                base = 8;
  10679c:	e3a03008 	mov	r3, #8
  1067a0:	e54b3009 	strb	r3, [fp, #-9]
            }
        }
        for (;;)
        {
            if (isdigit(c))
  1067a4:	e55b300a 	ldrb	r3, [fp, #-10]
  1067a8:	e353002f 	cmp	r3, #47	; 0x2f
  1067ac:	9a000010 	bls	1067f4 <netdev_ip4addr_aton+0x110>
  1067b0:	e55b300a 	ldrb	r3, [fp, #-10]
  1067b4:	e3530039 	cmp	r3, #57	; 0x39
  1067b8:	8a00000d 	bhi	1067f4 <netdev_ip4addr_aton+0x110>
            {
                val = (val * base) + (uint32_t) (c - '0');
  1067bc:	e55b3009 	ldrb	r3, [fp, #-9]
  1067c0:	e51b2008 	ldr	r2, [fp, #-8]
  1067c4:	e0020392 	mul	r2, r2, r3
  1067c8:	e55b300a 	ldrb	r3, [fp, #-10]
  1067cc:	e0823003 	add	r3, r2, r3
  1067d0:	e2433030 	sub	r3, r3, #48	; 0x30
  1067d4:	e50b3008 	str	r3, [fp, #-8]
                c = *++cp;
  1067d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1067dc:	e2833001 	add	r3, r3, #1
  1067e0:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  1067e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1067e8:	e5d33000 	ldrb	r3, [r3]
  1067ec:	e54b300a 	strb	r3, [fp, #-10]
  1067f0:	ea00002a 	b	1068a0 <netdev_ip4addr_aton+0x1bc>
            }
            else if (base == 16 && isxdigit(c))
  1067f4:	e55b3009 	ldrb	r3, [fp, #-9]
  1067f8:	e3530010 	cmp	r3, #16
  1067fc:	1a000028 	bne	1068a4 <netdev_ip4addr_aton+0x1c0>
  106800:	e55b300a 	ldrb	r3, [fp, #-10]
  106804:	e353002f 	cmp	r3, #47	; 0x2f
  106808:	9a000002 	bls	106818 <netdev_ip4addr_aton+0x134>
  10680c:	e55b300a 	ldrb	r3, [fp, #-10]
  106810:	e3530039 	cmp	r3, #57	; 0x39
  106814:	9a00000b 	bls	106848 <netdev_ip4addr_aton+0x164>
  106818:	e55b300a 	ldrb	r3, [fp, #-10]
  10681c:	e3530060 	cmp	r3, #96	; 0x60
  106820:	9a000002 	bls	106830 <netdev_ip4addr_aton+0x14c>
  106824:	e55b300a 	ldrb	r3, [fp, #-10]
  106828:	e3530066 	cmp	r3, #102	; 0x66
  10682c:	9a000005 	bls	106848 <netdev_ip4addr_aton+0x164>
  106830:	e55b300a 	ldrb	r3, [fp, #-10]
  106834:	e3530040 	cmp	r3, #64	; 0x40
  106838:	9a000019 	bls	1068a4 <netdev_ip4addr_aton+0x1c0>
  10683c:	e55b300a 	ldrb	r3, [fp, #-10]
  106840:	e3530046 	cmp	r3, #70	; 0x46
  106844:	8a000016 	bhi	1068a4 <netdev_ip4addr_aton+0x1c0>
            {
                val = (val << 4) | (uint32_t) (c + 10 - (islower(c) ? 'a' : 'A'));
  106848:	e51b3008 	ldr	r3, [fp, #-8]
  10684c:	e1a03203 	lsl	r3, r3, #4
  106850:	e55b200a 	ldrb	r2, [fp, #-10]
  106854:	e282100a 	add	r1, r2, #10
  106858:	e55b200a 	ldrb	r2, [fp, #-10]
  10685c:	e3520060 	cmp	r2, #96	; 0x60
  106860:	9a000004 	bls	106878 <netdev_ip4addr_aton+0x194>
  106864:	e55b200a 	ldrb	r2, [fp, #-10]
  106868:	e352007a 	cmp	r2, #122	; 0x7a
  10686c:	8a000001 	bhi	106878 <netdev_ip4addr_aton+0x194>
  106870:	e3a02061 	mov	r2, #97	; 0x61
  106874:	ea000000 	b	10687c <netdev_ip4addr_aton+0x198>
  106878:	e3a02041 	mov	r2, #65	; 0x41
  10687c:	e0412002 	sub	r2, r1, r2
  106880:	e1833002 	orr	r3, r3, r2
  106884:	e50b3008 	str	r3, [fp, #-8]
                c = *++cp;
  106888:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10688c:	e2833001 	add	r3, r3, #1
  106890:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  106894:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106898:	e5d33000 	ldrb	r3, [r3]
  10689c:	e54b300a 	strb	r3, [fp, #-10]
            if (isdigit(c))
  1068a0:	eaffffbf 	b	1067a4 <netdev_ip4addr_aton+0xc0>
            else
            {
                break;
            }
        }
        if (c == '.')
  1068a4:	e55b300a 	ldrb	r3, [fp, #-10]
  1068a8:	e353002e 	cmp	r3, #46	; 0x2e
  1068ac:	1a000012 	bne	1068fc <netdev_ip4addr_aton+0x218>
             * Internet format:
             *  a.b.c.d
             *  a.b.c   (with c treated as 16 bits)
             *  a.b (with b treated as 24 bits)
             */
            if (pp >= parts + 3)
  1068b0:	e24b3020 	sub	r3, fp, #32
  1068b4:	e283300c 	add	r3, r3, #12
  1068b8:	e51b2010 	ldr	r2, [fp, #-16]
  1068bc:	e1520003 	cmp	r2, r3
  1068c0:	3a000001 	bcc	1068cc <netdev_ip4addr_aton+0x1e8>
            {
                return 0;
  1068c4:	e3a03000 	mov	r3, #0
  1068c8:	ea00008f 	b	106b0c <netdev_ip4addr_aton+0x428>
            }
            *pp++ = val;
  1068cc:	e51b3010 	ldr	r3, [fp, #-16]
  1068d0:	e2832004 	add	r2, r3, #4
  1068d4:	e50b2010 	str	r2, [fp, #-16]
  1068d8:	e51b2008 	ldr	r2, [fp, #-8]
  1068dc:	e5832000 	str	r2, [r3]
            c = *++cp;
  1068e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1068e4:	e2833001 	add	r3, r3, #1
  1068e8:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  1068ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1068f0:	e5d33000 	ldrb	r3, [r3]
  1068f4:	e54b300a 	strb	r3, [fp, #-10]
        if (!isdigit(c))
  1068f8:	eaffff83 	b	10670c <netdev_ip4addr_aton+0x28>
        }
        else
        {
            break;
  1068fc:	e320f000 	nop	{0}
        }
    }
    /*
     * Check for trailing characters.
     */
    if (c != '\0' && !isspace(c))
  106900:	e55b300a 	ldrb	r3, [fp, #-10]
  106904:	e3530000 	cmp	r3, #0
  106908:	0a000013 	beq	10695c <netdev_ip4addr_aton+0x278>
  10690c:	e55b300a 	ldrb	r3, [fp, #-10]
  106910:	e3530020 	cmp	r3, #32
  106914:	0a000010 	beq	10695c <netdev_ip4addr_aton+0x278>
  106918:	e55b300a 	ldrb	r3, [fp, #-10]
  10691c:	e353000c 	cmp	r3, #12
  106920:	0a00000d 	beq	10695c <netdev_ip4addr_aton+0x278>
  106924:	e55b300a 	ldrb	r3, [fp, #-10]
  106928:	e353000a 	cmp	r3, #10
  10692c:	0a00000a 	beq	10695c <netdev_ip4addr_aton+0x278>
  106930:	e55b300a 	ldrb	r3, [fp, #-10]
  106934:	e353000d 	cmp	r3, #13
  106938:	0a000007 	beq	10695c <netdev_ip4addr_aton+0x278>
  10693c:	e55b300a 	ldrb	r3, [fp, #-10]
  106940:	e3530009 	cmp	r3, #9
  106944:	0a000004 	beq	10695c <netdev_ip4addr_aton+0x278>
  106948:	e55b300a 	ldrb	r3, [fp, #-10]
  10694c:	e353000b 	cmp	r3, #11
  106950:	0a000001 	beq	10695c <netdev_ip4addr_aton+0x278>
    {
        return 0;
  106954:	e3a03000 	mov	r3, #0
  106958:	ea00006b 	b	106b0c <netdev_ip4addr_aton+0x428>
    }
    /*
     * Concoct the address according to
     * the number of parts specified.
     */
    switch (pp - parts + 1)
  10695c:	e51b2010 	ldr	r2, [fp, #-16]
  106960:	e24b3020 	sub	r3, fp, #32
  106964:	e0423003 	sub	r3, r2, r3
  106968:	e1a03143 	asr	r3, r3, #2
  10696c:	e2833001 	add	r3, r3, #1
  106970:	e3530004 	cmp	r3, #4
  106974:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  106978:	ea000048 	b	106aa0 <netdev_ip4addr_aton+0x3bc>
  10697c:	00106990 	.word	0x00106990
  106980:	00106abc 	.word	0x00106abc
  106984:	00106998 	.word	0x00106998
  106988:	001069d8 	.word	0x001069d8
  10698c:	00106a30 	.word	0x00106a30
    {

    case 0:
        return 0; /* initial nondigit */
  106990:	e3a03000 	mov	r3, #0
  106994:	ea00005c 	b	106b0c <netdev_ip4addr_aton+0x428>

    case 1: /* a -- 32 bits */
        break;

    case 2: /* a.b -- 8.24 bits */
        if (val > 0xffffffUL)
  106998:	e51b3008 	ldr	r3, [fp, #-8]
  10699c:	e3530401 	cmp	r3, #16777216	; 0x1000000
  1069a0:	3a000001 	bcc	1069ac <netdev_ip4addr_aton+0x2c8>
        {
            return 0;
  1069a4:	e3a03000 	mov	r3, #0
  1069a8:	ea000057 	b	106b0c <netdev_ip4addr_aton+0x428>
        }
        if (parts[0] > 0xff)
  1069ac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1069b0:	e35300ff 	cmp	r3, #255	; 0xff
  1069b4:	9a000001 	bls	1069c0 <netdev_ip4addr_aton+0x2dc>
        {
            return 0;
  1069b8:	e3a03000 	mov	r3, #0
  1069bc:	ea000052 	b	106b0c <netdev_ip4addr_aton+0x428>
        }
        val |= parts[0] << 24;
  1069c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1069c4:	e1a03c03 	lsl	r3, r3, #24
  1069c8:	e51b2008 	ldr	r2, [fp, #-8]
  1069cc:	e1823003 	orr	r3, r2, r3
  1069d0:	e50b3008 	str	r3, [fp, #-8]
        break;
  1069d4:	ea000039 	b	106ac0 <netdev_ip4addr_aton+0x3dc>

    case 3: /* a.b.c -- 8.8.16 bits */
        if (val > 0xffff)
  1069d8:	e51b3008 	ldr	r3, [fp, #-8]
  1069dc:	e3530801 	cmp	r3, #65536	; 0x10000
  1069e0:	3a000001 	bcc	1069ec <netdev_ip4addr_aton+0x308>
        {
            return 0;
  1069e4:	e3a03000 	mov	r3, #0
  1069e8:	ea000047 	b	106b0c <netdev_ip4addr_aton+0x428>
        }
        if ((parts[0] > 0xff) || (parts[1] > 0xff))
  1069ec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1069f0:	e35300ff 	cmp	r3, #255	; 0xff
  1069f4:	8a000002 	bhi	106a04 <netdev_ip4addr_aton+0x320>
  1069f8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1069fc:	e35300ff 	cmp	r3, #255	; 0xff
  106a00:	9a000001 	bls	106a0c <netdev_ip4addr_aton+0x328>
        {
            return 0;
  106a04:	e3a03000 	mov	r3, #0
  106a08:	ea00003f 	b	106b0c <netdev_ip4addr_aton+0x428>
        }
        val |= (parts[0] << 24) | (parts[1] << 16);
  106a0c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  106a10:	e1a02c03 	lsl	r2, r3, #24
  106a14:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  106a18:	e1a03803 	lsl	r3, r3, #16
  106a1c:	e1823003 	orr	r3, r2, r3
  106a20:	e51b2008 	ldr	r2, [fp, #-8]
  106a24:	e1823003 	orr	r3, r2, r3
  106a28:	e50b3008 	str	r3, [fp, #-8]
        break;
  106a2c:	ea000023 	b	106ac0 <netdev_ip4addr_aton+0x3dc>

    case 4: /* a.b.c.d -- 8.8.8.8 bits */
        if (val > 0xff)
  106a30:	e51b3008 	ldr	r3, [fp, #-8]
  106a34:	e35300ff 	cmp	r3, #255	; 0xff
  106a38:	9a000001 	bls	106a44 <netdev_ip4addr_aton+0x360>
        {
            return 0;
  106a3c:	e3a03000 	mov	r3, #0
  106a40:	ea000031 	b	106b0c <netdev_ip4addr_aton+0x428>
        }
        if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff))
  106a44:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  106a48:	e35300ff 	cmp	r3, #255	; 0xff
  106a4c:	8a000005 	bhi	106a68 <netdev_ip4addr_aton+0x384>
  106a50:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  106a54:	e35300ff 	cmp	r3, #255	; 0xff
  106a58:	8a000002 	bhi	106a68 <netdev_ip4addr_aton+0x384>
  106a5c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  106a60:	e35300ff 	cmp	r3, #255	; 0xff
  106a64:	9a000001 	bls	106a70 <netdev_ip4addr_aton+0x38c>
        {
            return 0;
  106a68:	e3a03000 	mov	r3, #0
  106a6c:	ea000026 	b	106b0c <netdev_ip4addr_aton+0x428>
        }
        val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  106a70:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  106a74:	e1a02c03 	lsl	r2, r3, #24
  106a78:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  106a7c:	e1a03803 	lsl	r3, r3, #16
  106a80:	e1822003 	orr	r2, r2, r3
  106a84:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  106a88:	e1a03403 	lsl	r3, r3, #8
  106a8c:	e1823003 	orr	r3, r2, r3
  106a90:	e51b2008 	ldr	r2, [fp, #-8]
  106a94:	e1823003 	orr	r3, r2, r3
  106a98:	e50b3008 	str	r3, [fp, #-8]
        break;
  106a9c:	ea000007 	b	106ac0 <netdev_ip4addr_aton+0x3dc>
    default:
        RT_ASSERT(0);
  106aa0:	e3a020a7 	mov	r2, #167	; 0xa7
  106aa4:	e3061174 	movw	r1, #24948	; 0x6174
  106aa8:	e3401014 	movt	r1, #20
  106aac:	e3060170 	movw	r0, #24944	; 0x6170
  106ab0:	e3400014 	movt	r0, #20
  106ab4:	ebfff2b7 	bl	103598 <rt_assert_handler>
        break;
  106ab8:	ea000000 	b	106ac0 <netdev_ip4addr_aton+0x3dc>
        break;
  106abc:	e320f000 	nop	{0}
    }
    if (addr)
  106ac0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  106ac4:	e3530000 	cmp	r3, #0
  106ac8:	0a00000e 	beq	106b08 <netdev_ip4addr_aton+0x424>
    {
        ip4_addr_set_u32(addr, htonl(val));
  106acc:	e51b3008 	ldr	r3, [fp, #-8]
  106ad0:	e1a02c03 	lsl	r2, r3, #24
  106ad4:	e51b3008 	ldr	r3, [fp, #-8]
  106ad8:	e1a03403 	lsl	r3, r3, #8
  106adc:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
  106ae0:	e1822003 	orr	r2, r2, r3
  106ae4:	e51b3008 	ldr	r3, [fp, #-8]
  106ae8:	e1a03423 	lsr	r3, r3, #8
  106aec:	e2033cff 	and	r3, r3, #65280	; 0xff00
  106af0:	e1822003 	orr	r2, r2, r3
  106af4:	e51b3008 	ldr	r3, [fp, #-8]
  106af8:	e1a03c23 	lsr	r3, r3, #24
  106afc:	e1822003 	orr	r2, r2, r3
  106b00:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  106b04:	e5832000 	str	r2, [r3]
    }
    return 1;
  106b08:	e3a03001 	mov	r3, #1
}
  106b0c:	e1a00003 	mov	r0, r3
  106b10:	e24bd004 	sub	sp, fp, #4
  106b14:	e8bd8800 	pop	{fp, pc}

00106b18 <netdev_ip4addr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *netdev_ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
{
  106b18:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  106b1c:	e28db000 	add	fp, sp, #0
  106b20:	e24dd034 	sub	sp, sp, #52	; 0x34
  106b24:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  106b28:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  106b2c:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
    char *rp;
    uint8_t *ap;
    uint8_t rem;
    uint8_t n;
    uint8_t i;
    int len = 0;
  106b30:	e3a03000 	mov	r3, #0
  106b34:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

    s_addr = ip4_addr_get_u32(addr);
  106b38:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106b3c:	e5933000 	ldr	r3, [r3]
  106b40:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    rp = buf;
  106b44:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  106b48:	e50b3008 	str	r3, [fp, #-8]
    ap = (uint8_t *) &s_addr;
  106b4c:	e24b301c 	sub	r3, fp, #28
  106b50:	e50b300c 	str	r3, [fp, #-12]
    for (n = 0; n < 4; n++)
  106b54:	e3a03000 	mov	r3, #0
  106b58:	e54b300d 	strb	r3, [fp, #-13]
  106b5c:	ea00004b 	b	106c90 <netdev_ip4addr_ntoa_r+0x178>
    {
        i = 0;
  106b60:	e3a03000 	mov	r3, #0
  106b64:	e54b300e 	strb	r3, [fp, #-14]
        do
        {
            rem = *ap % (uint8_t) 10;
  106b68:	e51b300c 	ldr	r3, [fp, #-12]
  106b6c:	e5d31000 	ldrb	r1, [r3]
  106b70:	e30c3ccd 	movw	r3, #52429	; 0xcccd
  106b74:	e34c3ccc 	movt	r3, #52428	; 0xcccc
  106b78:	e0832391 	umull	r2, r3, r1, r3
  106b7c:	e1a031a3 	lsr	r3, r3, #3
  106b80:	e3a0200a 	mov	r2, #10
  106b84:	e0030392 	mul	r3, r2, r3
  106b88:	e0413003 	sub	r3, r1, r3
  106b8c:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
            *ap /= (uint8_t) 10;
  106b90:	e51b300c 	ldr	r3, [fp, #-12]
  106b94:	e5d32000 	ldrb	r2, [r3]
  106b98:	e30c3ccd 	movw	r3, #52429	; 0xcccd
  106b9c:	e34c3ccc 	movt	r3, #52428	; 0xcccc
  106ba0:	e0832392 	umull	r2, r3, r2, r3
  106ba4:	e1a031a3 	lsr	r3, r3, #3
  106ba8:	e6ef2073 	uxtb	r2, r3
  106bac:	e51b300c 	ldr	r3, [fp, #-12]
  106bb0:	e5c32000 	strb	r2, [r3]
            inv[i++] = (char) ('0' + rem);
  106bb4:	e55b300e 	ldrb	r3, [fp, #-14]
  106bb8:	e2832001 	add	r2, r3, #1
  106bbc:	e54b200e 	strb	r2, [fp, #-14]
  106bc0:	e1a01003 	mov	r1, r3
  106bc4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  106bc8:	e2833030 	add	r3, r3, #48	; 0x30
  106bcc:	e6ef2073 	uxtb	r2, r3
  106bd0:	e24b3004 	sub	r3, fp, #4
  106bd4:	e0833001 	add	r3, r3, r1
  106bd8:	e543201c 	strb	r2, [r3, #-28]	; 0xffffffe4
        } while (*ap);
  106bdc:	e51b300c 	ldr	r3, [fp, #-12]
  106be0:	e5d33000 	ldrb	r3, [r3]
  106be4:	e3530000 	cmp	r3, #0
  106be8:	1affffde 	bne	106b68 <netdev_ip4addr_ntoa_r+0x50>
        while (i--)
  106bec:	ea00000f 	b	106c30 <netdev_ip4addr_ntoa_r+0x118>
        {
            if (len++ >= buflen)
  106bf0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  106bf4:	e2832001 	add	r2, r3, #1
  106bf8:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
  106bfc:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  106c00:	e1520003 	cmp	r2, r3
  106c04:	ca000001 	bgt	106c10 <netdev_ip4addr_ntoa_r+0xf8>
            {
                return NULL;
  106c08:	e3a03000 	mov	r3, #0
  106c0c:	ea000029 	b	106cb8 <netdev_ip4addr_ntoa_r+0x1a0>
            }
            *rp++ = inv[i];
  106c10:	e55b200e 	ldrb	r2, [fp, #-14]
  106c14:	e51b3008 	ldr	r3, [fp, #-8]
  106c18:	e2831001 	add	r1, r3, #1
  106c1c:	e50b1008 	str	r1, [fp, #-8]
  106c20:	e24b1004 	sub	r1, fp, #4
  106c24:	e0812002 	add	r2, r1, r2
  106c28:	e552201c 	ldrb	r2, [r2, #-28]	; 0xffffffe4
  106c2c:	e5c32000 	strb	r2, [r3]
        while (i--)
  106c30:	e55b300e 	ldrb	r3, [fp, #-14]
  106c34:	e2432001 	sub	r2, r3, #1
  106c38:	e54b200e 	strb	r2, [fp, #-14]
  106c3c:	e3530000 	cmp	r3, #0
  106c40:	1affffea 	bne	106bf0 <netdev_ip4addr_ntoa_r+0xd8>
        }
        if (len++ >= buflen)
  106c44:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  106c48:	e2832001 	add	r2, r3, #1
  106c4c:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
  106c50:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  106c54:	e1520003 	cmp	r2, r3
  106c58:	ca000001 	bgt	106c64 <netdev_ip4addr_ntoa_r+0x14c>
        {
            return NULL;
  106c5c:	e3a03000 	mov	r3, #0
  106c60:	ea000014 	b	106cb8 <netdev_ip4addr_ntoa_r+0x1a0>
        }
        *rp++ = '.';
  106c64:	e51b3008 	ldr	r3, [fp, #-8]
  106c68:	e2832001 	add	r2, r3, #1
  106c6c:	e50b2008 	str	r2, [fp, #-8]
  106c70:	e3a0202e 	mov	r2, #46	; 0x2e
  106c74:	e5c32000 	strb	r2, [r3]
        ap++;
  106c78:	e51b300c 	ldr	r3, [fp, #-12]
  106c7c:	e2833001 	add	r3, r3, #1
  106c80:	e50b300c 	str	r3, [fp, #-12]
    for (n = 0; n < 4; n++)
  106c84:	e55b300d 	ldrb	r3, [fp, #-13]
  106c88:	e2833001 	add	r3, r3, #1
  106c8c:	e54b300d 	strb	r3, [fp, #-13]
  106c90:	e55b300d 	ldrb	r3, [fp, #-13]
  106c94:	e3530003 	cmp	r3, #3
  106c98:	9affffb0 	bls	106b60 <netdev_ip4addr_ntoa_r+0x48>
    }
    *--rp = 0;
  106c9c:	e51b3008 	ldr	r3, [fp, #-8]
  106ca0:	e2433001 	sub	r3, r3, #1
  106ca4:	e50b3008 	str	r3, [fp, #-8]
  106ca8:	e51b3008 	ldr	r3, [fp, #-8]
  106cac:	e3a02000 	mov	r2, #0
  106cb0:	e5c32000 	strb	r2, [r3]
    return buf;
  106cb4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
}
  106cb8:	e1a00003 	mov	r0, r3
  106cbc:	e28bd000 	add	sp, fp, #0
  106cc0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  106cc4:	e12fff1e 	bx	lr

00106cc8 <netdev_ip4addr_ntoa>:
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         representation of addr
 */
char *netdev_ip4addr_ntoa(const ip4_addr_t *addr)
{
  106cc8:	e92d4800 	push	{fp, lr}
  106ccc:	e28db004 	add	fp, sp, #4
  106cd0:	e24dd008 	sub	sp, sp, #8
  106cd4:	e50b0008 	str	r0, [fp, #-8]
    static char str[IP4ADDR_STRLEN_MAX];
    return netdev_ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
  106cd8:	e3a02010 	mov	r2, #16
  106cdc:	e30e1450 	movw	r1, #58448	; 0xe450
  106ce0:	e3401014 	movt	r1, #20
  106ce4:	e51b0008 	ldr	r0, [fp, #-8]
  106ce8:	ebffff8a 	bl	106b18 <netdev_ip4addr_ntoa_r>
  106cec:	e1a03000 	mov	r3, r0
}
  106cf0:	e1a00003 	mov	r0, r3
  106cf4:	e24bd004 	sub	sp, fp, #4
  106cf8:	e8bd8800 	pop	{fp, pc}

00106cfc <netdev_ipaddr_addr>:
 *
 * @param cp IP address in ascii representation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
in_addr_t netdev_ipaddr_addr(const char *cp)
{
  106cfc:	e92d4800 	push	{fp, lr}
  106d00:	e28db004 	add	fp, sp, #4
  106d04:	e24dd010 	sub	sp, sp, #16
  106d08:	e50b0010 	str	r0, [fp, #-16]
    ip4_addr_t val;

    if (netdev_ip4addr_aton(cp, &val)) {
  106d0c:	e24b3008 	sub	r3, fp, #8
  106d10:	e1a01003 	mov	r1, r3
  106d14:	e51b0010 	ldr	r0, [fp, #-16]
  106d18:	ebfffe71 	bl	1066e4 <netdev_ip4addr_aton>
  106d1c:	e1a03000 	mov	r3, r0
  106d20:	e3530000 	cmp	r3, #0
  106d24:	0a000001 	beq	106d30 <netdev_ipaddr_addr+0x34>
        return ip4_addr_get_u32(&val);
  106d28:	e51b3008 	ldr	r3, [fp, #-8]
  106d2c:	ea000000 	b	106d34 <netdev_ipaddr_addr+0x38>
    }
    return (IPADDR_NONE);
  106d30:	e3e03000 	mvn	r3, #0
}
  106d34:	e1a00003 	mov	r0, r3
  106d38:	e24bd004 	sub	sp, fp, #4
  106d3c:	e8bd8800 	pop	{fp, pc}

00106d40 <netdev_inet_ntop>:

#endif /* NETDEV_IPV6 */

const char *
netdev_inet_ntop(int af, const void *src, char *dst, int32_t size)
{
  106d40:	e92d4800 	push	{fp, lr}
  106d44:	e28db004 	add	fp, sp, #4
  106d48:	e24dd018 	sub	sp, sp, #24
  106d4c:	e50b0010 	str	r0, [fp, #-16]
  106d50:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  106d54:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  106d58:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
#define AF_INET         2
#define AF_INET6        10

    const char *ret = NULL;
  106d5c:	e3a03000 	mov	r3, #0
  106d60:	e50b3008 	str	r3, [fp, #-8]
    int size_int = (int)size;
  106d64:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  106d68:	e50b300c 	str	r3, [fp, #-12]
    if (size_int < 0)
  106d6c:	e51b300c 	ldr	r3, [fp, #-12]
  106d70:	e3530000 	cmp	r3, #0
  106d74:	aa000001 	bge	106d80 <netdev_inet_ntop+0x40>
    {
        return NULL;
  106d78:	e3a03000 	mov	r3, #0
  106d7c:	ea00000a 	b	106dac <netdev_inet_ntop+0x6c>
    }
    switch (af)
  106d80:	e51b3010 	ldr	r3, [fp, #-16]
  106d84:	e3530002 	cmp	r3, #2
  106d88:	0a000002 	beq	106d98 <netdev_inet_ntop+0x58>
#if NETDEV_IPV6
    case AF_INET6:
        return netdev_ip6addr_ntoa_r((const ip6_addr_t *)src, dst, size_int);
#endif
    default:
        break;
  106d8c:	e320f000 	nop	{0}
    }
    return ret;
  106d90:	e51b3008 	ldr	r3, [fp, #-8]
  106d94:	ea000004 	b	106dac <netdev_inet_ntop+0x6c>
        return netdev_ip4addr_ntoa_r((const ip4_addr_t *)src, dst, size_int);
  106d98:	e51b200c 	ldr	r2, [fp, #-12]
  106d9c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  106da0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  106da4:	ebffff5b 	bl	106b18 <netdev_ip4addr_ntoa_r>
  106da8:	e1a03000 	mov	r3, r0
}
  106dac:	e1a00003 	mov	r0, r3
  106db0:	e24bd004 	sub	sp, fp, #4
  106db4:	e8bd8800 	pop	{fp, pc}

00106db8 <netdev_inet_pton>:

int
netdev_inet_pton(int af, const char *src, void *dst)
{
  106db8:	e92d4800 	push	{fp, lr}
  106dbc:	e28db004 	add	fp, sp, #4
  106dc0:	e24dd018 	sub	sp, sp, #24
  106dc4:	e50b0010 	str	r0, [fp, #-16]
  106dc8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  106dcc:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
#define AF_INET         2
#define AF_INET6        10

    int err;
    switch (af)
  106dd0:	e51b3010 	ldr	r3, [fp, #-16]
  106dd4:	e3530002 	cmp	r3, #2
  106dd8:	1a000004 	bne	106df0 <netdev_inet_pton+0x38>
    {
#if NETDEV_IPV4
    case AF_INET:
        err = netdev_ip4addr_aton(src, (ip4_addr_t *)dst);
  106ddc:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  106de0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  106de4:	ebfffe3e 	bl	1066e4 <netdev_ip4addr_aton>
  106de8:	e50b0008 	str	r0, [fp, #-8]
        break;
  106dec:	ea000002 	b	106dfc <netdev_inet_pton+0x44>
        }
        break;
    }
#endif
    default:
        err = -1;
  106df0:	e3e03000 	mvn	r3, #0
  106df4:	e50b3008 	str	r3, [fp, #-8]
        break;
  106df8:	e320f000 	nop	{0}
    }
    return err;
  106dfc:	e51b3008 	ldr	r3, [fp, #-8]
}
  106e00:	e1a00003 	mov	r0, r3
  106e04:	e24bd004 	sub	sp, fp, #4
  106e08:	e8bd8800 	pop	{fp, pc}

00106e0c <sal_init>:
 *
 * @return result  0: initialize success
 *                -1: initialize failed
 */
int sal_init(void)
{
  106e0c:	e92d4800 	push	{fp, lr}
  106e10:	e28db004 	add	fp, sp, #4
  106e14:	e24dd008 	sub	sp, sp, #8
    int cn;

    if (init_ok)
  106e18:	e30e3490 	movw	r3, #58512	; 0xe490
  106e1c:	e3403014 	movt	r3, #20
  106e20:	e5933000 	ldr	r3, [r3]
  106e24:	e3530000 	cmp	r3, #0
  106e28:	0a000001 	beq	106e34 <sal_init+0x28>
    {
        LOG_D("Socket Abstraction Layer is already initialized.");
        return 0;
  106e2c:	e3a03000 	mov	r3, #0
  106e30:	ea000032 	b	106f00 <sal_init+0xf4>
    }

    /* init sal socket table */
    cn = SOCKET_TABLE_STEP_LEN < SAL_SOCKETS_NUM ? SOCKET_TABLE_STEP_LEN : SAL_SOCKETS_NUM;
  106e34:	e3a03004 	mov	r3, #4
  106e38:	e50b3008 	str	r3, [fp, #-8]
    socket_table.max_socket = cn;
  106e3c:	e51b2008 	ldr	r2, [fp, #-8]
  106e40:	e30e3460 	movw	r3, #58464	; 0xe460
  106e44:	e3403014 	movt	r3, #20
  106e48:	e5832000 	str	r2, [r3]
    socket_table.sockets = rt_calloc(1, cn * sizeof(struct sal_socket *));
  106e4c:	e51b3008 	ldr	r3, [fp, #-8]
  106e50:	e1a03103 	lsl	r3, r3, #2
  106e54:	e1a01003 	mov	r1, r3
  106e58:	e3a00001 	mov	r0, #1
  106e5c:	ebfff06a 	bl	10300c <rt_calloc>
  106e60:	e1a02000 	mov	r2, r0
  106e64:	e30e3460 	movw	r3, #58464	; 0xe460
  106e68:	e3403014 	movt	r3, #20
  106e6c:	e5832004 	str	r2, [r3, #4]
    if (socket_table.sockets == RT_NULL)
  106e70:	e30e3460 	movw	r3, #58464	; 0xe460
  106e74:	e3403014 	movt	r3, #20
  106e78:	e5933004 	ldr	r3, [r3, #4]
  106e7c:	e3530000 	cmp	r3, #0
  106e80:	1a00000a 	bne	106eb0 <sal_init+0xa4>
    {
        LOG_E("No memory for socket table.\n");
  106e84:	e3060188 	movw	r0, #24968	; 0x6188
  106e88:	e3400014 	movt	r0, #20
  106e8c:	ebfff0a0 	bl	103114 <rt_kprintf>
  106e90:	e306019c 	movw	r0, #24988	; 0x619c
  106e94:	e3400014 	movt	r0, #20
  106e98:	ebfff09d 	bl	103114 <rt_kprintf>
  106e9c:	e30601bc 	movw	r0, #25020	; 0x61bc
  106ea0:	e3400014 	movt	r0, #20
  106ea4:	ebfff09a 	bl	103114 <rt_kprintf>
        return -1;
  106ea8:	e3e03000 	mvn	r3, #0
  106eac:	ea000013 	b	106f00 <sal_init+0xf4>
    }

    /* create sal socket lock */
    rt_mutex_init(&sal_core_lock, "sal_lock", RT_IPC_FLAG_FIFO);
  106eb0:	e3a02000 	mov	r2, #0
  106eb4:	e30611c4 	movw	r1, #25028	; 0x61c4
  106eb8:	e3401014 	movt	r1, #20
  106ebc:	e30e0468 	movw	r0, #58472	; 0xe468
  106ec0:	e3400014 	movt	r0, #20
  106ec4:	ebffe79f 	bl	100d48 <rt_mutex_init>

    LOG_I("Socket Abstraction Layer initialize success.");
  106ec8:	e30601d0 	movw	r0, #25040	; 0x61d0
  106ecc:	e3400014 	movt	r0, #20
  106ed0:	ebfff08f 	bl	103114 <rt_kprintf>
  106ed4:	e30601e4 	movw	r0, #25060	; 0x61e4
  106ed8:	e3400014 	movt	r0, #20
  106edc:	ebfff08c 	bl	103114 <rt_kprintf>
  106ee0:	e30601bc 	movw	r0, #25020	; 0x61bc
  106ee4:	e3400014 	movt	r0, #20
  106ee8:	ebfff089 	bl	103114 <rt_kprintf>
    init_ok = RT_TRUE;
  106eec:	e30e3490 	movw	r3, #58512	; 0xe490
  106ef0:	e3403014 	movt	r3, #20
  106ef4:	e3a02001 	mov	r2, #1
  106ef8:	e5832000 	str	r2, [r3]

    return 0;
  106efc:	e3a03000 	mov	r3, #0
}
  106f00:	e1a00003 	mov	r0, r3
  106f04:	e24bd004 	sub	sp, fp, #4
  106f08:	e8bd8800 	pop	{fp, pc}

00106f0c <check_netdev_internet_up_work>:

/* check SAL network interface device internet status */
void check_netdev_internet_up_work(void *work_data)
{
  106f0c:	e92d4810 	push	{r4, fp, lr}
  106f10:	e28db008 	add	fp, sp, #8
  106f14:	e24dd0ac 	sub	sp, sp, #172	; 0xac
  106f18:	e50b00a8 	str	r0, [fp, #-168]	; 0xffffff58
#define SAL_INTERNET_PORT      8101

#define SAL_INTERNET_MONTH_LEN 4
#define SAL_INTERNET_DATE_LEN  16

    int index, sockfd = -1, result = 0;
  106f1c:	e3e03000 	mvn	r3, #0
  106f20:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  106f24:	e3a03000 	mov	r3, #0
  106f28:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    struct sockaddr_in server_addr;
    struct hostent *host;
    struct timeval timeout;
    struct netdev *netdev = (struct netdev *)work_data;
  106f2c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xffffff58
  106f30:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    socklen_t addr_len = sizeof(struct sockaddr_in);
  106f34:	e3a03010 	mov	r3, #16
  106f38:	e50b3050 	str	r3, [fp, #-80]	; 0xffffffb0
    char send_data[SAL_INTERNET_BUFF_LEN], recv_data = 0;
  106f3c:	e3a03000 	mov	r3, #0
  106f40:	e54b305d 	strb	r3, [fp, #-93]	; 0xffffffa3
    // struct rt_delayed_work *delay_work = (struct rt_delayed_work *)work;

    const char month[][SAL_INTERNET_MONTH_LEN] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
  106f44:	e3063238 	movw	r3, #25144	; 0x6238
  106f48:	e3403014 	movt	r3, #20
  106f4c:	e24bc090 	sub	ip, fp, #144	; 0x90
  106f50:	e1a0e003 	mov	lr, r3
  106f54:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
  106f58:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  106f5c:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
  106f60:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  106f64:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
  106f68:	e88c000f 	stm	ip, {r0, r1, r2, r3}
    char date[SAL_INTERNET_DATE_LEN];
    int moth_num = 0;
  106f6c:	e3a03000 	mov	r3, #0
  106f70:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    struct sal_proto_family *pf = (struct sal_proto_family *) netdev->sal_user_data;
  106f74:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  106f78:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  106f7c:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
    // {
    //     rt_free(delay_work);
    // }

    /* get network interface socket operations */
    if (pf == RT_NULL || pf->skt_ops == RT_NULL)
  106f80:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106f84:	e3530000 	cmp	r3, #0
  106f88:	0a000003 	beq	106f9c <check_netdev_internet_up_work+0x90>
  106f8c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106f90:	e5933008 	ldr	r3, [r3, #8]
  106f94:	e3530000 	cmp	r3, #0
  106f98:	1a000002 	bne	106fa8 <check_netdev_internet_up_work+0x9c>
    {
        result = -RT_ERROR;
  106f9c:	e3e03000 	mvn	r3, #0
  106fa0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        goto __exit;
  106fa4:	ea0000bc 	b	10729c <check_netdev_internet_up_work+0x390>
    }

    host = (struct hostent *) pf->netdb_ops->gethostbyname(SAL_INTERNET_HOST);
  106fa8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106fac:	e593300c 	ldr	r3, [r3, #12]
  106fb0:	e5933000 	ldr	r3, [r3]
  106fb4:	e3060214 	movw	r0, #25108	; 0x6214
  106fb8:	e3400014 	movt	r0, #20
  106fbc:	e12fff33 	blx	r3
  106fc0:	e50b002c 	str	r0, [fp, #-44]	; 0xffffffd4
    if (host == RT_NULL)
  106fc4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  106fc8:	e3530000 	cmp	r3, #0
  106fcc:	1a000002 	bne	106fdc <check_netdev_internet_up_work+0xd0>
    {
        result = -RT_ERROR;
  106fd0:	e3e03000 	mvn	r3, #0
  106fd4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        goto __exit;
  106fd8:	ea0000af 	b	10729c <check_netdev_internet_up_work+0x390>
    }

    skt_ops = pf->skt_ops;
  106fdc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  106fe0:	e5933008 	ldr	r3, [r3, #8]
  106fe4:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    if ((sockfd = skt_ops->socket(AF_INET, SOCK_DGRAM, 0)) < 0)
  106fe8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  106fec:	e5933000 	ldr	r3, [r3]
  106ff0:	e3a02000 	mov	r2, #0
  106ff4:	e3a01002 	mov	r1, #2
  106ff8:	e3a00002 	mov	r0, #2
  106ffc:	e12fff33 	blx	r3
  107000:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  107004:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  107008:	e3530000 	cmp	r3, #0
  10700c:	aa000002 	bge	10701c <check_netdev_internet_up_work+0x110>
    {
        result = -RT_ERROR;
  107010:	e3e03000 	mvn	r3, #0
  107014:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        goto __exit;
  107018:	ea00009f 	b	10729c <check_netdev_internet_up_work+0x390>
    }
    
    server_addr.sin_family = AF_INET;
  10701c:	e3a03002 	mov	r3, #2
  107020:	e54b303b 	strb	r3, [fp, #-59]	; 0xffffffc5
    server_addr.sin_port = htons(SAL_INTERNET_PORT);
  107024:	e30a351f 	movw	r3, #42271	; 0xa51f
  107028:	e34f3fff 	movt	r3, #65535	; 0xffff
  10702c:	e14b33ba 	strh	r3, [fp, #-58]	; 0xffffffc6
    server_addr.sin_addr = *((struct in_addr *)host->h_addr);
  107030:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  107034:	e5933010 	ldr	r3, [r3, #16]
  107038:	e5933000 	ldr	r3, [r3]
  10703c:	e5933000 	ldr	r3, [r3]
  107040:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
    rt_memset(&(server_addr.sin_zero), 0, sizeof(server_addr.sin_zero));
  107044:	e24b303c 	sub	r3, fp, #60	; 0x3c
  107048:	e2833008 	add	r3, r3, #8
  10704c:	e3a02008 	mov	r2, #8
  107050:	e3a01000 	mov	r1, #0
  107054:	e1a00003 	mov	r0, r3
  107058:	ebfff09a 	bl	1032c8 <rt_memset>

    timeout.tv_sec = SAL_INTERNET_TIMEOUT;
  10705c:	e3a02002 	mov	r2, #2
  107060:	e3a03000 	mov	r3, #0
  107064:	e14b24fc 	strd	r2, [fp, #-76]	; 0xffffffb4
    timeout.tv_usec = 0;
  107068:	e3a03000 	mov	r3, #0
  10706c:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc

    /* set receive and send timeout */
    skt_ops->setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, (void *) &timeout, sizeof(timeout));
  107070:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107074:	e5934024 	ldr	r4, [r3, #36]	; 0x24
  107078:	e24b204c 	sub	r2, fp, #76	; 0x4c
  10707c:	e3a03010 	mov	r3, #16
  107080:	e58d3000 	str	r3, [sp]
  107084:	e1a03002 	mov	r3, r2
  107088:	e3012006 	movw	r2, #4102	; 0x1006
  10708c:	e3001fff 	movw	r1, #4095	; 0xfff
  107090:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  107094:	e12fff34 	blx	r4
    skt_ops->setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, (void *) &timeout, sizeof(timeout));
  107098:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10709c:	e5934024 	ldr	r4, [r3, #36]	; 0x24
  1070a0:	e24b204c 	sub	r2, fp, #76	; 0x4c
  1070a4:	e3a03010 	mov	r3, #16
  1070a8:	e58d3000 	str	r3, [sp]
  1070ac:	e1a03002 	mov	r3, r2
  1070b0:	e3012005 	movw	r2, #4101	; 0x1005
  1070b4:	e3001fff 	movw	r1, #4095	; 0xfff
  1070b8:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1070bc:	e12fff34 	blx	r4

    /* get build moth value*/
    rt_memset(date, 0x00, SAL_INTERNET_DATE_LEN);
  1070c0:	e24b30a0 	sub	r3, fp, #160	; 0xa0
  1070c4:	e3a02010 	mov	r2, #16
  1070c8:	e3a01000 	mov	r1, #0
  1070cc:	e1a00003 	mov	r0, r3
  1070d0:	ebfff07c 	bl	1032c8 <rt_memset>
    rt_snprintf(date, SAL_INTERNET_DATE_LEN, "%s", __DATE__);
  1070d4:	e24b00a0 	sub	r0, fp, #160	; 0xa0
  1070d8:	e3063228 	movw	r3, #25128	; 0x6228
  1070dc:	e3403014 	movt	r3, #20
  1070e0:	e3062234 	movw	r2, #25140	; 0x6234
  1070e4:	e3402014 	movt	r2, #20
  1070e8:	e3a01010 	mov	r1, #16
  1070ec:	ebffefd2 	bl	10303c <rt_snprintf>

    for (index = 0; index < sizeof(month) / SAL_INTERNET_MONTH_LEN; index++)
  1070f0:	e3a03000 	mov	r3, #0
  1070f4:	e50b3010 	str	r3, [fp, #-16]
  1070f8:	ea000011 	b	107144 <check_netdev_internet_up_work+0x238>
    {
        if (rt_memcmp(date, month[index], SAL_INTERNET_MONTH_LEN - 1) == 0)
  1070fc:	e24b2090 	sub	r2, fp, #144	; 0x90
  107100:	e51b3010 	ldr	r3, [fp, #-16]
  107104:	e1a03103 	lsl	r3, r3, #2
  107108:	e0821003 	add	r1, r2, r3
  10710c:	e24b30a0 	sub	r3, fp, #160	; 0xa0
  107110:	e3a02003 	mov	r2, #3
  107114:	e1a00003 	mov	r0, r3
  107118:	ebfff086 	bl	103338 <rt_memcmp>
  10711c:	e1a03000 	mov	r3, r0
  107120:	e3530000 	cmp	r3, #0
  107124:	1a000003 	bne	107138 <check_netdev_internet_up_work+0x22c>
        {
            moth_num = index + 1;
  107128:	e51b3010 	ldr	r3, [fp, #-16]
  10712c:	e2833001 	add	r3, r3, #1
  107130:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
            break;
  107134:	ea000005 	b	107150 <check_netdev_internet_up_work+0x244>
    for (index = 0; index < sizeof(month) / SAL_INTERNET_MONTH_LEN; index++)
  107138:	e51b3010 	ldr	r3, [fp, #-16]
  10713c:	e2833001 	add	r3, r3, #1
  107140:	e50b3010 	str	r3, [fp, #-16]
  107144:	e51b3010 	ldr	r3, [fp, #-16]
  107148:	e353000b 	cmp	r3, #11
  10714c:	9affffea 	bls	1070fc <check_netdev_internet_up_work+0x1f0>
        }
    }

    /* not find build month */
    if (moth_num == 0 || moth_num > sizeof(month) / SAL_INTERNET_MONTH_LEN)
  107150:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  107154:	e3530000 	cmp	r3, #0
  107158:	0a000002 	beq	107168 <check_netdev_internet_up_work+0x25c>
  10715c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  107160:	e353000c 	cmp	r3, #12
  107164:	9a000002 	bls	107174 <check_netdev_internet_up_work+0x268>
    {
        result = -RT_ERROR;
  107168:	e3e03000 	mvn	r3, #0
  10716c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        goto __exit;
  107170:	ea000049 	b	10729c <check_netdev_internet_up_work+0x390>
    }

    rt_memset(send_data, 0x00, SAL_INTERNET_BUFF_LEN);
  107174:	e24b305c 	sub	r3, fp, #92	; 0x5c
  107178:	e3a0200c 	mov	r2, #12
  10717c:	e3a01000 	mov	r1, #0
  107180:	e1a00003 	mov	r0, r3
  107184:	ebfff04f 	bl	1032c8 <rt_memset>
    send_data[0] = SAL_INTERNET_VERSION;
  107188:	e3a03000 	mov	r3, #0
  10718c:	e54b305c 	strb	r3, [fp, #-92]	; 0xffffffa4
    for (index = 0; index < netdev->hwaddr_len; index++)
  107190:	e3a03000 	mov	r3, #0
  107194:	e50b3010 	str	r3, [fp, #-16]
  107198:	ea000010 	b	1071e0 <check_netdev_internet_up_work+0x2d4>
    {
        send_data[index + 1] = netdev->hwaddr[index] + moth_num;
  10719c:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  1071a0:	e51b3010 	ldr	r3, [fp, #-16]
  1071a4:	e0823003 	add	r3, r2, r3
  1071a8:	e2833021 	add	r3, r3, #33	; 0x21
  1071ac:	e5d31000 	ldrb	r1, [r3]
  1071b0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1071b4:	e6ef2073 	uxtb	r2, r3
  1071b8:	e51b3010 	ldr	r3, [fp, #-16]
  1071bc:	e2833001 	add	r3, r3, #1
  1071c0:	e0812002 	add	r2, r1, r2
  1071c4:	e6ef2072 	uxtb	r2, r2
  1071c8:	e24b100c 	sub	r1, fp, #12
  1071cc:	e0813003 	add	r3, r1, r3
  1071d0:	e5432050 	strb	r2, [r3, #-80]	; 0xffffffb0
    for (index = 0; index < netdev->hwaddr_len; index++)
  1071d4:	e51b3010 	ldr	r3, [fp, #-16]
  1071d8:	e2833001 	add	r3, r3, #1
  1071dc:	e50b3010 	str	r3, [fp, #-16]
  1071e0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1071e4:	e5d33020 	ldrb	r3, [r3, #32]
  1071e8:	e1a02003 	mov	r2, r3
  1071ec:	e51b3010 	ldr	r3, [fp, #-16]
  1071f0:	e1530002 	cmp	r3, r2
  1071f4:	baffffe8 	blt	10719c <check_netdev_internet_up_work+0x290>
    }
    send_data[9] = RT_VERSION;
  1071f8:	e3a03005 	mov	r3, #5
  1071fc:	e54b3053 	strb	r3, [fp, #-83]	; 0xffffffad
    send_data[10] = RT_SUBVERSION;
  107200:	e3a03000 	mov	r3, #0
  107204:	e54b3052 	strb	r3, [fp, #-82]	; 0xffffffae
    send_data[11] = RT_REVISION;
  107208:	e3a03000 	mov	r3, #0
  10720c:	e54b3051 	strb	r3, [fp, #-81]	; 0xffffffaf

    skt_ops->sendto(sockfd, send_data, SAL_INTERNET_BUFF_LEN, 0,
  107210:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107214:	e5934018 	ldr	r4, [r3, #24]
  107218:	e24b105c 	sub	r1, fp, #92	; 0x5c
  10721c:	e3a03010 	mov	r3, #16
  107220:	e58d3004 	str	r3, [sp, #4]
  107224:	e24b303c 	sub	r3, fp, #60	; 0x3c
  107228:	e58d3000 	str	r3, [sp]
  10722c:	e3a03000 	mov	r3, #0
  107230:	e3a0200c 	mov	r2, #12
  107234:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  107238:	e12fff34 	blx	r4
                    (struct sockaddr *)&server_addr, sizeof(struct sockaddr));

    result = skt_ops->recvfrom(sockfd, &recv_data, sizeof(recv_data), 0, (struct sockaddr *)&server_addr, &addr_len);
  10723c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107240:	e593401c 	ldr	r4, [r3, #28]
  107244:	e24b105d 	sub	r1, fp, #93	; 0x5d
  107248:	e24b3050 	sub	r3, fp, #80	; 0x50
  10724c:	e58d3004 	str	r3, [sp, #4]
  107250:	e24b303c 	sub	r3, fp, #60	; 0x3c
  107254:	e58d3000 	str	r3, [sp]
  107258:	e3a03000 	mov	r3, #0
  10725c:	e3a02001 	mov	r2, #1
  107260:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  107264:	e12fff34 	blx	r4
  107268:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    if (result < 0)
  10726c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  107270:	e3530000 	cmp	r3, #0
  107274:	ba000005 	blt	107290 <check_netdev_internet_up_work+0x384>
    {
        goto __exit;
    }

    if (recv_data == RT_FALSE)
  107278:	e55b305d 	ldrb	r3, [fp, #-93]	; 0xffffffa3
  10727c:	e3530000 	cmp	r3, #0
  107280:	1a000004 	bne	107298 <check_netdev_internet_up_work+0x38c>
    {
        result = -RT_ERROR;
  107284:	e3e03000 	mvn	r3, #0
  107288:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        goto __exit;
  10728c:	ea000002 	b	10729c <check_netdev_internet_up_work+0x390>
        goto __exit;
  107290:	e320f000 	nop	{0}
  107294:	ea000000 	b	10729c <check_netdev_internet_up_work+0x390>
    }

__exit:
  107298:	e320f000 	nop	{0}
    if (result > 0)
  10729c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1072a0:	e3530000 	cmp	r3, #0
  1072a4:	da000006 	ble	1072c4 <check_netdev_internet_up_work+0x3b8>
    {
        LOG_D("Set network interface device(%s) internet status up.", netdev->name);
        netdev->flags |= NETDEV_FLAG_INTERNET_UP;
  1072a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1072ac:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1072b0:	e3833080 	orr	r3, r3, #128	; 0x80
  1072b4:	e6ff2073 	uxth	r2, r3
  1072b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1072bc:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
  1072c0:	ea000005 	b	1072dc <check_netdev_internet_up_work+0x3d0>
    }
    else
    {
        LOG_D("Set network interface device(%s) internet status down.", netdev->name);
        netdev->flags &= ~NETDEV_FLAG_INTERNET_UP;
  1072c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1072c8:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1072cc:	e3c33080 	bic	r3, r3, #128	; 0x80
  1072d0:	e6ff2073 	uxth	r2, r3
  1072d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1072d8:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    }

    if (sockfd >= 0)
  1072dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1072e0:	e3530000 	cmp	r3, #0
  1072e4:	ba000003 	blt	1072f8 <check_netdev_internet_up_work+0x3ec>
    {
        skt_ops->closesocket(sockfd);
  1072e8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1072ec:	e5933004 	ldr	r3, [r3, #4]
  1072f0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1072f4:	e12fff33 	blx	r3
    }
}
  1072f8:	e320f000 	nop	{0}
  1072fc:	e24bd008 	sub	sp, fp, #8
  107300:	e8bd8810 	pop	{r4, fp, pc}

00107304 <sal_get_socket>:
 * @param socket sal socket index
 *
 * @return sal socket object of the current sal socket index
 */
struct sal_socket *sal_get_socket(int socket)
{
  107304:	e92d4800 	push	{fp, lr}
  107308:	e28db004 	add	fp, sp, #4
  10730c:	e24dd010 	sub	sp, sp, #16
  107310:	e50b0010 	str	r0, [fp, #-16]
    struct sal_socket_table *st = &socket_table;
  107314:	e30e3460 	movw	r3, #58464	; 0xe460
  107318:	e3403014 	movt	r3, #20
  10731c:	e50b3008 	str	r3, [fp, #-8]

    if (socket < 0 || socket >= (int) st->max_socket)
  107320:	e51b3010 	ldr	r3, [fp, #-16]
  107324:	e3530000 	cmp	r3, #0
  107328:	ba000005 	blt	107344 <sal_get_socket+0x40>
  10732c:	e51b3008 	ldr	r3, [fp, #-8]
  107330:	e5933000 	ldr	r3, [r3]
  107334:	e1a02003 	mov	r2, r3
  107338:	e51b3010 	ldr	r3, [fp, #-16]
  10733c:	e1530002 	cmp	r3, r2
  107340:	ba000001 	blt	10734c <sal_get_socket+0x48>
    {
        return RT_NULL;
  107344:	e3a03000 	mov	r3, #0
  107348:	ea000015 	b	1073a4 <sal_get_socket+0xa0>
    }

    socket = socket - SAL_SOCKET_OFFSET;
    /* check socket structure valid or not */
    RT_ASSERT(st->sockets[socket]->magic == SAL_SOCKET_MAGIC);
  10734c:	e51b3008 	ldr	r3, [fp, #-8]
  107350:	e5932004 	ldr	r2, [r3, #4]
  107354:	e51b3010 	ldr	r3, [fp, #-16]
  107358:	e1a03103 	lsl	r3, r3, #2
  10735c:	e0823003 	add	r3, r2, r3
  107360:	e5933000 	ldr	r3, [r3]
  107364:	e5933000 	ldr	r3, [r3]
  107368:	e3052a10 	movw	r2, #23056	; 0x5a10
  10736c:	e1530002 	cmp	r3, r2
  107370:	0a000005 	beq	10738c <sal_get_socket+0x88>
  107374:	e300213b 	movw	r2, #315	; 0x13b
  107378:	e306135c 	movw	r1, #25436	; 0x635c
  10737c:	e3401014 	movt	r1, #20
  107380:	e3060268 	movw	r0, #25192	; 0x6268
  107384:	e3400014 	movt	r0, #20
  107388:	ebfff082 	bl	103598 <rt_assert_handler>

    return st->sockets[socket];
  10738c:	e51b3008 	ldr	r3, [fp, #-8]
  107390:	e5932004 	ldr	r2, [r3, #4]
  107394:	e51b3010 	ldr	r3, [fp, #-16]
  107398:	e1a03103 	lsl	r3, r3, #2
  10739c:	e0823003 	add	r3, r2, r3
  1073a0:	e5933000 	ldr	r3, [r3]
}
  1073a4:	e1a00003 	mov	r0, r3
  1073a8:	e24bd004 	sub	sp, fp, #4
  1073ac:	e8bd8800 	pop	{fp, pc}

001073b0 <sal_lock>:
 * This function will lock sal socket.
 *
 * @note please don't invoke it on ISR.
 */
static void sal_lock(void)
{
  1073b0:	e92d4800 	push	{fp, lr}
  1073b4:	e28db004 	add	fp, sp, #4
  1073b8:	e24dd008 	sub	sp, sp, #8
    rt_err_t result;

    result = rt_mutex_take(&sal_core_lock, RT_WAITING_FOREVER);
  1073bc:	e3e01000 	mvn	r1, #0
  1073c0:	e30e0468 	movw	r0, #58472	; 0xe468
  1073c4:	e3400014 	movt	r0, #20
  1073c8:	ebffe6cc 	bl	100f00 <rt_mutex_take>
  1073cc:	e50b0008 	str	r0, [fp, #-8]
    if (result != RT_EOK)
  1073d0:	e51b3008 	ldr	r3, [fp, #-8]
  1073d4:	e3530000 	cmp	r3, #0
  1073d8:	0a000005 	beq	1073f4 <sal_lock+0x44>
    {
        RT_ASSERT(0);
  1073dc:	e3a02f53 	mov	r2, #332	; 0x14c
  1073e0:	e306136c 	movw	r1, #25452	; 0x636c
  1073e4:	e3401014 	movt	r1, #20
  1073e8:	e3060298 	movw	r0, #25240	; 0x6298
  1073ec:	e3400014 	movt	r0, #20
  1073f0:	ebfff068 	bl	103598 <rt_assert_handler>
    }
}
  1073f4:	e320f000 	nop	{0}
  1073f8:	e24bd004 	sub	sp, fp, #4
  1073fc:	e8bd8800 	pop	{fp, pc}

00107400 <sal_unlock>:
 * This function will lock sal socket.
 *
 * @note please don't invoke it on ISR.
 */
static void sal_unlock(void)
{
  107400:	e92d4800 	push	{fp, lr}
  107404:	e28db004 	add	fp, sp, #4
    rt_mutex_release(&sal_core_lock);
  107408:	e30e0468 	movw	r0, #58472	; 0xe468
  10740c:	e3400014 	movt	r0, #20
  107410:	ebffe6d8 	bl	100f78 <rt_mutex_release>
}
  107414:	e320f000 	nop	{0}
  107418:	e8bd8800 	pop	{fp, pc}

0010741c <sal_netdev_cleanup>:
 * This function will clean the netdev.
 *
 * @note please don't invoke it on ISR.
 */
int sal_netdev_cleanup(struct netdev *netdev)
{
  10741c:	e92d4800 	push	{fp, lr}
  107420:	e28db004 	add	fp, sp, #4
  107424:	e24dd010 	sub	sp, sp, #16
  107428:	e50b0010 	str	r0, [fp, #-16]
    int idx = 0, find_dev;
  10742c:	e3a03000 	mov	r3, #0
  107430:	e50b3008 	str	r3, [fp, #-8]

    do
    {
        find_dev = 0;
  107434:	e3a03000 	mov	r3, #0
  107438:	e50b300c 	str	r3, [fp, #-12]
        sal_lock();
  10743c:	ebffffdb 	bl	1073b0 <sal_lock>
        for (idx = 0; idx < socket_table.max_socket; idx++)
  107440:	e3a03000 	mov	r3, #0
  107444:	e50b3008 	str	r3, [fp, #-8]
  107448:	ea000019 	b	1074b4 <sal_netdev_cleanup+0x98>
        {
            if (socket_table.sockets[idx] && socket_table.sockets[idx]->netdev == netdev)
  10744c:	e30e3460 	movw	r3, #58464	; 0xe460
  107450:	e3403014 	movt	r3, #20
  107454:	e5932004 	ldr	r2, [r3, #4]
  107458:	e51b3008 	ldr	r3, [fp, #-8]
  10745c:	e1a03103 	lsl	r3, r3, #2
  107460:	e0823003 	add	r3, r2, r3
  107464:	e5933000 	ldr	r3, [r3]
  107468:	e3530000 	cmp	r3, #0
  10746c:	0a00000d 	beq	1074a8 <sal_netdev_cleanup+0x8c>
  107470:	e30e3460 	movw	r3, #58464	; 0xe460
  107474:	e3403014 	movt	r3, #20
  107478:	e5932004 	ldr	r2, [r3, #4]
  10747c:	e51b3008 	ldr	r3, [fp, #-8]
  107480:	e1a03103 	lsl	r3, r3, #2
  107484:	e0823003 	add	r3, r2, r3
  107488:	e5933000 	ldr	r3, [r3]
  10748c:	e5933014 	ldr	r3, [r3, #20]
  107490:	e51b2010 	ldr	r2, [fp, #-16]
  107494:	e1520003 	cmp	r2, r3
  107498:	1a000002 	bne	1074a8 <sal_netdev_cleanup+0x8c>
            {
                find_dev = 1;
  10749c:	e3a03001 	mov	r3, #1
  1074a0:	e50b300c 	str	r3, [fp, #-12]
                break;
  1074a4:	ea000008 	b	1074cc <sal_netdev_cleanup+0xb0>
        for (idx = 0; idx < socket_table.max_socket; idx++)
  1074a8:	e51b3008 	ldr	r3, [fp, #-8]
  1074ac:	e2833001 	add	r3, r3, #1
  1074b0:	e50b3008 	str	r3, [fp, #-8]
  1074b4:	e30e3460 	movw	r3, #58464	; 0xe460
  1074b8:	e3403014 	movt	r3, #20
  1074bc:	e5932000 	ldr	r2, [r3]
  1074c0:	e51b3008 	ldr	r3, [fp, #-8]
  1074c4:	e1520003 	cmp	r2, r3
  1074c8:	8affffdf 	bhi	10744c <sal_netdev_cleanup+0x30>
            }
        }
        sal_unlock();
  1074cc:	ebffffcb 	bl	107400 <sal_unlock>
        if (find_dev)
  1074d0:	e51b300c 	ldr	r3, [fp, #-12]
  1074d4:	e3530000 	cmp	r3, #0
  1074d8:	0a000001 	beq	1074e4 <sal_netdev_cleanup+0xc8>
        {
            rt_thread_mdelay(100);
  1074dc:	e3a00064 	mov	r0, #100	; 0x64
  1074e0:	ebffea65 	bl	101e7c <rt_thread_mdelay>
        }
    }
    while (find_dev);
  1074e4:	e51b300c 	ldr	r3, [fp, #-12]
  1074e8:	e3530000 	cmp	r3, #0
  1074ec:	1affffd0 	bne	107434 <sal_netdev_cleanup+0x18>

    return 0;
  1074f0:	e3a03000 	mov	r3, #0
}
  1074f4:	e1a00003 	mov	r0, r3
  1074f8:	e24bd004 	sub	sp, fp, #4
  1074fc:	e8bd8800 	pop	{fp, pc}

00107500 <socket_init>:
 *         -1 : input the wrong family
 *         -2 : input the wrong socket type
 *         -3 : get network interface failed
 */
static int socket_init(int family, int type, int protocol, struct sal_socket **res)
{
  107500:	e92d4800 	push	{fp, lr}
  107504:	e28db004 	add	fp, sp, #4
  107508:	e24dd028 	sub	sp, sp, #40	; 0x28
  10750c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  107510:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  107514:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  107518:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4

    struct sal_socket *sock;
    struct sal_proto_family *pf;
    struct netdev *netdv_def = netdev_default;
  10751c:	e3003564 	movw	r3, #1380	; 0x564
  107520:	e3403015 	movt	r3, #21
  107524:	e5933000 	ldr	r3, [r3]
  107528:	e50b300c 	str	r3, [fp, #-12]
    struct netdev *netdev = RT_NULL;
  10752c:	e3a03000 	mov	r3, #0
  107530:	e50b3010 	str	r3, [fp, #-16]
    rt_bool_t flag = RT_FALSE;
  107534:	e3a03000 	mov	r3, #0
  107538:	e50b3008 	str	r3, [fp, #-8]

    if (family < 0 || family > AF_MAX)
  10753c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107540:	e3530000 	cmp	r3, #0
  107544:	ba000002 	blt	107554 <socket_init+0x54>
  107548:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10754c:	e353002f 	cmp	r3, #47	; 0x2f
  107550:	da000001 	ble	10755c <socket_init+0x5c>
    {
        return -1;
  107554:	e3e03000 	mvn	r3, #0
  107558:	ea000050 	b	1076a0 <socket_init+0x1a0>
    }

    if (type < 0 || type > SOCK_MAX)
  10755c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  107560:	e3530000 	cmp	r3, #0
  107564:	ba000004 	blt	10757c <socket_init+0x7c>
  107568:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  10756c:	e3a03001 	mov	r3, #1
  107570:	e3403008 	movt	r3, #8
  107574:	e1520003 	cmp	r2, r3
  107578:	da000001 	ble	107584 <socket_init+0x84>
    {
        return -2;
  10757c:	e3e03001 	mvn	r3, #1
  107580:	ea000046 	b	1076a0 <socket_init+0x1a0>
    }

    sock = *res;
  107584:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  107588:	e5933000 	ldr	r3, [r3]
  10758c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    sock->domain = family;
  107590:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  107594:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  107598:	e5832008 	str	r2, [r3, #8]
    sock->type = type;
  10759c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1075a0:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  1075a4:	e583200c 	str	r2, [r3, #12]
    sock->protocol = protocol;
  1075a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1075ac:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  1075b0:	e5832010 	str	r2, [r3, #16]

    if (netdv_def && netdev_is_up(netdv_def))
  1075b4:	e51b300c 	ldr	r3, [fp, #-12]
  1075b8:	e3530000 	cmp	r3, #0
  1075bc:	0a00001e 	beq	10763c <socket_init+0x13c>
  1075c0:	e51b300c 	ldr	r3, [fp, #-12]
  1075c4:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1075c8:	e2033001 	and	r3, r3, #1
  1075cc:	e6ef3073 	uxtb	r3, r3
  1075d0:	e3530000 	cmp	r3, #0
  1075d4:	0a000018 	beq	10763c <socket_init+0x13c>
    {
        /* check default network interface device protocol family */
        pf = (struct sal_proto_family *) netdv_def->sal_user_data;
  1075d8:	e51b300c 	ldr	r3, [fp, #-12]
  1075dc:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  1075e0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        if (pf != RT_NULL && pf->skt_ops && (pf->family == family || pf->sec_family == family))
  1075e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1075e8:	e3530000 	cmp	r3, #0
  1075ec:	0a000012 	beq	10763c <socket_init+0x13c>
  1075f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1075f4:	e5933008 	ldr	r3, [r3, #8]
  1075f8:	e3530000 	cmp	r3, #0
  1075fc:	0a00000e 	beq	10763c <socket_init+0x13c>
  107600:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  107604:	e5933000 	ldr	r3, [r3]
  107608:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  10760c:	e1520003 	cmp	r2, r3
  107610:	0a000004 	beq	107628 <socket_init+0x128>
  107614:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  107618:	e5933004 	ldr	r3, [r3, #4]
  10761c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  107620:	e1520003 	cmp	r2, r3
  107624:	1a000004 	bne	10763c <socket_init+0x13c>
        {
            sock->netdev = netdv_def;
  107628:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10762c:	e51b200c 	ldr	r2, [fp, #-12]
  107630:	e5832014 	str	r2, [r3, #20]
            flag = RT_TRUE;
  107634:	e3a03001 	mov	r3, #1
  107638:	e50b3008 	str	r3, [fp, #-8]
        }
    }

    if (flag == RT_FALSE)
  10763c:	e51b3008 	ldr	r3, [fp, #-8]
  107640:	e3530000 	cmp	r3, #0
  107644:	1a000014 	bne	10769c <socket_init+0x19c>
    {
        /* get network interface device by protocol family */
        netdev = netdev_get_by_family(family);
  107648:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10764c:	ebfff7e1 	bl	1055d8 <netdev_get_by_family>
  107650:	e50b0010 	str	r0, [fp, #-16]
        if (netdev == RT_NULL)
  107654:	e51b3010 	ldr	r3, [fp, #-16]
  107658:	e3530000 	cmp	r3, #0
  10765c:	1a00000b 	bne	107690 <socket_init+0x190>
        {
            LOG_E("not find network interface device by protocol family(%d).", family);
  107660:	e3060188 	movw	r0, #24968	; 0x6188
  107664:	e3400014 	movt	r0, #20
  107668:	ebffeea9 	bl	103114 <rt_kprintf>
  10766c:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  107670:	e306029c 	movw	r0, #25244	; 0x629c
  107674:	e3400014 	movt	r0, #20
  107678:	ebffeea5 	bl	103114 <rt_kprintf>
  10767c:	e30601bc 	movw	r0, #25020	; 0x61bc
  107680:	e3400014 	movt	r0, #20
  107684:	ebffeea2 	bl	103114 <rt_kprintf>
            return -3;
  107688:	e3e03002 	mvn	r3, #2
  10768c:	ea000003 	b	1076a0 <socket_init+0x1a0>
        }

        sock->netdev = netdev;
  107690:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  107694:	e51b2010 	ldr	r2, [fp, #-16]
  107698:	e5832014 	str	r2, [r3, #20]
    }

    return 0;
  10769c:	e3a03000 	mov	r3, #0
}
  1076a0:	e1a00003 	mov	r0, r3
  1076a4:	e24bd004 	sub	sp, fp, #4
  1076a8:	e8bd8800 	pop	{fp, pc}

001076ac <socket_alloc>:

static int socket_alloc(struct sal_socket_table *st, int f_socket)
{
  1076ac:	e92d4810 	push	{r4, fp, lr}
  1076b0:	e28db008 	add	fp, sp, #8
  1076b4:	e24dd01c 	sub	sp, sp, #28
  1076b8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  1076bc:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
    int idx;

    /* find an empty socket entry */
    for (idx = f_socket; idx < (int) st->max_socket; idx++)
  1076c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1076c4:	e50b3010 	str	r3, [fp, #-16]
  1076c8:	ea00000a 	b	1076f8 <socket_alloc+0x4c>
    {
        if (st->sockets[idx] == RT_NULL)
  1076cc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1076d0:	e5932004 	ldr	r2, [r3, #4]
  1076d4:	e51b3010 	ldr	r3, [fp, #-16]
  1076d8:	e1a03103 	lsl	r3, r3, #2
  1076dc:	e0823003 	add	r3, r2, r3
  1076e0:	e5933000 	ldr	r3, [r3]
  1076e4:	e3530000 	cmp	r3, #0
  1076e8:	0a000009 	beq	107714 <socket_alloc+0x68>
    for (idx = f_socket; idx < (int) st->max_socket; idx++)
  1076ec:	e51b3010 	ldr	r3, [fp, #-16]
  1076f0:	e2833001 	add	r3, r3, #1
  1076f4:	e50b3010 	str	r3, [fp, #-16]
  1076f8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1076fc:	e5933000 	ldr	r3, [r3]
  107700:	e1a02003 	mov	r2, r3
  107704:	e51b3010 	ldr	r3, [fp, #-16]
  107708:	e1530002 	cmp	r3, r2
  10770c:	baffffee 	blt	1076cc <socket_alloc+0x20>
  107710:	ea000000 	b	107718 <socket_alloc+0x6c>
        {
            break;
  107714:	e320f000 	nop	{0}
        }
    }

    /* allocate a larger sockte container */
    if (idx == (int) st->max_socket &&  st->max_socket < SAL_SOCKETS_NUM)
  107718:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10771c:	e5933000 	ldr	r3, [r3]
  107720:	e1a02003 	mov	r2, r3
  107724:	e51b3010 	ldr	r3, [fp, #-16]
  107728:	e1530002 	cmp	r3, r2
  10772c:	1a00002e 	bne	1077ec <socket_alloc+0x140>
  107730:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107734:	e5933000 	ldr	r3, [r3]
  107738:	e353001f 	cmp	r3, #31
  10773c:	8a00002a 	bhi	1077ec <socket_alloc+0x140>
    {
        int cnt, index;
        struct sal_socket **sockets;

        /* increase the number of socket with 4 step length */
        cnt = st->max_socket + SOCKET_TABLE_STEP_LEN;
  107740:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107744:	e5933000 	ldr	r3, [r3]
  107748:	e2833004 	add	r3, r3, #4
  10774c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        cnt = cnt > SAL_SOCKETS_NUM ? SAL_SOCKETS_NUM : cnt;
  107750:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  107754:	e3530020 	cmp	r3, #32
  107758:	b1a03003 	movlt	r3, r3
  10775c:	a3a03020 	movge	r3, #32
  107760:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

        sockets = rt_realloc(st->sockets, cnt * sizeof(struct sal_socket *));
  107764:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107768:	e5932004 	ldr	r2, [r3, #4]
  10776c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  107770:	e1a03103 	lsl	r3, r3, #2
  107774:	e1a01003 	mov	r1, r3
  107778:	e1a00002 	mov	r0, r2
  10777c:	ebffee16 	bl	102fdc <rt_realloc>
  107780:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
        if (sockets == RT_NULL)
  107784:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  107788:	e3530000 	cmp	r3, #0
  10778c:	0a00003a 	beq	10787c <socket_alloc+0x1d0>
            goto __result; /* return st->max_socket */

        /* clean the new allocated fds */
        for (index = st->max_socket; index < cnt; index++)
  107790:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107794:	e5933000 	ldr	r3, [r3]
  107798:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  10779c:	ea000008 	b	1077c4 <socket_alloc+0x118>
        {
            sockets[index] = RT_NULL;
  1077a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1077a4:	e1a03103 	lsl	r3, r3, #2
  1077a8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1077ac:	e0823003 	add	r3, r2, r3
  1077b0:	e3a02000 	mov	r2, #0
  1077b4:	e5832000 	str	r2, [r3]
        for (index = st->max_socket; index < cnt; index++)
  1077b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1077bc:	e2833001 	add	r3, r3, #1
  1077c0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1077c4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  1077c8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1077cc:	e1520003 	cmp	r2, r3
  1077d0:	bafffff2 	blt	1077a0 <socket_alloc+0xf4>
        }

        st->sockets = sockets;
  1077d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1077d8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1077dc:	e5832004 	str	r2, [r3, #4]
        st->max_socket = cnt;
  1077e0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1077e4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1077e8:	e5832000 	str	r2, [r3]
    }

    /* allocate  'struct sal_socket' */
    if (idx < (int) st->max_socket && st->sockets[idx] == RT_NULL)
  1077ec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1077f0:	e5933000 	ldr	r3, [r3]
  1077f4:	e1a02003 	mov	r2, r3
  1077f8:	e51b3010 	ldr	r3, [fp, #-16]
  1077fc:	e1530002 	cmp	r3, r2
  107800:	aa00001f 	bge	107884 <socket_alloc+0x1d8>
  107804:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107808:	e5932004 	ldr	r2, [r3, #4]
  10780c:	e51b3010 	ldr	r3, [fp, #-16]
  107810:	e1a03103 	lsl	r3, r3, #2
  107814:	e0823003 	add	r3, r2, r3
  107818:	e5933000 	ldr	r3, [r3]
  10781c:	e3530000 	cmp	r3, #0
  107820:	1a000017 	bne	107884 <socket_alloc+0x1d8>
    {
        st->sockets[idx] = rt_calloc(1, sizeof(struct sal_socket));
  107824:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107828:	e5932004 	ldr	r2, [r3, #4]
  10782c:	e51b3010 	ldr	r3, [fp, #-16]
  107830:	e1a03103 	lsl	r3, r3, #2
  107834:	e0824003 	add	r4, r2, r3
  107838:	e3a0101c 	mov	r1, #28
  10783c:	e3a00001 	mov	r0, #1
  107840:	ebffedf1 	bl	10300c <rt_calloc>
  107844:	e1a03000 	mov	r3, r0
  107848:	e5843000 	str	r3, [r4]
        if (st->sockets[idx] == RT_NULL)
  10784c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107850:	e5932004 	ldr	r2, [r3, #4]
  107854:	e51b3010 	ldr	r3, [fp, #-16]
  107858:	e1a03103 	lsl	r3, r3, #2
  10785c:	e0823003 	add	r3, r2, r3
  107860:	e5933000 	ldr	r3, [r3]
  107864:	e3530000 	cmp	r3, #0
  107868:	1a000005 	bne	107884 <socket_alloc+0x1d8>
        {
            idx = st->max_socket;
  10786c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107870:	e5933000 	ldr	r3, [r3]
  107874:	e50b3010 	str	r3, [fp, #-16]
  107878:	ea000002 	b	107888 <socket_alloc+0x1dc>
            goto __result; /* return st->max_socket */
  10787c:	e320f000 	nop	{0}
  107880:	ea000000 	b	107888 <socket_alloc+0x1dc>
        }
    }

__result:
  107884:	e320f000 	nop	{0}
    return idx;
  107888:	e51b3010 	ldr	r3, [fp, #-16]
}
  10788c:	e1a00003 	mov	r0, r3
  107890:	e24bd008 	sub	sp, fp, #8
  107894:	e8bd8810 	pop	{r4, fp, pc}

00107898 <socket_free>:

static void socket_free(struct sal_socket_table *st, int idx)
{
  107898:	e92d4800 	push	{fp, lr}
  10789c:	e28db004 	add	fp, sp, #4
  1078a0:	e24dd010 	sub	sp, sp, #16
  1078a4:	e50b0010 	str	r0, [fp, #-16]
  1078a8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    struct sal_socket *sock;

    sock = st->sockets[idx];
  1078ac:	e51b3010 	ldr	r3, [fp, #-16]
  1078b0:	e5932004 	ldr	r2, [r3, #4]
  1078b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1078b8:	e1a03103 	lsl	r3, r3, #2
  1078bc:	e0823003 	add	r3, r2, r3
  1078c0:	e5933000 	ldr	r3, [r3]
  1078c4:	e50b3008 	str	r3, [fp, #-8]
    st->sockets[idx] = RT_NULL;
  1078c8:	e51b3010 	ldr	r3, [fp, #-16]
  1078cc:	e5932004 	ldr	r2, [r3, #4]
  1078d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1078d4:	e1a03103 	lsl	r3, r3, #2
  1078d8:	e0823003 	add	r3, r2, r3
  1078dc:	e3a02000 	mov	r2, #0
  1078e0:	e5832000 	str	r2, [r3]
    rt_free(sock);
  1078e4:	e51b0008 	ldr	r0, [fp, #-8]
  1078e8:	ebffedb3 	bl	102fbc <rt_free>
}
  1078ec:	e320f000 	nop	{0}
  1078f0:	e24bd004 	sub	sp, fp, #4
  1078f4:	e8bd8800 	pop	{fp, pc}

001078f8 <socket_new>:

static int socket_new(void)
{
  1078f8:	e92d4800 	push	{fp, lr}
  1078fc:	e28db004 	add	fp, sp, #4
  107900:	e24dd010 	sub	sp, sp, #16
    struct sal_socket *sock;
    struct sal_socket_table *st = &socket_table;
  107904:	e30e3460 	movw	r3, #58464	; 0xe460
  107908:	e3403014 	movt	r3, #20
  10790c:	e50b300c 	str	r3, [fp, #-12]
    int idx;

    sal_lock();
  107910:	ebfffea6 	bl	1073b0 <sal_lock>

    /* find an empty sal socket entry */
    idx = socket_alloc(st, 0);
  107914:	e3a01000 	mov	r1, #0
  107918:	e51b000c 	ldr	r0, [fp, #-12]
  10791c:	ebffff62 	bl	1076ac <socket_alloc>
  107920:	e50b0008 	str	r0, [fp, #-8]

    /* can't find an empty sal socket entry */
    if (idx == (int) st->max_socket)
  107924:	e51b300c 	ldr	r3, [fp, #-12]
  107928:	e5933000 	ldr	r3, [r3]
  10792c:	e1a02003 	mov	r2, r3
  107930:	e51b3008 	ldr	r3, [fp, #-8]
  107934:	e1530002 	cmp	r3, r2
  107938:	1a000002 	bne	107948 <socket_new+0x50>
    {
        idx = -(1 + SAL_SOCKET_OFFSET);
  10793c:	e3e03000 	mvn	r3, #0
  107940:	e50b3008 	str	r3, [fp, #-8]
        goto __result;
  107944:	ea000012 	b	107994 <socket_new+0x9c>
    }

    sock = st->sockets[idx];
  107948:	e51b300c 	ldr	r3, [fp, #-12]
  10794c:	e5932004 	ldr	r2, [r3, #4]
  107950:	e51b3008 	ldr	r3, [fp, #-8]
  107954:	e1a03103 	lsl	r3, r3, #2
  107958:	e0823003 	add	r3, r2, r3
  10795c:	e5933000 	ldr	r3, [r3]
  107960:	e50b3010 	str	r3, [fp, #-16]
    sock->socket = idx + SAL_SOCKET_OFFSET;
  107964:	e51b3010 	ldr	r3, [fp, #-16]
  107968:	e51b2008 	ldr	r2, [fp, #-8]
  10796c:	e5832004 	str	r2, [r3, #4]
    sock->magic = SAL_SOCKET_MAGIC;
  107970:	e51b3010 	ldr	r3, [fp, #-16]
  107974:	e3052a10 	movw	r2, #23056	; 0x5a10
  107978:	e5832000 	str	r2, [r3]
    sock->netdev = RT_NULL;
  10797c:	e51b3010 	ldr	r3, [fp, #-16]
  107980:	e3a02000 	mov	r2, #0
  107984:	e5832014 	str	r2, [r3, #20]
    sock->user_data = RT_NULL;
  107988:	e51b3010 	ldr	r3, [fp, #-16]
  10798c:	e3a02000 	mov	r2, #0
  107990:	e5832018 	str	r2, [r3, #24]
#ifdef SAL_USING_TLS
    sock->user_data_tls = RT_NULL;
#endif

__result:
    sal_unlock();
  107994:	ebfffe99 	bl	107400 <sal_unlock>
    return idx + SAL_SOCKET_OFFSET;
  107998:	e51b3008 	ldr	r3, [fp, #-8]
}
  10799c:	e1a00003 	mov	r0, r3
  1079a0:	e24bd004 	sub	sp, fp, #4
  1079a4:	e8bd8800 	pop	{fp, pc}

001079a8 <socket_delete>:

static void socket_delete(int socket)
{
  1079a8:	e92d4800 	push	{fp, lr}
  1079ac:	e28db004 	add	fp, sp, #4
  1079b0:	e24dd018 	sub	sp, sp, #24
  1079b4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    struct sal_socket *sock;
    struct sal_socket_table *st = &socket_table;
  1079b8:	e30e3460 	movw	r3, #58464	; 0xe460
  1079bc:	e3403014 	movt	r3, #20
  1079c0:	e50b3008 	str	r3, [fp, #-8]
    int idx;

    idx = socket - SAL_SOCKET_OFFSET;
  1079c4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1079c8:	e50b300c 	str	r3, [fp, #-12]
    if (idx < 0 || idx >= (int) st->max_socket)
  1079cc:	e51b300c 	ldr	r3, [fp, #-12]
  1079d0:	e3530000 	cmp	r3, #0
  1079d4:	ba00001d 	blt	107a50 <socket_delete+0xa8>
  1079d8:	e51b3008 	ldr	r3, [fp, #-8]
  1079dc:	e5933000 	ldr	r3, [r3]
  1079e0:	e1a02003 	mov	r2, r3
  1079e4:	e51b300c 	ldr	r3, [fp, #-12]
  1079e8:	e1530002 	cmp	r3, r2
  1079ec:	aa000017 	bge	107a50 <socket_delete+0xa8>
    {
        return;
    }
    sal_lock();
  1079f0:	ebfffe6e 	bl	1073b0 <sal_lock>
    sock = sal_get_socket(socket);
  1079f4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1079f8:	ebfffe41 	bl	107304 <sal_get_socket>
  1079fc:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(sock != RT_NULL);
  107a00:	e51b3010 	ldr	r3, [fp, #-16]
  107a04:	e3530000 	cmp	r3, #0
  107a08:	1a000005 	bne	107a24 <socket_delete+0x7c>
  107a0c:	e3002223 	movw	r2, #547	; 0x223
  107a10:	e3061378 	movw	r1, #25464	; 0x6378
  107a14:	e3401014 	movt	r1, #20
  107a18:	e30602d8 	movw	r0, #25304	; 0x62d8
  107a1c:	e3400014 	movt	r0, #20
  107a20:	ebffeedc 	bl	103598 <rt_assert_handler>
    sock->magic = 0;
  107a24:	e51b3010 	ldr	r3, [fp, #-16]
  107a28:	e3a02000 	mov	r2, #0
  107a2c:	e5832000 	str	r2, [r3]
    sock->netdev = RT_NULL;
  107a30:	e51b3010 	ldr	r3, [fp, #-16]
  107a34:	e3a02000 	mov	r2, #0
  107a38:	e5832014 	str	r2, [r3, #20]
    socket_free(st, idx);
  107a3c:	e51b100c 	ldr	r1, [fp, #-12]
  107a40:	e51b0008 	ldr	r0, [fp, #-8]
  107a44:	ebffff93 	bl	107898 <socket_free>
    sal_unlock();
  107a48:	ebfffe6c 	bl	107400 <sal_unlock>
  107a4c:	ea000000 	b	107a54 <socket_delete+0xac>
        return;
  107a50:	e320f000 	nop	{0}
}
  107a54:	e24bd004 	sub	sp, fp, #4
  107a58:	e8bd8800 	pop	{fp, pc}

00107a5c <sal_accept>:

int sal_accept(int socket, struct sockaddr *addr, socklen_t *addrlen)
{
  107a5c:	e92d4800 	push	{fp, lr}
  107a60:	e28db004 	add	fp, sp, #4
  107a64:	e24dd028 	sub	sp, sp, #40	; 0x28
  107a68:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  107a6c:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  107a70:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
    int new_socket;
    struct sal_socket *sock;
    struct sal_proto_family *pf;

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  107a74:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  107a78:	ebfffe21 	bl	107304 <sal_get_socket>
  107a7c:	e50b0008 	str	r0, [fp, #-8]
  107a80:	e51b3008 	ldr	r3, [fp, #-8]
  107a84:	e3530000 	cmp	r3, #0
  107a88:	1a000001 	bne	107a94 <sal_accept+0x38>
  107a8c:	e3e03000 	mvn	r3, #0
  107a90:	ea000059 	b	107bfc <sal_accept+0x1a0>

    /* check the network interface is up status */
    SAL_NETDEV_IS_UP(sock->netdev);
  107a94:	e51b3008 	ldr	r3, [fp, #-8]
  107a98:	e5933014 	ldr	r3, [r3, #20]
  107a9c:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  107aa0:	e2033001 	and	r3, r3, #1
  107aa4:	e3530000 	cmp	r3, #0
  107aa8:	1a000001 	bne	107ab4 <sal_accept+0x58>
  107aac:	e3e03000 	mvn	r3, #0
  107ab0:	ea000051 	b	107bfc <sal_accept+0x1a0>

    /* check the network interface socket operations */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, accept);
  107ab4:	e51b3008 	ldr	r3, [fp, #-8]
  107ab8:	e5933014 	ldr	r3, [r3, #20]
  107abc:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  107ac0:	e50b300c 	str	r3, [fp, #-12]
  107ac4:	e51b300c 	ldr	r3, [fp, #-12]
  107ac8:	e5933008 	ldr	r3, [r3, #8]
  107acc:	e5933014 	ldr	r3, [r3, #20]
  107ad0:	e3530000 	cmp	r3, #0
  107ad4:	1a000001 	bne	107ae0 <sal_accept+0x84>
  107ad8:	e3e03000 	mvn	r3, #0
  107adc:	ea000046 	b	107bfc <sal_accept+0x1a0>

    new_socket = pf->skt_ops->accept((int)(size_t)sock->user_data, addr, addrlen);
  107ae0:	e51b300c 	ldr	r3, [fp, #-12]
  107ae4:	e5933008 	ldr	r3, [r3, #8]
  107ae8:	e5933014 	ldr	r3, [r3, #20]
  107aec:	e51b2008 	ldr	r2, [fp, #-8]
  107af0:	e5922018 	ldr	r2, [r2, #24]
  107af4:	e1a00002 	mov	r0, r2
  107af8:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  107afc:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  107b00:	e12fff33 	blx	r3
  107b04:	e50b0010 	str	r0, [fp, #-16]
    if (new_socket != -1)
  107b08:	e51b3010 	ldr	r3, [fp, #-16]
  107b0c:	e3730001 	cmn	r3, #1
  107b10:	0a000038 	beq	107bf8 <sal_accept+0x19c>
        int retval;
        int new_sal_socket;
        struct sal_socket *new_sock;

        /* allocate a new socket structure and registered socket options */
        new_sal_socket = socket_new();
  107b14:	ebffff77 	bl	1078f8 <socket_new>
  107b18:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
        new_sock = sal_get_socket(new_sal_socket);
  107b1c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  107b20:	ebfffdf7 	bl	107304 <sal_get_socket>
  107b24:	e1a03000 	mov	r3, r0
  107b28:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
        if (new_sock == RT_NULL)
  107b2c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  107b30:	e3530000 	cmp	r3, #0
  107b34:	1a000006 	bne	107b54 <sal_accept+0xf8>
        {
            pf->skt_ops->closesocket(new_socket);
  107b38:	e51b300c 	ldr	r3, [fp, #-12]
  107b3c:	e5933008 	ldr	r3, [r3, #8]
  107b40:	e5933004 	ldr	r3, [r3, #4]
  107b44:	e51b0010 	ldr	r0, [fp, #-16]
  107b48:	e12fff33 	blx	r3
            return -1;
  107b4c:	e3e03000 	mvn	r3, #0
  107b50:	ea000029 	b	107bfc <sal_accept+0x1a0>
        }

        retval = socket_init(sock->domain, sock->type, sock->protocol, &new_sock);
  107b54:	e51b3008 	ldr	r3, [fp, #-8]
  107b58:	e5930008 	ldr	r0, [r3, #8]
  107b5c:	e51b3008 	ldr	r3, [fp, #-8]
  107b60:	e593100c 	ldr	r1, [r3, #12]
  107b64:	e51b3008 	ldr	r3, [fp, #-8]
  107b68:	e5932010 	ldr	r2, [r3, #16]
  107b6c:	e24b301c 	sub	r3, fp, #28
  107b70:	ebfffe62 	bl	107500 <socket_init>
  107b74:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
        if (retval < 0)
  107b78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  107b7c:	e3530000 	cmp	r3, #0
  107b80:	aa000017 	bge	107be4 <sal_accept+0x188>
        {
            pf->skt_ops->closesocket(new_socket);
  107b84:	e51b300c 	ldr	r3, [fp, #-12]
  107b88:	e5933008 	ldr	r3, [r3, #8]
  107b8c:	e5933004 	ldr	r3, [r3, #4]
  107b90:	e51b0010 	ldr	r0, [fp, #-16]
  107b94:	e12fff33 	blx	r3
            rt_memset(new_sock, 0x00, sizeof(struct sal_socket));
  107b98:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  107b9c:	e3a0201c 	mov	r2, #28
  107ba0:	e3a01000 	mov	r1, #0
  107ba4:	e1a00003 	mov	r0, r3
  107ba8:	ebffedc6 	bl	1032c8 <rt_memset>
            /* socket init failed, delete socket */
            socket_delete(new_sal_socket);
  107bac:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  107bb0:	ebffff7c 	bl	1079a8 <socket_delete>
            LOG_E("New socket registered failed, return error %d.", retval);
  107bb4:	e3060188 	movw	r0, #24968	; 0x6188
  107bb8:	e3400014 	movt	r0, #20
  107bbc:	ebffed54 	bl	103114 <rt_kprintf>
  107bc0:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  107bc4:	e30602e8 	movw	r0, #25320	; 0x62e8
  107bc8:	e3400014 	movt	r0, #20
  107bcc:	ebffed50 	bl	103114 <rt_kprintf>
  107bd0:	e30601bc 	movw	r0, #25020	; 0x61bc
  107bd4:	e3400014 	movt	r0, #20
  107bd8:	ebffed4d 	bl	103114 <rt_kprintf>
            return -1;
  107bdc:	e3e03000 	mvn	r3, #0
  107be0:	ea000005 	b	107bfc <sal_accept+0x1a0>
        }

        /* socket structure user_data used to store the acquired new socket */
        new_sock->user_data = (void *)(size_t)new_socket;
  107be4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  107be8:	e51b2010 	ldr	r2, [fp, #-16]
  107bec:	e5832018 	str	r2, [r3, #24]

        return new_sal_socket;
  107bf0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  107bf4:	ea000000 	b	107bfc <sal_accept+0x1a0>
    }

    return -1;
  107bf8:	e3e03000 	mvn	r3, #0
}
  107bfc:	e1a00003 	mov	r0, r3
  107c00:	e24bd004 	sub	sp, fp, #4
  107c04:	e8bd8800 	pop	{fp, pc}

00107c08 <sal_sockaddr_to_ipaddr>:

static void sal_sockaddr_to_ipaddr(const struct sockaddr *name, ip_addr_t *local_ipaddr)
{
  107c08:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  107c0c:	e28db000 	add	fp, sp, #0
  107c10:	e24dd014 	sub	sp, sp, #20
  107c14:	e50b0010 	str	r0, [fp, #-16]
  107c18:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    const struct sockaddr_in *svr_addr = (const struct sockaddr_in *) name;
  107c1c:	e51b3010 	ldr	r3, [fp, #-16]
  107c20:	e50b3008 	str	r3, [fp, #-8]

#if NETDEV_IPV4 && NETDEV_IPV6
    local_ipaddr->u_addr.ip4.addr = svr_addr->sin_addr.s_addr;
    local_ipaddr->type = IPADDR_TYPE_V4;
#elif NETDEV_IPV4
    local_ipaddr->addr = svr_addr->sin_addr.s_addr;
  107c24:	e51b3008 	ldr	r3, [fp, #-8]
  107c28:	e5932004 	ldr	r2, [r3, #4]
  107c2c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  107c30:	e5832000 	str	r2, [r3]
#elif NETDEV_IPV6
#error "not only support IPV6"
#endif /* NETDEV_IPV4 && NETDEV_IPV6*/
}
  107c34:	e320f000 	nop	{0}
  107c38:	e28bd000 	add	sp, fp, #0
  107c3c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  107c40:	e12fff1e 	bx	lr

00107c44 <sal_bind>:

int sal_bind(int socket, const struct sockaddr *name, socklen_t namelen)
{
  107c44:	e92d4800 	push	{fp, lr}
  107c48:	e28db004 	add	fp, sp, #4
  107c4c:	e24dd030 	sub	sp, sp, #48	; 0x30
  107c50:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  107c54:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  107c58:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
    struct sal_socket *sock;
    struct sal_proto_family *pf;
    ip_addr_t input_ipaddr;

    RT_ASSERT(name);
  107c5c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  107c60:	e3530000 	cmp	r3, #0
  107c64:	1a000005 	bne	107c80 <sal_bind+0x3c>
  107c68:	e3002271 	movw	r2, #625	; 0x271
  107c6c:	e3061388 	movw	r1, #25480	; 0x6388
  107c70:	e3401014 	movt	r1, #20
  107c74:	e3060318 	movw	r0, #25368	; 0x6318
  107c78:	e3400014 	movt	r0, #20
  107c7c:	ebffee45 	bl	103598 <rt_assert_handler>

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  107c80:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  107c84:	ebfffd9e 	bl	107304 <sal_get_socket>
  107c88:	e50b0008 	str	r0, [fp, #-8]
  107c8c:	e51b3008 	ldr	r3, [fp, #-8]
  107c90:	e3530000 	cmp	r3, #0
  107c94:	1a000001 	bne	107ca0 <sal_bind+0x5c>
  107c98:	e3e03000 	mvn	r3, #0
  107c9c:	ea000062 	b	107e2c <sal_bind+0x1e8>

    /* bind network interface by ip address */
    sal_sockaddr_to_ipaddr(name, &input_ipaddr);
  107ca0:	e24b3020 	sub	r3, fp, #32
  107ca4:	e1a01003 	mov	r1, r3
  107ca8:	e51b002c 	ldr	r0, [fp, #-44]	; 0xffffffd4
  107cac:	ebffffd5 	bl	107c08 <sal_sockaddr_to_ipaddr>

    /* check input ipaddr is default netdev ipaddr */
    if (!ip_addr_isany_val(input_ipaddr))
  107cb0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  107cb4:	e3530000 	cmp	r3, #0
  107cb8:	0a000046 	beq	107dd8 <sal_bind+0x194>
    {
        struct sal_proto_family *input_pf = RT_NULL, *local_pf = RT_NULL;
  107cbc:	e3a03000 	mov	r3, #0
  107cc0:	e50b300c 	str	r3, [fp, #-12]
  107cc4:	e3a03000 	mov	r3, #0
  107cc8:	e50b3010 	str	r3, [fp, #-16]
        struct netdev *new_netdev = RT_NULL;
  107ccc:	e3a03000 	mov	r3, #0
  107cd0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

        new_netdev = netdev_get_by_ipaddr(&input_ipaddr);
  107cd4:	e24b3020 	sub	r3, fp, #32
  107cd8:	e1a00003 	mov	r0, r3
  107cdc:	ebfff5df 	bl	105460 <netdev_get_by_ipaddr>
  107ce0:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
        if (new_netdev == RT_NULL)
  107ce4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  107ce8:	e3530000 	cmp	r3, #0
  107cec:	1a000001 	bne	107cf8 <sal_bind+0xb4>
        {
            return -1;
  107cf0:	e3e03000 	mvn	r3, #0
  107cf4:	ea00004c 	b	107e2c <sal_bind+0x1e8>
        }

        /* get input and local ip address proto_family */
        SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, local_pf, bind);
  107cf8:	e51b3008 	ldr	r3, [fp, #-8]
  107cfc:	e5933014 	ldr	r3, [r3, #20]
  107d00:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  107d04:	e50b3010 	str	r3, [fp, #-16]
  107d08:	e51b3010 	ldr	r3, [fp, #-16]
  107d0c:	e5933008 	ldr	r3, [r3, #8]
  107d10:	e5933008 	ldr	r3, [r3, #8]
  107d14:	e3530000 	cmp	r3, #0
  107d18:	1a000001 	bne	107d24 <sal_bind+0xe0>
  107d1c:	e3e03000 	mvn	r3, #0
  107d20:	ea000041 	b	107e2c <sal_bind+0x1e8>
        SAL_NETDEV_SOCKETOPS_VALID(new_netdev, input_pf, bind);
  107d24:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  107d28:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  107d2c:	e50b300c 	str	r3, [fp, #-12]
  107d30:	e51b300c 	ldr	r3, [fp, #-12]
  107d34:	e5933008 	ldr	r3, [r3, #8]
  107d38:	e5933008 	ldr	r3, [r3, #8]
  107d3c:	e3530000 	cmp	r3, #0
  107d40:	1a000001 	bne	107d4c <sal_bind+0x108>
  107d44:	e3e03000 	mvn	r3, #0
  107d48:	ea000037 	b	107e2c <sal_bind+0x1e8>

        /* check the network interface protocol family type */
        if (input_pf->family != local_pf->family)
  107d4c:	e51b300c 	ldr	r3, [fp, #-12]
  107d50:	e5932000 	ldr	r2, [r3]
  107d54:	e51b3010 	ldr	r3, [fp, #-16]
  107d58:	e5933000 	ldr	r3, [r3]
  107d5c:	e1520003 	cmp	r2, r3
  107d60:	0a00001c 	beq	107dd8 <sal_bind+0x194>
        {
            int new_socket = -1;
  107d64:	e3e03000 	mvn	r3, #0
  107d68:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

            /* protocol family is different, close old socket and create new socket by input ip address */
            local_pf->skt_ops->closesocket(socket);
  107d6c:	e51b3010 	ldr	r3, [fp, #-16]
  107d70:	e5933008 	ldr	r3, [r3, #8]
  107d74:	e5933004 	ldr	r3, [r3, #4]
  107d78:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  107d7c:	e12fff33 	blx	r3

            new_socket = input_pf->skt_ops->socket(input_pf->family, sock->type, sock->protocol);
  107d80:	e51b300c 	ldr	r3, [fp, #-12]
  107d84:	e5933008 	ldr	r3, [r3, #8]
  107d88:	e5933000 	ldr	r3, [r3]
  107d8c:	e51b200c 	ldr	r2, [fp, #-12]
  107d90:	e5920000 	ldr	r0, [r2]
  107d94:	e51b2008 	ldr	r2, [fp, #-8]
  107d98:	e592100c 	ldr	r1, [r2, #12]
  107d9c:	e51b2008 	ldr	r2, [fp, #-8]
  107da0:	e5922010 	ldr	r2, [r2, #16]
  107da4:	e12fff33 	blx	r3
  107da8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
            if (new_socket < 0)
  107dac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  107db0:	e3530000 	cmp	r3, #0
  107db4:	aa000001 	bge	107dc0 <sal_bind+0x17c>
            {
                return -1;
  107db8:	e3e03000 	mvn	r3, #0
  107dbc:	ea00001a 	b	107e2c <sal_bind+0x1e8>
            }
            sock->netdev = new_netdev;
  107dc0:	e51b3008 	ldr	r3, [fp, #-8]
  107dc4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  107dc8:	e5832014 	str	r2, [r3, #20]
            sock->user_data = (void *)(size_t)new_socket;
  107dcc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  107dd0:	e51b3008 	ldr	r3, [fp, #-8]
  107dd4:	e5832018 	str	r2, [r3, #24]
        }
    }

    /* check and get protocol families by the network interface device */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, bind);
  107dd8:	e51b3008 	ldr	r3, [fp, #-8]
  107ddc:	e5933014 	ldr	r3, [r3, #20]
  107de0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  107de4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  107de8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  107dec:	e5933008 	ldr	r3, [r3, #8]
  107df0:	e5933008 	ldr	r3, [r3, #8]
  107df4:	e3530000 	cmp	r3, #0
  107df8:	1a000001 	bne	107e04 <sal_bind+0x1c0>
  107dfc:	e3e03000 	mvn	r3, #0
  107e00:	ea000009 	b	107e2c <sal_bind+0x1e8>
    return pf->skt_ops->bind((int)(size_t)sock->user_data, name, namelen);
  107e04:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  107e08:	e5933008 	ldr	r3, [r3, #8]
  107e0c:	e5933008 	ldr	r3, [r3, #8]
  107e10:	e51b2008 	ldr	r2, [fp, #-8]
  107e14:	e5922018 	ldr	r2, [r2, #24]
  107e18:	e1a00002 	mov	r0, r2
  107e1c:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  107e20:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  107e24:	e12fff33 	blx	r3
  107e28:	e1a03000 	mov	r3, r0
}
  107e2c:	e1a00003 	mov	r0, r3
  107e30:	e24bd004 	sub	sp, fp, #4
  107e34:	e8bd8800 	pop	{fp, pc}

00107e38 <sal_shutdown>:

int sal_shutdown(int socket, int how)
{
  107e38:	e92d4800 	push	{fp, lr}
  107e3c:	e28db004 	add	fp, sp, #4
  107e40:	e24dd018 	sub	sp, sp, #24
  107e44:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  107e48:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    struct sal_socket *sock;
    struct sal_proto_family *pf;
    int error = 0;
  107e4c:	e3a03000 	mov	r3, #0
  107e50:	e50b3008 	str	r3, [fp, #-8]

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  107e54:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  107e58:	ebfffd29 	bl	107304 <sal_get_socket>
  107e5c:	e50b000c 	str	r0, [fp, #-12]
  107e60:	e51b300c 	ldr	r3, [fp, #-12]
  107e64:	e3530000 	cmp	r3, #0
  107e68:	1a000001 	bne	107e74 <sal_shutdown+0x3c>
  107e6c:	e3e03000 	mvn	r3, #0
  107e70:	ea00001b 	b	107ee4 <sal_shutdown+0xac>

    /* shutdown operation not need to check network interface status */
    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, shutdown);
  107e74:	e51b300c 	ldr	r3, [fp, #-12]
  107e78:	e5933014 	ldr	r3, [r3, #20]
  107e7c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  107e80:	e50b3010 	str	r3, [fp, #-16]
  107e84:	e51b3010 	ldr	r3, [fp, #-16]
  107e88:	e5933008 	ldr	r3, [r3, #8]
  107e8c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  107e90:	e3530000 	cmp	r3, #0
  107e94:	1a000001 	bne	107ea0 <sal_shutdown+0x68>
  107e98:	e3e03000 	mvn	r3, #0
  107e9c:	ea000010 	b	107ee4 <sal_shutdown+0xac>

    if (pf->skt_ops->shutdown((int)(size_t)sock->user_data, how) == 0)
  107ea0:	e51b3010 	ldr	r3, [fp, #-16]
  107ea4:	e5933008 	ldr	r3, [r3, #8]
  107ea8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  107eac:	e51b200c 	ldr	r2, [fp, #-12]
  107eb0:	e5922018 	ldr	r2, [r2, #24]
  107eb4:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  107eb8:	e1a00002 	mov	r0, r2
  107ebc:	e12fff33 	blx	r3
  107ec0:	e1a03000 	mov	r3, r0
  107ec4:	e3530000 	cmp	r3, #0
  107ec8:	1a000002 	bne	107ed8 <sal_shutdown+0xa0>
            {
                return -1;
            }
        }
#endif
        error = 0;
  107ecc:	e3a03000 	mov	r3, #0
  107ed0:	e50b3008 	str	r3, [fp, #-8]
  107ed4:	ea000001 	b	107ee0 <sal_shutdown+0xa8>
    }
    else
    {
        error = -1;
  107ed8:	e3e03000 	mvn	r3, #0
  107edc:	e50b3008 	str	r3, [fp, #-8]
    }


    return error;
  107ee0:	e51b3008 	ldr	r3, [fp, #-8]
}
  107ee4:	e1a00003 	mov	r0, r3
  107ee8:	e24bd004 	sub	sp, fp, #4
  107eec:	e8bd8800 	pop	{fp, pc}

00107ef0 <sal_getpeername>:

int sal_getpeername(int socket, struct sockaddr *name, socklen_t *namelen)
{
  107ef0:	e92d4800 	push	{fp, lr}
  107ef4:	e28db004 	add	fp, sp, #4
  107ef8:	e24dd018 	sub	sp, sp, #24
  107efc:	e50b0010 	str	r0, [fp, #-16]
  107f00:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  107f04:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    struct sal_socket *sock;
    struct sal_proto_family *pf;

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  107f08:	e51b0010 	ldr	r0, [fp, #-16]
  107f0c:	ebfffcfc 	bl	107304 <sal_get_socket>
  107f10:	e50b0008 	str	r0, [fp, #-8]
  107f14:	e51b3008 	ldr	r3, [fp, #-8]
  107f18:	e3530000 	cmp	r3, #0
  107f1c:	1a000001 	bne	107f28 <sal_getpeername+0x38>
  107f20:	e3e03000 	mvn	r3, #0
  107f24:	ea000014 	b	107f7c <sal_getpeername+0x8c>

    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, getpeername);
  107f28:	e51b3008 	ldr	r3, [fp, #-8]
  107f2c:	e5933014 	ldr	r3, [r3, #20]
  107f30:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  107f34:	e50b300c 	str	r3, [fp, #-12]
  107f38:	e51b300c 	ldr	r3, [fp, #-12]
  107f3c:	e5933008 	ldr	r3, [r3, #8]
  107f40:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  107f44:	e3530000 	cmp	r3, #0
  107f48:	1a000001 	bne	107f54 <sal_getpeername+0x64>
  107f4c:	e3e03000 	mvn	r3, #0
  107f50:	ea000009 	b	107f7c <sal_getpeername+0x8c>

    return pf->skt_ops->getpeername((int)(size_t)sock->user_data, name, namelen);
  107f54:	e51b300c 	ldr	r3, [fp, #-12]
  107f58:	e5933008 	ldr	r3, [r3, #8]
  107f5c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  107f60:	e51b2008 	ldr	r2, [fp, #-8]
  107f64:	e5922018 	ldr	r2, [r2, #24]
  107f68:	e1a00002 	mov	r0, r2
  107f6c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  107f70:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  107f74:	e12fff33 	blx	r3
  107f78:	e1a03000 	mov	r3, r0
}
  107f7c:	e1a00003 	mov	r0, r3
  107f80:	e24bd004 	sub	sp, fp, #4
  107f84:	e8bd8800 	pop	{fp, pc}

00107f88 <sal_getsockname>:

int sal_getsockname(int socket, struct sockaddr *name, socklen_t *namelen)
{
  107f88:	e92d4800 	push	{fp, lr}
  107f8c:	e28db004 	add	fp, sp, #4
  107f90:	e24dd018 	sub	sp, sp, #24
  107f94:	e50b0010 	str	r0, [fp, #-16]
  107f98:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  107f9c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    struct sal_socket *sock;
    struct sal_proto_family *pf;

    /* get socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  107fa0:	e51b0010 	ldr	r0, [fp, #-16]
  107fa4:	ebfffcd6 	bl	107304 <sal_get_socket>
  107fa8:	e50b0008 	str	r0, [fp, #-8]
  107fac:	e51b3008 	ldr	r3, [fp, #-8]
  107fb0:	e3530000 	cmp	r3, #0
  107fb4:	1a000001 	bne	107fc0 <sal_getsockname+0x38>
  107fb8:	e3e03000 	mvn	r3, #0
  107fbc:	ea000014 	b	108014 <sal_getsockname+0x8c>

    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, getsockname);
  107fc0:	e51b3008 	ldr	r3, [fp, #-8]
  107fc4:	e5933014 	ldr	r3, [r3, #20]
  107fc8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  107fcc:	e50b300c 	str	r3, [fp, #-12]
  107fd0:	e51b300c 	ldr	r3, [fp, #-12]
  107fd4:	e5933008 	ldr	r3, [r3, #8]
  107fd8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  107fdc:	e3530000 	cmp	r3, #0
  107fe0:	1a000001 	bne	107fec <sal_getsockname+0x64>
  107fe4:	e3e03000 	mvn	r3, #0
  107fe8:	ea000009 	b	108014 <sal_getsockname+0x8c>

    return pf->skt_ops->getsockname((int)(size_t)sock->user_data, name, namelen);
  107fec:	e51b300c 	ldr	r3, [fp, #-12]
  107ff0:	e5933008 	ldr	r3, [r3, #8]
  107ff4:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  107ff8:	e51b2008 	ldr	r2, [fp, #-8]
  107ffc:	e5922018 	ldr	r2, [r2, #24]
  108000:	e1a00002 	mov	r0, r2
  108004:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  108008:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10800c:	e12fff33 	blx	r3
  108010:	e1a03000 	mov	r3, r0
}
  108014:	e1a00003 	mov	r0, r3
  108018:	e24bd004 	sub	sp, fp, #4
  10801c:	e8bd8800 	pop	{fp, pc}

00108020 <sal_getsockopt>:

int sal_getsockopt(int socket, int level, int optname, void *optval, socklen_t *optlen)
{
  108020:	e92d4810 	push	{r4, fp, lr}
  108024:	e28db008 	add	fp, sp, #8
  108028:	e24dd024 	sub	sp, sp, #36	; 0x24
  10802c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  108030:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  108034:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  108038:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    struct sal_socket *sock;
    struct sal_proto_family *pf;

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  10803c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  108040:	ebfffcaf 	bl	107304 <sal_get_socket>
  108044:	e50b0010 	str	r0, [fp, #-16]
  108048:	e51b3010 	ldr	r3, [fp, #-16]
  10804c:	e3530000 	cmp	r3, #0
  108050:	1a000001 	bne	10805c <sal_getsockopt+0x3c>
  108054:	e3e03000 	mvn	r3, #0
  108058:	ea000017 	b	1080bc <sal_getsockopt+0x9c>

    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, getsockopt);
  10805c:	e51b3010 	ldr	r3, [fp, #-16]
  108060:	e5933014 	ldr	r3, [r3, #20]
  108064:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108068:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  10806c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108070:	e5933008 	ldr	r3, [r3, #8]
  108074:	e5933020 	ldr	r3, [r3, #32]
  108078:	e3530000 	cmp	r3, #0
  10807c:	1a000001 	bne	108088 <sal_getsockopt+0x68>
  108080:	e3e03000 	mvn	r3, #0
  108084:	ea00000c 	b	1080bc <sal_getsockopt+0x9c>

    return pf->skt_ops->getsockopt((int)(size_t)sock->user_data, level, optname, optval, optlen);
  108088:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10808c:	e5933008 	ldr	r3, [r3, #8]
  108090:	e5934020 	ldr	r4, [r3, #32]
  108094:	e51b3010 	ldr	r3, [fp, #-16]
  108098:	e5933018 	ldr	r3, [r3, #24]
  10809c:	e1a00003 	mov	r0, r3
  1080a0:	e59b3004 	ldr	r3, [fp, #4]
  1080a4:	e58d3000 	str	r3, [sp]
  1080a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1080ac:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1080b0:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  1080b4:	e12fff34 	blx	r4
  1080b8:	e1a03000 	mov	r3, r0
}
  1080bc:	e1a00003 	mov	r0, r3
  1080c0:	e24bd008 	sub	sp, fp, #8
  1080c4:	e8bd8810 	pop	{r4, fp, pc}

001080c8 <sal_setsockopt>:

int sal_setsockopt(int socket, int level, int optname, const void *optval, socklen_t optlen)
{
  1080c8:	e92d4810 	push	{r4, fp, lr}
  1080cc:	e28db008 	add	fp, sp, #8
  1080d0:	e24dd024 	sub	sp, sp, #36	; 0x24
  1080d4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1080d8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  1080dc:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  1080e0:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    struct sal_socket *sock;
    struct sal_proto_family *pf;

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  1080e4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1080e8:	ebfffc85 	bl	107304 <sal_get_socket>
  1080ec:	e50b0010 	str	r0, [fp, #-16]
  1080f0:	e51b3010 	ldr	r3, [fp, #-16]
  1080f4:	e3530000 	cmp	r3, #0
  1080f8:	1a000001 	bne	108104 <sal_setsockopt+0x3c>
  1080fc:	e3e03000 	mvn	r3, #0
  108100:	ea000017 	b	108164 <sal_setsockopt+0x9c>

    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, setsockopt);
  108104:	e51b3010 	ldr	r3, [fp, #-16]
  108108:	e5933014 	ldr	r3, [r3, #20]
  10810c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108110:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  108114:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108118:	e5933008 	ldr	r3, [r3, #8]
  10811c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  108120:	e3530000 	cmp	r3, #0
  108124:	1a000001 	bne	108130 <sal_setsockopt+0x68>
  108128:	e3e03000 	mvn	r3, #0
  10812c:	ea00000c 	b	108164 <sal_setsockopt+0x9c>
    else
    {
        return pf->skt_ops->setsockopt((int) sock->user_data, level, optname, optval, optlen);
    }
#else
    return pf->skt_ops->setsockopt((int)(size_t)sock->user_data, level, optname, optval, optlen);
  108130:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108134:	e5933008 	ldr	r3, [r3, #8]
  108138:	e5934024 	ldr	r4, [r3, #36]	; 0x24
  10813c:	e51b3010 	ldr	r3, [fp, #-16]
  108140:	e5933018 	ldr	r3, [r3, #24]
  108144:	e1a00003 	mov	r0, r3
  108148:	e59b3004 	ldr	r3, [fp, #4]
  10814c:	e58d3000 	str	r3, [sp]
  108150:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  108154:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  108158:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  10815c:	e12fff34 	blx	r4
  108160:	e1a03000 	mov	r3, r0
#endif /* SAL_USING_TLS */
}
  108164:	e1a00003 	mov	r0, r3
  108168:	e24bd008 	sub	sp, fp, #8
  10816c:	e8bd8810 	pop	{r4, fp, pc}

00108170 <sal_connect>:

int sal_connect(int socket, const struct sockaddr *name, socklen_t namelen)
{
  108170:	e92d4800 	push	{fp, lr}
  108174:	e28db004 	add	fp, sp, #4
  108178:	e24dd020 	sub	sp, sp, #32
  10817c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  108180:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  108184:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
    struct sal_socket *sock;
    struct sal_proto_family *pf;
    int ret;

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  108188:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  10818c:	ebfffc5c 	bl	107304 <sal_get_socket>
  108190:	e50b0008 	str	r0, [fp, #-8]
  108194:	e51b3008 	ldr	r3, [fp, #-8]
  108198:	e3530000 	cmp	r3, #0
  10819c:	1a000001 	bne	1081a8 <sal_connect+0x38>
  1081a0:	e3e03000 	mvn	r3, #0
  1081a4:	ea00001d 	b	108220 <sal_connect+0xb0>

    /* check the network interface is up status */
    SAL_NETDEV_IS_UP(sock->netdev);
  1081a8:	e51b3008 	ldr	r3, [fp, #-8]
  1081ac:	e5933014 	ldr	r3, [r3, #20]
  1081b0:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1081b4:	e2033001 	and	r3, r3, #1
  1081b8:	e3530000 	cmp	r3, #0
  1081bc:	1a000001 	bne	1081c8 <sal_connect+0x58>
  1081c0:	e3e03000 	mvn	r3, #0
  1081c4:	ea000015 	b	108220 <sal_connect+0xb0>
    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, connect);
  1081c8:	e51b3008 	ldr	r3, [fp, #-8]
  1081cc:	e5933014 	ldr	r3, [r3, #20]
  1081d0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  1081d4:	e50b300c 	str	r3, [fp, #-12]
  1081d8:	e51b300c 	ldr	r3, [fp, #-12]
  1081dc:	e5933008 	ldr	r3, [r3, #8]
  1081e0:	e5933010 	ldr	r3, [r3, #16]
  1081e4:	e3530000 	cmp	r3, #0
  1081e8:	1a000001 	bne	1081f4 <sal_connect+0x84>
  1081ec:	e3e03000 	mvn	r3, #0
  1081f0:	ea00000a 	b	108220 <sal_connect+0xb0>

    ret = pf->skt_ops->connect((int)(size_t)sock->user_data, name, namelen);
  1081f4:	e51b300c 	ldr	r3, [fp, #-12]
  1081f8:	e5933008 	ldr	r3, [r3, #8]
  1081fc:	e5933010 	ldr	r3, [r3, #16]
  108200:	e51b2008 	ldr	r2, [fp, #-8]
  108204:	e5922018 	ldr	r2, [r2, #24]
  108208:	e1a00002 	mov	r0, r2
  10820c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  108210:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  108214:	e12fff33 	blx	r3
  108218:	e50b0010 	str	r0, [fp, #-16]

        return ret;
    }
#endif

    return ret;
  10821c:	e51b3010 	ldr	r3, [fp, #-16]
}
  108220:	e1a00003 	mov	r0, r3
  108224:	e24bd004 	sub	sp, fp, #4
  108228:	e8bd8800 	pop	{fp, pc}

0010822c <sal_listen>:

int sal_listen(int socket, int backlog)
{
  10822c:	e92d4800 	push	{fp, lr}
  108230:	e28db004 	add	fp, sp, #4
  108234:	e24dd010 	sub	sp, sp, #16
  108238:	e50b0010 	str	r0, [fp, #-16]
  10823c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    struct sal_socket *sock;
    struct sal_proto_family *pf;

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  108240:	e51b0010 	ldr	r0, [fp, #-16]
  108244:	ebfffc2e 	bl	107304 <sal_get_socket>
  108248:	e50b0008 	str	r0, [fp, #-8]
  10824c:	e51b3008 	ldr	r3, [fp, #-8]
  108250:	e3530000 	cmp	r3, #0
  108254:	1a000001 	bne	108260 <sal_listen+0x34>
  108258:	e3e03000 	mvn	r3, #0
  10825c:	ea000013 	b	1082b0 <sal_listen+0x84>

    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, listen);
  108260:	e51b3008 	ldr	r3, [fp, #-8]
  108264:	e5933014 	ldr	r3, [r3, #20]
  108268:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10826c:	e50b300c 	str	r3, [fp, #-12]
  108270:	e51b300c 	ldr	r3, [fp, #-12]
  108274:	e5933008 	ldr	r3, [r3, #8]
  108278:	e593300c 	ldr	r3, [r3, #12]
  10827c:	e3530000 	cmp	r3, #0
  108280:	1a000001 	bne	10828c <sal_listen+0x60>
  108284:	e3e03000 	mvn	r3, #0
  108288:	ea000008 	b	1082b0 <sal_listen+0x84>

    return pf->skt_ops->listen((int)(size_t)sock->user_data, backlog);
  10828c:	e51b300c 	ldr	r3, [fp, #-12]
  108290:	e5933008 	ldr	r3, [r3, #8]
  108294:	e593300c 	ldr	r3, [r3, #12]
  108298:	e51b2008 	ldr	r2, [fp, #-8]
  10829c:	e5922018 	ldr	r2, [r2, #24]
  1082a0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1082a4:	e1a00002 	mov	r0, r2
  1082a8:	e12fff33 	blx	r3
  1082ac:	e1a03000 	mov	r3, r0
}
  1082b0:	e1a00003 	mov	r0, r3
  1082b4:	e24bd004 	sub	sp, fp, #4
  1082b8:	e8bd8800 	pop	{fp, pc}

001082bc <sal_recvfrom>:

int sal_recvfrom(int socket, void *mem, size_t len, int flags,
                 struct sockaddr *from, socklen_t *fromlen)
{
  1082bc:	e92d4810 	push	{r4, fp, lr}
  1082c0:	e28db008 	add	fp, sp, #8
  1082c4:	e24dd024 	sub	sp, sp, #36	; 0x24
  1082c8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1082cc:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  1082d0:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  1082d4:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    struct sal_socket *sock;
    struct sal_proto_family *pf;

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  1082d8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1082dc:	ebfffc08 	bl	107304 <sal_get_socket>
  1082e0:	e50b0010 	str	r0, [fp, #-16]
  1082e4:	e51b3010 	ldr	r3, [fp, #-16]
  1082e8:	e3530000 	cmp	r3, #0
  1082ec:	1a000001 	bne	1082f8 <sal_recvfrom+0x3c>
  1082f0:	e3e03000 	mvn	r3, #0
  1082f4:	ea000021 	b	108380 <sal_recvfrom+0xc4>

    /* check the network interface is up status  */
    SAL_NETDEV_IS_UP(sock->netdev);
  1082f8:	e51b3010 	ldr	r3, [fp, #-16]
  1082fc:	e5933014 	ldr	r3, [r3, #20]
  108300:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  108304:	e2033001 	and	r3, r3, #1
  108308:	e3530000 	cmp	r3, #0
  10830c:	1a000001 	bne	108318 <sal_recvfrom+0x5c>
  108310:	e3e03000 	mvn	r3, #0
  108314:	ea000019 	b	108380 <sal_recvfrom+0xc4>
    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, recvfrom);
  108318:	e51b3010 	ldr	r3, [fp, #-16]
  10831c:	e5933014 	ldr	r3, [r3, #20]
  108320:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108324:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  108328:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10832c:	e5933008 	ldr	r3, [r3, #8]
  108330:	e593301c 	ldr	r3, [r3, #28]
  108334:	e3530000 	cmp	r3, #0
  108338:	1a000001 	bne	108344 <sal_recvfrom+0x88>
  10833c:	e3e03000 	mvn	r3, #0
  108340:	ea00000e 	b	108380 <sal_recvfrom+0xc4>
    else
    {
        return pf->skt_ops->recvfrom((int)(size_t)sock->user_data, mem, len, flags, from, fromlen);
    }
#else
    return pf->skt_ops->recvfrom((int)(size_t)sock->user_data, mem, len, flags, from, fromlen);
  108344:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108348:	e5933008 	ldr	r3, [r3, #8]
  10834c:	e593401c 	ldr	r4, [r3, #28]
  108350:	e51b3010 	ldr	r3, [fp, #-16]
  108354:	e5933018 	ldr	r3, [r3, #24]
  108358:	e1a00003 	mov	r0, r3
  10835c:	e59b3008 	ldr	r3, [fp, #8]
  108360:	e58d3004 	str	r3, [sp, #4]
  108364:	e59b3004 	ldr	r3, [fp, #4]
  108368:	e58d3000 	str	r3, [sp]
  10836c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  108370:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  108374:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  108378:	e12fff34 	blx	r4
  10837c:	e1a03000 	mov	r3, r0
#endif
}
  108380:	e1a00003 	mov	r0, r3
  108384:	e24bd008 	sub	sp, fp, #8
  108388:	e8bd8810 	pop	{r4, fp, pc}

0010838c <sal_sendto>:

int sal_sendto(int socket, const void *dataptr, size_t size, int flags,
               const struct sockaddr *to, socklen_t tolen)
{
  10838c:	e92d4810 	push	{r4, fp, lr}
  108390:	e28db008 	add	fp, sp, #8
  108394:	e24dd024 	sub	sp, sp, #36	; 0x24
  108398:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10839c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  1083a0:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  1083a4:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    struct sal_socket *sock;
    struct sal_proto_family *pf;

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  1083a8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1083ac:	ebfffbd4 	bl	107304 <sal_get_socket>
  1083b0:	e50b0010 	str	r0, [fp, #-16]
  1083b4:	e51b3010 	ldr	r3, [fp, #-16]
  1083b8:	e3530000 	cmp	r3, #0
  1083bc:	1a000001 	bne	1083c8 <sal_sendto+0x3c>
  1083c0:	e3e03000 	mvn	r3, #0
  1083c4:	ea000021 	b	108450 <sal_sendto+0xc4>

    /* check the network interface is up status  */
    SAL_NETDEV_IS_UP(sock->netdev);
  1083c8:	e51b3010 	ldr	r3, [fp, #-16]
  1083cc:	e5933014 	ldr	r3, [r3, #20]
  1083d0:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1083d4:	e2033001 	and	r3, r3, #1
  1083d8:	e3530000 	cmp	r3, #0
  1083dc:	1a000001 	bne	1083e8 <sal_sendto+0x5c>
  1083e0:	e3e03000 	mvn	r3, #0
  1083e4:	ea000019 	b	108450 <sal_sendto+0xc4>
    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, sendto);
  1083e8:	e51b3010 	ldr	r3, [fp, #-16]
  1083ec:	e5933014 	ldr	r3, [r3, #20]
  1083f0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  1083f4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1083f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1083fc:	e5933008 	ldr	r3, [r3, #8]
  108400:	e5933018 	ldr	r3, [r3, #24]
  108404:	e3530000 	cmp	r3, #0
  108408:	1a000001 	bne	108414 <sal_sendto+0x88>
  10840c:	e3e03000 	mvn	r3, #0
  108410:	ea00000e 	b	108450 <sal_sendto+0xc4>
    else
    {
        return pf->skt_ops->sendto((int) sock->user_data, dataptr, size, flags, to, tolen);
    }
#else
    return pf->skt_ops->sendto((int)(size_t)sock->user_data, dataptr, size, flags, to, tolen);
  108414:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108418:	e5933008 	ldr	r3, [r3, #8]
  10841c:	e5934018 	ldr	r4, [r3, #24]
  108420:	e51b3010 	ldr	r3, [fp, #-16]
  108424:	e5933018 	ldr	r3, [r3, #24]
  108428:	e1a00003 	mov	r0, r3
  10842c:	e59b3008 	ldr	r3, [fp, #8]
  108430:	e58d3004 	str	r3, [sp, #4]
  108434:	e59b3004 	ldr	r3, [fp, #4]
  108438:	e58d3000 	str	r3, [sp]
  10843c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  108440:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  108444:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  108448:	e12fff34 	blx	r4
  10844c:	e1a03000 	mov	r3, r0
#endif
}
  108450:	e1a00003 	mov	r0, r3
  108454:	e24bd008 	sub	sp, fp, #8
  108458:	e8bd8810 	pop	{r4, fp, pc}

0010845c <sal_socket>:

int sal_socket(int domain, int type, int protocol)
{
  10845c:	e92d4800 	push	{fp, lr}
  108460:	e28db004 	add	fp, sp, #4
  108464:	e24dd028 	sub	sp, sp, #40	; 0x28
  108468:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  10846c:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  108470:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
    int socket, proto_socket;
    struct sal_socket *sock;
    struct sal_proto_family *pf;

    /* allocate a new socket and registered socket options */
    socket = socket_new();
  108474:	ebfffd1f 	bl	1078f8 <socket_new>
  108478:	e50b0008 	str	r0, [fp, #-8]
    if (socket < 0)
  10847c:	e51b3008 	ldr	r3, [fp, #-8]
  108480:	e3530000 	cmp	r3, #0
  108484:	aa000001 	bge	108490 <sal_socket+0x34>
    {
        return -1;
  108488:	e3e03000 	mvn	r3, #0
  10848c:	ea000040 	b	108594 <sal_socket+0x138>
    }

    /* get sal socket object by socket descriptor */
    sock = sal_get_socket(socket);
  108490:	e51b0008 	ldr	r0, [fp, #-8]
  108494:	ebfffb9a 	bl	107304 <sal_get_socket>
  108498:	e1a03000 	mov	r3, r0
  10849c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    if (sock == RT_NULL)
  1084a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1084a4:	e3530000 	cmp	r3, #0
  1084a8:	1a000003 	bne	1084bc <sal_socket+0x60>
    {
        socket_delete(socket);
  1084ac:	e51b0008 	ldr	r0, [fp, #-8]
  1084b0:	ebfffd3c 	bl	1079a8 <socket_delete>
        return -1;
  1084b4:	e3e03000 	mvn	r3, #0
  1084b8:	ea000035 	b	108594 <sal_socket+0x138>
    }

    /* Initialize sal socket object */
    retval = socket_init(domain, type, protocol, &sock);
  1084bc:	e24b3018 	sub	r3, fp, #24
  1084c0:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  1084c4:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  1084c8:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  1084cc:	ebfffc0b 	bl	107500 <socket_init>
  1084d0:	e50b000c 	str	r0, [fp, #-12]
    if (retval < 0)
  1084d4:	e51b300c 	ldr	r3, [fp, #-12]
  1084d8:	e3530000 	cmp	r3, #0
  1084dc:	aa00000d 	bge	108518 <sal_socket+0xbc>
    {
        LOG_E("SAL socket protocol family input failed, return error %d.", retval);
  1084e0:	e3060188 	movw	r0, #24968	; 0x6188
  1084e4:	e3400014 	movt	r0, #20
  1084e8:	ebffeb09 	bl	103114 <rt_kprintf>
  1084ec:	e51b100c 	ldr	r1, [fp, #-12]
  1084f0:	e3060320 	movw	r0, #25376	; 0x6320
  1084f4:	e3400014 	movt	r0, #20
  1084f8:	ebffeb05 	bl	103114 <rt_kprintf>
  1084fc:	e30601bc 	movw	r0, #25020	; 0x61bc
  108500:	e3400014 	movt	r0, #20
  108504:	ebffeb02 	bl	103114 <rt_kprintf>
        socket_delete(socket);
  108508:	e51b0008 	ldr	r0, [fp, #-8]
  10850c:	ebfffd25 	bl	1079a8 <socket_delete>
        return -1;
  108510:	e3e03000 	mvn	r3, #0
  108514:	ea00001e 	b	108594 <sal_socket+0x138>
    }

    /* valid the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, socket);
  108518:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10851c:	e5933014 	ldr	r3, [r3, #20]
  108520:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108524:	e50b3010 	str	r3, [fp, #-16]
  108528:	e51b3010 	ldr	r3, [fp, #-16]
  10852c:	e5933008 	ldr	r3, [r3, #8]
  108530:	e5933000 	ldr	r3, [r3]
  108534:	e3530000 	cmp	r3, #0
  108538:	1a000001 	bne	108544 <sal_socket+0xe8>
  10853c:	e3e03000 	mvn	r3, #0
  108540:	ea000013 	b	108594 <sal_socket+0x138>

    proto_socket = pf->skt_ops->socket(domain, type, protocol);
  108544:	e51b3010 	ldr	r3, [fp, #-16]
  108548:	e5933008 	ldr	r3, [r3, #8]
  10854c:	e5933000 	ldr	r3, [r3]
  108550:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  108554:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  108558:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10855c:	e12fff33 	blx	r3
  108560:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
    if (proto_socket >= 0)
  108564:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108568:	e3530000 	cmp	r3, #0
  10856c:	ba000005 	blt	108588 <sal_socket+0x12c>
                socket_delete(socket);
                return -1;
            }
        }
#endif
        sock->user_data = (void *)(size_t)proto_socket;
  108570:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  108574:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  108578:	e5832018 	str	r2, [r3, #24]
        return sock->socket;
  10857c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  108580:	e5933004 	ldr	r3, [r3, #4]
  108584:	ea000002 	b	108594 <sal_socket+0x138>
    }
    socket_delete(socket);
  108588:	e51b0008 	ldr	r0, [fp, #-8]
  10858c:	ebfffd05 	bl	1079a8 <socket_delete>
    return -1;
  108590:	e3e03000 	mvn	r3, #0
}
  108594:	e1a00003 	mov	r0, r3
  108598:	e24bd004 	sub	sp, fp, #4
  10859c:	e8bd8800 	pop	{fp, pc}

001085a0 <sal_closesocket>:

int sal_closesocket(int socket)
{
  1085a0:	e92d4800 	push	{fp, lr}
  1085a4:	e28db004 	add	fp, sp, #4
  1085a8:	e24dd018 	sub	sp, sp, #24
  1085ac:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    struct sal_socket *sock;
    struct sal_proto_family *pf;
    int error = 0;
  1085b0:	e3a03000 	mov	r3, #0
  1085b4:	e50b3008 	str	r3, [fp, #-8]

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  1085b8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1085bc:	ebfffb50 	bl	107304 <sal_get_socket>
  1085c0:	e50b000c 	str	r0, [fp, #-12]
  1085c4:	e51b300c 	ldr	r3, [fp, #-12]
  1085c8:	e3530000 	cmp	r3, #0
  1085cc:	1a000001 	bne	1085d8 <sal_closesocket+0x38>
  1085d0:	e3e03000 	mvn	r3, #0
  1085d4:	ea00001c 	b	10864c <sal_closesocket+0xac>

    /* clsoesocket operation not need to vaild network interface status */
    /* valid the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, socket);
  1085d8:	e51b300c 	ldr	r3, [fp, #-12]
  1085dc:	e5933014 	ldr	r3, [r3, #20]
  1085e0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  1085e4:	e50b3010 	str	r3, [fp, #-16]
  1085e8:	e51b3010 	ldr	r3, [fp, #-16]
  1085ec:	e5933008 	ldr	r3, [r3, #8]
  1085f0:	e5933000 	ldr	r3, [r3]
  1085f4:	e3530000 	cmp	r3, #0
  1085f8:	1a000001 	bne	108604 <sal_closesocket+0x64>
  1085fc:	e3e03000 	mvn	r3, #0
  108600:	ea000011 	b	10864c <sal_closesocket+0xac>

    if (pf->skt_ops->closesocket((int)(size_t)sock->user_data) == 0)
  108604:	e51b3010 	ldr	r3, [fp, #-16]
  108608:	e5933008 	ldr	r3, [r3, #8]
  10860c:	e5933004 	ldr	r3, [r3, #4]
  108610:	e51b200c 	ldr	r2, [fp, #-12]
  108614:	e5922018 	ldr	r2, [r2, #24]
  108618:	e1a00002 	mov	r0, r2
  10861c:	e12fff33 	blx	r3
  108620:	e1a03000 	mov	r3, r0
  108624:	e3530000 	cmp	r3, #0
  108628:	1a000002 	bne	108638 <sal_closesocket+0x98>
            {
                return -1;
            }
        }
#endif
        error = 0;
  10862c:	e3a03000 	mov	r3, #0
  108630:	e50b3008 	str	r3, [fp, #-8]
  108634:	ea000001 	b	108640 <sal_closesocket+0xa0>
    }
    else
    {
        error = -1;
  108638:	e3e03000 	mvn	r3, #0
  10863c:	e50b3008 	str	r3, [fp, #-8]
    }

    /* delete socket */
    socket_delete(socket);
  108640:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  108644:	ebfffcd7 	bl	1079a8 <socket_delete>

    return error;
  108648:	e51b3008 	ldr	r3, [fp, #-8]
}
  10864c:	e1a00003 	mov	r0, r3
  108650:	e24bd004 	sub	sp, fp, #4
  108654:	e8bd8800 	pop	{fp, pc}

00108658 <sal_ioctlsocket>:

int sal_ioctlsocket(int socket, long cmd, void *arg)
{
  108658:	e92d4800 	push	{fp, lr}
  10865c:	e28db004 	add	fp, sp, #4
  108660:	e24dd028 	sub	sp, sp, #40	; 0x28
  108664:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  108668:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  10866c:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
    struct sal_socket *sock;
    struct sal_proto_family *pf;
    struct sockaddr_in *addr_in = RT_NULL;
  108670:	e3a03000 	mov	r3, #0
  108674:	e50b3008 	str	r3, [fp, #-8]
    struct sockaddr *addr = RT_NULL;
  108678:	e3a03000 	mov	r3, #0
  10867c:	e50b300c 	str	r3, [fp, #-12]
    ip_addr_t input_ipaddr;
    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  108680:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  108684:	ebfffb1e 	bl	107304 <sal_get_socket>
  108688:	e50b0010 	str	r0, [fp, #-16]
  10868c:	e51b3010 	ldr	r3, [fp, #-16]
  108690:	e3530000 	cmp	r3, #0
  108694:	1a000001 	bne	1086a0 <sal_ioctlsocket+0x48>
  108698:	e3e03000 	mvn	r3, #0
  10869c:	ea000086 	b	1088bc <sal_ioctlsocket+0x264>
    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, ioctlsocket);
  1086a0:	e51b3010 	ldr	r3, [fp, #-16]
  1086a4:	e5933014 	ldr	r3, [r3, #20]
  1086a8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  1086ac:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1086b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1086b4:	e5933008 	ldr	r3, [r3, #8]
  1086b8:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  1086bc:	e3530000 	cmp	r3, #0
  1086c0:	1a000001 	bne	1086cc <sal_ioctlsocket+0x74>
  1086c4:	e3e03000 	mvn	r3, #0
  1086c8:	ea00007b 	b	1088bc <sal_ioctlsocket+0x264>

    struct sal_ifreq *ifr = (struct sal_ifreq *)arg;
  1086cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1086d0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    if((sock->domain == AF_INET)&&(sock->netdev)&&(ifr != RT_NULL))
  1086d4:	e51b3010 	ldr	r3, [fp, #-16]
  1086d8:	e5933008 	ldr	r3, [r3, #8]
  1086dc:	e3530002 	cmp	r3, #2
  1086e0:	1a000068 	bne	108888 <sal_ioctlsocket+0x230>
  1086e4:	e51b3010 	ldr	r3, [fp, #-16]
  1086e8:	e5933014 	ldr	r3, [r3, #20]
  1086ec:	e3530000 	cmp	r3, #0
  1086f0:	0a000064 	beq	108888 <sal_ioctlsocket+0x230>
  1086f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1086f8:	e3530000 	cmp	r3, #0
  1086fc:	0a000061 	beq	108888 <sal_ioctlsocket+0x230>
    {
        switch (cmd)
  108700:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  108704:	e2433c89 	sub	r3, r3, #35072	; 0x8900
  108708:	e2433015 	sub	r3, r3, #21
  10870c:	e3530012 	cmp	r3, #18
  108710:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  108714:	ea00005d 	b	108890 <sal_ioctlsocket+0x238>
  108718:	00108764 	.word	0x00108764
  10871c:	0010878c 	.word	0x0010878c
  108720:	00108890 	.word	0x00108890
  108724:	00108890 	.word	0x00108890
  108728:	00108890 	.word	0x00108890
  10872c:	00108890 	.word	0x00108890
  108730:	001087c8 	.word	0x001087c8
  108734:	001087f0 	.word	0x001087f0
  108738:	00108890 	.word	0x00108890
  10873c:	00108890 	.word	0x00108890
  108740:	00108890 	.word	0x00108890
  108744:	00108890 	.word	0x00108890
  108748:	00108868 	.word	0x00108868
  10874c:	00108890 	.word	0x00108890
  108750:	00108890 	.word	0x00108890
  108754:	00108890 	.word	0x00108890
  108758:	00108890 	.word	0x00108890
  10875c:	00108890 	.word	0x00108890
  108760:	0010882c 	.word	0x0010882c
        {
        case SIOCGIFADDR:
            addr_in = (struct sockaddr_in *)&(ifr->ifr_ifru.ifru_addr);
  108764:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  108768:	e2833010 	add	r3, r3, #16
  10876c:	e50b3008 	str	r3, [fp, #-8]
#if NETDEV_IPV4 && NETDEV_IPV6
            addr_in->sin_addr.s_addr = sock->netdev->ip_addr.u_addr.ip4.addr;
#elif NETDEV_IPV4
            addr_in->sin_addr.s_addr = sock->netdev->ip_addr.addr;
  108770:	e51b3010 	ldr	r3, [fp, #-16]
  108774:	e5933014 	ldr	r3, [r3, #20]
  108778:	e593200c 	ldr	r2, [r3, #12]
  10877c:	e51b3008 	ldr	r3, [fp, #-8]
  108780:	e5832004 	str	r2, [r3, #4]
#elif NETDEV_IPV6
#error "not only support IPV6"
#endif /* NETDEV_IPV4 && NETDEV_IPV6*/
            return 0;
  108784:	e3a03000 	mov	r3, #0
  108788:	ea00004b 	b	1088bc <sal_ioctlsocket+0x264>

        case SIOCSIFADDR:
            addr = (struct sockaddr *)&(ifr->ifr_ifru.ifru_addr);
  10878c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  108790:	e2833010 	add	r3, r3, #16
  108794:	e50b300c 	str	r3, [fp, #-12]
            sal_sockaddr_to_ipaddr(addr,&input_ipaddr);
  108798:	e24b301c 	sub	r3, fp, #28
  10879c:	e1a01003 	mov	r1, r3
  1087a0:	e51b000c 	ldr	r0, [fp, #-12]
  1087a4:	ebfffd17 	bl	107c08 <sal_sockaddr_to_ipaddr>
            netdev_set_ipaddr(sock->netdev,&input_ipaddr);
  1087a8:	e51b3010 	ldr	r3, [fp, #-16]
  1087ac:	e5933014 	ldr	r3, [r3, #20]
  1087b0:	e24b201c 	sub	r2, fp, #28
  1087b4:	e1a01002 	mov	r1, r2
  1087b8:	e1a00003 	mov	r0, r3
  1087bc:	ebfff4ae 	bl	105a7c <netdev_set_ipaddr>
            return 0;    
  1087c0:	e3a03000 	mov	r3, #0
  1087c4:	ea00003c 	b	1088bc <sal_ioctlsocket+0x264>

        case SIOCGIFNETMASK:
            addr_in = (struct sockaddr_in *)&(ifr->ifr_ifru.ifru_netmask);
  1087c8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1087cc:	e2833010 	add	r3, r3, #16
  1087d0:	e50b3008 	str	r3, [fp, #-8]
#if NETDEV_IPV4 && NETDEV_IPV6
            addr_in->sin_addr.s_addr = sock->netdev->netmask.u_addr.ip4.addr;
#elif NETDEV_IPV4
            addr_in->sin_addr.s_addr = sock->netdev->netmask.addr;
  1087d4:	e51b3010 	ldr	r3, [fp, #-16]
  1087d8:	e5933014 	ldr	r3, [r3, #20]
  1087dc:	e5932010 	ldr	r2, [r3, #16]
  1087e0:	e51b3008 	ldr	r3, [fp, #-8]
  1087e4:	e5832004 	str	r2, [r3, #4]
#elif NETDEV_IPV6
#error "not only support IPV6"
#endif /* NETDEV_IPV4 && NETDEV_IPV6*/
            return 0;
  1087e8:	e3a03000 	mov	r3, #0
  1087ec:	ea000032 	b	1088bc <sal_ioctlsocket+0x264>

        case SIOCSIFNETMASK:
            addr = (struct sockaddr *)&(ifr->ifr_ifru.ifru_netmask);
  1087f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1087f4:	e2833010 	add	r3, r3, #16
  1087f8:	e50b300c 	str	r3, [fp, #-12]
            sal_sockaddr_to_ipaddr(addr,&input_ipaddr);
  1087fc:	e24b301c 	sub	r3, fp, #28
  108800:	e1a01003 	mov	r1, r3
  108804:	e51b000c 	ldr	r0, [fp, #-12]
  108808:	ebfffcfe 	bl	107c08 <sal_sockaddr_to_ipaddr>
            netdev_set_netmask(sock->netdev,&input_ipaddr);
  10880c:	e51b3010 	ldr	r3, [fp, #-16]
  108810:	e5933014 	ldr	r3, [r3, #20]
  108814:	e24b201c 	sub	r2, fp, #28
  108818:	e1a01002 	mov	r1, r2
  10881c:	e1a00003 	mov	r0, r3
  108820:	ebfff4e4 	bl	105bb8 <netdev_set_netmask>
            return 0;            
  108824:	e3a03000 	mov	r3, #0
  108828:	ea000023 	b	1088bc <sal_ioctlsocket+0x264>

        case SIOCGIFHWADDR:
            addr = (struct sockaddr *)&(ifr->ifr_ifru.ifru_hwaddr);
  10882c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  108830:	e2833010 	add	r3, r3, #16
  108834:	e50b300c 	str	r3, [fp, #-12]
            rt_memcpy(addr->sa_data,sock->netdev->hwaddr,sock->netdev->hwaddr_len);
  108838:	e51b300c 	ldr	r3, [fp, #-12]
  10883c:	e2830002 	add	r0, r3, #2
  108840:	e51b3010 	ldr	r3, [fp, #-16]
  108844:	e5933014 	ldr	r3, [r3, #20]
  108848:	e2831021 	add	r1, r3, #33	; 0x21
  10884c:	e51b3010 	ldr	r3, [fp, #-16]
  108850:	e5933014 	ldr	r3, [r3, #20]
  108854:	e5d33020 	ldrb	r3, [r3, #32]
  108858:	e1a02003 	mov	r2, r3
  10885c:	ebffeaa7 	bl	103300 <rt_memcpy>
            return 0;
  108860:	e3a03000 	mov	r3, #0
  108864:	ea000014 	b	1088bc <sal_ioctlsocket+0x264>

        case SIOCGIFMTU:
            ifr->ifr_ifru.ifru_mtu = sock->netdev->mtu;
  108868:	e51b3010 	ldr	r3, [fp, #-16]
  10886c:	e5933014 	ldr	r3, [r3, #20]
  108870:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  108874:	e1a02003 	mov	r2, r3
  108878:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10887c:	e5832010 	str	r2, [r3, #16]
            return 0;            
  108880:	e3a03000 	mov	r3, #0
  108884:	ea00000c 	b	1088bc <sal_ioctlsocket+0x264>

        default:
            break;
        }
    }
  108888:	e320f000 	nop	{0}
  10888c:	ea000000 	b	108894 <sal_ioctlsocket+0x23c>
            break;
  108890:	e320f000 	nop	{0}
    return pf->skt_ops->ioctlsocket((int)(size_t)sock->user_data, cmd, arg);
  108894:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108898:	e5933008 	ldr	r3, [r3, #8]
  10889c:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  1088a0:	e51b2010 	ldr	r2, [fp, #-16]
  1088a4:	e5922018 	ldr	r2, [r2, #24]
  1088a8:	e1a00002 	mov	r0, r2
  1088ac:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  1088b0:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  1088b4:	e12fff33 	blx	r3
  1088b8:	e1a03000 	mov	r3, r0
}
  1088bc:	e1a00003 	mov	r0, r3
  1088c0:	e24bd004 	sub	sp, fp, #4
  1088c4:	e8bd8800 	pop	{fp, pc}

001088c8 <sal_poll>:

#ifdef SAL_USING_POSIX
int sal_poll(struct dfs_fd *file, struct rt_pollreq *req)
{
  1088c8:	e92d4800 	push	{fp, lr}
  1088cc:	e28db004 	add	fp, sp, #4
  1088d0:	e24dd018 	sub	sp, sp, #24
  1088d4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1088d8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    struct sal_socket *sock;
    struct sal_proto_family *pf;
    int socket = (int)(size_t)file->fnode->data;
  1088dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1088e0:	e5933018 	ldr	r3, [r3, #24]
  1088e4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  1088e8:	e50b3008 	str	r3, [fp, #-8]

    /* get the socket object by socket descriptor */
    SAL_SOCKET_OBJ_GET(sock, socket);
  1088ec:	e51b0008 	ldr	r0, [fp, #-8]
  1088f0:	ebfffa83 	bl	107304 <sal_get_socket>
  1088f4:	e50b000c 	str	r0, [fp, #-12]
  1088f8:	e51b300c 	ldr	r3, [fp, #-12]
  1088fc:	e3530000 	cmp	r3, #0
  108900:	1a000001 	bne	10890c <sal_poll+0x44>
  108904:	e3e03000 	mvn	r3, #0
  108908:	ea000019 	b	108974 <sal_poll+0xac>

    /* check the network interface is up status  */
    SAL_NETDEV_IS_UP(sock->netdev);
  10890c:	e51b300c 	ldr	r3, [fp, #-12]
  108910:	e5933014 	ldr	r3, [r3, #20]
  108914:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  108918:	e2033001 	and	r3, r3, #1
  10891c:	e3530000 	cmp	r3, #0
  108920:	1a000001 	bne	10892c <sal_poll+0x64>
  108924:	e3e03000 	mvn	r3, #0
  108928:	ea000011 	b	108974 <sal_poll+0xac>
    /* check the network interface socket opreation */
    SAL_NETDEV_SOCKETOPS_VALID(sock->netdev, pf, poll);
  10892c:	e51b300c 	ldr	r3, [fp, #-12]
  108930:	e5933014 	ldr	r3, [r3, #20]
  108934:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108938:	e50b3010 	str	r3, [fp, #-16]
  10893c:	e51b3010 	ldr	r3, [fp, #-16]
  108940:	e5933008 	ldr	r3, [r3, #8]
  108944:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  108948:	e3530000 	cmp	r3, #0
  10894c:	1a000001 	bne	108958 <sal_poll+0x90>
  108950:	e3e03000 	mvn	r3, #0
  108954:	ea000006 	b	108974 <sal_poll+0xac>

    return pf->skt_ops->poll(file, req);
  108958:	e51b3010 	ldr	r3, [fp, #-16]
  10895c:	e5933008 	ldr	r3, [r3, #8]
  108960:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  108964:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  108968:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  10896c:	e12fff33 	blx	r3
  108970:	e1a03000 	mov	r3, r0
}
  108974:	e1a00003 	mov	r0, r3
  108978:	e24bd004 	sub	sp, fp, #4
  10897c:	e8bd8800 	pop	{fp, pc}

00108980 <sal_gethostbyname>:
#endif

struct hostent *sal_gethostbyname(const char *name)
{
  108980:	e92d4800 	push	{fp, lr}
  108984:	e28db004 	add	fp, sp, #4
  108988:	e24dd010 	sub	sp, sp, #16
  10898c:	e50b0010 	str	r0, [fp, #-16]
    struct netdev *netdev = netdev_default;
  108990:	e3003564 	movw	r3, #1380	; 0x564
  108994:	e3403015 	movt	r3, #21
  108998:	e5933000 	ldr	r3, [r3]
  10899c:	e50b3008 	str	r3, [fp, #-8]
    struct sal_proto_family *pf;

    if (SAL_NETDEV_NETDBOPS_VALID(netdev, pf, gethostbyname))
  1089a0:	e51b3008 	ldr	r3, [fp, #-8]
  1089a4:	e3530000 	cmp	r3, #0
  1089a8:	0a000017 	beq	108a0c <sal_gethostbyname+0x8c>
  1089ac:	e51b3008 	ldr	r3, [fp, #-8]
  1089b0:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  1089b4:	e2033001 	and	r3, r3, #1
  1089b8:	e6ef3073 	uxtb	r3, r3
  1089bc:	e3530000 	cmp	r3, #0
  1089c0:	0a000011 	beq	108a0c <sal_gethostbyname+0x8c>
  1089c4:	e51b3008 	ldr	r3, [fp, #-8]
  1089c8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  1089cc:	e50b300c 	str	r3, [fp, #-12]
  1089d0:	e51b300c 	ldr	r3, [fp, #-12]
  1089d4:	e3530000 	cmp	r3, #0
  1089d8:	0a00000b 	beq	108a0c <sal_gethostbyname+0x8c>
  1089dc:	e51b300c 	ldr	r3, [fp, #-12]
  1089e0:	e593300c 	ldr	r3, [r3, #12]
  1089e4:	e5933000 	ldr	r3, [r3]
  1089e8:	e3530000 	cmp	r3, #0
  1089ec:	0a000006 	beq	108a0c <sal_gethostbyname+0x8c>
    {
        return pf->netdb_ops->gethostbyname(name);
  1089f0:	e51b300c 	ldr	r3, [fp, #-12]
  1089f4:	e593300c 	ldr	r3, [r3, #12]
  1089f8:	e5933000 	ldr	r3, [r3]
  1089fc:	e51b0010 	ldr	r0, [fp, #-16]
  108a00:	e12fff33 	blx	r3
  108a04:	e1a03000 	mov	r3, r0
  108a08:	ea00001e 	b	108a88 <sal_gethostbyname+0x108>
    }
    else
    {
        /* get the first network interface device with up status */
        netdev = netdev_get_first_by_flags(NETDEV_FLAG_UP);
  108a0c:	e3a00001 	mov	r0, #1
  108a10:	ebfff265 	bl	1053ac <netdev_get_first_by_flags>
  108a14:	e50b0008 	str	r0, [fp, #-8]
        if (SAL_NETDEV_NETDBOPS_VALID(netdev, pf, gethostbyname))
  108a18:	e51b3008 	ldr	r3, [fp, #-8]
  108a1c:	e3530000 	cmp	r3, #0
  108a20:	0a000017 	beq	108a84 <sal_gethostbyname+0x104>
  108a24:	e51b3008 	ldr	r3, [fp, #-8]
  108a28:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  108a2c:	e2033001 	and	r3, r3, #1
  108a30:	e6ef3073 	uxtb	r3, r3
  108a34:	e3530000 	cmp	r3, #0
  108a38:	0a000011 	beq	108a84 <sal_gethostbyname+0x104>
  108a3c:	e51b3008 	ldr	r3, [fp, #-8]
  108a40:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108a44:	e50b300c 	str	r3, [fp, #-12]
  108a48:	e51b300c 	ldr	r3, [fp, #-12]
  108a4c:	e3530000 	cmp	r3, #0
  108a50:	0a00000b 	beq	108a84 <sal_gethostbyname+0x104>
  108a54:	e51b300c 	ldr	r3, [fp, #-12]
  108a58:	e593300c 	ldr	r3, [r3, #12]
  108a5c:	e5933000 	ldr	r3, [r3]
  108a60:	e3530000 	cmp	r3, #0
  108a64:	0a000006 	beq	108a84 <sal_gethostbyname+0x104>
        {
            return pf->netdb_ops->gethostbyname(name);
  108a68:	e51b300c 	ldr	r3, [fp, #-12]
  108a6c:	e593300c 	ldr	r3, [r3, #12]
  108a70:	e5933000 	ldr	r3, [r3]
  108a74:	e51b0010 	ldr	r0, [fp, #-16]
  108a78:	e12fff33 	blx	r3
  108a7c:	e1a03000 	mov	r3, r0
  108a80:	ea000000 	b	108a88 <sal_gethostbyname+0x108>
        }
    }

    return RT_NULL;
  108a84:	e3a03000 	mov	r3, #0
}
  108a88:	e1a00003 	mov	r0, r3
  108a8c:	e24bd004 	sub	sp, fp, #4
  108a90:	e8bd8800 	pop	{fp, pc}

00108a94 <sal_gethostbyname_r>:

int sal_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
                        size_t buflen, struct hostent **result, int *h_errnop)
{
  108a94:	e92d4810 	push	{r4, fp, lr}
  108a98:	e28db008 	add	fp, sp, #8
  108a9c:	e24dd024 	sub	sp, sp, #36	; 0x24
  108aa0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  108aa4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  108aa8:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  108aac:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    struct netdev *netdev = netdev_default;
  108ab0:	e3003564 	movw	r3, #1380	; 0x564
  108ab4:	e3403015 	movt	r3, #21
  108ab8:	e5933000 	ldr	r3, [r3]
  108abc:	e50b3010 	str	r3, [fp, #-16]
    struct sal_proto_family *pf;

    if (SAL_NETDEV_NETDBOPS_VALID(netdev, pf, gethostbyname_r))
  108ac0:	e51b3010 	ldr	r3, [fp, #-16]
  108ac4:	e3530000 	cmp	r3, #0
  108ac8:	0a00001e 	beq	108b48 <sal_gethostbyname_r+0xb4>
  108acc:	e51b3010 	ldr	r3, [fp, #-16]
  108ad0:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  108ad4:	e2033001 	and	r3, r3, #1
  108ad8:	e6ef3073 	uxtb	r3, r3
  108adc:	e3530000 	cmp	r3, #0
  108ae0:	0a000018 	beq	108b48 <sal_gethostbyname_r+0xb4>
  108ae4:	e51b3010 	ldr	r3, [fp, #-16]
  108ae8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108aec:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  108af0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108af4:	e3530000 	cmp	r3, #0
  108af8:	0a000012 	beq	108b48 <sal_gethostbyname_r+0xb4>
  108afc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108b00:	e593300c 	ldr	r3, [r3, #12]
  108b04:	e5933004 	ldr	r3, [r3, #4]
  108b08:	e3530000 	cmp	r3, #0
  108b0c:	0a00000d 	beq	108b48 <sal_gethostbyname_r+0xb4>
    {
        return pf->netdb_ops->gethostbyname_r(name, ret, buf, buflen, result, h_errnop);
  108b10:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108b14:	e593300c 	ldr	r3, [r3, #12]
  108b18:	e5934004 	ldr	r4, [r3, #4]
  108b1c:	e59b3008 	ldr	r3, [fp, #8]
  108b20:	e58d3004 	str	r3, [sp, #4]
  108b24:	e59b3004 	ldr	r3, [fp, #4]
  108b28:	e58d3000 	str	r3, [sp]
  108b2c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  108b30:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  108b34:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  108b38:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  108b3c:	e12fff34 	blx	r4
  108b40:	e1a03000 	mov	r3, r0
  108b44:	ea000025 	b	108be0 <sal_gethostbyname_r+0x14c>
    }
    else
    {
        /* get the first network interface device with up status */
        netdev = netdev_get_first_by_flags(NETDEV_FLAG_UP);
  108b48:	e3a00001 	mov	r0, #1
  108b4c:	ebfff216 	bl	1053ac <netdev_get_first_by_flags>
  108b50:	e50b0010 	str	r0, [fp, #-16]
        if (SAL_NETDEV_NETDBOPS_VALID(netdev, pf, gethostbyname_r))
  108b54:	e51b3010 	ldr	r3, [fp, #-16]
  108b58:	e3530000 	cmp	r3, #0
  108b5c:	0a00001e 	beq	108bdc <sal_gethostbyname_r+0x148>
  108b60:	e51b3010 	ldr	r3, [fp, #-16]
  108b64:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  108b68:	e2033001 	and	r3, r3, #1
  108b6c:	e6ef3073 	uxtb	r3, r3
  108b70:	e3530000 	cmp	r3, #0
  108b74:	0a000018 	beq	108bdc <sal_gethostbyname_r+0x148>
  108b78:	e51b3010 	ldr	r3, [fp, #-16]
  108b7c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108b80:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  108b84:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108b88:	e3530000 	cmp	r3, #0
  108b8c:	0a000012 	beq	108bdc <sal_gethostbyname_r+0x148>
  108b90:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108b94:	e593300c 	ldr	r3, [r3, #12]
  108b98:	e5933004 	ldr	r3, [r3, #4]
  108b9c:	e3530000 	cmp	r3, #0
  108ba0:	0a00000d 	beq	108bdc <sal_gethostbyname_r+0x148>
        {
            return pf->netdb_ops->gethostbyname_r(name, ret, buf, buflen, result, h_errnop);
  108ba4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108ba8:	e593300c 	ldr	r3, [r3, #12]
  108bac:	e5934004 	ldr	r4, [r3, #4]
  108bb0:	e59b3008 	ldr	r3, [fp, #8]
  108bb4:	e58d3004 	str	r3, [sp, #4]
  108bb8:	e59b3004 	ldr	r3, [fp, #4]
  108bbc:	e58d3000 	str	r3, [sp]
  108bc0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  108bc4:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  108bc8:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  108bcc:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  108bd0:	e12fff34 	blx	r4
  108bd4:	e1a03000 	mov	r3, r0
  108bd8:	ea000000 	b	108be0 <sal_gethostbyname_r+0x14c>
        }
    }

    return -1;
  108bdc:	e3e03000 	mvn	r3, #0
}
  108be0:	e1a00003 	mov	r0, r3
  108be4:	e24bd008 	sub	sp, fp, #8
  108be8:	e8bd8810 	pop	{r4, fp, pc}

00108bec <sal_getaddrinfo>:

int sal_getaddrinfo(const char *nodename,
                    const char *servname,
                    const struct addrinfo *hints,
                    struct addrinfo **res)
{
  108bec:	e92d4810 	push	{r4, fp, lr}
  108bf0:	e28db008 	add	fp, sp, #8
  108bf4:	e24dd01c 	sub	sp, sp, #28
  108bf8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  108bfc:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  108c00:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  108c04:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    struct netdev *netdev = netdev_default;
  108c08:	e3003564 	movw	r3, #1380	; 0x564
  108c0c:	e3403015 	movt	r3, #21
  108c10:	e5933000 	ldr	r3, [r3]
  108c14:	e50b3010 	str	r3, [fp, #-16]
    struct sal_proto_family *pf;

    if (SAL_NETDEV_NETDBOPS_VALID(netdev, pf, getaddrinfo))
  108c18:	e51b3010 	ldr	r3, [fp, #-16]
  108c1c:	e3530000 	cmp	r3, #0
  108c20:	0a00001a 	beq	108c90 <sal_getaddrinfo+0xa4>
  108c24:	e51b3010 	ldr	r3, [fp, #-16]
  108c28:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  108c2c:	e2033001 	and	r3, r3, #1
  108c30:	e6ef3073 	uxtb	r3, r3
  108c34:	e3530000 	cmp	r3, #0
  108c38:	0a000014 	beq	108c90 <sal_getaddrinfo+0xa4>
  108c3c:	e51b3010 	ldr	r3, [fp, #-16]
  108c40:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108c44:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  108c48:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108c4c:	e3530000 	cmp	r3, #0
  108c50:	0a00000e 	beq	108c90 <sal_getaddrinfo+0xa4>
  108c54:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108c58:	e593300c 	ldr	r3, [r3, #12]
  108c5c:	e5933008 	ldr	r3, [r3, #8]
  108c60:	e3530000 	cmp	r3, #0
  108c64:	0a000009 	beq	108c90 <sal_getaddrinfo+0xa4>
    {
        return pf->netdb_ops->getaddrinfo(nodename, servname, hints, res);
  108c68:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108c6c:	e593300c 	ldr	r3, [r3, #12]
  108c70:	e5934008 	ldr	r4, [r3, #8]
  108c74:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  108c78:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  108c7c:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  108c80:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  108c84:	e12fff34 	blx	r4
  108c88:	e1a03000 	mov	r3, r0
  108c8c:	ea000021 	b	108d18 <sal_getaddrinfo+0x12c>
    }
    else
    {
        /* get the first network interface device with up status */
        netdev = netdev_get_first_by_flags(NETDEV_FLAG_UP);
  108c90:	e3a00001 	mov	r0, #1
  108c94:	ebfff1c4 	bl	1053ac <netdev_get_first_by_flags>
  108c98:	e50b0010 	str	r0, [fp, #-16]
        if (SAL_NETDEV_NETDBOPS_VALID(netdev, pf, getaddrinfo))
  108c9c:	e51b3010 	ldr	r3, [fp, #-16]
  108ca0:	e3530000 	cmp	r3, #0
  108ca4:	0a00001a 	beq	108d14 <sal_getaddrinfo+0x128>
  108ca8:	e51b3010 	ldr	r3, [fp, #-16]
  108cac:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  108cb0:	e2033001 	and	r3, r3, #1
  108cb4:	e6ef3073 	uxtb	r3, r3
  108cb8:	e3530000 	cmp	r3, #0
  108cbc:	0a000014 	beq	108d14 <sal_getaddrinfo+0x128>
  108cc0:	e51b3010 	ldr	r3, [fp, #-16]
  108cc4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108cc8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  108ccc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108cd0:	e3530000 	cmp	r3, #0
  108cd4:	0a00000e 	beq	108d14 <sal_getaddrinfo+0x128>
  108cd8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108cdc:	e593300c 	ldr	r3, [r3, #12]
  108ce0:	e5933008 	ldr	r3, [r3, #8]
  108ce4:	e3530000 	cmp	r3, #0
  108ce8:	0a000009 	beq	108d14 <sal_getaddrinfo+0x128>
        {
            return pf->netdb_ops->getaddrinfo(nodename, servname, hints, res);
  108cec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108cf0:	e593300c 	ldr	r3, [r3, #12]
  108cf4:	e5934008 	ldr	r4, [r3, #8]
  108cf8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  108cfc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  108d00:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  108d04:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  108d08:	e12fff34 	blx	r4
  108d0c:	e1a03000 	mov	r3, r0
  108d10:	ea000000 	b	108d18 <sal_getaddrinfo+0x12c>
        }
    }

    return -1;
  108d14:	e3e03000 	mvn	r3, #0
}
  108d18:	e1a00003 	mov	r0, r3
  108d1c:	e24bd008 	sub	sp, fp, #8
  108d20:	e8bd8810 	pop	{r4, fp, pc}

00108d24 <sal_freeaddrinfo>:

void sal_freeaddrinfo(struct addrinfo *ai)
{
  108d24:	e92d4800 	push	{fp, lr}
  108d28:	e28db004 	add	fp, sp, #4
  108d2c:	e24dd010 	sub	sp, sp, #16
  108d30:	e50b0010 	str	r0, [fp, #-16]
    struct netdev *netdev = netdev_default;
  108d34:	e3003564 	movw	r3, #1380	; 0x564
  108d38:	e3403015 	movt	r3, #21
  108d3c:	e5933000 	ldr	r3, [r3]
  108d40:	e50b3008 	str	r3, [fp, #-8]
    struct sal_proto_family *pf;

    if (SAL_NETDEV_NETDBOPS_VALID(netdev, pf, freeaddrinfo))
  108d44:	e51b3008 	ldr	r3, [fp, #-8]
  108d48:	e3530000 	cmp	r3, #0
  108d4c:	0a000016 	beq	108dac <sal_freeaddrinfo+0x88>
  108d50:	e51b3008 	ldr	r3, [fp, #-8]
  108d54:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  108d58:	e2033001 	and	r3, r3, #1
  108d5c:	e6ef3073 	uxtb	r3, r3
  108d60:	e3530000 	cmp	r3, #0
  108d64:	0a000010 	beq	108dac <sal_freeaddrinfo+0x88>
  108d68:	e51b3008 	ldr	r3, [fp, #-8]
  108d6c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108d70:	e50b300c 	str	r3, [fp, #-12]
  108d74:	e51b300c 	ldr	r3, [fp, #-12]
  108d78:	e3530000 	cmp	r3, #0
  108d7c:	0a00000a 	beq	108dac <sal_freeaddrinfo+0x88>
  108d80:	e51b300c 	ldr	r3, [fp, #-12]
  108d84:	e593300c 	ldr	r3, [r3, #12]
  108d88:	e593300c 	ldr	r3, [r3, #12]
  108d8c:	e3530000 	cmp	r3, #0
  108d90:	0a000005 	beq	108dac <sal_freeaddrinfo+0x88>
    {
        pf->netdb_ops->freeaddrinfo(ai);
  108d94:	e51b300c 	ldr	r3, [fp, #-12]
  108d98:	e593300c 	ldr	r3, [r3, #12]
  108d9c:	e593300c 	ldr	r3, [r3, #12]
  108da0:	e51b0010 	ldr	r0, [fp, #-16]
  108da4:	e12fff33 	blx	r3
        if (SAL_NETDEV_NETDBOPS_VALID(netdev, pf, freeaddrinfo))
        {
            pf->netdb_ops->freeaddrinfo(ai);
        }
    }
}
  108da8:	ea00001b 	b	108e1c <sal_freeaddrinfo+0xf8>
        netdev = netdev_get_first_by_flags(NETDEV_FLAG_UP);
  108dac:	e3a00001 	mov	r0, #1
  108db0:	ebfff17d 	bl	1053ac <netdev_get_first_by_flags>
  108db4:	e50b0008 	str	r0, [fp, #-8]
        if (SAL_NETDEV_NETDBOPS_VALID(netdev, pf, freeaddrinfo))
  108db8:	e51b3008 	ldr	r3, [fp, #-8]
  108dbc:	e3530000 	cmp	r3, #0
  108dc0:	0a000015 	beq	108e1c <sal_freeaddrinfo+0xf8>
  108dc4:	e51b3008 	ldr	r3, [fp, #-8]
  108dc8:	e1d332ba 	ldrh	r3, [r3, #42]	; 0x2a
  108dcc:	e2033001 	and	r3, r3, #1
  108dd0:	e6ef3073 	uxtb	r3, r3
  108dd4:	e3530000 	cmp	r3, #0
  108dd8:	0a00000f 	beq	108e1c <sal_freeaddrinfo+0xf8>
  108ddc:	e51b3008 	ldr	r3, [fp, #-8]
  108de0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  108de4:	e50b300c 	str	r3, [fp, #-12]
  108de8:	e51b300c 	ldr	r3, [fp, #-12]
  108dec:	e3530000 	cmp	r3, #0
  108df0:	0a000009 	beq	108e1c <sal_freeaddrinfo+0xf8>
  108df4:	e51b300c 	ldr	r3, [fp, #-12]
  108df8:	e593300c 	ldr	r3, [r3, #12]
  108dfc:	e593300c 	ldr	r3, [r3, #12]
  108e00:	e3530000 	cmp	r3, #0
  108e04:	0a000004 	beq	108e1c <sal_freeaddrinfo+0xf8>
            pf->netdb_ops->freeaddrinfo(ai);
  108e08:	e51b300c 	ldr	r3, [fp, #-12]
  108e0c:	e593300c 	ldr	r3, [r3, #12]
  108e10:	e593300c 	ldr	r3, [r3, #12]
  108e14:	e51b0010 	ldr	r0, [fp, #-16]
  108e18:	e12fff33 	blx	r3
}
  108e1c:	e320f000 	nop	{0}
  108e20:	e24bd004 	sub	sp, fp, #4
  108e24:	e8bd8800 	pop	{fp, pc}

00108e28 <unet_socket>:
 * socket options. To solve the issue, we do it separately in 2 steps.
 */
#define INTF_SOCK_NONBLOCK  04000
#define IMPL_SOCK_NONBLOCK  1
int unet_socket(int domain, int type, int protocol)
{
  108e28:	e92d4800 	push	{fp, lr}
  108e2c:	e28db004 	add	fp, sp, #4
  108e30:	e24dd018 	sub	sp, sp, #24
  108e34:	e50b0010 	str	r0, [fp, #-16]
  108e38:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  108e3c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    int socket;

    /* filter-out socket options: SOCK_NONBLOCK & SOCK_CLOEXEC (not supported) */
    int flag = type & INTF_SOCK_NONBLOCK;
  108e40:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108e44:	e2033b02 	and	r3, r3, #2048	; 0x800
  108e48:	e50b3008 	str	r3, [fp, #-8]
    type &= ~INTF_SOCK_NONBLOCK;
  108e4c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  108e50:	e3c33b02 	bic	r3, r3, #2048	; 0x800
  108e54:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

    socket = lwip_socket(domain, type, protocol);
  108e58:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  108e5c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  108e60:	e51b0010 	ldr	r0, [fp, #-16]
  108e64:	eb00281f 	bl	112ee8 <lwip_socket>
  108e68:	e50b000c 	str	r0, [fp, #-12]
    // sock_wqueue_add((void*)get_socket(socket));

    /* handle the socket options */
    if (socket >= 0 && flag != 0)
  108e6c:	e51b300c 	ldr	r3, [fp, #-12]
  108e70:	e3530000 	cmp	r3, #0
  108e74:	ba000006 	blt	108e94 <unet_socket+0x6c>
  108e78:	e51b3008 	ldr	r3, [fp, #-8]
  108e7c:	e3530000 	cmp	r3, #0
  108e80:	0a000003 	beq	108e94 <unet_socket+0x6c>
        unet_fcntl(socket, F_SETFL, flag);
  108e84:	e51b2008 	ldr	r2, [fp, #-8]
  108e88:	e3a01004 	mov	r1, #4
  108e8c:	e51b000c 	ldr	r0, [fp, #-12]
  108e90:	eb0000e2 	bl	109220 <unet_fcntl>

    return socket;
  108e94:	e51b300c 	ldr	r3, [fp, #-12]
}
  108e98:	e1a00003 	mov	r0, r3
  108e9c:	e24bd004 	sub	sp, fp, #4
  108ea0:	e8bd8800 	pop	{fp, pc}

00108ea4 <unet_close>:

int unet_close(int socket)
{
  108ea4:	e92d4800 	push	{fp, lr}
  108ea8:	e28db004 	add	fp, sp, #4
  108eac:	e24dd010 	sub	sp, sp, #16
  108eb0:	e50b0010 	str	r0, [fp, #-16]
    int result = lwip_close(socket);
  108eb4:	e51b0010 	ldr	r0, [fp, #-16]
  108eb8:	eb0022f4 	bl	111a90 <lwip_close>
  108ebc:	e50b0008 	str	r0, [fp, #-8]
    // sock_wqueue_delete((void*)get_socket(socket));

    return result;
  108ec0:	e51b3008 	ldr	r3, [fp, #-8]
}
  108ec4:	e1a00003 	mov	r0, r3
  108ec8:	e24bd004 	sub	sp, fp, #4
  108ecc:	e8bd8800 	pop	{fp, pc}

00108ed0 <unet_bind>:

int unet_bind(int socket, const struct sockaddr *name, socklen_t namelen)
{
  108ed0:	e92d4800 	push	{fp, lr}
  108ed4:	e28db004 	add	fp, sp, #4
  108ed8:	e24dd010 	sub	sp, sp, #16
  108edc:	e50b0008 	str	r0, [fp, #-8]
  108ee0:	e50b100c 	str	r1, [fp, #-12]
  108ee4:	e50b2010 	str	r2, [fp, #-16]
    return lwip_bind(socket, name, namelen);
  108ee8:	e51b2010 	ldr	r2, [fp, #-16]
  108eec:	e51b100c 	ldr	r1, [fp, #-12]
  108ef0:	e51b0008 	ldr	r0, [fp, #-8]
  108ef4:	eb00227f 	bl	1118f8 <lwip_bind>
  108ef8:	e1a03000 	mov	r3, r0
}
  108efc:	e1a00003 	mov	r0, r3
  108f00:	e24bd004 	sub	sp, fp, #4
  108f04:	e8bd8800 	pop	{fp, pc}

00108f08 <unet_listen>:

int unet_listen(int socket, int backlog)
{
  108f08:	e92d4800 	push	{fp, lr}
  108f0c:	e28db004 	add	fp, sp, #4
  108f10:	e24dd008 	sub	sp, sp, #8
  108f14:	e50b0008 	str	r0, [fp, #-8]
  108f18:	e50b100c 	str	r1, [fp, #-12]
    return lwip_listen(socket, backlog);
  108f1c:	e51b100c 	ldr	r1, [fp, #-12]
  108f20:	e51b0008 	ldr	r0, [fp, #-8]
  108f24:	eb002398 	bl	111d8c <lwip_listen>
  108f28:	e1a03000 	mov	r3, r0
}
  108f2c:	e1a00003 	mov	r0, r3
  108f30:	e24bd004 	sub	sp, fp, #4
  108f34:	e8bd8800 	pop	{fp, pc}

00108f38 <unet_connect>:

int unet_connect(int socket, const struct sockaddr *name, socklen_t namelen)
{
  108f38:	e92d4800 	push	{fp, lr}
  108f3c:	e28db004 	add	fp, sp, #4
  108f40:	e24dd010 	sub	sp, sp, #16
  108f44:	e50b0008 	str	r0, [fp, #-8]
  108f48:	e50b100c 	str	r1, [fp, #-12]
  108f4c:	e50b2010 	str	r2, [fp, #-16]
    return lwip_connect(socket, name, namelen);
  108f50:	e51b2010 	ldr	r2, [fp, #-16]
  108f54:	e51b100c 	ldr	r1, [fp, #-12]
  108f58:	e51b0008 	ldr	r0, [fp, #-8]
  108f5c:	eb002315 	bl	111bb8 <lwip_connect>
  108f60:	e1a03000 	mov	r3, r0
}
  108f64:	e1a00003 	mov	r0, r3
  108f68:	e24bd004 	sub	sp, fp, #4
  108f6c:	e8bd8800 	pop	{fp, pc}

00108f70 <unet_accept>:

int unet_accept(int socket, struct sockaddr *addr, socklen_t *addrlen)
{
  108f70:	e92d4800 	push	{fp, lr}
  108f74:	e28db004 	add	fp, sp, #4
  108f78:	e24dd010 	sub	sp, sp, #16
  108f7c:	e50b0008 	str	r0, [fp, #-8]
  108f80:	e50b100c 	str	r1, [fp, #-12]
  108f84:	e50b2010 	str	r2, [fp, #-16]
    socket = lwip_accept(socket, addr, addrlen);
  108f88:	e51b2010 	ldr	r2, [fp, #-16]
  108f8c:	e51b100c 	ldr	r1, [fp, #-12]
  108f90:	e51b0008 	ldr	r0, [fp, #-8]
  108f94:	eb002149 	bl	1114c0 <lwip_accept>
  108f98:	e50b0008 	str	r0, [fp, #-8]
    // sock_wqueue_add((void*)get_socket(socket));

    return socket;
  108f9c:	e51b3008 	ldr	r3, [fp, #-8]
}
  108fa0:	e1a00003 	mov	r0, r3
  108fa4:	e24bd004 	sub	sp, fp, #4
  108fa8:	e8bd8800 	pop	{fp, pc}

00108fac <unet_sendto>:

int unet_sendto(int socket, const void *data, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)
{
  108fac:	e92d4800 	push	{fp, lr}
  108fb0:	e28db004 	add	fp, sp, #4
  108fb4:	e24dd020 	sub	sp, sp, #32
  108fb8:	e50b0010 	str	r0, [fp, #-16]
  108fbc:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  108fc0:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  108fc4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    int result;
    if(tolen  == 0)
  108fc8:	e59b3008 	ldr	r3, [fp, #8]
  108fcc:	e3530000 	cmp	r3, #0
  108fd0:	1a00000a 	bne	109000 <unet_sendto+0x54>
    {
        result = lwip_sendto(socket, data, size, flags, RT_NULL, RT_NULL);
  108fd4:	e3a03000 	mov	r3, #0
  108fd8:	e58d3004 	str	r3, [sp, #4]
  108fdc:	e3a03000 	mov	r3, #0
  108fe0:	e58d3000 	str	r3, [sp]
  108fe4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  108fe8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  108fec:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  108ff0:	e51b0010 	ldr	r0, [fp, #-16]
  108ff4:	eb002727 	bl	112c98 <lwip_sendto>
  108ff8:	e50b0008 	str	r0, [fp, #-8]
  108ffc:	ea000009 	b	109028 <unet_sendto+0x7c>
    }
    else
    {
        result = lwip_sendto(socket, data, size, flags, to, tolen);
  109000:	e59b3008 	ldr	r3, [fp, #8]
  109004:	e58d3004 	str	r3, [sp, #4]
  109008:	e59b3004 	ldr	r3, [fp, #4]
  10900c:	e58d3000 	str	r3, [sp]
  109010:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109014:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  109018:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10901c:	e51b0010 	ldr	r0, [fp, #-16]
  109020:	eb00271c 	bl	112c98 <lwip_sendto>
  109024:	e50b0008 	str	r0, [fp, #-8]
    }
    if(result <= 0)
  109028:	e51b3008 	ldr	r3, [fp, #-8]
  10902c:	e3530000 	cmp	r3, #0
  109030:	ca000005 	bgt	10904c <unet_sendto+0xa0>
    {
        rt_kprintf("%s line %d sendto error\n",__func__,__LINE__);
  109034:	e3a02058 	mov	r2, #88	; 0x58
  109038:	e30613b0 	movw	r1, #25520	; 0x63b0
  10903c:	e3401014 	movt	r1, #20
  109040:	e3060394 	movw	r0, #25492	; 0x6394
  109044:	e3400014 	movt	r0, #20
  109048:	ebffe831 	bl	103114 <rt_kprintf>
    }
    return result;
  10904c:	e51b3008 	ldr	r3, [fp, #-8]
}
  109050:	e1a00003 	mov	r0, r3
  109054:	e24bd004 	sub	sp, fp, #4
  109058:	e8bd8800 	pop	{fp, pc}

0010905c <unet_recvfrom>:

int unet_recvfrom(int socket, void *mem, size_t size, int flags, struct sockaddr *from, socklen_t *fromlen)
{
  10905c:	e92d4800 	push	{fp, lr}
  109060:	e28db004 	add	fp, sp, #4
  109064:	e24dd018 	sub	sp, sp, #24
  109068:	e50b0008 	str	r0, [fp, #-8]
  10906c:	e50b100c 	str	r1, [fp, #-12]
  109070:	e50b2010 	str	r2, [fp, #-16]
  109074:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    if(from && fromlen)
  109078:	e59b3004 	ldr	r3, [fp, #4]
  10907c:	e3530000 	cmp	r3, #0
  109080:	0a00000d 	beq	1090bc <unet_recvfrom+0x60>
  109084:	e59b3008 	ldr	r3, [fp, #8]
  109088:	e3530000 	cmp	r3, #0
  10908c:	0a00000a 	beq	1090bc <unet_recvfrom+0x60>
    {
        return lwip_recvfrom(socket, mem, size, flags, from, fromlen);
  109090:	e59b3008 	ldr	r3, [fp, #8]
  109094:	e58d3004 	str	r3, [sp, #4]
  109098:	e59b3004 	ldr	r3, [fp, #4]
  10909c:	e58d3000 	str	r3, [sp]
  1090a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1090a4:	e51b2010 	ldr	r2, [fp, #-16]
  1090a8:	e51b100c 	ldr	r1, [fp, #-12]
  1090ac:	e51b0008 	ldr	r0, [fp, #-8]
  1090b0:	eb00238d 	bl	111eec <lwip_recvfrom>
  1090b4:	e1a03000 	mov	r3, r0
  1090b8:	ea000009 	b	1090e4 <unet_recvfrom+0x88>
    }
    else
    {
        return lwip_recvfrom(socket, mem, size, flags, RT_NULL, RT_NULL);
  1090bc:	e3a03000 	mov	r3, #0
  1090c0:	e58d3004 	str	r3, [sp, #4]
  1090c4:	e3a03000 	mov	r3, #0
  1090c8:	e58d3000 	str	r3, [sp]
  1090cc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1090d0:	e51b2010 	ldr	r2, [fp, #-16]
  1090d4:	e51b100c 	ldr	r1, [fp, #-12]
  1090d8:	e51b0008 	ldr	r0, [fp, #-8]
  1090dc:	eb002382 	bl	111eec <lwip_recvfrom>
  1090e0:	e1a03000 	mov	r3, r0
    }
}
  1090e4:	e1a00003 	mov	r0, r3
  1090e8:	e24bd004 	sub	sp, fp, #4
  1090ec:	e8bd8800 	pop	{fp, pc}

001090f0 <unet_getsockopt>:

int unet_getsockopt(int socket, int level, int optname, void *optval, socklen_t *optlen)
{
  1090f0:	e92d4800 	push	{fp, lr}
  1090f4:	e28db004 	add	fp, sp, #4
  1090f8:	e24dd018 	sub	sp, sp, #24
  1090fc:	e50b0008 	str	r0, [fp, #-8]
  109100:	e50b100c 	str	r1, [fp, #-12]
  109104:	e50b2010 	str	r2, [fp, #-16]
  109108:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return lwip_getsockopt(socket, level, optname, optval, optlen);
  10910c:	e59b3004 	ldr	r3, [fp, #4]
  109110:	e58d3000 	str	r3, [sp]
  109114:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109118:	e51b2010 	ldr	r2, [fp, #-16]
  10911c:	e51b100c 	ldr	r1, [fp, #-12]
  109120:	e51b0008 	ldr	r0, [fp, #-8]
  109124:	eb002c85 	bl	114340 <lwip_getsockopt>
  109128:	e1a03000 	mov	r3, r0
}
  10912c:	e1a00003 	mov	r0, r3
  109130:	e24bd004 	sub	sp, fp, #4
  109134:	e8bd8800 	pop	{fp, pc}

00109138 <unet_setsockopt>:

int unet_setsockopt(int socket, int level, int optname, const void *optval, socklen_t optlen)
{
  109138:	e92d4800 	push	{fp, lr}
  10913c:	e28db004 	add	fp, sp, #4
  109140:	e24dd018 	sub	sp, sp, #24
  109144:	e50b0008 	str	r0, [fp, #-8]
  109148:	e50b100c 	str	r1, [fp, #-12]
  10914c:	e50b2010 	str	r2, [fp, #-16]
  109150:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return lwip_setsockopt(socket, level, optname, optval, optlen);
  109154:	e59b3004 	ldr	r3, [fp, #4]
  109158:	e58d3000 	str	r3, [sp]
  10915c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109160:	e51b2010 	ldr	r2, [fp, #-16]
  109164:	e51b100c 	ldr	r1, [fp, #-12]
  109168:	e51b0008 	ldr	r0, [fp, #-8]
  10916c:	eb002f3b 	bl	114e60 <lwip_setsockopt>
  109170:	e1a03000 	mov	r3, r0
}
  109174:	e1a00003 	mov	r0, r3
  109178:	e24bd004 	sub	sp, fp, #4
  10917c:	e8bd8800 	pop	{fp, pc}

00109180 <unet_shutdown>:

int unet_shutdown(int socket, int how)
{
  109180:	e92d4800 	push	{fp, lr}
  109184:	e28db004 	add	fp, sp, #4
  109188:	e24dd008 	sub	sp, sp, #8
  10918c:	e50b0008 	str	r0, [fp, #-8]
  109190:	e50b100c 	str	r1, [fp, #-12]
    return lwip_shutdown(socket, how);
  109194:	e51b100c 	ldr	r1, [fp, #-12]
  109198:	e51b0008 	ldr	r0, [fp, #-8]
  10919c:	eb002b6d 	bl	113f58 <lwip_shutdown>
  1091a0:	e1a03000 	mov	r3, r0
}
  1091a4:	e1a00003 	mov	r0, r3
  1091a8:	e24bd004 	sub	sp, fp, #4
  1091ac:	e8bd8800 	pop	{fp, pc}

001091b0 <unet_getpeername>:

int unet_getpeername(int socket, struct sockaddr *name, socklen_t *namelen)
{
  1091b0:	e92d4800 	push	{fp, lr}
  1091b4:	e28db004 	add	fp, sp, #4
  1091b8:	e24dd010 	sub	sp, sp, #16
  1091bc:	e50b0008 	str	r0, [fp, #-8]
  1091c0:	e50b100c 	str	r1, [fp, #-12]
  1091c4:	e50b2010 	str	r2, [fp, #-16]
    return lwip_getpeername(socket, name, namelen);
  1091c8:	e51b2010 	ldr	r2, [fp, #-16]
  1091cc:	e51b100c 	ldr	r1, [fp, #-12]
  1091d0:	e51b0008 	ldr	r0, [fp, #-8]
  1091d4:	eb002c3b 	bl	1142c8 <lwip_getpeername>
  1091d8:	e1a03000 	mov	r3, r0
}
  1091dc:	e1a00003 	mov	r0, r3
  1091e0:	e24bd004 	sub	sp, fp, #4
  1091e4:	e8bd8800 	pop	{fp, pc}

001091e8 <unet_getsockname>:

int unet_getsockname(int socket, struct sockaddr *name, socklen_t *namelen)
{
  1091e8:	e92d4800 	push	{fp, lr}
  1091ec:	e28db004 	add	fp, sp, #4
  1091f0:	e24dd010 	sub	sp, sp, #16
  1091f4:	e50b0008 	str	r0, [fp, #-8]
  1091f8:	e50b100c 	str	r1, [fp, #-12]
  1091fc:	e50b2010 	str	r2, [fp, #-16]
    return lwip_getsockname(socket, name, namelen);
  109200:	e51b2010 	ldr	r2, [fp, #-16]
  109204:	e51b100c 	ldr	r1, [fp, #-12]
  109208:	e51b0008 	ldr	r0, [fp, #-8]
  10920c:	eb002c3c 	bl	114304 <lwip_getsockname>
  109210:	e1a03000 	mov	r3, r0
}
  109214:	e1a00003 	mov	r0, r3
  109218:	e24bd004 	sub	sp, fp, #4
  10921c:	e8bd8800 	pop	{fp, pc}

00109220 <unet_fcntl>:

int unet_fcntl(int socket, int cmd, int val)
{
  109220:	e92d4800 	push	{fp, lr}
  109224:	e28db004 	add	fp, sp, #4
  109228:	e24dd010 	sub	sp, sp, #16
  10922c:	e50b0008 	str	r0, [fp, #-8]
  109230:	e50b100c 	str	r1, [fp, #-12]
  109234:	e50b2010 	str	r2, [fp, #-16]
    return lwip_fcntl(socket, cmd, val);
  109238:	e51b2010 	ldr	r2, [fp, #-16]
  10923c:	e51b100c 	ldr	r1, [fp, #-12]
  109240:	e51b0008 	ldr	r0, [fp, #-8]
  109244:	eb003251 	bl	115b90 <lwip_fcntl>
  109248:	e1a03000 	mov	r3, r0
}
  10924c:	e1a00003 	mov	r0, r3
  109250:	e24bd004 	sub	sp, fp, #4
  109254:	e8bd8800 	pop	{fp, pc}

00109258 <unet_ioctl>:

/* Observe the 'real' IOCTL operations in unet 'api/sockets.c' and find that
 * 'argp' is used as an integer pointer. */
int unet_ioctl(int socket, long cmd, void *argp)
{
  109258:	e92d4800 	push	{fp, lr}
  10925c:	e28db004 	add	fp, sp, #4
  109260:	e24dd010 	sub	sp, sp, #16
  109264:	e50b0008 	str	r0, [fp, #-8]
  109268:	e50b100c 	str	r1, [fp, #-12]
  10926c:	e50b2010 	str	r2, [fp, #-16]
    return lwip_ioctl(socket, cmd, argp);
  109270:	e51b2010 	ldr	r2, [fp, #-16]
  109274:	e51b100c 	ldr	r1, [fp, #-12]
  109278:	e51b0008 	ldr	r0, [fp, #-8]
  10927c:	eb00319c 	bl	1158f4 <lwip_ioctl>
  109280:	e1a03000 	mov	r3, r0
}
  109284:	e1a00003 	mov	r0, r3
  109288:	e24bd004 	sub	sp, fp, #4
  10928c:	e8bd8800 	pop	{fp, pc}

00109290 <unet_gethostbyname>:
#include <stdio.h>
struct hostent* unet_gethostbyname(const char *name)
{
  109290:	e92d4800 	push	{fp, lr}
  109294:	e28db004 	add	fp, sp, #4
  109298:	e24dd008 	sub	sp, sp, #8
  10929c:	e50b0008 	str	r0, [fp, #-8]
    static struct hostent s_hostent, *p_hostent = RT_NULL;
    static char *s_aliases;
    static ip_addr_t s_hostent_addr;
    static ip_addr_t *s_phostent_addr[2];
    static char s_hostname[DNS_MAX_NAME_LENGTH + 1];
    p_hostent = lwip_gethostbyname(name);
  1092a0:	e51b0008 	ldr	r0, [fp, #-8]
  1092a4:	eb001d00 	bl	1106ac <lwip_gethostbyname>
  1092a8:	e1a02000 	mov	r2, r0
  1092ac:	e30e3494 	movw	r3, #58516	; 0xe494
  1092b0:	e3403014 	movt	r3, #20
  1092b4:	e5832000 	str	r2, [r3]
    memset(&s_hostent, 0, sizeof(s_hostent));
  1092b8:	e3a02014 	mov	r2, #20
  1092bc:	e3a01000 	mov	r1, #0
  1092c0:	e30e0498 	movw	r0, #58520	; 0xe498
  1092c4:	e3400014 	movt	r0, #20
  1092c8:	eb00e069 	bl	141474 <memset>
    /* fill hostent */
    s_hostent_addr = *((ip_addr_t *) p_hostent->h_addr);
  1092cc:	e30e3494 	movw	r3, #58516	; 0xe494
  1092d0:	e3403014 	movt	r3, #20
  1092d4:	e5933000 	ldr	r3, [r3]
  1092d8:	e5933010 	ldr	r3, [r3, #16]
  1092dc:	e5932000 	ldr	r2, [r3]
  1092e0:	e30e34ac 	movw	r3, #58540	; 0xe4ac
  1092e4:	e3403014 	movt	r3, #20
  1092e8:	e5922000 	ldr	r2, [r2]
  1092ec:	e5832000 	str	r2, [r3]
    s_phostent_addr[0] = &s_hostent_addr;
  1092f0:	e30e34b0 	movw	r3, #58544	; 0xe4b0
  1092f4:	e3403014 	movt	r3, #20
  1092f8:	e30e24ac 	movw	r2, #58540	; 0xe4ac
  1092fc:	e3402014 	movt	r2, #20
  109300:	e5832000 	str	r2, [r3]
    s_phostent_addr[1] = NULL;
  109304:	e30e34b0 	movw	r3, #58544	; 0xe4b0
  109308:	e3403014 	movt	r3, #20
  10930c:	e3a02000 	mov	r2, #0
  109310:	e5832004 	str	r2, [r3, #4]
    strncpy(s_hostname, name, DNS_MAX_NAME_LENGTH);
  109314:	e3a02c01 	mov	r2, #256	; 0x100
  109318:	e51b1008 	ldr	r1, [fp, #-8]
  10931c:	e30e04b8 	movw	r0, #58552	; 0xe4b8
  109320:	e3400014 	movt	r0, #20
  109324:	eb00e134 	bl	1417fc <strncpy>
    s_hostname[DNS_MAX_NAME_LENGTH] = 0;
  109328:	e30e34b8 	movw	r3, #58552	; 0xe4b8
  10932c:	e3403014 	movt	r3, #20
  109330:	e3a02000 	mov	r2, #0
  109334:	e5c32100 	strb	r2, [r3, #256]	; 0x100
    s_hostent.h_name = s_hostname;
  109338:	e30e3498 	movw	r3, #58520	; 0xe498
  10933c:	e3403014 	movt	r3, #20
  109340:	e30e24b8 	movw	r2, #58552	; 0xe4b8
  109344:	e3402014 	movt	r2, #20
  109348:	e5832000 	str	r2, [r3]
    s_aliases = NULL;
  10934c:	e30e35bc 	movw	r3, #58812	; 0xe5bc
  109350:	e3403014 	movt	r3, #20
  109354:	e3a02000 	mov	r2, #0
  109358:	e5832000 	str	r2, [r3]
    s_hostent.h_aliases = &s_aliases;
  10935c:	e30e3498 	movw	r3, #58520	; 0xe498
  109360:	e3403014 	movt	r3, #20
  109364:	e30e25bc 	movw	r2, #58812	; 0xe5bc
  109368:	e3402014 	movt	r2, #20
  10936c:	e5832004 	str	r2, [r3, #4]
    s_hostent.h_addrtype = AF_INET;
  109370:	e30e3498 	movw	r3, #58520	; 0xe498
  109374:	e3403014 	movt	r3, #20
  109378:	e3a02002 	mov	r2, #2
  10937c:	e5832008 	str	r2, [r3, #8]
    s_hostent.h_length = sizeof(ip_addr_t);
  109380:	e30e3498 	movw	r3, #58520	; 0xe498
  109384:	e3403014 	movt	r3, #20
  109388:	e3a02004 	mov	r2, #4
  10938c:	e583200c 	str	r2, [r3, #12]
    s_hostent.h_addr_list = (char**)&s_phostent_addr;
  109390:	e30e3498 	movw	r3, #58520	; 0xe498
  109394:	e3403014 	movt	r3, #20
  109398:	e30e24b0 	movw	r2, #58544	; 0xe4b0
  10939c:	e3402014 	movt	r2, #20
  1093a0:	e5832010 	str	r2, [r3, #16]
    p_hostent = &s_hostent;
  1093a4:	e30e3494 	movw	r3, #58516	; 0xe494
  1093a8:	e3403014 	movt	r3, #20
  1093ac:	e30e2498 	movw	r2, #58520	; 0xe498
  1093b0:	e3402014 	movt	r2, #20
  1093b4:	e5832000 	str	r2, [r3]

    return p_hostent;
  1093b8:	e30e3494 	movw	r3, #58516	; 0xe494
  1093bc:	e3403014 	movt	r3, #20
  1093c0:	e5933000 	ldr	r3, [r3]
}
  1093c4:	e1a00003 	mov	r0, r3
  1093c8:	e24bd004 	sub	sp, fp, #4
  1093cc:	e8bd8800 	pop	{fp, pc}

001093d0 <unet_gethostbyname_r>:

int unet_gethostbyname_r(const char *name, struct hostent *ret, char *buf, size_t buflen, struct hostent **result, int *h_errnop)
{
  1093d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1093d4:	e28db000 	add	fp, sp, #0
  1093d8:	e24dd014 	sub	sp, sp, #20
  1093dc:	e50b0008 	str	r0, [fp, #-8]
  1093e0:	e50b100c 	str	r1, [fp, #-12]
  1093e4:	e50b2010 	str	r2, [fp, #-16]
  1093e8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return 0;
  1093ec:	e3a03000 	mov	r3, #0
}
  1093f0:	e1a00003 	mov	r0, r3
  1093f4:	e28bd000 	add	sp, fp, #0
  1093f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1093fc:	e12fff1e 	bx	lr

00109400 <unet_getaddrinfo>:

int unet_getaddrinfo(const char *nodename, const char *servname, const struct addrinfo *hints, struct addrinfo **res)
{
  109400:	e92d4800 	push	{fp, lr}
  109404:	e28db004 	add	fp, sp, #4
  109408:	e24dd010 	sub	sp, sp, #16
  10940c:	e50b0008 	str	r0, [fp, #-8]
  109410:	e50b100c 	str	r1, [fp, #-12]
  109414:	e50b2010 	str	r2, [fp, #-16]
  109418:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    return lwip_getaddrinfo(nodename, servname, hints, res);
  10941c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109420:	e51b2010 	ldr	r2, [fp, #-16]
  109424:	e51b100c 	ldr	r1, [fp, #-12]
  109428:	e51b0008 	ldr	r0, [fp, #-8]
  10942c:	eb001d6c 	bl	1109e4 <lwip_getaddrinfo>
  109430:	e1a03000 	mov	r3, r0
}
  109434:	e1a00003 	mov	r0, r3
  109438:	e24bd004 	sub	sp, fp, #4
  10943c:	e8bd8800 	pop	{fp, pc}

00109440 <unet_freeaddrinfo>:

void unet_freeaddrinfo(struct addrinfo *ai)
{
  109440:	e92d4800 	push	{fp, lr}
  109444:	e28db004 	add	fp, sp, #4
  109448:	e24dd008 	sub	sp, sp, #8
  10944c:	e50b0008 	str	r0, [fp, #-8]
    lwip_freeaddrinfo(ai);
  109450:	e51b0008 	ldr	r0, [fp, #-8]
  109454:	eb001d4f 	bl	110998 <lwip_freeaddrinfo>
}
  109458:	e320f000 	nop	{0}
  10945c:	e24bd004 	sub	sp, fp, #4
  109460:	e8bd8800 	pop	{fp, pc}

00109464 <rt_list_init>:
{
  109464:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  109468:	e28db000 	add	fp, sp, #0
  10946c:	e24dd00c 	sub	sp, sp, #12
  109470:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
  109474:	e51b3008 	ldr	r3, [fp, #-8]
  109478:	e51b2008 	ldr	r2, [fp, #-8]
  10947c:	e5832004 	str	r2, [r3, #4]
  109480:	e51b3008 	ldr	r3, [fp, #-8]
  109484:	e5932004 	ldr	r2, [r3, #4]
  109488:	e51b3008 	ldr	r3, [fp, #-8]
  10948c:	e5832000 	str	r2, [r3]
}
  109490:	e320f000 	nop	{0}
  109494:	e28bd000 	add	sp, fp, #0
  109498:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10949c:	e12fff1e 	bx	lr

001094a0 <accept_internal>:
#include "dfs_net.h"

#include "sal_socket.h"

int accept_internal(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  1094a0:	e92d4810 	push	{r4, fp, lr}
  1094a4:	e28db008 	add	fp, sp, #8
  1094a8:	e24dd024 	sub	sp, sp, #36	; 0x24
  1094ac:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  1094b0:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  1094b4:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
    int new_socket = -1;
  1094b8:	e3e03000 	mvn	r3, #0
  1094bc:	e50b3010 	str	r3, [fp, #-16]
    int socket = dfs_net_getsocket(s);
  1094c0:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  1094c4:	eb000352 	bl	10a214 <dfs_net_getsocket>
  1094c8:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec

    new_socket = sal_accept(socket, addr, addrlen);
  1094cc:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  1094d0:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  1094d4:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1094d8:	ebfff95f 	bl	107a5c <sal_accept>
  1094dc:	e50b0010 	str	r0, [fp, #-16]
    if (new_socket != -1)
  1094e0:	e51b3010 	ldr	r3, [fp, #-16]
  1094e4:	e3730001 	cmn	r3, #1
  1094e8:	0a000050 	beq	109630 <accept_internal+0x190>
        /* this is a new socket, create it in file system fd */
        int fd;
        struct dfs_fd *d;

        /* allocate a fd */
        fd = fd_new();
  1094ec:	eb000272 	bl	109ebc <fd_new>
  1094f0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
        if (fd < 0)
  1094f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1094f8:	e3530000 	cmp	r3, #0
  1094fc:	aa000003 	bge	109510 <accept_internal+0x70>
        {
            sal_closesocket(new_socket);
  109500:	e51b0010 	ldr	r0, [fp, #-16]
  109504:	ebfffc25 	bl	1085a0 <sal_closesocket>
            return -ENOMEM;
  109508:	e3e0300b 	mvn	r3, #11
  10950c:	ea000048 	b	109634 <accept_internal+0x194>
        }

        d = fd_get(fd);
  109510:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  109514:	eb00029d 	bl	109f90 <fd_get>
  109518:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
        if(d)
  10951c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109520:	e3530000 	cmp	r3, #0
  109524:	0a00003d 	beq	109620 <accept_internal+0x180>
        {
            /* this is a socket fd */
            d->fnode = (struct dfs_fnode *)rt_malloc(sizeof(struct dfs_fnode));
  109528:	e3a00028 	mov	r0, #40	; 0x28
  10952c:	ebffe698 	bl	102f94 <rt_malloc>
  109530:	e1a02000 	mov	r2, r0
  109534:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109538:	e5832018 	str	r2, [r3, #24]
            if (!d->fnode)
  10953c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109540:	e5933018 	ldr	r3, [r3, #24]
  109544:	e3530000 	cmp	r3, #0
  109548:	1a000003 	bne	10955c <accept_internal+0xbc>
            {
                /* release fd */
                fd_release(fd);
  10954c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  109550:	eb0002ed 	bl	10a10c <fd_release>
                return -ENOMEM;
  109554:	e3e0300b 	mvn	r3, #11
  109558:	ea000035 	b	109634 <accept_internal+0x194>
            }
            rt_memset(d->fnode, 0, sizeof(struct dfs_fnode));
  10955c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109560:	e5933018 	ldr	r3, [r3, #24]
  109564:	e3a02028 	mov	r2, #40	; 0x28
  109568:	e3a01000 	mov	r1, #0
  10956c:	e1a00003 	mov	r0, r3
  109570:	ebffe754 	bl	1032c8 <rt_memset>
            rt_list_init(&d->fnode->list);
  109574:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109578:	e5933018 	ldr	r3, [r3, #24]
  10957c:	e2833010 	add	r3, r3, #16
  109580:	e1a00003 	mov	r0, r3
  109584:	ebffffb6 	bl	109464 <rt_list_init>

            d->fnode->type = FT_SOCKET;
  109588:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10958c:	e5933018 	ldr	r3, [r3, #24]
  109590:	e3a02001 	mov	r2, #1
  109594:	e1c320b0 	strh	r2, [r3]
            d->fnode->path = NULL;
  109598:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10959c:	e5933018 	ldr	r3, [r3, #24]
  1095a0:	e3a02000 	mov	r2, #0
  1095a4:	e5832004 	str	r2, [r3, #4]
            d->fnode->fullpath = NULL;
  1095a8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1095ac:	e5933018 	ldr	r3, [r3, #24]
  1095b0:	e3a02000 	mov	r2, #0
  1095b4:	e5832008 	str	r2, [r3, #8]
            d->fnode->ref_count = 1;
  1095b8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1095bc:	e5933018 	ldr	r3, [r3, #24]
  1095c0:	e3a02001 	mov	r2, #1
  1095c4:	e583200c 	str	r2, [r3, #12]
            d->fnode->fops = dfs_net_get_fops();
  1095c8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1095cc:	e5934018 	ldr	r4, [r3, #24]
  1095d0:	eb0003ae 	bl	10a490 <dfs_net_get_fops>
  1095d4:	e1a03000 	mov	r3, r0
  1095d8:	e5843018 	str	r3, [r4, #24]
            d->flags = O_RDWR; /* set flags as read and write */
  1095dc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1095e0:	e3a02002 	mov	r2, #2
  1095e4:	e5832004 	str	r2, [r3, #4]
            d->fnode->size = 0;
  1095e8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1095ec:	e5933018 	ldr	r3, [r3, #24]
  1095f0:	e3a02000 	mov	r2, #0
  1095f4:	e5832020 	str	r2, [r3, #32]
            d->pos = 0;
  1095f8:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  1095fc:	e3a02000 	mov	r2, #0
  109600:	e3a03000 	mov	r3, #0
  109604:	e1c121f0 	strd	r2, [r1, #16]

            /* set socket to the data of dfs_fd */
            d->fnode->data = (void *)(size_t)new_socket;
  109608:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10960c:	e5933018 	ldr	r3, [r3, #24]
  109610:	e51b2010 	ldr	r2, [fp, #-16]
  109614:	e5832024 	str	r2, [r3, #36]	; 0x24

            return fd;
  109618:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10961c:	ea000004 	b	109634 <accept_internal+0x194>
        }

        sal_closesocket(new_socket);
  109620:	e51b0010 	ldr	r0, [fp, #-16]
  109624:	ebfffbdd 	bl	1085a0 <sal_closesocket>
        return -ENOMEM;
  109628:	e3e0300b 	mvn	r3, #11
  10962c:	ea000000 	b	109634 <accept_internal+0x194>
    }

    return -1;
  109630:	e3e03000 	mvn	r3, #0
}
  109634:	e1a00003 	mov	r0, r3
  109638:	e24bd008 	sub	sp, fp, #8
  10963c:	e8bd8810 	pop	{r4, fp, pc}

00109640 <bind_internal>:

int bind_internal(int s, const struct sockaddr *name, socklen_t namelen)
{
  109640:	e92d4800 	push	{fp, lr}
  109644:	e28db004 	add	fp, sp, #4
  109648:	e24dd018 	sub	sp, sp, #24
  10964c:	e50b0010 	str	r0, [fp, #-16]
  109650:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  109654:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    int socket = dfs_net_getsocket(s);
  109658:	e51b0010 	ldr	r0, [fp, #-16]
  10965c:	eb0002ec 	bl	10a214 <dfs_net_getsocket>
  109660:	e50b0008 	str	r0, [fp, #-8]
        server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        return sal_bind(socket, (struct sockaddr *)&server_addr, namelen);
    }
#endif /* SAL_USING_AF_UNIX */

    return sal_bind(socket, name, namelen);
  109664:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  109668:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10966c:	e51b0008 	ldr	r0, [fp, #-8]
  109670:	ebfff973 	bl	107c44 <sal_bind>
  109674:	e1a03000 	mov	r3, r0
}
  109678:	e1a00003 	mov	r0, r3
  10967c:	e24bd004 	sub	sp, fp, #4
  109680:	e8bd8800 	pop	{fp, pc}

00109684 <connect_internal>:

int connect_internal(int s, const struct sockaddr *name, socklen_t namelen)
{
  109684:	e92d4800 	push	{fp, lr}
  109688:	e28db004 	add	fp, sp, #4
  10968c:	e24dd018 	sub	sp, sp, #24
  109690:	e50b0010 	str	r0, [fp, #-16]
  109694:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  109698:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    int socket = dfs_net_getsocket(s);
  10969c:	e51b0010 	ldr	r0, [fp, #-16]
  1096a0:	eb0002db 	bl	10a214 <dfs_net_getsocket>
  1096a4:	e50b0008 	str	r0, [fp, #-8]
        server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        return sal_connect(socket, (struct sockaddr *)&server_addr, namelen);
    }
#endif /* SAL_USING_AF_UNIX */

    return sal_connect(socket, name, namelen);
  1096a8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1096ac:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1096b0:	e51b0008 	ldr	r0, [fp, #-8]
  1096b4:	ebfffaad 	bl	108170 <sal_connect>
  1096b8:	e1a03000 	mov	r3, r0
}
  1096bc:	e1a00003 	mov	r0, r3
  1096c0:	e24bd004 	sub	sp, fp, #4
  1096c4:	e8bd8800 	pop	{fp, pc}

001096c8 <setsockopt_internal>:

int setsockopt_internal(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  1096c8:	e92d4800 	push	{fp, lr}
  1096cc:	e28db004 	add	fp, sp, #4
  1096d0:	e24dd020 	sub	sp, sp, #32
  1096d4:	e50b0010 	str	r0, [fp, #-16]
  1096d8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1096dc:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  1096e0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    int socket = dfs_net_getsocket(s);
  1096e4:	e51b0010 	ldr	r0, [fp, #-16]
  1096e8:	eb0002c9 	bl	10a214 <dfs_net_getsocket>
  1096ec:	e50b0008 	str	r0, [fp, #-8]

    return sal_setsockopt(socket, level, optname, optval, optlen);
  1096f0:	e59b3004 	ldr	r3, [fp, #4]
  1096f4:	e58d3000 	str	r3, [sp]
  1096f8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1096fc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  109700:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  109704:	e51b0008 	ldr	r0, [fp, #-8]
  109708:	ebfffa6e 	bl	1080c8 <sal_setsockopt>
  10970c:	e1a03000 	mov	r3, r0
}
  109710:	e1a00003 	mov	r0, r3
  109714:	e24bd004 	sub	sp, fp, #4
  109718:	e8bd8800 	pop	{fp, pc}

0010971c <listen_internal>:

int listen_internal(int s, int backlog)
{
  10971c:	e92d4800 	push	{fp, lr}
  109720:	e28db004 	add	fp, sp, #4
  109724:	e24dd010 	sub	sp, sp, #16
  109728:	e50b0010 	str	r0, [fp, #-16]
  10972c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    int socket = dfs_net_getsocket(s);
  109730:	e51b0010 	ldr	r0, [fp, #-16]
  109734:	eb0002b6 	bl	10a214 <dfs_net_getsocket>
  109738:	e50b0008 	str	r0, [fp, #-8]

    return sal_listen(socket, backlog);
  10973c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  109740:	e51b0008 	ldr	r0, [fp, #-8]
  109744:	ebfffab8 	bl	10822c <sal_listen>
  109748:	e1a03000 	mov	r3, r0
}
  10974c:	e1a00003 	mov	r0, r3
  109750:	e24bd004 	sub	sp, fp, #4
  109754:	e8bd8800 	pop	{fp, pc}

00109758 <recv_internal>:


int recv_internal(int s, void *mem, size_t len, int flags)
{
  109758:	e92d4800 	push	{fp, lr}
  10975c:	e28db004 	add	fp, sp, #4
  109760:	e24dd020 	sub	sp, sp, #32
  109764:	e50b0010 	str	r0, [fp, #-16]
  109768:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10976c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  109770:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    int socket = dfs_net_getsocket(s);
  109774:	e51b0010 	ldr	r0, [fp, #-16]
  109778:	eb0002a5 	bl	10a214 <dfs_net_getsocket>
  10977c:	e50b0008 	str	r0, [fp, #-8]

    return sal_recvfrom(socket, mem, len, flags, NULL, NULL);
  109780:	e3a03000 	mov	r3, #0
  109784:	e58d3004 	str	r3, [sp, #4]
  109788:	e3a03000 	mov	r3, #0
  10978c:	e58d3000 	str	r3, [sp]
  109790:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109794:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  109798:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10979c:	e51b0008 	ldr	r0, [fp, #-8]
  1097a0:	ebfffac5 	bl	1082bc <sal_recvfrom>
  1097a4:	e1a03000 	mov	r3, r0
}
  1097a8:	e1a00003 	mov	r0, r3
  1097ac:	e24bd004 	sub	sp, fp, #4
  1097b0:	e8bd8800 	pop	{fp, pc}

001097b4 <recvfrom_internal>:

int recvfrom_internal(int s, void *mem, size_t len, int flags,
             struct sockaddr *from, socklen_t *fromlen)
{
  1097b4:	e92d4800 	push	{fp, lr}
  1097b8:	e28db004 	add	fp, sp, #4
  1097bc:	e24dd020 	sub	sp, sp, #32
  1097c0:	e50b0010 	str	r0, [fp, #-16]
  1097c4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1097c8:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  1097cc:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    int socket = dfs_net_getsocket(s);
  1097d0:	e51b0010 	ldr	r0, [fp, #-16]
  1097d4:	eb00028e 	bl	10a214 <dfs_net_getsocket>
  1097d8:	e50b0008 	str	r0, [fp, #-8]

    return sal_recvfrom(socket, mem, len, flags, from, fromlen);
  1097dc:	e59b3008 	ldr	r3, [fp, #8]
  1097e0:	e58d3004 	str	r3, [sp, #4]
  1097e4:	e59b3004 	ldr	r3, [fp, #4]
  1097e8:	e58d3000 	str	r3, [sp]
  1097ec:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1097f0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1097f4:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1097f8:	e51b0008 	ldr	r0, [fp, #-8]
  1097fc:	ebfffaae 	bl	1082bc <sal_recvfrom>
  109800:	e1a03000 	mov	r3, r0
}
  109804:	e1a00003 	mov	r0, r3
  109808:	e24bd004 	sub	sp, fp, #4
  10980c:	e8bd8800 	pop	{fp, pc}

00109810 <send_internal>:

int send_internal(int s, const void *dataptr, size_t size, int flags)
{
  109810:	e92d4800 	push	{fp, lr}
  109814:	e28db004 	add	fp, sp, #4
  109818:	e24dd020 	sub	sp, sp, #32
  10981c:	e50b0010 	str	r0, [fp, #-16]
  109820:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  109824:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  109828:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    int socket = dfs_net_getsocket(s);
  10982c:	e51b0010 	ldr	r0, [fp, #-16]
  109830:	eb000277 	bl	10a214 <dfs_net_getsocket>
  109834:	e50b0008 	str	r0, [fp, #-8]

    return sal_sendto(socket, dataptr, size, flags, NULL, 0);
  109838:	e3a03000 	mov	r3, #0
  10983c:	e58d3004 	str	r3, [sp, #4]
  109840:	e3a03000 	mov	r3, #0
  109844:	e58d3000 	str	r3, [sp]
  109848:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10984c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  109850:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  109854:	e51b0008 	ldr	r0, [fp, #-8]
  109858:	ebfffacb 	bl	10838c <sal_sendto>
  10985c:	e1a03000 	mov	r3, r0
}
  109860:	e1a00003 	mov	r0, r3
  109864:	e24bd004 	sub	sp, fp, #4
  109868:	e8bd8800 	pop	{fp, pc}

0010986c <sendto_internal>:

int sendto_internal(int s, const void *dataptr, size_t size, int flags,
           const struct sockaddr *to, socklen_t tolen)
{
  10986c:	e92d4800 	push	{fp, lr}
  109870:	e28db004 	add	fp, sp, #4
  109874:	e24dd020 	sub	sp, sp, #32
  109878:	e50b0010 	str	r0, [fp, #-16]
  10987c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  109880:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  109884:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    int socket = dfs_net_getsocket(s);
  109888:	e51b0010 	ldr	r0, [fp, #-16]
  10988c:	eb000260 	bl	10a214 <dfs_net_getsocket>
  109890:	e50b0008 	str	r0, [fp, #-8]

    return sal_sendto(socket, dataptr, size, flags, to, tolen);
  109894:	e59b3008 	ldr	r3, [fp, #8]
  109898:	e58d3004 	str	r3, [sp, #4]
  10989c:	e59b3004 	ldr	r3, [fp, #4]
  1098a0:	e58d3000 	str	r3, [sp]
  1098a4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1098a8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1098ac:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1098b0:	e51b0008 	ldr	r0, [fp, #-8]
  1098b4:	ebfffab4 	bl	10838c <sal_sendto>
  1098b8:	e1a03000 	mov	r3, r0
}
  1098bc:	e1a00003 	mov	r0, r3
  1098c0:	e24bd004 	sub	sp, fp, #4
  1098c4:	e8bd8800 	pop	{fp, pc}

001098c8 <socket_internal>:

int socket_internal(int domain, int type, int protocol)
{
  1098c8:	e92d4810 	push	{r4, fp, lr}
  1098cc:	e28db008 	add	fp, sp, #8
  1098d0:	e24dd024 	sub	sp, sp, #36	; 0x24
  1098d4:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  1098d8:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  1098dc:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
    int fd;
    int socket;
    struct dfs_fd *d;

    /* allocate a fd */
    fd = fd_new();
  1098e0:	eb000175 	bl	109ebc <fd_new>
  1098e4:	e50b0010 	str	r0, [fp, #-16]
    if (fd < 0)
  1098e8:	e51b3010 	ldr	r3, [fp, #-16]
  1098ec:	e3530000 	cmp	r3, #0
  1098f0:	aa000001 	bge	1098fc <socket_internal+0x34>
    {
        return -ENOMEM;
  1098f4:	e3e0300b 	mvn	r3, #11
  1098f8:	ea00004f 	b	109a3c <socket_internal+0x174>
    }
    d = fd_get(fd);
  1098fc:	e51b0010 	ldr	r0, [fp, #-16]
  109900:	eb0001a2 	bl	109f90 <fd_get>
  109904:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
    d->fnode = (struct dfs_fnode *)rt_malloc(sizeof(struct dfs_fnode));
  109908:	e3a00028 	mov	r0, #40	; 0x28
  10990c:	ebffe5a0 	bl	102f94 <rt_malloc>
  109910:	e1a02000 	mov	r2, r0
  109914:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109918:	e5832018 	str	r2, [r3, #24]
    if (!d->fnode)
  10991c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109920:	e5933018 	ldr	r3, [r3, #24]
  109924:	e3530000 	cmp	r3, #0
  109928:	1a000003 	bne	10993c <socket_internal+0x74>
    {
        /* release fd */
        fd_release(fd);
  10992c:	e51b0010 	ldr	r0, [fp, #-16]
  109930:	eb0001f5 	bl	10a10c <fd_release>
        return -ENOMEM;
  109934:	e3e0300b 	mvn	r3, #11
  109938:	ea00003f 	b	109a3c <socket_internal+0x174>
    {
        domain = AF_INET;
    }
#endif /* SAL_USING_AF_UNIX */
    /* create socket  and then put it to the dfs_fd */
    socket = sal_socket(domain, type, protocol);
  10993c:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  109940:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  109944:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  109948:	ebfffac3 	bl	10845c <sal_socket>
  10994c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    if (socket >= 0)
  109950:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  109954:	e3530000 	cmp	r3, #0
  109958:	ba000030 	blt	109a20 <socket_internal+0x158>
    {
        rt_memset(d->fnode, 0, sizeof(struct dfs_fnode));
  10995c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109960:	e5933018 	ldr	r3, [r3, #24]
  109964:	e3a02028 	mov	r2, #40	; 0x28
  109968:	e3a01000 	mov	r1, #0
  10996c:	e1a00003 	mov	r0, r3
  109970:	ebffe654 	bl	1032c8 <rt_memset>
        rt_list_init(&d->fnode->list);
  109974:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109978:	e5933018 	ldr	r3, [r3, #24]
  10997c:	e2833010 	add	r3, r3, #16
  109980:	e1a00003 	mov	r0, r3
  109984:	ebfffeb6 	bl	109464 <rt_list_init>
        /* this is a socket fd */
        d->fnode->type = FT_SOCKET;
  109988:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10998c:	e5933018 	ldr	r3, [r3, #24]
  109990:	e3a02001 	mov	r2, #1
  109994:	e1c320b0 	strh	r2, [r3]
        d->fnode->path = NULL;
  109998:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10999c:	e5933018 	ldr	r3, [r3, #24]
  1099a0:	e3a02000 	mov	r2, #0
  1099a4:	e5832004 	str	r2, [r3, #4]
        d->fnode->fullpath = NULL;
  1099a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1099ac:	e5933018 	ldr	r3, [r3, #24]
  1099b0:	e3a02000 	mov	r2, #0
  1099b4:	e5832008 	str	r2, [r3, #8]
        d->fnode->ref_count = 1;
  1099b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1099bc:	e5933018 	ldr	r3, [r3, #24]
  1099c0:	e3a02001 	mov	r2, #1
  1099c4:	e583200c 	str	r2, [r3, #12]
        d->fnode->fops = dfs_net_get_fops();
  1099c8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1099cc:	e5934018 	ldr	r4, [r3, #24]
  1099d0:	eb0002ae 	bl	10a490 <dfs_net_get_fops>
  1099d4:	e1a03000 	mov	r3, r0
  1099d8:	e5843018 	str	r3, [r4, #24]

        d->flags = O_RDWR; /* set flags as read and write */
  1099dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1099e0:	e3a02002 	mov	r2, #2
  1099e4:	e5832004 	str	r2, [r3, #4]
        d->fnode->size = 0;
  1099e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1099ec:	e5933018 	ldr	r3, [r3, #24]
  1099f0:	e3a02000 	mov	r2, #0
  1099f4:	e5832020 	str	r2, [r3, #32]
        d->pos = 0;
  1099f8:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1099fc:	e3a02000 	mov	r2, #0
  109a00:	e3a03000 	mov	r3, #0
  109a04:	e1c121f0 	strd	r2, [r1, #16]

        /* set socket to the data of dfs_fd */
        d->fnode->data = (void *)(size_t)socket;
  109a08:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109a0c:	e5933018 	ldr	r3, [r3, #24]
  109a10:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  109a14:	e5832024 	str	r2, [r3, #36]	; 0x24
        /* release fd */
        fd_release(fd);
        return -ENOMEM;
    }

    return fd;
  109a18:	e51b3010 	ldr	r3, [fp, #-16]
  109a1c:	ea000006 	b	109a3c <socket_internal+0x174>
        rt_free(d->fnode);
  109a20:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109a24:	e5933018 	ldr	r3, [r3, #24]
  109a28:	e1a00003 	mov	r0, r3
  109a2c:	ebffe562 	bl	102fbc <rt_free>
        fd_release(fd);
  109a30:	e51b0010 	ldr	r0, [fp, #-16]
  109a34:	eb0001b4 	bl	10a10c <fd_release>
        return -ENOMEM;
  109a38:	e3e0300b 	mvn	r3, #11
  109a3c:	e1a00003 	mov	r0, r3
  109a40:	e24bd008 	sub	sp, fp, #8
  109a44:	e8bd8810 	pop	{r4, fp, pc}

00109a48 <dfs_init>:

/**
 * this function will initialize device file system.
 */
int dfs_init(void)
{
  109a48:	e92d4800 	push	{fp, lr}
  109a4c:	e28db004 	add	fp, sp, #4
    static rt_bool_t init_ok = RT_FALSE;

    if (init_ok)
  109a50:	e30e3618 	movw	r3, #58904	; 0xe618
  109a54:	e3403014 	movt	r3, #20
  109a58:	e5933000 	ldr	r3, [r3]
  109a5c:	e3530000 	cmp	r3, #0
  109a60:	0a000004 	beq	109a78 <dfs_init+0x30>
    {
        rt_kprintf("dfs already init.\n");
  109a64:	e30603bc 	movw	r0, #25532	; 0x63bc
  109a68:	e3400014 	movt	r0, #20
  109a6c:	ebffe5a8 	bl	103114 <rt_kprintf>
        return 0;
  109a70:	e3a03000 	mov	r3, #0
  109a74:	ea000016 	b	109ad4 <dfs_init+0x8c>
    }

    /* init fnode hash table */
    dfs_fnode_mgr_init();
  109a78:	eb0001c6 	bl	10a198 <dfs_fnode_mgr_init>

    /* clean fd table */
    memset(&_fdtab, 0, sizeof(_fdtab));
  109a7c:	e3a02008 	mov	r2, #8
  109a80:	e3a01000 	mov	r1, #0
  109a84:	e30e0610 	movw	r0, #58896	; 0xe610
  109a88:	e3400014 	movt	r0, #20
  109a8c:	eb00de78 	bl	141474 <memset>

    /* create device filesystem lock */
    rt_mutex_init(&fslock, "fslock", RT_IPC_FLAG_FIFO);
  109a90:	e3a02000 	mov	r2, #0
  109a94:	e30613d0 	movw	r1, #25552	; 0x63d0
  109a98:	e3401014 	movt	r1, #20
  109a9c:	e30e05c0 	movw	r0, #58816	; 0xe5c0
  109aa0:	e3400014 	movt	r0, #20
  109aa4:	ebffdca7 	bl	100d48 <rt_mutex_init>
    rt_mutex_init(&fdlock, "fdlock", RT_IPC_FLAG_FIFO);
  109aa8:	e3a02000 	mov	r2, #0
  109aac:	e30613d8 	movw	r1, #25560	; 0x63d8
  109ab0:	e3401014 	movt	r1, #20
  109ab4:	e30e05e8 	movw	r0, #58856	; 0xe5e8
  109ab8:	e3400014 	movt	r0, #20
  109abc:	ebffdca1 	bl	100d48 <rt_mutex_init>

    init_ok = RT_TRUE;
  109ac0:	e30e3618 	movw	r3, #58904	; 0xe618
  109ac4:	e3403014 	movt	r3, #20
  109ac8:	e3a02001 	mov	r2, #1
  109acc:	e5832000 	str	r2, [r3]

    return 0;
  109ad0:	e3a03000 	mov	r3, #0
}
  109ad4:	e1a00003 	mov	r0, r3
  109ad8:	e8bd8800 	pop	{fp, pc}

00109adc <dfs_lock>:
 * this function will lock device file system.
 *
 * @note please don't invoke it on ISR.
 */
void dfs_lock(void)
{
  109adc:	e92d4800 	push	{fp, lr}
  109ae0:	e28db004 	add	fp, sp, #4
  109ae4:	e24dd008 	sub	sp, sp, #8
    rt_err_t result = -RT_EBUSY;
  109ae8:	e3e03006 	mvn	r3, #6
  109aec:	e50b3008 	str	r3, [fp, #-8]

    while (result == -RT_EBUSY)
  109af0:	ea000004 	b	109b08 <dfs_lock+0x2c>
    {
        result = rt_mutex_take(&fslock, RT_WAITING_FOREVER);
  109af4:	e3e01000 	mvn	r1, #0
  109af8:	e30e05c0 	movw	r0, #58816	; 0xe5c0
  109afc:	e3400014 	movt	r0, #20
  109b00:	ebffdcfe 	bl	100f00 <rt_mutex_take>
  109b04:	e50b0008 	str	r0, [fp, #-8]
    while (result == -RT_EBUSY)
  109b08:	e51b3008 	ldr	r3, [fp, #-8]
  109b0c:	e3730007 	cmn	r3, #7
  109b10:	0afffff7 	beq	109af4 <dfs_lock+0x18>
    }

    if (result != RT_EOK)
  109b14:	e51b3008 	ldr	r3, [fp, #-8]
  109b18:	e3530000 	cmp	r3, #0
  109b1c:	0a000005 	beq	109b38 <dfs_lock+0x5c>
    {
        RT_ASSERT(0);
  109b20:	e3a0203d 	mov	r2, #61	; 0x3d
  109b24:	e306144c 	movw	r1, #25676	; 0x644c
  109b28:	e3401014 	movt	r1, #20
  109b2c:	e30603e0 	movw	r0, #25568	; 0x63e0
  109b30:	e3400014 	movt	r0, #20
  109b34:	ebffe697 	bl	103598 <rt_assert_handler>
    }
}
  109b38:	e320f000 	nop	{0}
  109b3c:	e24bd004 	sub	sp, fp, #4
  109b40:	e8bd8800 	pop	{fp, pc}

00109b44 <dfs_fd_lock>:

void dfs_fd_lock(void)
{
  109b44:	e92d4800 	push	{fp, lr}
  109b48:	e28db004 	add	fp, sp, #4
  109b4c:	e24dd008 	sub	sp, sp, #8
    rt_err_t result = -RT_EBUSY;
  109b50:	e3e03006 	mvn	r3, #6
  109b54:	e50b3008 	str	r3, [fp, #-8]

    while (result == -RT_EBUSY)
  109b58:	ea000004 	b	109b70 <dfs_fd_lock+0x2c>
    {
        result = rt_mutex_take(&fdlock, RT_WAITING_FOREVER);
  109b5c:	e3e01000 	mvn	r1, #0
  109b60:	e30e05e8 	movw	r0, #58856	; 0xe5e8
  109b64:	e3400014 	movt	r0, #20
  109b68:	ebffdce4 	bl	100f00 <rt_mutex_take>
  109b6c:	e50b0008 	str	r0, [fp, #-8]
    while (result == -RT_EBUSY)
  109b70:	e51b3008 	ldr	r3, [fp, #-8]
  109b74:	e3730007 	cmn	r3, #7
  109b78:	0afffff7 	beq	109b5c <dfs_fd_lock+0x18>
    }

    if (result != RT_EOK)
  109b7c:	e51b3008 	ldr	r3, [fp, #-8]
  109b80:	e3530000 	cmp	r3, #0
  109b84:	0a000005 	beq	109ba0 <dfs_fd_lock+0x5c>
    {
        RT_ASSERT(0);
  109b88:	e3a0204c 	mov	r2, #76	; 0x4c
  109b8c:	e3061458 	movw	r1, #25688	; 0x6458
  109b90:	e3401014 	movt	r1, #20
  109b94:	e30603e0 	movw	r0, #25568	; 0x63e0
  109b98:	e3400014 	movt	r0, #20
  109b9c:	ebffe67d 	bl	103598 <rt_assert_handler>
    }
}
  109ba0:	e320f000 	nop	{0}
  109ba4:	e24bd004 	sub	sp, fp, #4
  109ba8:	e8bd8800 	pop	{fp, pc}

00109bac <dfs_unlock>:
 * this function will lock device file system.
 *
 * @note please don't invoke it on ISR.
 */
void dfs_unlock(void)
{
  109bac:	e92d4800 	push	{fp, lr}
  109bb0:	e28db004 	add	fp, sp, #4
    rt_mutex_release(&fslock);
  109bb4:	e30e05c0 	movw	r0, #58816	; 0xe5c0
  109bb8:	e3400014 	movt	r0, #20
  109bbc:	ebffdced 	bl	100f78 <rt_mutex_release>
}
  109bc0:	e320f000 	nop	{0}
  109bc4:	e8bd8800 	pop	{fp, pc}

00109bc8 <dfs_fd_unlock>:

void dfs_fd_unlock(void)
{
  109bc8:	e92d4800 	push	{fp, lr}
  109bcc:	e28db004 	add	fp, sp, #4
    rt_mutex_release(&fdlock);
  109bd0:	e30e05e8 	movw	r0, #58856	; 0xe5e8
  109bd4:	e3400014 	movt	r0, #20
  109bd8:	ebffdce6 	bl	100f78 <rt_mutex_release>
}
  109bdc:	e320f000 	nop	{0}
  109be0:	e8bd8800 	pop	{fp, pc}

00109be4 <fd_slot_expand>:

static int fd_slot_expand(struct dfs_fdtable *fdt, int fd)
{
  109be4:	e92d4800 	push	{fp, lr}
  109be8:	e28db004 	add	fp, sp, #4
  109bec:	e24dd018 	sub	sp, sp, #24
  109bf0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  109bf4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    int nr;
    int index;
    struct dfs_fd **fds = NULL;
  109bf8:	e3a03000 	mov	r3, #0
  109bfc:	e50b3010 	str	r3, [fp, #-16]

    if (fd < fdt->maxfd)
  109c00:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  109c04:	e5932000 	ldr	r2, [r3]
  109c08:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109c0c:	e1520003 	cmp	r2, r3
  109c10:	9a000001 	bls	109c1c <fd_slot_expand+0x38>
    {
        return fd;
  109c14:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109c18:	ea000032 	b	109ce8 <fd_slot_expand+0x104>
    }
    if (fd >= DFS_FD_MAX)
  109c1c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109c20:	e353001f 	cmp	r3, #31
  109c24:	da000001 	ble	109c30 <fd_slot_expand+0x4c>
    {
        return -1;
  109c28:	e3e03000 	mvn	r3, #0
  109c2c:	ea00002d 	b	109ce8 <fd_slot_expand+0x104>
    }

    nr = ((fd + 4) & ~3);
  109c30:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  109c34:	e2833004 	add	r3, r3, #4
  109c38:	e3c33003 	bic	r3, r3, #3
  109c3c:	e50b3008 	str	r3, [fp, #-8]
    if (nr > DFS_FD_MAX)
  109c40:	e51b3008 	ldr	r3, [fp, #-8]
  109c44:	e3530020 	cmp	r3, #32
  109c48:	da000001 	ble	109c54 <fd_slot_expand+0x70>
    {
        nr = DFS_FD_MAX;
  109c4c:	e3a03020 	mov	r3, #32
  109c50:	e50b3008 	str	r3, [fp, #-8]
    }
    fds = (struct dfs_fd **)rt_realloc(fdt->fds, nr * sizeof(struct dfs_fd *));
  109c54:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  109c58:	e5932004 	ldr	r2, [r3, #4]
  109c5c:	e51b3008 	ldr	r3, [fp, #-8]
  109c60:	e1a03103 	lsl	r3, r3, #2
  109c64:	e1a01003 	mov	r1, r3
  109c68:	e1a00002 	mov	r0, r2
  109c6c:	ebffe4da 	bl	102fdc <rt_realloc>
  109c70:	e50b0010 	str	r0, [fp, #-16]
    if (!fds)
  109c74:	e51b3010 	ldr	r3, [fp, #-16]
  109c78:	e3530000 	cmp	r3, #0
  109c7c:	1a000001 	bne	109c88 <fd_slot_expand+0xa4>
    {
        return -1;
  109c80:	e3e03000 	mvn	r3, #0
  109c84:	ea000017 	b	109ce8 <fd_slot_expand+0x104>
    }

    /* clean the new allocated fds */
    for (index = fdt->maxfd; index < nr; index++)
  109c88:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  109c8c:	e5933000 	ldr	r3, [r3]
  109c90:	e50b300c 	str	r3, [fp, #-12]
  109c94:	ea000008 	b	109cbc <fd_slot_expand+0xd8>
    {
        fds[index] = NULL;
  109c98:	e51b300c 	ldr	r3, [fp, #-12]
  109c9c:	e1a03103 	lsl	r3, r3, #2
  109ca0:	e51b2010 	ldr	r2, [fp, #-16]
  109ca4:	e0823003 	add	r3, r2, r3
  109ca8:	e3a02000 	mov	r2, #0
  109cac:	e5832000 	str	r2, [r3]
    for (index = fdt->maxfd; index < nr; index++)
  109cb0:	e51b300c 	ldr	r3, [fp, #-12]
  109cb4:	e2833001 	add	r3, r3, #1
  109cb8:	e50b300c 	str	r3, [fp, #-12]
  109cbc:	e51b200c 	ldr	r2, [fp, #-12]
  109cc0:	e51b3008 	ldr	r3, [fp, #-8]
  109cc4:	e1520003 	cmp	r2, r3
  109cc8:	bafffff2 	blt	109c98 <fd_slot_expand+0xb4>
    }
    fdt->fds   = fds;
  109ccc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  109cd0:	e51b2010 	ldr	r2, [fp, #-16]
  109cd4:	e5832004 	str	r2, [r3, #4]
    fdt->maxfd = nr;
  109cd8:	e51b2008 	ldr	r2, [fp, #-8]
  109cdc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  109ce0:	e5832000 	str	r2, [r3]

    return fd;
  109ce4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
}
  109ce8:	e1a00003 	mov	r0, r3
  109cec:	e24bd004 	sub	sp, fp, #4
  109cf0:	e8bd8800 	pop	{fp, pc}

00109cf4 <fd_slot_alloc>:

static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)
{
  109cf4:	e92d4800 	push	{fp, lr}
  109cf8:	e28db004 	add	fp, sp, #4
  109cfc:	e24dd010 	sub	sp, sp, #16
  109d00:	e50b0010 	str	r0, [fp, #-16]
  109d04:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    int idx;

    /* find an empty fd slot */
    for (idx = startfd; idx < (int)fdt->maxfd; idx++)
  109d08:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109d0c:	e50b3008 	str	r3, [fp, #-8]
  109d10:	ea00000c 	b	109d48 <fd_slot_alloc+0x54>
    {
        if (fdt->fds[idx] == RT_NULL)
  109d14:	e51b3010 	ldr	r3, [fp, #-16]
  109d18:	e5932004 	ldr	r2, [r3, #4]
  109d1c:	e51b3008 	ldr	r3, [fp, #-8]
  109d20:	e1a03103 	lsl	r3, r3, #2
  109d24:	e0823003 	add	r3, r2, r3
  109d28:	e5933000 	ldr	r3, [r3]
  109d2c:	e3530000 	cmp	r3, #0
  109d30:	1a000001 	bne	109d3c <fd_slot_alloc+0x48>
        {
            return idx;
  109d34:	e51b3008 	ldr	r3, [fp, #-8]
  109d38:	ea00001a 	b	109da8 <fd_slot_alloc+0xb4>
    for (idx = startfd; idx < (int)fdt->maxfd; idx++)
  109d3c:	e51b3008 	ldr	r3, [fp, #-8]
  109d40:	e2833001 	add	r3, r3, #1
  109d44:	e50b3008 	str	r3, [fp, #-8]
  109d48:	e51b3010 	ldr	r3, [fp, #-16]
  109d4c:	e5933000 	ldr	r3, [r3]
  109d50:	e1a02003 	mov	r2, r3
  109d54:	e51b3008 	ldr	r3, [fp, #-8]
  109d58:	e1530002 	cmp	r3, r2
  109d5c:	baffffec 	blt	109d14 <fd_slot_alloc+0x20>
        }
    }

    idx = fdt->maxfd;
  109d60:	e51b3010 	ldr	r3, [fp, #-16]
  109d64:	e5933000 	ldr	r3, [r3]
  109d68:	e50b3008 	str	r3, [fp, #-8]
    if (idx < startfd)
  109d6c:	e51b2008 	ldr	r2, [fp, #-8]
  109d70:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109d74:	e1520003 	cmp	r2, r3
  109d78:	aa000001 	bge	109d84 <fd_slot_alloc+0x90>
    {
        idx = startfd;
  109d7c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109d80:	e50b3008 	str	r3, [fp, #-8]
    }
    if (fd_slot_expand(fdt, idx) < 0)
  109d84:	e51b1008 	ldr	r1, [fp, #-8]
  109d88:	e51b0010 	ldr	r0, [fp, #-16]
  109d8c:	ebffff94 	bl	109be4 <fd_slot_expand>
  109d90:	e1a03000 	mov	r3, r0
  109d94:	e3530000 	cmp	r3, #0
  109d98:	aa000001 	bge	109da4 <fd_slot_alloc+0xb0>
    {
        return -1;
  109d9c:	e3e03000 	mvn	r3, #0
  109da0:	ea000000 	b	109da8 <fd_slot_alloc+0xb4>
    }
    return idx;
  109da4:	e51b3008 	ldr	r3, [fp, #-8]
}
  109da8:	e1a00003 	mov	r0, r3
  109dac:	e24bd004 	sub	sp, fp, #4
  109db0:	e8bd8800 	pop	{fp, pc}

00109db4 <fd_alloc>:

static int fd_alloc(struct dfs_fdtable *fdt, int startfd)
{
  109db4:	e92d4800 	push	{fp, lr}
  109db8:	e28db004 	add	fp, sp, #4
  109dbc:	e24dd010 	sub	sp, sp, #16
  109dc0:	e50b0010 	str	r0, [fp, #-16]
  109dc4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    int idx;
    struct dfs_fd *fd = NULL;
  109dc8:	e3a03000 	mov	r3, #0
  109dcc:	e50b3008 	str	r3, [fp, #-8]

    idx = fd_slot_alloc(fdt, startfd);
  109dd0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  109dd4:	e51b0010 	ldr	r0, [fp, #-16]
  109dd8:	ebffffc5 	bl	109cf4 <fd_slot_alloc>
  109ddc:	e50b000c 	str	r0, [fp, #-12]

    /* allocate  'struct dfs_fd' */
    if (idx < 0)
  109de0:	e51b300c 	ldr	r3, [fp, #-12]
  109de4:	e3530000 	cmp	r3, #0
  109de8:	aa000001 	bge	109df4 <fd_alloc+0x40>
    {
        return -1;
  109dec:	e3e03000 	mvn	r3, #0
  109df0:	ea00001a 	b	109e60 <fd_alloc+0xac>
    }
    fd = (struct dfs_fd *)rt_calloc(1, sizeof(struct dfs_fd));
  109df4:	e3a01020 	mov	r1, #32
  109df8:	e3a00001 	mov	r0, #1
  109dfc:	ebffe482 	bl	10300c <rt_calloc>
  109e00:	e50b0008 	str	r0, [fp, #-8]
    if (!fd)
  109e04:	e51b3008 	ldr	r3, [fp, #-8]
  109e08:	e3530000 	cmp	r3, #0
  109e0c:	1a000001 	bne	109e18 <fd_alloc+0x64>
    {
        return -1;
  109e10:	e3e03000 	mvn	r3, #0
  109e14:	ea000011 	b	109e60 <fd_alloc+0xac>
    }
    fd->ref_count = 1;
  109e18:	e51b3008 	ldr	r3, [fp, #-8]
  109e1c:	e3a02001 	mov	r2, #1
  109e20:	e5832008 	str	r2, [r3, #8]
    fd->magic = DFS_FD_MAGIC;
  109e24:	e51b2008 	ldr	r2, [fp, #-8]
  109e28:	e30f3dfd 	movw	r3, #65021	; 0xfdfd
  109e2c:	e34f3fff 	movt	r3, #65535	; 0xffff
  109e30:	e1c230b0 	strh	r3, [r2]
    fd->fnode = NULL;
  109e34:	e51b3008 	ldr	r3, [fp, #-8]
  109e38:	e3a02000 	mov	r2, #0
  109e3c:	e5832018 	str	r2, [r3, #24]
    fdt->fds[idx] = fd;
  109e40:	e51b3010 	ldr	r3, [fp, #-16]
  109e44:	e5932004 	ldr	r2, [r3, #4]
  109e48:	e51b300c 	ldr	r3, [fp, #-12]
  109e4c:	e1a03103 	lsl	r3, r3, #2
  109e50:	e0823003 	add	r3, r2, r3
  109e54:	e51b2008 	ldr	r2, [fp, #-8]
  109e58:	e5832000 	str	r2, [r3]

    return idx;
  109e5c:	e51b300c 	ldr	r3, [fp, #-12]
}
  109e60:	e1a00003 	mov	r0, r3
  109e64:	e24bd004 	sub	sp, fp, #4
  109e68:	e8bd8800 	pop	{fp, pc}

00109e6c <fdt_fd_new>:
 * This function will allocate a file descriptor.
 *
 * @return -1 on failed or the allocated file descriptor.
 */
int fdt_fd_new(struct dfs_fdtable *fdt)
{
  109e6c:	e92d4800 	push	{fp, lr}
  109e70:	e28db004 	add	fp, sp, #4
  109e74:	e24dd010 	sub	sp, sp, #16
  109e78:	e50b0010 	str	r0, [fp, #-16]
    int idx;

    /* lock filesystem */
    dfs_fd_lock();
  109e7c:	ebffff30 	bl	109b44 <dfs_fd_lock>

    /* find an empty fd entry */
    idx = fd_alloc(fdt, DFS_STDIO_OFFSET);
  109e80:	e3a01003 	mov	r1, #3
  109e84:	e51b0010 	ldr	r0, [fp, #-16]
  109e88:	ebffffc9 	bl	109db4 <fd_alloc>
  109e8c:	e50b0008 	str	r0, [fp, #-8]

    /* can't find an empty fd entry */
    if (idx < 0)
  109e90:	e51b3008 	ldr	r3, [fp, #-8]
  109e94:	e3530000 	cmp	r3, #0
  109e98:	aa000002 	bge	109ea8 <fdt_fd_new+0x3c>
    {
        rt_kprintf("DFS fd new is failed! Could not found an empty fd entry.");
  109e9c:	e30603e4 	movw	r0, #25572	; 0x63e4
  109ea0:	e3400014 	movt	r0, #20
  109ea4:	ebffe49a 	bl	103114 <rt_kprintf>
    }

    dfs_fd_unlock();
  109ea8:	ebffff46 	bl	109bc8 <dfs_fd_unlock>
    return idx;
  109eac:	e51b3008 	ldr	r3, [fp, #-8]
}
  109eb0:	e1a00003 	mov	r0, r3
  109eb4:	e24bd004 	sub	sp, fp, #4
  109eb8:	e8bd8800 	pop	{fp, pc}

00109ebc <fd_new>:

int fd_new(void)
{
  109ebc:	e92d4800 	push	{fp, lr}
  109ec0:	e28db004 	add	fp, sp, #4
  109ec4:	e24dd008 	sub	sp, sp, #8
    struct dfs_fdtable *fdt = NULL;
  109ec8:	e3a03000 	mov	r3, #0
  109ecc:	e50b3008 	str	r3, [fp, #-8]

    fdt = dfs_fdtable_get();
  109ed0:	eb000099 	bl	10a13c <dfs_fdtable_get>
  109ed4:	e50b0008 	str	r0, [fp, #-8]
    return fdt_fd_new(fdt);
  109ed8:	e51b0008 	ldr	r0, [fp, #-8]
  109edc:	ebffffe2 	bl	109e6c <fdt_fd_new>
  109ee0:	e1a03000 	mov	r3, r0
}
  109ee4:	e1a00003 	mov	r0, r3
  109ee8:	e24bd004 	sub	sp, fp, #4
  109eec:	e8bd8800 	pop	{fp, pc}

00109ef0 <fdt_fd_get>:
 * @return NULL on on this file descriptor or the file descriptor structure
 * pointer.
 */

struct dfs_fd *fdt_fd_get(struct dfs_fdtable* fdt, int fd)
{
  109ef0:	e92d4800 	push	{fp, lr}
  109ef4:	e28db004 	add	fp, sp, #4
  109ef8:	e24dd010 	sub	sp, sp, #16
  109efc:	e50b0010 	str	r0, [fp, #-16]
  109f00:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    struct dfs_fd *d;

    if (fd < 0 || fd >= (int)fdt->maxfd)
  109f04:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109f08:	e3530000 	cmp	r3, #0
  109f0c:	ba000005 	blt	109f28 <fdt_fd_get+0x38>
  109f10:	e51b3010 	ldr	r3, [fp, #-16]
  109f14:	e5933000 	ldr	r3, [r3]
  109f18:	e1a02003 	mov	r2, r3
  109f1c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109f20:	e1530002 	cmp	r3, r2
  109f24:	ba000001 	blt	109f30 <fdt_fd_get+0x40>
    {
        return NULL;
  109f28:	e3a03000 	mov	r3, #0
  109f2c:	ea000014 	b	109f84 <fdt_fd_get+0x94>
    }

    dfs_fd_lock();
  109f30:	ebffff03 	bl	109b44 <dfs_fd_lock>
    d = fdt->fds[fd];
  109f34:	e51b3010 	ldr	r3, [fp, #-16]
  109f38:	e5932004 	ldr	r2, [r3, #4]
  109f3c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  109f40:	e1a03103 	lsl	r3, r3, #2
  109f44:	e0823003 	add	r3, r2, r3
  109f48:	e5933000 	ldr	r3, [r3]
  109f4c:	e50b3008 	str	r3, [fp, #-8]

    /* check dfs_fd valid or not */
    if ((d == NULL) || (d->magic != DFS_FD_MAGIC))
  109f50:	e51b3008 	ldr	r3, [fp, #-8]
  109f54:	e3530000 	cmp	r3, #0
  109f58:	0a000004 	beq	109f70 <fdt_fd_get+0x80>
  109f5c:	e51b3008 	ldr	r3, [fp, #-8]
  109f60:	e1d330b0 	ldrh	r3, [r3]
  109f64:	e30f2dfd 	movw	r2, #65021	; 0xfdfd
  109f68:	e1530002 	cmp	r3, r2
  109f6c:	0a000002 	beq	109f7c <fdt_fd_get+0x8c>
    {
        dfs_fd_unlock();
  109f70:	ebffff14 	bl	109bc8 <dfs_fd_unlock>
        return NULL;
  109f74:	e3a03000 	mov	r3, #0
  109f78:	ea000001 	b	109f84 <fdt_fd_get+0x94>
    }

    dfs_fd_unlock();
  109f7c:	ebffff11 	bl	109bc8 <dfs_fd_unlock>

    return d;
  109f80:	e51b3008 	ldr	r3, [fp, #-8]
}
  109f84:	e1a00003 	mov	r0, r3
  109f88:	e24bd004 	sub	sp, fp, #4
  109f8c:	e8bd8800 	pop	{fp, pc}

00109f90 <fd_get>:

struct dfs_fd *fd_get(int fd)
{
  109f90:	e92d4800 	push	{fp, lr}
  109f94:	e28db004 	add	fp, sp, #4
  109f98:	e24dd010 	sub	sp, sp, #16
  109f9c:	e50b0010 	str	r0, [fp, #-16]
    struct dfs_fdtable *fdt;

    fdt = dfs_fdtable_get();
  109fa0:	eb000065 	bl	10a13c <dfs_fdtable_get>
  109fa4:	e50b0008 	str	r0, [fp, #-8]
    return fdt_fd_get(fdt, fd);
  109fa8:	e51b1010 	ldr	r1, [fp, #-16]
  109fac:	e51b0008 	ldr	r0, [fp, #-8]
  109fb0:	ebffffce 	bl	109ef0 <fdt_fd_get>
  109fb4:	e1a03000 	mov	r3, r0
}
  109fb8:	e1a00003 	mov	r0, r3
  109fbc:	e24bd004 	sub	sp, fp, #4
  109fc0:	e8bd8800 	pop	{fp, pc}

00109fc4 <fdt_fd_release>:
 * @ingroup Fd
 *
 * This function will put the file descriptor.
 */
void fdt_fd_release(struct dfs_fdtable* fdt, int fd)
{
  109fc4:	e92d4800 	push	{fp, lr}
  109fc8:	e28db004 	add	fp, sp, #4
  109fcc:	e24dd010 	sub	sp, sp, #16
  109fd0:	e50b0010 	str	r0, [fp, #-16]
  109fd4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    struct dfs_fd *fd_slot = NULL;
  109fd8:	e3a03000 	mov	r3, #0
  109fdc:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(fdt != NULL);
  109fe0:	e51b3010 	ldr	r3, [fp, #-16]
  109fe4:	e3530000 	cmp	r3, #0
  109fe8:	1a000005 	bne	10a004 <fdt_fd_release+0x40>
  109fec:	e300210b 	movw	r2, #267	; 0x10b
  109ff0:	e3061464 	movw	r1, #25700	; 0x6464
  109ff4:	e3401014 	movt	r1, #20
  109ff8:	e3060420 	movw	r0, #25632	; 0x6420
  109ffc:	e3400014 	movt	r0, #20
  10a000:	ebffe564 	bl	103598 <rt_assert_handler>

    dfs_fd_lock();
  10a004:	ebfffece 	bl	109b44 <dfs_fd_lock>

    if ((fd < 0) || (fd >= fdt->maxfd))
  10a008:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10a00c:	e3530000 	cmp	r3, #0
  10a010:	ba000004 	blt	10a028 <fdt_fd_release+0x64>
  10a014:	e51b3010 	ldr	r3, [fp, #-16]
  10a018:	e5932000 	ldr	r2, [r3]
  10a01c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10a020:	e1520003 	cmp	r2, r3
  10a024:	8a000001 	bhi	10a030 <fdt_fd_release+0x6c>
    {
        dfs_fd_unlock();
  10a028:	ebfffee6 	bl	109bc8 <dfs_fd_unlock>
        return;
  10a02c:	ea000034 	b	10a104 <fdt_fd_release+0x140>
    }

    fd_slot = fdt->fds[fd];
  10a030:	e51b3010 	ldr	r3, [fp, #-16]
  10a034:	e5932004 	ldr	r2, [r3, #4]
  10a038:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10a03c:	e1a03103 	lsl	r3, r3, #2
  10a040:	e0823003 	add	r3, r2, r3
  10a044:	e5933000 	ldr	r3, [r3]
  10a048:	e50b3008 	str	r3, [fp, #-8]
    if (fd_slot == NULL)
  10a04c:	e51b3008 	ldr	r3, [fp, #-8]
  10a050:	e3530000 	cmp	r3, #0
  10a054:	1a000001 	bne	10a060 <fdt_fd_release+0x9c>
    {
        dfs_fd_unlock();
  10a058:	ebfffeda 	bl	109bc8 <dfs_fd_unlock>
        return;
  10a05c:	ea000028 	b	10a104 <fdt_fd_release+0x140>
    }
    fdt->fds[fd] = NULL;
  10a060:	e51b3010 	ldr	r3, [fp, #-16]
  10a064:	e5932004 	ldr	r2, [r3, #4]
  10a068:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10a06c:	e1a03103 	lsl	r3, r3, #2
  10a070:	e0823003 	add	r3, r2, r3
  10a074:	e3a02000 	mov	r2, #0
  10a078:	e5832000 	str	r2, [r3]

    /* check fd */
    RT_ASSERT(fd_slot->magic == DFS_FD_MAGIC);
  10a07c:	e51b3008 	ldr	r3, [fp, #-8]
  10a080:	e1d330b0 	ldrh	r3, [r3]
  10a084:	e30f2dfd 	movw	r2, #65021	; 0xfdfd
  10a088:	e1530002 	cmp	r3, r2
  10a08c:	0a000005 	beq	10a0a8 <fdt_fd_release+0xe4>
  10a090:	e300211e 	movw	r2, #286	; 0x11e
  10a094:	e3061464 	movw	r1, #25700	; 0x6464
  10a098:	e3401014 	movt	r1, #20
  10a09c:	e306042c 	movw	r0, #25644	; 0x642c
  10a0a0:	e3400014 	movt	r0, #20
  10a0a4:	ebffe53b 	bl	103598 <rt_assert_handler>

    fd_slot->ref_count--;
  10a0a8:	e51b3008 	ldr	r3, [fp, #-8]
  10a0ac:	e5933008 	ldr	r3, [r3, #8]
  10a0b0:	e2432001 	sub	r2, r3, #1
  10a0b4:	e51b3008 	ldr	r3, [fp, #-8]
  10a0b8:	e5832008 	str	r2, [r3, #8]

    /* clear this fd entry */
    if (fd_slot->ref_count == 0)
  10a0bc:	e51b3008 	ldr	r3, [fp, #-8]
  10a0c0:	e5933008 	ldr	r3, [r3, #8]
  10a0c4:	e3530000 	cmp	r3, #0
  10a0c8:	1a00000c 	bne	10a100 <fdt_fd_release+0x13c>
    {
        struct dfs_fnode *fnode = fd_slot->fnode;
  10a0cc:	e51b3008 	ldr	r3, [fp, #-8]
  10a0d0:	e5933018 	ldr	r3, [r3, #24]
  10a0d4:	e50b300c 	str	r3, [fp, #-12]
        if (fnode)
  10a0d8:	e51b300c 	ldr	r3, [fp, #-12]
  10a0dc:	e3530000 	cmp	r3, #0
  10a0e0:	0a000004 	beq	10a0f8 <fdt_fd_release+0x134>
        {
            fnode->ref_count--;
  10a0e4:	e51b300c 	ldr	r3, [fp, #-12]
  10a0e8:	e593300c 	ldr	r3, [r3, #12]
  10a0ec:	e2432001 	sub	r2, r3, #1
  10a0f0:	e51b300c 	ldr	r3, [fp, #-12]
  10a0f4:	e583200c 	str	r2, [r3, #12]
        }
        rt_free(fd_slot);
  10a0f8:	e51b0008 	ldr	r0, [fp, #-8]
  10a0fc:	ebffe3ae 	bl	102fbc <rt_free>
    }
    dfs_fd_unlock();
  10a100:	ebfffeb0 	bl	109bc8 <dfs_fd_unlock>
}
  10a104:	e24bd004 	sub	sp, fp, #4
  10a108:	e8bd8800 	pop	{fp, pc}

0010a10c <fd_release>:

void fd_release(int fd)
{
  10a10c:	e92d4800 	push	{fp, lr}
  10a110:	e28db004 	add	fp, sp, #4
  10a114:	e24dd010 	sub	sp, sp, #16
  10a118:	e50b0010 	str	r0, [fp, #-16]
    struct dfs_fdtable *fdt;

    fdt = dfs_fdtable_get();
  10a11c:	eb000006 	bl	10a13c <dfs_fdtable_get>
  10a120:	e50b0008 	str	r0, [fp, #-8]
    fdt_fd_release(fdt, fd);
  10a124:	e51b1010 	ldr	r1, [fp, #-16]
  10a128:	e51b0008 	ldr	r0, [fp, #-8]
  10a12c:	ebffffa4 	bl	109fc4 <fdt_fd_release>
}
  10a130:	e320f000 	nop	{0}
  10a134:	e24bd004 	sub	sp, fp, #4
  10a138:	e8bd8800 	pop	{fp, pc}

0010a13c <dfs_fdtable_get>:

/**
 * This function will get the file descriptor table of current process.
 */
struct dfs_fdtable *dfs_fdtable_get(void)
{
  10a13c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10a140:	e28db000 	add	fp, sp, #0
    return &_fdtab;
  10a144:	e30e3610 	movw	r3, #58896	; 0xe610
  10a148:	e3403014 	movt	r3, #20
}
  10a14c:	e1a00003 	mov	r0, r3
  10a150:	e28bd000 	add	sp, fp, #0
  10a154:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10a158:	e12fff1e 	bx	lr

0010a15c <rt_list_init>:
{
  10a15c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10a160:	e28db000 	add	fp, sp, #0
  10a164:	e24dd00c 	sub	sp, sp, #12
  10a168:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
  10a16c:	e51b3008 	ldr	r3, [fp, #-8]
  10a170:	e51b2008 	ldr	r2, [fp, #-8]
  10a174:	e5832004 	str	r2, [r3, #4]
  10a178:	e51b3008 	ldr	r3, [fp, #-8]
  10a17c:	e5932004 	ldr	r2, [r3, #4]
  10a180:	e51b3008 	ldr	r3, [fp, #-8]
  10a184:	e5832000 	str	r2, [r3]
}
  10a188:	e320f000 	nop	{0}
  10a18c:	e28bd000 	add	sp, fp, #0
  10a190:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10a194:	e12fff1e 	bx	lr

0010a198 <dfs_fnode_mgr_init>:
};

static struct dfs_fnode_mgr dfs_fm;

void dfs_fnode_mgr_init(void)
{
  10a198:	e92d4800 	push	{fp, lr}
  10a19c:	e28db004 	add	fp, sp, #4
  10a1a0:	e24dd008 	sub	sp, sp, #8
    int i = 0;
  10a1a4:	e3a03000 	mov	r3, #0
  10a1a8:	e50b3008 	str	r3, [fp, #-8]

    rt_mutex_init(&dfs_fm.lock, "dfs_mgr", RT_IPC_FLAG_PRIO);
  10a1ac:	e3a02001 	mov	r2, #1
  10a1b0:	e3061474 	movw	r1, #25716	; 0x6474
  10a1b4:	e3401014 	movt	r1, #20
  10a1b8:	e30e061c 	movw	r0, #58908	; 0xe61c
  10a1bc:	e3400014 	movt	r0, #20
  10a1c0:	ebffdae0 	bl	100d48 <rt_mutex_init>
    for (i = 0; i < DFS_FNODE_HASH_NR; i++)
  10a1c4:	e3a03000 	mov	r3, #0
  10a1c8:	e50b3008 	str	r3, [fp, #-8]
  10a1cc:	ea00000a 	b	10a1fc <dfs_fnode_mgr_init+0x64>
    {
        rt_list_init(&dfs_fm.head[i]);
  10a1d0:	e51b3008 	ldr	r3, [fp, #-8]
  10a1d4:	e2833005 	add	r3, r3, #5
  10a1d8:	e1a02183 	lsl	r2, r3, #3
  10a1dc:	e30e361c 	movw	r3, #58908	; 0xe61c
  10a1e0:	e3403014 	movt	r3, #20
  10a1e4:	e0823003 	add	r3, r2, r3
  10a1e8:	e1a00003 	mov	r0, r3
  10a1ec:	ebffffda 	bl	10a15c <rt_list_init>
    for (i = 0; i < DFS_FNODE_HASH_NR; i++)
  10a1f0:	e51b3008 	ldr	r3, [fp, #-8]
  10a1f4:	e2833001 	add	r3, r3, #1
  10a1f8:	e50b3008 	str	r3, [fp, #-8]
  10a1fc:	e51b3008 	ldr	r3, [fp, #-8]
  10a200:	e353007f 	cmp	r3, #127	; 0x7f
  10a204:	dafffff1 	ble	10a1d0 <dfs_fnode_mgr_init+0x38>
    }
  10a208:	e320f000 	nop	{0}
  10a20c:	e24bd004 	sub	sp, fp, #4
  10a210:	e8bd8800 	pop	{fp, pc}

0010a214 <dfs_net_getsocket>:
#include "dfs.h"
#include "dfs_net.h"
#include "../netdev/sal_socket.h"

int dfs_net_getsocket(int fd)
{
  10a214:	e92d4800 	push	{fp, lr}
  10a218:	e28db004 	add	fp, sp, #4
  10a21c:	e24dd010 	sub	sp, sp, #16
  10a220:	e50b0010 	str	r0, [fp, #-16]
    int socket;
    struct dfs_fd *_dfs_fd;

    _dfs_fd = fd_get(fd);
  10a224:	e51b0010 	ldr	r0, [fp, #-16]
  10a228:	ebffff58 	bl	109f90 <fd_get>
  10a22c:	e50b000c 	str	r0, [fp, #-12]
    if (_dfs_fd == NULL) return -1;
  10a230:	e51b300c 	ldr	r3, [fp, #-12]
  10a234:	e3530000 	cmp	r3, #0
  10a238:	1a000001 	bne	10a244 <dfs_net_getsocket+0x30>
  10a23c:	e3e03000 	mvn	r3, #0
  10a240:	ea00000c 	b	10a278 <dfs_net_getsocket+0x64>

    if (_dfs_fd->fnode->type != FT_SOCKET) socket = -1;
  10a244:	e51b300c 	ldr	r3, [fp, #-12]
  10a248:	e5933018 	ldr	r3, [r3, #24]
  10a24c:	e1d330b0 	ldrh	r3, [r3]
  10a250:	e3530001 	cmp	r3, #1
  10a254:	0a000002 	beq	10a264 <dfs_net_getsocket+0x50>
  10a258:	e3e03000 	mvn	r3, #0
  10a25c:	e50b3008 	str	r3, [fp, #-8]
  10a260:	ea000003 	b	10a274 <dfs_net_getsocket+0x60>
    else socket = (int)(size_t)_dfs_fd->fnode->data;
  10a264:	e51b300c 	ldr	r3, [fp, #-12]
  10a268:	e5933018 	ldr	r3, [r3, #24]
  10a26c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  10a270:	e50b3008 	str	r3, [fp, #-8]

    return socket;
  10a274:	e51b3008 	ldr	r3, [fp, #-8]
}
  10a278:	e1a00003 	mov	r0, r3
  10a27c:	e24bd004 	sub	sp, fp, #4
  10a280:	e8bd8800 	pop	{fp, pc}

0010a284 <dfs_net_ioctl>:

static int dfs_net_ioctl(struct dfs_fd* file, int cmd, void* args)
{
  10a284:	e92d4800 	push	{fp, lr}
  10a288:	e28db004 	add	fp, sp, #4
  10a28c:	e24dd018 	sub	sp, sp, #24
  10a290:	e50b0010 	str	r0, [fp, #-16]
  10a294:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10a298:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    int ret;
    int socket = (int)(size_t)file->fnode->data;
  10a29c:	e51b3010 	ldr	r3, [fp, #-16]
  10a2a0:	e5933018 	ldr	r3, [r3, #24]
  10a2a4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  10a2a8:	e50b3008 	str	r3, [fp, #-8]

    ret = sal_ioctlsocket(socket, cmd, args);
  10a2ac:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  10a2b0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10a2b4:	e51b0008 	ldr	r0, [fp, #-8]
  10a2b8:	ebfff8e6 	bl	108658 <sal_ioctlsocket>
  10a2bc:	e50b000c 	str	r0, [fp, #-12]
    if (ret < 0)
  10a2c0:	e51b300c 	ldr	r3, [fp, #-12]
  10a2c4:	e3530000 	cmp	r3, #0
  10a2c8:	aa000006 	bge	10a2e8 <dfs_net_ioctl+0x64>
    {
        ret = rt_get_errno();
  10a2cc:	ebffdf62 	bl	10205c <rt_get_errno>
  10a2d0:	e50b000c 	str	r0, [fp, #-12]
        return (ret > 0) ? (-ret) : ret;
  10a2d4:	e51b300c 	ldr	r3, [fp, #-12]
  10a2d8:	e3530000 	cmp	r3, #0
  10a2dc:	b2633000 	rsblt	r3, r3, #0
  10a2e0:	e2633000 	rsb	r3, r3, #0
  10a2e4:	ea000000 	b	10a2ec <dfs_net_ioctl+0x68>
    }
    return ret;
  10a2e8:	e51b300c 	ldr	r3, [fp, #-12]
}
  10a2ec:	e1a00003 	mov	r0, r3
  10a2f0:	e24bd004 	sub	sp, fp, #4
  10a2f4:	e8bd8800 	pop	{fp, pc}

0010a2f8 <dfs_net_read>:

static int dfs_net_read(struct dfs_fd* file, void *buf, size_t count)
{
  10a2f8:	e92d4800 	push	{fp, lr}
  10a2fc:	e28db004 	add	fp, sp, #4
  10a300:	e24dd020 	sub	sp, sp, #32
  10a304:	e50b0010 	str	r0, [fp, #-16]
  10a308:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10a30c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    int ret;
    int socket = (int)(size_t)file->fnode->data;
  10a310:	e51b3010 	ldr	r3, [fp, #-16]
  10a314:	e5933018 	ldr	r3, [r3, #24]
  10a318:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  10a31c:	e50b3008 	str	r3, [fp, #-8]

    ret = sal_recvfrom(socket, buf, count, 0, NULL, NULL);
  10a320:	e3a03000 	mov	r3, #0
  10a324:	e58d3004 	str	r3, [sp, #4]
  10a328:	e3a03000 	mov	r3, #0
  10a32c:	e58d3000 	str	r3, [sp]
  10a330:	e3a03000 	mov	r3, #0
  10a334:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  10a338:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10a33c:	e51b0008 	ldr	r0, [fp, #-8]
  10a340:	ebfff7dd 	bl	1082bc <sal_recvfrom>
  10a344:	e50b000c 	str	r0, [fp, #-12]
    if (ret < 0)
  10a348:	e51b300c 	ldr	r3, [fp, #-12]
  10a34c:	e3530000 	cmp	r3, #0
  10a350:	aa000006 	bge	10a370 <dfs_net_read+0x78>
    {
        ret = rt_get_errno();
  10a354:	ebffdf40 	bl	10205c <rt_get_errno>
  10a358:	e50b000c 	str	r0, [fp, #-12]
        return (ret > 0) ? (-ret) : ret;
  10a35c:	e51b300c 	ldr	r3, [fp, #-12]
  10a360:	e3530000 	cmp	r3, #0
  10a364:	b2633000 	rsblt	r3, r3, #0
  10a368:	e2633000 	rsb	r3, r3, #0
  10a36c:	ea000000 	b	10a374 <dfs_net_read+0x7c>
    }
    return ret;
  10a370:	e51b300c 	ldr	r3, [fp, #-12]
}
  10a374:	e1a00003 	mov	r0, r3
  10a378:	e24bd004 	sub	sp, fp, #4
  10a37c:	e8bd8800 	pop	{fp, pc}

0010a380 <dfs_net_write>:

static int dfs_net_write(struct dfs_fd *file, const void *buf, size_t count)
{
  10a380:	e92d4800 	push	{fp, lr}
  10a384:	e28db004 	add	fp, sp, #4
  10a388:	e24dd020 	sub	sp, sp, #32
  10a38c:	e50b0010 	str	r0, [fp, #-16]
  10a390:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10a394:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    int ret;
    int socket = (int)(size_t)file->fnode->data;
  10a398:	e51b3010 	ldr	r3, [fp, #-16]
  10a39c:	e5933018 	ldr	r3, [r3, #24]
  10a3a0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  10a3a4:	e50b3008 	str	r3, [fp, #-8]
    
    ret = sal_sendto(socket, buf, count, 0, NULL, 0);
  10a3a8:	e3a03000 	mov	r3, #0
  10a3ac:	e58d3004 	str	r3, [sp, #4]
  10a3b0:	e3a03000 	mov	r3, #0
  10a3b4:	e58d3000 	str	r3, [sp]
  10a3b8:	e3a03000 	mov	r3, #0
  10a3bc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  10a3c0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10a3c4:	e51b0008 	ldr	r0, [fp, #-8]
  10a3c8:	ebfff7ef 	bl	10838c <sal_sendto>
  10a3cc:	e50b000c 	str	r0, [fp, #-12]
    if (ret < 0)
  10a3d0:	e51b300c 	ldr	r3, [fp, #-12]
  10a3d4:	e3530000 	cmp	r3, #0
  10a3d8:	aa000006 	bge	10a3f8 <dfs_net_write+0x78>
    {
        ret = rt_get_errno();
  10a3dc:	ebffdf1e 	bl	10205c <rt_get_errno>
  10a3e0:	e50b000c 	str	r0, [fp, #-12]
        return (ret > 0) ? (-ret) : ret;
  10a3e4:	e51b300c 	ldr	r3, [fp, #-12]
  10a3e8:	e3530000 	cmp	r3, #0
  10a3ec:	b2633000 	rsblt	r3, r3, #0
  10a3f0:	e2633000 	rsb	r3, r3, #0
  10a3f4:	ea000000 	b	10a3fc <dfs_net_write+0x7c>
    }
    return ret;
  10a3f8:	e51b300c 	ldr	r3, [fp, #-12]
}
  10a3fc:	e1a00003 	mov	r0, r3
  10a400:	e24bd004 	sub	sp, fp, #4
  10a404:	e8bd8800 	pop	{fp, pc}

0010a408 <dfs_net_close>:
static int dfs_net_close(struct dfs_fd* file)
{
  10a408:	e92d4800 	push	{fp, lr}
  10a40c:	e28db004 	add	fp, sp, #4
  10a410:	e24dd010 	sub	sp, sp, #16
  10a414:	e50b0010 	str	r0, [fp, #-16]
    int socket;
    int ret = 0;
  10a418:	e3a03000 	mov	r3, #0
  10a41c:	e50b3008 	str	r3, [fp, #-8]

    if (file->fnode->ref_count == 1)
  10a420:	e51b3010 	ldr	r3, [fp, #-16]
  10a424:	e5933018 	ldr	r3, [r3, #24]
  10a428:	e593300c 	ldr	r3, [r3, #12]
  10a42c:	e3530001 	cmp	r3, #1
  10a430:	1a000006 	bne	10a450 <dfs_net_close+0x48>
    {
        socket = (int)(size_t)file->fnode->data;
  10a434:	e51b3010 	ldr	r3, [fp, #-16]
  10a438:	e5933018 	ldr	r3, [r3, #24]
  10a43c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  10a440:	e50b300c 	str	r3, [fp, #-12]
        ret = sal_closesocket(socket);
  10a444:	e51b000c 	ldr	r0, [fp, #-12]
  10a448:	ebfff854 	bl	1085a0 <sal_closesocket>
  10a44c:	e50b0008 	str	r0, [fp, #-8]
    }
    return ret;
  10a450:	e51b3008 	ldr	r3, [fp, #-8]
}
  10a454:	e1a00003 	mov	r0, r3
  10a458:	e24bd004 	sub	sp, fp, #4
  10a45c:	e8bd8800 	pop	{fp, pc}

0010a460 <dfs_net_poll>:

static int dfs_net_poll(struct dfs_fd *file, struct rt_pollreq *req)
{
  10a460:	e92d4800 	push	{fp, lr}
  10a464:	e28db004 	add	fp, sp, #4
  10a468:	e24dd008 	sub	sp, sp, #8
  10a46c:	e50b0008 	str	r0, [fp, #-8]
  10a470:	e50b100c 	str	r1, [fp, #-12]
    extern int sal_poll(struct dfs_fd *file, struct rt_pollreq *req);

    return sal_poll(file, req);
  10a474:	e51b100c 	ldr	r1, [fp, #-12]
  10a478:	e51b0008 	ldr	r0, [fp, #-8]
  10a47c:	ebfff911 	bl	1088c8 <sal_poll>
  10a480:	e1a03000 	mov	r3, r0
}
  10a484:	e1a00003 	mov	r0, r3
  10a488:	e24bd004 	sub	sp, fp, #4
  10a48c:	e8bd8800 	pop	{fp, pc}

0010a490 <dfs_net_get_fops>:
    dfs_net_write,
    dfs_net_poll,
};

const struct dfs_file_ops *dfs_net_get_fops(void)
{
  10a490:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10a494:	e28db000 	add	fp, sp, #0
    return &_net_fops;
  10a498:	e306347c 	movw	r3, #25724	; 0x647c
  10a49c:	e3403014 	movt	r3, #20
}
  10a4a0:	e1a00003 	mov	r0, r3
  10a4a4:	e28bd000 	add	sp, fp, #0
  10a4a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10a4ac:	e12fff1e 	bx	lr

0010a4b0 <tcpip_init_done_callback>:

/*
 * Initialize the ethernetif layer and set network interface device up
 */
static void tcpip_init_done_callback(void *arg)
{
  10a4b0:	e92d4800 	push	{fp, lr}
  10a4b4:	e28db004 	add	fp, sp, #4
  10a4b8:	e24dd008 	sub	sp, sp, #8
  10a4bc:	e50b0008 	str	r0, [fp, #-8]
    rt_sem_release((rt_sem_t)arg);
  10a4c0:	e51b0008 	ldr	r0, [fp, #-8]
  10a4c4:	ebffdb5e 	bl	101244 <rt_sem_release>
}
  10a4c8:	e320f000 	nop	{0}
  10a4cc:	e24bd004 	sub	sp, fp, #4
  10a4d0:	e8bd8800 	pop	{fp, pc}

0010a4d4 <lwip_system_init>:
/**
 * LwIP system initialization
 */
extern int eth_system_device_init_private(void);
int lwip_system_init(void)
{
  10a4d4:	e92d4800 	push	{fp, lr}
  10a4d8:	e28db004 	add	fp, sp, #4
  10a4dc:	e24dd010 	sub	sp, sp, #16
    struct rt_semaphore *done_sem;
    static rt_bool_t init_ok = RT_FALSE;

    if (init_ok)
  10a4e0:	e30e3a4c 	movw	r3, #59980	; 0xea4c
  10a4e4:	e3403014 	movt	r3, #20
  10a4e8:	e5933000 	ldr	r3, [r3]
  10a4ec:	e3530000 	cmp	r3, #0
  10a4f0:	0a000004 	beq	10a508 <lwip_system_init+0x34>
    {
        rt_kprintf("lwip system already init.\n");
  10a4f4:	e3060490 	movw	r0, #25744	; 0x6490
  10a4f8:	e3400014 	movt	r0, #20
  10a4fc:	ebffe304 	bl	103114 <rt_kprintf>
        return 0;
  10a500:	e3a03000 	mov	r3, #0
  10a504:	ea00003c 	b	10a5fc <lwip_system_init+0x128>
    }

    eth_system_device_init_private();
  10a508:	eb007e94 	bl	129f60 <eth_system_device_init_private>

    /* set default netif to NULL */
    netif_default = RT_NULL;
  10a50c:	e3063838 	movw	r3, #26680	; 0x6838
  10a510:	e3403057 	movt	r3, #87	; 0x57
  10a514:	e3a02000 	mov	r2, #0
  10a518:	e5832000 	str	r2, [r3]
    done_sem = rt_sem_create("done", 0, RT_IPC_FLAG_FIFO);
  10a51c:	e3a02000 	mov	r2, #0
  10a520:	e3a01000 	mov	r1, #0
  10a524:	e30604ac 	movw	r0, #25772	; 0x64ac
  10a528:	e3400014 	movt	r0, #20
  10a52c:	ebffdaad 	bl	100fe8 <rt_sem_create>
  10a530:	e50b0008 	str	r0, [fp, #-8]

    if (done_sem == RT_NULL)
  10a534:	e51b3008 	ldr	r3, [fp, #-8]
  10a538:	e3530000 	cmp	r3, #0
  10a53c:	1a000008 	bne	10a564 <lwip_system_init+0x90>
    {
        LWIP_ASSERT("Failed to create semaphore", 0);
  10a540:	e30604b4 	movw	r0, #25780	; 0x64b4
  10a544:	e3400014 	movt	r0, #20
  10a548:	ebffe2f1 	bl	103114 <rt_kprintf>
  10a54c:	e3a0105e 	mov	r1, #94	; 0x5e
  10a550:	e30604d0 	movw	r0, #25808	; 0x64d0
  10a554:	e3400014 	movt	r0, #20
  10a558:	eb0002c7 	bl	10b07c <sys_arch_assert>

        return -1;
  10a55c:	e3e03000 	mvn	r3, #0
  10a560:	ea000025 	b	10a5fc <lwip_system_init+0x128>
    }

    tcpip_init(tcpip_init_done_callback, (void *)done_sem);
  10a564:	e51b1008 	ldr	r1, [fp, #-8]
  10a568:	e30a04b0 	movw	r0, #42160	; 0xa4b0
  10a56c:	e3400010 	movt	r0, #16
  10a570:	eb00303e 	bl	116670 <tcpip_init>

    /* waiting for initialization done */
    if (rt_sem_take(done_sem, RT_WAITING_FOREVER) != RT_EOK)
  10a574:	e3e01000 	mvn	r1, #0
  10a578:	e51b0008 	ldr	r0, [fp, #-8]
  10a57c:	ebffdb4c 	bl	1012b4 <rt_sem_take>
  10a580:	e1a03000 	mov	r3, r0
  10a584:	e3530000 	cmp	r3, #0
  10a588:	0a000003 	beq	10a59c <lwip_system_init+0xc8>
    {
        rt_sem_delete(done_sem);
  10a58c:	e51b0008 	ldr	r0, [fp, #-8]
  10a590:	ebffdadf 	bl	101114 <rt_sem_delete>

        return -1;
  10a594:	e3e03000 	mvn	r3, #0
  10a598:	ea000017 	b	10a5fc <lwip_system_init+0x128>
    }
    rt_sem_delete(done_sem);
  10a59c:	e51b0008 	ldr	r0, [fp, #-8]
  10a5a0:	ebffdadb 	bl	101114 <rt_sem_delete>

        netifapi_netif_set_addr(netif_default, &ipaddr, &netmask, &gw);
    }
#endif

    rt_thread_t tid = rt_thread_create("tcpip_mb_timer", tcpip_mb_timer_entry, NULL, 1024, 25, 10); 
  10a5a4:	e3a0300a 	mov	r3, #10
  10a5a8:	e58d3004 	str	r3, [sp, #4]
  10a5ac:	e3a03019 	mov	r3, #25
  10a5b0:	e58d3000 	str	r3, [sp]
  10a5b4:	e3a03b01 	mov	r3, #1024	; 0x400
  10a5b8:	e3a02000 	mov	r2, #0
  10a5bc:	e30a1ac8 	movw	r1, #43720	; 0xaac8
  10a5c0:	e3401010 	movt	r1, #16
  10a5c4:	e3060500 	movw	r0, #25856	; 0x6500
  10a5c8:	e3400014 	movt	r0, #20
  10a5cc:	ebffdec8 	bl	1020f4 <rt_thread_create>
  10a5d0:	e50b000c 	str	r0, [fp, #-12]
    if (tid) rt_thread_startup(tid);
  10a5d4:	e51b300c 	ldr	r3, [fp, #-12]
  10a5d8:	e3530000 	cmp	r3, #0
  10a5dc:	0a000001 	beq	10a5e8 <lwip_system_init+0x114>
  10a5e0:	e51b000c 	ldr	r0, [fp, #-12]
  10a5e4:	ebffdef7 	bl	1021c8 <rt_thread_startup>

    init_ok = RT_TRUE;
  10a5e8:	e30e3a4c 	movw	r3, #59980	; 0xea4c
  10a5ec:	e3403014 	movt	r3, #20
  10a5f0:	e3a02001 	mov	r2, #1
  10a5f4:	e5832000 	str	r2, [r3]

    return 0;
  10a5f8:	e3a03000 	mov	r3, #0
}
  10a5fc:	e1a00003 	mov	r0, r3
  10a600:	e24bd004 	sub	sp, fp, #4
  10a604:	e8bd8800 	pop	{fp, pc}

0010a608 <sys_init>:

void sys_init(void)
{
  10a608:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10a60c:	e28db000 	add	fp, sp, #0
    /* nothing on RT-Thread porting */
}
  10a610:	e320f000 	nop	{0}
  10a614:	e28bd000 	add	sp, fp, #0
  10a618:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10a61c:	e12fff1e 	bx	lr

0010a620 <lwip_sys_init>:

void lwip_sys_init(void)
{
  10a620:	e92d4800 	push	{fp, lr}
  10a624:	e28db004 	add	fp, sp, #4
    lwip_system_init();
  10a628:	ebffffa9 	bl	10a4d4 <lwip_system_init>
}
  10a62c:	e320f000 	nop	{0}
  10a630:	e8bd8800 	pop	{fp, pc}

0010a634 <sys_sem_new>:
 * Create a new semaphore
 *
 * @return the operation status, ERR_OK on OK; others on error
 */
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
  10a634:	e92d4800 	push	{fp, lr}
  10a638:	e28db004 	add	fp, sp, #4
  10a63c:	e24dd020 	sub	sp, sp, #32
  10a640:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10a644:	e1a03001 	mov	r3, r1
  10a648:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    char tname[RT_NAME_MAX];
    sys_sem_t tmpsem;

    RT_DEBUG_NOT_IN_INTERRUPT;

    rt_snprintf(tname, RT_NAME_MAX, "%s%d", SYS_LWIP_SEM_NAME, counter);
  10a64c:	e30e3a50 	movw	r3, #59984	; 0xea50
  10a650:	e3403014 	movt	r3, #20
  10a654:	e1d330b0 	ldrh	r3, [r3]
  10a658:	e24b0010 	sub	r0, fp, #16
  10a65c:	e58d3000 	str	r3, [sp]
  10a660:	e3063510 	movw	r3, #25872	; 0x6510
  10a664:	e3403014 	movt	r3, #20
  10a668:	e3062514 	movw	r2, #25876	; 0x6514
  10a66c:	e3402014 	movt	r2, #20
  10a670:	e3a01008 	mov	r1, #8
  10a674:	ebffe270 	bl	10303c <rt_snprintf>
    counter ++;
  10a678:	e30e3a50 	movw	r3, #59984	; 0xea50
  10a67c:	e3403014 	movt	r3, #20
  10a680:	e1d330b0 	ldrh	r3, [r3]
  10a684:	e2833001 	add	r3, r3, #1
  10a688:	e6ff2073 	uxth	r2, r3
  10a68c:	e30e3a50 	movw	r3, #59984	; 0xea50
  10a690:	e3403014 	movt	r3, #20
  10a694:	e1c320b0 	strh	r2, [r3]

    tmpsem = rt_sem_create(tname, count, RT_IPC_FLAG_FIFO);
  10a698:	e55b1019 	ldrb	r1, [fp, #-25]	; 0xffffffe7
  10a69c:	e24b3010 	sub	r3, fp, #16
  10a6a0:	e3a02000 	mov	r2, #0
  10a6a4:	e1a00003 	mov	r0, r3
  10a6a8:	ebffda4e 	bl	100fe8 <rt_sem_create>
  10a6ac:	e50b0008 	str	r0, [fp, #-8]
    if (tmpsem == RT_NULL)
  10a6b0:	e51b3008 	ldr	r3, [fp, #-8]
  10a6b4:	e3530000 	cmp	r3, #0
  10a6b8:	1a000001 	bne	10a6c4 <sys_sem_new+0x90>
        return ERR_MEM;
  10a6bc:	e3e03000 	mvn	r3, #0
  10a6c0:	ea000003 	b	10a6d4 <sys_sem_new+0xa0>
    else
    {
        *sem = tmpsem;
  10a6c4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10a6c8:	e51b2008 	ldr	r2, [fp, #-8]
  10a6cc:	e5832000 	str	r2, [r3]

        return ERR_OK;
  10a6d0:	e3a03000 	mov	r3, #0
    }
}
  10a6d4:	e1a00003 	mov	r0, r3
  10a6d8:	e24bd004 	sub	sp, fp, #4
  10a6dc:	e8bd8800 	pop	{fp, pc}

0010a6e0 <sys_sem_free>:

/*
 * Deallocate a semaphore
 */
void sys_sem_free(sys_sem_t *sem)
{
  10a6e0:	e92d4800 	push	{fp, lr}
  10a6e4:	e28db004 	add	fp, sp, #4
  10a6e8:	e24dd008 	sub	sp, sp, #8
  10a6ec:	e50b0008 	str	r0, [fp, #-8]
    RT_DEBUG_NOT_IN_INTERRUPT;
    rt_sem_delete(*sem);
  10a6f0:	e51b3008 	ldr	r3, [fp, #-8]
  10a6f4:	e5933000 	ldr	r3, [r3]
  10a6f8:	e1a00003 	mov	r0, r3
  10a6fc:	ebffda84 	bl	101114 <rt_sem_delete>
}
  10a700:	e320f000 	nop	{0}
  10a704:	e24bd004 	sub	sp, fp, #4
  10a708:	e8bd8800 	pop	{fp, pc}

0010a70c <sys_sem_signal>:

/*
 * Signal a semaphore
 */
void sys_sem_signal(sys_sem_t *sem)
{
  10a70c:	e92d4800 	push	{fp, lr}
  10a710:	e28db004 	add	fp, sp, #4
  10a714:	e24dd008 	sub	sp, sp, #8
  10a718:	e50b0008 	str	r0, [fp, #-8]
    rt_sem_release(*sem);
  10a71c:	e51b3008 	ldr	r3, [fp, #-8]
  10a720:	e5933000 	ldr	r3, [r3]
  10a724:	e1a00003 	mov	r0, r3
  10a728:	ebffdac5 	bl	101244 <rt_sem_release>
}
  10a72c:	e320f000 	nop	{0}
  10a730:	e24bd004 	sub	sp, fp, #4
  10a734:	e8bd8800 	pop	{fp, pc}

0010a738 <sys_arch_sem_wait>:
 *         spent waiting for the semaphore to be signaled; If the semaphore isn't signaled
 *         within the specified time, it will return SYS_ARCH_TIMEOUT; If the thread doesn't
 *         wait for the semaphore, it will return zero
 */
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
  10a738:	e92d4800 	push	{fp, lr}
  10a73c:	e28db004 	add	fp, sp, #4
  10a740:	e24dd018 	sub	sp, sp, #24
  10a744:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10a748:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    u32_t tick;

    RT_DEBUG_NOT_IN_INTERRUPT;

    /* get the begin tick */
    tick = rt_tick_get();
  10a74c:	ebffddc3 	bl	101e60 <rt_tick_get>
  10a750:	e50b000c 	str	r0, [fp, #-12]
    if (timeout == 0)
  10a754:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10a758:	e3530000 	cmp	r3, #0
  10a75c:	1a000002 	bne	10a76c <sys_arch_sem_wait+0x34>
        t = RT_WAITING_FOREVER;
  10a760:	e3e03000 	mvn	r3, #0
  10a764:	e50b3008 	str	r3, [fp, #-8]
  10a768:	ea000007 	b	10a78c <sys_arch_sem_wait+0x54>
    else
    {
        /* convert msecond to os tick */
        if (timeout < (1000/RT_TICK_PER_SECOND))
  10a76c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10a770:	e3530000 	cmp	r3, #0
  10a774:	1a000002 	bne	10a784 <sys_arch_sem_wait+0x4c>
            t = 1;
  10a778:	e3a03001 	mov	r3, #1
  10a77c:	e50b3008 	str	r3, [fp, #-8]
  10a780:	ea000001 	b	10a78c <sys_arch_sem_wait+0x54>
        else
            t = timeout / (1000/RT_TICK_PER_SECOND);
  10a784:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10a788:	e50b3008 	str	r3, [fp, #-8]
    }

    ret = rt_sem_take(*sem, t);
  10a78c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10a790:	e5933000 	ldr	r3, [r3]
  10a794:	e51b1008 	ldr	r1, [fp, #-8]
  10a798:	e1a00003 	mov	r0, r3
  10a79c:	ebffdac4 	bl	1012b4 <rt_sem_take>
  10a7a0:	e50b0010 	str	r0, [fp, #-16]

    if (ret == -RT_ETIMEOUT)
  10a7a4:	e51b3010 	ldr	r3, [fp, #-16]
  10a7a8:	e3730002 	cmn	r3, #2
  10a7ac:	1a000001 	bne	10a7b8 <sys_arch_sem_wait+0x80>
        return SYS_ARCH_TIMEOUT;
  10a7b0:	e3e03000 	mvn	r3, #0
  10a7b4:	ea00000f 	b	10a7f8 <sys_arch_sem_wait+0xc0>
    else
    {
        if (ret == RT_EOK)
  10a7b8:	e51b3010 	ldr	r3, [fp, #-16]
  10a7bc:	e3530000 	cmp	r3, #0
  10a7c0:	1a000001 	bne	10a7cc <sys_arch_sem_wait+0x94>
            ret = 1;
  10a7c4:	e3a03001 	mov	r3, #1
  10a7c8:	e50b3010 	str	r3, [fp, #-16]
    }

    /* get elapse msecond */
    tick = rt_tick_get() - tick;
  10a7cc:	ebffdda3 	bl	101e60 <rt_tick_get>
  10a7d0:	e1a02000 	mov	r2, r0
  10a7d4:	e51b300c 	ldr	r3, [fp, #-12]
  10a7d8:	e0423003 	sub	r3, r2, r3
  10a7dc:	e50b300c 	str	r3, [fp, #-12]

    /* convert tick to msecond */
    tick = tick * (1000 / RT_TICK_PER_SECOND);
    if (tick == 0)
  10a7e0:	e51b300c 	ldr	r3, [fp, #-12]
  10a7e4:	e3530000 	cmp	r3, #0
  10a7e8:	1a000001 	bne	10a7f4 <sys_arch_sem_wait+0xbc>
        tick = 1;
  10a7ec:	e3a03001 	mov	r3, #1
  10a7f0:	e50b300c 	str	r3, [fp, #-12]

    return tick;
  10a7f4:	e51b300c 	ldr	r3, [fp, #-12]
}
  10a7f8:	e1a00003 	mov	r0, r3
  10a7fc:	e24bd004 	sub	sp, fp, #4
  10a800:	e8bd8800 	pop	{fp, pc}

0010a804 <sys_sem_valid>:
#ifndef sys_sem_valid
/** Check if a semaphore is valid/allocated:
 *  return 1 for valid, 0 for invalid
 */
rt_ubase_t sys_sem_valid(sys_sem_t *sem)
{
  10a804:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10a808:	e28db000 	add	fp, sp, #0
  10a80c:	e24dd00c 	sub	sp, sp, #12
  10a810:	e50b0008 	str	r0, [fp, #-8]
    return (rt_ubase_t)(*sem);
  10a814:	e51b3008 	ldr	r3, [fp, #-8]
  10a818:	e5933000 	ldr	r3, [r3]
}
  10a81c:	e1a00003 	mov	r0, r3
  10a820:	e28bd000 	add	sp, fp, #0
  10a824:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10a828:	e12fff1e 	bx	lr

0010a82c <sys_sem_set_invalid>:

#ifndef sys_sem_set_invalid
/** Set a semaphore invalid so that sys_sem_valid returns 0
 */
void sys_sem_set_invalid(sys_sem_t *sem)
{
  10a82c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10a830:	e28db000 	add	fp, sp, #0
  10a834:	e24dd00c 	sub	sp, sp, #12
  10a838:	e50b0008 	str	r0, [fp, #-8]
    *sem = RT_NULL;
  10a83c:	e51b3008 	ldr	r3, [fp, #-8]
  10a840:	e3a02000 	mov	r2, #0
  10a844:	e5832000 	str	r2, [r3]
}
  10a848:	e320f000 	nop	{0}
  10a84c:	e28bd000 	add	sp, fp, #0
  10a850:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10a854:	e12fff1e 	bx	lr

0010a858 <sys_mutex_new>:
/** Create a new mutex
 * @param mutex pointer to the mutex to create
 * @return a new mutex
 */
err_t sys_mutex_new(sys_mutex_t *mutex)
{
  10a858:	e92d4800 	push	{fp, lr}
  10a85c:	e28db004 	add	fp, sp, #4
  10a860:	e24dd020 	sub	sp, sp, #32
  10a864:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    char tname[RT_NAME_MAX];
    sys_mutex_t tmpmutex;

    RT_DEBUG_NOT_IN_INTERRUPT;

    rt_snprintf(tname, RT_NAME_MAX, "%s%d", SYS_LWIP_MUTEX_NAME, counter);
  10a868:	e30e3a52 	movw	r3, #59986	; 0xea52
  10a86c:	e3403014 	movt	r3, #20
  10a870:	e1d330b0 	ldrh	r3, [r3]
  10a874:	e24b0010 	sub	r0, fp, #16
  10a878:	e58d3000 	str	r3, [sp]
  10a87c:	e306351c 	movw	r3, #25884	; 0x651c
  10a880:	e3403014 	movt	r3, #20
  10a884:	e3062514 	movw	r2, #25876	; 0x6514
  10a888:	e3402014 	movt	r2, #20
  10a88c:	e3a01008 	mov	r1, #8
  10a890:	ebffe1e9 	bl	10303c <rt_snprintf>
    counter ++;
  10a894:	e30e3a52 	movw	r3, #59986	; 0xea52
  10a898:	e3403014 	movt	r3, #20
  10a89c:	e1d330b0 	ldrh	r3, [r3]
  10a8a0:	e2833001 	add	r3, r3, #1
  10a8a4:	e6ff2073 	uxth	r2, r3
  10a8a8:	e30e3a52 	movw	r3, #59986	; 0xea52
  10a8ac:	e3403014 	movt	r3, #20
  10a8b0:	e1c320b0 	strh	r2, [r3]

    tmpmutex = rt_mutex_create(tname, RT_IPC_FLAG_FIFO);
  10a8b4:	e24b3010 	sub	r3, fp, #16
  10a8b8:	e3a01000 	mov	r1, #0
  10a8bc:	e1a00003 	mov	r0, r3
  10a8c0:	ebffd8f8 	bl	100ca8 <rt_mutex_create>
  10a8c4:	e50b0008 	str	r0, [fp, #-8]
    if (tmpmutex == RT_NULL)
  10a8c8:	e51b3008 	ldr	r3, [fp, #-8]
  10a8cc:	e3530000 	cmp	r3, #0
  10a8d0:	1a000001 	bne	10a8dc <sys_mutex_new+0x84>
        return ERR_MEM;
  10a8d4:	e3e03000 	mvn	r3, #0
  10a8d8:	ea000003 	b	10a8ec <sys_mutex_new+0x94>
    else
    {
        *mutex = tmpmutex;
  10a8dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10a8e0:	e51b2008 	ldr	r2, [fp, #-8]
  10a8e4:	e5832000 	str	r2, [r3]

        return ERR_OK;
  10a8e8:	e3a03000 	mov	r3, #0
    }
}
  10a8ec:	e1a00003 	mov	r0, r3
  10a8f0:	e24bd004 	sub	sp, fp, #4
  10a8f4:	e8bd8800 	pop	{fp, pc}

0010a8f8 <sys_mutex_lock>:

/** Lock a mutex
 * @param mutex the mutex to lock
 */
void sys_mutex_lock(sys_mutex_t *mutex)
{
  10a8f8:	e92d4800 	push	{fp, lr}
  10a8fc:	e28db004 	add	fp, sp, #4
  10a900:	e24dd008 	sub	sp, sp, #8
  10a904:	e50b0008 	str	r0, [fp, #-8]
    RT_DEBUG_NOT_IN_INTERRUPT;
    rt_mutex_take(*mutex, RT_WAITING_FOREVER);
  10a908:	e51b3008 	ldr	r3, [fp, #-8]
  10a90c:	e5933000 	ldr	r3, [r3]
  10a910:	e3e01000 	mvn	r1, #0
  10a914:	e1a00003 	mov	r0, r3
  10a918:	ebffd978 	bl	100f00 <rt_mutex_take>

    return;
  10a91c:	e320f000 	nop	{0}
}
  10a920:	e24bd004 	sub	sp, fp, #4
  10a924:	e8bd8800 	pop	{fp, pc}

0010a928 <sys_mutex_unlock>:

/** Unlock a mutex
 * @param mutex the mutex to unlock
 */
void sys_mutex_unlock(sys_mutex_t *mutex)
{
  10a928:	e92d4800 	push	{fp, lr}
  10a92c:	e28db004 	add	fp, sp, #4
  10a930:	e24dd008 	sub	sp, sp, #8
  10a934:	e50b0008 	str	r0, [fp, #-8]
    rt_mutex_release(*mutex);
  10a938:	e51b3008 	ldr	r3, [fp, #-8]
  10a93c:	e5933000 	ldr	r3, [r3]
  10a940:	e1a00003 	mov	r0, r3
  10a944:	ebffd98b 	bl	100f78 <rt_mutex_release>
}
  10a948:	e320f000 	nop	{0}
  10a94c:	e24bd004 	sub	sp, fp, #4
  10a950:	e8bd8800 	pop	{fp, pc}

0010a954 <sys_mutex_free>:

/** Delete a semaphore
 * @param mutex the mutex to delete
 */
void sys_mutex_free(sys_mutex_t *mutex)
{
  10a954:	e92d4800 	push	{fp, lr}
  10a958:	e28db004 	add	fp, sp, #4
  10a95c:	e24dd008 	sub	sp, sp, #8
  10a960:	e50b0008 	str	r0, [fp, #-8]
    RT_DEBUG_NOT_IN_INTERRUPT;

    rt_mutex_delete(*mutex);
  10a964:	e51b3008 	ldr	r3, [fp, #-8]
  10a968:	e5933000 	ldr	r3, [r3]
  10a96c:	e1a00003 	mov	r0, r3
  10a970:	ebffd916 	bl	100dd0 <rt_mutex_delete>
}
  10a974:	e320f000 	nop	{0}
  10a978:	e24bd004 	sub	sp, fp, #4
  10a97c:	e8bd8800 	pop	{fp, pc}

0010a980 <sys_mutex_valid>:
#ifndef sys_mutex_valid
/** Check if a mutex is valid/allocated:
 *  return 1 for valid, 0 for invalid
 */
rt_base_t sys_mutex_valid(sys_mutex_t *mutex)
{
  10a980:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10a984:	e28db000 	add	fp, sp, #0
  10a988:	e24dd00c 	sub	sp, sp, #12
  10a98c:	e50b0008 	str	r0, [fp, #-8]
    return (rt_base_t)(*mutex);
  10a990:	e51b3008 	ldr	r3, [fp, #-8]
  10a994:	e5933000 	ldr	r3, [r3]
}
  10a998:	e1a00003 	mov	r0, r3
  10a99c:	e28bd000 	add	sp, fp, #0
  10a9a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10a9a4:	e12fff1e 	bx	lr

0010a9a8 <sys_mutex_set_invalid>:

#ifndef sys_mutex_set_invalid
/** Set a mutex invalid so that sys_mutex_valid returns 0
 */
void sys_mutex_set_invalid(sys_mutex_t *mutex)
{
  10a9a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10a9ac:	e28db000 	add	fp, sp, #0
  10a9b0:	e24dd00c 	sub	sp, sp, #12
  10a9b4:	e50b0008 	str	r0, [fp, #-8]
    *mutex = RT_NULL;
  10a9b8:	e51b3008 	ldr	r3, [fp, #-8]
  10a9bc:	e3a02000 	mov	r2, #0
  10a9c0:	e5832000 	str	r2, [r3]
}
  10a9c4:	e320f000 	nop	{0}
  10a9c8:	e28bd000 	add	sp, fp, #0
  10a9cc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10a9d0:	e12fff1e 	bx	lr

0010a9d4 <list_insert>:
    struct mbbuf_list *next;
};

struct mbbuf_list head = {0, 0};
static void list_insert(rt_mailbox_buff_t new_mbbuf)
{
  10a9d4:	e92d4800 	push	{fp, lr}
  10a9d8:	e28db004 	add	fp, sp, #4
  10a9dc:	e24dd010 	sub	sp, sp, #16
  10a9e0:	e50b0010 	str	r0, [fp, #-16]
    struct mbbuf_list *cur = &head;
  10a9e4:	e30e3a44 	movw	r3, #59972	; 0xea44
  10a9e8:	e3403014 	movt	r3, #20
  10a9ec:	e50b3008 	str	r3, [fp, #-8]
    while (cur->next)
  10a9f0:	ea000002 	b	10aa00 <list_insert+0x2c>
    {
        cur = cur->next;
  10a9f4:	e51b3008 	ldr	r3, [fp, #-8]
  10a9f8:	e5933004 	ldr	r3, [r3, #4]
  10a9fc:	e50b3008 	str	r3, [fp, #-8]
    while (cur->next)
  10aa00:	e51b3008 	ldr	r3, [fp, #-8]
  10aa04:	e5933004 	ldr	r3, [r3, #4]
  10aa08:	e3530000 	cmp	r3, #0
  10aa0c:	1afffff8 	bne	10a9f4 <list_insert+0x20>
    }

    struct mbbuf_list *new_node = (struct mbbuf_list *)malloc(sizeof(struct mbbuf_list));
  10aa10:	e3a00008 	mov	r0, #8
  10aa14:	eb00cacd 	bl	13d550 <malloc>
  10aa18:	e1a03000 	mov	r3, r0
  10aa1c:	e50b300c 	str	r3, [fp, #-12]
    cur->next = new_node;
  10aa20:	e51b3008 	ldr	r3, [fp, #-8]
  10aa24:	e51b200c 	ldr	r2, [fp, #-12]
  10aa28:	e5832004 	str	r2, [r3, #4]
    new_node->next = RT_NULL;
  10aa2c:	e51b300c 	ldr	r3, [fp, #-12]
  10aa30:	e3a02000 	mov	r2, #0
  10aa34:	e5832004 	str	r2, [r3, #4]
    new_node->mbbuf = new_mbbuf;
  10aa38:	e51b300c 	ldr	r3, [fp, #-12]
  10aa3c:	e51b2010 	ldr	r2, [fp, #-16]
  10aa40:	e5832000 	str	r2, [r3]
}
  10aa44:	e320f000 	nop	{0}
  10aa48:	e24bd004 	sub	sp, fp, #4
  10aa4c:	e8bd8800 	pop	{fp, pc}

0010aa50 <list_del>:

static void list_del(rt_mailbox_buff_t del_mbbuf)
{
  10aa50:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10aa54:	e28db000 	add	fp, sp, #0
  10aa58:	e24dd014 	sub	sp, sp, #20
  10aa5c:	e50b0010 	str	r0, [fp, #-16]
    struct mbbuf_list *cur = &head;
  10aa60:	e30e3a44 	movw	r3, #59972	; 0xea44
  10aa64:	e3403014 	movt	r3, #20
  10aa68:	e50b3008 	str	r3, [fp, #-8]
    while (cur->next)
  10aa6c:	ea00000e 	b	10aaac <list_del+0x5c>
    {
        if (cur->next->mbbuf == del_mbbuf)
  10aa70:	e51b3008 	ldr	r3, [fp, #-8]
  10aa74:	e5933004 	ldr	r3, [r3, #4]
  10aa78:	e5933000 	ldr	r3, [r3]
  10aa7c:	e51b2010 	ldr	r2, [fp, #-16]
  10aa80:	e1520003 	cmp	r2, r3
  10aa84:	1a000005 	bne	10aaa0 <list_del+0x50>
        {
            cur->next = cur->next->next;
  10aa88:	e51b3008 	ldr	r3, [fp, #-8]
  10aa8c:	e5933004 	ldr	r3, [r3, #4]
  10aa90:	e5932004 	ldr	r2, [r3, #4]
  10aa94:	e51b3008 	ldr	r3, [fp, #-8]
  10aa98:	e5832004 	str	r2, [r3, #4]
            return;
  10aa9c:	ea000006 	b	10aabc <list_del+0x6c>
        }
        cur = cur->next;
  10aaa0:	e51b3008 	ldr	r3, [fp, #-8]
  10aaa4:	e5933004 	ldr	r3, [r3, #4]
  10aaa8:	e50b3008 	str	r3, [fp, #-8]
    while (cur->next)
  10aaac:	e51b3008 	ldr	r3, [fp, #-8]
  10aab0:	e5933004 	ldr	r3, [r3, #4]
  10aab4:	e3530000 	cmp	r3, #0
  10aab8:	1affffec 	bne	10aa70 <list_del+0x20>
    }
}
  10aabc:	e28bd000 	add	sp, fp, #0
  10aac0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10aac4:	e12fff1e 	bx	lr

0010aac8 <tcpip_mb_timer_entry>:

void tcpip_mb_timer_entry()
{
  10aac8:	e92d4800 	push	{fp, lr}
  10aacc:	e28db004 	add	fp, sp, #4
  10aad0:	e24dd008 	sub	sp, sp, #8
    while (1)
    {
        rt_thread_mdelay(INPUT_BUF_TIMEOUT);
  10aad4:	e3a00001 	mov	r0, #1
  10aad8:	ebffdce7 	bl	101e7c <rt_thread_mdelay>
        struct mbbuf_list *cur = &head;
  10aadc:	e30e3a44 	movw	r3, #59972	; 0xea44
  10aae0:	e3403014 	movt	r3, #20
  10aae4:	e50b3008 	str	r3, [fp, #-8]
        while (cur->next)
  10aae8:	ea000012 	b	10ab38 <tcpip_mb_timer_entry+0x70>
        {
            if (!buffer_empty(cur->next->mbbuf->cb))
  10aaec:	e51b3008 	ldr	r3, [fp, #-8]
  10aaf0:	e5933004 	ldr	r3, [r3, #4]
  10aaf4:	e5933000 	ldr	r3, [r3]
  10aaf8:	e5933004 	ldr	r3, [r3, #4]
  10aafc:	e1a00003 	mov	r0, r3
  10ab00:	eb0001f8 	bl	10b2e8 <buffer_empty>
  10ab04:	e1a03000 	mov	r3, r0
  10ab08:	e3530000 	cmp	r3, #0
  10ab0c:	1a000006 	bne	10ab2c <tcpip_mb_timer_entry+0x64>
            {
                rt_mb_send(cur->next->mbbuf->mb, INPUT_NOTIFICATION);
  10ab10:	e51b3008 	ldr	r3, [fp, #-8]
  10ab14:	e5933004 	ldr	r3, [r3, #4]
  10ab18:	e5933000 	ldr	r3, [r3]
  10ab1c:	e5933000 	ldr	r3, [r3]
  10ab20:	e3a01000 	mov	r1, #0
  10ab24:	e1a00003 	mov	r0, r3
  10ab28:	ebffdab5 	bl	101604 <rt_mb_send>
            }
            
            cur = cur->next;
  10ab2c:	e51b3008 	ldr	r3, [fp, #-8]
  10ab30:	e5933004 	ldr	r3, [r3, #4]
  10ab34:	e50b3008 	str	r3, [fp, #-8]
        while (cur->next)
  10ab38:	e51b3008 	ldr	r3, [fp, #-8]
  10ab3c:	e5933004 	ldr	r3, [r3, #4]
  10ab40:	e3530000 	cmp	r3, #0
  10ab44:	1affffe8 	bne	10aaec <tcpip_mb_timer_entry+0x24>
    {
  10ab48:	eaffffe1 	b	10aad4 <tcpip_mb_timer_entry+0xc>

0010ab4c <sys_mbox_new>:
 * Create an empty mailbox for maximum "size" elements
 *
 * @return the operation status, ERR_OK on OK; others on error
 */
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
  10ab4c:	e92d4810 	push	{r4, fp, lr}
  10ab50:	e28db008 	add	fp, sp, #8
  10ab54:	e24dd01c 	sub	sp, sp, #28
  10ab58:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10ab5c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    static unsigned short counter = 0;
    char tname[RT_NAME_MAX];

    RT_DEBUG_NOT_IN_INTERRUPT;

    rt_snprintf(tname, RT_NAME_MAX, "%s%d", SYS_LWIP_MBOX_NAME, counter);
  10ab60:	e30e3a54 	movw	r3, #59988	; 0xea54
  10ab64:	e3403014 	movt	r3, #20
  10ab68:	e1d330b0 	ldrh	r3, [r3]
  10ab6c:	e24b0014 	sub	r0, fp, #20
  10ab70:	e58d3000 	str	r3, [sp]
  10ab74:	e3063520 	movw	r3, #25888	; 0x6520
  10ab78:	e3403014 	movt	r3, #20
  10ab7c:	e3062514 	movw	r2, #25876	; 0x6514
  10ab80:	e3402014 	movt	r2, #20
  10ab84:	e3a01008 	mov	r1, #8
  10ab88:	ebffe12b 	bl	10303c <rt_snprintf>
    counter++;
  10ab8c:	e30e3a54 	movw	r3, #59988	; 0xea54
  10ab90:	e3403014 	movt	r3, #20
  10ab94:	e1d330b0 	ldrh	r3, [r3]
  10ab98:	e2833001 	add	r3, r3, #1
  10ab9c:	e6ff2073 	uxth	r2, r3
  10aba0:	e30e3a54 	movw	r3, #59988	; 0xea54
  10aba4:	e3403014 	movt	r3, #20
  10aba8:	e1c320b0 	strh	r2, [r3]

    *mbox = malloc(sizeof(struct rt_mailbox_buff));
  10abac:	e3a00008 	mov	r0, #8
  10abb0:	eb00ca66 	bl	13d550 <malloc>
  10abb4:	e1a03000 	mov	r3, r0
  10abb8:	e1a02003 	mov	r2, r3
  10abbc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10abc0:	e5832000 	str	r2, [r3]
    (*mbox)->cb = buffer_new(INPUT_BUF_LEN);
  10abc4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10abc8:	e5934000 	ldr	r4, [r3]
  10abcc:	e3a00080 	mov	r0, #128	; 0x80
  10abd0:	eb00017f 	bl	10b1d4 <buffer_new>
  10abd4:	e1a03000 	mov	r3, r0
  10abd8:	e5843004 	str	r3, [r4, #4]
    (*mbox)->mb = rt_mb_create(tname, size, RT_IPC_FLAG_FIFO);
  10abdc:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  10abe0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10abe4:	e5934000 	ldr	r4, [r3]
  10abe8:	e24b3014 	sub	r3, fp, #20
  10abec:	e3a02000 	mov	r2, #0
  10abf0:	e1a00003 	mov	r0, r3
  10abf4:	ebffd9cc 	bl	10132c <rt_mb_create>
  10abf8:	e1a03000 	mov	r3, r0
  10abfc:	e5843000 	str	r3, [r4]

    if (!(*mbox) || !(*mbox)->cb || !(*mbox)->cb)
  10ac00:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10ac04:	e5933000 	ldr	r3, [r3]
  10ac08:	e3530000 	cmp	r3, #0
  10ac0c:	0a000009 	beq	10ac38 <sys_mbox_new+0xec>
  10ac10:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10ac14:	e5933000 	ldr	r3, [r3]
  10ac18:	e5933004 	ldr	r3, [r3, #4]
  10ac1c:	e3530000 	cmp	r3, #0
  10ac20:	0a000004 	beq	10ac38 <sys_mbox_new+0xec>
  10ac24:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10ac28:	e5933000 	ldr	r3, [r3]
  10ac2c:	e5933004 	ldr	r3, [r3, #4]
  10ac30:	e3530000 	cmp	r3, #0
  10ac34:	1a000001 	bne	10ac40 <sys_mbox_new+0xf4>
    {
        return ERR_MEM;
  10ac38:	e3e03000 	mvn	r3, #0
  10ac3c:	ea000004 	b	10ac54 <sys_mbox_new+0x108>
    }

    list_insert(*mbox);
  10ac40:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10ac44:	e5933000 	ldr	r3, [r3]
  10ac48:	e1a00003 	mov	r0, r3
  10ac4c:	ebffff60 	bl	10a9d4 <list_insert>
    return ERR_OK;
  10ac50:	e3a03000 	mov	r3, #0
}
  10ac54:	e1a00003 	mov	r0, r3
  10ac58:	e24bd008 	sub	sp, fp, #8
  10ac5c:	e8bd8810 	pop	{r4, fp, pc}

0010ac60 <sys_mbox_free>:

/*
 * Deallocate a mailbox
 */
void sys_mbox_free(sys_mbox_t *mbox)
{
  10ac60:	e92d4800 	push	{fp, lr}
  10ac64:	e28db004 	add	fp, sp, #4
  10ac68:	e24dd008 	sub	sp, sp, #8
  10ac6c:	e50b0008 	str	r0, [fp, #-8]
    RT_DEBUG_NOT_IN_INTERRUPT;

    rt_mb_delete((*mbox)->mb);
  10ac70:	e51b3008 	ldr	r3, [fp, #-8]
  10ac74:	e5933000 	ldr	r3, [r3]
  10ac78:	e5933000 	ldr	r3, [r3]
  10ac7c:	e1a00003 	mov	r0, r3
  10ac80:	ebffd9f4 	bl	101458 <rt_mb_delete>
    buffer_del((*mbox)->cb);
  10ac84:	e51b3008 	ldr	r3, [fp, #-8]
  10ac88:	e5933000 	ldr	r3, [r3]
  10ac8c:	e5933004 	ldr	r3, [r3, #4]
  10ac90:	e1a00003 	mov	r0, r3
  10ac94:	eb000170 	bl	10b25c <buffer_del>
    list_del(*mbox);
  10ac98:	e51b3008 	ldr	r3, [fp, #-8]
  10ac9c:	e5933000 	ldr	r3, [r3]
  10aca0:	e1a00003 	mov	r0, r3
  10aca4:	ebffff69 	bl	10aa50 <list_del>
    free(*mbox);
  10aca8:	e51b3008 	ldr	r3, [fp, #-8]
  10acac:	e5933000 	ldr	r3, [r3]
  10acb0:	e1a00003 	mov	r0, r3
  10acb4:	eb00cbe1 	bl	13dc40 <free>

    return;
  10acb8:	e320f000 	nop	{0}
}
  10acbc:	e24bd004 	sub	sp, fp, #4
  10acc0:	e8bd8800 	pop	{fp, pc}

0010acc4 <post_msg>:

rt_err_t post_msg(sys_mbox_t *mbox, void *msg)
{
  10acc4:	e92d4800 	push	{fp, lr}
  10acc8:	e28db004 	add	fp, sp, #4
  10accc:	e24dd008 	sub	sp, sp, #8
  10acd0:	e50b0008 	str	r0, [fp, #-8]
  10acd4:	e50b100c 	str	r1, [fp, #-12]
    while (buffer_enqueue((*mbox)->cb, (rt_ubase_t)msg) == -1)
  10acd8:	ea000005 	b	10acf4 <post_msg+0x30>
    {
        rt_mb_send((*mbox)->mb, INPUT_NOTIFICATION);
  10acdc:	e51b3008 	ldr	r3, [fp, #-8]
  10ace0:	e5933000 	ldr	r3, [r3]
  10ace4:	e5933000 	ldr	r3, [r3]
  10ace8:	e3a01000 	mov	r1, #0
  10acec:	e1a00003 	mov	r0, r3
  10acf0:	ebffda43 	bl	101604 <rt_mb_send>
    while (buffer_enqueue((*mbox)->cb, (rt_ubase_t)msg) == -1)
  10acf4:	e51b3008 	ldr	r3, [fp, #-8]
  10acf8:	e5933000 	ldr	r3, [r3]
  10acfc:	e5933004 	ldr	r3, [r3, #4]
  10ad00:	e51b200c 	ldr	r2, [fp, #-12]
  10ad04:	e1a01002 	mov	r1, r2
  10ad08:	e1a00003 	mov	r0, r3
  10ad0c:	eb000185 	bl	10b328 <buffer_enqueue>
  10ad10:	e1a03000 	mov	r3, r0
  10ad14:	e3730001 	cmn	r3, #1
  10ad18:	0affffef 	beq	10acdc <post_msg+0x18>
    }

    return ERR_OK;
  10ad1c:	e3a03000 	mov	r3, #0
}
  10ad20:	e1a00003 	mov	r0, r3
  10ad24:	e24bd004 	sub	sp, fp, #4
  10ad28:	e8bd8800 	pop	{fp, pc}

0010ad2c <fetch_msg>:

rt_err_t fetch_msg(sys_mbox_t *mbox, void **msg, u32_t t)
{
  10ad2c:	e92d4800 	push	{fp, lr}
  10ad30:	e28db004 	add	fp, sp, #4
  10ad34:	e24dd018 	sub	sp, sp, #24
  10ad38:	e50b0010 	str	r0, [fp, #-16]
  10ad3c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10ad40:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    rt_err_t ret;
    do
    {
        ret = buffer_dequeue((*mbox)->cb, (rt_ubase_t*)msg);
  10ad44:	e51b3010 	ldr	r3, [fp, #-16]
  10ad48:	e5933000 	ldr	r3, [r3]
  10ad4c:	e5933004 	ldr	r3, [r3, #4]
  10ad50:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10ad54:	e1a00003 	mov	r0, r3
  10ad58:	eb000196 	bl	10b3b8 <buffer_dequeue>
  10ad5c:	e50b0008 	str	r0, [fp, #-8]
        if (ret == 0)
  10ad60:	e51b3008 	ldr	r3, [fp, #-8]
  10ad64:	e3530000 	cmp	r3, #0
  10ad68:	1a000001 	bne	10ad74 <fetch_msg+0x48>
        {
            return RT_EOK;
  10ad6c:	e3a03000 	mov	r3, #0
  10ad70:	ea00000c 	b	10ada8 <fetch_msg+0x7c>
        } 
        ret = rt_mb_recv((*mbox)->mb, (rt_ubase_t *)msg, t);
  10ad74:	e51b3010 	ldr	r3, [fp, #-16]
  10ad78:	e5933000 	ldr	r3, [r3]
  10ad7c:	e5933000 	ldr	r3, [r3]
  10ad80:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  10ad84:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10ad88:	e1a00003 	mov	r0, r3
  10ad8c:	ebffda3a 	bl	10167c <rt_mb_recv>
  10ad90:	e50b0008 	str	r0, [fp, #-8]
    } while (*msg == (void*)INPUT_NOTIFICATION);
  10ad94:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10ad98:	e5933000 	ldr	r3, [r3]
  10ad9c:	e3530000 	cmp	r3, #0
  10ada0:	0affffe7 	beq	10ad44 <fetch_msg+0x18>

    return ret;
  10ada4:	e51b3008 	ldr	r3, [fp, #-8]
}
  10ada8:	e1a00003 	mov	r0, r3
  10adac:	e24bd004 	sub	sp, fp, #4
  10adb0:	e8bd8800 	pop	{fp, pc}

0010adb4 <sys_mbox_post>:
 * -> blocks if full, only used from tasks not from ISR
 * @param mbox mbox to posts the message
 * @param msg message to post (ATTENTION: can be NULL)
 */
void sys_mbox_post(sys_mbox_t *mbox, void *msg)
{
  10adb4:	e92d4800 	push	{fp, lr}
  10adb8:	e28db004 	add	fp, sp, #4
  10adbc:	e24dd008 	sub	sp, sp, #8
  10adc0:	e50b0008 	str	r0, [fp, #-8]
  10adc4:	e50b100c 	str	r1, [fp, #-12]
    RT_DEBUG_NOT_IN_INTERRUPT;

    post_msg(mbox, msg);
  10adc8:	e51b100c 	ldr	r1, [fp, #-12]
  10adcc:	e51b0008 	ldr	r0, [fp, #-8]
  10add0:	ebffffbb 	bl	10acc4 <post_msg>

    return;
  10add4:	e320f000 	nop	{0}
}
  10add8:	e24bd004 	sub	sp, fp, #4
  10addc:	e8bd8800 	pop	{fp, pc}

0010ade0 <sys_mbox_trypost>:
 *
 * @return return ERR_OK if the "msg" is posted, ERR_MEM if the mailbox is full
 */

err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
  10ade0:	e92d4800 	push	{fp, lr}
  10ade4:	e28db004 	add	fp, sp, #4
  10ade8:	e24dd008 	sub	sp, sp, #8
  10adec:	e50b0008 	str	r0, [fp, #-8]
  10adf0:	e50b100c 	str	r1, [fp, #-12]
    return post_msg(mbox, msg);
  10adf4:	e51b100c 	ldr	r1, [fp, #-12]
  10adf8:	e51b0008 	ldr	r0, [fp, #-8]
  10adfc:	ebffffb0 	bl	10acc4 <post_msg>
  10ae00:	e1a03000 	mov	r3, r0
  10ae04:	e6af3073 	sxtb	r3, r3
}
  10ae08:	e1a00003 	mov	r0, r3
  10ae0c:	e24bd004 	sub	sp, fp, #4
  10ae10:	e8bd8800 	pop	{fp, pc}

0010ae14 <sys_arch_mbox_fetch>:
 * @return time (in milliseconds) waited for a message, may be 0 if not waited
           or SYS_ARCH_TIMEOUT on timeout
 *         The returned time has to be accurate to prevent timer jitter!
 */
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
  10ae14:	e92d4800 	push	{fp, lr}
  10ae18:	e28db004 	add	fp, sp, #4
  10ae1c:	e24dd020 	sub	sp, sp, #32
  10ae20:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10ae24:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  10ae28:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
    u32_t tick;

    RT_DEBUG_NOT_IN_INTERRUPT;

    /* get the begin tick */
    tick = rt_tick_get();
  10ae2c:	ebffdc0b 	bl	101e60 <rt_tick_get>
  10ae30:	e50b000c 	str	r0, [fp, #-12]

    if(timeout == 0)
  10ae34:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10ae38:	e3530000 	cmp	r3, #0
  10ae3c:	1a000002 	bne	10ae4c <sys_arch_mbox_fetch+0x38>
        t = RT_WAITING_FOREVER;
  10ae40:	e3e03000 	mvn	r3, #0
  10ae44:	e50b3008 	str	r3, [fp, #-8]
  10ae48:	ea000007 	b	10ae6c <sys_arch_mbox_fetch+0x58>
    else
    {
        /* convirt msecond to os tick */
        if (timeout < (1000/RT_TICK_PER_SECOND))
  10ae4c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10ae50:	e3530000 	cmp	r3, #0
  10ae54:	1a000002 	bne	10ae64 <sys_arch_mbox_fetch+0x50>
            t = 1;
  10ae58:	e3a03001 	mov	r3, #1
  10ae5c:	e50b3008 	str	r3, [fp, #-8]
  10ae60:	ea000001 	b	10ae6c <sys_arch_mbox_fetch+0x58>
        else
            t = timeout / (1000/RT_TICK_PER_SECOND);
  10ae64:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10ae68:	e50b3008 	str	r3, [fp, #-8]
    }

    ret = fetch_msg(mbox, msg, t);
  10ae6c:	e51b3008 	ldr	r3, [fp, #-8]
  10ae70:	e1a02003 	mov	r2, r3
  10ae74:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  10ae78:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  10ae7c:	ebffffaa 	bl	10ad2c <fetch_msg>
  10ae80:	e50b0010 	str	r0, [fp, #-16]

    if(ret == -RT_ETIMEOUT)
  10ae84:	e51b3010 	ldr	r3, [fp, #-16]
  10ae88:	e3730002 	cmn	r3, #2
  10ae8c:	1a000001 	bne	10ae98 <sys_arch_mbox_fetch+0x84>
        return SYS_ARCH_TIMEOUT;
  10ae90:	e3e03000 	mvn	r3, #0
  10ae94:	ea000014 	b	10aeec <sys_arch_mbox_fetch+0xd8>
    else
    {
        LWIP_ASSERT("rt_mb_recv returned with error!", ret == RT_EOK);
  10ae98:	e51b3010 	ldr	r3, [fp, #-16]
  10ae9c:	e3530000 	cmp	r3, #0
  10aea0:	0a000006 	beq	10aec0 <sys_arch_mbox_fetch+0xac>
  10aea4:	e3060528 	movw	r0, #25896	; 0x6528
  10aea8:	e3400014 	movt	r0, #20
  10aeac:	ebffe098 	bl	103114 <rt_kprintf>
  10aeb0:	e3a01f82 	mov	r1, #520	; 0x208
  10aeb4:	e30604d0 	movw	r0, #25808	; 0x64d0
  10aeb8:	e3400014 	movt	r0, #20
  10aebc:	eb00006e 	bl	10b07c <sys_arch_assert>
    }

    /* get elapse msecond */
    tick = rt_tick_get() - tick;
  10aec0:	ebffdbe6 	bl	101e60 <rt_tick_get>
  10aec4:	e1a02000 	mov	r2, r0
  10aec8:	e51b300c 	ldr	r3, [fp, #-12]
  10aecc:	e0423003 	sub	r3, r2, r3
  10aed0:	e50b300c 	str	r3, [fp, #-12]

    /* convert tick to msecond */
    tick = tick * (1000 / RT_TICK_PER_SECOND);
    if (tick == 0)
  10aed4:	e51b300c 	ldr	r3, [fp, #-12]
  10aed8:	e3530000 	cmp	r3, #0
  10aedc:	1a000001 	bne	10aee8 <sys_arch_mbox_fetch+0xd4>
        tick = 1;
  10aee0:	e3a03001 	mov	r3, #1
  10aee4:	e50b300c 	str	r3, [fp, #-12]

    return tick;
  10aee8:	e51b300c 	ldr	r3, [fp, #-12]
}
  10aeec:	e1a00003 	mov	r0, r3
  10aef0:	e24bd004 	sub	sp, fp, #4
  10aef4:	e8bd8800 	pop	{fp, pc}

0010aef8 <sys_arch_mbox_tryfetch>:
 * @param timeout maximum time (in milliseconds) to wait for a message
 * @return 0 (milliseconds) if a message has been received
 *         or SYS_MBOX_EMPTY if the mailbox is empty
 */
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
  10aef8:	e92d4800 	push	{fp, lr}
  10aefc:	e28db004 	add	fp, sp, #4
  10af00:	e24dd010 	sub	sp, sp, #16
  10af04:	e50b0010 	str	r0, [fp, #-16]
  10af08:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    int ret;

    ret = fetch_msg(mbox, msg, 0);
  10af0c:	e3a02000 	mov	r2, #0
  10af10:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10af14:	e51b0010 	ldr	r0, [fp, #-16]
  10af18:	ebffff83 	bl	10ad2c <fetch_msg>
  10af1c:	e50b0008 	str	r0, [fp, #-8]
       
    if(ret == -RT_ETIMEOUT)
  10af20:	e51b3008 	ldr	r3, [fp, #-8]
  10af24:	e3730002 	cmn	r3, #2
  10af28:	1a000001 	bne	10af34 <sys_arch_mbox_tryfetch+0x3c>
        return SYS_ARCH_TIMEOUT;
  10af2c:	e3e03000 	mvn	r3, #0
  10af30:	ea000005 	b	10af4c <sys_arch_mbox_tryfetch+0x54>
    else
    {
        if (ret == RT_EOK)
  10af34:	e51b3008 	ldr	r3, [fp, #-8]
  10af38:	e3530000 	cmp	r3, #0
  10af3c:	1a000001 	bne	10af48 <sys_arch_mbox_tryfetch+0x50>
            ret = 1;
  10af40:	e3a03001 	mov	r3, #1
  10af44:	e50b3008 	str	r3, [fp, #-8]
    }

    return ret;
  10af48:	e51b3008 	ldr	r3, [fp, #-8]
}
  10af4c:	e1a00003 	mov	r0, r3
  10af50:	e24bd004 	sub	sp, fp, #4
  10af54:	e8bd8800 	pop	{fp, pc}

0010af58 <sys_mbox_valid>:
#ifndef sys_mbox_valid
/** Check if an mbox is valid/allocated:
 *  return 1 for valid, 0 for invalid
 */
rt_base_t sys_mbox_valid(sys_mbox_t *mbox)
{
  10af58:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10af5c:	e28db000 	add	fp, sp, #0
  10af60:	e24dd00c 	sub	sp, sp, #12
  10af64:	e50b0008 	str	r0, [fp, #-8]
    return (rt_base_t)(*mbox);
  10af68:	e51b3008 	ldr	r3, [fp, #-8]
  10af6c:	e5933000 	ldr	r3, [r3]
}
  10af70:	e1a00003 	mov	r0, r3
  10af74:	e28bd000 	add	sp, fp, #0
  10af78:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10af7c:	e12fff1e 	bx	lr

0010af80 <sys_mbox_set_invalid>:

#ifndef sys_mbox_set_invalid
/** Set an mbox invalid so that sys_mbox_valid returns 0
 */
void sys_mbox_set_invalid(sys_mbox_t *mbox)
{
  10af80:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10af84:	e28db000 	add	fp, sp, #0
  10af88:	e24dd00c 	sub	sp, sp, #12
  10af8c:	e50b0008 	str	r0, [fp, #-8]
    *mbox = RT_NULL;
  10af90:	e51b3008 	ldr	r3, [fp, #-8]
  10af94:	e3a02000 	mov	r2, #0
  10af98:	e5832000 	str	r2, [r3]
}
  10af9c:	e320f000 	nop	{0}
  10afa0:	e28bd000 	add	sp, fp, #0
  10afa4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10afa8:	e12fff1e 	bx	lr

0010afac <sys_thread_new>:
sys_thread_t sys_thread_new(const char    *name,
                            lwip_thread_fn thread,
                            void          *arg,
                            int            stacksize,
                            int            prio)
{
  10afac:	e92d4800 	push	{fp, lr}
  10afb0:	e28db004 	add	fp, sp, #4
  10afb4:	e24dd020 	sub	sp, sp, #32
  10afb8:	e50b0010 	str	r0, [fp, #-16]
  10afbc:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10afc0:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  10afc4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    rt_thread_t t;

    RT_DEBUG_NOT_IN_INTERRUPT;

    /* create thread */
    t = rt_thread_create(name, thread, arg, stacksize, prio, 20);
  10afc8:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  10afcc:	e59b3004 	ldr	r3, [fp, #4]
  10afd0:	e6ef3073 	uxtb	r3, r3
  10afd4:	e3a02014 	mov	r2, #20
  10afd8:	e58d2004 	str	r2, [sp, #4]
  10afdc:	e58d3000 	str	r3, [sp]
  10afe0:	e1a03001 	mov	r3, r1
  10afe4:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  10afe8:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10afec:	e51b0010 	ldr	r0, [fp, #-16]
  10aff0:	ebffdc3f 	bl	1020f4 <rt_thread_create>
  10aff4:	e50b0008 	str	r0, [fp, #-8]
    
    RT_ASSERT(t != RT_NULL);
  10aff8:	e51b3008 	ldr	r3, [fp, #-8]
  10affc:	e3530000 	cmp	r3, #0
  10b000:	1a000005 	bne	10b01c <sys_thread_new+0x70>
  10b004:	e3002255 	movw	r2, #597	; 0x255
  10b008:	e3061574 	movw	r1, #25972	; 0x6574
  10b00c:	e3401014 	movt	r1, #20
  10b010:	e3060548 	movw	r0, #25928	; 0x6548
  10b014:	e3400014 	movt	r0, #20
  10b018:	ebffe15e 	bl	103598 <rt_assert_handler>

    /* startup thread */
    rt_thread_startup(t);
  10b01c:	e51b0008 	ldr	r0, [fp, #-8]
  10b020:	ebffdc68 	bl	1021c8 <rt_thread_startup>

    return t;
  10b024:	e51b3008 	ldr	r3, [fp, #-8]
}
  10b028:	e1a00003 	mov	r0, r3
  10b02c:	e24bd004 	sub	sp, fp, #4
  10b030:	e8bd8800 	pop	{fp, pc}

0010b034 <sys_arch_protect>:

sys_prot_t sys_arch_protect(void)
{
  10b034:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10b038:	e28db000 	add	fp, sp, #0
  10b03c:	e24dd00c 	sub	sp, sp, #12
    //rt_base_t level;
    rt_base_t level = 0;
  10b040:	e3a03000 	mov	r3, #0
  10b044:	e50b3008 	str	r3, [fp, #-8]

    /* disable interrupt */
    //level = rt_hw_interrupt_disable();

    return level;
  10b048:	e51b3008 	ldr	r3, [fp, #-8]
}
  10b04c:	e1a00003 	mov	r0, r3
  10b050:	e28bd000 	add	sp, fp, #0
  10b054:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10b058:	e12fff1e 	bx	lr

0010b05c <sys_arch_unprotect>:

void sys_arch_unprotect(sys_prot_t pval)
{
  10b05c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10b060:	e28db000 	add	fp, sp, #0
  10b064:	e24dd00c 	sub	sp, sp, #12
  10b068:	e50b0008 	str	r0, [fp, #-8]
    /* enable interrupt */
    //rt_hw_interrupt_enable(pval);

    return;
  10b06c:	e320f000 	nop	{0}
}
  10b070:	e28bd000 	add	sp, fp, #0
  10b074:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10b078:	e12fff1e 	bx	lr

0010b07c <sys_arch_assert>:

void sys_arch_assert(const char *file, int line)
{
  10b07c:	e92d4800 	push	{fp, lr}
  10b080:	e28db004 	add	fp, sp, #4
  10b084:	e24dd008 	sub	sp, sp, #8
  10b088:	e50b0008 	str	r0, [fp, #-8]
  10b08c:	e50b100c 	str	r1, [fp, #-12]
    rt_kprintf("\nAssertion: %d in %s\n", line, file);
  10b090:	e51b2008 	ldr	r2, [fp, #-8]
  10b094:	e51b100c 	ldr	r1, [fp, #-12]
  10b098:	e3060558 	movw	r0, #25944	; 0x6558
  10b09c:	e3400014 	movt	r0, #20
  10b0a0:	ebffe01b 	bl	103114 <rt_kprintf>
    RT_ASSERT(0);
  10b0a4:	e3002273 	movw	r2, #627	; 0x273
  10b0a8:	e3061584 	movw	r1, #25988	; 0x6584
  10b0ac:	e3401014 	movt	r1, #20
  10b0b0:	e3060570 	movw	r0, #25968	; 0x6570
  10b0b4:	e3400014 	movt	r0, #20
  10b0b8:	ebffe136 	bl	103598 <rt_assert_handler>
}
  10b0bc:	e320f000 	nop	{0}
  10b0c0:	e24bd004 	sub	sp, fp, #4
  10b0c4:	e8bd8800 	pop	{fp, pc}

0010b0c8 <sys_jiffies>:

u32_t sys_jiffies(void)
{
  10b0c8:	e92d4800 	push	{fp, lr}
  10b0cc:	e28db004 	add	fp, sp, #4
    return rt_tick_get();
  10b0d0:	ebffdb62 	bl	101e60 <rt_tick_get>
  10b0d4:	e1a03000 	mov	r3, r0
}
  10b0d8:	e1a00003 	mov	r0, r3
  10b0dc:	e8bd8800 	pop	{fp, pc}

0010b0e0 <sys_now>:

u32_t sys_now(void)
{
  10b0e0:	e92d4800 	push	{fp, lr}
  10b0e4:	e28db004 	add	fp, sp, #4
    return rt_tick_get() * (1000 / RT_TICK_PER_SECOND);
  10b0e8:	ebffdb5c 	bl	101e60 <rt_tick_get>
  10b0ec:	e1a03000 	mov	r3, r0
}
  10b0f0:	e1a00003 	mov	r0, r3
  10b0f4:	e8bd8800 	pop	{fp, pc}

0010b0f8 <mem_init>:


RT_WEAK
void mem_init(void)
{
  10b0f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10b0fc:	e28db000 	add	fp, sp, #0
}
  10b100:	e320f000 	nop	{0}
  10b104:	e28bd000 	add	sp, fp, #0
  10b108:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10b10c:	e12fff1e 	bx	lr

0010b110 <mem_calloc>:

void *mem_calloc(mem_size_t count, mem_size_t size)
{
  10b110:	e92d4800 	push	{fp, lr}
  10b114:	e28db004 	add	fp, sp, #4
  10b118:	e24dd008 	sub	sp, sp, #8
  10b11c:	e1a03000 	mov	r3, r0
  10b120:	e1a02001 	mov	r2, r1
  10b124:	e14b30b6 	strh	r3, [fp, #-6]
  10b128:	e1a03002 	mov	r3, r2
  10b12c:	e14b30b8 	strh	r3, [fp, #-8]
    return rt_calloc(count, size);
  10b130:	e15b30b6 	ldrh	r3, [fp, #-6]
  10b134:	e15b20b8 	ldrh	r2, [fp, #-8]
  10b138:	e1a01002 	mov	r1, r2
  10b13c:	e1a00003 	mov	r0, r3
  10b140:	ebffdfb1 	bl	10300c <rt_calloc>
  10b144:	e1a03000 	mov	r3, r0
}
  10b148:	e1a00003 	mov	r0, r3
  10b14c:	e24bd004 	sub	sp, fp, #4
  10b150:	e8bd8800 	pop	{fp, pc}

0010b154 <mem_trim>:

void *mem_trim(void *mem, mem_size_t size)
{
  10b154:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10b158:	e28db000 	add	fp, sp, #0
  10b15c:	e24dd00c 	sub	sp, sp, #12
  10b160:	e50b0008 	str	r0, [fp, #-8]
  10b164:	e1a03001 	mov	r3, r1
  10b168:	e14b30ba 	strh	r3, [fp, #-10]
    /* not support trim yet */
    return mem;
  10b16c:	e51b3008 	ldr	r3, [fp, #-8]
}
  10b170:	e1a00003 	mov	r0, r3
  10b174:	e28bd000 	add	sp, fp, #0
  10b178:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10b17c:	e12fff1e 	bx	lr

0010b180 <mem_malloc>:

void *mem_malloc(mem_size_t size)
{
  10b180:	e92d4800 	push	{fp, lr}
  10b184:	e28db004 	add	fp, sp, #4
  10b188:	e24dd008 	sub	sp, sp, #8
  10b18c:	e1a03000 	mov	r3, r0
  10b190:	e14b30b6 	strh	r3, [fp, #-6]
    return rt_malloc(size);
  10b194:	e15b30b6 	ldrh	r3, [fp, #-6]
  10b198:	e1a00003 	mov	r0, r3
  10b19c:	ebffdf7c 	bl	102f94 <rt_malloc>
  10b1a0:	e1a03000 	mov	r3, r0
}
  10b1a4:	e1a00003 	mov	r0, r3
  10b1a8:	e24bd004 	sub	sp, fp, #4
  10b1ac:	e8bd8800 	pop	{fp, pc}

0010b1b0 <mem_free>:

void  mem_free(void *mem)
{
  10b1b0:	e92d4800 	push	{fp, lr}
  10b1b4:	e28db004 	add	fp, sp, #4
  10b1b8:	e24dd008 	sub	sp, sp, #8
  10b1bc:	e50b0008 	str	r0, [fp, #-8]
    rt_free(mem);
  10b1c0:	e51b0008 	ldr	r0, [fp, #-8]
  10b1c4:	ebffdf7c 	bl	102fbc <rt_free>
}
  10b1c8:	e320f000 	nop	{0}
  10b1cc:	e24bd004 	sub	sp, fp, #4
  10b1d0:	e8bd8800 	pop	{fp, pc}

0010b1d4 <buffer_new>:
#include "arch/cirbuff.h"
#include <rtthread.h>

struct cirbuff * buffer_new(int len)
{
  10b1d4:	e92d4800 	push	{fp, lr}
  10b1d8:	e28db004 	add	fp, sp, #4
  10b1dc:	e24dd010 	sub	sp, sp, #16
  10b1e0:	e50b0010 	str	r0, [fp, #-16]
    struct cirbuff * new_cb = (struct cirbuff *)rt_malloc(sizeof(struct cirbuff));
  10b1e4:	e3a00010 	mov	r0, #16
  10b1e8:	ebffdf69 	bl	102f94 <rt_malloc>
  10b1ec:	e50b0008 	str	r0, [fp, #-8]
    new_cb->input_ptr = 0;
  10b1f0:	e51b3008 	ldr	r3, [fp, #-8]
  10b1f4:	e3a02000 	mov	r2, #0
  10b1f8:	e5832004 	str	r2, [r3, #4]
    new_cb->output_ptr = 0;
  10b1fc:	e51b3008 	ldr	r3, [fp, #-8]
  10b200:	e3a02000 	mov	r2, #0
  10b204:	e5832008 	str	r2, [r3, #8]
    new_cb->buff = (rt_ubase_t *)rt_malloc(sizeof(rt_ubase_t) * len);
  10b208:	e51b3010 	ldr	r3, [fp, #-16]
  10b20c:	e1a03103 	lsl	r3, r3, #2
  10b210:	e1a00003 	mov	r0, r3
  10b214:	ebffdf5e 	bl	102f94 <rt_malloc>
  10b218:	e1a02000 	mov	r2, r0
  10b21c:	e51b3008 	ldr	r3, [fp, #-8]
  10b220:	e5832000 	str	r2, [r3]
    rt_memset(new_cb->buff, 0, sizeof(rt_ubase_t) * len);
  10b224:	e51b3008 	ldr	r3, [fp, #-8]
  10b228:	e5930000 	ldr	r0, [r3]
  10b22c:	e51b3010 	ldr	r3, [fp, #-16]
  10b230:	e1a03103 	lsl	r3, r3, #2
  10b234:	e1a02003 	mov	r2, r3
  10b238:	e3a01000 	mov	r1, #0
  10b23c:	ebffe021 	bl	1032c8 <rt_memset>
    new_cb->len = len;
  10b240:	e51b3008 	ldr	r3, [fp, #-8]
  10b244:	e51b2010 	ldr	r2, [fp, #-16]
  10b248:	e583200c 	str	r2, [r3, #12]
    
    return new_cb;
  10b24c:	e51b3008 	ldr	r3, [fp, #-8]
}
  10b250:	e1a00003 	mov	r0, r3
  10b254:	e24bd004 	sub	sp, fp, #4
  10b258:	e8bd8800 	pop	{fp, pc}

0010b25c <buffer_del>:

void buffer_del(struct cirbuff *cb)
{
  10b25c:	e92d4800 	push	{fp, lr}
  10b260:	e28db004 	add	fp, sp, #4
  10b264:	e24dd008 	sub	sp, sp, #8
  10b268:	e50b0008 	str	r0, [fp, #-8]
    rt_free(cb->buff);
  10b26c:	e51b3008 	ldr	r3, [fp, #-8]
  10b270:	e5933000 	ldr	r3, [r3]
  10b274:	e1a00003 	mov	r0, r3
  10b278:	ebffdf4f 	bl	102fbc <rt_free>
    rt_free(cb);
  10b27c:	e51b0008 	ldr	r0, [fp, #-8]
  10b280:	ebffdf4d 	bl	102fbc <rt_free>
}
  10b284:	e320f000 	nop	{0}
  10b288:	e24bd004 	sub	sp, fp, #4
  10b28c:	e8bd8800 	pop	{fp, pc}

0010b290 <buffer_full>:

int buffer_full(struct cirbuff *cb)
{
  10b290:	e92d4810 	push	{r4, fp, lr}
  10b294:	e28db008 	add	fp, sp, #8
  10b298:	e24dd00c 	sub	sp, sp, #12
  10b29c:	e50b0010 	str	r0, [fp, #-16]
    return cb->output_ptr == ((cb->input_ptr + 1) % cb->len);
  10b2a0:	e51b3010 	ldr	r3, [fp, #-16]
  10b2a4:	e5934008 	ldr	r4, [r3, #8]
  10b2a8:	e51b3010 	ldr	r3, [fp, #-16]
  10b2ac:	e5933004 	ldr	r3, [r3, #4]
  10b2b0:	e2832001 	add	r2, r3, #1
  10b2b4:	e51b3010 	ldr	r3, [fp, #-16]
  10b2b8:	e593300c 	ldr	r3, [r3, #12]
  10b2bc:	e1a01003 	mov	r1, r3
  10b2c0:	e1a00002 	mov	r0, r2
  10b2c4:	eb00b6f5 	bl	138ea0 <__aeabi_idivmod>
  10b2c8:	e1a03001 	mov	r3, r1
  10b2cc:	e1540003 	cmp	r4, r3
  10b2d0:	03a03001 	moveq	r3, #1
  10b2d4:	13a03000 	movne	r3, #0
  10b2d8:	e6ef3073 	uxtb	r3, r3
}
  10b2dc:	e1a00003 	mov	r0, r3
  10b2e0:	e24bd008 	sub	sp, fp, #8
  10b2e4:	e8bd8810 	pop	{r4, fp, pc}

0010b2e8 <buffer_empty>:

int buffer_empty(struct cirbuff *cb)
{
  10b2e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  10b2ec:	e28db000 	add	fp, sp, #0
  10b2f0:	e24dd00c 	sub	sp, sp, #12
  10b2f4:	e50b0008 	str	r0, [fp, #-8]
    return cb->input_ptr == cb->output_ptr;
  10b2f8:	e51b3008 	ldr	r3, [fp, #-8]
  10b2fc:	e5932004 	ldr	r2, [r3, #4]
  10b300:	e51b3008 	ldr	r3, [fp, #-8]
  10b304:	e5933008 	ldr	r3, [r3, #8]
  10b308:	e1520003 	cmp	r2, r3
  10b30c:	03a03001 	moveq	r3, #1
  10b310:	13a03000 	movne	r3, #0
  10b314:	e6ef3073 	uxtb	r3, r3
}
  10b318:	e1a00003 	mov	r0, r3
  10b31c:	e28bd000 	add	sp, fp, #0
  10b320:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  10b324:	e12fff1e 	bx	lr

0010b328 <buffer_enqueue>:

int buffer_enqueue(struct cirbuff *cb, rt_ubase_t data)
{
  10b328:	e92d4800 	push	{fp, lr}
  10b32c:	e28db004 	add	fp, sp, #4
  10b330:	e24dd008 	sub	sp, sp, #8
  10b334:	e50b0008 	str	r0, [fp, #-8]
  10b338:	e50b100c 	str	r1, [fp, #-12]
    if (buffer_full(cb))
  10b33c:	e51b0008 	ldr	r0, [fp, #-8]
  10b340:	ebffffd2 	bl	10b290 <buffer_full>
  10b344:	e1a03000 	mov	r3, r0
  10b348:	e3530000 	cmp	r3, #0
  10b34c:	0a000001 	beq	10b358 <buffer_enqueue+0x30>
    {
        return -1;
  10b350:	e3e03000 	mvn	r3, #0
  10b354:	ea000014 	b	10b3ac <buffer_enqueue+0x84>
    }

    cb->buff[cb->input_ptr] = data;
  10b358:	e51b3008 	ldr	r3, [fp, #-8]
  10b35c:	e5932000 	ldr	r2, [r3]
  10b360:	e51b3008 	ldr	r3, [fp, #-8]
  10b364:	e5933004 	ldr	r3, [r3, #4]
  10b368:	e1a03103 	lsl	r3, r3, #2
  10b36c:	e0823003 	add	r3, r2, r3
  10b370:	e51b200c 	ldr	r2, [fp, #-12]
  10b374:	e5832000 	str	r2, [r3]
    cb->input_ptr = (cb->input_ptr + 1) % cb->len;
  10b378:	e51b3008 	ldr	r3, [fp, #-8]
  10b37c:	e5933004 	ldr	r3, [r3, #4]
  10b380:	e2832001 	add	r2, r3, #1
  10b384:	e51b3008 	ldr	r3, [fp, #-8]
  10b388:	e593300c 	ldr	r3, [r3, #12]
  10b38c:	e1a01003 	mov	r1, r3
  10b390:	e1a00002 	mov	r0, r2
  10b394:	eb00b6c1 	bl	138ea0 <__aeabi_idivmod>
  10b398:	e1a03001 	mov	r3, r1
  10b39c:	e1a02003 	mov	r2, r3
  10b3a0:	e51b3008 	ldr	r3, [fp, #-8]
  10b3a4:	e5832004 	str	r2, [r3, #4]

    return 0;
  10b3a8:	e3a03000 	mov	r3, #0
}
  10b3ac:	e1a00003 	mov	r0, r3
  10b3b0:	e24bd004 	sub	sp, fp, #4
  10b3b4:	e8bd8800 	pop	{fp, pc}

0010b3b8 <buffer_dequeue>:

int buffer_dequeue(struct cirbuff *cb, rt_ubase_t *data)
{
  10b3b8:	e92d4800 	push	{fp, lr}
  10b3bc:	e28db004 	add	fp, sp, #4
  10b3c0:	e24dd008 	sub	sp, sp, #8
  10b3c4:	e50b0008 	str	r0, [fp, #-8]
  10b3c8:	e50b100c 	str	r1, [fp, #-12]
    if (buffer_empty(cb))
  10b3cc:	e51b0008 	ldr	r0, [fp, #-8]
  10b3d0:	ebffffc4 	bl	10b2e8 <buffer_empty>
  10b3d4:	e1a03000 	mov	r3, r0
  10b3d8:	e3530000 	cmp	r3, #0
  10b3dc:	0a000001 	beq	10b3e8 <buffer_dequeue+0x30>
    {
        return -1;
  10b3e0:	e3e03000 	mvn	r3, #0
  10b3e4:	ea000015 	b	10b440 <buffer_dequeue+0x88>
    }

    *data = cb->buff[cb->output_ptr];
  10b3e8:	e51b3008 	ldr	r3, [fp, #-8]
  10b3ec:	e5932000 	ldr	r2, [r3]
  10b3f0:	e51b3008 	ldr	r3, [fp, #-8]
  10b3f4:	e5933008 	ldr	r3, [r3, #8]
  10b3f8:	e1a03103 	lsl	r3, r3, #2
  10b3fc:	e0823003 	add	r3, r2, r3
  10b400:	e5932000 	ldr	r2, [r3]
  10b404:	e51b300c 	ldr	r3, [fp, #-12]
  10b408:	e5832000 	str	r2, [r3]
    cb->output_ptr = (cb->output_ptr + 1) % cb->len;
  10b40c:	e51b3008 	ldr	r3, [fp, #-8]
  10b410:	e5933008 	ldr	r3, [r3, #8]
  10b414:	e2832001 	add	r2, r3, #1
  10b418:	e51b3008 	ldr	r3, [fp, #-8]
  10b41c:	e593300c 	ldr	r3, [r3, #12]
  10b420:	e1a01003 	mov	r1, r3
  10b424:	e1a00002 	mov	r0, r2
  10b428:	eb00b69c 	bl	138ea0 <__aeabi_idivmod>
  10b42c:	e1a03001 	mov	r3, r1
  10b430:	e1a02003 	mov	r2, r3
  10b434:	e51b3008 	ldr	r3, [fp, #-8]
  10b438:	e5832008 	str	r2, [r3, #8]

    return 0;
  10b43c:	e3a03000 	mov	r3, #0
}
  10b440:	e1a00003 	mov	r0, r3
  10b444:	e24bd004 	sub	sp, fp, #4
  10b448:	e8bd8800 	pop	{fp, pc}

0010b44c <netconn_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
static err_t
netconn_apimsg(tcpip_callback_fn fn, struct api_msg *apimsg)
{
  10b44c:	e92d4800 	push	{fp, lr}
  10b450:	e28db004 	add	fp, sp, #4
  10b454:	e24dd010 	sub	sp, sp, #16
  10b458:	e50b0010 	str	r0, [fp, #-16]
  10b45c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec

#if LWIP_NETCONN_SEM_PER_THREAD
  apimsg->op_completed_sem = LWIP_NETCONN_THREAD_SEM_GET();
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

  err = tcpip_send_msg_wait_sem(fn, apimsg, LWIP_API_MSG_SEM(apimsg));
  10b460:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10b464:	e5933000 	ldr	r3, [r3]
  10b468:	e2833010 	add	r3, r3, #16
  10b46c:	e1a02003 	mov	r2, r3
  10b470:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10b474:	e51b0010 	ldr	r0, [fp, #-16]
  10b478:	eb002c15 	bl	1164d4 <tcpip_send_msg_wait_sem>
  10b47c:	e1a03000 	mov	r3, r0
  10b480:	e54b3005 	strb	r3, [fp, #-5]
  if (err == ERR_OK) {
  10b484:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10b488:	e3530000 	cmp	r3, #0
  10b48c:	1a000002 	bne	10b49c <netconn_apimsg+0x50>
    return apimsg->err;
  10b490:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10b494:	e1d330d4 	ldrsb	r3, [r3, #4]
  10b498:	ea000000 	b	10b4a0 <netconn_apimsg+0x54>
  }
  return err;
  10b49c:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  10b4a0:	e1a00003 	mov	r0, r3
  10b4a4:	e24bd004 	sub	sp, fp, #4
  10b4a8:	e8bd8800 	pop	{fp, pc}

0010b4ac <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  10b4ac:	e92d4800 	push	{fp, lr}
  10b4b0:	e28db004 	add	fp, sp, #4
  10b4b4:	e24dd030 	sub	sp, sp, #48	; 0x30
  10b4b8:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10b4bc:	e1a03001 	mov	r3, r1
  10b4c0:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  10b4c4:	e54b3029 	strb	r3, [fp, #-41]	; 0xffffffd7
  struct netconn *conn;
  API_MSG_VAR_DECLARE(msg);
  API_MSG_VAR_ALLOC_RETURN_NULL(msg);

  conn = netconn_alloc(t, callback);
  10b4c8:	e51b1030 	ldr	r1, [fp, #-48]	; 0xffffffd0
  10b4cc:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  10b4d0:	eb000878 	bl	10d6b8 <netconn_alloc>
  10b4d4:	e50b0008 	str	r0, [fp, #-8]
  if (conn != NULL) {
  10b4d8:	e51b3008 	ldr	r3, [fp, #-8]
  10b4dc:	e3530000 	cmp	r3, #0
  10b4e0:	0a00004f 	beq	10b624 <netconn_new_with_proto_and_callback+0x178>
    err_t err;

    API_MSG_VAR_REF(msg).msg.n.proto = proto;
  10b4e4:	e55b3029 	ldrb	r3, [fp, #-41]	; 0xffffffd7
  10b4e8:	e54b301c 	strb	r3, [fp, #-28]	; 0xffffffe4
    API_MSG_VAR_REF(msg).conn = conn;
  10b4ec:	e51b3008 	ldr	r3, [fp, #-8]
  10b4f0:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    err = netconn_apimsg(lwip_netconn_do_newconn, &API_MSG_VAR_REF(msg));
  10b4f4:	e24b3024 	sub	r3, fp, #36	; 0x24
  10b4f8:	e1a01003 	mov	r1, r3
  10b4fc:	e30d062c 	movw	r0, #54828	; 0xd62c
  10b500:	e3400010 	movt	r0, #16
  10b504:	ebffffd0 	bl	10b44c <netconn_apimsg>
  10b508:	e1a03000 	mov	r3, r0
  10b50c:	e54b3009 	strb	r3, [fp, #-9]
    if (err != ERR_OK) {
  10b510:	e15b30d9 	ldrsb	r3, [fp, #-9]
  10b514:	e3530000 	cmp	r3, #0
  10b518:	0a000041 	beq	10b624 <netconn_new_with_proto_and_callback+0x178>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  10b51c:	e51b3008 	ldr	r3, [fp, #-8]
  10b520:	e5933008 	ldr	r3, [r3, #8]
  10b524:	e3530000 	cmp	r3, #0
  10b528:	0a000006 	beq	10b548 <netconn_new_with_proto_and_callback+0x9c>
  10b52c:	e3060594 	movw	r0, #26004	; 0x6594
  10b530:	e3400014 	movt	r0, #20
  10b534:	ebffdef6 	bl	103114 <rt_kprintf>
  10b538:	e3a01089 	mov	r1, #137	; 0x89
  10b53c:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b540:	e3400014 	movt	r0, #20
  10b544:	ebfffecc 	bl	10b07c <sys_arch_assert>
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
  10b548:	e51b3008 	ldr	r3, [fp, #-8]
  10b54c:	e2833014 	add	r3, r3, #20
  10b550:	e1a00003 	mov	r0, r3
  10b554:	ebfffe7f 	bl	10af58 <sys_mbox_valid>
  10b558:	e1a03000 	mov	r3, r0
  10b55c:	e3530000 	cmp	r3, #0
  10b560:	1a000006 	bne	10b580 <netconn_new_with_proto_and_callback+0xd4>
  10b564:	e30605e8 	movw	r0, #26088	; 0x65e8
  10b568:	e3400014 	movt	r0, #20
  10b56c:	ebffdee8 	bl	103114 <rt_kprintf>
  10b570:	e3a0108a 	mov	r1, #138	; 0x8a
  10b574:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b578:	e3400014 	movt	r0, #20
  10b57c:	ebfffebe 	bl	10b07c <sys_arch_assert>
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
  10b580:	e51b3008 	ldr	r3, [fp, #-8]
  10b584:	e2833018 	add	r3, r3, #24
  10b588:	e1a00003 	mov	r0, r3
  10b58c:	ebfffe71 	bl	10af58 <sys_mbox_valid>
  10b590:	e1a03000 	mov	r3, r0
  10b594:	e3530000 	cmp	r3, #0
  10b598:	0a000006 	beq	10b5b8 <netconn_new_with_proto_and_callback+0x10c>
  10b59c:	e3060600 	movw	r0, #26112	; 0x6600
  10b5a0:	e3400014 	movt	r0, #20
  10b5a4:	ebffdeda 	bl	103114 <rt_kprintf>
  10b5a8:	e3a0108c 	mov	r1, #140	; 0x8c
  10b5ac:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b5b0:	e3400014 	movt	r0, #20
  10b5b4:	ebfffeb0 	bl	10b07c <sys_arch_assert>
#endif /* LWIP_TCP */
#if !LWIP_NETCONN_SEM_PER_THREAD
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
  10b5b8:	e51b3008 	ldr	r3, [fp, #-8]
  10b5bc:	e2833010 	add	r3, r3, #16
  10b5c0:	e1a00003 	mov	r0, r3
  10b5c4:	ebfffc8e 	bl	10a804 <sys_sem_valid>
  10b5c8:	e1a03000 	mov	r3, r0
  10b5cc:	e3530000 	cmp	r3, #0
  10b5d0:	1a000006 	bne	10b5f0 <netconn_new_with_proto_and_callback+0x144>
  10b5d4:	e3060624 	movw	r0, #26148	; 0x6624
  10b5d8:	e3400014 	movt	r0, #20
  10b5dc:	ebffdecc 	bl	103114 <rt_kprintf>
  10b5e0:	e3a0108f 	mov	r1, #143	; 0x8f
  10b5e4:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b5e8:	e3400014 	movt	r0, #20
  10b5ec:	ebfffea2 	bl	10b07c <sys_arch_assert>
      sys_sem_free(&conn->op_completed);
  10b5f0:	e51b3008 	ldr	r3, [fp, #-8]
  10b5f4:	e2833010 	add	r3, r3, #16
  10b5f8:	e1a00003 	mov	r0, r3
  10b5fc:	ebfffc37 	bl	10a6e0 <sys_sem_free>
#endif /* !LWIP_NETCONN_SEM_PER_THREAD */
      sys_mbox_free(&conn->recvmbox);
  10b600:	e51b3008 	ldr	r3, [fp, #-8]
  10b604:	e2833014 	add	r3, r3, #20
  10b608:	e1a00003 	mov	r0, r3
  10b60c:	ebfffd93 	bl	10ac60 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  10b610:	e51b1008 	ldr	r1, [fp, #-8]
  10b614:	e3a00008 	mov	r0, #8
  10b618:	eb003797 	bl	11947c <memp_free>
      API_MSG_VAR_FREE(msg);
      return NULL;
  10b61c:	e3a03000 	mov	r3, #0
  10b620:	ea000000 	b	10b628 <netconn_new_with_proto_and_callback+0x17c>
    }
  }
  API_MSG_VAR_FREE(msg);
  return conn;
  10b624:	e51b3008 	ldr	r3, [fp, #-8]
}
  10b628:	e1a00003 	mov	r0, r3
  10b62c:	e24bd004 	sub	sp, fp, #4
  10b630:	e8bd8800 	pop	{fp, pc}

0010b634 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  10b634:	e92d4800 	push	{fp, lr}
  10b638:	e28db004 	add	fp, sp, #4
  10b63c:	e24dd028 	sub	sp, sp, #40	; 0x28
  10b640:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  err_t err;
  API_MSG_VAR_DECLARE(msg);

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  10b644:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b648:	e3530000 	cmp	r3, #0
  10b64c:	1a000001 	bne	10b658 <netconn_delete+0x24>
    return ERR_OK;
  10b650:	e3a03000 	mov	r3, #0
  10b654:	ea000013 	b	10b6a8 <netconn_delete+0x74>
  }

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
  10b658:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b65c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
#if LWIP_TCP
#if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
  /* get the time we started, which is later compared to
     sys_now() + conn->send_timeout */
  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
  10b660:	ebfffe9e 	bl	10b0e0 <sys_now>
  10b664:	e1a03000 	mov	r3, r0
  10b668:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
  API_MSG_VAR_REF(msg).msg.sd.polls_left =
    ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - 1) / TCP_SLOW_INTERVAL) + 1;
#endif /* LWIP_TCP */
#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
  err = netconn_apimsg(lwip_netconn_do_delconn, &API_MSG_VAR_REF(msg));
  10b66c:	e24b3020 	sub	r3, fp, #32
  10b670:	e1a01003 	mov	r1, r3
  10b674:	e30e0054 	movw	r0, #57428	; 0xe054
  10b678:	e3400010 	movt	r0, #16
  10b67c:	ebffff72 	bl	10b44c <netconn_apimsg>
  10b680:	e1a03000 	mov	r3, r0
  10b684:	e54b3005 	strb	r3, [fp, #-5]
  API_MSG_VAR_FREE(msg);

  if (err != ERR_OK) {
  10b688:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10b68c:	e3530000 	cmp	r3, #0
  10b690:	0a000001 	beq	10b69c <netconn_delete+0x68>
    return err;
  10b694:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10b698:	ea000002 	b	10b6a8 <netconn_delete+0x74>
  }

  netconn_free(conn);
  10b69c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  10b6a0:	eb000878 	bl	10d888 <netconn_free>

  return ERR_OK;
  10b6a4:	e3a03000 	mov	r3, #0
}
  10b6a8:	e1a00003 	mov	r0, r3
  10b6ac:	e24bd004 	sub	sp, fp, #4
  10b6b0:	e8bd8800 	pop	{fp, pc}

0010b6b4 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
{
  10b6b4:	e92d4800 	push	{fp, lr}
  10b6b8:	e28db004 	add	fp, sp, #4
  10b6bc:	e24dd030 	sub	sp, sp, #48	; 0x30
  10b6c0:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10b6c4:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  10b6c8:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  10b6cc:	e54b3031 	strb	r3, [fp, #-49]	; 0xffffffcf
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  10b6d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b6d4:	e3530000 	cmp	r3, #0
  10b6d8:	1a000008 	bne	10b700 <netconn_getaddr+0x4c>
  10b6dc:	e3060640 	movw	r0, #26176	; 0x6640
  10b6e0:	e3400014 	movt	r0, #20
  10b6e4:	ebffde8a 	bl	103114 <rt_kprintf>
  10b6e8:	e3a010d9 	mov	r1, #217	; 0xd9
  10b6ec:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b6f0:	e3400014 	movt	r0, #20
  10b6f4:	ebfffe60 	bl	10b07c <sys_arch_assert>
  10b6f8:	e3e0300f 	mvn	r3, #15
  10b6fc:	ea000027 	b	10b7a0 <netconn_getaddr+0xec>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  10b700:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10b704:	e3530000 	cmp	r3, #0
  10b708:	1a000008 	bne	10b730 <netconn_getaddr+0x7c>
  10b70c:	e3060660 	movw	r0, #26208	; 0x6660
  10b710:	e3400014 	movt	r0, #20
  10b714:	ebffde7e 	bl	103114 <rt_kprintf>
  10b718:	e3a010da 	mov	r1, #218	; 0xda
  10b71c:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b720:	e3400014 	movt	r0, #20
  10b724:	ebfffe54 	bl	10b07c <sys_arch_assert>
  10b728:	e3e0300f 	mvn	r3, #15
  10b72c:	ea00001b 	b	10b7a0 <netconn_getaddr+0xec>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  10b730:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  10b734:	e3530000 	cmp	r3, #0
  10b738:	1a000008 	bne	10b760 <netconn_getaddr+0xac>
  10b73c:	e3060680 	movw	r0, #26240	; 0x6680
  10b740:	e3400014 	movt	r0, #20
  10b744:	ebffde72 	bl	103114 <rt_kprintf>
  10b748:	e3a010db 	mov	r1, #219	; 0xdb
  10b74c:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b750:	e3400014 	movt	r0, #20
  10b754:	ebfffe48 	bl	10b07c <sys_arch_assert>
  10b758:	e3e0300f 	mvn	r3, #15
  10b75c:	ea00000f 	b	10b7a0 <netconn_getaddr+0xec>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
  10b760:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b764:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  API_MSG_VAR_REF(msg).msg.ad.local = local;
  10b768:	e55b3031 	ldrb	r3, [fp, #-49]	; 0xffffffcf
  10b76c:	e54b3010 	strb	r3, [fp, #-16]
#if LWIP_MPU_COMPATIBLE
  err = netconn_apimsg(lwip_netconn_do_getaddr, &API_MSG_VAR_REF(msg));
  *addr = msg->msg.ad.ipaddr;
  *port = msg->msg.ad.port;
#else /* LWIP_MPU_COMPATIBLE */
  msg.msg.ad.ipaddr = addr;
  10b770:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10b774:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  msg.msg.ad.port = port;
  10b778:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  10b77c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  err = netconn_apimsg(lwip_netconn_do_getaddr, &msg);
  10b780:	e24b3020 	sub	r3, fp, #32
  10b784:	e1a01003 	mov	r1, r3
  10b788:	e30f0974 	movw	r0, #63860	; 0xf974
  10b78c:	e3400010 	movt	r0, #16
  10b790:	ebffff2d 	bl	10b44c <netconn_apimsg>
  10b794:	e1a03000 	mov	r3, r0
  10b798:	e54b3005 	strb	r3, [fp, #-5]
#endif /* LWIP_MPU_COMPATIBLE */
  API_MSG_VAR_FREE(msg);

  return err;
  10b79c:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  10b7a0:	e1a00003 	mov	r0, r3
  10b7a4:	e24bd004 	sub	sp, fp, #4
  10b7a8:	e8bd8800 	pop	{fp, pc}

0010b7ac <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, const ip_addr_t *addr, u16_t port)
{
  10b7ac:	e92d4800 	push	{fp, lr}
  10b7b0:	e28db004 	add	fp, sp, #4
  10b7b4:	e24dd030 	sub	sp, sp, #48	; 0x30
  10b7b8:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10b7bc:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  10b7c0:	e1a03002 	mov	r3, r2
  10b7c4:	e14b32be 	strh	r3, [fp, #-46]	; 0xffffffd2
  API_MSG_VAR_DECLARE(msg);
  err_t err;
  
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  10b7c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b7cc:	e3530000 	cmp	r3, #0
  10b7d0:	1a000008 	bne	10b7f8 <netconn_bind+0x4c>
  10b7d4:	e30606a0 	movw	r0, #26272	; 0x66a0
  10b7d8:	e3400014 	movt	r0, #20
  10b7dc:	ebffde4c 	bl	103114 <rt_kprintf>
  10b7e0:	e3a010ff 	mov	r1, #255	; 0xff
  10b7e4:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b7e8:	e3400014 	movt	r0, #20
  10b7ec:	ebfffe22 	bl	10b07c <sys_arch_assert>
  10b7f0:	e3e0300f 	mvn	r3, #15
  10b7f4:	ea000013 	b	10b848 <netconn_bind+0x9c>

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
  if (addr == NULL) {
  10b7f8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10b7fc:	e3530000 	cmp	r3, #0
  10b800:	1a000002 	bne	10b810 <netconn_bind+0x64>
    addr = IP4_ADDR_ANY;
  10b804:	e3093b24 	movw	r3, #39716	; 0x9b24
  10b808:	e3403014 	movt	r3, #20
  10b80c:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
    addr = IP_ANY_TYPE;
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
  10b810:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b814:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
  10b818:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10b81c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  API_MSG_VAR_REF(msg).msg.bc.port = port;
  10b820:	e15b32be 	ldrh	r3, [fp, #-46]	; 0xffffffd2
  10b824:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  err = netconn_apimsg(lwip_netconn_do_bind, &API_MSG_VAR_REF(msg));
  10b828:	e24b3020 	sub	r3, fp, #32
  10b82c:	e1a01003 	mov	r1, r3
  10b830:	e30e0400 	movw	r0, #58368	; 0xe400
  10b834:	e3400010 	movt	r0, #16
  10b838:	ebffff03 	bl	10b44c <netconn_apimsg>
  10b83c:	e1a03000 	mov	r3, r0
  10b840:	e54b3005 	strb	r3, [fp, #-5]
  API_MSG_VAR_FREE(msg);

  return err;
  10b844:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  10b848:	e1a00003 	mov	r0, r3
  10b84c:	e24bd004 	sub	sp, fp, #4
  10b850:	e8bd8800 	pop	{fp, pc}

0010b854 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, const ip_addr_t *addr, u16_t port)
{
  10b854:	e92d4800 	push	{fp, lr}
  10b858:	e28db004 	add	fp, sp, #4
  10b85c:	e24dd030 	sub	sp, sp, #48	; 0x30
  10b860:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10b864:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  10b868:	e1a03002 	mov	r3, r2
  10b86c:	e14b32be 	strh	r3, [fp, #-46]	; 0xffffffd2
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  10b870:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b874:	e3530000 	cmp	r3, #0
  10b878:	1a000008 	bne	10b8a0 <netconn_connect+0x4c>
  10b87c:	e30606bc 	movw	r0, #26300	; 0x66bc
  10b880:	e3400014 	movt	r0, #20
  10b884:	ebffde22 	bl	103114 <rt_kprintf>
  10b888:	e300112b 	movw	r1, #299	; 0x12b
  10b88c:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b890:	e3400014 	movt	r0, #20
  10b894:	ebfffdf8 	bl	10b07c <sys_arch_assert>
  10b898:	e3e0300f 	mvn	r3, #15
  10b89c:	ea000013 	b	10b8f0 <netconn_connect+0x9c>

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
  if (addr == NULL) {
  10b8a0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10b8a4:	e3530000 	cmp	r3, #0
  10b8a8:	1a000002 	bne	10b8b8 <netconn_connect+0x64>
    addr = IP4_ADDR_ANY;
  10b8ac:	e3093b24 	movw	r3, #39716	; 0x9b24
  10b8b0:	e3403014 	movt	r3, #20
  10b8b4:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
  }
#endif /* LWIP_IPV4 */

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
  10b8b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b8bc:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
  10b8c0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10b8c4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  API_MSG_VAR_REF(msg).msg.bc.port = port;
  10b8c8:	e15b32be 	ldrh	r3, [fp, #-46]	; 0xffffffd2
  10b8cc:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  err = netconn_apimsg(lwip_netconn_do_connect, &API_MSG_VAR_REF(msg));
  10b8d0:	e24b3020 	sub	r3, fp, #32
  10b8d4:	e1a01003 	mov	r1, r3
  10b8d8:	e30e07a4 	movw	r0, #59300	; 0xe7a4
  10b8dc:	e3400010 	movt	r0, #16
  10b8e0:	ebfffed9 	bl	10b44c <netconn_apimsg>
  10b8e4:	e1a03000 	mov	r3, r0
  10b8e8:	e54b3005 	strb	r3, [fp, #-5]
  API_MSG_VAR_FREE(msg);

  return err;
  10b8ec:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  10b8f0:	e1a00003 	mov	r0, r3
  10b8f4:	e24bd004 	sub	sp, fp, #4
  10b8f8:	e8bd8800 	pop	{fp, pc}

0010b8fc <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return See @ref err_t
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  10b8fc:	e92d4800 	push	{fp, lr}
  10b900:	e28db004 	add	fp, sp, #4
  10b904:	e24dd028 	sub	sp, sp, #40	; 0x28
  10b908:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  10b90c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b910:	e3530000 	cmp	r3, #0
  10b914:	1a000008 	bne	10b93c <netconn_disconnect+0x40>
  10b918:	e30606dc 	movw	r0, #26332	; 0x66dc
  10b91c:	e3400014 	movt	r0, #20
  10b920:	ebffddfb 	bl	103114 <rt_kprintf>
  10b924:	e300114b 	movw	r1, #331	; 0x14b
  10b928:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b92c:	e3400014 	movt	r0, #20
  10b930:	ebfffdd1 	bl	10b07c <sys_arch_assert>
  10b934:	e3e0300f 	mvn	r3, #15
  10b938:	ea000009 	b	10b964 <netconn_disconnect+0x68>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
  10b93c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b940:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  err = netconn_apimsg(lwip_netconn_do_disconnect, &API_MSG_VAR_REF(msg));
  10b944:	e24b3020 	sub	r3, fp, #32
  10b948:	e1a01003 	mov	r1, r3
  10b94c:	e30e0adc 	movw	r0, #60124	; 0xeadc
  10b950:	e3400010 	movt	r0, #16
  10b954:	ebfffebc 	bl	10b44c <netconn_apimsg>
  10b958:	e1a03000 	mov	r3, r0
  10b95c:	e54b3005 	strb	r3, [fp, #-5]
  API_MSG_VAR_FREE(msg);

  return err;
  10b960:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  10b964:	e1a00003 	mov	r0, r3
  10b968:	e24bd004 	sub	sp, fp, #4
  10b96c:	e8bd8800 	pop	{fp, pc}

0010b970 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  10b970:	e92d4800 	push	{fp, lr}
  10b974:	e28db004 	add	fp, sp, #4
  10b978:	e24dd028 	sub	sp, sp, #40	; 0x28
  10b97c:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10b980:	e1a03001 	mov	r3, r1
  10b984:	e54b3029 	strb	r3, [fp, #-41]	; 0xffffffd7
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  10b988:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b98c:	e3530000 	cmp	r3, #0
  10b990:	1a000008 	bne	10b9b8 <netconn_listen_with_backlog+0x48>
  10b994:	e3060700 	movw	r0, #26368	; 0x6700
  10b998:	e3400014 	movt	r0, #20
  10b99c:	ebffdddc 	bl	103114 <rt_kprintf>
  10b9a0:	e3a01f5a 	mov	r1, #360	; 0x168
  10b9a4:	e30605b8 	movw	r0, #26040	; 0x65b8
  10b9a8:	e3400014 	movt	r0, #20
  10b9ac:	ebfffdb2 	bl	10b07c <sys_arch_assert>
  10b9b0:	e3e0300f 	mvn	r3, #15
  10b9b4:	ea000009 	b	10b9e0 <netconn_listen_with_backlog+0x70>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
  10b9b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10b9bc:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
#if TCP_LISTEN_BACKLOG
  API_MSG_VAR_REF(msg).msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  err = netconn_apimsg(lwip_netconn_do_listen, &API_MSG_VAR_REF(msg));
  10b9c0:	e24b3020 	sub	r3, fp, #32
  10b9c4:	e1a01003 	mov	r1, r3
  10b9c8:	e30e0b88 	movw	r0, #60296	; 0xeb88
  10b9cc:	e3400010 	movt	r0, #16
  10b9d0:	ebfffe9d 	bl	10b44c <netconn_apimsg>
  10b9d4:	e1a03000 	mov	r3, r0
  10b9d8:	e54b3005 	strb	r3, [fp, #-5]
  API_MSG_VAR_FREE(msg);

  return err;
  10b9dc:	e15b30d5 	ldrsb	r3, [fp, #-5]
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(backlog);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
  10b9e0:	e1a00003 	mov	r0, r3
  10b9e4:	e24bd004 	sub	sp, fp, #4
  10b9e8:	e8bd8800 	pop	{fp, pc}

0010b9ec <netconn_accept>:
 * @return ERR_OK if a new connection has been received or an error
 *                code otherwise
 */
err_t
netconn_accept(struct netconn *conn, struct netconn **new_conn)
{
  10b9ec:	e92d4800 	push	{fp, lr}
  10b9f0:	e28db004 	add	fp, sp, #4
  10b9f4:	e24dd010 	sub	sp, sp, #16
  10b9f8:	e50b0010 	str	r0, [fp, #-16]
  10b9fc:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct netconn *newconn;
#if TCP_LISTEN_BACKLOG
  API_MSG_VAR_DECLARE(msg);
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
  10ba00:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10ba04:	e3530000 	cmp	r3, #0
  10ba08:	1a000008 	bne	10ba30 <netconn_accept+0x44>
  10ba0c:	e3060720 	movw	r0, #26400	; 0x6720
  10ba10:	e3400014 	movt	r0, #20
  10ba14:	ebffddbe 	bl	103114 <rt_kprintf>
  10ba18:	e300118d 	movw	r1, #397	; 0x18d
  10ba1c:	e30605b8 	movw	r0, #26040	; 0x65b8
  10ba20:	e3400014 	movt	r0, #20
  10ba24:	ebfffd94 	bl	10b07c <sys_arch_assert>
  10ba28:	e3e0300f 	mvn	r3, #15
  10ba2c:	ea000053 	b	10bb80 <netconn_accept+0x194>
  *new_conn = NULL;
  10ba30:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10ba34:	e3a02000 	mov	r2, #0
  10ba38:	e5832000 	str	r2, [r3]
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
  10ba3c:	e51b3010 	ldr	r3, [fp, #-16]
  10ba40:	e3530000 	cmp	r3, #0
  10ba44:	1a000008 	bne	10ba6c <netconn_accept+0x80>
  10ba48:	e3060740 	movw	r0, #26432	; 0x6740
  10ba4c:	e3400014 	movt	r0, #20
  10ba50:	ebffddaf 	bl	103114 <rt_kprintf>
  10ba54:	e300118f 	movw	r1, #399	; 0x18f
  10ba58:	e30605b8 	movw	r0, #26040	; 0x65b8
  10ba5c:	e3400014 	movt	r0, #20
  10ba60:	ebfffd85 	bl	10b07c <sys_arch_assert>
  10ba64:	e3e0300f 	mvn	r3, #15
  10ba68:	ea000044 	b	10bb80 <netconn_accept+0x194>

  if (ERR_IS_FATAL(conn->last_err)) {
  10ba6c:	e51b3010 	ldr	r3, [fp, #-16]
  10ba70:	e1d330dc 	ldrsb	r3, [r3, #12]
  10ba74:	e373000c 	cmn	r3, #12
  10ba78:	aa000002 	bge	10ba88 <netconn_accept+0x9c>
    /* don't recv on fatal errors: this might block the application task
       waiting on acceptmbox forever! */
    return conn->last_err;
  10ba7c:	e51b3010 	ldr	r3, [fp, #-16]
  10ba80:	e1d330dc 	ldrsb	r3, [r3, #12]
  10ba84:	ea00003d 	b	10bb80 <netconn_accept+0x194>
  }
  if (!sys_mbox_valid(&conn->acceptmbox)) {
  10ba88:	e51b3010 	ldr	r3, [fp, #-16]
  10ba8c:	e2833018 	add	r3, r3, #24
  10ba90:	e1a00003 	mov	r0, r3
  10ba94:	ebfffd2f 	bl	10af58 <sys_mbox_valid>
  10ba98:	e1a03000 	mov	r3, r0
  10ba9c:	e3530000 	cmp	r3, #0
  10baa0:	1a000001 	bne	10baac <netconn_accept+0xc0>
    return ERR_CLSD;
  10baa4:	e3e0300e 	mvn	r3, #14
  10baa8:	ea000034 	b	10bb80 <netconn_accept+0x194>
#if TCP_LISTEN_BACKLOG
  API_MSG_VAR_ALLOC(msg);
#endif /* TCP_LISTEN_BACKLOG */

#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(&conn->acceptmbox, &accept_ptr, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
  10baac:	e51b3010 	ldr	r3, [fp, #-16]
  10bab0:	e2830018 	add	r0, r3, #24
  10bab4:	e51b3010 	ldr	r3, [fp, #-16]
  10bab8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  10babc:	e1a02003 	mov	r2, r3
  10bac0:	e24b300c 	sub	r3, fp, #12
  10bac4:	e1a01003 	mov	r1, r3
  10bac8:	ebfffcd1 	bl	10ae14 <sys_arch_mbox_fetch>
  10bacc:	e1a03000 	mov	r3, r0
  10bad0:	e3730001 	cmn	r3, #1
  10bad4:	1a000001 	bne	10bae0 <netconn_accept+0xf4>
#if TCP_LISTEN_BACKLOG
    API_MSG_VAR_FREE(msg);
#endif /* TCP_LISTEN_BACKLOG */
    return ERR_TIMEOUT;
  10bad8:	e3e03002 	mvn	r3, #2
  10badc:	ea000027 	b	10bb80 <netconn_accept+0x194>
  }
#else
  sys_arch_mbox_fetch(&conn->acceptmbox, &accept_ptr, 0);
#endif /* LWIP_SO_RCVTIMEO*/
  newconn = (struct netconn *)accept_ptr;
  10bae0:	e51b300c 	ldr	r3, [fp, #-12]
  10bae4:	e50b3008 	str	r3, [fp, #-8]
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  10bae8:	e51b3010 	ldr	r3, [fp, #-16]
  10baec:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10baf0:	e3530000 	cmp	r3, #0
  10baf4:	0a000005 	beq	10bb10 <netconn_accept+0x124>
  10baf8:	e51b3010 	ldr	r3, [fp, #-16]
  10bafc:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10bb00:	e3a02000 	mov	r2, #0
  10bb04:	e3a01001 	mov	r1, #1
  10bb08:	e51b0010 	ldr	r0, [fp, #-16]
  10bb0c:	e12fff33 	blx	r3

  if (accept_ptr == &netconn_aborted) {
  10bb10:	e51b200c 	ldr	r2, [fp, #-12]
  10bb14:	e300357c 	movw	r3, #1404	; 0x57c
  10bb18:	e3403015 	movt	r3, #21
  10bb1c:	e1520003 	cmp	r2, r3
  10bb20:	1a000001 	bne	10bb2c <netconn_accept+0x140>
    /* a connection has been aborted: out of pcbs or out of netconns during accept */
    /* @todo: set netconn error, but this would be fatal and thus block further accepts */
#if TCP_LISTEN_BACKLOG
    API_MSG_VAR_FREE(msg);
#endif /* TCP_LISTEN_BACKLOG */
    return ERR_ABRT;
  10bb24:	e3e0300c 	mvn	r3, #12
  10bb28:	ea000014 	b	10bb80 <netconn_accept+0x194>
  }
  if (newconn == NULL) {
  10bb2c:	e51b3008 	ldr	r3, [fp, #-8]
  10bb30:	e3530000 	cmp	r3, #0
  10bb34:	1a00000d 	bne	10bb70 <netconn_accept+0x184>
    /* connection has been aborted */
    /* in this special case, we set the netconn error from application thread, as
       on a ready-to-accept listening netconn, there should not be anything running
       in tcpip_thread */
    NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
  10bb38:	e51b3010 	ldr	r3, [fp, #-16]
  10bb3c:	e3530000 	cmp	r3, #0
  10bb40:	0a000008 	beq	10bb68 <netconn_accept+0x17c>
  10bb44:	ebffd9bc 	bl	10223c <rt_enter_critical>
  10bb48:	e51b3010 	ldr	r3, [fp, #-16]
  10bb4c:	e1d330dc 	ldrsb	r3, [r3, #12]
  10bb50:	e373000c 	cmn	r3, #12
  10bb54:	ba000002 	blt	10bb64 <netconn_accept+0x178>
  10bb58:	e51b3010 	ldr	r3, [fp, #-16]
  10bb5c:	e3e0200e 	mvn	r2, #14
  10bb60:	e5c3200c 	strb	r2, [r3, #12]
  10bb64:	ebffd9ba 	bl	102254 <rt_exit_critical>
#if TCP_LISTEN_BACKLOG
    API_MSG_VAR_FREE(msg);
#endif /* TCP_LISTEN_BACKLOG */
    return ERR_CLSD;
  10bb68:	e3e0300e 	mvn	r3, #14
  10bb6c:	ea000003 	b	10bb80 <netconn_accept+0x194>
  /* don't care for the return value of lwip_netconn_do_recv */
  netconn_apimsg(lwip_netconn_do_accepted, &API_MSG_VAR_REF(msg));
  API_MSG_VAR_FREE(msg);
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
  10bb70:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10bb74:	e51b2008 	ldr	r2, [fp, #-8]
  10bb78:	e5832000 	str	r2, [r3]
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
  10bb7c:	e3a03000 	mov	r3, #0
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
  10bb80:	e1a00003 	mov	r0, r3
  10bb84:	e24bd004 	sub	sp, fp, #4
  10bb88:	e8bd8800 	pop	{fp, pc}

0010bb8c <netconn_recv_data>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t
netconn_recv_data(struct netconn *conn, void **new_buf)
{
  10bb8c:	e92d4800 	push	{fp, lr}
  10bb90:	e28db004 	add	fp, sp, #4
  10bb94:	e24dd028 	sub	sp, sp, #40	; 0x28
  10bb98:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10bb9c:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  void *buf = NULL;
  10bba0:	e3a03000 	mov	r3, #0
  10bba4:	e50b300c 	str	r3, [fp, #-12]
#if LWIP_MPU_COMPATIBLE
  msg = NULL;
#endif
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  10bba8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10bbac:	e3530000 	cmp	r3, #0
  10bbb0:	1a000008 	bne	10bbd8 <netconn_recv_data+0x4c>
  10bbb4:	e3060760 	movw	r0, #26464	; 0x6760
  10bbb8:	e3400014 	movt	r0, #20
  10bbbc:	ebffdd54 	bl	103114 <rt_kprintf>
  10bbc0:	e30011e7 	movw	r1, #487	; 0x1e7
  10bbc4:	e30605b8 	movw	r0, #26040	; 0x65b8
  10bbc8:	e3400014 	movt	r0, #20
  10bbcc:	ebfffd2a 	bl	10b07c <sys_arch_assert>
  10bbd0:	e3e0300f 	mvn	r3, #15
  10bbd4:	ea0000a5 	b	10be70 <netconn_recv_data+0x2e4>
  *new_buf = NULL;
  10bbd8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10bbdc:	e3a02000 	mov	r2, #0
  10bbe0:	e5832000 	str	r2, [r3]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
  10bbe4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bbe8:	e3530000 	cmp	r3, #0
  10bbec:	1a000008 	bne	10bc14 <netconn_recv_data+0x88>
  10bbf0:	e3060780 	movw	r0, #26496	; 0x6780
  10bbf4:	e3400014 	movt	r0, #20
  10bbf8:	ebffdd45 	bl	103114 <rt_kprintf>
  10bbfc:	e30011e9 	movw	r1, #489	; 0x1e9
  10bc00:	e30605b8 	movw	r0, #26040	; 0x65b8
  10bc04:	e3400014 	movt	r0, #20
  10bc08:	ebfffd1b 	bl	10b07c <sys_arch_assert>
  10bc0c:	e3e0300f 	mvn	r3, #15
  10bc10:	ea000096 	b	10be70 <netconn_recv_data+0x2e4>
#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
  10bc14:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bc18:	e5933000 	ldr	r3, [r3]
  10bc1c:	e20330f0 	and	r3, r3, #240	; 0xf0
  10bc20:	e3530010 	cmp	r3, #16
  10bc24:	1a000011 	bne	10bc70 <netconn_recv_data+0xe4>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    if (!sys_mbox_valid(&conn->recvmbox)) {
  10bc28:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bc2c:	e2833014 	add	r3, r3, #20
  10bc30:	e1a00003 	mov	r0, r3
  10bc34:	ebfffcc7 	bl	10af58 <sys_mbox_valid>
  10bc38:	e1a03000 	mov	r3, r0
  10bc3c:	e3530000 	cmp	r3, #0
  10bc40:	1a00000a 	bne	10bc70 <netconn_recv_data+0xe4>
      /* This happens when calling this function after receiving FIN */
      return sys_mbox_valid(&conn->acceptmbox) ? ERR_CONN : ERR_CLSD;
  10bc44:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bc48:	e2833018 	add	r3, r3, #24
  10bc4c:	e1a00003 	mov	r0, r3
  10bc50:	ebfffcc0 	bl	10af58 <sys_mbox_valid>
  10bc54:	e1a03000 	mov	r3, r0
  10bc58:	e3530000 	cmp	r3, #0
  10bc5c:	0a000001 	beq	10bc68 <netconn_recv_data+0xdc>
  10bc60:	e3e0300a 	mvn	r3, #10
  10bc64:	ea000081 	b	10be70 <netconn_recv_data+0x2e4>
  10bc68:	e3e0300e 	mvn	r3, #14
  10bc6c:	ea00007f 	b	10be70 <netconn_recv_data+0x2e4>
    }
  }
#endif /* LWIP_TCP */
  LWIP_ERROR("netconn_recv: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
  10bc70:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bc74:	e2833014 	add	r3, r3, #20
  10bc78:	e1a00003 	mov	r0, r3
  10bc7c:	ebfffcb5 	bl	10af58 <sys_mbox_valid>
  10bc80:	e1a03000 	mov	r3, r0
  10bc84:	e3530000 	cmp	r3, #0
  10bc88:	1a000008 	bne	10bcb0 <netconn_recv_data+0x124>
  10bc8c:	e306079c 	movw	r0, #26524	; 0x679c
  10bc90:	e3400014 	movt	r0, #20
  10bc94:	ebffdd1e 	bl	103114 <rt_kprintf>
  10bc98:	e30011f5 	movw	r1, #501	; 0x1f5
  10bc9c:	e30605b8 	movw	r0, #26040	; 0x65b8
  10bca0:	e3400014 	movt	r0, #20
  10bca4:	ebfffcf4 	bl	10b07c <sys_arch_assert>
  10bca8:	e3e0300a 	mvn	r3, #10
  10bcac:	ea00006f 	b	10be70 <netconn_recv_data+0x2e4>

  if (ERR_IS_FATAL(conn->last_err)) {
  10bcb0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bcb4:	e1d330dc 	ldrsb	r3, [r3, #12]
  10bcb8:	e373000c 	cmn	r3, #12
  10bcbc:	aa000002 	bge	10bccc <netconn_recv_data+0x140>
    /* don't recv on fatal errors: this might block the application task
       waiting on recvmbox forever! */
    /* @todo: this does not allow us to fetch data that has been put into recvmbox
       before the fatal error occurred - is that a problem? */
    return conn->last_err;
  10bcc0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bcc4:	e1d330dc 	ldrsb	r3, [r3, #12]
  10bcc8:	ea000068 	b	10be70 <netconn_recv_data+0x2e4>
    API_MSG_VAR_ALLOC(msg);
  }
#endif /* LWIP_TCP */

#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
  10bccc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bcd0:	e2830014 	add	r0, r3, #20
  10bcd4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bcd8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  10bcdc:	e1a02003 	mov	r2, r3
  10bce0:	e24b300c 	sub	r3, fp, #12
  10bce4:	e1a01003 	mov	r1, r3
  10bce8:	ebfffc49 	bl	10ae14 <sys_arch_mbox_fetch>
  10bcec:	e1a03000 	mov	r3, r0
  10bcf0:	e3730001 	cmn	r3, #1
  10bcf4:	1a000001 	bne	10bd00 <netconn_recv_data+0x174>
#endif /* (LWIP_UDP || LWIP_RAW) */
    {
      API_MSG_VAR_FREE(msg);
    }
#endif /* LWIP_TCP */
    return ERR_TIMEOUT;
  10bcf8:	e3e03002 	mvn	r3, #2
  10bcfc:	ea00005b 	b	10be70 <netconn_recv_data+0x2e4>
  sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
  10bd00:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bd04:	e5933000 	ldr	r3, [r3]
  10bd08:	e20330f0 	and	r3, r3, #240	; 0xf0
  10bd0c:	e3530010 	cmp	r3, #16
  10bd10:	1a000032 	bne	10bde0 <netconn_recv_data+0x254>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    /* Let the stack know that we have taken the data. */
    /* @todo: Speedup: Don't block and wait for the answer here
       (to prevent multiple thread-switches). */
    API_MSG_VAR_REF(msg).conn = conn;
  10bd14:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bd18:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    if (buf != NULL) {
  10bd1c:	e51b300c 	ldr	r3, [fp, #-12]
  10bd20:	e3530000 	cmp	r3, #0
  10bd24:	0a000003 	beq	10bd38 <netconn_recv_data+0x1ac>
      API_MSG_VAR_REF(msg).msg.r.len = ((struct pbuf *)buf)->tot_len;
  10bd28:	e51b300c 	ldr	r3, [fp, #-12]
  10bd2c:	e1d330b8 	ldrh	r3, [r3, #8]
  10bd30:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  10bd34:	ea000001 	b	10bd40 <netconn_recv_data+0x1b4>
    } else {
      API_MSG_VAR_REF(msg).msg.r.len = 1;
  10bd38:	e3a03001 	mov	r3, #1
  10bd3c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    }

    /* don't care for the return value of lwip_netconn_do_recv */
    netconn_apimsg(lwip_netconn_do_recv, &API_MSG_VAR_REF(msg));
  10bd40:	e24b3024 	sub	r3, fp, #36	; 0x24
  10bd44:	e1a01003 	mov	r1, r3
  10bd48:	e30f0034 	movw	r0, #61492	; 0xf034
  10bd4c:	e3400010 	movt	r0, #16
  10bd50:	ebfffdbd 	bl	10b44c <netconn_apimsg>
    API_MSG_VAR_FREE(msg);

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (buf == NULL) {
  10bd54:	e51b300c 	ldr	r3, [fp, #-12]
  10bd58:	e3530000 	cmp	r3, #0
  10bd5c:	1a00001b 	bne	10bdd0 <netconn_recv_data+0x244>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  10bd60:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bd64:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10bd68:	e3530000 	cmp	r3, #0
  10bd6c:	0a000005 	beq	10bd88 <netconn_recv_data+0x1fc>
  10bd70:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bd74:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10bd78:	e3a02000 	mov	r2, #0
  10bd7c:	e3a01001 	mov	r1, #1
  10bd80:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  10bd84:	e12fff33 	blx	r3
      if (conn->pcb.ip == NULL) {
  10bd88:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bd8c:	e5933008 	ldr	r3, [r3, #8]
  10bd90:	e3530000 	cmp	r3, #0
  10bd94:	1a000008 	bne	10bdbc <netconn_recv_data+0x230>
        /* race condition: RST during recv */
        return conn->last_err == ERR_OK ? ERR_RST : conn->last_err;
  10bd98:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bd9c:	e1d330dc 	ldrsb	r3, [r3, #12]
  10bda0:	e3530000 	cmp	r3, #0
  10bda4:	0a000002 	beq	10bdb4 <netconn_recv_data+0x228>
  10bda8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10bdac:	e1d330dc 	ldrsb	r3, [r3, #12]
  10bdb0:	ea00002e 	b	10be70 <netconn_recv_data+0x2e4>
  10bdb4:	e3e0300d 	mvn	r3, #13
  10bdb8:	ea00002c 	b	10be70 <netconn_recv_data+0x2e4>
      }
      /* RX side is closed, so deallocate the recvmbox */
      netconn_close_shutdown(conn, NETCONN_SHUT_RD);
  10bdbc:	e3a01001 	mov	r1, #1
  10bdc0:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  10bdc4:	eb00015a 	bl	10c334 <netconn_close_shutdown>
      /* Don' store ERR_CLSD as conn->err since we are only half-closed */
      return ERR_CLSD;
  10bdc8:	e3e0300e 	mvn	r3, #14
  10bdcc:	ea000027 	b	10be70 <netconn_recv_data+0x2e4>
    }
    len = ((struct pbuf *)buf)->tot_len;
  10bdd0:	e51b300c 	ldr	r3, [fp, #-12]
  10bdd4:	e1d330b8 	ldrh	r3, [r3, #8]
  10bdd8:	e14b30b6 	strh	r3, [fp, #-6]
  10bddc:	ea00000d 	b	10be18 <netconn_recv_data+0x28c>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
  10bde0:	e51b300c 	ldr	r3, [fp, #-12]
  10bde4:	e3530000 	cmp	r3, #0
  10bde8:	1a000006 	bne	10be08 <netconn_recv_data+0x27c>
  10bdec:	e30607bc 	movw	r0, #26556	; 0x67bc
  10bdf0:	e3400014 	movt	r0, #20
  10bdf4:	ebffdcc6 	bl	103114 <rt_kprintf>
  10bdf8:	e300123e 	movw	r1, #574	; 0x23e
  10bdfc:	e30605b8 	movw	r0, #26040	; 0x65b8
  10be00:	e3400014 	movt	r0, #20
  10be04:	ebfffc9c 	bl	10b07c <sys_arch_assert>
    len = netbuf_len((struct netbuf*)buf);
  10be08:	e51b300c 	ldr	r3, [fp, #-12]
  10be0c:	e5933000 	ldr	r3, [r3]
  10be10:	e1d330b8 	ldrh	r3, [r3, #8]
  10be14:	e14b30b6 	strh	r3, [fp, #-6]
  }
#endif /* (LWIP_UDP || LWIP_RAW) */

#if LWIP_SO_RCVBUF
  SYS_ARCH_DEC(conn->recv_avail, len);
  10be18:	ebffd907 	bl	10223c <rt_enter_critical>
  10be1c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10be20:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
  10be24:	e15b30b6 	ldrh	r3, [fp, #-6]
  10be28:	e0422003 	sub	r2, r2, r3
  10be2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10be30:	e583202c 	str	r2, [r3, #44]	; 0x2c
  10be34:	ebffd906 	bl	102254 <rt_exit_critical>
#endif /* LWIP_SO_RCVBUF */
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  10be38:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10be3c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10be40:	e3530000 	cmp	r3, #0
  10be44:	0a000005 	beq	10be60 <netconn_recv_data+0x2d4>
  10be48:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10be4c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10be50:	e15b20b6 	ldrh	r2, [fp, #-6]
  10be54:	e3a01001 	mov	r1, #1
  10be58:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  10be5c:	e12fff33 	blx	r3

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
  10be60:	e51b200c 	ldr	r2, [fp, #-12]
  10be64:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10be68:	e5832000 	str	r2, [r3]
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
  10be6c:	e3a03000 	mov	r3, #0
}
  10be70:	e1a00003 	mov	r0, r3
  10be74:	e24bd004 	sub	sp, fp, #4
  10be78:	e8bd8800 	pop	{fp, pc}

0010be7c <netconn_recv_tcp_pbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t
netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
  10be7c:	e92d4800 	push	{fp, lr}
  10be80:	e28db004 	add	fp, sp, #4
  10be84:	e24dd008 	sub	sp, sp, #8
  10be88:	e50b0008 	str	r0, [fp, #-8]
  10be8c:	e50b100c 	str	r1, [fp, #-12]
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
  10be90:	e51b3008 	ldr	r3, [fp, #-8]
  10be94:	e3530000 	cmp	r3, #0
  10be98:	0a000004 	beq	10beb0 <netconn_recv_tcp_pbuf+0x34>
  10be9c:	e51b3008 	ldr	r3, [fp, #-8]
  10bea0:	e5933000 	ldr	r3, [r3]
  10bea4:	e20330f0 	and	r3, r3, #240	; 0xf0
  10bea8:	e3530010 	cmp	r3, #16
  10beac:	0a000008 	beq	10bed4 <netconn_recv_tcp_pbuf+0x58>
  10beb0:	e3060780 	movw	r0, #26496	; 0x6780
  10beb4:	e3400014 	movt	r0, #20
  10beb8:	ebffdc95 	bl	103114 <rt_kprintf>
  10bebc:	e300125e 	movw	r1, #606	; 0x25e
  10bec0:	e30605b8 	movw	r0, #26040	; 0x65b8
  10bec4:	e3400014 	movt	r0, #20
  10bec8:	ebfffc6b 	bl	10b07c <sys_arch_assert>
  10becc:	e3e0300f 	mvn	r3, #15
  10bed0:	ea000003 	b	10bee4 <netconn_recv_tcp_pbuf+0x68>
             NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf);
  10bed4:	e51b100c 	ldr	r1, [fp, #-12]
  10bed8:	e51b0008 	ldr	r0, [fp, #-8]
  10bedc:	ebffff2a 	bl	10bb8c <netconn_recv_data>
  10bee0:	e1a03000 	mov	r3, r0
}
  10bee4:	e1a00003 	mov	r0, r3
  10bee8:	e24bd004 	sub	sp, fp, #4
  10beec:	e8bd8800 	pop	{fp, pc}

0010bef0 <netconn_recv>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t
netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
  10bef0:	e92d4800 	push	{fp, lr}
  10bef4:	e28db004 	add	fp, sp, #4
  10bef8:	e24dd018 	sub	sp, sp, #24
  10befc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10bf00:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
#if LWIP_TCP
  struct netbuf *buf = NULL;
  10bf04:	e3a03000 	mov	r3, #0
  10bf08:	e50b3008 	str	r3, [fp, #-8]
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  10bf0c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10bf10:	e3530000 	cmp	r3, #0
  10bf14:	1a000008 	bne	10bf3c <netconn_recv+0x4c>
  10bf18:	e3060760 	movw	r0, #26464	; 0x6760
  10bf1c:	e3400014 	movt	r0, #20
  10bf20:	ebffdc7b 	bl	103114 <rt_kprintf>
  10bf24:	e3a01f9d 	mov	r1, #628	; 0x274
  10bf28:	e30605b8 	movw	r0, #26040	; 0x65b8
  10bf2c:	e3400014 	movt	r0, #20
  10bf30:	ebfffc51 	bl	10b07c <sys_arch_assert>
  10bf34:	e3e0300f 	mvn	r3, #15
  10bf38:	ea00004d 	b	10c074 <netconn_recv+0x184>
  *new_buf = NULL;
  10bf3c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10bf40:	e3a02000 	mov	r2, #0
  10bf44:	e5832000 	str	r2, [r3]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
  10bf48:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10bf4c:	e3530000 	cmp	r3, #0
  10bf50:	1a000008 	bne	10bf78 <netconn_recv+0x88>
  10bf54:	e3060780 	movw	r0, #26496	; 0x6780
  10bf58:	e3400014 	movt	r0, #20
  10bf5c:	ebffdc6c 	bl	103114 <rt_kprintf>
  10bf60:	e3001276 	movw	r1, #630	; 0x276
  10bf64:	e30605b8 	movw	r0, #26040	; 0x65b8
  10bf68:	e3400014 	movt	r0, #20
  10bf6c:	ebfffc42 	bl	10b07c <sys_arch_assert>
  10bf70:	e3e0300f 	mvn	r3, #15
  10bf74:	ea00003e 	b	10c074 <netconn_recv+0x184>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP)
  10bf78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10bf7c:	e5933000 	ldr	r3, [r3]
  10bf80:	e20330f0 	and	r3, r3, #240	; 0xf0
  10bf84:	e3530010 	cmp	r3, #16
  10bf88:	1a000035 	bne	10c064 <netconn_recv+0x174>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
  10bf8c:	e3a03000 	mov	r3, #0
  10bf90:	e50b3010 	str	r3, [fp, #-16]
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
  10bf94:	e3a02d0a 	mov	r2, #640	; 0x280
  10bf98:	e30615b8 	movw	r1, #26040	; 0x65b8
  10bf9c:	e3401014 	movt	r1, #20
  10bfa0:	e3a00007 	mov	r0, #7
  10bfa4:	eb0034cc 	bl	1192dc <memp_malloc_fn>
  10bfa8:	e50b0008 	str	r0, [fp, #-8]
    if (buf == NULL) {
  10bfac:	e51b3008 	ldr	r3, [fp, #-8]
  10bfb0:	e3530000 	cmp	r3, #0
  10bfb4:	1a000001 	bne	10bfc0 <netconn_recv+0xd0>
      return ERR_MEM;
  10bfb8:	e3e03000 	mvn	r3, #0
  10bfbc:	ea00002c 	b	10c074 <netconn_recv+0x184>
    }

    err = netconn_recv_data(conn, (void **)&p);
  10bfc0:	e24b3010 	sub	r3, fp, #16
  10bfc4:	e1a01003 	mov	r1, r3
  10bfc8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  10bfcc:	ebfffeee 	bl	10bb8c <netconn_recv_data>
  10bfd0:	e1a03000 	mov	r3, r0
  10bfd4:	e54b3009 	strb	r3, [fp, #-9]
    if (err != ERR_OK) {
  10bfd8:	e15b30d9 	ldrsb	r3, [fp, #-9]
  10bfdc:	e3530000 	cmp	r3, #0
  10bfe0:	0a000004 	beq	10bff8 <netconn_recv+0x108>
      memp_free(MEMP_NETBUF, buf);
  10bfe4:	e51b1008 	ldr	r1, [fp, #-8]
  10bfe8:	e3a00007 	mov	r0, #7
  10bfec:	eb003522 	bl	11947c <memp_free>
      return err;
  10bff0:	e15b30d9 	ldrsb	r3, [fp, #-9]
  10bff4:	ea00001e 	b	10c074 <netconn_recv+0x184>
    }
    LWIP_ASSERT("p != NULL", p != NULL);
  10bff8:	e51b3010 	ldr	r3, [fp, #-16]
  10bffc:	e3530000 	cmp	r3, #0
  10c000:	1a000006 	bne	10c020 <netconn_recv+0x130>
  10c004:	e30607c8 	movw	r0, #26568	; 0x67c8
  10c008:	e3400014 	movt	r0, #20
  10c00c:	ebffdc40 	bl	103114 <rt_kprintf>
  10c010:	e300128a 	movw	r1, #650	; 0x28a
  10c014:	e30605b8 	movw	r0, #26040	; 0x65b8
  10c018:	e3400014 	movt	r0, #20
  10c01c:	ebfffc16 	bl	10b07c <sys_arch_assert>

    buf->p = p;
  10c020:	e51b2010 	ldr	r2, [fp, #-16]
  10c024:	e51b3008 	ldr	r3, [fp, #-8]
  10c028:	e5832000 	str	r2, [r3]
    buf->ptr = p;
  10c02c:	e51b2010 	ldr	r2, [fp, #-16]
  10c030:	e51b3008 	ldr	r3, [fp, #-8]
  10c034:	e5832004 	str	r2, [r3, #4]
    buf->port = 0;
  10c038:	e51b3008 	ldr	r3, [fp, #-8]
  10c03c:	e3a02000 	mov	r2, #0
  10c040:	e1c320bc 	strh	r2, [r3, #12]
    ip_addr_set_zero(&buf->addr);
  10c044:	e51b3008 	ldr	r3, [fp, #-8]
  10c048:	e3a02000 	mov	r2, #0
  10c04c:	e5832008 	str	r2, [r3, #8]
    *new_buf = buf;
  10c050:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10c054:	e51b2008 	ldr	r2, [fp, #-8]
  10c058:	e5832000 	str	r2, [r3]
    /* don't set conn->last_err: it's only ERR_OK, anyway */
    return ERR_OK;
  10c05c:	e3a03000 	mov	r3, #0
  10c060:	ea000003 	b	10c074 <netconn_recv+0x184>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
  10c064:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  10c068:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  10c06c:	ebfffec6 	bl	10bb8c <netconn_recv_data>
  10c070:	e1a03000 	mov	r3, r0
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
  10c074:	e1a00003 	mov	r0, r3
  10c078:	e24bd004 	sub	sp, fp, #4
  10c07c:	e8bd8800 	pop	{fp, pc}

0010c080 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, const ip_addr_t *addr, u16_t port)
{
  10c080:	e92d4800 	push	{fp, lr}
  10c084:	e28db004 	add	fp, sp, #4
  10c088:	e24dd010 	sub	sp, sp, #16
  10c08c:	e50b0008 	str	r0, [fp, #-8]
  10c090:	e50b100c 	str	r1, [fp, #-12]
  10c094:	e50b2010 	str	r2, [fp, #-16]
  10c098:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  if (buf != NULL) {
  10c09c:	e51b300c 	ldr	r3, [fp, #-12]
  10c0a0:	e3530000 	cmp	r3, #0
  10c0a4:	0a000010 	beq	10c0ec <netconn_sendto+0x6c>
    ip_addr_set(&buf->addr, addr);
  10c0a8:	e51b3010 	ldr	r3, [fp, #-16]
  10c0ac:	e3530000 	cmp	r3, #0
  10c0b0:	0a000002 	beq	10c0c0 <netconn_sendto+0x40>
  10c0b4:	e51b3010 	ldr	r3, [fp, #-16]
  10c0b8:	e5933000 	ldr	r3, [r3]
  10c0bc:	ea000000 	b	10c0c4 <netconn_sendto+0x44>
  10c0c0:	e3a03000 	mov	r3, #0
  10c0c4:	e51b200c 	ldr	r2, [fp, #-12]
  10c0c8:	e5823008 	str	r3, [r2, #8]
    buf->port = port;
  10c0cc:	e51b300c 	ldr	r3, [fp, #-12]
  10c0d0:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
  10c0d4:	e1c320bc 	strh	r2, [r3, #12]
    return netconn_send(conn, buf);
  10c0d8:	e51b100c 	ldr	r1, [fp, #-12]
  10c0dc:	e51b0008 	ldr	r0, [fp, #-8]
  10c0e0:	eb000005 	bl	10c0fc <netconn_send>
  10c0e4:	e1a03000 	mov	r3, r0
  10c0e8:	ea000000 	b	10c0f0 <netconn_sendto+0x70>
  }
  return ERR_VAL;
  10c0ec:	e3e03005 	mvn	r3, #5
}
  10c0f0:	e1a00003 	mov	r0, r3
  10c0f4:	e24bd004 	sub	sp, fp, #4
  10c0f8:	e8bd8800 	pop	{fp, pc}

0010c0fc <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  10c0fc:	e92d4800 	push	{fp, lr}
  10c100:	e28db004 	add	fp, sp, #4
  10c104:	e24dd028 	sub	sp, sp, #40	; 0x28
  10c108:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10c10c:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  10c110:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c114:	e3530000 	cmp	r3, #0
  10c118:	1a000008 	bne	10c140 <netconn_send+0x44>
  10c11c:	e30607d4 	movw	r0, #26580	; 0x67d4
  10c120:	e3400014 	movt	r0, #20
  10c124:	ebffdbfa 	bl	103114 <rt_kprintf>
  10c128:	e30012c3 	movw	r1, #707	; 0x2c3
  10c12c:	e30605b8 	movw	r0, #26040	; 0x65b8
  10c130:	e3400014 	movt	r0, #20
  10c134:	ebfffbd0 	bl	10b07c <sys_arch_assert>
  10c138:	e3e0300f 	mvn	r3, #15
  10c13c:	ea00000b 	b	10c170 <netconn_send+0x74>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
  10c140:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c144:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  API_MSG_VAR_REF(msg).msg.b = buf;
  10c148:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10c14c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  err = netconn_apimsg(lwip_netconn_do_send, &API_MSG_VAR_REF(msg));
  10c150:	e24b3020 	sub	r3, fp, #32
  10c154:	e1a01003 	mov	r1, r3
  10c158:	e30e0e28 	movw	r0, #60968	; 0xee28
  10c15c:	e3400010 	movt	r0, #16
  10c160:	ebfffcb9 	bl	10b44c <netconn_apimsg>
  10c164:	e1a03000 	mov	r3, r0
  10c168:	e54b3005 	strb	r3, [fp, #-5]
  API_MSG_VAR_FREE(msg);

  return err;
  10c16c:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  10c170:	e1a00003 	mov	r0, r3
  10c174:	e24bd004 	sub	sp, fp, #4
  10c178:	e8bd8800 	pop	{fp, pc}

0010c17c <netconn_write_partly>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
                     u8_t apiflags, size_t *bytes_written)
{
  10c17c:	e92d4800 	push	{fp, lr}
  10c180:	e28db004 	add	fp, sp, #4
  10c184:	e24dd030 	sub	sp, sp, #48	; 0x30
  10c188:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10c18c:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  10c190:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  10c194:	e54b3031 	strb	r3, [fp, #-49]	; 0xffffffcf
  API_MSG_VAR_DECLARE(msg);
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  10c198:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c19c:	e3530000 	cmp	r3, #0
  10c1a0:	1a000008 	bne	10c1c8 <netconn_write_partly+0x4c>
  10c1a4:	e30607f0 	movw	r0, #26608	; 0x67f0
  10c1a8:	e3400014 	movt	r0, #20
  10c1ac:	ebffdbd8 	bl	103114 <rt_kprintf>
  10c1b0:	e30012e6 	movw	r1, #742	; 0x2e6
  10c1b4:	e30605b8 	movw	r0, #26040	; 0x65b8
  10c1b8:	e3400014 	movt	r0, #20
  10c1bc:	ebfffbae 	bl	10b07c <sys_arch_assert>
  10c1c0:	e3e0300f 	mvn	r3, #15
  10c1c4:	ea000057 	b	10c328 <netconn_write_partly+0x1ac>
  LWIP_ERROR("netconn_write: invalid conn->type",  (NETCONNTYPE_GROUP(conn->type)== NETCONN_TCP), return ERR_VAL;);
  10c1c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c1cc:	e5933000 	ldr	r3, [r3]
  10c1d0:	e20330f0 	and	r3, r3, #240	; 0xf0
  10c1d4:	e3530010 	cmp	r3, #16
  10c1d8:	0a000008 	beq	10c200 <netconn_write_partly+0x84>
  10c1dc:	e306080c 	movw	r0, #26636	; 0x680c
  10c1e0:	e3400014 	movt	r0, #20
  10c1e4:	ebffdbca 	bl	103114 <rt_kprintf>
  10c1e8:	e30012e7 	movw	r1, #743	; 0x2e7
  10c1ec:	e30605b8 	movw	r0, #26040	; 0x65b8
  10c1f0:	e3400014 	movt	r0, #20
  10c1f4:	ebfffba0 	bl	10b07c <sys_arch_assert>
  10c1f8:	e3e03005 	mvn	r3, #5
  10c1fc:	ea000049 	b	10c328 <netconn_write_partly+0x1ac>
  if (size == 0) {
  10c200:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  10c204:	e3530000 	cmp	r3, #0
  10c208:	1a000001 	bne	10c214 <netconn_write_partly+0x98>
    return ERR_OK;
  10c20c:	e3a03000 	mov	r3, #0
  10c210:	ea000044 	b	10c328 <netconn_write_partly+0x1ac>
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
  10c214:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c218:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10c21c:	e2033002 	and	r3, r3, #2
  10c220:	e3530000 	cmp	r3, #0
  10c224:	1a000003 	bne	10c238 <netconn_write_partly+0xbc>
  10c228:	e55b3031 	ldrb	r3, [fp, #-49]	; 0xffffffcf
  10c22c:	e2033004 	and	r3, r3, #4
  10c230:	e3530000 	cmp	r3, #0
  10c234:	0a000001 	beq	10c240 <netconn_write_partly+0xc4>
  10c238:	e3a03001 	mov	r3, #1
  10c23c:	ea000000 	b	10c244 <netconn_write_partly+0xc8>
  10c240:	e3a03000 	mov	r3, #0
  10c244:	e54b3005 	strb	r3, [fp, #-5]
#if LWIP_SO_SNDTIMEO
  if (conn->send_timeout != 0) {
  10c248:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c24c:	e5933020 	ldr	r3, [r3, #32]
  10c250:	e3530000 	cmp	r3, #0
  10c254:	0a000001 	beq	10c260 <netconn_write_partly+0xe4>
    dontblock = 1;
  10c258:	e3a03001 	mov	r3, #1
  10c25c:	e54b3005 	strb	r3, [fp, #-5]
  }
#endif /* LWIP_SO_SNDTIMEO */
  if (dontblock && !bytes_written) {
  10c260:	e55b3005 	ldrb	r3, [fp, #-5]
  10c264:	e3530000 	cmp	r3, #0
  10c268:	0a000004 	beq	10c280 <netconn_write_partly+0x104>
  10c26c:	e59b3004 	ldr	r3, [fp, #4]
  10c270:	e3530000 	cmp	r3, #0
  10c274:	1a000001 	bne	10c280 <netconn_write_partly+0x104>
    /* This implies netconn_write() cannot be used for non-blocking send, since
       it has no way to return the number of bytes written. */
    return ERR_VAL;
  10c278:	e3e03005 	mvn	r3, #5
  10c27c:	ea000029 	b	10c328 <netconn_write_partly+0x1ac>
  }

  API_MSG_VAR_ALLOC(msg);
  /* non-blocking write sends as much  */
  API_MSG_VAR_REF(msg).conn = conn;
  10c280:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c284:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  API_MSG_VAR_REF(msg).msg.w.dataptr = dataptr;
  10c288:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10c28c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  API_MSG_VAR_REF(msg).msg.w.apiflags = apiflags;
  10c290:	e55b3031 	ldrb	r3, [fp, #-49]	; 0xffffffcf
  10c294:	e54b3010 	strb	r3, [fp, #-16]
  API_MSG_VAR_REF(msg).msg.w.len = size;
  10c298:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  10c29c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
#if LWIP_SO_SNDTIMEO
  if (conn->send_timeout != 0) {
  10c2a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c2a4:	e5933020 	ldr	r3, [r3, #32]
  10c2a8:	e3530000 	cmp	r3, #0
  10c2ac:	0a000003 	beq	10c2c0 <netconn_write_partly+0x144>
    /* get the time we started, which is later compared to
        sys_now() + conn->send_timeout */
    API_MSG_VAR_REF(msg).msg.w.time_started = sys_now();
  10c2b0:	ebfffb8a 	bl	10b0e0 <sys_now>
  10c2b4:	e1a03000 	mov	r3, r0
  10c2b8:	e50b300c 	str	r3, [fp, #-12]
  10c2bc:	ea000001 	b	10c2c8 <netconn_write_partly+0x14c>
  } else {
    API_MSG_VAR_REF(msg).msg.w.time_started = 0;
  10c2c0:	e3a03000 	mov	r3, #0
  10c2c4:	e50b300c 	str	r3, [fp, #-12]
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = netconn_apimsg(lwip_netconn_do_write, &API_MSG_VAR_REF(msg));
  10c2c8:	e24b3020 	sub	r3, fp, #32
  10c2cc:	e1a01003 	mov	r1, r3
  10c2d0:	e30f0720 	movw	r0, #63264	; 0xf720
  10c2d4:	e3400010 	movt	r0, #16
  10c2d8:	ebfffc5b 	bl	10b44c <netconn_apimsg>
  10c2dc:	e1a03000 	mov	r3, r0
  10c2e0:	e54b3006 	strb	r3, [fp, #-6]
  if ((err == ERR_OK) && (bytes_written != NULL)) {
  10c2e4:	e15b30d6 	ldrsb	r3, [fp, #-6]
  10c2e8:	e3530000 	cmp	r3, #0
  10c2ec:	1a00000c 	bne	10c324 <netconn_write_partly+0x1a8>
  10c2f0:	e59b3004 	ldr	r3, [fp, #4]
  10c2f4:	e3530000 	cmp	r3, #0
  10c2f8:	0a000009 	beq	10c324 <netconn_write_partly+0x1a8>
    if (dontblock) {
  10c2fc:	e55b3005 	ldrb	r3, [fp, #-5]
  10c300:	e3530000 	cmp	r3, #0
  10c304:	0a000003 	beq	10c318 <netconn_write_partly+0x19c>
      /* nonblocking write: maybe the data has been sent partly */
      *bytes_written = API_MSG_VAR_REF(msg).msg.w.len;
  10c308:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  10c30c:	e59b3004 	ldr	r3, [fp, #4]
  10c310:	e5832000 	str	r2, [r3]
  10c314:	ea000002 	b	10c324 <netconn_write_partly+0x1a8>
    } else {
      /* blocking call succeeded: all data has been sent if it */
      *bytes_written = size;
  10c318:	e59b3004 	ldr	r3, [fp, #4]
  10c31c:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  10c320:	e5832000 	str	r2, [r3]
    }
  }
  API_MSG_VAR_FREE(msg);

  return err;
  10c324:	e15b30d6 	ldrsb	r3, [fp, #-6]
}
  10c328:	e1a00003 	mov	r0, r3
  10c32c:	e24bd004 	sub	sp, fp, #4
  10c330:	e8bd8800 	pop	{fp, pc}

0010c334 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
  10c334:	e92d4800 	push	{fp, lr}
  10c338:	e28db004 	add	fp, sp, #4
  10c33c:	e24dd028 	sub	sp, sp, #40	; 0x28
  10c340:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10c344:	e1a03001 	mov	r3, r1
  10c348:	e54b3029 	strb	r3, [fp, #-41]	; 0xffffffd7
  API_MSG_VAR_DECLARE(msg);
  err_t err;
  LWIP_UNUSED_ARG(how);

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  10c34c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c350:	e3530000 	cmp	r3, #0
  10c354:	1a000008 	bne	10c37c <netconn_close_shutdown+0x48>
  10c358:	e3060830 	movw	r0, #26672	; 0x6830
  10c35c:	e3400014 	movt	r0, #20
  10c360:	ebffdb6b 	bl	103114 <rt_kprintf>
  10c364:	e3a01fca 	mov	r1, #808	; 0x328
  10c368:	e30605b8 	movw	r0, #26040	; 0x65b8
  10c36c:	e3400014 	movt	r0, #20
  10c370:	ebfffb41 	bl	10b07c <sys_arch_assert>
  10c374:	e3e0300f 	mvn	r3, #15
  10c378:	ea00000e 	b	10c3b8 <netconn_close_shutdown+0x84>

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
  10c37c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c380:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
#if LWIP_TCP
  /* shutting down both ends is the same as closing */
  API_MSG_VAR_REF(msg).msg.sd.shut = how;
  10c384:	e55b3029 	ldrb	r3, [fp, #-41]	; 0xffffffd7
  10c388:	e54b3018 	strb	r3, [fp, #-24]	; 0xffffffe8
#if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
  /* get the time we started, which is later compared to
     sys_now() + conn->send_timeout */
  API_MSG_VAR_REF(msg).msg.sd.time_started = sys_now();
  10c38c:	ebfffb53 	bl	10b0e0 <sys_now>
  10c390:	e1a03000 	mov	r3, r0
  10c394:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
  API_MSG_VAR_REF(msg).msg.sd.polls_left =
    ((LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT + TCP_SLOW_INTERVAL - 1) / TCP_SLOW_INTERVAL) + 1;
#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
#endif /* LWIP_TCP */
  err = netconn_apimsg(lwip_netconn_do_close, &API_MSG_VAR_REF(msg));
  10c398:	e24b3020 	sub	r3, fp, #32
  10c39c:	e1a01003 	mov	r1, r3
  10c3a0:	e30f0bf4 	movw	r0, #64500	; 0xfbf4
  10c3a4:	e3400010 	movt	r0, #16
  10c3a8:	ebfffc27 	bl	10b44c <netconn_apimsg>
  10c3ac:	e1a03000 	mov	r3, r0
  10c3b0:	e54b3005 	strb	r3, [fp, #-5]
  API_MSG_VAR_FREE(msg);

  return err;
  10c3b4:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  10c3b8:	e1a00003 	mov	r0, r3
  10c3bc:	e24bd004 	sub	sp, fp, #4
  10c3c0:	e8bd8800 	pop	{fp, pc}

0010c3c4 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  10c3c4:	e92d4800 	push	{fp, lr}
  10c3c8:	e28db004 	add	fp, sp, #4
  10c3cc:	e24dd008 	sub	sp, sp, #8
  10c3d0:	e50b0008 	str	r0, [fp, #-8]
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
  10c3d4:	e3a01003 	mov	r1, #3
  10c3d8:	e51b0008 	ldr	r0, [fp, #-8]
  10c3dc:	ebffffd4 	bl	10c334 <netconn_close_shutdown>
  10c3e0:	e1a03000 	mov	r3, r0
}
  10c3e4:	e1a00003 	mov	r0, r3
  10c3e8:	e24bd004 	sub	sp, fp, #4
  10c3ec:	e8bd8800 	pop	{fp, pc}

0010c3f0 <netconn_shutdown>:
 * @param shut_tx shut down the TX side (no more write possible after this)
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
{
  10c3f0:	e92d4800 	push	{fp, lr}
  10c3f4:	e28db004 	add	fp, sp, #4
  10c3f8:	e24dd008 	sub	sp, sp, #8
  10c3fc:	e50b0008 	str	r0, [fp, #-8]
  10c400:	e1a03001 	mov	r3, r1
  10c404:	e54b3009 	strb	r3, [fp, #-9]
  10c408:	e1a03002 	mov	r3, r2
  10c40c:	e54b300a 	strb	r3, [fp, #-10]
  return netconn_close_shutdown(conn, (shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0));
  10c410:	e55b3009 	ldrb	r3, [fp, #-9]
  10c414:	e3530000 	cmp	r3, #0
  10c418:	13a03001 	movne	r3, #1
  10c41c:	03a03000 	moveq	r3, #0
  10c420:	e6ef3073 	uxtb	r3, r3
  10c424:	e6af3073 	sxtb	r3, r3
  10c428:	e55b200a 	ldrb	r2, [fp, #-10]
  10c42c:	e3520000 	cmp	r2, #0
  10c430:	0a000001 	beq	10c43c <netconn_shutdown+0x4c>
  10c434:	e3a02002 	mov	r2, #2
  10c438:	ea000000 	b	10c440 <netconn_shutdown+0x50>
  10c43c:	e3a02000 	mov	r2, #0
  10c440:	e1823003 	orr	r3, r2, r3
  10c444:	e6af3073 	sxtb	r3, r3
  10c448:	e6ef3073 	uxtb	r3, r3
  10c44c:	e1a01003 	mov	r1, r3
  10c450:	e51b0008 	ldr	r0, [fp, #-8]
  10c454:	ebffffb6 	bl	10c334 <netconn_close_shutdown>
  10c458:	e1a03000 	mov	r3, r0
}
  10c45c:	e1a00003 	mov	r0, r3
  10c460:	e24bd004 	sub	sp, fp, #4
  10c464:	e8bd8800 	pop	{fp, pc}

0010c468 <netconn_join_leave_group>:
err_t
netconn_join_leave_group(struct netconn *conn,
                         const ip_addr_t *multiaddr,
                         const ip_addr_t *netif_addr,
                         enum netconn_igmp join_or_leave)
{
  10c468:	e92d4800 	push	{fp, lr}
  10c46c:	e28db004 	add	fp, sp, #4
  10c470:	e24dd030 	sub	sp, sp, #48	; 0x30
  10c474:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10c478:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  10c47c:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  10c480:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_join_leave_group: invalid conn",  (conn != NULL), return ERR_ARG;);
  10c484:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c488:	e3530000 	cmp	r3, #0
  10c48c:	1a000008 	bne	10c4b4 <netconn_join_leave_group+0x4c>
  10c490:	e306084c 	movw	r0, #26700	; 0x684c
  10c494:	e3400014 	movt	r0, #20
  10c498:	ebffdb1d 	bl	103114 <rt_kprintf>
  10c49c:	e3a01e37 	mov	r1, #880	; 0x370
  10c4a0:	e30605b8 	movw	r0, #26040	; 0x65b8
  10c4a4:	e3400014 	movt	r0, #20
  10c4a8:	ebfffaf3 	bl	10b07c <sys_arch_assert>
  10c4ac:	e3e0300f 	mvn	r3, #15
  10c4b0:	ea00001b 	b	10c524 <netconn_join_leave_group+0xbc>

  API_MSG_VAR_ALLOC(msg);

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
  if (multiaddr == NULL) {
  10c4b4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10c4b8:	e3530000 	cmp	r3, #0
  10c4bc:	1a000002 	bne	10c4cc <netconn_join_leave_group+0x64>
    multiaddr = IP4_ADDR_ANY;
  10c4c0:	e3093b24 	movw	r3, #39716	; 0x9b24
  10c4c4:	e3403014 	movt	r3, #20
  10c4c8:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
  }
  if (netif_addr == NULL) {
  10c4cc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  10c4d0:	e3530000 	cmp	r3, #0
  10c4d4:	1a000002 	bne	10c4e4 <netconn_join_leave_group+0x7c>
    netif_addr = IP4_ADDR_ANY;
  10c4d8:	e3093b24 	movw	r3, #39716	; 0x9b24
  10c4dc:	e3403014 	movt	r3, #20
  10c4e0:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
  }
#endif /* LWIP_IPV4 */

  API_MSG_VAR_REF(msg).conn = conn;
  10c4e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c4e8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  API_MSG_VAR_REF(msg).msg.jl.multiaddr = API_MSG_VAR_REF(multiaddr);
  10c4ec:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10c4f0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  API_MSG_VAR_REF(msg).msg.jl.netif_addr = API_MSG_VAR_REF(netif_addr);
  10c4f4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  10c4f8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  API_MSG_VAR_REF(msg).msg.jl.join_or_leave = join_or_leave;
  10c4fc:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  10c500:	e50b3010 	str	r3, [fp, #-16]
  err = netconn_apimsg(lwip_netconn_do_join_leave_group, &API_MSG_VAR_REF(msg));
  10c504:	e24b3020 	sub	r3, fp, #32
  10c508:	e1a01003 	mov	r1, r3
  10c50c:	e30f0e34 	movw	r0, #65076	; 0xfe34
  10c510:	e3400010 	movt	r0, #16
  10c514:	ebfffbcc 	bl	10b44c <netconn_apimsg>
  10c518:	e1a03000 	mov	r3, r0
  10c51c:	e54b3005 	strb	r3, [fp, #-5]
  API_MSG_VAR_FREE(msg);

  return err;
  10c520:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  10c524:	e1a00003 	mov	r0, r3
  10c528:	e24bd004 	sub	sp, fp, #4
  10c52c:	e8bd8800 	pop	{fp, pc}

0010c530 <netconn_gethostbyname>:
netconn_gethostbyname_addrtype(const char *name, ip_addr_t *addr, u8_t dns_addrtype)
#else
err_t
netconn_gethostbyname(const char *name, ip_addr_t *addr)
#endif
{
  10c530:	e92d4800 	push	{fp, lr}
  10c534:	e28db004 	add	fp, sp, #4
  10c538:	e24dd028 	sub	sp, sp, #40	; 0x28
  10c53c:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  10c540:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  sys_sem_t sem;
#endif /* LWIP_MPU_COMPATIBLE */
  err_t err;
  err_t cberr;

  LWIP_ERROR("netconn_gethostbyname: invalid name", (name != NULL), return ERR_ARG;);
  10c544:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c548:	e3530000 	cmp	r3, #0
  10c54c:	1a000008 	bne	10c574 <netconn_gethostbyname+0x44>
  10c550:	e3060874 	movw	r0, #26740	; 0x6874
  10c554:	e3400014 	movt	r0, #20
  10c558:	ebffdaed 	bl	103114 <rt_kprintf>
  10c55c:	e30013a5 	movw	r1, #933	; 0x3a5
  10c560:	e30605b8 	movw	r0, #26040	; 0x65b8
  10c564:	e3400014 	movt	r0, #20
  10c568:	ebfffac3 	bl	10b07c <sys_arch_assert>
  10c56c:	e3e0300f 	mvn	r3, #15
  10c570:	ea000036 	b	10c650 <netconn_gethostbyname+0x120>
  LWIP_ERROR("netconn_gethostbyname: invalid addr", (addr != NULL), return ERR_ARG;);
  10c574:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10c578:	e3530000 	cmp	r3, #0
  10c57c:	1a000008 	bne	10c5a4 <netconn_gethostbyname+0x74>
  10c580:	e3060898 	movw	r0, #26776	; 0x6898
  10c584:	e3400014 	movt	r0, #20
  10c588:	ebffdae1 	bl	103114 <rt_kprintf>
  10c58c:	e30013a6 	movw	r1, #934	; 0x3a6
  10c590:	e30605b8 	movw	r0, #26040	; 0x65b8
  10c594:	e3400014 	movt	r0, #20
  10c598:	ebfffab7 	bl	10b07c <sys_arch_assert>
  10c59c:	e3e0300f 	mvn	r3, #15
  10c5a0:	ea00002a 	b	10c650 <netconn_gethostbyname+0x120>
  API_VAR_ALLOC(struct dns_api_msg, MEMP_DNS_API_MSG, msg, ERR_MEM);
#if LWIP_MPU_COMPATIBLE
  strncpy(API_VAR_REF(msg).name, name, DNS_MAX_NAME_LENGTH-1);
  API_VAR_REF(msg).name[DNS_MAX_NAME_LENGTH-1] = 0;
#else /* LWIP_MPU_COMPATIBLE */
  msg.err = &err;
  10c5a4:	e24b301d 	sub	r3, fp, #29
  10c5a8:	e50b300c 	str	r3, [fp, #-12]
  msg.sem = &sem;
  10c5ac:	e24b301c 	sub	r3, fp, #28
  10c5b0:	e50b3010 	str	r3, [fp, #-16]
  API_VAR_REF(msg).addr = API_VAR_REF(addr);
  10c5b4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  10c5b8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  API_VAR_REF(msg).name = name;
  10c5bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c5c0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  API_VAR_REF(msg).dns_addrtype = dns_addrtype;
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_NETCONN_SEM_PER_THREAD
  API_VAR_REF(msg).sem = LWIP_NETCONN_THREAD_SEM_GET();
#else /* LWIP_NETCONN_SEM_PER_THREAD*/
  err = sys_sem_new(API_EXPR_REF(API_VAR_REF(msg).sem), 0);
  10c5c4:	e51b3010 	ldr	r3, [fp, #-16]
  10c5c8:	e3a01000 	mov	r1, #0
  10c5cc:	e1a00003 	mov	r0, r3
  10c5d0:	ebfff817 	bl	10a634 <sys_sem_new>
  10c5d4:	e1a03000 	mov	r3, r0
  10c5d8:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
  if (err != ERR_OK) {
  10c5dc:	e15b31dd 	ldrsb	r3, [fp, #-29]	; 0xffffffe3
  10c5e0:	e3530000 	cmp	r3, #0
  10c5e4:	0a000001 	beq	10c5f0 <netconn_gethostbyname+0xc0>
    API_VAR_FREE(MEMP_DNS_API_MSG, msg);
    return err;
  10c5e8:	e15b31dd 	ldrsb	r3, [fp, #-29]	; 0xffffffe3
  10c5ec:	ea000017 	b	10c650 <netconn_gethostbyname+0x120>
  }
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

  cberr = tcpip_callback(lwip_netconn_do_gethostbyname, &API_VAR_REF(msg));
  10c5f0:	e24b3018 	sub	r3, fp, #24
  10c5f4:	e3a02001 	mov	r2, #1
  10c5f8:	e1a01003 	mov	r1, r3
  10c5fc:	e30f0ffc 	movw	r0, #65532	; 0xfffc
  10c600:	e3400010 	movt	r0, #16
  10c604:	eb002772 	bl	1163d4 <tcpip_callback_with_block>
  10c608:	e1a03000 	mov	r3, r0
  10c60c:	e54b3005 	strb	r3, [fp, #-5]
  if (cberr != ERR_OK) {
  10c610:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10c614:	e3530000 	cmp	r3, #0
  10c618:	0a000004 	beq	10c630 <netconn_gethostbyname+0x100>
#if !LWIP_NETCONN_SEM_PER_THREAD
    sys_sem_free(API_EXPR_REF(API_VAR_REF(msg).sem));
  10c61c:	e51b3010 	ldr	r3, [fp, #-16]
  10c620:	e1a00003 	mov	r0, r3
  10c624:	ebfff82d 	bl	10a6e0 <sys_sem_free>
#endif /* !LWIP_NETCONN_SEM_PER_THREAD */
    API_VAR_FREE(MEMP_DNS_API_MSG, msg);
    return cberr;
  10c628:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10c62c:	ea000007 	b	10c650 <netconn_gethostbyname+0x120>
  }
  sys_sem_wait(API_EXPR_REF_SEM(API_VAR_REF(msg).sem));
  10c630:	e51b3010 	ldr	r3, [fp, #-16]
  10c634:	e3a01000 	mov	r1, #0
  10c638:	e1a00003 	mov	r0, r3
  10c63c:	ebfff83d 	bl	10a738 <sys_arch_sem_wait>
#if !LWIP_NETCONN_SEM_PER_THREAD
  sys_sem_free(API_EXPR_REF(API_VAR_REF(msg).sem));
  10c640:	e51b3010 	ldr	r3, [fp, #-16]
  10c644:	e1a00003 	mov	r0, r3
  10c648:	ebfff824 	bl	10a6e0 <sys_sem_free>
  *addr = msg->addr;
  err = msg->err;
#endif /* LWIP_MPU_COMPATIBLE */

  API_VAR_FREE(MEMP_DNS_API_MSG, msg);
  return err;
  10c64c:	e15b31dd 	ldrsb	r3, [fp, #-29]	; 0xffffffe3
}
  10c650:	e1a00003 	mov	r0, r3
  10c654:	e24bd004 	sub	sp, fp, #4
  10c658:	e8bd8800 	pop	{fp, pc}

0010c65c <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    const ip_addr_t *addr)
{
  10c65c:	e92d4800 	push	{fp, lr}
  10c660:	e28db004 	add	fp, sp, #4
  10c664:	e24dd028 	sub	sp, sp, #40	; 0x28
  10c668:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  10c66c:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  10c670:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  10c674:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
  struct pbuf *q;
  struct netbuf *buf;
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;
  10c678:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10c67c:	e50b300c 	str	r3, [fp, #-12]

  if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
  10c680:	e51b300c 	ldr	r3, [fp, #-12]
  10c684:	e3530000 	cmp	r3, #0
  10c688:	0a00006b 	beq	10c83c <recv_raw+0x1e0>
  10c68c:	e51b300c 	ldr	r3, [fp, #-12]
  10c690:	e2833014 	add	r3, r3, #20
  10c694:	e1a00003 	mov	r0, r3
  10c698:	ebfffa2e 	bl	10af58 <sys_mbox_valid>
  10c69c:	e1a03000 	mov	r3, r0
  10c6a0:	e3530000 	cmp	r3, #0
  10c6a4:	0a000064 	beq	10c83c <recv_raw+0x1e0>
#if LWIP_SO_RCVBUF
    int recv_avail;
    SYS_ARCH_GET(conn->recv_avail, recv_avail);
  10c6a8:	ebffd6e3 	bl	10223c <rt_enter_critical>
  10c6ac:	e51b300c 	ldr	r3, [fp, #-12]
  10c6b0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  10c6b4:	e50b3010 	str	r3, [fp, #-16]
  10c6b8:	ebffd6e5 	bl	102254 <rt_exit_critical>
    if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
  10c6bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c6c0:	e1d330b8 	ldrh	r3, [r3, #8]
  10c6c4:	e1a02003 	mov	r2, r3
  10c6c8:	e51b3010 	ldr	r3, [fp, #-16]
  10c6cc:	e0822003 	add	r2, r2, r3
  10c6d0:	e51b300c 	ldr	r3, [fp, #-12]
  10c6d4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  10c6d8:	e1520003 	cmp	r2, r3
  10c6dc:	da000001 	ble	10c6e8 <recv_raw+0x8c>
      return 0;
  10c6e0:	e3a03000 	mov	r3, #0
  10c6e4:	ea000055 	b	10c840 <recv_raw+0x1e4>
    }
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  10c6e8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  10c6ec:	e1d330b8 	ldrh	r3, [r3, #8]
  10c6f0:	e3a02000 	mov	r2, #0
  10c6f4:	e1a01003 	mov	r1, r3
  10c6f8:	e3a00004 	mov	r0, #4
  10c6fc:	eb003765 	bl	11a498 <pbuf_alloc>
  10c700:	e50b0008 	str	r0, [fp, #-8]
    if (q != NULL) {
  10c704:	e51b3008 	ldr	r3, [fp, #-8]
  10c708:	e3530000 	cmp	r3, #0
  10c70c:	0a000009 	beq	10c738 <recv_raw+0xdc>
      if (pbuf_copy(q, p) != ERR_OK) {
  10c710:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
  10c714:	e51b0008 	ldr	r0, [fp, #-8]
  10c718:	eb003bba 	bl	11b608 <pbuf_copy>
  10c71c:	e1a03000 	mov	r3, r0
  10c720:	e3530000 	cmp	r3, #0
  10c724:	0a000003 	beq	10c738 <recv_raw+0xdc>
        pbuf_free(q);
  10c728:	e51b0008 	ldr	r0, [fp, #-8]
  10c72c:	eb003a60 	bl	11b0b4 <pbuf_free>
        q = NULL;
  10c730:	e3a03000 	mov	r3, #0
  10c734:	e50b3008 	str	r3, [fp, #-8]
      }
    }

    if (q != NULL) {
  10c738:	e51b3008 	ldr	r3, [fp, #-8]
  10c73c:	e3530000 	cmp	r3, #0
  10c740:	0a00003d 	beq	10c83c <recv_raw+0x1e0>
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
  10c744:	e3a02081 	mov	r2, #129	; 0x81
  10c748:	e30618bc 	movw	r1, #26812	; 0x68bc
  10c74c:	e3401014 	movt	r1, #20
  10c750:	e3a00007 	mov	r0, #7
  10c754:	eb0032e0 	bl	1192dc <memp_malloc_fn>
  10c758:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
      if (buf == NULL) {
  10c75c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10c760:	e3530000 	cmp	r3, #0
  10c764:	1a000003 	bne	10c778 <recv_raw+0x11c>
        pbuf_free(q);
  10c768:	e51b0008 	ldr	r0, [fp, #-8]
  10c76c:	eb003a50 	bl	11b0b4 <pbuf_free>
        return 0;
  10c770:	e3a03000 	mov	r3, #0
  10c774:	ea000031 	b	10c840 <recv_raw+0x1e4>
      }

      buf->p = q;
  10c778:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10c77c:	e51b2008 	ldr	r2, [fp, #-8]
  10c780:	e5832000 	str	r2, [r3]
      buf->ptr = q;
  10c784:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10c788:	e51b2008 	ldr	r2, [fp, #-8]
  10c78c:	e5832004 	str	r2, [r3, #4]
      ip_addr_copy(buf->addr, *ip_current_src_addr());
  10c790:	e30035e8 	movw	r3, #1512	; 0x5e8
  10c794:	e3403015 	movt	r3, #21
  10c798:	e5932010 	ldr	r2, [r3, #16]
  10c79c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10c7a0:	e5832008 	str	r2, [r3, #8]
      buf->port = pcb->protocol;
  10c7a4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  10c7a8:	e5d33010 	ldrb	r3, [r3, #16]
  10c7ac:	e6ff2073 	uxth	r2, r3
  10c7b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10c7b4:	e1c320bc 	strh	r2, [r3, #12]

      len = q->tot_len;
  10c7b8:	e51b3008 	ldr	r3, [fp, #-8]
  10c7bc:	e1d330b8 	ldrh	r3, [r3, #8]
  10c7c0:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
  10c7c4:	e51b300c 	ldr	r3, [fp, #-12]
  10c7c8:	e2833014 	add	r3, r3, #20
  10c7cc:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  10c7d0:	e1a00003 	mov	r0, r3
  10c7d4:	ebfff981 	bl	10ade0 <sys_mbox_trypost>
  10c7d8:	e1a03000 	mov	r3, r0
  10c7dc:	e3530000 	cmp	r3, #0
  10c7e0:	0a000003 	beq	10c7f4 <recv_raw+0x198>
        netbuf_delete(buf);
  10c7e4:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  10c7e8:	eb000e50 	bl	110130 <netbuf_delete>
        return 0;
  10c7ec:	e3a03000 	mov	r3, #0
  10c7f0:	ea000012 	b	10c840 <recv_raw+0x1e4>
      } else {
#if LWIP_SO_RCVBUF
        SYS_ARCH_INC(conn->recv_avail, len);
  10c7f4:	ebffd690 	bl	10223c <rt_enter_critical>
  10c7f8:	e51b300c 	ldr	r3, [fp, #-12]
  10c7fc:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
  10c800:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  10c804:	e0822003 	add	r2, r2, r3
  10c808:	e51b300c 	ldr	r3, [fp, #-12]
  10c80c:	e583202c 	str	r2, [r3, #44]	; 0x2c
  10c810:	ebffd68f 	bl	102254 <rt_exit_critical>
#endif /* LWIP_SO_RCVBUF */
        /* Register event with callback */
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  10c814:	e51b300c 	ldr	r3, [fp, #-12]
  10c818:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10c81c:	e3530000 	cmp	r3, #0
  10c820:	0a000005 	beq	10c83c <recv_raw+0x1e0>
  10c824:	e51b300c 	ldr	r3, [fp, #-12]
  10c828:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10c82c:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  10c830:	e3a01000 	mov	r1, #0
  10c834:	e51b000c 	ldr	r0, [fp, #-12]
  10c838:	e12fff33 	blx	r3
      }
    }
  }

  return 0; /* do not eat the packet */
  10c83c:	e3a03000 	mov	r3, #0
}
  10c840:	e1a00003 	mov	r0, r3
  10c844:	e24bd004 	sub	sp, fp, #4
  10c848:	e8bd8800 	pop	{fp, pc}

0010c84c <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   const ip_addr_t *addr, u16_t port)
{
  10c84c:	e92d4800 	push	{fp, lr}
  10c850:	e28db004 	add	fp, sp, #4
  10c854:	e24dd020 	sub	sp, sp, #32
  10c858:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10c85c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  10c860:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  10c864:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  10c868:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10c86c:	e3530000 	cmp	r3, #0
  10c870:	1a000006 	bne	10c890 <recv_udp+0x44>
  10c874:	e30608ec 	movw	r0, #26860	; 0x68ec
  10c878:	e3400014 	movt	r0, #20
  10c87c:	ebffda24 	bl	103114 <rt_kprintf>
  10c880:	e3a010b1 	mov	r1, #177	; 0xb1
  10c884:	e30608bc 	movw	r0, #26812	; 0x68bc
  10c888:	e3400014 	movt	r0, #20
  10c88c:	ebfff9fa 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  10c890:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10c894:	e3530000 	cmp	r3, #0
  10c898:	1a000006 	bne	10c8b8 <recv_udp+0x6c>
  10c89c:	e3060910 	movw	r0, #26896	; 0x6910
  10c8a0:	e3400014 	movt	r0, #20
  10c8a4:	ebffda1a 	bl	103114 <rt_kprintf>
  10c8a8:	e3a010b2 	mov	r1, #178	; 0xb2
  10c8ac:	e30608bc 	movw	r0, #26812	; 0x68bc
  10c8b0:	e3400014 	movt	r0, #20
  10c8b4:	ebfff9f0 	bl	10b07c <sys_arch_assert>
  conn = (struct netconn *)arg;
  10c8b8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10c8bc:	e50b3008 	str	r3, [fp, #-8]
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  10c8c0:	e51b3008 	ldr	r3, [fp, #-8]
  10c8c4:	e5933008 	ldr	r3, [r3, #8]
  10c8c8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  10c8cc:	e1520003 	cmp	r2, r3
  10c8d0:	0a000006 	beq	10c8f0 <recv_udp+0xa4>
  10c8d4:	e3060930 	movw	r0, #26928	; 0x6930
  10c8d8:	e3400014 	movt	r0, #20
  10c8dc:	ebffda0c 	bl	103114 <rt_kprintf>
  10c8e0:	e3a010b4 	mov	r1, #180	; 0xb4
  10c8e4:	e30608bc 	movw	r0, #26812	; 0x68bc
  10c8e8:	e3400014 	movt	r0, #20
  10c8ec:	ebfff9e2 	bl	10b07c <sys_arch_assert>

#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  10c8f0:	ebffd651 	bl	10223c <rt_enter_critical>
  10c8f4:	e51b3008 	ldr	r3, [fp, #-8]
  10c8f8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  10c8fc:	e50b300c 	str	r3, [fp, #-12]
  10c900:	ebffd653 	bl	102254 <rt_exit_critical>
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
  10c904:	e51b3008 	ldr	r3, [fp, #-8]
  10c908:	e3530000 	cmp	r3, #0
  10c90c:	0a00000f 	beq	10c950 <recv_udp+0x104>
  10c910:	e51b3008 	ldr	r3, [fp, #-8]
  10c914:	e2833014 	add	r3, r3, #20
  10c918:	e1a00003 	mov	r0, r3
  10c91c:	ebfff98d 	bl	10af58 <sys_mbox_valid>
  10c920:	e1a03000 	mov	r3, r0
  10c924:	e3530000 	cmp	r3, #0
  10c928:	0a000008 	beq	10c950 <recv_udp+0x104>
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
  10c92c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10c930:	e1d330b8 	ldrh	r3, [r3, #8]
  10c934:	e1a02003 	mov	r2, r3
  10c938:	e51b300c 	ldr	r3, [fp, #-12]
  10c93c:	e0822003 	add	r2, r2, r3
  10c940:	e51b3008 	ldr	r3, [fp, #-8]
  10c944:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
  10c948:	e1520003 	cmp	r2, r3
  10c94c:	da000002 	ble	10c95c <recv_udp+0x110>
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  10c950:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10c954:	eb0039d6 	bl	11b0b4 <pbuf_free>
    return;
  10c958:	ea00003d 	b	10ca54 <recv_udp+0x208>
  }

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
  10c95c:	e3a020c1 	mov	r2, #193	; 0xc1
  10c960:	e30618bc 	movw	r1, #26812	; 0x68bc
  10c964:	e3401014 	movt	r1, #20
  10c968:	e3a00007 	mov	r0, #7
  10c96c:	eb00325a 	bl	1192dc <memp_malloc_fn>
  10c970:	e50b0010 	str	r0, [fp, #-16]
  if (buf == NULL) {
  10c974:	e51b3010 	ldr	r3, [fp, #-16]
  10c978:	e3530000 	cmp	r3, #0
  10c97c:	1a000002 	bne	10c98c <recv_udp+0x140>
    pbuf_free(p);
  10c980:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10c984:	eb0039ca 	bl	11b0b4 <pbuf_free>
    return;
  10c988:	ea000031 	b	10ca54 <recv_udp+0x208>
  } else {
    buf->p = p;
  10c98c:	e51b3010 	ldr	r3, [fp, #-16]
  10c990:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  10c994:	e5832000 	str	r2, [r3]
    buf->ptr = p;
  10c998:	e51b3010 	ldr	r3, [fp, #-16]
  10c99c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  10c9a0:	e5832004 	str	r2, [r3, #4]
    ip_addr_set(&buf->addr, addr);
  10c9a4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  10c9a8:	e3530000 	cmp	r3, #0
  10c9ac:	0a000002 	beq	10c9bc <recv_udp+0x170>
  10c9b0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  10c9b4:	e5933000 	ldr	r3, [r3]
  10c9b8:	ea000000 	b	10c9c0 <recv_udp+0x174>
  10c9bc:	e3a03000 	mov	r3, #0
  10c9c0:	e51b2010 	ldr	r2, [fp, #-16]
  10c9c4:	e5823008 	str	r3, [r2, #8]
    buf->port = port;
  10c9c8:	e51b3010 	ldr	r3, [fp, #-16]
  10c9cc:	e1db20b4 	ldrh	r2, [fp, #4]
  10c9d0:	e1c320bc 	strh	r2, [r3, #12]
      buf->toport_chksum = udphdr->dest;
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
  10c9d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10c9d8:	e1d330b8 	ldrh	r3, [r3, #8]
  10c9dc:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
  10c9e0:	e51b3008 	ldr	r3, [fp, #-8]
  10c9e4:	e2833014 	add	r3, r3, #20
  10c9e8:	e51b1010 	ldr	r1, [fp, #-16]
  10c9ec:	e1a00003 	mov	r0, r3
  10c9f0:	ebfff8fa 	bl	10ade0 <sys_mbox_trypost>
  10c9f4:	e1a03000 	mov	r3, r0
  10c9f8:	e3530000 	cmp	r3, #0
  10c9fc:	0a000002 	beq	10ca0c <recv_udp+0x1c0>
    netbuf_delete(buf);
  10ca00:	e51b0010 	ldr	r0, [fp, #-16]
  10ca04:	eb000dc9 	bl	110130 <netbuf_delete>
    return;
  10ca08:	ea000011 	b	10ca54 <recv_udp+0x208>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
  10ca0c:	ebffd60a 	bl	10223c <rt_enter_critical>
  10ca10:	e51b3008 	ldr	r3, [fp, #-8]
  10ca14:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
  10ca18:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  10ca1c:	e0822003 	add	r2, r2, r3
  10ca20:	e51b3008 	ldr	r3, [fp, #-8]
  10ca24:	e583202c 	str	r2, [r3, #44]	; 0x2c
  10ca28:	ebffd609 	bl	102254 <rt_exit_critical>
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  10ca2c:	e51b3008 	ldr	r3, [fp, #-8]
  10ca30:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10ca34:	e3530000 	cmp	r3, #0
  10ca38:	0a000005 	beq	10ca54 <recv_udp+0x208>
  10ca3c:	e51b3008 	ldr	r3, [fp, #-8]
  10ca40:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10ca44:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
  10ca48:	e3a01000 	mov	r1, #0
  10ca4c:	e51b0008 	ldr	r0, [fp, #-8]
  10ca50:	e12fff33 	blx	r3
  }
}
  10ca54:	e24bd004 	sub	sp, fp, #4
  10ca58:	e8bd8800 	pop	{fp, pc}

0010ca5c <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  10ca5c:	e92d4800 	push	{fp, lr}
  10ca60:	e28db004 	add	fp, sp, #4
  10ca64:	e24dd018 	sub	sp, sp, #24
  10ca68:	e50b0010 	str	r0, [fp, #-16]
  10ca6c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10ca70:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  10ca74:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  10ca78:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10ca7c:	e3530000 	cmp	r3, #0
  10ca80:	1a000006 	bne	10caa0 <recv_tcp+0x44>
  10ca84:	e3060950 	movw	r0, #26960	; 0x6950
  10ca88:	e3400014 	movt	r0, #20
  10ca8c:	ebffd9a0 	bl	103114 <rt_kprintf>
  10ca90:	e3a010f3 	mov	r1, #243	; 0xf3
  10ca94:	e30608bc 	movw	r0, #26812	; 0x68bc
  10ca98:	e3400014 	movt	r0, #20
  10ca9c:	ebfff976 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  10caa0:	e51b3010 	ldr	r3, [fp, #-16]
  10caa4:	e3530000 	cmp	r3, #0
  10caa8:	1a000006 	bne	10cac8 <recv_tcp+0x6c>
  10caac:	e3060974 	movw	r0, #26996	; 0x6974
  10cab0:	e3400014 	movt	r0, #20
  10cab4:	ebffd996 	bl	103114 <rt_kprintf>
  10cab8:	e3a010f4 	mov	r1, #244	; 0xf4
  10cabc:	e30608bc 	movw	r0, #26812	; 0x68bc
  10cac0:	e3400014 	movt	r0, #20
  10cac4:	ebfff96c 	bl	10b07c <sys_arch_assert>
  conn = (struct netconn *)arg;
  10cac8:	e51b3010 	ldr	r3, [fp, #-16]
  10cacc:	e50b300c 	str	r3, [fp, #-12]

  if (conn == NULL) {
  10cad0:	e51b300c 	ldr	r3, [fp, #-12]
  10cad4:	e3530000 	cmp	r3, #0
  10cad8:	1a000001 	bne	10cae4 <recv_tcp+0x88>
    return ERR_VAL;
  10cadc:	e3e03005 	mvn	r3, #5
  10cae0:	ea000053 	b	10cc34 <recv_tcp+0x1d8>
  }
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  10cae4:	e51b300c 	ldr	r3, [fp, #-12]
  10cae8:	e5933008 	ldr	r3, [r3, #8]
  10caec:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  10caf0:	e1520003 	cmp	r2, r3
  10caf4:	0a000006 	beq	10cb14 <recv_tcp+0xb8>
  10caf8:	e3060994 	movw	r0, #27028	; 0x6994
  10cafc:	e3400014 	movt	r0, #20
  10cb00:	ebffd983 	bl	103114 <rt_kprintf>
  10cb04:	e3a010fa 	mov	r1, #250	; 0xfa
  10cb08:	e30608bc 	movw	r0, #26812	; 0x68bc
  10cb0c:	e3400014 	movt	r0, #20
  10cb10:	ebfff959 	bl	10b07c <sys_arch_assert>

  if (!sys_mbox_valid(&conn->recvmbox)) {
  10cb14:	e51b300c 	ldr	r3, [fp, #-12]
  10cb18:	e2833014 	add	r3, r3, #20
  10cb1c:	e1a00003 	mov	r0, r3
  10cb20:	ebfff90c 	bl	10af58 <sys_mbox_valid>
  10cb24:	e1a03000 	mov	r3, r0
  10cb28:	e3530000 	cmp	r3, #0
  10cb2c:	1a00000b 	bne	10cb60 <recv_tcp+0x104>
    /* recvmbox already deleted */
    if (p != NULL) {
  10cb30:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10cb34:	e3530000 	cmp	r3, #0
  10cb38:	0a000006 	beq	10cb58 <recv_tcp+0xfc>
      tcp_recved(pcb, p->tot_len);
  10cb3c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10cb40:	e1d330b8 	ldrh	r3, [r3, #8]
  10cb44:	e1a01003 	mov	r1, r3
  10cb48:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  10cb4c:	eb0045e4 	bl	11e2e4 <tcp_recved>
      pbuf_free(p);
  10cb50:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  10cb54:	eb003956 	bl	11b0b4 <pbuf_free>
    }
    return ERR_OK;
  10cb58:	e3a03000 	mov	r3, #0
  10cb5c:	ea000034 	b	10cc34 <recv_tcp+0x1d8>
  /* Unlike for UDP or RAW pcbs, don't check for available space
     using recv_avail since that could break the connection
     (data is already ACKed) */

  /* don't overwrite fatal errors! */
  if (err != ERR_OK) {
  10cb60:	e15b31d9 	ldrsb	r3, [fp, #-25]	; 0xffffffe7
  10cb64:	e3530000 	cmp	r3, #0
  10cb68:	0a00000b 	beq	10cb9c <recv_tcp+0x140>
    NETCONN_SET_SAFE_ERR(conn, err);
  10cb6c:	e51b300c 	ldr	r3, [fp, #-12]
  10cb70:	e3530000 	cmp	r3, #0
  10cb74:	0a000008 	beq	10cb9c <recv_tcp+0x140>
  10cb78:	ebffd5af 	bl	10223c <rt_enter_critical>
  10cb7c:	e51b300c 	ldr	r3, [fp, #-12]
  10cb80:	e1d330dc 	ldrsb	r3, [r3, #12]
  10cb84:	e373000c 	cmn	r3, #12
  10cb88:	ba000002 	blt	10cb98 <recv_tcp+0x13c>
  10cb8c:	e51b300c 	ldr	r3, [fp, #-12]
  10cb90:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
  10cb94:	e5c3200c 	strb	r2, [r3, #12]
  10cb98:	ebffd5ad 	bl	102254 <rt_exit_critical>
  }

  if (p != NULL) {
  10cb9c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10cba0:	e3530000 	cmp	r3, #0
  10cba4:	0a000003 	beq	10cbb8 <recv_tcp+0x15c>
    len = p->tot_len;
  10cba8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10cbac:	e1d330b8 	ldrh	r3, [r3, #8]
  10cbb0:	e14b30b6 	strh	r3, [fp, #-6]
  10cbb4:	ea000001 	b	10cbc0 <recv_tcp+0x164>
  } else {
    len = 0;
  10cbb8:	e3a03000 	mov	r3, #0
  10cbbc:	e14b30b6 	strh	r3, [fp, #-6]
  }

  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
  10cbc0:	e51b300c 	ldr	r3, [fp, #-12]
  10cbc4:	e2833014 	add	r3, r3, #20
  10cbc8:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  10cbcc:	e1a00003 	mov	r0, r3
  10cbd0:	ebfff882 	bl	10ade0 <sys_mbox_trypost>
  10cbd4:	e1a03000 	mov	r3, r0
  10cbd8:	e3530000 	cmp	r3, #0
  10cbdc:	0a000001 	beq	10cbe8 <recv_tcp+0x18c>
    /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
    return ERR_MEM;
  10cbe0:	e3e03000 	mvn	r3, #0
  10cbe4:	ea000012 	b	10cc34 <recv_tcp+0x1d8>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
  10cbe8:	ebffd593 	bl	10223c <rt_enter_critical>
  10cbec:	e51b300c 	ldr	r3, [fp, #-12]
  10cbf0:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
  10cbf4:	e15b30b6 	ldrh	r3, [fp, #-6]
  10cbf8:	e0822003 	add	r2, r2, r3
  10cbfc:	e51b300c 	ldr	r3, [fp, #-12]
  10cc00:	e583202c 	str	r2, [r3, #44]	; 0x2c
  10cc04:	ebffd592 	bl	102254 <rt_exit_critical>
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  10cc08:	e51b300c 	ldr	r3, [fp, #-12]
  10cc0c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cc10:	e3530000 	cmp	r3, #0
  10cc14:	0a000005 	beq	10cc30 <recv_tcp+0x1d4>
  10cc18:	e51b300c 	ldr	r3, [fp, #-12]
  10cc1c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cc20:	e15b20b6 	ldrh	r2, [fp, #-6]
  10cc24:	e3a01000 	mov	r1, #0
  10cc28:	e51b000c 	ldr	r0, [fp, #-12]
  10cc2c:	e12fff33 	blx	r3
  }

  return ERR_OK;
  10cc30:	e3a03000 	mov	r3, #0
}
  10cc34:	e1a00003 	mov	r0, r3
  10cc38:	e24bd004 	sub	sp, fp, #4
  10cc3c:	e8bd8800 	pop	{fp, pc}

0010cc40 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  10cc40:	e92d4800 	push	{fp, lr}
  10cc44:	e28db004 	add	fp, sp, #4
  10cc48:	e24dd010 	sub	sp, sp, #16
  10cc4c:	e50b0010 	str	r0, [fp, #-16]
  10cc50:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct netconn *conn = (struct netconn *)arg;
  10cc54:	e51b3010 	ldr	r3, [fp, #-16]
  10cc58:	e50b3008 	str	r3, [fp, #-8]

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  10cc5c:	e51b3008 	ldr	r3, [fp, #-8]
  10cc60:	e3530000 	cmp	r3, #0
  10cc64:	1a000006 	bne	10cc84 <poll_tcp+0x44>
  10cc68:	e30609b4 	movw	r0, #27060	; 0x69b4
  10cc6c:	e3400014 	movt	r0, #20
  10cc70:	ebffd927 	bl	103114 <rt_kprintf>
  10cc74:	e3001132 	movw	r1, #306	; 0x132
  10cc78:	e30608bc 	movw	r0, #26812	; 0x68bc
  10cc7c:	e3400014 	movt	r0, #20
  10cc80:	ebfff8fd 	bl	10b07c <sys_arch_assert>

  if (conn->state == NETCONN_WRITE) {
  10cc84:	e51b3008 	ldr	r3, [fp, #-8]
  10cc88:	e5933004 	ldr	r3, [r3, #4]
  10cc8c:	e3530001 	cmp	r3, #1
  10cc90:	1a000003 	bne	10cca4 <poll_tcp+0x64>
    lwip_netconn_do_writemore(conn  WRITE_DELAYED);
  10cc94:	e3a01001 	mov	r1, #1
  10cc98:	e51b0008 	ldr	r0, [fp, #-8]
  10cc9c:	eb000924 	bl	10f134 <lwip_netconn_do_writemore>
  10cca0:	ea000006 	b	10ccc0 <poll_tcp+0x80>
  } else if (conn->state == NETCONN_CLOSE) {
  10cca4:	e51b3008 	ldr	r3, [fp, #-8]
  10cca8:	e5933004 	ldr	r3, [r3, #4]
  10ccac:	e3530004 	cmp	r3, #4
  10ccb0:	1a000002 	bne	10ccc0 <poll_tcp+0x80>
#if !LWIP_SO_SNDTIMEO && !LWIP_SO_LINGER
    if (conn->current_msg && conn->current_msg->msg.sd.polls_left) {
      conn->current_msg->msg.sd.polls_left--;
    }
#endif /* !LWIP_SO_SNDTIMEO && !LWIP_SO_LINGER */
    lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
  10ccb4:	e3a01001 	mov	r1, #1
  10ccb8:	e51b0008 	ldr	r0, [fp, #-8]
  10ccbc:	eb000394 	bl	10db14 <lwip_netconn_do_close_internal>
  }
  /* @todo: implement connect timeout here? */

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
  10ccc0:	e51b3008 	ldr	r3, [fp, #-8]
  10ccc4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10ccc8:	e2033010 	and	r3, r3, #16
  10cccc:	e3530000 	cmp	r3, #0
  10ccd0:	0a00001d 	beq	10cd4c <poll_tcp+0x10c>
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
  10ccd4:	e51b3008 	ldr	r3, [fp, #-8]
  10ccd8:	e5933008 	ldr	r3, [r3, #8]
  10ccdc:	e3530000 	cmp	r3, #0
  10cce0:	0a000019 	beq	10cd4c <poll_tcp+0x10c>
  10cce4:	e51b3008 	ldr	r3, [fp, #-8]
  10cce8:	e5933008 	ldr	r3, [r3, #8]
  10ccec:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
  10ccf0:	e3530a01 	cmp	r3, #4096	; 0x1000
  10ccf4:	9a000014 	bls	10cd4c <poll_tcp+0x10c>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
  10ccf8:	e51b3008 	ldr	r3, [fp, #-8]
  10ccfc:	e5933008 	ldr	r3, [r3, #8]
  10cd00:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
  10cd04:	e353000a 	cmp	r3, #10
  10cd08:	8a00000f 	bhi	10cd4c <poll_tcp+0x10c>
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
  10cd0c:	e51b3008 	ldr	r3, [fp, #-8]
  10cd10:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10cd14:	e3c33010 	bic	r3, r3, #16
  10cd18:	e6ef2073 	uxtb	r2, r3
  10cd1c:	e51b3008 	ldr	r3, [fp, #-8]
  10cd20:	e5c32030 	strb	r2, [r3, #48]	; 0x30
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  10cd24:	e51b3008 	ldr	r3, [fp, #-8]
  10cd28:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cd2c:	e3530000 	cmp	r3, #0
  10cd30:	0a000005 	beq	10cd4c <poll_tcp+0x10c>
  10cd34:	e51b3008 	ldr	r3, [fp, #-8]
  10cd38:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cd3c:	e3a02000 	mov	r2, #0
  10cd40:	e3a01002 	mov	r1, #2
  10cd44:	e51b0008 	ldr	r0, [fp, #-8]
  10cd48:	e12fff33 	blx	r3
    }
  }

  return ERR_OK;
  10cd4c:	e3a03000 	mov	r3, #0
}
  10cd50:	e1a00003 	mov	r0, r3
  10cd54:	e24bd004 	sub	sp, fp, #4
  10cd58:	e8bd8800 	pop	{fp, pc}

0010cd5c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  10cd5c:	e92d4800 	push	{fp, lr}
  10cd60:	e28db004 	add	fp, sp, #4
  10cd64:	e24dd018 	sub	sp, sp, #24
  10cd68:	e50b0010 	str	r0, [fp, #-16]
  10cd6c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10cd70:	e1a03002 	mov	r3, r2
  10cd74:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  struct netconn *conn = (struct netconn *)arg;
  10cd78:	e51b3010 	ldr	r3, [fp, #-16]
  10cd7c:	e50b3008 	str	r3, [fp, #-8]

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  10cd80:	e51b3008 	ldr	r3, [fp, #-8]
  10cd84:	e3530000 	cmp	r3, #0
  10cd88:	1a000006 	bne	10cda8 <sent_tcp+0x4c>
  10cd8c:	e30609b4 	movw	r0, #27060	; 0x69b4
  10cd90:	e3400014 	movt	r0, #20
  10cd94:	ebffd8de 	bl	103114 <rt_kprintf>
  10cd98:	e300115b 	movw	r1, #347	; 0x15b
  10cd9c:	e30608bc 	movw	r0, #26812	; 0x68bc
  10cda0:	e3400014 	movt	r0, #20
  10cda4:	ebfff8b4 	bl	10b07c <sys_arch_assert>

  if (conn) {
  10cda8:	e51b3008 	ldr	r3, [fp, #-8]
  10cdac:	e3530000 	cmp	r3, #0
  10cdb0:	0a00002c 	beq	10ce68 <sent_tcp+0x10c>
    if (conn->state == NETCONN_WRITE) {
  10cdb4:	e51b3008 	ldr	r3, [fp, #-8]
  10cdb8:	e5933004 	ldr	r3, [r3, #4]
  10cdbc:	e3530001 	cmp	r3, #1
  10cdc0:	1a000003 	bne	10cdd4 <sent_tcp+0x78>
      lwip_netconn_do_writemore(conn  WRITE_DELAYED);
  10cdc4:	e3a01001 	mov	r1, #1
  10cdc8:	e51b0008 	ldr	r0, [fp, #-8]
  10cdcc:	eb0008d8 	bl	10f134 <lwip_netconn_do_writemore>
  10cdd0:	ea000006 	b	10cdf0 <sent_tcp+0x94>
    } else if (conn->state == NETCONN_CLOSE) {
  10cdd4:	e51b3008 	ldr	r3, [fp, #-8]
  10cdd8:	e5933004 	ldr	r3, [r3, #4]
  10cddc:	e3530004 	cmp	r3, #4
  10cde0:	1a000002 	bne	10cdf0 <sent_tcp+0x94>
      lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
  10cde4:	e3a01001 	mov	r1, #1
  10cde8:	e51b0008 	ldr	r0, [fp, #-8]
  10cdec:	eb000348 	bl	10db14 <lwip_netconn_do_close_internal>
    }

    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
  10cdf0:	e51b3008 	ldr	r3, [fp, #-8]
  10cdf4:	e5933008 	ldr	r3, [r3, #8]
  10cdf8:	e3530000 	cmp	r3, #0
  10cdfc:	0a000019 	beq	10ce68 <sent_tcp+0x10c>
  10ce00:	e51b3008 	ldr	r3, [fp, #-8]
  10ce04:	e5933008 	ldr	r3, [r3, #8]
  10ce08:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
  10ce0c:	e3530a01 	cmp	r3, #4096	; 0x1000
  10ce10:	9a000014 	bls	10ce68 <sent_tcp+0x10c>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
  10ce14:	e51b3008 	ldr	r3, [fp, #-8]
  10ce18:	e5933008 	ldr	r3, [r3, #8]
  10ce1c:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
  10ce20:	e353000a 	cmp	r3, #10
  10ce24:	8a00000f 	bhi	10ce68 <sent_tcp+0x10c>
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
  10ce28:	e51b3008 	ldr	r3, [fp, #-8]
  10ce2c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10ce30:	e3c33010 	bic	r3, r3, #16
  10ce34:	e6ef2073 	uxtb	r2, r3
  10ce38:	e51b3008 	ldr	r3, [fp, #-8]
  10ce3c:	e5c32030 	strb	r2, [r3, #48]	; 0x30
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  10ce40:	e51b3008 	ldr	r3, [fp, #-8]
  10ce44:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10ce48:	e3530000 	cmp	r3, #0
  10ce4c:	0a000005 	beq	10ce68 <sent_tcp+0x10c>
  10ce50:	e51b3008 	ldr	r3, [fp, #-8]
  10ce54:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10ce58:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  10ce5c:	e3a01002 	mov	r1, #2
  10ce60:	e51b0008 	ldr	r0, [fp, #-8]
  10ce64:	e12fff33 	blx	r3
    }
  }

  return ERR_OK;
  10ce68:	e3a03000 	mov	r3, #0
}
  10ce6c:	e1a00003 	mov	r0, r3
  10ce70:	e24bd004 	sub	sp, fp, #4
  10ce74:	e8bd8800 	pop	{fp, pc}

0010ce78 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  10ce78:	e92d4800 	push	{fp, lr}
  10ce7c:	e28db004 	add	fp, sp, #4
  10ce80:	e24dd018 	sub	sp, sp, #24
  10ce84:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10ce88:	e1a03001 	mov	r3, r1
  10ce8c:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
  struct netconn *conn;
  enum netconn_state old_state;

  conn = (struct netconn *)arg;
  10ce90:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10ce94:	e50b3008 	str	r3, [fp, #-8]
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  10ce98:	e51b3008 	ldr	r3, [fp, #-8]
  10ce9c:	e3530000 	cmp	r3, #0
  10cea0:	1a000006 	bne	10cec0 <err_tcp+0x48>
  10cea4:	e30609b4 	movw	r0, #27060	; 0x69b4
  10cea8:	e3400014 	movt	r0, #20
  10ceac:	ebffd898 	bl	103114 <rt_kprintf>
  10ceb0:	e300117e 	movw	r1, #382	; 0x17e
  10ceb4:	e30608bc 	movw	r0, #26812	; 0x68bc
  10ceb8:	e3400014 	movt	r0, #20
  10cebc:	ebfff86e 	bl	10b07c <sys_arch_assert>

  conn->pcb.tcp = NULL;
  10cec0:	e51b3008 	ldr	r3, [fp, #-8]
  10cec4:	e3a02000 	mov	r2, #0
  10cec8:	e5832008 	str	r2, [r3, #8]

  /* reset conn->state now before waking up other threads */
  old_state = conn->state;
  10cecc:	e51b3008 	ldr	r3, [fp, #-8]
  10ced0:	e5933004 	ldr	r3, [r3, #4]
  10ced4:	e50b300c 	str	r3, [fp, #-12]
  conn->state = NETCONN_NONE;
  10ced8:	e51b3008 	ldr	r3, [fp, #-8]
  10cedc:	e3a02000 	mov	r2, #0
  10cee0:	e5832004 	str	r2, [r3, #4]

  if (old_state == NETCONN_CLOSE) {
  10cee4:	e51b300c 	ldr	r3, [fp, #-12]
  10cee8:	e3530004 	cmp	r3, #4
  10ceec:	1a00000e 	bne	10cf2c <err_tcp+0xb4>
    /* RST during close: let close return success & dealloc the netconn */
    err = ERR_OK;
  10cef0:	e3a03000 	mov	r3, #0
  10cef4:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    NETCONN_SET_SAFE_ERR(conn, ERR_OK);
  10cef8:	e51b3008 	ldr	r3, [fp, #-8]
  10cefc:	e3530000 	cmp	r3, #0
  10cf00:	0a00000e 	beq	10cf40 <err_tcp+0xc8>
  10cf04:	ebffd4cc 	bl	10223c <rt_enter_critical>
  10cf08:	e51b3008 	ldr	r3, [fp, #-8]
  10cf0c:	e1d330dc 	ldrsb	r3, [r3, #12]
  10cf10:	e373000c 	cmn	r3, #12
  10cf14:	ba000002 	blt	10cf24 <err_tcp+0xac>
  10cf18:	e51b3008 	ldr	r3, [fp, #-8]
  10cf1c:	e3a02000 	mov	r2, #0
  10cf20:	e5c3200c 	strb	r2, [r3, #12]
  10cf24:	ebffd4ca 	bl	102254 <rt_exit_critical>
  10cf28:	ea000004 	b	10cf40 <err_tcp+0xc8>
  } else {
    /* no check since this is always fatal! */
    SYS_ARCH_SET(conn->last_err, err);
  10cf2c:	ebffd4c2 	bl	10223c <rt_enter_critical>
  10cf30:	e51b3008 	ldr	r3, [fp, #-8]
  10cf34:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
  10cf38:	e5c3200c 	strb	r2, [r3, #12]
  10cf3c:	ebffd4c4 	bl	102254 <rt_exit_critical>
  }

  /* @todo: the type of NETCONN_EVT created should depend on 'old_state' */

  /* Notify the user layer about a connection error. Used to signal select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
  10cf40:	e51b3008 	ldr	r3, [fp, #-8]
  10cf44:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cf48:	e3530000 	cmp	r3, #0
  10cf4c:	0a000005 	beq	10cf68 <err_tcp+0xf0>
  10cf50:	e51b3008 	ldr	r3, [fp, #-8]
  10cf54:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cf58:	e3a02000 	mov	r2, #0
  10cf5c:	e3a01004 	mov	r1, #4
  10cf60:	e51b0008 	ldr	r0, [fp, #-8]
  10cf64:	e12fff33 	blx	r3
  /* Try to release selects pending on 'read' or 'write', too.
     They will get an error if they actually try to read or write. */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  10cf68:	e51b3008 	ldr	r3, [fp, #-8]
  10cf6c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cf70:	e3530000 	cmp	r3, #0
  10cf74:	0a000005 	beq	10cf90 <err_tcp+0x118>
  10cf78:	e51b3008 	ldr	r3, [fp, #-8]
  10cf7c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cf80:	e3a02000 	mov	r2, #0
  10cf84:	e3a01000 	mov	r1, #0
  10cf88:	e51b0008 	ldr	r0, [fp, #-8]
  10cf8c:	e12fff33 	blx	r3
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  10cf90:	e51b3008 	ldr	r3, [fp, #-8]
  10cf94:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cf98:	e3530000 	cmp	r3, #0
  10cf9c:	0a000005 	beq	10cfb8 <err_tcp+0x140>
  10cfa0:	e51b3008 	ldr	r3, [fp, #-8]
  10cfa4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10cfa8:	e3a02000 	mov	r2, #0
  10cfac:	e3a01002 	mov	r1, #2
  10cfb0:	e51b0008 	ldr	r0, [fp, #-8]
  10cfb4:	e12fff33 	blx	r3

  /* pass NULL-message to recvmbox to wake up pending recv */
  if (sys_mbox_valid(&conn->recvmbox)) {
  10cfb8:	e51b3008 	ldr	r3, [fp, #-8]
  10cfbc:	e2833014 	add	r3, r3, #20
  10cfc0:	e1a00003 	mov	r0, r3
  10cfc4:	ebfff7e3 	bl	10af58 <sys_mbox_valid>
  10cfc8:	e1a03000 	mov	r3, r0
  10cfcc:	e3530000 	cmp	r3, #0
  10cfd0:	0a000004 	beq	10cfe8 <err_tcp+0x170>
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, NULL);
  10cfd4:	e51b3008 	ldr	r3, [fp, #-8]
  10cfd8:	e2833014 	add	r3, r3, #20
  10cfdc:	e3a01000 	mov	r1, #0
  10cfe0:	e1a00003 	mov	r0, r3
  10cfe4:	ebfff77d 	bl	10ade0 <sys_mbox_trypost>
  }
  /* pass NULL-message to acceptmbox to wake up pending accept */
  if (sys_mbox_valid(&conn->acceptmbox)) {
  10cfe8:	e51b3008 	ldr	r3, [fp, #-8]
  10cfec:	e2833018 	add	r3, r3, #24
  10cff0:	e1a00003 	mov	r0, r3
  10cff4:	ebfff7d7 	bl	10af58 <sys_mbox_valid>
  10cff8:	e1a03000 	mov	r3, r0
  10cffc:	e3530000 	cmp	r3, #0
  10d000:	0a000004 	beq	10d018 <err_tcp+0x1a0>
    /* use trypost to preven deadlock */
    sys_mbox_trypost(&conn->acceptmbox, NULL);
  10d004:	e51b3008 	ldr	r3, [fp, #-8]
  10d008:	e2833018 	add	r3, r3, #24
  10d00c:	e3a01000 	mov	r1, #0
  10d010:	e1a00003 	mov	r0, r3
  10d014:	ebfff771 	bl	10ade0 <sys_mbox_trypost>
  }

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
  10d018:	e51b300c 	ldr	r3, [fp, #-12]
  10d01c:	e3530001 	cmp	r3, #1
  10d020:	0a000005 	beq	10d03c <err_tcp+0x1c4>
  10d024:	e51b300c 	ldr	r3, [fp, #-12]
  10d028:	e3530004 	cmp	r3, #4
  10d02c:	0a000002 	beq	10d03c <err_tcp+0x1c4>
  10d030:	e51b300c 	ldr	r3, [fp, #-12]
  10d034:	e3530003 	cmp	r3, #3
  10d038:	1a000042 	bne	10d148 <err_tcp+0x2d0>
      (old_state == NETCONN_CONNECT)) {
    /* calling lwip_netconn_do_writemore/lwip_netconn_do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
  10d03c:	e51b3008 	ldr	r3, [fp, #-8]
  10d040:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10d044:	e2033004 	and	r3, r3, #4
  10d048:	e3530000 	cmp	r3, #0
  10d04c:	13a03001 	movne	r3, #1
  10d050:	03a03000 	moveq	r3, #0
  10d054:	e6ef3073 	uxtb	r3, r3
  10d058:	e50b3010 	str	r3, [fp, #-16]
    SET_NONBLOCKING_CONNECT(conn, 0);
  10d05c:	e51b3008 	ldr	r3, [fp, #-8]
  10d060:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10d064:	e3c33004 	bic	r3, r3, #4
  10d068:	e6ef2073 	uxtb	r2, r3
  10d06c:	e51b3008 	ldr	r3, [fp, #-8]
  10d070:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    if (!was_nonblocking_connect) {
  10d074:	e51b3010 	ldr	r3, [fp, #-16]
  10d078:	e3530000 	cmp	r3, #0
  10d07c:	1a00003d 	bne	10d178 <err_tcp+0x300>
      sys_sem_t* op_completed_sem;
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
  10d080:	e51b3008 	ldr	r3, [fp, #-8]
  10d084:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10d088:	e3530000 	cmp	r3, #0
  10d08c:	1a000006 	bne	10d0ac <err_tcp+0x234>
  10d090:	e30609c4 	movw	r0, #27076	; 0x69c4
  10d094:	e3400014 	movt	r0, #20
  10d098:	ebffd81d 	bl	103114 <rt_kprintf>
  10d09c:	e30011ad 	movw	r1, #429	; 0x1ad
  10d0a0:	e30608bc 	movw	r0, #26812	; 0x68bc
  10d0a4:	e3400014 	movt	r0, #20
  10d0a8:	ebfff7f3 	bl	10b07c <sys_arch_assert>
      conn->current_msg->err = err;
  10d0ac:	e51b3008 	ldr	r3, [fp, #-8]
  10d0b0:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10d0b4:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
  10d0b8:	e5c32004 	strb	r2, [r3, #4]
      op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
  10d0bc:	e51b3008 	ldr	r3, [fp, #-8]
  10d0c0:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10d0c4:	e5933000 	ldr	r3, [r3]
  10d0c8:	e2833010 	add	r3, r3, #16
  10d0cc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      LWIP_ASSERT("inavlid op_completed_sem", sys_sem_valid(op_completed_sem));
  10d0d0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  10d0d4:	ebfff5ca 	bl	10a804 <sys_sem_valid>
  10d0d8:	e1a03000 	mov	r3, r0
  10d0dc:	e3530000 	cmp	r3, #0
  10d0e0:	1a000006 	bne	10d100 <err_tcp+0x288>
  10d0e4:	e30609e0 	movw	r0, #27104	; 0x69e0
  10d0e8:	e3400014 	movt	r0, #20
  10d0ec:	ebffd808 	bl	103114 <rt_kprintf>
  10d0f0:	e3a01e1b 	mov	r1, #432	; 0x1b0
  10d0f4:	e30608bc 	movw	r0, #26812	; 0x68bc
  10d0f8:	e3400014 	movt	r0, #20
  10d0fc:	ebfff7de 	bl	10b07c <sys_arch_assert>
      conn->current_msg = NULL;
  10d100:	e51b3008 	ldr	r3, [fp, #-8]
  10d104:	e3a02000 	mov	r2, #0
  10d108:	e5832038 	str	r2, [r3, #56]	; 0x38
      /* wake up the waiting task */
      NETCONN_SET_SAFE_ERR(conn, err);
  10d10c:	e51b3008 	ldr	r3, [fp, #-8]
  10d110:	e3530000 	cmp	r3, #0
  10d114:	0a000008 	beq	10d13c <err_tcp+0x2c4>
  10d118:	ebffd447 	bl	10223c <rt_enter_critical>
  10d11c:	e51b3008 	ldr	r3, [fp, #-8]
  10d120:	e1d330dc 	ldrsb	r3, [r3, #12]
  10d124:	e373000c 	cmn	r3, #12
  10d128:	ba000002 	blt	10d138 <err_tcp+0x2c0>
  10d12c:	e51b3008 	ldr	r3, [fp, #-8]
  10d130:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
  10d134:	e5c3200c 	strb	r2, [r3, #12]
  10d138:	ebffd445 	bl	102254 <rt_exit_critical>
      sys_sem_signal(op_completed_sem);
  10d13c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  10d140:	ebfff571 	bl	10a70c <sys_sem_signal>
      (old_state == NETCONN_CONNECT)) {
  10d144:	ea00000b 	b	10d178 <err_tcp+0x300>
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
  10d148:	e51b3008 	ldr	r3, [fp, #-8]
  10d14c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10d150:	e3530000 	cmp	r3, #0
  10d154:	0a000008 	beq	10d17c <err_tcp+0x304>
  10d158:	e30609fc 	movw	r0, #27132	; 0x69fc
  10d15c:	e3400014 	movt	r0, #20
  10d160:	ebffd7eb 	bl	103114 <rt_kprintf>
  10d164:	e30011b7 	movw	r1, #439	; 0x1b7
  10d168:	e30608bc 	movw	r0, #26812	; 0x68bc
  10d16c:	e3400014 	movt	r0, #20
  10d170:	ebfff7c1 	bl	10b07c <sys_arch_assert>
  }
}
  10d174:	ea000000 	b	10d17c <err_tcp+0x304>
      (old_state == NETCONN_CONNECT)) {
  10d178:	e320f000 	nop	{0}
}
  10d17c:	e320f000 	nop	{0}
  10d180:	e24bd004 	sub	sp, fp, #4
  10d184:	e8bd8800 	pop	{fp, pc}

0010d188 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  10d188:	e92d4800 	push	{fp, lr}
  10d18c:	e28db004 	add	fp, sp, #4
  10d190:	e24dd010 	sub	sp, sp, #16
  10d194:	e50b0010 	str	r0, [fp, #-16]
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  10d198:	e51b3010 	ldr	r3, [fp, #-16]
  10d19c:	e5933008 	ldr	r3, [r3, #8]
  10d1a0:	e50b3008 	str	r3, [fp, #-8]
  tcp_arg(pcb, conn);
  10d1a4:	e51b1010 	ldr	r1, [fp, #-16]
  10d1a8:	e51b0008 	ldr	r0, [fp, #-8]
  10d1ac:	eb004aed 	bl	11fd68 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  10d1b0:	e30c1a5c 	movw	r1, #51804	; 0xca5c
  10d1b4:	e3401010 	movt	r1, #16
  10d1b8:	e51b0008 	ldr	r0, [fp, #-8]
  10d1bc:	eb004af8 	bl	11fda4 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  10d1c0:	e30c1d5c 	movw	r1, #52572	; 0xcd5c
  10d1c4:	e3401010 	movt	r1, #16
  10d1c8:	e51b0008 	ldr	r0, [fp, #-8]
  10d1cc:	eb004b0d 	bl	11fe08 <tcp_sent>
  tcp_poll(pcb, poll_tcp, NETCONN_TCP_POLL_INTERVAL);
  10d1d0:	e3a02002 	mov	r2, #2
  10d1d4:	e30c1c40 	movw	r1, #52288	; 0xcc40
  10d1d8:	e3401010 	movt	r1, #16
  10d1dc:	e51b0008 	ldr	r0, [fp, #-8]
  10d1e0:	eb004b4f 	bl	11ff24 <tcp_poll>
  tcp_err(pcb, err_tcp);
  10d1e4:	e30c1e78 	movw	r1, #52856	; 0xce78
  10d1e8:	e3401010 	movt	r1, #16
  10d1ec:	e51b0008 	ldr	r0, [fp, #-8]
  10d1f0:	eb004b1d 	bl	11fe6c <tcp_err>
}
  10d1f4:	e320f000 	nop	{0}
  10d1f8:	e24bd004 	sub	sp, fp, #4
  10d1fc:	e8bd8800 	pop	{fp, pc}

0010d200 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  10d200:	e92d4800 	push	{fp, lr}
  10d204:	e28db004 	add	fp, sp, #4
  10d208:	e24dd020 	sub	sp, sp, #32
  10d20c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10d210:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  10d214:	e1a03002 	mov	r3, r2
  10d218:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;
  10d21c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d220:	e50b3008 	str	r3, [fp, #-8]

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (conn == NULL) {
  10d224:	e51b3008 	ldr	r3, [fp, #-8]
  10d228:	e3530000 	cmp	r3, #0
  10d22c:	1a000001 	bne	10d238 <accept_function+0x38>
    return ERR_VAL;
  10d230:	e3e03005 	mvn	r3, #5
  10d234:	ea00007d 	b	10d430 <accept_function+0x230>
  }
  if (!sys_mbox_valid(&conn->acceptmbox)) {
  10d238:	e51b3008 	ldr	r3, [fp, #-8]
  10d23c:	e2833018 	add	r3, r3, #24
  10d240:	e1a00003 	mov	r0, r3
  10d244:	ebfff743 	bl	10af58 <sys_mbox_valid>
  10d248:	e1a03000 	mov	r3, r0
  10d24c:	e3530000 	cmp	r3, #0
  10d250:	1a000001 	bne	10d25c <accept_function+0x5c>
    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
    return ERR_VAL;
  10d254:	e3e03005 	mvn	r3, #5
  10d258:	ea000074 	b	10d430 <accept_function+0x230>
  }

  if (newpcb == NULL) {
  10d25c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  10d260:	e3530000 	cmp	r3, #0
  10d264:	1a000014 	bne	10d2bc <accept_function+0xbc>
    /* out-of-pcbs during connect: pass on this error to the application */
    if (sys_mbox_trypost(&conn->acceptmbox, &netconn_aborted) == ERR_OK) {
  10d268:	e51b3008 	ldr	r3, [fp, #-8]
  10d26c:	e2833018 	add	r3, r3, #24
  10d270:	e300157c 	movw	r1, #1404	; 0x57c
  10d274:	e3401015 	movt	r1, #21
  10d278:	e1a00003 	mov	r0, r3
  10d27c:	ebfff6d7 	bl	10ade0 <sys_mbox_trypost>
  10d280:	e1a03000 	mov	r3, r0
  10d284:	e3530000 	cmp	r3, #0
  10d288:	1a000009 	bne	10d2b4 <accept_function+0xb4>
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  10d28c:	e51b3008 	ldr	r3, [fp, #-8]
  10d290:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10d294:	e3530000 	cmp	r3, #0
  10d298:	0a000005 	beq	10d2b4 <accept_function+0xb4>
  10d29c:	e51b3008 	ldr	r3, [fp, #-8]
  10d2a0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10d2a4:	e3a02000 	mov	r2, #0
  10d2a8:	e3a01000 	mov	r1, #0
  10d2ac:	e51b0008 	ldr	r0, [fp, #-8]
  10d2b0:	e12fff33 	blx	r3
    }
    return ERR_VAL;
  10d2b4:	e3e03005 	mvn	r3, #5
  10d2b8:	ea00005c 	b	10d430 <accept_function+0x230>
  }

  /* We have to set the callback here even though
   * the new socket is unknown. newconn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  10d2bc:	e51b3008 	ldr	r3, [fp, #-8]
  10d2c0:	e5932000 	ldr	r2, [r3]
  10d2c4:	e51b3008 	ldr	r3, [fp, #-8]
  10d2c8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10d2cc:	e1a01003 	mov	r1, r3
  10d2d0:	e1a00002 	mov	r0, r2
  10d2d4:	eb0000f7 	bl	10d6b8 <netconn_alloc>
  10d2d8:	e50b000c 	str	r0, [fp, #-12]
  if (newconn == NULL) {
  10d2dc:	e51b300c 	ldr	r3, [fp, #-12]
  10d2e0:	e3530000 	cmp	r3, #0
  10d2e4:	1a000014 	bne	10d33c <accept_function+0x13c>
    /* outof netconns: pass on this error to the application */
    if (sys_mbox_trypost(&conn->acceptmbox, &netconn_aborted) == ERR_OK) {
  10d2e8:	e51b3008 	ldr	r3, [fp, #-8]
  10d2ec:	e2833018 	add	r3, r3, #24
  10d2f0:	e300157c 	movw	r1, #1404	; 0x57c
  10d2f4:	e3401015 	movt	r1, #21
  10d2f8:	e1a00003 	mov	r0, r3
  10d2fc:	ebfff6b7 	bl	10ade0 <sys_mbox_trypost>
  10d300:	e1a03000 	mov	r3, r0
  10d304:	e3530000 	cmp	r3, #0
  10d308:	1a000009 	bne	10d334 <accept_function+0x134>
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  10d30c:	e51b3008 	ldr	r3, [fp, #-8]
  10d310:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10d314:	e3530000 	cmp	r3, #0
  10d318:	0a000005 	beq	10d334 <accept_function+0x134>
  10d31c:	e51b3008 	ldr	r3, [fp, #-8]
  10d320:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10d324:	e3a02000 	mov	r2, #0
  10d328:	e3a01000 	mov	r1, #0
  10d32c:	e51b0008 	ldr	r0, [fp, #-8]
  10d330:	e12fff33 	blx	r3
    }
    return ERR_MEM;
  10d334:	e3e03000 	mvn	r3, #0
  10d338:	ea00003c 	b	10d430 <accept_function+0x230>
  }
  newconn->pcb.tcp = newpcb;
  10d33c:	e51b300c 	ldr	r3, [fp, #-12]
  10d340:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  10d344:	e5832008 	str	r2, [r3, #8]
  setup_tcp(newconn);
  10d348:	e51b000c 	ldr	r0, [fp, #-12]
  10d34c:	ebffff8d 	bl	10d188 <setup_tcp>
  /* no protection: when creating the pcb, the netconn is not yet known
     to the application thread */
  newconn->last_err = err;
  10d350:	e51b300c 	ldr	r3, [fp, #-12]
  10d354:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
  10d358:	e5c3200c 	strb	r2, [r3, #12]

  /* handle backlog counter */
  tcp_backlog_delayed(newpcb);

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
  10d35c:	e51b3008 	ldr	r3, [fp, #-8]
  10d360:	e2833018 	add	r3, r3, #24
  10d364:	e51b100c 	ldr	r1, [fp, #-12]
  10d368:	e1a00003 	mov	r0, r3
  10d36c:	ebfff69b 	bl	10ade0 <sys_mbox_trypost>
  10d370:	e1a03000 	mov	r3, r0
  10d374:	e3530000 	cmp	r3, #0
  10d378:	0a000021 	beq	10d404 <accept_function+0x204>
    /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
       so do nothing here! */
    /* remove all references to this netconn from the pcb */
    struct tcp_pcb* pcb = newconn->pcb.tcp;
  10d37c:	e51b300c 	ldr	r3, [fp, #-12]
  10d380:	e5933008 	ldr	r3, [r3, #8]
  10d384:	e50b3010 	str	r3, [fp, #-16]
    tcp_arg(pcb, NULL);
  10d388:	e3a01000 	mov	r1, #0
  10d38c:	e51b0010 	ldr	r0, [fp, #-16]
  10d390:	eb004a74 	bl	11fd68 <tcp_arg>
    tcp_recv(pcb, NULL);
  10d394:	e3a01000 	mov	r1, #0
  10d398:	e51b0010 	ldr	r0, [fp, #-16]
  10d39c:	eb004a80 	bl	11fda4 <tcp_recv>
    tcp_sent(pcb, NULL);
  10d3a0:	e3a01000 	mov	r1, #0
  10d3a4:	e51b0010 	ldr	r0, [fp, #-16]
  10d3a8:	eb004a96 	bl	11fe08 <tcp_sent>
    tcp_poll(pcb, NULL, 0);
  10d3ac:	e3a02000 	mov	r2, #0
  10d3b0:	e3a01000 	mov	r1, #0
  10d3b4:	e51b0010 	ldr	r0, [fp, #-16]
  10d3b8:	eb004ad9 	bl	11ff24 <tcp_poll>
    tcp_err(pcb, NULL);
  10d3bc:	e3a01000 	mov	r1, #0
  10d3c0:	e51b0010 	ldr	r0, [fp, #-16]
  10d3c4:	eb004aa8 	bl	11fe6c <tcp_err>
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
  10d3c8:	e51b300c 	ldr	r3, [fp, #-12]
  10d3cc:	e3a02000 	mov	r2, #0
  10d3d0:	e5832008 	str	r2, [r3, #8]
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
  10d3d4:	e51b300c 	ldr	r3, [fp, #-12]
  10d3d8:	e2833014 	add	r3, r3, #20
  10d3dc:	e1a00003 	mov	r0, r3
  10d3e0:	ebfff61e 	bl	10ac60 <sys_mbox_free>
    sys_mbox_set_invalid(&newconn->recvmbox);
  10d3e4:	e51b300c 	ldr	r3, [fp, #-12]
  10d3e8:	e2833014 	add	r3, r3, #20
  10d3ec:	e1a00003 	mov	r0, r3
  10d3f0:	ebfff6e2 	bl	10af80 <sys_mbox_set_invalid>
    netconn_free(newconn);
  10d3f4:	e51b000c 	ldr	r0, [fp, #-12]
  10d3f8:	eb000122 	bl	10d888 <netconn_free>
    return ERR_MEM;
  10d3fc:	e3e03000 	mvn	r3, #0
  10d400:	ea00000a 	b	10d430 <accept_function+0x230>
  } else {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  10d404:	e51b3008 	ldr	r3, [fp, #-8]
  10d408:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10d40c:	e3530000 	cmp	r3, #0
  10d410:	0a000005 	beq	10d42c <accept_function+0x22c>
  10d414:	e51b3008 	ldr	r3, [fp, #-8]
  10d418:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10d41c:	e3a02000 	mov	r2, #0
  10d420:	e3a01000 	mov	r1, #0
  10d424:	e51b0008 	ldr	r0, [fp, #-8]
  10d428:	e12fff33 	blx	r3
  }

  return ERR_OK;
  10d42c:	e3a03000 	mov	r3, #0
}
  10d430:	e1a00003 	mov	r0, r3
  10d434:	e24bd004 	sub	sp, fp, #4
  10d438:	e8bd8800 	pop	{fp, pc}

0010d43c <pcb_new>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
static void
pcb_new(struct api_msg *msg)
{
  10d43c:	e92d4810 	push	{r4, fp, lr}
  10d440:	e28db008 	add	fp, sp, #8
  10d444:	e24dd014 	sub	sp, sp, #20
  10d448:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  enum lwip_ip_addr_type iptype = IPADDR_TYPE_V4;
  10d44c:	e3a03000 	mov	r3, #0
  10d450:	e50b3010 	str	r3, [fp, #-16]

  LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  10d454:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d458:	e5933000 	ldr	r3, [r3]
  10d45c:	e5933008 	ldr	r3, [r3, #8]
  10d460:	e3530000 	cmp	r3, #0
  10d464:	0a000006 	beq	10d484 <pcb_new+0x48>
  10d468:	e3060a18 	movw	r0, #27160	; 0x6a18
  10d46c:	e3400014 	movt	r0, #20
  10d470:	ebffd727 	bl	103114 <rt_kprintf>
  10d474:	e3001226 	movw	r1, #550	; 0x226
  10d478:	e30608bc 	movw	r0, #26812	; 0x68bc
  10d47c:	e3400014 	movt	r0, #20
  10d480:	ebfff6fd 	bl	10b07c <sys_arch_assert>
    iptype = IPADDR_TYPE_ANY;
  }
#endif

  /* Allocate a PCB for this connection */
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  10d484:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d488:	e5933000 	ldr	r3, [r3]
  10d48c:	e5933000 	ldr	r3, [r3]
  10d490:	e20330f0 	and	r3, r3, #240	; 0xf0
  10d494:	e3530020 	cmp	r3, #32
  10d498:	0a00001d 	beq	10d514 <pcb_new+0xd8>
  10d49c:	e3530040 	cmp	r3, #64	; 0x40
  10d4a0:	0a000002 	beq	10d4b0 <pcb_new+0x74>
  10d4a4:	e3530010 	cmp	r3, #16
  10d4a8:	0a00003a 	beq	10d598 <pcb_new+0x15c>
  10d4ac:	ea00004b 	b	10d5e0 <pcb_new+0x1a4>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->pcb.raw = raw_new_ip_type(iptype, msg->msg.n.proto);
  10d4b0:	e51b3010 	ldr	r3, [fp, #-16]
  10d4b4:	e6ef2073 	uxtb	r2, r3
  10d4b8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d4bc:	e5d31008 	ldrb	r1, [r3, #8]
  10d4c0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d4c4:	e5934000 	ldr	r4, [r3]
  10d4c8:	e1a00002 	mov	r0, r2
  10d4cc:	eb003d6a 	bl	11ca7c <raw_new_ip_type>
  10d4d0:	e1a03000 	mov	r3, r0
  10d4d4:	e5843008 	str	r3, [r4, #8]
    if (msg->conn->pcb.raw != NULL) {
  10d4d8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d4dc:	e5933000 	ldr	r3, [r3]
  10d4e0:	e5933008 	ldr	r3, [r3, #8]
  10d4e4:	e3530000 	cmp	r3, #0
  10d4e8:	0a000040 	beq	10d5f0 <pcb_new+0x1b4>
      if (NETCONNTYPE_ISIPV6(msg->conn->type) && msg->conn->pcb.raw->protocol == IP6_NEXTH_ICMP6) {
        msg->conn->pcb.raw->chksum_reqd = 1;
        msg->conn->pcb.raw->chksum_offset = 2;
      }
#endif /* LWIP_IPV6 */
      raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  10d4ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d4f0:	e5933000 	ldr	r3, [r3]
  10d4f4:	e5930008 	ldr	r0, [r3, #8]
  10d4f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d4fc:	e5933000 	ldr	r3, [r3]
  10d500:	e1a02003 	mov	r2, r3
  10d504:	e30c165c 	movw	r1, #50780	; 0xc65c
  10d508:	e3401010 	movt	r1, #16
  10d50c:	eb003c57 	bl	11c670 <raw_recv>
    }
    break;
  10d510:	ea000036 	b	10d5f0 <pcb_new+0x1b4>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->pcb.udp = udp_new_ip_type(iptype);
  10d514:	e51b3010 	ldr	r3, [fp, #-16]
  10d518:	e6ef2073 	uxtb	r2, r3
  10d51c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d520:	e5934000 	ldr	r4, [r3]
  10d524:	e1a00002 	mov	r0, r2
  10d528:	eb006dfd 	bl	128d24 <udp_new_ip_type>
  10d52c:	e1a03000 	mov	r3, r0
  10d530:	e5843008 	str	r3, [r4, #8]
    if (msg->conn->pcb.udp != NULL) {
  10d534:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d538:	e5933000 	ldr	r3, [r3]
  10d53c:	e5933008 	ldr	r3, [r3, #8]
  10d540:	e3530000 	cmp	r3, #0
  10d544:	0a00002b 	beq	10d5f8 <pcb_new+0x1bc>
#if LWIP_UDPLITE
      if (NETCONNTYPE_ISUDPLITE(msg->conn->type)) {
        udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
      }
#endif /* LWIP_UDPLITE */
      if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
  10d548:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d54c:	e5933000 	ldr	r3, [r3]
  10d550:	e5933000 	ldr	r3, [r3]
  10d554:	e3530022 	cmp	r3, #34	; 0x22
  10d558:	1a000004 	bne	10d570 <pcb_new+0x134>
        udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  10d55c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d560:	e5933000 	ldr	r3, [r3]
  10d564:	e5933008 	ldr	r3, [r3, #8]
  10d568:	e3a02001 	mov	r2, #1
  10d56c:	e5c32010 	strb	r2, [r3, #16]
      }
      udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  10d570:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d574:	e5933000 	ldr	r3, [r3]
  10d578:	e5930008 	ldr	r0, [r3, #8]
  10d57c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d580:	e5933000 	ldr	r3, [r3]
  10d584:	e1a02003 	mov	r2, r3
  10d588:	e30c184c 	movw	r1, #51276	; 0xc84c
  10d58c:	e3401010 	movt	r1, #16
  10d590:	eb006d88 	bl	128bb8 <udp_recv>
    }
    break;
  10d594:	ea000017 	b	10d5f8 <pcb_new+0x1bc>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->pcb.tcp = tcp_new_ip_type(iptype);
  10d598:	e51b3010 	ldr	r3, [fp, #-16]
  10d59c:	e6ef2073 	uxtb	r2, r3
  10d5a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d5a4:	e5934000 	ldr	r4, [r3]
  10d5a8:	e1a00002 	mov	r0, r2
  10d5ac:	eb0049e1 	bl	11fd38 <tcp_new_ip_type>
  10d5b0:	e1a03000 	mov	r3, r0
  10d5b4:	e5843008 	str	r3, [r4, #8]
    if (msg->conn->pcb.tcp != NULL) {
  10d5b8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d5bc:	e5933000 	ldr	r3, [r3]
  10d5c0:	e5933008 	ldr	r3, [r3, #8]
  10d5c4:	e3530000 	cmp	r3, #0
  10d5c8:	0a00000c 	beq	10d600 <pcb_new+0x1c4>
      setup_tcp(msg->conn);
  10d5cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d5d0:	e5933000 	ldr	r3, [r3]
  10d5d4:	e1a00003 	mov	r0, r3
  10d5d8:	ebfffeea 	bl	10d188 <setup_tcp>
    }
    break;
  10d5dc:	ea000007 	b	10d600 <pcb_new+0x1c4>
#endif /* LWIP_TCP */
  default:
    /* Unsupported netconn type, e.g. protocol disabled */
    msg->err = ERR_VAL;
  10d5e0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d5e4:	e3e02005 	mvn	r2, #5
  10d5e8:	e5c32004 	strb	r2, [r3, #4]
    return;
  10d5ec:	ea00000c 	b	10d624 <pcb_new+0x1e8>
    break;
  10d5f0:	e320f000 	nop	{0}
  10d5f4:	ea000002 	b	10d604 <pcb_new+0x1c8>
    break;
  10d5f8:	e320f000 	nop	{0}
  10d5fc:	ea000000 	b	10d604 <pcb_new+0x1c8>
    break;
  10d600:	e320f000 	nop	{0}
  }
  if (msg->conn->pcb.ip == NULL) {
  10d604:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d608:	e5933000 	ldr	r3, [r3]
  10d60c:	e5933008 	ldr	r3, [r3, #8]
  10d610:	e3530000 	cmp	r3, #0
  10d614:	1a000002 	bne	10d624 <pcb_new+0x1e8>
    msg->err = ERR_MEM;
  10d618:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d61c:	e3e02000 	mvn	r2, #0
  10d620:	e5c32004 	strb	r2, [r3, #4]
  }
}
  10d624:	e24bd008 	sub	sp, fp, #8
  10d628:	e8bd8810 	pop	{r4, fp, pc}

0010d62c <lwip_netconn_do_newconn>:
 *
 * @param m the api_msg_msg describing the connection type
 */
void
lwip_netconn_do_newconn(void *m)
{
  10d62c:	e92d4800 	push	{fp, lr}
  10d630:	e28db004 	add	fp, sp, #4
  10d634:	e24dd010 	sub	sp, sp, #16
  10d638:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10d63c:	e51b3010 	ldr	r3, [fp, #-16]
  10d640:	e50b3008 	str	r3, [fp, #-8]

  msg->err = ERR_OK;
  10d644:	e51b3008 	ldr	r3, [fp, #-8]
  10d648:	e3a02000 	mov	r2, #0
  10d64c:	e5c32004 	strb	r2, [r3, #4]
  if (msg->conn->pcb.tcp == NULL) {
  10d650:	e51b3008 	ldr	r3, [fp, #-8]
  10d654:	e5933000 	ldr	r3, [r3]
  10d658:	e5933008 	ldr	r3, [r3, #8]
  10d65c:	e3530000 	cmp	r3, #0
  10d660:	1a000001 	bne	10d66c <lwip_netconn_do_newconn+0x40>
    pcb_new(msg);
  10d664:	e51b0008 	ldr	r0, [fp, #-8]
  10d668:	ebffff73 	bl	10d43c <pcb_new>
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
  10d66c:	e51b3008 	ldr	r3, [fp, #-8]
  10d670:	e5933000 	ldr	r3, [r3]
  10d674:	e3530000 	cmp	r3, #0
  10d678:	0a00000b 	beq	10d6ac <lwip_netconn_do_newconn+0x80>
  10d67c:	ebffd2ee 	bl	10223c <rt_enter_critical>
  10d680:	e51b3008 	ldr	r3, [fp, #-8]
  10d684:	e5933000 	ldr	r3, [r3]
  10d688:	e1d330dc 	ldrsb	r3, [r3, #12]
  10d68c:	e373000c 	cmn	r3, #12
  10d690:	ba000004 	blt	10d6a8 <lwip_netconn_do_newconn+0x7c>
  10d694:	e51b3008 	ldr	r3, [fp, #-8]
  10d698:	e5933000 	ldr	r3, [r3]
  10d69c:	e51b2008 	ldr	r2, [fp, #-8]
  10d6a0:	e1d220d4 	ldrsb	r2, [r2, #4]
  10d6a4:	e5c3200c 	strb	r2, [r3, #12]
  10d6a8:	ebffd2e9 	bl	102254 <rt_exit_critical>
}
  10d6ac:	e320f000 	nop	{0}
  10d6b0:	e24bd004 	sub	sp, fp, #4
  10d6b4:	e8bd8800 	pop	{fp, pc}

0010d6b8 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  10d6b8:	e92d4800 	push	{fp, lr}
  10d6bc:	e28db004 	add	fp, sp, #4
  10d6c0:	e24dd010 	sub	sp, sp, #16
  10d6c4:	e50b0010 	str	r0, [fp, #-16]
  10d6c8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct netconn *conn;
  int size;

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
  10d6cc:	e3002287 	movw	r2, #647	; 0x287
  10d6d0:	e30618bc 	movw	r1, #26812	; 0x68bc
  10d6d4:	e3401014 	movt	r1, #20
  10d6d8:	e3a00008 	mov	r0, #8
  10d6dc:	eb002efe 	bl	1192dc <memp_malloc_fn>
  10d6e0:	e50b000c 	str	r0, [fp, #-12]
  if (conn == NULL) {
  10d6e4:	e51b300c 	ldr	r3, [fp, #-12]
  10d6e8:	e3530000 	cmp	r3, #0
  10d6ec:	1a000001 	bne	10d6f8 <netconn_alloc+0x40>
    return NULL;
  10d6f0:	e3a03000 	mov	r3, #0
  10d6f4:	ea000060 	b	10d87c <netconn_alloc+0x1c4>
  }

  conn->last_err = ERR_OK;
  10d6f8:	e51b300c 	ldr	r3, [fp, #-12]
  10d6fc:	e3a02000 	mov	r2, #0
  10d700:	e5c3200c 	strb	r2, [r3, #12]
  conn->type = t;
  10d704:	e51b300c 	ldr	r3, [fp, #-12]
  10d708:	e51b2010 	ldr	r2, [fp, #-16]
  10d70c:	e5832000 	str	r2, [r3]
  conn->pcb.tcp = NULL;
  10d710:	e51b300c 	ldr	r3, [fp, #-12]
  10d714:	e3a02000 	mov	r2, #0
  10d718:	e5832008 	str	r2, [r3, #8]

  /* If all sizes are the same, every compiler should optimize this switch to nothing */
  switch(NETCONNTYPE_GROUP(t)) {
  10d71c:	e51b3010 	ldr	r3, [fp, #-16]
  10d720:	e20330f0 	and	r3, r3, #240	; 0xf0
  10d724:	e3530020 	cmp	r3, #32
  10d728:	0a000007 	beq	10d74c <netconn_alloc+0x94>
  10d72c:	e3530040 	cmp	r3, #64	; 0x40
  10d730:	0a000002 	beq	10d740 <netconn_alloc+0x88>
  10d734:	e3530010 	cmp	r3, #16
  10d738:	0a000006 	beq	10d758 <netconn_alloc+0xa0>
  10d73c:	ea000008 	b	10d764 <netconn_alloc+0xac>
#if LWIP_RAW
  case NETCONN_RAW:
    size = DEFAULT_RAW_RECVMBOX_SIZE;
  10d740:	e3a03001 	mov	r3, #1
  10d744:	e50b3008 	str	r3, [fp, #-8]
    break;
  10d748:	ea00000d 	b	10d784 <netconn_alloc+0xcc>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    size = DEFAULT_UDP_RECVMBOX_SIZE;
  10d74c:	e3a03b01 	mov	r3, #1024	; 0x400
  10d750:	e50b3008 	str	r3, [fp, #-8]
    break;
  10d754:	ea00000a 	b	10d784 <netconn_alloc+0xcc>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    size = DEFAULT_TCP_RECVMBOX_SIZE;
  10d758:	e30f3fff 	movw	r3, #65535	; 0xffff
  10d75c:	e50b3008 	str	r3, [fp, #-8]
    break;
  10d760:	ea000007 	b	10d784 <netconn_alloc+0xcc>
#endif /* LWIP_TCP */
  default:
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
  10d764:	e3060a38 	movw	r0, #27192	; 0x6a38
  10d768:	e3400014 	movt	r0, #20
  10d76c:	ebffd668 	bl	103114 <rt_kprintf>
  10d770:	e30012a2 	movw	r1, #674	; 0x2a2
  10d774:	e30608bc 	movw	r0, #26812	; 0x68bc
  10d778:	e3400014 	movt	r0, #20
  10d77c:	ebfff63e 	bl	10b07c <sys_arch_assert>
    goto free_and_return;
  10d780:	ea000039 	b	10d86c <netconn_alloc+0x1b4>
  }

  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
  10d784:	e51b300c 	ldr	r3, [fp, #-12]
  10d788:	e2833014 	add	r3, r3, #20
  10d78c:	e51b1008 	ldr	r1, [fp, #-8]
  10d790:	e1a00003 	mov	r0, r3
  10d794:	ebfff4ec 	bl	10ab4c <sys_mbox_new>
  10d798:	e1a03000 	mov	r3, r0
  10d79c:	e3530000 	cmp	r3, #0
  10d7a0:	1a000030 	bne	10d868 <netconn_alloc+0x1b0>
    goto free_and_return;
  }
#if !LWIP_NETCONN_SEM_PER_THREAD
  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
  10d7a4:	e51b300c 	ldr	r3, [fp, #-12]
  10d7a8:	e2833010 	add	r3, r3, #16
  10d7ac:	e3a01000 	mov	r1, #0
  10d7b0:	e1a00003 	mov	r0, r3
  10d7b4:	ebfff39e 	bl	10a634 <sys_sem_new>
  10d7b8:	e1a03000 	mov	r3, r0
  10d7bc:	e3530000 	cmp	r3, #0
  10d7c0:	0a000004 	beq	10d7d8 <netconn_alloc+0x120>
    sys_mbox_free(&conn->recvmbox);
  10d7c4:	e51b300c 	ldr	r3, [fp, #-12]
  10d7c8:	e2833014 	add	r3, r3, #20
  10d7cc:	e1a00003 	mov	r0, r3
  10d7d0:	ebfff522 	bl	10ac60 <sys_mbox_free>
    goto free_and_return;
  10d7d4:	ea000024 	b	10d86c <netconn_alloc+0x1b4>
  }
#endif

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
  10d7d8:	e51b300c 	ldr	r3, [fp, #-12]
  10d7dc:	e2833018 	add	r3, r3, #24
  10d7e0:	e1a00003 	mov	r0, r3
  10d7e4:	ebfff5e5 	bl	10af80 <sys_mbox_set_invalid>
#endif
  conn->state        = NETCONN_NONE;
  10d7e8:	e51b300c 	ldr	r3, [fp, #-12]
  10d7ec:	e3a02000 	mov	r2, #0
  10d7f0:	e5832004 	str	r2, [r3, #4]
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  10d7f4:	e51b300c 	ldr	r3, [fp, #-12]
  10d7f8:	e3e02000 	mvn	r2, #0
  10d7fc:	e583201c 	str	r2, [r3, #28]
#endif /* LWIP_SOCKET */
  conn->callback     = callback;
  10d800:	e51b300c 	ldr	r3, [fp, #-12]
  10d804:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  10d808:	e583203c 	str	r2, [r3, #60]	; 0x3c
#if LWIP_TCP
  conn->current_msg  = NULL;
  10d80c:	e51b300c 	ldr	r3, [fp, #-12]
  10d810:	e3a02000 	mov	r2, #0
  10d814:	e5832038 	str	r2, [r3, #56]	; 0x38
  conn->write_offset = 0;
  10d818:	e51b300c 	ldr	r3, [fp, #-12]
  10d81c:	e3a02000 	mov	r2, #0
  10d820:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif /* LWIP_TCP */
#if LWIP_SO_SNDTIMEO
  conn->send_timeout = 0;
  10d824:	e51b300c 	ldr	r3, [fp, #-12]
  10d828:	e3a02000 	mov	r2, #0
  10d82c:	e5832020 	str	r2, [r3, #32]
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
  conn->recv_timeout = 0;
  10d830:	e51b300c 	ldr	r3, [fp, #-12]
  10d834:	e3a02000 	mov	r2, #0
  10d838:	e5832024 	str	r2, [r3, #36]	; 0x24
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
  10d83c:	e51b300c 	ldr	r3, [fp, #-12]
  10d840:	e3a02602 	mov	r2, #2097152	; 0x200000
  10d844:	e5832028 	str	r2, [r3, #40]	; 0x28
  conn->recv_avail   = 0;
  10d848:	e51b300c 	ldr	r3, [fp, #-12]
  10d84c:	e3a02000 	mov	r2, #0
  10d850:	e583202c 	str	r2, [r3, #44]	; 0x2c
#endif /* LWIP_SO_RCVBUF */
#if LWIP_SO_LINGER
  conn->linger = -1;
#endif /* LWIP_SO_LINGER */
  conn->flags = 0;
  10d854:	e51b300c 	ldr	r3, [fp, #-12]
  10d858:	e3a02000 	mov	r2, #0
  10d85c:	e5c32030 	strb	r2, [r3, #48]	; 0x30
  return conn;
  10d860:	e51b300c 	ldr	r3, [fp, #-12]
  10d864:	ea000004 	b	10d87c <netconn_alloc+0x1c4>
    goto free_and_return;
  10d868:	e320f000 	nop	{0}
free_and_return:
  memp_free(MEMP_NETCONN, conn);
  10d86c:	e51b100c 	ldr	r1, [fp, #-12]
  10d870:	e3a00008 	mov	r0, #8
  10d874:	eb002f00 	bl	11947c <memp_free>
  return NULL;
  10d878:	e3a03000 	mov	r3, #0
}
  10d87c:	e1a00003 	mov	r0, r3
  10d880:	e24bd004 	sub	sp, fp, #4
  10d884:	e8bd8800 	pop	{fp, pc}

0010d888 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  10d888:	e92d4800 	push	{fp, lr}
  10d88c:	e28db004 	add	fp, sp, #4
  10d890:	e24dd008 	sub	sp, sp, #8
  10d894:	e50b0008 	str	r0, [fp, #-8]
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  10d898:	e51b3008 	ldr	r3, [fp, #-8]
  10d89c:	e5933008 	ldr	r3, [r3, #8]
  10d8a0:	e3530000 	cmp	r3, #0
  10d8a4:	0a000006 	beq	10d8c4 <netconn_free+0x3c>
  10d8a8:	e3060a60 	movw	r0, #27232	; 0x6a60
  10d8ac:	e3400014 	movt	r0, #20
  10d8b0:	ebffd617 	bl	103114 <rt_kprintf>
  10d8b4:	e30012da 	movw	r1, #730	; 0x2da
  10d8b8:	e30608bc 	movw	r0, #26812	; 0x68bc
  10d8bc:	e3400014 	movt	r0, #20
  10d8c0:	ebfff5ed 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
  10d8c4:	e51b3008 	ldr	r3, [fp, #-8]
  10d8c8:	e2833014 	add	r3, r3, #20
  10d8cc:	e1a00003 	mov	r0, r3
  10d8d0:	ebfff5a0 	bl	10af58 <sys_mbox_valid>
  10d8d4:	e1a03000 	mov	r3, r0
  10d8d8:	e3530000 	cmp	r3, #0
  10d8dc:	0a000006 	beq	10d8fc <netconn_free+0x74>
  10d8e0:	e3060a90 	movw	r0, #27280	; 0x6a90
  10d8e4:	e3400014 	movt	r0, #20
  10d8e8:	ebffd609 	bl	103114 <rt_kprintf>
  10d8ec:	e3a01fb7 	mov	r1, #732	; 0x2dc
  10d8f0:	e30608bc 	movw	r0, #26812	; 0x68bc
  10d8f4:	e3400014 	movt	r0, #20
  10d8f8:	ebfff5df 	bl	10b07c <sys_arch_assert>
    !sys_mbox_valid(&conn->recvmbox));
#if LWIP_TCP
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
  10d8fc:	e51b3008 	ldr	r3, [fp, #-8]
  10d900:	e2833018 	add	r3, r3, #24
  10d904:	e1a00003 	mov	r0, r3
  10d908:	ebfff592 	bl	10af58 <sys_mbox_valid>
  10d90c:	e1a03000 	mov	r3, r0
  10d910:	e3530000 	cmp	r3, #0
  10d914:	0a000006 	beq	10d934 <netconn_free+0xac>
  10d918:	e3060acc 	movw	r0, #27340	; 0x6acc
  10d91c:	e3400014 	movt	r0, #20
  10d920:	ebffd5fb 	bl	103114 <rt_kprintf>
  10d924:	e30012df 	movw	r1, #735	; 0x2df
  10d928:	e30608bc 	movw	r0, #26812	; 0x68bc
  10d92c:	e3400014 	movt	r0, #20
  10d930:	ebfff5d1 	bl	10b07c <sys_arch_assert>
    !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */

#if !LWIP_NETCONN_SEM_PER_THREAD
  sys_sem_free(&conn->op_completed);
  10d934:	e51b3008 	ldr	r3, [fp, #-8]
  10d938:	e2833010 	add	r3, r3, #16
  10d93c:	e1a00003 	mov	r0, r3
  10d940:	ebfff366 	bl	10a6e0 <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
  10d944:	e51b3008 	ldr	r3, [fp, #-8]
  10d948:	e2833010 	add	r3, r3, #16
  10d94c:	e1a00003 	mov	r0, r3
  10d950:	ebfff3b5 	bl	10a82c <sys_sem_set_invalid>
#endif

  memp_free(MEMP_NETCONN, conn);
  10d954:	e51b1008 	ldr	r1, [fp, #-8]
  10d958:	e3a00008 	mov	r0, #8
  10d95c:	eb002ec6 	bl	11947c <memp_free>
}
  10d960:	e320f000 	nop	{0}
  10d964:	e24bd004 	sub	sp, fp, #4
  10d968:	e8bd8800 	pop	{fp, pc}

0010d96c <netconn_drain>:
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
  10d96c:	e92d4800 	push	{fp, lr}
  10d970:	e28db004 	add	fp, sp, #4
  10d974:	e24dd018 	sub	sp, sp, #24
  10d978:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
#endif /* LWIP_TCP */

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
  10d97c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d980:	e2833014 	add	r3, r3, #20
  10d984:	e1a00003 	mov	r0, r3
  10d988:	ebfff572 	bl	10af58 <sys_mbox_valid>
  10d98c:	e1a03000 	mov	r3, r0
  10d990:	e3530000 	cmp	r3, #0
  10d994:	0a00002c 	beq	10da4c <netconn_drain+0xe0>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  10d998:	ea00001a 	b	10da08 <netconn_drain+0x9c>
#if LWIP_TCP
      if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) {
  10d99c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d9a0:	e5933000 	ldr	r3, [r3]
  10d9a4:	e20330f0 	and	r3, r3, #240	; 0xf0
  10d9a8:	e3530010 	cmp	r3, #16
  10d9ac:	1a000012 	bne	10d9fc <netconn_drain+0x90>
        if (mem != NULL) {
  10d9b0:	e51b3010 	ldr	r3, [fp, #-16]
  10d9b4:	e3530000 	cmp	r3, #0
  10d9b8:	0a000012 	beq	10da08 <netconn_drain+0x9c>
          p = (struct pbuf*)mem;
  10d9bc:	e51b3010 	ldr	r3, [fp, #-16]
  10d9c0:	e50b3008 	str	r3, [fp, #-8]
          /* pcb might be set to NULL already by err_tcp() */
          if (conn->pcb.tcp != NULL) {
  10d9c4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d9c8:	e5933008 	ldr	r3, [r3, #8]
  10d9cc:	e3530000 	cmp	r3, #0
  10d9d0:	0a000006 	beq	10d9f0 <netconn_drain+0x84>
            tcp_recved(conn->pcb.tcp, p->tot_len);
  10d9d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10d9d8:	e5932008 	ldr	r2, [r3, #8]
  10d9dc:	e51b3008 	ldr	r3, [fp, #-8]
  10d9e0:	e1d330b8 	ldrh	r3, [r3, #8]
  10d9e4:	e1a01003 	mov	r1, r3
  10d9e8:	e1a00002 	mov	r0, r2
  10d9ec:	eb00423c 	bl	11e2e4 <tcp_recved>
          }
          pbuf_free(p);
  10d9f0:	e51b0008 	ldr	r0, [fp, #-8]
  10d9f4:	eb0035ae 	bl	11b0b4 <pbuf_free>
  10d9f8:	ea000002 	b	10da08 <netconn_drain+0x9c>
        }
      } else
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
  10d9fc:	e51b3010 	ldr	r3, [fp, #-16]
  10da00:	e1a00003 	mov	r0, r3
  10da04:	eb0009c9 	bl	110130 <netbuf_delete>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  10da08:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10da0c:	e2833014 	add	r3, r3, #20
  10da10:	e24b2010 	sub	r2, fp, #16
  10da14:	e1a01002 	mov	r1, r2
  10da18:	e1a00003 	mov	r0, r3
  10da1c:	ebfff535 	bl	10aef8 <sys_arch_mbox_tryfetch>
  10da20:	e1a03000 	mov	r3, r0
  10da24:	e3730001 	cmn	r3, #1
  10da28:	1affffdb 	bne	10d99c <netconn_drain+0x30>
      }
    }
    sys_mbox_free(&conn->recvmbox);
  10da2c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10da30:	e2833014 	add	r3, r3, #20
  10da34:	e1a00003 	mov	r0, r3
  10da38:	ebfff488 	bl	10ac60 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
  10da3c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10da40:	e2833014 	add	r3, r3, #20
  10da44:	e1a00003 	mov	r0, r3
  10da48:	ebfff54c 	bl	10af80 <sys_mbox_set_invalid>
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
  10da4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10da50:	e2833018 	add	r3, r3, #24
  10da54:	e1a00003 	mov	r0, r3
  10da58:	ebfff53e 	bl	10af58 <sys_mbox_valid>
  10da5c:	e1a03000 	mov	r3, r0
  10da60:	e3530000 	cmp	r3, #0
  10da64:	0a000027 	beq	10db08 <netconn_drain+0x19c>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  10da68:	ea000015 	b	10dac4 <netconn_drain+0x158>
      if (mem != &netconn_aborted) {
  10da6c:	e51b2010 	ldr	r2, [fp, #-16]
  10da70:	e300357c 	movw	r3, #1404	; 0x57c
  10da74:	e3403015 	movt	r3, #21
  10da78:	e1520003 	cmp	r2, r3
  10da7c:	0a000010 	beq	10dac4 <netconn_drain+0x158>
        struct netconn *newconn = (struct netconn *)mem;
  10da80:	e51b3010 	ldr	r3, [fp, #-16]
  10da84:	e50b300c 	str	r3, [fp, #-12]
        /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
        /* pcb might be set to NULL already by err_tcp() */
        /* drain recvmbox */
        netconn_drain(newconn);
  10da88:	e51b000c 	ldr	r0, [fp, #-12]
  10da8c:	ebffffb6 	bl	10d96c <netconn_drain>
        if (newconn->pcb.tcp != NULL) {
  10da90:	e51b300c 	ldr	r3, [fp, #-12]
  10da94:	e5933008 	ldr	r3, [r3, #8]
  10da98:	e3530000 	cmp	r3, #0
  10da9c:	0a000006 	beq	10dabc <netconn_drain+0x150>
          tcp_abort(newconn->pcb.tcp);
  10daa0:	e51b300c 	ldr	r3, [fp, #-12]
  10daa4:	e5933008 	ldr	r3, [r3, #8]
  10daa8:	e1a00003 	mov	r0, r3
  10daac:	eb00405a 	bl	11dc1c <tcp_abort>
          newconn->pcb.tcp = NULL;
  10dab0:	e51b300c 	ldr	r3, [fp, #-12]
  10dab4:	e3a02000 	mov	r2, #0
  10dab8:	e5832008 	str	r2, [r3, #8]
        }
        netconn_free(newconn);
  10dabc:	e51b000c 	ldr	r0, [fp, #-12]
  10dac0:	ebffff70 	bl	10d888 <netconn_free>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  10dac4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10dac8:	e2833018 	add	r3, r3, #24
  10dacc:	e24b2010 	sub	r2, fp, #16
  10dad0:	e1a01002 	mov	r1, r2
  10dad4:	e1a00003 	mov	r0, r3
  10dad8:	ebfff506 	bl	10aef8 <sys_arch_mbox_tryfetch>
  10dadc:	e1a03000 	mov	r3, r0
  10dae0:	e3730001 	cmn	r3, #1
  10dae4:	1affffe0 	bne	10da6c <netconn_drain+0x100>
      }
    }
    sys_mbox_free(&conn->acceptmbox);
  10dae8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10daec:	e2833018 	add	r3, r3, #24
  10daf0:	e1a00003 	mov	r0, r3
  10daf4:	ebfff459 	bl	10ac60 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
  10daf8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10dafc:	e2833018 	add	r3, r3, #24
  10db00:	e1a00003 	mov	r0, r3
  10db04:	ebfff51d 	bl	10af80 <sys_mbox_set_invalid>
  }
#endif /* LWIP_TCP */
}
  10db08:	e320f000 	nop	{0}
  10db0c:	e24bd004 	sub	sp, fp, #4
  10db10:	e8bd8800 	pop	{fp, pc}

0010db14 <lwip_netconn_do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static err_t
lwip_netconn_do_close_internal(struct netconn *conn  WRITE_DELAYED_PARAM)
{
  10db14:	e92d4800 	push	{fp, lr}
  10db18:	e28db004 	add	fp, sp, #4
  10db1c:	e24dd020 	sub	sp, sp, #32
  10db20:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  10db24:	e1a03001 	mov	r3, r1
  10db28:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
  err_t err;
  u8_t shut, shut_rx, shut_tx, close;
  u8_t close_finished = 0;
  10db2c:	e3a03000 	mov	r3, #0
  10db30:	e54b3007 	strb	r3, [fp, #-7]
  struct tcp_pcb* tpcb;
#if LWIP_SO_LINGER
  u8_t linger_wait_required = 0;
#endif /* LWIP_SO_LINGER */

  LWIP_ASSERT("invalid conn", (conn != NULL));
  10db34:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10db38:	e3530000 	cmp	r3, #0
  10db3c:	1a000006 	bne	10db5c <lwip_netconn_do_close_internal+0x48>
  10db40:	e3060b08 	movw	r0, #27400	; 0x6b08
  10db44:	e3400014 	movt	r0, #20
  10db48:	ebffd571 	bl	103114 <rt_kprintf>
  10db4c:	e300133d 	movw	r1, #829	; 0x33d
  10db50:	e30608bc 	movw	r0, #26812	; 0x68bc
  10db54:	e3400014 	movt	r0, #20
  10db58:	ebfff547 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("this is for tcp netconns only", (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP));
  10db5c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10db60:	e5933000 	ldr	r3, [r3]
  10db64:	e20330f0 	and	r3, r3, #240	; 0xf0
  10db68:	e3530010 	cmp	r3, #16
  10db6c:	0a000006 	beq	10db8c <lwip_netconn_do_close_internal+0x78>
  10db70:	e3060b18 	movw	r0, #27416	; 0x6b18
  10db74:	e3400014 	movt	r0, #20
  10db78:	ebffd565 	bl	103114 <rt_kprintf>
  10db7c:	e300133e 	movw	r1, #830	; 0x33e
  10db80:	e30608bc 	movw	r0, #26812	; 0x68bc
  10db84:	e3400014 	movt	r0, #20
  10db88:	ebfff53b 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  10db8c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10db90:	e5933004 	ldr	r3, [r3, #4]
  10db94:	e3530004 	cmp	r3, #4
  10db98:	0a000006 	beq	10dbb8 <lwip_netconn_do_close_internal+0xa4>
  10db9c:	e3060b38 	movw	r0, #27448	; 0x6b38
  10dba0:	e3400014 	movt	r0, #20
  10dba4:	ebffd55a 	bl	103114 <rt_kprintf>
  10dba8:	e300133f 	movw	r1, #831	; 0x33f
  10dbac:	e30608bc 	movw	r0, #26812	; 0x68bc
  10dbb0:	e3400014 	movt	r0, #20
  10dbb4:	ebfff530 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  10dbb8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10dbbc:	e5933008 	ldr	r3, [r3, #8]
  10dbc0:	e3530000 	cmp	r3, #0
  10dbc4:	1a000006 	bne	10dbe4 <lwip_netconn_do_close_internal+0xd0>
  10dbc8:	e3060b5c 	movw	r0, #27484	; 0x6b5c
  10dbcc:	e3400014 	movt	r0, #20
  10dbd0:	ebffd54f 	bl	103114 <rt_kprintf>
  10dbd4:	e3a01d0d 	mov	r1, #832	; 0x340
  10dbd8:	e30608bc 	movw	r0, #26812	; 0x68bc
  10dbdc:	e3400014 	movt	r0, #20
  10dbe0:	ebfff525 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
  10dbe4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10dbe8:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10dbec:	e3530000 	cmp	r3, #0
  10dbf0:	1a000006 	bne	10dc10 <lwip_netconn_do_close_internal+0xfc>
  10dbf4:	e30609c4 	movw	r0, #27076	; 0x69c4
  10dbf8:	e3400014 	movt	r0, #20
  10dbfc:	ebffd544 	bl	103114 <rt_kprintf>
  10dc00:	e3001341 	movw	r1, #833	; 0x341
  10dc04:	e30608bc 	movw	r0, #26812	; 0x68bc
  10dc08:	e3400014 	movt	r0, #20
  10dc0c:	ebfff51a 	bl	10b07c <sys_arch_assert>

  tpcb = conn->pcb.tcp;
  10dc10:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10dc14:	e5933008 	ldr	r3, [r3, #8]
  10dc18:	e50b3010 	str	r3, [fp, #-16]
  shut = conn->current_msg->msg.sd.shut;
  10dc1c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10dc20:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10dc24:	e5d33008 	ldrb	r3, [r3, #8]
  10dc28:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  shut_rx = shut & NETCONN_SHUT_RD;
  10dc2c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  10dc30:	e2033001 	and	r3, r3, #1
  10dc34:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
  shut_tx = shut & NETCONN_SHUT_WR;
  10dc38:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  10dc3c:	e2033002 	and	r3, r3, #2
  10dc40:	e54b3013 	strb	r3, [fp, #-19]	; 0xffffffed
  /* shutting down both ends is the same as closing
     (also if RD or WR side was shut down before already) */
  if (shut == NETCONN_SHUT_RDWR) {
  10dc44:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  10dc48:	e3530003 	cmp	r3, #3
  10dc4c:	1a000002 	bne	10dc5c <lwip_netconn_do_close_internal+0x148>
    close = 1;
  10dc50:	e3a03001 	mov	r3, #1
  10dc54:	e54b3006 	strb	r3, [fp, #-6]
  10dc58:	ea00001e 	b	10dcd8 <lwip_netconn_do_close_internal+0x1c4>
  } else if (shut_rx &&
  10dc5c:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
  10dc60:	e3530000 	cmp	r3, #0
  10dc64:	0a00000e 	beq	10dca4 <lwip_netconn_do_close_internal+0x190>
             ((tpcb->state == FIN_WAIT_1) ||
  10dc68:	e51b3010 	ldr	r3, [fp, #-16]
  10dc6c:	e5933014 	ldr	r3, [r3, #20]
  } else if (shut_rx &&
  10dc70:	e3530005 	cmp	r3, #5
  10dc74:	0a000007 	beq	10dc98 <lwip_netconn_do_close_internal+0x184>
              (tpcb->state == FIN_WAIT_2) ||
  10dc78:	e51b3010 	ldr	r3, [fp, #-16]
  10dc7c:	e5933014 	ldr	r3, [r3, #20]
             ((tpcb->state == FIN_WAIT_1) ||
  10dc80:	e3530006 	cmp	r3, #6
  10dc84:	0a000003 	beq	10dc98 <lwip_netconn_do_close_internal+0x184>
              (tpcb->state == CLOSING))) {
  10dc88:	e51b3010 	ldr	r3, [fp, #-16]
  10dc8c:	e5933014 	ldr	r3, [r3, #20]
              (tpcb->state == FIN_WAIT_2) ||
  10dc90:	e3530008 	cmp	r3, #8
  10dc94:	1a000002 	bne	10dca4 <lwip_netconn_do_close_internal+0x190>
    close = 1;
  10dc98:	e3a03001 	mov	r3, #1
  10dc9c:	e54b3006 	strb	r3, [fp, #-6]
  10dca0:	ea00000c 	b	10dcd8 <lwip_netconn_do_close_internal+0x1c4>
  } else if (shut_tx && ((tpcb->flags & TF_RXCLOSED) != 0)) {
  10dca4:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
  10dca8:	e3530000 	cmp	r3, #0
  10dcac:	0a000007 	beq	10dcd0 <lwip_netconn_do_close_internal+0x1bc>
  10dcb0:	e51b3010 	ldr	r3, [fp, #-16]
  10dcb4:	e5d3301e 	ldrb	r3, [r3, #30]
  10dcb8:	e2033010 	and	r3, r3, #16
  10dcbc:	e3530000 	cmp	r3, #0
  10dcc0:	0a000002 	beq	10dcd0 <lwip_netconn_do_close_internal+0x1bc>
    close = 1;
  10dcc4:	e3a03001 	mov	r3, #1
  10dcc8:	e54b3006 	strb	r3, [fp, #-6]
  10dccc:	ea000001 	b	10dcd8 <lwip_netconn_do_close_internal+0x1c4>
  } else {
    close = 0;
  10dcd0:	e3a03000 	mov	r3, #0
  10dcd4:	e54b3006 	strb	r3, [fp, #-6]
  }

  /* Set back some callback pointers */
  if (close) {
  10dcd8:	e55b3006 	ldrb	r3, [fp, #-6]
  10dcdc:	e3530000 	cmp	r3, #0
  10dce0:	0a000002 	beq	10dcf0 <lwip_netconn_do_close_internal+0x1dc>
    tcp_arg(tpcb, NULL);
  10dce4:	e3a01000 	mov	r1, #0
  10dce8:	e51b0010 	ldr	r0, [fp, #-16]
  10dcec:	eb00481d 	bl	11fd68 <tcp_arg>
  }
  if (tpcb->state == LISTEN) {
  10dcf0:	e51b3010 	ldr	r3, [fp, #-16]
  10dcf4:	e5933014 	ldr	r3, [r3, #20]
  10dcf8:	e3530001 	cmp	r3, #1
  10dcfc:	1a000003 	bne	10dd10 <lwip_netconn_do_close_internal+0x1fc>
    tcp_accept(tpcb, NULL);
  10dd00:	e3a01000 	mov	r1, #0
  10dd04:	e51b0010 	ldr	r0, [fp, #-16]
  10dd08:	eb004870 	bl	11fed0 <tcp_accept>
  10dd0c:	ea000018 	b	10dd74 <lwip_netconn_do_close_internal+0x260>
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
  10dd10:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
  10dd14:	e3530000 	cmp	r3, #0
  10dd18:	0a000005 	beq	10dd34 <lwip_netconn_do_close_internal+0x220>
      tcp_recv(tpcb, NULL);
  10dd1c:	e3a01000 	mov	r1, #0
  10dd20:	e51b0010 	ldr	r0, [fp, #-16]
  10dd24:	eb00481e 	bl	11fda4 <tcp_recv>
      tcp_accept(tpcb, NULL);
  10dd28:	e3a01000 	mov	r1, #0
  10dd2c:	e51b0010 	ldr	r0, [fp, #-16]
  10dd30:	eb004866 	bl	11fed0 <tcp_accept>
    }
    if (shut_tx) {
  10dd34:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
  10dd38:	e3530000 	cmp	r3, #0
  10dd3c:	0a000002 	beq	10dd4c <lwip_netconn_do_close_internal+0x238>
      tcp_sent(tpcb, NULL);
  10dd40:	e3a01000 	mov	r1, #0
  10dd44:	e51b0010 	ldr	r0, [fp, #-16]
  10dd48:	eb00482e 	bl	11fe08 <tcp_sent>
    }
    if (close) {
  10dd4c:	e55b3006 	ldrb	r3, [fp, #-6]
  10dd50:	e3530000 	cmp	r3, #0
  10dd54:	0a000006 	beq	10dd74 <lwip_netconn_do_close_internal+0x260>
      tcp_poll(tpcb, NULL, 0);
  10dd58:	e3a02000 	mov	r2, #0
  10dd5c:	e3a01000 	mov	r1, #0
  10dd60:	e51b0010 	ldr	r0, [fp, #-16]
  10dd64:	eb00486e 	bl	11ff24 <tcp_poll>
      tcp_err(tpcb, NULL);
  10dd68:	e3a01000 	mov	r1, #0
  10dd6c:	e51b0010 	ldr	r0, [fp, #-16]
  10dd70:	eb00483d 	bl	11fe6c <tcp_err>
    }
  }
  /* Try to close the connection */
  if (close) {
  10dd74:	e55b3006 	ldrb	r3, [fp, #-6]
  10dd78:	e3530000 	cmp	r3, #0
  10dd7c:	0a000004 	beq	10dd94 <lwip_netconn_do_close_internal+0x280>
      }
    }
    if ((err == ERR_OK) && (tpcb != NULL))
#endif /* LWIP_SO_LINGER */
    {
      err = tcp_close(tpcb);
  10dd80:	e51b0010 	ldr	r0, [fp, #-16]
  10dd84:	eb003eb0 	bl	11d84c <tcp_close>
  10dd88:	e1a03000 	mov	r3, r0
  10dd8c:	e54b3005 	strb	r3, [fp, #-5]
  10dd90:	ea000006 	b	10ddb0 <lwip_netconn_do_close_internal+0x29c>
    }
  } else {
    err = tcp_shutdown(tpcb, shut_rx, shut_tx);
  10dd94:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
  10dd98:	e55b2013 	ldrb	r2, [fp, #-19]	; 0xffffffed
  10dd9c:	e1a01003 	mov	r1, r3
  10dda0:	e51b0010 	ldr	r0, [fp, #-16]
  10dda4:	eb003ebd 	bl	11d8a0 <tcp_shutdown>
  10dda8:	e1a03000 	mov	r3, r0
  10ddac:	e54b3005 	strb	r3, [fp, #-5]
  }
  if (err == ERR_OK) {
  10ddb0:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10ddb4:	e3530000 	cmp	r3, #0
  10ddb8:	1a000002 	bne	10ddc8 <lwip_netconn_do_close_internal+0x2b4>
    close_finished = 1;
  10ddbc:	e3a03001 	mov	r3, #1
  10ddc0:	e54b3007 	strb	r3, [fp, #-7]
  10ddc4:	ea000021 	b	10de50 <lwip_netconn_do_close_internal+0x33c>
      close_finished = 0;
      err = ERR_INPROGRESS;
    }
#endif /* LWIP_SO_LINGER */
  } else {
    if (err == ERR_MEM) {
  10ddc8:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10ddcc:	e3730001 	cmn	r3, #1
  10ddd0:	1a00001c 	bne	10de48 <lwip_netconn_do_close_internal+0x334>
         nonblocking netconns, we have to wait since no standard socket application
         is prepared for close failing because of resource shortage.
         Check the timeout: this is kind of an lwip addition to the standard sockets:
         we wait for some time when failing to allocate a segment for the FIN */
#if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
      s32_t close_timeout = LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT;
  10ddd4:	e3043e20 	movw	r3, #20000	; 0x4e20
  10ddd8:	e50b300c 	str	r3, [fp, #-12]
#if LWIP_SO_SNDTIMEO
      if (conn->send_timeout > 0) {
  10dddc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10dde0:	e5933020 	ldr	r3, [r3, #32]
  10dde4:	e3530000 	cmp	r3, #0
  10dde8:	da000002 	ble	10ddf8 <lwip_netconn_do_close_internal+0x2e4>
        close_timeout = conn->send_timeout;
  10ddec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10ddf0:	e5933020 	ldr	r3, [r3, #32]
  10ddf4:	e50b300c 	str	r3, [fp, #-12]
      if (conn->linger >= 0) {
        /* use linger timeout (seconds) */
        close_timeout = conn->linger * 1000U;
      }
#endif
      if ((s32_t)(sys_now() - conn->current_msg->msg.sd.time_started) >= close_timeout) {
  10ddf8:	ebfff4b8 	bl	10b0e0 <sys_now>
  10ddfc:	e1a02000 	mov	r2, r0
  10de00:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10de04:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10de08:	e593300c 	ldr	r3, [r3, #12]
  10de0c:	e0423003 	sub	r3, r2, r3
  10de10:	e1a02003 	mov	r2, r3
  10de14:	e51b300c 	ldr	r3, [fp, #-12]
  10de18:	e1530002 	cmp	r3, r2
  10de1c:	ca00000b 	bgt	10de50 <lwip_netconn_do_close_internal+0x33c>
#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
      if (conn->current_msg->msg.sd.polls_left == 0) {
#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
        close_finished = 1;
  10de20:	e3a03001 	mov	r3, #1
  10de24:	e54b3007 	strb	r3, [fp, #-7]
        if (close) {
  10de28:	e55b3006 	ldrb	r3, [fp, #-6]
  10de2c:	e3530000 	cmp	r3, #0
  10de30:	0a000006 	beq	10de50 <lwip_netconn_do_close_internal+0x33c>
          /* in this case, we want to RST the connection */
          tcp_abort(tpcb);
  10de34:	e51b0010 	ldr	r0, [fp, #-16]
  10de38:	eb003f77 	bl	11dc1c <tcp_abort>
          err = ERR_OK;
  10de3c:	e3a03000 	mov	r3, #0
  10de40:	e54b3005 	strb	r3, [fp, #-5]
  10de44:	ea000001 	b	10de50 <lwip_netconn_do_close_internal+0x33c>
        }
      }
    } else {
      /* Closing failed for a non-memory error: give up */
      close_finished = 1;
  10de48:	e3a03001 	mov	r3, #1
  10de4c:	e54b3007 	strb	r3, [fp, #-7]
    }
  }
  if (close_finished) {
  10de50:	e55b3007 	ldrb	r3, [fp, #-7]
  10de54:	e3530000 	cmp	r3, #0
  10de58:	0a00004e 	beq	10df98 <lwip_netconn_do_close_internal+0x484>
    /* Closing done (succeeded, non-memory error, nonblocking error or timeout) */
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
  10de5c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10de60:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10de64:	e5933000 	ldr	r3, [r3]
  10de68:	e2833010 	add	r3, r3, #16
  10de6c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    conn->current_msg->err = err;
  10de70:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10de74:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10de78:	e55b2005 	ldrb	r2, [fp, #-5]
  10de7c:	e5c32004 	strb	r2, [r3, #4]
    conn->current_msg = NULL;
  10de80:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10de84:	e3a02000 	mov	r2, #0
  10de88:	e5832038 	str	r2, [r3, #56]	; 0x38
    conn->state = NETCONN_NONE;
  10de8c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10de90:	e3a02000 	mov	r2, #0
  10de94:	e5832004 	str	r2, [r3, #4]
    if (err == ERR_OK) {
  10de98:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10de9c:	e3530000 	cmp	r3, #0
  10dea0:	1a000029 	bne	10df4c <lwip_netconn_do_close_internal+0x438>
      if (close) {
  10dea4:	e55b3006 	ldrb	r3, [fp, #-6]
  10dea8:	e3530000 	cmp	r3, #0
  10deac:	0a00000c 	beq	10dee4 <lwip_netconn_do_close_internal+0x3d0>
        /* Set back some callback pointers as conn is going away */
        conn->pcb.tcp = NULL;
  10deb0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10deb4:	e3a02000 	mov	r2, #0
  10deb8:	e5832008 	str	r2, [r3, #8]
        /* Trigger select() in socket layer. Make sure everybody notices activity
         on the connection, error first! */
        API_EVENT(conn, NETCONN_EVT_ERROR, 0);
  10debc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10dec0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10dec4:	e3530000 	cmp	r3, #0
  10dec8:	0a000005 	beq	10dee4 <lwip_netconn_do_close_internal+0x3d0>
  10decc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10ded0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10ded4:	e3a02000 	mov	r2, #0
  10ded8:	e3a01004 	mov	r1, #4
  10dedc:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10dee0:	e12fff33 	blx	r3
      }
      if (shut_rx) {
  10dee4:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
  10dee8:	e3530000 	cmp	r3, #0
  10deec:	0a000009 	beq	10df18 <lwip_netconn_do_close_internal+0x404>
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  10def0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10def4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10def8:	e3530000 	cmp	r3, #0
  10defc:	0a000005 	beq	10df18 <lwip_netconn_do_close_internal+0x404>
  10df00:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10df04:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10df08:	e3a02000 	mov	r2, #0
  10df0c:	e3a01000 	mov	r1, #0
  10df10:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10df14:	e12fff33 	blx	r3
      }
      if (shut_tx) {
  10df18:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
  10df1c:	e3530000 	cmp	r3, #0
  10df20:	0a000009 	beq	10df4c <lwip_netconn_do_close_internal+0x438>
        API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  10df24:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10df28:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10df2c:	e3530000 	cmp	r3, #0
  10df30:	0a000005 	beq	10df4c <lwip_netconn_do_close_internal+0x438>
  10df34:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10df38:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10df3c:	e3a02000 	mov	r2, #0
  10df40:	e3a01002 	mov	r1, #2
  10df44:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10df48:	e12fff33 	blx	r3
      }
    }
    NETCONN_SET_SAFE_ERR(conn, err);
  10df4c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10df50:	e3530000 	cmp	r3, #0
  10df54:	0a000008 	beq	10df7c <lwip_netconn_do_close_internal+0x468>
  10df58:	ebffd0b7 	bl	10223c <rt_enter_critical>
  10df5c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10df60:	e1d330dc 	ldrsb	r3, [r3, #12]
  10df64:	e373000c 	cmn	r3, #12
  10df68:	ba000002 	blt	10df78 <lwip_netconn_do_close_internal+0x464>
  10df6c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10df70:	e55b2005 	ldrb	r2, [fp, #-5]
  10df74:	e5c3200c 	strb	r2, [r3, #12]
  10df78:	ebffd0b5 	bl	102254 <rt_exit_critical>
#if LWIP_TCPIP_CORE_LOCKING
    if (delayed)
  10df7c:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  10df80:	e3530000 	cmp	r3, #0
  10df84:	0a000001 	beq	10df90 <lwip_netconn_do_close_internal+0x47c>
#endif
    {
      /* wake up the application task */
      sys_sem_signal(op_completed_sem);
  10df88:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  10df8c:	ebfff1de 	bl	10a70c <sys_sem_signal>
    }
    return ERR_OK;
  10df90:	e3a03000 	mov	r3, #0
  10df94:	ea00002b 	b	10e048 <lwip_netconn_do_close_internal+0x534>
  }
  if (!close_finished) {
  10df98:	e55b3007 	ldrb	r3, [fp, #-7]
  10df9c:	e3530000 	cmp	r3, #0
  10dfa0:	1a00001d 	bne	10e01c <lwip_netconn_do_close_internal+0x508>
    /* Closing failed and we want to wait: restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (tpcb->state != LISTEN));
  10dfa4:	e51b3010 	ldr	r3, [fp, #-16]
  10dfa8:	e5933014 	ldr	r3, [r3, #20]
  10dfac:	e3530001 	cmp	r3, #1
  10dfb0:	1a000006 	bne	10dfd0 <lwip_netconn_do_close_internal+0x4bc>
  10dfb4:	e3060b70 	movw	r0, #27504	; 0x6b70
  10dfb8:	e3400014 	movt	r0, #20
  10dfbc:	ebffd454 	bl	103114 <rt_kprintf>
  10dfc0:	e30013dd 	movw	r1, #989	; 0x3dd
  10dfc4:	e30608bc 	movw	r0, #26812	; 0x68bc
  10dfc8:	e3400014 	movt	r0, #20
  10dfcc:	ebfff42a 	bl	10b07c <sys_arch_assert>
    if (shut_tx) {
  10dfd0:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
  10dfd4:	e3530000 	cmp	r3, #0
  10dfd8:	0a000003 	beq	10dfec <lwip_netconn_do_close_internal+0x4d8>
      tcp_sent(tpcb, sent_tcp);
  10dfdc:	e30c1d5c 	movw	r1, #52572	; 0xcd5c
  10dfe0:	e3401010 	movt	r1, #16
  10dfe4:	e51b0010 	ldr	r0, [fp, #-16]
  10dfe8:	eb004786 	bl	11fe08 <tcp_sent>
    }
    /* when waiting for close, set up poll interval to 500ms */
    tcp_poll(tpcb, poll_tcp, 1);
  10dfec:	e3a02001 	mov	r2, #1
  10dff0:	e30c1c40 	movw	r1, #52288	; 0xcc40
  10dff4:	e3401010 	movt	r1, #16
  10dff8:	e51b0010 	ldr	r0, [fp, #-16]
  10dffc:	eb0047c8 	bl	11ff24 <tcp_poll>
    tcp_err(tpcb, err_tcp);
  10e000:	e30c1e78 	movw	r1, #52856	; 0xce78
  10e004:	e3401010 	movt	r1, #16
  10e008:	e51b0010 	ldr	r0, [fp, #-16]
  10e00c:	eb004796 	bl	11fe6c <tcp_err>
    tcp_arg(tpcb, conn);
  10e010:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  10e014:	e51b0010 	ldr	r0, [fp, #-16]
  10e018:	eb004752 	bl	11fd68 <tcp_arg>
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
  LWIP_ASSERT("err != ERR_OK", err != ERR_OK);
  10e01c:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10e020:	e3530000 	cmp	r3, #0
  10e024:	1a000006 	bne	10e044 <lwip_netconn_do_close_internal+0x530>
  10e028:	e3060b94 	movw	r0, #27540	; 0x6b94
  10e02c:	e3400014 	movt	r0, #20
  10e030:	ebffd437 	bl	103114 <rt_kprintf>
  10e034:	e30013e9 	movw	r1, #1001	; 0x3e9
  10e038:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e03c:	e3400014 	movt	r0, #20
  10e040:	ebfff40d 	bl	10b07c <sys_arch_assert>
  return err;
  10e044:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  10e048:	e1a00003 	mov	r0, r3
  10e04c:	e24bd004 	sub	sp, fp, #4
  10e050:	e8bd8800 	pop	{fp, pc}

0010e054 <lwip_netconn_do_delconn>:
 *
 * @param m the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_delconn(void *m)
{
  10e054:	e92d4800 	push	{fp, lr}
  10e058:	e28db004 	add	fp, sp, #4
  10e05c:	e24dd010 	sub	sp, sp, #16
  10e060:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10e064:	e51b3010 	ldr	r3, [fp, #-16]
  10e068:	e50b3008 	str	r3, [fp, #-8]

  enum netconn_state state = msg->conn->state;
  10e06c:	e51b3008 	ldr	r3, [fp, #-8]
  10e070:	e5933000 	ldr	r3, [r3]
  10e074:	e5933004 	ldr	r3, [r3, #4]
  10e078:	e50b300c 	str	r3, [fp, #-12]
  LWIP_ASSERT("netconn state error", /* this only happens for TCP netconns */
  10e07c:	e51b300c 	ldr	r3, [fp, #-12]
  10e080:	e3530000 	cmp	r3, #0
  10e084:	0a00000c 	beq	10e0bc <lwip_netconn_do_delconn+0x68>
  10e088:	e51b3008 	ldr	r3, [fp, #-8]
  10e08c:	e5933000 	ldr	r3, [r3]
  10e090:	e5933000 	ldr	r3, [r3]
  10e094:	e20330f0 	and	r3, r3, #240	; 0xf0
  10e098:	e3530010 	cmp	r3, #16
  10e09c:	0a000006 	beq	10e0bc <lwip_netconn_do_delconn+0x68>
  10e0a0:	e3060ba4 	movw	r0, #27556	; 0x6ba4
  10e0a4:	e3400014 	movt	r0, #20
  10e0a8:	ebffd419 	bl	103114 <rt_kprintf>
  10e0ac:	e30013fb 	movw	r1, #1019	; 0x3fb
  10e0b0:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e0b4:	e3400014 	movt	r0, #20
  10e0b8:	ebfff3ef 	bl	10b07c <sys_arch_assert>
      NETCONN_SET_SAFE_ERR(msg->conn, ERR_CLSD);
      sys_sem_signal(op_completed_sem);
    }
  }
#else /* LWIP_NETCONN_FULLDUPLEX */
  if (((state != NETCONN_NONE) &&
  10e0bc:	e51b300c 	ldr	r3, [fp, #-12]
  10e0c0:	e3530000 	cmp	r3, #0
  10e0c4:	0a000005 	beq	10e0e0 <lwip_netconn_do_delconn+0x8c>
  10e0c8:	e51b300c 	ldr	r3, [fp, #-12]
  10e0cc:	e3530002 	cmp	r3, #2
  10e0d0:	0a000002 	beq	10e0e0 <lwip_netconn_do_delconn+0x8c>
       (state != NETCONN_LISTEN) &&
  10e0d4:	e51b300c 	ldr	r3, [fp, #-12]
  10e0d8:	e3530003 	cmp	r3, #3
  10e0dc:	1a000008 	bne	10e104 <lwip_netconn_do_delconn+0xb0>
       (state != NETCONN_CONNECT)) ||
  10e0e0:	e51b300c 	ldr	r3, [fp, #-12]
  10e0e4:	e3530003 	cmp	r3, #3
  10e0e8:	1a000009 	bne	10e114 <lwip_netconn_do_delconn+0xc0>
      ((state == NETCONN_CONNECT) && !IN_NONBLOCKING_CONNECT(msg->conn))) {
  10e0ec:	e51b3008 	ldr	r3, [fp, #-8]
  10e0f0:	e5933000 	ldr	r3, [r3]
  10e0f4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10e0f8:	e2033004 	and	r3, r3, #4
  10e0fc:	e3530000 	cmp	r3, #0
  10e100:	1a000003 	bne	10e114 <lwip_netconn_do_delconn+0xc0>
    /* This means either a blocking write or blocking connect is running
       (nonblocking write returns and sets state to NONE) */
    msg->err = ERR_INPROGRESS;
  10e104:	e51b3008 	ldr	r3, [fp, #-8]
  10e108:	e3e02004 	mvn	r2, #4
  10e10c:	e5c32004 	strb	r2, [r3, #4]
  10e110:	ea00009e 	b	10e390 <lwip_netconn_do_delconn+0x33c>
  } else
#endif /* LWIP_NETCONN_FULLDUPLEX */
  {
    LWIP_ASSERT("blocking connect in progress",
  10e114:	e51b300c 	ldr	r3, [fp, #-12]
  10e118:	e3530003 	cmp	r3, #3
  10e11c:	1a00000c 	bne	10e154 <lwip_netconn_do_delconn+0x100>
  10e120:	e51b3008 	ldr	r3, [fp, #-8]
  10e124:	e5933000 	ldr	r3, [r3]
  10e128:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10e12c:	e2033004 	and	r3, r3, #4
  10e130:	e3530000 	cmp	r3, #0
  10e134:	1a000006 	bne	10e154 <lwip_netconn_do_delconn+0x100>
  10e138:	e3060bb8 	movw	r0, #27576	; 0x6bb8
  10e13c:	e3400014 	movt	r0, #20
  10e140:	ebffd3f3 	bl	103114 <rt_kprintf>
  10e144:	e3001419 	movw	r1, #1049	; 0x419
  10e148:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e14c:	e3400014 	movt	r0, #20
  10e150:	ebfff3c9 	bl	10b07c <sys_arch_assert>
      (state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
    msg->err = ERR_OK;
  10e154:	e51b3008 	ldr	r3, [fp, #-8]
  10e158:	e3a02000 	mov	r2, #0
  10e15c:	e5c32004 	strb	r2, [r3, #4]
    /* Drain and delete mboxes */
    netconn_drain(msg->conn);
  10e160:	e51b3008 	ldr	r3, [fp, #-8]
  10e164:	e5933000 	ldr	r3, [r3]
  10e168:	e1a00003 	mov	r0, r3
  10e16c:	ebfffdfe 	bl	10d96c <netconn_drain>

    if (msg->conn->pcb.tcp != NULL) {
  10e170:	e51b3008 	ldr	r3, [fp, #-8]
  10e174:	e5933000 	ldr	r3, [r3]
  10e178:	e5933008 	ldr	r3, [r3, #8]
  10e17c:	e3530000 	cmp	r3, #0
  10e180:	0a000068 	beq	10e328 <lwip_netconn_do_delconn+0x2d4>

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  10e184:	e51b3008 	ldr	r3, [fp, #-8]
  10e188:	e5933000 	ldr	r3, [r3]
  10e18c:	e5933000 	ldr	r3, [r3]
  10e190:	e20330f0 	and	r3, r3, #240	; 0xf0
  10e194:	e3530020 	cmp	r3, #32
  10e198:	0a00000a 	beq	10e1c8 <lwip_netconn_do_delconn+0x174>
  10e19c:	e3530040 	cmp	r3, #64	; 0x40
  10e1a0:	0a000002 	beq	10e1b0 <lwip_netconn_do_delconn+0x15c>
  10e1a4:	e3530010 	cmp	r3, #16
  10e1a8:	0a000011 	beq	10e1f4 <lwip_netconn_do_delconn+0x1a0>
        /* API_EVENT is called inside lwip_netconn_do_close_internal, before releasing
           the application thread, so we can return at this point! */
        return;
#endif /* LWIP_TCP */
      default:
        break;
  10e1ac:	ea000059 	b	10e318 <lwip_netconn_do_delconn+0x2c4>
        raw_remove(msg->conn->pcb.raw);
  10e1b0:	e51b3008 	ldr	r3, [fp, #-8]
  10e1b4:	e5933000 	ldr	r3, [r3]
  10e1b8:	e5933008 	ldr	r3, [r3, #8]
  10e1bc:	e1a00003 	mov	r0, r3
  10e1c0:	eb0039d7 	bl	11c924 <raw_remove>
        break;
  10e1c4:	ea000053 	b	10e318 <lwip_netconn_do_delconn+0x2c4>
        msg->conn->pcb.udp->recv_arg = NULL;
  10e1c8:	e51b3008 	ldr	r3, [fp, #-8]
  10e1cc:	e5933000 	ldr	r3, [r3]
  10e1d0:	e5933008 	ldr	r3, [r3, #8]
  10e1d4:	e3a02000 	mov	r2, #0
  10e1d8:	e5832024 	str	r2, [r3, #36]	; 0x24
        udp_remove(msg->conn->pcb.udp);
  10e1dc:	e51b3008 	ldr	r3, [fp, #-8]
  10e1e0:	e5933000 	ldr	r3, [r3]
  10e1e4:	e5933008 	ldr	r3, [r3, #8]
  10e1e8:	e1a00003 	mov	r0, r3
  10e1ec:	eb006a81 	bl	128bf8 <udp_remove>
        break;
  10e1f0:	ea000048 	b	10e318 <lwip_netconn_do_delconn+0x2c4>
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
  10e1f4:	e51b3008 	ldr	r3, [fp, #-8]
  10e1f8:	e5933000 	ldr	r3, [r3]
  10e1fc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10e200:	e3530000 	cmp	r3, #0
  10e204:	1a000004 	bne	10e21c <lwip_netconn_do_delconn+0x1c8>
  10e208:	e51b3008 	ldr	r3, [fp, #-8]
  10e20c:	e5933000 	ldr	r3, [r3]
  10e210:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  10e214:	e3530000 	cmp	r3, #0
  10e218:	0a000006 	beq	10e238 <lwip_netconn_do_delconn+0x1e4>
  10e21c:	e3060bd8 	movw	r0, #27608	; 0x6bd8
  10e220:	e3400014 	movt	r0, #20
  10e224:	ebffd3ba 	bl	103114 <rt_kprintf>
  10e228:	e300142f 	movw	r1, #1071	; 0x42f
  10e22c:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e230:	e3400014 	movt	r0, #20
  10e234:	ebfff390 	bl	10b07c <sys_arch_assert>
        msg->conn->state = NETCONN_CLOSE;
  10e238:	e51b3008 	ldr	r3, [fp, #-8]
  10e23c:	e5933000 	ldr	r3, [r3]
  10e240:	e3a02004 	mov	r2, #4
  10e244:	e5832004 	str	r2, [r3, #4]
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
  10e248:	e51b3008 	ldr	r3, [fp, #-8]
  10e24c:	e3a02003 	mov	r2, #3
  10e250:	e5c32008 	strb	r2, [r3, #8]
        msg->conn->current_msg = msg;
  10e254:	e51b3008 	ldr	r3, [fp, #-8]
  10e258:	e5933000 	ldr	r3, [r3]
  10e25c:	e51b2008 	ldr	r2, [fp, #-8]
  10e260:	e5832038 	str	r2, [r3, #56]	; 0x38
        if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
  10e264:	e51b3008 	ldr	r3, [fp, #-8]
  10e268:	e5933000 	ldr	r3, [r3]
  10e26c:	e3a01000 	mov	r1, #0
  10e270:	e1a00003 	mov	r0, r3
  10e274:	ebfffe26 	bl	10db14 <lwip_netconn_do_close_internal>
  10e278:	e1a03000 	mov	r3, r0
  10e27c:	e3530000 	cmp	r3, #0
  10e280:	0a00005b 	beq	10e3f4 <lwip_netconn_do_delconn+0x3a0>
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
  10e284:	e51b3008 	ldr	r3, [fp, #-8]
  10e288:	e5933000 	ldr	r3, [r3]
  10e28c:	e5933004 	ldr	r3, [r3, #4]
  10e290:	e3530004 	cmp	r3, #4
  10e294:	0a000006 	beq	10e2b4 <lwip_netconn_do_delconn+0x260>
  10e298:	e3060bf4 	movw	r0, #27636	; 0x6bf4
  10e29c:	e3400014 	movt	r0, #20
  10e2a0:	ebffd39b 	bl	103114 <rt_kprintf>
  10e2a4:	e3001435 	movw	r1, #1077	; 0x435
  10e2a8:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e2ac:	e3400014 	movt	r0, #20
  10e2b0:	ebfff371 	bl	10b07c <sys_arch_assert>
          UNLOCK_TCPIP_CORE();
  10e2b4:	e30005e4 	movw	r0, #1508	; 0x5e4
  10e2b8:	e3400015 	movt	r0, #21
  10e2bc:	ebfff199 	bl	10a928 <sys_mutex_unlock>
          sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
  10e2c0:	e51b3008 	ldr	r3, [fp, #-8]
  10e2c4:	e5933000 	ldr	r3, [r3]
  10e2c8:	e2833010 	add	r3, r3, #16
  10e2cc:	e3a01000 	mov	r1, #0
  10e2d0:	e1a00003 	mov	r0, r3
  10e2d4:	ebfff117 	bl	10a738 <sys_arch_sem_wait>
          LOCK_TCPIP_CORE();
  10e2d8:	e30005e4 	movw	r0, #1508	; 0x5e4
  10e2dc:	e3400015 	movt	r0, #21
  10e2e0:	ebfff184 	bl	10a8f8 <sys_mutex_lock>
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
  10e2e4:	e51b3008 	ldr	r3, [fp, #-8]
  10e2e8:	e5933000 	ldr	r3, [r3]
  10e2ec:	e5933004 	ldr	r3, [r3, #4]
  10e2f0:	e3530000 	cmp	r3, #0
  10e2f4:	0a00003e 	beq	10e3f4 <lwip_netconn_do_delconn+0x3a0>
  10e2f8:	e3060bf4 	movw	r0, #27636	; 0x6bf4
  10e2fc:	e3400014 	movt	r0, #20
  10e300:	ebffd383 	bl	103114 <rt_kprintf>
  10e304:	e3001439 	movw	r1, #1081	; 0x439
  10e308:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e30c:	e3400014 	movt	r0, #20
  10e310:	ebfff359 	bl	10b07c <sys_arch_assert>
        return;
  10e314:	ea000036 	b	10e3f4 <lwip_netconn_do_delconn+0x3a0>
      }
      msg->conn->pcb.tcp = NULL;
  10e318:	e51b3008 	ldr	r3, [fp, #-8]
  10e31c:	e5933000 	ldr	r3, [r3]
  10e320:	e3a02000 	mov	r2, #0
  10e324:	e5832008 	str	r2, [r3, #8]
    }
    /* tcp netconns don't come here! */

    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  10e328:	e51b3008 	ldr	r3, [fp, #-8]
  10e32c:	e5933000 	ldr	r3, [r3]
  10e330:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10e334:	e3530000 	cmp	r3, #0
  10e338:	0a000007 	beq	10e35c <lwip_netconn_do_delconn+0x308>
  10e33c:	e51b3008 	ldr	r3, [fp, #-8]
  10e340:	e5933000 	ldr	r3, [r3]
  10e344:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10e348:	e51b2008 	ldr	r2, [fp, #-8]
  10e34c:	e5920000 	ldr	r0, [r2]
  10e350:	e3a02000 	mov	r2, #0
  10e354:	e3a01000 	mov	r1, #0
  10e358:	e12fff33 	blx	r3
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  10e35c:	e51b3008 	ldr	r3, [fp, #-8]
  10e360:	e5933000 	ldr	r3, [r3]
  10e364:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10e368:	e3530000 	cmp	r3, #0
  10e36c:	0a000007 	beq	10e390 <lwip_netconn_do_delconn+0x33c>
  10e370:	e51b3008 	ldr	r3, [fp, #-8]
  10e374:	e5933000 	ldr	r3, [r3]
  10e378:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10e37c:	e51b2008 	ldr	r2, [fp, #-8]
  10e380:	e5920000 	ldr	r0, [r2]
  10e384:	e3a02000 	mov	r2, #0
  10e388:	e3a01002 	mov	r1, #2
  10e38c:	e12fff33 	blx	r3
  }
  if (sys_sem_valid(LWIP_API_MSG_SEM(msg))) {
  10e390:	e51b3008 	ldr	r3, [fp, #-8]
  10e394:	e5933000 	ldr	r3, [r3]
  10e398:	e2833010 	add	r3, r3, #16
  10e39c:	e1a00003 	mov	r0, r3
  10e3a0:	ebfff117 	bl	10a804 <sys_sem_valid>
  10e3a4:	e1a03000 	mov	r3, r0
  10e3a8:	e3530000 	cmp	r3, #0
  10e3ac:	0a000011 	beq	10e3f8 <lwip_netconn_do_delconn+0x3a4>
    TCPIP_APIMSG_ACK(msg);
  10e3b0:	e51b3008 	ldr	r3, [fp, #-8]
  10e3b4:	e5933000 	ldr	r3, [r3]
  10e3b8:	e3530000 	cmp	r3, #0
  10e3bc:	0a00000d 	beq	10e3f8 <lwip_netconn_do_delconn+0x3a4>
  10e3c0:	ebffcf9d 	bl	10223c <rt_enter_critical>
  10e3c4:	e51b3008 	ldr	r3, [fp, #-8]
  10e3c8:	e5933000 	ldr	r3, [r3]
  10e3cc:	e1d330dc 	ldrsb	r3, [r3, #12]
  10e3d0:	e373000c 	cmn	r3, #12
  10e3d4:	ba000004 	blt	10e3ec <lwip_netconn_do_delconn+0x398>
  10e3d8:	e51b3008 	ldr	r3, [fp, #-8]
  10e3dc:	e5933000 	ldr	r3, [r3]
  10e3e0:	e51b2008 	ldr	r2, [fp, #-8]
  10e3e4:	e1d220d4 	ldrsb	r2, [r2, #4]
  10e3e8:	e5c3200c 	strb	r2, [r3, #12]
  10e3ec:	ebffcf98 	bl	102254 <rt_exit_critical>
  10e3f0:	ea000000 	b	10e3f8 <lwip_netconn_do_delconn+0x3a4>
        return;
  10e3f4:	e320f000 	nop	{0}
  }
}
  10e3f8:	e24bd004 	sub	sp, fp, #4
  10e3fc:	e8bd8800 	pop	{fp, pc}

0010e400 <lwip_netconn_do_bind>:
 * @param m the api_msg_msg pointing to the connection and containing
 *          the IP address and port to bind to
 */
void
lwip_netconn_do_bind(void *m)
{
  10e400:	e92d4800 	push	{fp, lr}
  10e404:	e28db004 	add	fp, sp, #4
  10e408:	e24dd010 	sub	sp, sp, #16
  10e40c:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10e410:	e51b3010 	ldr	r3, [fp, #-16]
  10e414:	e50b3008 	str	r3, [fp, #-8]

  if (ERR_IS_FATAL(msg->conn->last_err)) {
  10e418:	e51b3008 	ldr	r3, [fp, #-8]
  10e41c:	e5933000 	ldr	r3, [r3]
  10e420:	e1d330dc 	ldrsb	r3, [r3, #12]
  10e424:	e373000c 	cmn	r3, #12
  10e428:	aa000005 	bge	10e444 <lwip_netconn_do_bind+0x44>
    msg->err = msg->conn->last_err;
  10e42c:	e51b3008 	ldr	r3, [fp, #-8]
  10e430:	e5933000 	ldr	r3, [r3]
  10e434:	e1d320dc 	ldrsb	r2, [r3, #12]
  10e438:	e51b3008 	ldr	r3, [fp, #-8]
  10e43c:	e5c32004 	strb	r2, [r3, #4]
  10e440:	ea00003c 	b	10e538 <lwip_netconn_do_bind+0x138>
  } else {
    msg->err = ERR_VAL;
  10e444:	e51b3008 	ldr	r3, [fp, #-8]
  10e448:	e3e02005 	mvn	r2, #5
  10e44c:	e5c32004 	strb	r2, [r3, #4]
    if (msg->conn->pcb.tcp != NULL) {
  10e450:	e51b3008 	ldr	r3, [fp, #-8]
  10e454:	e5933000 	ldr	r3, [r3]
  10e458:	e5933008 	ldr	r3, [r3, #8]
  10e45c:	e3530000 	cmp	r3, #0
  10e460:	0a000033 	beq	10e534 <lwip_netconn_do_bind+0x134>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  10e464:	e51b3008 	ldr	r3, [fp, #-8]
  10e468:	e5933000 	ldr	r3, [r3]
  10e46c:	e5933000 	ldr	r3, [r3]
  10e470:	e20330f0 	and	r3, r3, #240	; 0xf0
  10e474:	e3530020 	cmp	r3, #32
  10e478:	0a000011 	beq	10e4c4 <lwip_netconn_do_bind+0xc4>
  10e47c:	e3530040 	cmp	r3, #64	; 0x40
  10e480:	0a000002 	beq	10e490 <lwip_netconn_do_bind+0x90>
  10e484:	e3530010 	cmp	r3, #16
  10e488:	0a00001b 	beq	10e4fc <lwip_netconn_do_bind+0xfc>
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
  10e48c:	ea000029 	b	10e538 <lwip_netconn_do_bind+0x138>
        msg->err = raw_bind(msg->conn->pcb.raw, API_EXPR_REF(msg->msg.bc.ipaddr));
  10e490:	e51b3008 	ldr	r3, [fp, #-8]
  10e494:	e5933000 	ldr	r3, [r3]
  10e498:	e5932008 	ldr	r2, [r3, #8]
  10e49c:	e51b3008 	ldr	r3, [fp, #-8]
  10e4a0:	e5933008 	ldr	r3, [r3, #8]
  10e4a4:	e1a01003 	mov	r1, r3
  10e4a8:	e1a00002 	mov	r0, r2
  10e4ac:	eb003839 	bl	11c598 <raw_bind>
  10e4b0:	e1a03000 	mov	r3, r0
  10e4b4:	e1a02003 	mov	r2, r3
  10e4b8:	e51b3008 	ldr	r3, [fp, #-8]
  10e4bc:	e5c32004 	strb	r2, [r3, #4]
        break;
  10e4c0:	ea00001c 	b	10e538 <lwip_netconn_do_bind+0x138>
        msg->err = udp_bind(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
  10e4c4:	e51b3008 	ldr	r3, [fp, #-8]
  10e4c8:	e5933000 	ldr	r3, [r3]
  10e4cc:	e5930008 	ldr	r0, [r3, #8]
  10e4d0:	e51b3008 	ldr	r3, [fp, #-8]
  10e4d4:	e5931008 	ldr	r1, [r3, #8]
  10e4d8:	e51b3008 	ldr	r3, [fp, #-8]
  10e4dc:	e1d330bc 	ldrh	r3, [r3, #12]
  10e4e0:	e1a02003 	mov	r2, r3
  10e4e4:	eb0068d9 	bl	128850 <udp_bind>
  10e4e8:	e1a03000 	mov	r3, r0
  10e4ec:	e1a02003 	mov	r2, r3
  10e4f0:	e51b3008 	ldr	r3, [fp, #-8]
  10e4f4:	e5c32004 	strb	r2, [r3, #4]
        break;
  10e4f8:	ea00000e 	b	10e538 <lwip_netconn_do_bind+0x138>
        msg->err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
  10e4fc:	e51b3008 	ldr	r3, [fp, #-8]
  10e500:	e5933000 	ldr	r3, [r3]
  10e504:	e5930008 	ldr	r0, [r3, #8]
  10e508:	e51b3008 	ldr	r3, [fp, #-8]
  10e50c:	e5931008 	ldr	r1, [r3, #8]
  10e510:	e51b3008 	ldr	r3, [fp, #-8]
  10e514:	e1d330bc 	ldrh	r3, [r3, #12]
  10e518:	e1a02003 	mov	r2, r3
  10e51c:	eb003dc8 	bl	11dc44 <tcp_bind>
  10e520:	e1a03000 	mov	r3, r0
  10e524:	e1a02003 	mov	r2, r3
  10e528:	e51b3008 	ldr	r3, [fp, #-8]
  10e52c:	e5c32004 	strb	r2, [r3, #4]
        break;
  10e530:	ea000000 	b	10e538 <lwip_netconn_do_bind+0x138>
      }
    }
  10e534:	e320f000 	nop	{0}
  }
  TCPIP_APIMSG_ACK(msg);
  10e538:	e51b3008 	ldr	r3, [fp, #-8]
  10e53c:	e5933000 	ldr	r3, [r3]
  10e540:	e3530000 	cmp	r3, #0
  10e544:	0a00000b 	beq	10e578 <lwip_netconn_do_bind+0x178>
  10e548:	ebffcf3b 	bl	10223c <rt_enter_critical>
  10e54c:	e51b3008 	ldr	r3, [fp, #-8]
  10e550:	e5933000 	ldr	r3, [r3]
  10e554:	e1d330dc 	ldrsb	r3, [r3, #12]
  10e558:	e373000c 	cmn	r3, #12
  10e55c:	ba000004 	blt	10e574 <lwip_netconn_do_bind+0x174>
  10e560:	e51b3008 	ldr	r3, [fp, #-8]
  10e564:	e5933000 	ldr	r3, [r3]
  10e568:	e51b2008 	ldr	r2, [fp, #-8]
  10e56c:	e1d220d4 	ldrsb	r2, [r2, #4]
  10e570:	e5c3200c 	strb	r2, [r3, #12]
  10e574:	ebffcf36 	bl	102254 <rt_exit_critical>
}
  10e578:	e320f000 	nop	{0}
  10e57c:	e24bd004 	sub	sp, fp, #4
  10e580:	e8bd8800 	pop	{fp, pc}

0010e584 <lwip_netconn_do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
lwip_netconn_do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  10e584:	e92d4800 	push	{fp, lr}
  10e588:	e28db004 	add	fp, sp, #4
  10e58c:	e24dd020 	sub	sp, sp, #32
  10e590:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  10e594:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  10e598:	e1a03002 	mov	r3, r2
  10e59c:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
  struct netconn *conn;
  int was_blocking;
  sys_sem_t* op_completed_sem = NULL;
  10e5a0:	e3a03000 	mov	r3, #0
  10e5a4:	e50b3008 	str	r3, [fp, #-8]

  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *)arg;
  10e5a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10e5ac:	e50b300c 	str	r3, [fp, #-12]

  if (conn == NULL) {
  10e5b0:	e51b300c 	ldr	r3, [fp, #-12]
  10e5b4:	e3530000 	cmp	r3, #0
  10e5b8:	1a000001 	bne	10e5c4 <lwip_netconn_do_connected+0x40>
    return ERR_VAL;
  10e5bc:	e3e03005 	mvn	r3, #5
  10e5c0:	ea000074 	b	10e798 <lwip_netconn_do_connected+0x214>
  }

  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
  10e5c4:	e51b300c 	ldr	r3, [fp, #-12]
  10e5c8:	e5933004 	ldr	r3, [r3, #4]
  10e5cc:	e3530003 	cmp	r3, #3
  10e5d0:	0a000006 	beq	10e5f0 <lwip_netconn_do_connected+0x6c>
  10e5d4:	e3060bfc 	movw	r0, #27644	; 0x6bfc
  10e5d8:	e3400014 	movt	r0, #20
  10e5dc:	ebffd2cc 	bl	103114 <rt_kprintf>
  10e5e0:	e3001492 	movw	r1, #1170	; 0x492
  10e5e4:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e5e8:	e3400014 	movt	r0, #20
  10e5ec:	ebfff2a2 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
  10e5f0:	e51b300c 	ldr	r3, [fp, #-12]
  10e5f4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10e5f8:	e3530000 	cmp	r3, #0
  10e5fc:	1a00000b 	bne	10e630 <lwip_netconn_do_connected+0xac>
  10e600:	e51b300c 	ldr	r3, [fp, #-12]
  10e604:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10e608:	e2033004 	and	r3, r3, #4
  10e60c:	e3530000 	cmp	r3, #0
  10e610:	1a000006 	bne	10e630 <lwip_netconn_do_connected+0xac>
  10e614:	e3060c1c 	movw	r0, #27676	; 0x6c1c
  10e618:	e3400014 	movt	r0, #20
  10e61c:	ebffd2bc 	bl	103114 <rt_kprintf>
  10e620:	e3001494 	movw	r1, #1172	; 0x494
  10e624:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e628:	e3400014 	movt	r0, #20
  10e62c:	ebfff292 	bl	10b07c <sys_arch_assert>
    (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
  10e630:	e51b300c 	ldr	r3, [fp, #-12]
  10e634:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10e638:	e3530000 	cmp	r3, #0
  10e63c:	0a000008 	beq	10e664 <lwip_netconn_do_connected+0xe0>
    conn->current_msg->err = err;
  10e640:	e51b300c 	ldr	r3, [fp, #-12]
  10e644:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10e648:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
  10e64c:	e5c32004 	strb	r2, [r3, #4]
    op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
  10e650:	e51b300c 	ldr	r3, [fp, #-12]
  10e654:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10e658:	e5933000 	ldr	r3, [r3]
  10e65c:	e2833010 	add	r3, r3, #16
  10e660:	e50b3008 	str	r3, [fp, #-8]
  }
  if ((NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) && (err == ERR_OK)) {
  10e664:	e51b300c 	ldr	r3, [fp, #-12]
  10e668:	e5933000 	ldr	r3, [r3]
  10e66c:	e20330f0 	and	r3, r3, #240	; 0xf0
  10e670:	e3530010 	cmp	r3, #16
  10e674:	1a000004 	bne	10e68c <lwip_netconn_do_connected+0x108>
  10e678:	e15b31dd 	ldrsb	r3, [fp, #-29]	; 0xffffffe3
  10e67c:	e3530000 	cmp	r3, #0
  10e680:	1a000001 	bne	10e68c <lwip_netconn_do_connected+0x108>
    setup_tcp(conn);
  10e684:	e51b000c 	ldr	r0, [fp, #-12]
  10e688:	ebfffabe 	bl	10d188 <setup_tcp>
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
  10e68c:	e51b300c 	ldr	r3, [fp, #-12]
  10e690:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10e694:	e2033004 	and	r3, r3, #4
  10e698:	e3530000 	cmp	r3, #0
  10e69c:	03a03001 	moveq	r3, #1
  10e6a0:	13a03000 	movne	r3, #0
  10e6a4:	e6ef3073 	uxtb	r3, r3
  10e6a8:	e50b3010 	str	r3, [fp, #-16]
  SET_NONBLOCKING_CONNECT(conn, 0);
  10e6ac:	e51b300c 	ldr	r3, [fp, #-12]
  10e6b0:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10e6b4:	e3c33004 	bic	r3, r3, #4
  10e6b8:	e6ef2073 	uxtb	r2, r3
  10e6bc:	e51b300c 	ldr	r3, [fp, #-12]
  10e6c0:	e5c32030 	strb	r2, [r3, #48]	; 0x30
  LWIP_ASSERT("blocking connect state error",
  10e6c4:	e51b3010 	ldr	r3, [fp, #-16]
  10e6c8:	e3530000 	cmp	r3, #0
  10e6cc:	0a000002 	beq	10e6dc <lwip_netconn_do_connected+0x158>
  10e6d0:	e51b3008 	ldr	r3, [fp, #-8]
  10e6d4:	e3530000 	cmp	r3, #0
  10e6d8:	1a00000c 	bne	10e710 <lwip_netconn_do_connected+0x18c>
  10e6dc:	e51b3010 	ldr	r3, [fp, #-16]
  10e6e0:	e3530000 	cmp	r3, #0
  10e6e4:	1a000002 	bne	10e6f4 <lwip_netconn_do_connected+0x170>
  10e6e8:	e51b3008 	ldr	r3, [fp, #-8]
  10e6ec:	e3530000 	cmp	r3, #0
  10e6f0:	0a000006 	beq	10e710 <lwip_netconn_do_connected+0x18c>
  10e6f4:	e3060c5c 	movw	r0, #27740	; 0x6c5c
  10e6f8:	e3400014 	movt	r0, #20
  10e6fc:	ebffd284 	bl	103114 <rt_kprintf>
  10e700:	e30014a1 	movw	r1, #1185	; 0x4a1
  10e704:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e708:	e3400014 	movt	r0, #20
  10e70c:	ebfff25a 	bl	10b07c <sys_arch_assert>
    (was_blocking && op_completed_sem != NULL) ||
    (!was_blocking && op_completed_sem == NULL));
  conn->current_msg = NULL;
  10e710:	e51b300c 	ldr	r3, [fp, #-12]
  10e714:	e3a02000 	mov	r2, #0
  10e718:	e5832038 	str	r2, [r3, #56]	; 0x38
  conn->state = NETCONN_NONE;
  10e71c:	e51b300c 	ldr	r3, [fp, #-12]
  10e720:	e3a02000 	mov	r2, #0
  10e724:	e5832004 	str	r2, [r3, #4]
  NETCONN_SET_SAFE_ERR(conn, ERR_OK);
  10e728:	e51b300c 	ldr	r3, [fp, #-12]
  10e72c:	e3530000 	cmp	r3, #0
  10e730:	0a000008 	beq	10e758 <lwip_netconn_do_connected+0x1d4>
  10e734:	ebffcec0 	bl	10223c <rt_enter_critical>
  10e738:	e51b300c 	ldr	r3, [fp, #-12]
  10e73c:	e1d330dc 	ldrsb	r3, [r3, #12]
  10e740:	e373000c 	cmn	r3, #12
  10e744:	ba000002 	blt	10e754 <lwip_netconn_do_connected+0x1d0>
  10e748:	e51b300c 	ldr	r3, [fp, #-12]
  10e74c:	e3a02000 	mov	r2, #0
  10e750:	e5c3200c 	strb	r2, [r3, #12]
  10e754:	ebffcebe 	bl	102254 <rt_exit_critical>
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  10e758:	e51b300c 	ldr	r3, [fp, #-12]
  10e75c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10e760:	e3530000 	cmp	r3, #0
  10e764:	0a000005 	beq	10e780 <lwip_netconn_do_connected+0x1fc>
  10e768:	e51b300c 	ldr	r3, [fp, #-12]
  10e76c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10e770:	e3a02000 	mov	r2, #0
  10e774:	e3a01002 	mov	r1, #2
  10e778:	e51b000c 	ldr	r0, [fp, #-12]
  10e77c:	e12fff33 	blx	r3

  if (was_blocking) {
  10e780:	e51b3010 	ldr	r3, [fp, #-16]
  10e784:	e3530000 	cmp	r3, #0
  10e788:	0a000001 	beq	10e794 <lwip_netconn_do_connected+0x210>
    sys_sem_signal(op_completed_sem);
  10e78c:	e51b0008 	ldr	r0, [fp, #-8]
  10e790:	ebffefdd 	bl	10a70c <sys_sem_signal>
  }
  return ERR_OK;
  10e794:	e3a03000 	mov	r3, #0
}
  10e798:	e1a00003 	mov	r0, r3
  10e79c:	e24bd004 	sub	sp, fp, #4
  10e7a0:	e8bd8800 	pop	{fp, pc}

0010e7a4 <lwip_netconn_do_connect>:
 * @param m the api_msg_msg pointing to the connection and containing
 *          the IP address and port to connect to
 */
void
lwip_netconn_do_connect(void *m)
{
  10e7a4:	e92d4800 	push	{fp, lr}
  10e7a8:	e28db004 	add	fp, sp, #4
  10e7ac:	e24dd010 	sub	sp, sp, #16
  10e7b0:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10e7b4:	e51b3010 	ldr	r3, [fp, #-16]
  10e7b8:	e50b3008 	str	r3, [fp, #-8]

  if (msg->conn->pcb.tcp == NULL) {
  10e7bc:	e51b3008 	ldr	r3, [fp, #-8]
  10e7c0:	e5933000 	ldr	r3, [r3]
  10e7c4:	e5933008 	ldr	r3, [r3, #8]
  10e7c8:	e3530000 	cmp	r3, #0
  10e7cc:	1a000003 	bne	10e7e0 <lwip_netconn_do_connect+0x3c>
    /* This may happen when calling netconn_connect() a second time */
    msg->err = ERR_CLSD;
  10e7d0:	e51b3008 	ldr	r3, [fp, #-8]
  10e7d4:	e3e0200e 	mvn	r2, #14
  10e7d8:	e5c32004 	strb	r2, [r3, #4]
  10e7dc:	ea0000aa 	b	10ea8c <lwip_netconn_do_connect+0x2e8>
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  10e7e0:	e51b3008 	ldr	r3, [fp, #-8]
  10e7e4:	e5933000 	ldr	r3, [r3]
  10e7e8:	e5933000 	ldr	r3, [r3]
  10e7ec:	e20330f0 	and	r3, r3, #240	; 0xf0
  10e7f0:	e3530020 	cmp	r3, #32
  10e7f4:	0a000011 	beq	10e840 <lwip_netconn_do_connect+0x9c>
  10e7f8:	e3530040 	cmp	r3, #64	; 0x40
  10e7fc:	0a000002 	beq	10e80c <lwip_netconn_do_connect+0x68>
  10e800:	e3530010 	cmp	r3, #16
  10e804:	0a00001b 	beq	10e878 <lwip_netconn_do_connect+0xd4>
  10e808:	ea000093 	b	10ea5c <lwip_netconn_do_connect+0x2b8>
#if LWIP_RAW
    case NETCONN_RAW:
      msg->err = raw_connect(msg->conn->pcb.raw, API_EXPR_REF(msg->msg.bc.ipaddr));
  10e80c:	e51b3008 	ldr	r3, [fp, #-8]
  10e810:	e5933000 	ldr	r3, [r3]
  10e814:	e5932008 	ldr	r2, [r3, #8]
  10e818:	e51b3008 	ldr	r3, [fp, #-8]
  10e81c:	e5933008 	ldr	r3, [r3, #8]
  10e820:	e1a01003 	mov	r1, r3
  10e824:	e1a00002 	mov	r0, r2
  10e828:	eb003775 	bl	11c604 <raw_connect>
  10e82c:	e1a03000 	mov	r3, r0
  10e830:	e1a02003 	mov	r2, r3
  10e834:	e51b3008 	ldr	r3, [fp, #-8]
  10e838:	e5c32004 	strb	r2, [r3, #4]
      break;
  10e83c:	ea000092 	b	10ea8c <lwip_netconn_do_connect+0x2e8>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->err = udp_connect(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
  10e840:	e51b3008 	ldr	r3, [fp, #-8]
  10e844:	e5933000 	ldr	r3, [r3]
  10e848:	e5930008 	ldr	r0, [r3, #8]
  10e84c:	e51b3008 	ldr	r3, [fp, #-8]
  10e850:	e5931008 	ldr	r1, [r3, #8]
  10e854:	e51b3008 	ldr	r3, [fp, #-8]
  10e858:	e1d330bc 	ldrh	r3, [r3, #12]
  10e85c:	e1a02003 	mov	r2, r3
  10e860:	eb006870 	bl	128a28 <udp_connect>
  10e864:	e1a03000 	mov	r3, r0
  10e868:	e1a02003 	mov	r2, r3
  10e86c:	e51b3008 	ldr	r3, [fp, #-8]
  10e870:	e5c32004 	strb	r2, [r3, #4]
      break;
  10e874:	ea000084 	b	10ea8c <lwip_netconn_do_connect+0x2e8>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      /* Prevent connect while doing any other action. */
      if (msg->conn->state == NETCONN_CONNECT) {
  10e878:	e51b3008 	ldr	r3, [fp, #-8]
  10e87c:	e5933000 	ldr	r3, [r3]
  10e880:	e5933004 	ldr	r3, [r3, #4]
  10e884:	e3530003 	cmp	r3, #3
  10e888:	1a000003 	bne	10e89c <lwip_netconn_do_connect+0xf8>
        msg->err = ERR_ALREADY;
  10e88c:	e51b3008 	ldr	r3, [fp, #-8]
  10e890:	e3e02008 	mvn	r2, #8
  10e894:	e5c32004 	strb	r2, [r3, #4]
#endif /* LWIP_TCPIP_CORE_LOCKING */
            return;
          }
        }
      }
      break;
  10e898:	ea00007a 	b	10ea88 <lwip_netconn_do_connect+0x2e4>
      } else if (msg->conn->state != NETCONN_NONE) {
  10e89c:	e51b3008 	ldr	r3, [fp, #-8]
  10e8a0:	e5933000 	ldr	r3, [r3]
  10e8a4:	e5933004 	ldr	r3, [r3, #4]
  10e8a8:	e3530000 	cmp	r3, #0
  10e8ac:	0a000003 	beq	10e8c0 <lwip_netconn_do_connect+0x11c>
        msg->err = ERR_ISCONN;
  10e8b0:	e51b3008 	ldr	r3, [fp, #-8]
  10e8b4:	e3e02009 	mvn	r2, #9
  10e8b8:	e5c32004 	strb	r2, [r3, #4]
      break;
  10e8bc:	ea000071 	b	10ea88 <lwip_netconn_do_connect+0x2e4>
        setup_tcp(msg->conn);
  10e8c0:	e51b3008 	ldr	r3, [fp, #-8]
  10e8c4:	e5933000 	ldr	r3, [r3]
  10e8c8:	e1a00003 	mov	r0, r3
  10e8cc:	ebfffa2d 	bl	10d188 <setup_tcp>
        msg->err = tcp_connect(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr),
  10e8d0:	e51b3008 	ldr	r3, [fp, #-8]
  10e8d4:	e5933000 	ldr	r3, [r3]
  10e8d8:	e5930008 	ldr	r0, [r3, #8]
  10e8dc:	e51b3008 	ldr	r3, [fp, #-8]
  10e8e0:	e5931008 	ldr	r1, [r3, #8]
  10e8e4:	e51b3008 	ldr	r3, [fp, #-8]
  10e8e8:	e1d320bc 	ldrh	r2, [r3, #12]
  10e8ec:	e30e3584 	movw	r3, #58756	; 0xe584
  10e8f0:	e3403010 	movt	r3, #16
  10e8f4:	eb003efc 	bl	11e4ec <tcp_connect>
  10e8f8:	e1a03000 	mov	r3, r0
  10e8fc:	e1a02003 	mov	r2, r3
  10e900:	e51b3008 	ldr	r3, [fp, #-8]
  10e904:	e5c32004 	strb	r2, [r3, #4]
        if (msg->err == ERR_OK) {
  10e908:	e51b3008 	ldr	r3, [fp, #-8]
  10e90c:	e1d330d4 	ldrsb	r3, [r3, #4]
  10e910:	e3530000 	cmp	r3, #0
  10e914:	1a00005b 	bne	10ea88 <lwip_netconn_do_connect+0x2e4>
          u8_t non_blocking = netconn_is_nonblocking(msg->conn);
  10e918:	e51b3008 	ldr	r3, [fp, #-8]
  10e91c:	e5933000 	ldr	r3, [r3]
  10e920:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10e924:	e2033002 	and	r3, r3, #2
  10e928:	e3530000 	cmp	r3, #0
  10e92c:	13a03001 	movne	r3, #1
  10e930:	03a03000 	moveq	r3, #0
  10e934:	e6ef3073 	uxtb	r3, r3
  10e938:	e54b3009 	strb	r3, [fp, #-9]
          msg->conn->state = NETCONN_CONNECT;
  10e93c:	e51b3008 	ldr	r3, [fp, #-8]
  10e940:	e5933000 	ldr	r3, [r3]
  10e944:	e3a02003 	mov	r2, #3
  10e948:	e5832004 	str	r2, [r3, #4]
          SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
  10e94c:	e55b3009 	ldrb	r3, [fp, #-9]
  10e950:	e3530000 	cmp	r3, #0
  10e954:	0a000008 	beq	10e97c <lwip_netconn_do_connect+0x1d8>
  10e958:	e51b3008 	ldr	r3, [fp, #-8]
  10e95c:	e5933000 	ldr	r3, [r3]
  10e960:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
  10e964:	e51b3008 	ldr	r3, [fp, #-8]
  10e968:	e5933000 	ldr	r3, [r3]
  10e96c:	e3822004 	orr	r2, r2, #4
  10e970:	e6ef2072 	uxtb	r2, r2
  10e974:	e5c32030 	strb	r2, [r3, #48]	; 0x30
  10e978:	ea000007 	b	10e99c <lwip_netconn_do_connect+0x1f8>
  10e97c:	e51b3008 	ldr	r3, [fp, #-8]
  10e980:	e5933000 	ldr	r3, [r3]
  10e984:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
  10e988:	e51b3008 	ldr	r3, [fp, #-8]
  10e98c:	e5933000 	ldr	r3, [r3]
  10e990:	e3c22004 	bic	r2, r2, #4
  10e994:	e6ef2072 	uxtb	r2, r2
  10e998:	e5c32030 	strb	r2, [r3, #48]	; 0x30
          if (non_blocking) {
  10e99c:	e55b3009 	ldrb	r3, [fp, #-9]
  10e9a0:	e3530000 	cmp	r3, #0
  10e9a4:	0a000003 	beq	10e9b8 <lwip_netconn_do_connect+0x214>
            msg->err = ERR_INPROGRESS;
  10e9a8:	e51b3008 	ldr	r3, [fp, #-8]
  10e9ac:	e3e02004 	mvn	r2, #4
  10e9b0:	e5c32004 	strb	r2, [r3, #4]
      break;
  10e9b4:	ea000033 	b	10ea88 <lwip_netconn_do_connect+0x2e4>
            msg->conn->current_msg = msg;
  10e9b8:	e51b3008 	ldr	r3, [fp, #-8]
  10e9bc:	e5933000 	ldr	r3, [r3]
  10e9c0:	e51b2008 	ldr	r2, [fp, #-8]
  10e9c4:	e5832038 	str	r2, [r3, #56]	; 0x38
            LWIP_ASSERT("state!", msg->conn->state == NETCONN_CONNECT);
  10e9c8:	e51b3008 	ldr	r3, [fp, #-8]
  10e9cc:	e5933000 	ldr	r3, [r3]
  10e9d0:	e5933004 	ldr	r3, [r3, #4]
  10e9d4:	e3530003 	cmp	r3, #3
  10e9d8:	0a000006 	beq	10e9f8 <lwip_netconn_do_connect+0x254>
  10e9dc:	e3060bf4 	movw	r0, #27636	; 0x6bf4
  10e9e0:	e3400014 	movt	r0, #20
  10e9e4:	ebffd1ca 	bl	103114 <rt_kprintf>
  10e9e8:	e30014df 	movw	r1, #1247	; 0x4df
  10e9ec:	e30608bc 	movw	r0, #26812	; 0x68bc
  10e9f0:	e3400014 	movt	r0, #20
  10e9f4:	ebfff1a0 	bl	10b07c <sys_arch_assert>
            UNLOCK_TCPIP_CORE();
  10e9f8:	e30005e4 	movw	r0, #1508	; 0x5e4
  10e9fc:	e3400015 	movt	r0, #21
  10ea00:	ebffefc8 	bl	10a928 <sys_mutex_unlock>
            sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
  10ea04:	e51b3008 	ldr	r3, [fp, #-8]
  10ea08:	e5933000 	ldr	r3, [r3]
  10ea0c:	e2833010 	add	r3, r3, #16
  10ea10:	e3a01000 	mov	r1, #0
  10ea14:	e1a00003 	mov	r0, r3
  10ea18:	ebffef46 	bl	10a738 <sys_arch_sem_wait>
            LOCK_TCPIP_CORE();
  10ea1c:	e30005e4 	movw	r0, #1508	; 0x5e4
  10ea20:	e3400015 	movt	r0, #21
  10ea24:	ebffefb3 	bl	10a8f8 <sys_mutex_lock>
            LWIP_ASSERT("state!", msg->conn->state != NETCONN_CONNECT);
  10ea28:	e51b3008 	ldr	r3, [fp, #-8]
  10ea2c:	e5933000 	ldr	r3, [r3]
  10ea30:	e5933004 	ldr	r3, [r3, #4]
  10ea34:	e3530003 	cmp	r3, #3
  10ea38:	1a000024 	bne	10ead0 <lwip_netconn_do_connect+0x32c>
  10ea3c:	e3060bf4 	movw	r0, #27636	; 0x6bf4
  10ea40:	e3400014 	movt	r0, #20
  10ea44:	ebffd1b2 	bl	103114 <rt_kprintf>
  10ea48:	e30014e3 	movw	r1, #1251	; 0x4e3
  10ea4c:	e30608bc 	movw	r0, #26812	; 0x68bc
  10ea50:	e3400014 	movt	r0, #20
  10ea54:	ebfff188 	bl	10b07c <sys_arch_assert>
            return;
  10ea58:	ea00001c 	b	10ead0 <lwip_netconn_do_connect+0x32c>
#endif /* LWIP_TCP */
    default:
      LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
  10ea5c:	e3060c7c 	movw	r0, #27772	; 0x6c7c
  10ea60:	e3400014 	movt	r0, #20
  10ea64:	ebffd1aa 	bl	103114 <rt_kprintf>
  10ea68:	e30014ec 	movw	r1, #1260	; 0x4ec
  10ea6c:	e30608bc 	movw	r0, #26812	; 0x68bc
  10ea70:	e3400014 	movt	r0, #20
  10ea74:	ebfff180 	bl	10b07c <sys_arch_assert>
  10ea78:	e51b3008 	ldr	r3, [fp, #-8]
  10ea7c:	e3e02005 	mvn	r2, #5
  10ea80:	e5c32004 	strb	r2, [r3, #4]
      break;
  10ea84:	ea000000 	b	10ea8c <lwip_netconn_do_connect+0x2e8>
      break;
  10ea88:	e320f000 	nop	{0}
    }
  }
  /* For all other protocols, netconn_connect() calls TCPIP_APIMSG(),
     so use TCPIP_APIMSG_ACK() here. */
  TCPIP_APIMSG_ACK(msg);
  10ea8c:	e51b3008 	ldr	r3, [fp, #-8]
  10ea90:	e5933000 	ldr	r3, [r3]
  10ea94:	e3530000 	cmp	r3, #0
  10ea98:	0a00000d 	beq	10ead4 <lwip_netconn_do_connect+0x330>
  10ea9c:	ebffcde6 	bl	10223c <rt_enter_critical>
  10eaa0:	e51b3008 	ldr	r3, [fp, #-8]
  10eaa4:	e5933000 	ldr	r3, [r3]
  10eaa8:	e1d330dc 	ldrsb	r3, [r3, #12]
  10eaac:	e373000c 	cmn	r3, #12
  10eab0:	ba000004 	blt	10eac8 <lwip_netconn_do_connect+0x324>
  10eab4:	e51b3008 	ldr	r3, [fp, #-8]
  10eab8:	e5933000 	ldr	r3, [r3]
  10eabc:	e51b2008 	ldr	r2, [fp, #-8]
  10eac0:	e1d220d4 	ldrsb	r2, [r2, #4]
  10eac4:	e5c3200c 	strb	r2, [r3, #12]
  10eac8:	ebffcde1 	bl	102254 <rt_exit_critical>
  10eacc:	ea000000 	b	10ead4 <lwip_netconn_do_connect+0x330>
            return;
  10ead0:	e320f000 	nop	{0}
}
  10ead4:	e24bd004 	sub	sp, fp, #4
  10ead8:	e8bd8800 	pop	{fp, pc}

0010eadc <lwip_netconn_do_disconnect>:
 *
 * @param m the api_msg_msg pointing to the connection to disconnect
 */
void
lwip_netconn_do_disconnect(void *m)
{
  10eadc:	e92d4800 	push	{fp, lr}
  10eae0:	e28db004 	add	fp, sp, #4
  10eae4:	e24dd010 	sub	sp, sp, #16
  10eae8:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10eaec:	e51b3010 	ldr	r3, [fp, #-16]
  10eaf0:	e50b3008 	str	r3, [fp, #-8]

#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  10eaf4:	e51b3008 	ldr	r3, [fp, #-8]
  10eaf8:	e5933000 	ldr	r3, [r3]
  10eafc:	e5933000 	ldr	r3, [r3]
  10eb00:	e20330f0 	and	r3, r3, #240	; 0xf0
  10eb04:	e3530020 	cmp	r3, #32
  10eb08:	1a000008 	bne	10eb30 <lwip_netconn_do_disconnect+0x54>
    udp_disconnect(msg->conn->pcb.udp);
  10eb0c:	e51b3008 	ldr	r3, [fp, #-8]
  10eb10:	e5933000 	ldr	r3, [r3]
  10eb14:	e5933008 	ldr	r3, [r3, #8]
  10eb18:	e1a00003 	mov	r0, r3
  10eb1c:	eb006811 	bl	128b68 <udp_disconnect>
    msg->err = ERR_OK;
  10eb20:	e51b3008 	ldr	r3, [fp, #-8]
  10eb24:	e3a02000 	mov	r2, #0
  10eb28:	e5c32004 	strb	r2, [r3, #4]
  10eb2c:	ea000002 	b	10eb3c <lwip_netconn_do_disconnect+0x60>
  } else
#endif /* LWIP_UDP */
  {
    msg->err = ERR_VAL;
  10eb30:	e51b3008 	ldr	r3, [fp, #-8]
  10eb34:	e3e02005 	mvn	r2, #5
  10eb38:	e5c32004 	strb	r2, [r3, #4]
  }
  TCPIP_APIMSG_ACK(msg);
  10eb3c:	e51b3008 	ldr	r3, [fp, #-8]
  10eb40:	e5933000 	ldr	r3, [r3]
  10eb44:	e3530000 	cmp	r3, #0
  10eb48:	0a00000b 	beq	10eb7c <lwip_netconn_do_disconnect+0xa0>
  10eb4c:	ebffcdba 	bl	10223c <rt_enter_critical>
  10eb50:	e51b3008 	ldr	r3, [fp, #-8]
  10eb54:	e5933000 	ldr	r3, [r3]
  10eb58:	e1d330dc 	ldrsb	r3, [r3, #12]
  10eb5c:	e373000c 	cmn	r3, #12
  10eb60:	ba000004 	blt	10eb78 <lwip_netconn_do_disconnect+0x9c>
  10eb64:	e51b3008 	ldr	r3, [fp, #-8]
  10eb68:	e5933000 	ldr	r3, [r3]
  10eb6c:	e51b2008 	ldr	r2, [fp, #-8]
  10eb70:	e1d220d4 	ldrsb	r2, [r2, #4]
  10eb74:	e5c3200c 	strb	r2, [r3, #12]
  10eb78:	ebffcdb5 	bl	102254 <rt_exit_critical>
}
  10eb7c:	e320f000 	nop	{0}
  10eb80:	e24bd004 	sub	sp, fp, #4
  10eb84:	e8bd8800 	pop	{fp, pc}

0010eb88 <lwip_netconn_do_listen>:
 *
 * @param m the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_listen(void *m)
{
  10eb88:	e92d4800 	push	{fp, lr}
  10eb8c:	e28db004 	add	fp, sp, #4
  10eb90:	e24dd018 	sub	sp, sp, #24
  10eb94:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct api_msg *msg = (struct api_msg*)m;
  10eb98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10eb9c:	e50b3008 	str	r3, [fp, #-8]

  if (ERR_IS_FATAL(msg->conn->last_err)) {
  10eba0:	e51b3008 	ldr	r3, [fp, #-8]
  10eba4:	e5933000 	ldr	r3, [r3]
  10eba8:	e1d330dc 	ldrsb	r3, [r3, #12]
  10ebac:	e373000c 	cmn	r3, #12
  10ebb0:	aa000005 	bge	10ebcc <lwip_netconn_do_listen+0x44>
    msg->err = msg->conn->last_err;
  10ebb4:	e51b3008 	ldr	r3, [fp, #-8]
  10ebb8:	e5933000 	ldr	r3, [r3]
  10ebbc:	e1d320dc 	ldrsb	r2, [r3, #12]
  10ebc0:	e51b3008 	ldr	r3, [fp, #-8]
  10ebc4:	e5c32004 	strb	r2, [r3, #4]
  10ebc8:	ea000083 	b	10eddc <lwip_netconn_do_listen+0x254>
  } else {
    msg->err = ERR_CONN;
  10ebcc:	e51b3008 	ldr	r3, [fp, #-8]
  10ebd0:	e3e0200a 	mvn	r2, #10
  10ebd4:	e5c32004 	strb	r2, [r3, #4]
    if (msg->conn->pcb.tcp != NULL) {
  10ebd8:	e51b3008 	ldr	r3, [fp, #-8]
  10ebdc:	e5933000 	ldr	r3, [r3]
  10ebe0:	e5933008 	ldr	r3, [r3, #8]
  10ebe4:	e3530000 	cmp	r3, #0
  10ebe8:	0a00007b 	beq	10eddc <lwip_netconn_do_listen+0x254>
      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
  10ebec:	e51b3008 	ldr	r3, [fp, #-8]
  10ebf0:	e5933000 	ldr	r3, [r3]
  10ebf4:	e5933000 	ldr	r3, [r3]
  10ebf8:	e20330f0 	and	r3, r3, #240	; 0xf0
  10ebfc:	e3530010 	cmp	r3, #16
  10ec00:	1a000072 	bne	10edd0 <lwip_netconn_do_listen+0x248>
        if (msg->conn->state == NETCONN_NONE) {
  10ec04:	e51b3008 	ldr	r3, [fp, #-8]
  10ec08:	e5933000 	ldr	r3, [r3]
  10ec0c:	e5933004 	ldr	r3, [r3, #4]
  10ec10:	e3530000 	cmp	r3, #0
  10ec14:	1a000064 	bne	10edac <lwip_netconn_do_listen+0x224>
          struct tcp_pcb* lpcb;
          if (msg->conn->pcb.tcp->state != CLOSED) {
  10ec18:	e51b3008 	ldr	r3, [fp, #-8]
  10ec1c:	e5933000 	ldr	r3, [r3]
  10ec20:	e5933008 	ldr	r3, [r3, #8]
  10ec24:	e5933014 	ldr	r3, [r3, #20]
  10ec28:	e3530000 	cmp	r3, #0
  10ec2c:	0a000003 	beq	10ec40 <lwip_netconn_do_listen+0xb8>
            /* connection is not closed, cannot listen */
            msg->err = ERR_VAL;
  10ec30:	e51b3008 	ldr	r3, [fp, #-8]
  10ec34:	e3e02005 	mvn	r2, #5
  10ec38:	e5c32004 	strb	r2, [r3, #4]
  10ec3c:	ea000066 	b	10eddc <lwip_netconn_do_listen+0x254>
            err_t err;
            u8_t backlog;
#if TCP_LISTEN_BACKLOG
            backlog = msg->msg.lb.backlog;
#else  /* TCP_LISTEN_BACKLOG */
            backlog = TCP_DEFAULT_LISTEN_BACKLOG;
  10ec40:	e3e03000 	mvn	r3, #0
  10ec44:	e54b3009 	strb	r3, [fp, #-9]
              IP_SET_TYPE_VAL(msg->conn->pcb.tcp->local_ip,  IPADDR_TYPE_ANY);
              IP_SET_TYPE_VAL(msg->conn->pcb.tcp->remote_ip, IPADDR_TYPE_ANY);
            }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

            lpcb = tcp_listen_with_backlog_and_err(msg->conn->pcb.tcp, backlog, &err);
  10ec48:	e51b3008 	ldr	r3, [fp, #-8]
  10ec4c:	e5933000 	ldr	r3, [r3]
  10ec50:	e5933008 	ldr	r3, [r3, #8]
  10ec54:	e24b2011 	sub	r2, fp, #17
  10ec58:	e55b1009 	ldrb	r1, [fp, #-9]
  10ec5c:	e1a00003 	mov	r0, r3
  10ec60:	eb003ca6 	bl	11df00 <tcp_listen_with_backlog_and_err>
  10ec64:	e50b0010 	str	r0, [fp, #-16]

            if (lpcb == NULL) {
  10ec68:	e51b3010 	ldr	r3, [fp, #-16]
  10ec6c:	e3530000 	cmp	r3, #0
  10ec70:	1a000003 	bne	10ec84 <lwip_netconn_do_listen+0xfc>
              /* in this case, the old pcb is still allocated */
              msg->err = err;
  10ec74:	e15b21d1 	ldrsb	r2, [fp, #-17]	; 0xffffffef
  10ec78:	e51b3008 	ldr	r3, [fp, #-8]
  10ec7c:	e5c32004 	strb	r2, [r3, #4]
  10ec80:	ea000055 	b	10eddc <lwip_netconn_do_listen+0x254>
            } else {
              /* delete the recvmbox and allocate the acceptmbox */
              if (sys_mbox_valid(&msg->conn->recvmbox)) {
  10ec84:	e51b3008 	ldr	r3, [fp, #-8]
  10ec88:	e5933000 	ldr	r3, [r3]
  10ec8c:	e2833014 	add	r3, r3, #20
  10ec90:	e1a00003 	mov	r0, r3
  10ec94:	ebfff0af 	bl	10af58 <sys_mbox_valid>
  10ec98:	e1a03000 	mov	r3, r0
  10ec9c:	e3530000 	cmp	r3, #0
  10eca0:	0a000009 	beq	10eccc <lwip_netconn_do_listen+0x144>
                /** @todo: should we drain the recvmbox here? */
                sys_mbox_free(&msg->conn->recvmbox);
  10eca4:	e51b3008 	ldr	r3, [fp, #-8]
  10eca8:	e5933000 	ldr	r3, [r3]
  10ecac:	e2833014 	add	r3, r3, #20
  10ecb0:	e1a00003 	mov	r0, r3
  10ecb4:	ebffefe9 	bl	10ac60 <sys_mbox_free>
                sys_mbox_set_invalid(&msg->conn->recvmbox);
  10ecb8:	e51b3008 	ldr	r3, [fp, #-8]
  10ecbc:	e5933000 	ldr	r3, [r3]
  10ecc0:	e2833014 	add	r3, r3, #20
  10ecc4:	e1a00003 	mov	r0, r3
  10ecc8:	ebfff0ac 	bl	10af80 <sys_mbox_set_invalid>
              }
              msg->err = ERR_OK;
  10eccc:	e51b3008 	ldr	r3, [fp, #-8]
  10ecd0:	e3a02000 	mov	r2, #0
  10ecd4:	e5c32004 	strb	r2, [r3, #4]
              if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
  10ecd8:	e51b3008 	ldr	r3, [fp, #-8]
  10ecdc:	e5933000 	ldr	r3, [r3]
  10ece0:	e2833018 	add	r3, r3, #24
  10ece4:	e1a00003 	mov	r0, r3
  10ece8:	ebfff09a 	bl	10af58 <sys_mbox_valid>
  10ecec:	e1a03000 	mov	r3, r0
  10ecf0:	e3530000 	cmp	r3, #0
  10ecf4:	1a000009 	bne	10ed20 <lwip_netconn_do_listen+0x198>
                msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
  10ecf8:	e51b3008 	ldr	r3, [fp, #-8]
  10ecfc:	e5933000 	ldr	r3, [r3]
  10ed00:	e2833018 	add	r3, r3, #24
  10ed04:	e3a0100a 	mov	r1, #10
  10ed08:	e1a00003 	mov	r0, r3
  10ed0c:	ebffef8e 	bl	10ab4c <sys_mbox_new>
  10ed10:	e1a03000 	mov	r3, r0
  10ed14:	e1a02003 	mov	r2, r3
  10ed18:	e51b3008 	ldr	r3, [fp, #-8]
  10ed1c:	e5c32004 	strb	r2, [r3, #4]
              }
              if (msg->err == ERR_OK) {
  10ed20:	e51b3008 	ldr	r3, [fp, #-8]
  10ed24:	e1d330d4 	ldrsb	r3, [r3, #4]
  10ed28:	e3530000 	cmp	r3, #0
  10ed2c:	1a000017 	bne	10ed90 <lwip_netconn_do_listen+0x208>
                msg->conn->state = NETCONN_LISTEN;
  10ed30:	e51b3008 	ldr	r3, [fp, #-8]
  10ed34:	e5933000 	ldr	r3, [r3]
  10ed38:	e3a02002 	mov	r2, #2
  10ed3c:	e5832004 	str	r2, [r3, #4]
                msg->conn->pcb.tcp = lpcb;
  10ed40:	e51b3008 	ldr	r3, [fp, #-8]
  10ed44:	e5933000 	ldr	r3, [r3]
  10ed48:	e51b2010 	ldr	r2, [fp, #-16]
  10ed4c:	e5832008 	str	r2, [r3, #8]
                tcp_arg(msg->conn->pcb.tcp, msg->conn);
  10ed50:	e51b3008 	ldr	r3, [fp, #-8]
  10ed54:	e5933000 	ldr	r3, [r3]
  10ed58:	e5932008 	ldr	r2, [r3, #8]
  10ed5c:	e51b3008 	ldr	r3, [fp, #-8]
  10ed60:	e5933000 	ldr	r3, [r3]
  10ed64:	e1a01003 	mov	r1, r3
  10ed68:	e1a00002 	mov	r0, r2
  10ed6c:	eb0043fd 	bl	11fd68 <tcp_arg>
                tcp_accept(msg->conn->pcb.tcp, accept_function);
  10ed70:	e51b3008 	ldr	r3, [fp, #-8]
  10ed74:	e5933000 	ldr	r3, [r3]
  10ed78:	e5933008 	ldr	r3, [r3, #8]
  10ed7c:	e30d1200 	movw	r1, #53760	; 0xd200
  10ed80:	e3401010 	movt	r1, #16
  10ed84:	e1a00003 	mov	r0, r3
  10ed88:	eb004450 	bl	11fed0 <tcp_accept>
  10ed8c:	ea000012 	b	10eddc <lwip_netconn_do_listen+0x254>
              } else {
                /* since the old pcb is already deallocated, free lpcb now */
                tcp_close(lpcb);
  10ed90:	e51b0010 	ldr	r0, [fp, #-16]
  10ed94:	eb003aac 	bl	11d84c <tcp_close>
                msg->conn->pcb.tcp = NULL;
  10ed98:	e51b3008 	ldr	r3, [fp, #-8]
  10ed9c:	e5933000 	ldr	r3, [r3]
  10eda0:	e3a02000 	mov	r2, #0
  10eda4:	e5832008 	str	r2, [r3, #8]
  10eda8:	ea00000b 	b	10eddc <lwip_netconn_do_listen+0x254>
              }
            }
          }
        } else if (msg->conn->state == NETCONN_LISTEN) {
  10edac:	e51b3008 	ldr	r3, [fp, #-8]
  10edb0:	e5933000 	ldr	r3, [r3]
  10edb4:	e5933004 	ldr	r3, [r3, #4]
  10edb8:	e3530002 	cmp	r3, #2
  10edbc:	1a000006 	bne	10eddc <lwip_netconn_do_listen+0x254>
          /* already listening, allow updating of the backlog */
          msg->err = ERR_OK;
  10edc0:	e51b3008 	ldr	r3, [fp, #-8]
  10edc4:	e3a02000 	mov	r2, #0
  10edc8:	e5c32004 	strb	r2, [r3, #4]
  10edcc:	ea000002 	b	10eddc <lwip_netconn_do_listen+0x254>
          tcp_backlog_set(msg->conn->pcb.tcp, msg->msg.lb.backlog);
        }
      } else {
        msg->err = ERR_ARG;
  10edd0:	e51b3008 	ldr	r3, [fp, #-8]
  10edd4:	e3e0200f 	mvn	r2, #15
  10edd8:	e5c32004 	strb	r2, [r3, #4]
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  10eddc:	e51b3008 	ldr	r3, [fp, #-8]
  10ede0:	e5933000 	ldr	r3, [r3]
  10ede4:	e3530000 	cmp	r3, #0
  10ede8:	0a00000b 	beq	10ee1c <lwip_netconn_do_listen+0x294>
  10edec:	ebffcd12 	bl	10223c <rt_enter_critical>
  10edf0:	e51b3008 	ldr	r3, [fp, #-8]
  10edf4:	e5933000 	ldr	r3, [r3]
  10edf8:	e1d330dc 	ldrsb	r3, [r3, #12]
  10edfc:	e373000c 	cmn	r3, #12
  10ee00:	ba000004 	blt	10ee18 <lwip_netconn_do_listen+0x290>
  10ee04:	e51b3008 	ldr	r3, [fp, #-8]
  10ee08:	e5933000 	ldr	r3, [r3]
  10ee0c:	e51b2008 	ldr	r2, [fp, #-8]
  10ee10:	e1d220d4 	ldrsb	r2, [r2, #4]
  10ee14:	e5c3200c 	strb	r2, [r3, #12]
  10ee18:	ebffcd0d 	bl	102254 <rt_exit_critical>
}
  10ee1c:	e320f000 	nop	{0}
  10ee20:	e24bd004 	sub	sp, fp, #4
  10ee24:	e8bd8800 	pop	{fp, pc}

0010ee28 <lwip_netconn_do_send>:
 *
 * @param m the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_send(void *m)
{
  10ee28:	e92d4800 	push	{fp, lr}
  10ee2c:	e28db004 	add	fp, sp, #4
  10ee30:	e24dd010 	sub	sp, sp, #16
  10ee34:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10ee38:	e51b3010 	ldr	r3, [fp, #-16]
  10ee3c:	e50b3008 	str	r3, [fp, #-8]

  if (ERR_IS_FATAL(msg->conn->last_err)) {
  10ee40:	e51b3008 	ldr	r3, [fp, #-8]
  10ee44:	e5933000 	ldr	r3, [r3]
  10ee48:	e1d330dc 	ldrsb	r3, [r3, #12]
  10ee4c:	e373000c 	cmn	r3, #12
  10ee50:	aa000005 	bge	10ee6c <lwip_netconn_do_send+0x44>
    msg->err = msg->conn->last_err;
  10ee54:	e51b3008 	ldr	r3, [fp, #-8]
  10ee58:	e5933000 	ldr	r3, [r3]
  10ee5c:	e1d320dc 	ldrsb	r2, [r3, #12]
  10ee60:	e51b3008 	ldr	r3, [fp, #-8]
  10ee64:	e5c32004 	strb	r2, [r3, #4]
  10ee68:	ea00005e 	b	10efe8 <lwip_netconn_do_send+0x1c0>
  } else {
    msg->err = ERR_CONN;
  10ee6c:	e51b3008 	ldr	r3, [fp, #-8]
  10ee70:	e3e0200a 	mvn	r2, #10
  10ee74:	e5c32004 	strb	r2, [r3, #4]
    if (msg->conn->pcb.tcp != NULL) {
  10ee78:	e51b3008 	ldr	r3, [fp, #-8]
  10ee7c:	e5933000 	ldr	r3, [r3]
  10ee80:	e5933008 	ldr	r3, [r3, #8]
  10ee84:	e3530000 	cmp	r3, #0
  10ee88:	0a000055 	beq	10efe4 <lwip_netconn_do_send+0x1bc>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  10ee8c:	e51b3008 	ldr	r3, [fp, #-8]
  10ee90:	e5933000 	ldr	r3, [r3]
  10ee94:	e5933000 	ldr	r3, [r3]
  10ee98:	e20330f0 	and	r3, r3, #240	; 0xf0
  10ee9c:	e3530020 	cmp	r3, #32
  10eea0:	0a00002a 	beq	10ef50 <lwip_netconn_do_send+0x128>
  10eea4:	e3530040 	cmp	r3, #64	; 0x40
  10eea8:	0a000000 	beq	10eeb0 <lwip_netconn_do_send+0x88>
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
#endif /* LWIP_UDP */
      default:
        break;
  10eeac:	ea00004d 	b	10efe8 <lwip_netconn_do_send+0x1c0>
        if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
  10eeb0:	e51b3008 	ldr	r3, [fp, #-8]
  10eeb4:	e5933008 	ldr	r3, [r3, #8]
  10eeb8:	e2833008 	add	r3, r3, #8
  10eebc:	e3530000 	cmp	r3, #0
  10eec0:	0a000004 	beq	10eed8 <lwip_netconn_do_send+0xb0>
  10eec4:	e51b3008 	ldr	r3, [fp, #-8]
  10eec8:	e5933008 	ldr	r3, [r3, #8]
  10eecc:	e5933008 	ldr	r3, [r3, #8]
  10eed0:	e3530000 	cmp	r3, #0
  10eed4:	1a00000d 	bne	10ef10 <lwip_netconn_do_send+0xe8>
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  10eed8:	e51b3008 	ldr	r3, [fp, #-8]
  10eedc:	e5933000 	ldr	r3, [r3]
  10eee0:	e5932008 	ldr	r2, [r3, #8]
  10eee4:	e51b3008 	ldr	r3, [fp, #-8]
  10eee8:	e5933008 	ldr	r3, [r3, #8]
  10eeec:	e5933000 	ldr	r3, [r3]
  10eef0:	e1a01003 	mov	r1, r3
  10eef4:	e1a00002 	mov	r0, r2
  10eef8:	eb00367a 	bl	11c8e8 <raw_send>
  10eefc:	e1a03000 	mov	r3, r0
  10ef00:	e1a02003 	mov	r2, r3
  10ef04:	e51b3008 	ldr	r3, [fp, #-8]
  10ef08:	e5c32004 	strb	r2, [r3, #4]
        break;
  10ef0c:	ea000035 	b	10efe8 <lwip_netconn_do_send+0x1c0>
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
  10ef10:	e51b3008 	ldr	r3, [fp, #-8]
  10ef14:	e5933000 	ldr	r3, [r3]
  10ef18:	e5930008 	ldr	r0, [r3, #8]
  10ef1c:	e51b3008 	ldr	r3, [fp, #-8]
  10ef20:	e5933008 	ldr	r3, [r3, #8]
  10ef24:	e5931000 	ldr	r1, [r3]
  10ef28:	e51b3008 	ldr	r3, [fp, #-8]
  10ef2c:	e5933008 	ldr	r3, [r3, #8]
  10ef30:	e2833008 	add	r3, r3, #8
  10ef34:	e1a02003 	mov	r2, r3
  10ef38:	eb0035dc 	bl	11c6b0 <raw_sendto>
  10ef3c:	e1a03000 	mov	r3, r0
  10ef40:	e1a02003 	mov	r2, r3
  10ef44:	e51b3008 	ldr	r3, [fp, #-8]
  10ef48:	e5c32004 	strb	r2, [r3, #4]
        break;
  10ef4c:	ea000025 	b	10efe8 <lwip_netconn_do_send+0x1c0>
        if (ip_addr_isany_val(msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
  10ef50:	e51b3008 	ldr	r3, [fp, #-8]
  10ef54:	e5933008 	ldr	r3, [r3, #8]
  10ef58:	e5933008 	ldr	r3, [r3, #8]
  10ef5c:	e3530000 	cmp	r3, #0
  10ef60:	1a00000d 	bne	10ef9c <lwip_netconn_do_send+0x174>
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  10ef64:	e51b3008 	ldr	r3, [fp, #-8]
  10ef68:	e5933000 	ldr	r3, [r3]
  10ef6c:	e5932008 	ldr	r2, [r3, #8]
  10ef70:	e51b3008 	ldr	r3, [fp, #-8]
  10ef74:	e5933008 	ldr	r3, [r3, #8]
  10ef78:	e5933000 	ldr	r3, [r3]
  10ef7c:	e1a01003 	mov	r1, r3
  10ef80:	e1a00002 	mov	r0, r2
  10ef84:	eb0064d3 	bl	1282d8 <udp_send>
  10ef88:	e1a03000 	mov	r3, r0
  10ef8c:	e1a02003 	mov	r2, r3
  10ef90:	e51b3008 	ldr	r3, [fp, #-8]
  10ef94:	e5c32004 	strb	r2, [r3, #4]
        break;
  10ef98:	ea000012 	b	10efe8 <lwip_netconn_do_send+0x1c0>
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
  10ef9c:	e51b3008 	ldr	r3, [fp, #-8]
  10efa0:	e5933000 	ldr	r3, [r3]
  10efa4:	e5930008 	ldr	r0, [r3, #8]
  10efa8:	e51b3008 	ldr	r3, [fp, #-8]
  10efac:	e5933008 	ldr	r3, [r3, #8]
  10efb0:	e5931000 	ldr	r1, [r3]
  10efb4:	e51b3008 	ldr	r3, [fp, #-8]
  10efb8:	e5933008 	ldr	r3, [r3, #8]
  10efbc:	e2832008 	add	r2, r3, #8
  10efc0:	e51b3008 	ldr	r3, [fp, #-8]
  10efc4:	e5933008 	ldr	r3, [r3, #8]
  10efc8:	e1d330bc 	ldrh	r3, [r3, #12]
  10efcc:	eb0064d6 	bl	12832c <udp_sendto>
  10efd0:	e1a03000 	mov	r3, r0
  10efd4:	e1a02003 	mov	r2, r3
  10efd8:	e51b3008 	ldr	r3, [fp, #-8]
  10efdc:	e5c32004 	strb	r2, [r3, #4]
        break;
  10efe0:	ea000000 	b	10efe8 <lwip_netconn_do_send+0x1c0>
      }
    }
  10efe4:	e320f000 	nop	{0}
  }
  TCPIP_APIMSG_ACK(msg);
  10efe8:	e51b3008 	ldr	r3, [fp, #-8]
  10efec:	e5933000 	ldr	r3, [r3]
  10eff0:	e3530000 	cmp	r3, #0
  10eff4:	0a00000b 	beq	10f028 <lwip_netconn_do_send+0x200>
  10eff8:	ebffcc8f 	bl	10223c <rt_enter_critical>
  10effc:	e51b3008 	ldr	r3, [fp, #-8]
  10f000:	e5933000 	ldr	r3, [r3]
  10f004:	e1d330dc 	ldrsb	r3, [r3, #12]
  10f008:	e373000c 	cmn	r3, #12
  10f00c:	ba000004 	blt	10f024 <lwip_netconn_do_send+0x1fc>
  10f010:	e51b3008 	ldr	r3, [fp, #-8]
  10f014:	e5933000 	ldr	r3, [r3]
  10f018:	e51b2008 	ldr	r2, [fp, #-8]
  10f01c:	e1d220d4 	ldrsb	r2, [r2, #4]
  10f020:	e5c3200c 	strb	r2, [r3, #12]
  10f024:	ebffcc8a 	bl	102254 <rt_exit_critical>
}
  10f028:	e320f000 	nop	{0}
  10f02c:	e24bd004 	sub	sp, fp, #4
  10f030:	e8bd8800 	pop	{fp, pc}

0010f034 <lwip_netconn_do_recv>:
 *
 * @param m the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_recv(void *m)
{
  10f034:	e92d4800 	push	{fp, lr}
  10f038:	e28db004 	add	fp, sp, #4
  10f03c:	e24dd018 	sub	sp, sp, #24
  10f040:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct api_msg *msg = (struct api_msg*)m;
  10f044:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10f048:	e50b300c 	str	r3, [fp, #-12]

  msg->err = ERR_OK;
  10f04c:	e51b300c 	ldr	r3, [fp, #-12]
  10f050:	e3a02000 	mov	r2, #0
  10f054:	e5c32004 	strb	r2, [r3, #4]
  if (msg->conn->pcb.tcp != NULL) {
  10f058:	e51b300c 	ldr	r3, [fp, #-12]
  10f05c:	e5933000 	ldr	r3, [r3]
  10f060:	e5933008 	ldr	r3, [r3, #8]
  10f064:	e3530000 	cmp	r3, #0
  10f068:	0a00001e 	beq	10f0e8 <lwip_netconn_do_recv+0xb4>
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
  10f06c:	e51b300c 	ldr	r3, [fp, #-12]
  10f070:	e5933000 	ldr	r3, [r3]
  10f074:	e5933000 	ldr	r3, [r3]
  10f078:	e20330f0 	and	r3, r3, #240	; 0xf0
  10f07c:	e3530010 	cmp	r3, #16
  10f080:	1a000018 	bne	10f0e8 <lwip_netconn_do_recv+0xb4>
      u32_t remaining = msg->msg.r.len;
  10f084:	e51b300c 	ldr	r3, [fp, #-12]
  10f088:	e5933008 	ldr	r3, [r3, #8]
  10f08c:	e50b3008 	str	r3, [fp, #-8]
      do {
        u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
  10f090:	e51b3008 	ldr	r3, [fp, #-8]
  10f094:	e3530801 	cmp	r3, #65536	; 0x10000
  10f098:	2a000002 	bcs	10f0a8 <lwip_netconn_do_recv+0x74>
  10f09c:	e51b3008 	ldr	r3, [fp, #-8]
  10f0a0:	e6ff3073 	uxth	r3, r3
  10f0a4:	ea000000 	b	10f0ac <lwip_netconn_do_recv+0x78>
  10f0a8:	e30f3fff 	movw	r3, #65535	; 0xffff
  10f0ac:	e14b30be 	strh	r3, [fp, #-14]
        tcp_recved(msg->conn->pcb.tcp, recved);
  10f0b0:	e51b300c 	ldr	r3, [fp, #-12]
  10f0b4:	e5933000 	ldr	r3, [r3]
  10f0b8:	e5933008 	ldr	r3, [r3, #8]
  10f0bc:	e15b20be 	ldrh	r2, [fp, #-14]
  10f0c0:	e1a01002 	mov	r1, r2
  10f0c4:	e1a00003 	mov	r0, r3
  10f0c8:	eb003c85 	bl	11e2e4 <tcp_recved>
        remaining -= recved;
  10f0cc:	e15b30be 	ldrh	r3, [fp, #-14]
  10f0d0:	e51b2008 	ldr	r2, [fp, #-8]
  10f0d4:	e0423003 	sub	r3, r2, r3
  10f0d8:	e50b3008 	str	r3, [fp, #-8]
      } while (remaining != 0);
  10f0dc:	e51b3008 	ldr	r3, [fp, #-8]
  10f0e0:	e3530000 	cmp	r3, #0
  10f0e4:	1affffe9 	bne	10f090 <lwip_netconn_do_recv+0x5c>
    }
  }
  TCPIP_APIMSG_ACK(msg);
  10f0e8:	e51b300c 	ldr	r3, [fp, #-12]
  10f0ec:	e5933000 	ldr	r3, [r3]
  10f0f0:	e3530000 	cmp	r3, #0
  10f0f4:	0a00000b 	beq	10f128 <lwip_netconn_do_recv+0xf4>
  10f0f8:	ebffcc4f 	bl	10223c <rt_enter_critical>
  10f0fc:	e51b300c 	ldr	r3, [fp, #-12]
  10f100:	e5933000 	ldr	r3, [r3]
  10f104:	e1d330dc 	ldrsb	r3, [r3, #12]
  10f108:	e373000c 	cmn	r3, #12
  10f10c:	ba000004 	blt	10f124 <lwip_netconn_do_recv+0xf0>
  10f110:	e51b300c 	ldr	r3, [fp, #-12]
  10f114:	e5933000 	ldr	r3, [r3]
  10f118:	e51b200c 	ldr	r2, [fp, #-12]
  10f11c:	e1d220d4 	ldrsb	r2, [r2, #4]
  10f120:	e5c3200c 	strb	r2, [r3, #12]
  10f124:	ebffcc4a 	bl	102254 <rt_exit_critical>
}
  10f128:	e320f000 	nop	{0}
  10f12c:	e24bd004 	sub	sp, fp, #4
  10f130:	e8bd8800 	pop	{fp, pc}

0010f134 <lwip_netconn_do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
lwip_netconn_do_writemore(struct netconn *conn  WRITE_DELAYED_PARAM)
{
  10f134:	e92d4800 	push	{fp, lr}
  10f138:	e28db004 	add	fp, sp, #4
  10f13c:	e24dd020 	sub	sp, sp, #32
  10f140:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  10f144:	e1a03001 	mov	r3, r1
  10f148:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
  err_t err;
  const void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  10f14c:	e3a03000 	mov	r3, #0
  10f150:	e54b3009 	strb	r3, [fp, #-9]
  size_t diff;
  u8_t dontblock;
  u8_t apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  10f154:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f158:	e3530000 	cmp	r3, #0
  10f15c:	1a000006 	bne	10f17c <lwip_netconn_do_writemore+0x48>
  10f160:	e30609b4 	movw	r0, #27060	; 0x69b4
  10f164:	e3400014 	movt	r0, #20
  10f168:	ebffcfe9 	bl	103114 <rt_kprintf>
  10f16c:	e30015dd 	movw	r1, #1501	; 0x5dd
  10f170:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f174:	e3400014 	movt	r0, #20
  10f178:	ebffefbf 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  10f17c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f180:	e5933004 	ldr	r3, [r3, #4]
  10f184:	e3530001 	cmp	r3, #1
  10f188:	0a000006 	beq	10f1a8 <lwip_netconn_do_writemore+0x74>
  10f18c:	e3060c94 	movw	r0, #27796	; 0x6c94
  10f190:	e3400014 	movt	r0, #20
  10f194:	ebffcfde 	bl	103114 <rt_kprintf>
  10f198:	e30015de 	movw	r1, #1502	; 0x5de
  10f19c:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f1a0:	e3400014 	movt	r0, #20
  10f1a4:	ebffefb4 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
  10f1a8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f1ac:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f1b0:	e3530000 	cmp	r3, #0
  10f1b4:	1a000006 	bne	10f1d4 <lwip_netconn_do_writemore+0xa0>
  10f1b8:	e30609c4 	movw	r0, #27076	; 0x69c4
  10f1bc:	e3400014 	movt	r0, #20
  10f1c0:	ebffcfd3 	bl	103114 <rt_kprintf>
  10f1c4:	e30015df 	movw	r1, #1503	; 0x5df
  10f1c8:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f1cc:	e3400014 	movt	r0, #20
  10f1d0:	ebffefa9 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  10f1d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f1d8:	e5933008 	ldr	r3, [r3, #8]
  10f1dc:	e3530000 	cmp	r3, #0
  10f1e0:	1a000006 	bne	10f200 <lwip_netconn_do_writemore+0xcc>
  10f1e4:	e3060cb4 	movw	r0, #27828	; 0x6cb4
  10f1e8:	e3400014 	movt	r0, #20
  10f1ec:	ebffcfc8 	bl	103114 <rt_kprintf>
  10f1f0:	e3a01e5e 	mov	r1, #1504	; 0x5e0
  10f1f4:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f1f8:	e3400014 	movt	r0, #20
  10f1fc:	ebffef9e 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
  10f200:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f204:	e5932034 	ldr	r2, [r3, #52]	; 0x34
  10f208:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f20c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f210:	e593300c 	ldr	r3, [r3, #12]
  10f214:	e1520003 	cmp	r2, r3
  10f218:	3a000006 	bcc	10f238 <lwip_netconn_do_writemore+0x104>
  10f21c:	e3060ccc 	movw	r0, #27852	; 0x6ccc
  10f220:	e3400014 	movt	r0, #20
  10f224:	ebffcfba 	bl	103114 <rt_kprintf>
  10f228:	e30015e2 	movw	r1, #1506	; 0x5e2
  10f22c:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f230:	e3400014 	movt	r0, #20
  10f234:	ebffef90 	bl	10b07c <sys_arch_assert>
    conn->write_offset < conn->current_msg->msg.w.len);

  apiflags = conn->current_msg->msg.w.apiflags;
  10f238:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f23c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f240:	e5d33010 	ldrb	r3, [r3, #16]
  10f244:	e54b300a 	strb	r3, [fp, #-10]
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
  10f248:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f24c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10f250:	e2033002 	and	r3, r3, #2
  10f254:	e3530000 	cmp	r3, #0
  10f258:	1a000003 	bne	10f26c <lwip_netconn_do_writemore+0x138>
  10f25c:	e55b300a 	ldrb	r3, [fp, #-10]
  10f260:	e2033004 	and	r3, r3, #4
  10f264:	e3530000 	cmp	r3, #0
  10f268:	0a000001 	beq	10f274 <lwip_netconn_do_writemore+0x140>
  10f26c:	e3a03001 	mov	r3, #1
  10f270:	ea000000 	b	10f278 <lwip_netconn_do_writemore+0x144>
  10f274:	e3a03000 	mov	r3, #0
  10f278:	e54b300b 	strb	r3, [fp, #-11]

#if LWIP_SO_SNDTIMEO
  if ((conn->send_timeout != 0) &&
  10f27c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f280:	e5933020 	ldr	r3, [r3, #32]
  10f284:	e3530000 	cmp	r3, #0
  10f288:	0a000022 	beq	10f318 <lwip_netconn_do_writemore+0x1e4>
      ((s32_t)(sys_now() - conn->current_msg->msg.w.time_started) >= conn->send_timeout)) {
  10f28c:	ebffef93 	bl	10b0e0 <sys_now>
  10f290:	e1a02000 	mov	r2, r0
  10f294:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f298:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f29c:	e5933014 	ldr	r3, [r3, #20]
  10f2a0:	e0423003 	sub	r3, r2, r3
  10f2a4:	e1a02003 	mov	r2, r3
  10f2a8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f2ac:	e5933020 	ldr	r3, [r3, #32]
  if ((conn->send_timeout != 0) &&
  10f2b0:	e1520003 	cmp	r2, r3
  10f2b4:	ba000017 	blt	10f318 <lwip_netconn_do_writemore+0x1e4>
    write_finished = 1;
  10f2b8:	e3a03001 	mov	r3, #1
  10f2bc:	e54b3009 	strb	r3, [fp, #-9]
    if (conn->write_offset == 0) {
  10f2c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f2c4:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  10f2c8:	e3530000 	cmp	r3, #0
  10f2cc:	1a000006 	bne	10f2ec <lwip_netconn_do_writemore+0x1b8>
      /* nothing has been written */
      err = ERR_WOULDBLOCK;
  10f2d0:	e3e03006 	mvn	r3, #6
  10f2d4:	e54b3005 	strb	r3, [fp, #-5]
      conn->current_msg->msg.w.len = 0;
  10f2d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f2dc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f2e0:	e3a02000 	mov	r2, #0
  10f2e4:	e583200c 	str	r2, [r3, #12]
    if (conn->write_offset == 0) {
  10f2e8:	ea0000df 	b	10f66c <lwip_netconn_do_writemore+0x538>
    } else {
      /* partial write */
      err = ERR_OK;
  10f2ec:	e3a03000 	mov	r3, #0
  10f2f0:	e54b3005 	strb	r3, [fp, #-5]
      conn->current_msg->msg.w.len = conn->write_offset;
  10f2f4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f2f8:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f2fc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  10f300:	e5922034 	ldr	r2, [r2, #52]	; 0x34
  10f304:	e583200c 	str	r2, [r3, #12]
      conn->write_offset = 0;
  10f308:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f30c:	e3a02000 	mov	r2, #0
  10f310:	e5832034 	str	r2, [r3, #52]	; 0x34
    if (conn->write_offset == 0) {
  10f314:	ea0000d4 	b	10f66c <lwip_netconn_do_writemore+0x538>
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (const u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
  10f318:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f31c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f320:	e5932008 	ldr	r2, [r3, #8]
  10f324:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f328:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  10f32c:	e0823003 	add	r3, r2, r3
  10f330:	e50b3010 	str	r3, [fp, #-16]
    diff = conn->current_msg->msg.w.len - conn->write_offset;
  10f334:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f338:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f33c:	e593200c 	ldr	r2, [r3, #12]
  10f340:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f344:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  10f348:	e0423003 	sub	r3, r2, r3
  10f34c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    if (diff > 0xffffUL) { /* max_u16_t */
  10f350:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10f354:	e3530801 	cmp	r3, #65536	; 0x10000
  10f358:	3a000005 	bcc	10f374 <lwip_netconn_do_writemore+0x240>
      len = 0xffff;
  10f35c:	e3e03000 	mvn	r3, #0
  10f360:	e14b30b8 	strh	r3, [fp, #-8]
      apiflags |= TCP_WRITE_FLAG_MORE;
  10f364:	e55b300a 	ldrb	r3, [fp, #-10]
  10f368:	e3833002 	orr	r3, r3, #2
  10f36c:	e54b300a 	strb	r3, [fp, #-10]
  10f370:	ea000001 	b	10f37c <lwip_netconn_do_writemore+0x248>
    } else {
      len = (u16_t)diff;
  10f374:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10f378:	e14b30b8 	strh	r3, [fp, #-8]
    }
    available = tcp_sndbuf(conn->pcb.tcp);
  10f37c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f380:	e5933008 	ldr	r3, [r3, #8]
  10f384:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
  10f388:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
    if (available < len) {
  10f38c:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  10f390:	e15b30b8 	ldrh	r3, [fp, #-8]
  10f394:	e1520003 	cmp	r2, r3
  10f398:	2a00000d 	bcs	10f3d4 <lwip_netconn_do_writemore+0x2a0>
      /* don't try to write more than sendbuf */
      len = available;
  10f39c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  10f3a0:	e14b30b8 	strh	r3, [fp, #-8]
      if (dontblock) {
  10f3a4:	e55b300b 	ldrb	r3, [fp, #-11]
  10f3a8:	e3530000 	cmp	r3, #0
  10f3ac:	0a000005 	beq	10f3c8 <lwip_netconn_do_writemore+0x294>
        if (!len) {
  10f3b0:	e15b30b8 	ldrh	r3, [fp, #-8]
  10f3b4:	e3530000 	cmp	r3, #0
  10f3b8:	1a000005 	bne	10f3d4 <lwip_netconn_do_writemore+0x2a0>
          err = ERR_WOULDBLOCK;
  10f3bc:	e3e03006 	mvn	r3, #6
  10f3c0:	e54b3005 	strb	r3, [fp, #-5]
          goto err_mem;
  10f3c4:	ea000021 	b	10f450 <lwip_netconn_do_writemore+0x31c>
        }
      } else {
        apiflags |= TCP_WRITE_FLAG_MORE;
  10f3c8:	e55b300a 	ldrb	r3, [fp, #-10]
  10f3cc:	e3833002 	orr	r3, r3, #2
  10f3d0:	e54b300a 	strb	r3, [fp, #-10]
      }
    }
    LWIP_ASSERT("lwip_netconn_do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
  10f3d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f3d8:	e5932034 	ldr	r2, [r3, #52]	; 0x34
  10f3dc:	e15b30b8 	ldrh	r3, [fp, #-8]
  10f3e0:	e0822003 	add	r2, r2, r3
  10f3e4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f3e8:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f3ec:	e593300c 	ldr	r3, [r3, #12]
  10f3f0:	e1520003 	cmp	r2, r3
  10f3f4:	9a000006 	bls	10f414 <lwip_netconn_do_writemore+0x2e0>
  10f3f8:	e3060d00 	movw	r0, #27904	; 0x6d00
  10f3fc:	e3400014 	movt	r0, #20
  10f400:	ebffcf43 	bl	103114 <rt_kprintf>
  10f404:	e300160d 	movw	r1, #1549	; 0x60d
  10f408:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f40c:	e3400014 	movt	r0, #20
  10f410:	ebffef19 	bl	10b07c <sys_arch_assert>
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
  10f414:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f418:	e5930008 	ldr	r0, [r3, #8]
  10f41c:	e55b300a 	ldrb	r3, [fp, #-10]
  10f420:	e15b20b8 	ldrh	r2, [fp, #-8]
  10f424:	e51b1010 	ldr	r1, [fp, #-16]
  10f428:	eb00571a 	bl	125098 <tcp_write>
  10f42c:	e1a03000 	mov	r3, r0
  10f430:	e54b3005 	strb	r3, [fp, #-5]
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
  10f434:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10f438:	e3530000 	cmp	r3, #0
  10f43c:	0a000002 	beq	10f44c <lwip_netconn_do_writemore+0x318>
  10f440:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10f444:	e3730001 	cmn	r3, #1
  10f448:	1a00002e 	bne	10f508 <lwip_netconn_do_writemore+0x3d4>
err_mem:
  10f44c:	e320f000 	nop	{0}
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
  10f450:	e55b300b 	ldrb	r3, [fp, #-11]
  10f454:	e3530000 	cmp	r3, #0
  10f458:	0a000016 	beq	10f4b8 <lwip_netconn_do_writemore+0x384>
  10f45c:	e15b20b8 	ldrh	r2, [fp, #-8]
  10f460:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f464:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f468:	e593300c 	ldr	r3, [r3, #12]
  10f46c:	e1520003 	cmp	r2, r3
  10f470:	2a000010 	bcs	10f4b8 <lwip_netconn_do_writemore+0x384>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  10f474:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f478:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10f47c:	e3530000 	cmp	r3, #0
  10f480:	0a000005 	beq	10f49c <lwip_netconn_do_writemore+0x368>
  10f484:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f488:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10f48c:	e15b20b8 	ldrh	r2, [fp, #-8]
  10f490:	e3a01003 	mov	r1, #3
  10f494:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10f498:	e12fff33 	blx	r3
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
  10f49c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f4a0:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  10f4a4:	e3833010 	orr	r3, r3, #16
  10f4a8:	e6ef2073 	uxtb	r2, r3
  10f4ac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f4b0:	e5c32030 	strb	r2, [r3, #48]	; 0x30
  10f4b4:	ea000013 	b	10f508 <lwip_netconn_do_writemore+0x3d4>
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
  10f4b8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f4bc:	e5933008 	ldr	r3, [r3, #8]
  10f4c0:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
  10f4c4:	e3530a01 	cmp	r3, #4096	; 0x1000
  10f4c8:	9a000004 	bls	10f4e0 <lwip_netconn_do_writemore+0x3ac>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
  10f4cc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f4d0:	e5933008 	ldr	r3, [r3, #8]
  10f4d4:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
  10f4d8:	e353000a 	cmp	r3, #10
  10f4dc:	9a000009 	bls	10f508 <lwip_netconn_do_writemore+0x3d4>
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  10f4e0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f4e4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10f4e8:	e3530000 	cmp	r3, #0
  10f4ec:	0a000005 	beq	10f508 <lwip_netconn_do_writemore+0x3d4>
  10f4f0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f4f4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  10f4f8:	e15b20b8 	ldrh	r2, [fp, #-8]
  10f4fc:	e3a01003 	mov	r1, #3
  10f500:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  10f504:	e12fff33 	blx	r3
      }
    }

    if (err == ERR_OK) {
  10f508:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10f50c:	e3530000 	cmp	r3, #0
  10f510:	1a00002b 	bne	10f5c4 <lwip_netconn_do_writemore+0x490>
      err_t out_err;
      conn->write_offset += len;
  10f514:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f518:	e5932034 	ldr	r2, [r3, #52]	; 0x34
  10f51c:	e15b30b8 	ldrh	r3, [fp, #-8]
  10f520:	e0822003 	add	r2, r2, r3
  10f524:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f528:	e5832034 	str	r2, [r3, #52]	; 0x34
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
  10f52c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f530:	e5932034 	ldr	r2, [r3, #52]	; 0x34
  10f534:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f538:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f53c:	e593300c 	ldr	r3, [r3, #12]
  10f540:	e1520003 	cmp	r2, r3
  10f544:	0a000002 	beq	10f554 <lwip_netconn_do_writemore+0x420>
  10f548:	e55b300b 	ldrb	r3, [fp, #-11]
  10f54c:	e3530000 	cmp	r3, #0
  10f550:	0a000006 	beq	10f570 <lwip_netconn_do_writemore+0x43c>
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
  10f554:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f558:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f55c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  10f560:	e5922034 	ldr	r2, [r2, #52]	; 0x34
  10f564:	e583200c 	str	r2, [r3, #12]
        /* everything was written */
        write_finished = 1;
  10f568:	e3a03001 	mov	r3, #1
  10f56c:	e54b3009 	strb	r3, [fp, #-9]
      }
      out_err = tcp_output(conn->pcb.tcp);
  10f570:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f574:	e5933008 	ldr	r3, [r3, #8]
  10f578:	e1a00003 	mov	r0, r3
  10f57c:	eb005af6 	bl	12615c <tcp_output>
  10f580:	e1a03000 	mov	r3, r0
  10f584:	e54b3018 	strb	r3, [fp, #-24]	; 0xffffffe8
      if (ERR_IS_FATAL(out_err) || (out_err == ERR_RTE)) {
  10f588:	e15b31d8 	ldrsb	r3, [fp, #-24]	; 0xffffffe8
  10f58c:	e373000c 	cmn	r3, #12
  10f590:	ba000002 	blt	10f5a0 <lwip_netconn_do_writemore+0x46c>
  10f594:	e15b31d8 	ldrsb	r3, [fp, #-24]	; 0xffffffe8
  10f598:	e3730004 	cmn	r3, #4
  10f59c:	1a000032 	bne	10f66c <lwip_netconn_do_writemore+0x538>
        /* If tcp_output fails with fatal error or no route is found,
           don't try writing any more but return the error
           to the application thread. */
        err = out_err;
  10f5a0:	e55b3018 	ldrb	r3, [fp, #-24]	; 0xffffffe8
  10f5a4:	e54b3005 	strb	r3, [fp, #-5]
        write_finished = 1;
  10f5a8:	e3a03001 	mov	r3, #1
  10f5ac:	e54b3009 	strb	r3, [fp, #-9]
        conn->current_msg->msg.w.len = 0;
  10f5b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f5b4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f5b8:	e3a02000 	mov	r2, #0
  10f5bc:	e583200c 	str	r2, [r3, #12]
  10f5c0:	ea000029 	b	10f66c <lwip_netconn_do_writemore+0x538>
      }
    } else if (err == ERR_MEM) {
  10f5c4:	e15b30d5 	ldrsb	r3, [fp, #-5]
  10f5c8:	e3730001 	cmn	r3, #1
  10f5cc:	1a000020 	bne	10f654 <lwip_netconn_do_writemore+0x520>
         For blocking sockets, we do NOT return to the application
         thread, since ERR_MEM is only a temporary error! Non-blocking
         will remain non-writable until sent_tcp/poll_tcp is called */

      /* tcp_write returned ERR_MEM, try tcp_output anyway */
      err_t out_err = tcp_output(conn->pcb.tcp);
  10f5d0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f5d4:	e5933008 	ldr	r3, [r3, #8]
  10f5d8:	e1a00003 	mov	r0, r3
  10f5dc:	eb005ade 	bl	12615c <tcp_output>
  10f5e0:	e1a03000 	mov	r3, r0
  10f5e4:	e54b3017 	strb	r3, [fp, #-23]	; 0xffffffe9
      if (ERR_IS_FATAL(out_err) || (out_err == ERR_RTE)) {
  10f5e8:	e15b31d7 	ldrsb	r3, [fp, #-23]	; 0xffffffe9
  10f5ec:	e373000c 	cmn	r3, #12
  10f5f0:	ba000002 	blt	10f600 <lwip_netconn_do_writemore+0x4cc>
  10f5f4:	e15b31d7 	ldrsb	r3, [fp, #-23]	; 0xffffffe9
  10f5f8:	e3730004 	cmn	r3, #4
  10f5fc:	1a000008 	bne	10f624 <lwip_netconn_do_writemore+0x4f0>
        /* If tcp_output fails with fatal error or no route is found,
           don't try writing any more but return the error
           to the application thread. */
        err = out_err;
  10f600:	e55b3017 	ldrb	r3, [fp, #-23]	; 0xffffffe9
  10f604:	e54b3005 	strb	r3, [fp, #-5]
        write_finished = 1;
  10f608:	e3a03001 	mov	r3, #1
  10f60c:	e54b3009 	strb	r3, [fp, #-9]
        conn->current_msg->msg.w.len = 0;
  10f610:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f614:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f618:	e3a02000 	mov	r2, #0
  10f61c:	e583200c 	str	r2, [r3, #12]
  10f620:	ea000011 	b	10f66c <lwip_netconn_do_writemore+0x538>
      } else if (dontblock) {
  10f624:	e55b300b 	ldrb	r3, [fp, #-11]
  10f628:	e3530000 	cmp	r3, #0
  10f62c:	0a00000e 	beq	10f66c <lwip_netconn_do_writemore+0x538>
        /* non-blocking write is done on ERR_MEM */
        err = ERR_WOULDBLOCK;
  10f630:	e3e03006 	mvn	r3, #6
  10f634:	e54b3005 	strb	r3, [fp, #-5]
        write_finished = 1;
  10f638:	e3a03001 	mov	r3, #1
  10f63c:	e54b3009 	strb	r3, [fp, #-9]
        conn->current_msg->msg.w.len = 0;
  10f640:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f644:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f648:	e3a02000 	mov	r2, #0
  10f64c:	e583200c 	str	r2, [r3, #12]
  10f650:	ea000005 	b	10f66c <lwip_netconn_do_writemore+0x538>
      }
    } else {
      /* On errors != ERR_MEM, we don't try writing any more but return
         the error to the application thread. */
      write_finished = 1;
  10f654:	e3a03001 	mov	r3, #1
  10f658:	e54b3009 	strb	r3, [fp, #-9]
      conn->current_msg->msg.w.len = 0;
  10f65c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f660:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f664:	e3a02000 	mov	r2, #0
  10f668:	e583200c 	str	r2, [r3, #12]
    }
  }
  if (write_finished) {
  10f66c:	e55b3009 	ldrb	r3, [fp, #-9]
  10f670:	e3530000 	cmp	r3, #0
  10f674:	0a000023 	beq	10f708 <lwip_netconn_do_writemore+0x5d4>
    /* everything was written: set back connection state
       and back to application task */
    sys_sem_t* op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
  10f678:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f67c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f680:	e5933000 	ldr	r3, [r3]
  10f684:	e2833010 	add	r3, r3, #16
  10f688:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    conn->current_msg->err = err;
  10f68c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f690:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f694:	e55b2005 	ldrb	r2, [fp, #-5]
  10f698:	e5c32004 	strb	r2, [r3, #4]
    conn->current_msg = NULL;
  10f69c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f6a0:	e3a02000 	mov	r2, #0
  10f6a4:	e5832038 	str	r2, [r3, #56]	; 0x38
    conn->write_offset = 0;
  10f6a8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f6ac:	e3a02000 	mov	r2, #0
  10f6b0:	e5832034 	str	r2, [r3, #52]	; 0x34
    conn->state = NETCONN_NONE;
  10f6b4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f6b8:	e3a02000 	mov	r2, #0
  10f6bc:	e5832004 	str	r2, [r3, #4]
    NETCONN_SET_SAFE_ERR(conn, err);
  10f6c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f6c4:	e3530000 	cmp	r3, #0
  10f6c8:	0a000008 	beq	10f6f0 <lwip_netconn_do_writemore+0x5bc>
  10f6cc:	ebffcada 	bl	10223c <rt_enter_critical>
  10f6d0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f6d4:	e1d330dc 	ldrsb	r3, [r3, #12]
  10f6d8:	e373000c 	cmn	r3, #12
  10f6dc:	ba000002 	blt	10f6ec <lwip_netconn_do_writemore+0x5b8>
  10f6e0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  10f6e4:	e55b2005 	ldrb	r2, [fp, #-5]
  10f6e8:	e5c3200c 	strb	r2, [r3, #12]
  10f6ec:	ebffcad8 	bl	102254 <rt_exit_critical>
#if LWIP_TCPIP_CORE_LOCKING
    if (delayed)
  10f6f0:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  10f6f4:	e3530000 	cmp	r3, #0
  10f6f8:	0a000004 	beq	10f710 <lwip_netconn_do_writemore+0x5dc>
#endif
    {
      sys_sem_signal(op_completed_sem);
  10f6fc:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  10f700:	ebffec01 	bl	10a70c <sys_sem_signal>
  10f704:	ea000001 	b	10f710 <lwip_netconn_do_writemore+0x5dc>
    }
  }
#if LWIP_TCPIP_CORE_LOCKING
  else {
    return ERR_MEM;
  10f708:	e3e03000 	mvn	r3, #0
  10f70c:	ea000000 	b	10f714 <lwip_netconn_do_writemore+0x5e0>
  }
#endif
  return ERR_OK;
  10f710:	e3a03000 	mov	r3, #0
}
  10f714:	e1a00003 	mov	r0, r3
  10f718:	e24bd004 	sub	sp, fp, #4
  10f71c:	e8bd8800 	pop	{fp, pc}

0010f720 <lwip_netconn_do_write>:
 *
 * @param m the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_write(void *m)
{
  10f720:	e92d4800 	push	{fp, lr}
  10f724:	e28db004 	add	fp, sp, #4
  10f728:	e24dd010 	sub	sp, sp, #16
  10f72c:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10f730:	e51b3010 	ldr	r3, [fp, #-16]
  10f734:	e50b3008 	str	r3, [fp, #-8]

  if (ERR_IS_FATAL(msg->conn->last_err)) {
  10f738:	e51b3008 	ldr	r3, [fp, #-8]
  10f73c:	e5933000 	ldr	r3, [r3]
  10f740:	e1d330dc 	ldrsb	r3, [r3, #12]
  10f744:	e373000c 	cmn	r3, #12
  10f748:	aa000005 	bge	10f764 <lwip_netconn_do_write+0x44>
    msg->err = msg->conn->last_err;
  10f74c:	e51b3008 	ldr	r3, [fp, #-8]
  10f750:	e5933000 	ldr	r3, [r3]
  10f754:	e1d320dc 	ldrsb	r2, [r3, #12]
  10f758:	e51b3008 	ldr	r3, [fp, #-8]
  10f75c:	e5c32004 	strb	r2, [r3, #4]
  10f760:	ea00006f 	b	10f924 <lwip_netconn_do_write+0x204>
  } else {
    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
  10f764:	e51b3008 	ldr	r3, [fp, #-8]
  10f768:	e5933000 	ldr	r3, [r3]
  10f76c:	e5933000 	ldr	r3, [r3]
  10f770:	e20330f0 	and	r3, r3, #240	; 0xf0
  10f774:	e3530010 	cmp	r3, #16
  10f778:	1a000066 	bne	10f918 <lwip_netconn_do_write+0x1f8>
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
  10f77c:	e51b3008 	ldr	r3, [fp, #-8]
  10f780:	e5933000 	ldr	r3, [r3]
  10f784:	e5933004 	ldr	r3, [r3, #4]
  10f788:	e3530000 	cmp	r3, #0
  10f78c:	0a000003 	beq	10f7a0 <lwip_netconn_do_write+0x80>
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
  10f790:	e51b3008 	ldr	r3, [fp, #-8]
  10f794:	e3e02004 	mvn	r2, #4
  10f798:	e5c32004 	strb	r2, [r3, #4]
  10f79c:	ea000060 	b	10f924 <lwip_netconn_do_write+0x204>
      } else if (msg->conn->pcb.tcp != NULL) {
  10f7a0:	e51b3008 	ldr	r3, [fp, #-8]
  10f7a4:	e5933000 	ldr	r3, [r3]
  10f7a8:	e5933008 	ldr	r3, [r3, #8]
  10f7ac:	e3530000 	cmp	r3, #0
  10f7b0:	0a000054 	beq	10f908 <lwip_netconn_do_write+0x1e8>
        msg->conn->state = NETCONN_WRITE;
  10f7b4:	e51b3008 	ldr	r3, [fp, #-8]
  10f7b8:	e5933000 	ldr	r3, [r3]
  10f7bc:	e3a02001 	mov	r2, #1
  10f7c0:	e5832004 	str	r2, [r3, #4]
        /* set all the variables used by lwip_netconn_do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
  10f7c4:	e51b3008 	ldr	r3, [fp, #-8]
  10f7c8:	e5933000 	ldr	r3, [r3]
  10f7cc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10f7d0:	e3530000 	cmp	r3, #0
  10f7d4:	1a000004 	bne	10f7ec <lwip_netconn_do_write+0xcc>
  10f7d8:	e51b3008 	ldr	r3, [fp, #-8]
  10f7dc:	e5933000 	ldr	r3, [r3]
  10f7e0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  10f7e4:	e3530000 	cmp	r3, #0
  10f7e8:	0a000006 	beq	10f808 <lwip_netconn_do_write+0xe8>
  10f7ec:	e3060bd8 	movw	r0, #27608	; 0x6bd8
  10f7f0:	e3400014 	movt	r0, #20
  10f7f4:	ebffce46 	bl	103114 <rt_kprintf>
  10f7f8:	e300167d 	movw	r1, #1661	; 0x67d
  10f7fc:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f800:	e3400014 	movt	r0, #20
  10f804:	ebffee1c 	bl	10b07c <sys_arch_assert>
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
  10f808:	e51b3008 	ldr	r3, [fp, #-8]
  10f80c:	e593300c 	ldr	r3, [r3, #12]
  10f810:	e3530000 	cmp	r3, #0
  10f814:	1a000006 	bne	10f834 <lwip_netconn_do_write+0x114>
  10f818:	e3060d2c 	movw	r0, #27948	; 0x6d2c
  10f81c:	e3400014 	movt	r0, #20
  10f820:	ebffce3b 	bl	103114 <rt_kprintf>
  10f824:	e300167e 	movw	r1, #1662	; 0x67e
  10f828:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f82c:	e3400014 	movt	r0, #20
  10f830:	ebffee11 	bl	10b07c <sys_arch_assert>
        msg->conn->current_msg = msg;
  10f834:	e51b3008 	ldr	r3, [fp, #-8]
  10f838:	e5933000 	ldr	r3, [r3]
  10f83c:	e51b2008 	ldr	r2, [fp, #-8]
  10f840:	e5832038 	str	r2, [r3, #56]	; 0x38
        msg->conn->write_offset = 0;
  10f844:	e51b3008 	ldr	r3, [fp, #-8]
  10f848:	e5933000 	ldr	r3, [r3]
  10f84c:	e3a02000 	mov	r2, #0
  10f850:	e5832034 	str	r2, [r3, #52]	; 0x34
#if LWIP_TCPIP_CORE_LOCKING
        if (lwip_netconn_do_writemore(msg->conn, 0) != ERR_OK) {
  10f854:	e51b3008 	ldr	r3, [fp, #-8]
  10f858:	e5933000 	ldr	r3, [r3]
  10f85c:	e3a01000 	mov	r1, #0
  10f860:	e1a00003 	mov	r0, r3
  10f864:	ebfffe32 	bl	10f134 <lwip_netconn_do_writemore>
  10f868:	e1a03000 	mov	r3, r0
  10f86c:	e3530000 	cmp	r3, #0
  10f870:	0a00003c 	beq	10f968 <lwip_netconn_do_write+0x248>
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
  10f874:	e51b3008 	ldr	r3, [fp, #-8]
  10f878:	e5933000 	ldr	r3, [r3]
  10f87c:	e5933004 	ldr	r3, [r3, #4]
  10f880:	e3530001 	cmp	r3, #1
  10f884:	0a000006 	beq	10f8a4 <lwip_netconn_do_write+0x184>
  10f888:	e3060bf4 	movw	r0, #27636	; 0x6bf4
  10f88c:	e3400014 	movt	r0, #20
  10f890:	ebffce1f 	bl	103114 <rt_kprintf>
  10f894:	e3001683 	movw	r1, #1667	; 0x683
  10f898:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f89c:	e3400014 	movt	r0, #20
  10f8a0:	ebffedf5 	bl	10b07c <sys_arch_assert>
          UNLOCK_TCPIP_CORE();
  10f8a4:	e30005e4 	movw	r0, #1508	; 0x5e4
  10f8a8:	e3400015 	movt	r0, #21
  10f8ac:	ebffec1d 	bl	10a928 <sys_mutex_unlock>
          sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
  10f8b0:	e51b3008 	ldr	r3, [fp, #-8]
  10f8b4:	e5933000 	ldr	r3, [r3]
  10f8b8:	e2833010 	add	r3, r3, #16
  10f8bc:	e3a01000 	mov	r1, #0
  10f8c0:	e1a00003 	mov	r0, r3
  10f8c4:	ebffeb9b 	bl	10a738 <sys_arch_sem_wait>
          LOCK_TCPIP_CORE();
  10f8c8:	e30005e4 	movw	r0, #1508	; 0x5e4
  10f8cc:	e3400015 	movt	r0, #21
  10f8d0:	ebffec08 	bl	10a8f8 <sys_mutex_lock>
          LWIP_ASSERT("state!", msg->conn->state != NETCONN_WRITE);
  10f8d4:	e51b3008 	ldr	r3, [fp, #-8]
  10f8d8:	e5933000 	ldr	r3, [r3]
  10f8dc:	e5933004 	ldr	r3, [r3, #4]
  10f8e0:	e3530001 	cmp	r3, #1
  10f8e4:	1a00001f 	bne	10f968 <lwip_netconn_do_write+0x248>
  10f8e8:	e3060bf4 	movw	r0, #27636	; 0x6bf4
  10f8ec:	e3400014 	movt	r0, #20
  10f8f0:	ebffce07 	bl	103114 <rt_kprintf>
  10f8f4:	e3001687 	movw	r1, #1671	; 0x687
  10f8f8:	e30608bc 	movw	r0, #26812	; 0x68bc
  10f8fc:	e3400014 	movt	r0, #20
  10f900:	ebffeddd 	bl	10b07c <sys_arch_assert>
#else /* LWIP_TCPIP_CORE_LOCKING */
        lwip_netconn_do_writemore(msg->conn);
#endif /* LWIP_TCPIP_CORE_LOCKING */
        /* for both cases: if lwip_netconn_do_writemore was called, don't ACK the APIMSG
           since lwip_netconn_do_writemore ACKs it! */
        return;
  10f904:	ea000017 	b	10f968 <lwip_netconn_do_write+0x248>
      } else {
        msg->err = ERR_CONN;
  10f908:	e51b3008 	ldr	r3, [fp, #-8]
  10f90c:	e3e0200a 	mvn	r2, #10
  10f910:	e5c32004 	strb	r2, [r3, #4]
  10f914:	ea000002 	b	10f924 <lwip_netconn_do_write+0x204>
#else /* LWIP_TCP */
      msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->err = ERR_VAL;
  10f918:	e51b3008 	ldr	r3, [fp, #-8]
  10f91c:	e3e02005 	mvn	r2, #5
  10f920:	e5c32004 	strb	r2, [r3, #4]
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  10f924:	e51b3008 	ldr	r3, [fp, #-8]
  10f928:	e5933000 	ldr	r3, [r3]
  10f92c:	e3530000 	cmp	r3, #0
  10f930:	0a00000d 	beq	10f96c <lwip_netconn_do_write+0x24c>
  10f934:	ebffca40 	bl	10223c <rt_enter_critical>
  10f938:	e51b3008 	ldr	r3, [fp, #-8]
  10f93c:	e5933000 	ldr	r3, [r3]
  10f940:	e1d330dc 	ldrsb	r3, [r3, #12]
  10f944:	e373000c 	cmn	r3, #12
  10f948:	ba000004 	blt	10f960 <lwip_netconn_do_write+0x240>
  10f94c:	e51b3008 	ldr	r3, [fp, #-8]
  10f950:	e5933000 	ldr	r3, [r3]
  10f954:	e51b2008 	ldr	r2, [fp, #-8]
  10f958:	e1d220d4 	ldrsb	r2, [r2, #4]
  10f95c:	e5c3200c 	strb	r2, [r3, #12]
  10f960:	ebffca3b 	bl	102254 <rt_exit_critical>
  10f964:	ea000000 	b	10f96c <lwip_netconn_do_write+0x24c>
        return;
  10f968:	e320f000 	nop	{0}
}
  10f96c:	e24bd004 	sub	sp, fp, #4
  10f970:	e8bd8800 	pop	{fp, pc}

0010f974 <lwip_netconn_do_getaddr>:
 *
 * @param m the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_getaddr(void *m)
{
  10f974:	e92d4800 	push	{fp, lr}
  10f978:	e28db004 	add	fp, sp, #4
  10f97c:	e24dd010 	sub	sp, sp, #16
  10f980:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10f984:	e51b3010 	ldr	r3, [fp, #-16]
  10f988:	e50b3008 	str	r3, [fp, #-8]

  if (msg->conn->pcb.ip != NULL) {
  10f98c:	e51b3008 	ldr	r3, [fp, #-8]
  10f990:	e5933000 	ldr	r3, [r3]
  10f994:	e5933008 	ldr	r3, [r3, #8]
  10f998:	e3530000 	cmp	r3, #0
  10f99c:	0a00007e 	beq	10fb9c <lwip_netconn_do_getaddr+0x228>
    if (msg->msg.ad.local) {
  10f9a0:	e51b3008 	ldr	r3, [fp, #-8]
  10f9a4:	e5d33010 	ldrb	r3, [r3, #16]
  10f9a8:	e3530000 	cmp	r3, #0
  10f9ac:	0a000007 	beq	10f9d0 <lwip_netconn_do_getaddr+0x5c>
      ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
  10f9b0:	e51b3008 	ldr	r3, [fp, #-8]
  10f9b4:	e5933000 	ldr	r3, [r3]
  10f9b8:	e5932008 	ldr	r2, [r3, #8]
  10f9bc:	e51b3008 	ldr	r3, [fp, #-8]
  10f9c0:	e5933008 	ldr	r3, [r3, #8]
  10f9c4:	e5922000 	ldr	r2, [r2]
  10f9c8:	e5832000 	str	r2, [r3]
  10f9cc:	ea000006 	b	10f9ec <lwip_netconn_do_getaddr+0x78>
        msg->conn->pcb.ip->local_ip);
    } else {
      ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
  10f9d0:	e51b3008 	ldr	r3, [fp, #-8]
  10f9d4:	e5933000 	ldr	r3, [r3]
  10f9d8:	e5932008 	ldr	r2, [r3, #8]
  10f9dc:	e51b3008 	ldr	r3, [fp, #-8]
  10f9e0:	e5933008 	ldr	r3, [r3, #8]
  10f9e4:	e5922004 	ldr	r2, [r2, #4]
  10f9e8:	e5832000 	str	r2, [r3]
        msg->conn->pcb.ip->remote_ip);
    }

    msg->err = ERR_OK;
  10f9ec:	e51b3008 	ldr	r3, [fp, #-8]
  10f9f0:	e3a02000 	mov	r2, #0
  10f9f4:	e5c32004 	strb	r2, [r3, #4]
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  10f9f8:	e51b3008 	ldr	r3, [fp, #-8]
  10f9fc:	e5933000 	ldr	r3, [r3]
  10fa00:	e5933000 	ldr	r3, [r3]
  10fa04:	e20330f0 	and	r3, r3, #240	; 0xf0
  10fa08:	e3530020 	cmp	r3, #32
  10fa0c:	0a000015 	beq	10fa68 <lwip_netconn_do_getaddr+0xf4>
  10fa10:	e3530040 	cmp	r3, #64	; 0x40
  10fa14:	0a000002 	beq	10fa24 <lwip_netconn_do_getaddr+0xb0>
  10fa18:	e3530010 	cmp	r3, #16
  10fa1c:	0a000030 	beq	10fae4 <lwip_netconn_do_getaddr+0x170>
  10fa20:	ea000054 	b	10fb78 <lwip_netconn_do_getaddr+0x204>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  10fa24:	e51b3008 	ldr	r3, [fp, #-8]
  10fa28:	e5d33010 	ldrb	r3, [r3, #16]
  10fa2c:	e3530000 	cmp	r3, #0
  10fa30:	0a000008 	beq	10fa58 <lwip_netconn_do_getaddr+0xe4>
        API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  10fa34:	e51b3008 	ldr	r3, [fp, #-8]
  10fa38:	e5933000 	ldr	r3, [r3]
  10fa3c:	e5933008 	ldr	r3, [r3, #8]
  10fa40:	e5d32010 	ldrb	r2, [r3, #16]
  10fa44:	e51b3008 	ldr	r3, [fp, #-8]
  10fa48:	e593300c 	ldr	r3, [r3, #12]
  10fa4c:	e6ff2072 	uxth	r2, r2
  10fa50:	e1c320b0 	strh	r2, [r3]
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->err = ERR_CONN;
      }
      break;
  10fa54:	ea000053 	b	10fba8 <lwip_netconn_do_getaddr+0x234>
        msg->err = ERR_CONN;
  10fa58:	e51b3008 	ldr	r3, [fp, #-8]
  10fa5c:	e3e0200a 	mvn	r2, #10
  10fa60:	e5c32004 	strb	r2, [r3, #4]
      break;
  10fa64:	ea00004f 	b	10fba8 <lwip_netconn_do_getaddr+0x234>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  10fa68:	e51b3008 	ldr	r3, [fp, #-8]
  10fa6c:	e5d33010 	ldrb	r3, [r3, #16]
  10fa70:	e3530000 	cmp	r3, #0
  10fa74:	0a000007 	beq	10fa98 <lwip_netconn_do_getaddr+0x124>
        API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  10fa78:	e51b3008 	ldr	r3, [fp, #-8]
  10fa7c:	e5933000 	ldr	r3, [r3]
  10fa80:	e5932008 	ldr	r2, [r3, #8]
  10fa84:	e51b3008 	ldr	r3, [fp, #-8]
  10fa88:	e593300c 	ldr	r3, [r3, #12]
  10fa8c:	e1d221b2 	ldrh	r2, [r2, #18]
  10fa90:	e1c320b0 	strh	r2, [r3]
          msg->err = ERR_CONN;
        } else {
          API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
  10fa94:	ea000043 	b	10fba8 <lwip_netconn_do_getaddr+0x234>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  10fa98:	e51b3008 	ldr	r3, [fp, #-8]
  10fa9c:	e5933000 	ldr	r3, [r3]
  10faa0:	e5933008 	ldr	r3, [r3, #8]
  10faa4:	e5d33010 	ldrb	r3, [r3, #16]
  10faa8:	e2033004 	and	r3, r3, #4
  10faac:	e3530000 	cmp	r3, #0
  10fab0:	1a000003 	bne	10fac4 <lwip_netconn_do_getaddr+0x150>
          msg->err = ERR_CONN;
  10fab4:	e51b3008 	ldr	r3, [fp, #-8]
  10fab8:	e3e0200a 	mvn	r2, #10
  10fabc:	e5c32004 	strb	r2, [r3, #4]
      break;
  10fac0:	ea000038 	b	10fba8 <lwip_netconn_do_getaddr+0x234>
          API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  10fac4:	e51b3008 	ldr	r3, [fp, #-8]
  10fac8:	e5933000 	ldr	r3, [r3]
  10facc:	e5932008 	ldr	r2, [r3, #8]
  10fad0:	e51b3008 	ldr	r3, [fp, #-8]
  10fad4:	e593300c 	ldr	r3, [r3, #12]
  10fad8:	e1d221b4 	ldrh	r2, [r2, #20]
  10fadc:	e1c320b0 	strh	r2, [r3]
      break;
  10fae0:	ea000030 	b	10fba8 <lwip_netconn_do_getaddr+0x234>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      if ((msg->msg.ad.local == 0) &&
  10fae4:	e51b3008 	ldr	r3, [fp, #-8]
  10fae8:	e5d33010 	ldrb	r3, [r3, #16]
  10faec:	e3530000 	cmp	r3, #0
  10faf0:	1a00000f 	bne	10fb34 <lwip_netconn_do_getaddr+0x1c0>
          ((msg->conn->pcb.tcp->state == CLOSED) || (msg->conn->pcb.tcp->state == LISTEN))) {
  10faf4:	e51b3008 	ldr	r3, [fp, #-8]
  10faf8:	e5933000 	ldr	r3, [r3]
  10fafc:	e5933008 	ldr	r3, [r3, #8]
  10fb00:	e5933014 	ldr	r3, [r3, #20]
      if ((msg->msg.ad.local == 0) &&
  10fb04:	e3530000 	cmp	r3, #0
  10fb08:	0a000005 	beq	10fb24 <lwip_netconn_do_getaddr+0x1b0>
          ((msg->conn->pcb.tcp->state == CLOSED) || (msg->conn->pcb.tcp->state == LISTEN))) {
  10fb0c:	e51b3008 	ldr	r3, [fp, #-8]
  10fb10:	e5933000 	ldr	r3, [r3]
  10fb14:	e5933008 	ldr	r3, [r3, #8]
  10fb18:	e5933014 	ldr	r3, [r3, #20]
  10fb1c:	e3530001 	cmp	r3, #1
  10fb20:	1a000003 	bne	10fb34 <lwip_netconn_do_getaddr+0x1c0>
        /* pcb is not connected and remote name is requested */
        msg->err = ERR_CONN;
  10fb24:	e51b3008 	ldr	r3, [fp, #-8]
  10fb28:	e3e0200a 	mvn	r2, #10
  10fb2c:	e5c32004 	strb	r2, [r3, #4]
      } else {
        API_EXPR_DEREF(msg->msg.ad.port) = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
      }
      break;
  10fb30:	ea00001c 	b	10fba8 <lwip_netconn_do_getaddr+0x234>
        API_EXPR_DEREF(msg->msg.ad.port) = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
  10fb34:	e51b3008 	ldr	r3, [fp, #-8]
  10fb38:	e5d33010 	ldrb	r3, [r3, #16]
  10fb3c:	e3530000 	cmp	r3, #0
  10fb40:	0a000004 	beq	10fb58 <lwip_netconn_do_getaddr+0x1e4>
  10fb44:	e51b3008 	ldr	r3, [fp, #-8]
  10fb48:	e5933000 	ldr	r3, [r3]
  10fb4c:	e5933008 	ldr	r3, [r3, #8]
  10fb50:	e1d331ba 	ldrh	r3, [r3, #26]
  10fb54:	ea000003 	b	10fb68 <lwip_netconn_do_getaddr+0x1f4>
  10fb58:	e51b3008 	ldr	r3, [fp, #-8]
  10fb5c:	e5933000 	ldr	r3, [r3]
  10fb60:	e5933008 	ldr	r3, [r3, #8]
  10fb64:	e1d331bc 	ldrh	r3, [r3, #28]
  10fb68:	e51b2008 	ldr	r2, [fp, #-8]
  10fb6c:	e592200c 	ldr	r2, [r2, #12]
  10fb70:	e1c230b0 	strh	r3, [r2]
      break;
  10fb74:	ea00000b 	b	10fba8 <lwip_netconn_do_getaddr+0x234>
#endif /* LWIP_TCP */
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
  10fb78:	e3060d40 	movw	r0, #27968	; 0x6d40
  10fb7c:	e3400014 	movt	r0, #20
  10fb80:	ebffcd63 	bl	103114 <rt_kprintf>
  10fb84:	e30016d7 	movw	r1, #1751	; 0x6d7
  10fb88:	e30608bc 	movw	r0, #26812	; 0x68bc
  10fb8c:	e3400014 	movt	r0, #20
  10fb90:	ebffed39 	bl	10b07c <sys_arch_assert>
      break;
  10fb94:	e320f000 	nop	{0}
  10fb98:	ea000002 	b	10fba8 <lwip_netconn_do_getaddr+0x234>
    }
  } else {
    msg->err = ERR_CONN;
  10fb9c:	e51b3008 	ldr	r3, [fp, #-8]
  10fba0:	e3e0200a 	mvn	r2, #10
  10fba4:	e5c32004 	strb	r2, [r3, #4]
  }
  TCPIP_APIMSG_ACK(msg);
  10fba8:	e51b3008 	ldr	r3, [fp, #-8]
  10fbac:	e5933000 	ldr	r3, [r3]
  10fbb0:	e3530000 	cmp	r3, #0
  10fbb4:	0a00000b 	beq	10fbe8 <lwip_netconn_do_getaddr+0x274>
  10fbb8:	ebffc99f 	bl	10223c <rt_enter_critical>
  10fbbc:	e51b3008 	ldr	r3, [fp, #-8]
  10fbc0:	e5933000 	ldr	r3, [r3]
  10fbc4:	e1d330dc 	ldrsb	r3, [r3, #12]
  10fbc8:	e373000c 	cmn	r3, #12
  10fbcc:	ba000004 	blt	10fbe4 <lwip_netconn_do_getaddr+0x270>
  10fbd0:	e51b3008 	ldr	r3, [fp, #-8]
  10fbd4:	e5933000 	ldr	r3, [r3]
  10fbd8:	e51b2008 	ldr	r2, [fp, #-8]
  10fbdc:	e1d220d4 	ldrsb	r2, [r2, #4]
  10fbe0:	e5c3200c 	strb	r2, [r3, #12]
  10fbe4:	ebffc99a 	bl	102254 <rt_exit_critical>
}
  10fbe8:	e320f000 	nop	{0}
  10fbec:	e24bd004 	sub	sp, fp, #4
  10fbf0:	e8bd8800 	pop	{fp, pc}

0010fbf4 <lwip_netconn_do_close>:
 *
 * @param m the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_close(void *m)
{
  10fbf4:	e92d4800 	push	{fp, lr}
  10fbf8:	e28db004 	add	fp, sp, #4
  10fbfc:	e24dd010 	sub	sp, sp, #16
  10fc00:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10fc04:	e51b3010 	ldr	r3, [fp, #-16]
  10fc08:	e50b3008 	str	r3, [fp, #-8]

#if LWIP_TCP
  enum netconn_state state = msg->conn->state;
  10fc0c:	e51b3008 	ldr	r3, [fp, #-8]
  10fc10:	e5933000 	ldr	r3, [r3]
  10fc14:	e5933004 	ldr	r3, [r3, #4]
  10fc18:	e50b300c 	str	r3, [fp, #-12]
  /* First check if this is a TCP netconn and if it is in a correct state
      (LISTEN doesn't support half shutdown) */
  if ((msg->conn->pcb.tcp != NULL) &&
  10fc1c:	e51b3008 	ldr	r3, [fp, #-8]
  10fc20:	e5933000 	ldr	r3, [r3]
  10fc24:	e5933008 	ldr	r3, [r3, #8]
  10fc28:	e3530000 	cmp	r3, #0
  10fc2c:	0a000069 	beq	10fdd8 <lwip_netconn_do_close+0x1e4>
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
  10fc30:	e51b3008 	ldr	r3, [fp, #-8]
  10fc34:	e5933000 	ldr	r3, [r3]
  10fc38:	e5933000 	ldr	r3, [r3]
  10fc3c:	e20330f0 	and	r3, r3, #240	; 0xf0
  if ((msg->conn->pcb.tcp != NULL) &&
  10fc40:	e3530010 	cmp	r3, #16
  10fc44:	1a000063 	bne	10fdd8 <lwip_netconn_do_close+0x1e4>
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
  10fc48:	e51b3008 	ldr	r3, [fp, #-8]
  10fc4c:	e5d33008 	ldrb	r3, [r3, #8]
      (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
  10fc50:	e3530003 	cmp	r3, #3
  10fc54:	0a000002 	beq	10fc64 <lwip_netconn_do_close+0x70>
      ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
  10fc58:	e51b300c 	ldr	r3, [fp, #-12]
  10fc5c:	e3530002 	cmp	r3, #2
  10fc60:	0a00005c 	beq	10fdd8 <lwip_netconn_do_close+0x1e4>
    /* Check if we are in a connected state */
    if (state == NETCONN_CONNECT) {
  10fc64:	e51b300c 	ldr	r3, [fp, #-12]
  10fc68:	e3530003 	cmp	r3, #3
  10fc6c:	1a000003 	bne	10fc80 <lwip_netconn_do_close+0x8c>
      /* TCP connect in progress: cannot shutdown */
      msg->err = ERR_CONN;
  10fc70:	e51b3008 	ldr	r3, [fp, #-8]
  10fc74:	e3e0200a 	mvn	r2, #10
  10fc78:	e5c32004 	strb	r2, [r3, #4]
    if (state == NETCONN_CONNECT) {
  10fc7c:	ea000058 	b	10fde4 <lwip_netconn_do_close+0x1f0>
    } else if (state == NETCONN_WRITE) {
  10fc80:	e51b300c 	ldr	r3, [fp, #-12]
  10fc84:	e3530001 	cmp	r3, #1
  10fc88:	1a000003 	bne	10fc9c <lwip_netconn_do_close+0xa8>
        msg->err = tcp_shutdown(msg->conn->pcb.tcp, 1, 0);
      }
    }
    if (state == NETCONN_NONE) {
#else /* LWIP_NETCONN_FULLDUPLEX */
      msg->err = ERR_INPROGRESS;
  10fc8c:	e51b3008 	ldr	r3, [fp, #-8]
  10fc90:	e3e02004 	mvn	r2, #4
  10fc94:	e5c32004 	strb	r2, [r3, #4]
    if (state == NETCONN_CONNECT) {
  10fc98:	ea000051 	b	10fde4 <lwip_netconn_do_close+0x1f0>
    } else {
#endif /* LWIP_NETCONN_FULLDUPLEX */
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
  10fc9c:	e51b3008 	ldr	r3, [fp, #-8]
  10fca0:	e5d33008 	ldrb	r3, [r3, #8]
  10fca4:	e2033001 	and	r3, r3, #1
  10fca8:	e3530000 	cmp	r3, #0
  10fcac:	0a000003 	beq	10fcc0 <lwip_netconn_do_close+0xcc>
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
  10fcb0:	e51b3008 	ldr	r3, [fp, #-8]
  10fcb4:	e5933000 	ldr	r3, [r3]
  10fcb8:	e1a00003 	mov	r0, r3
  10fcbc:	ebfff72a 	bl	10d96c <netconn_drain>
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
  10fcc0:	e51b3008 	ldr	r3, [fp, #-8]
  10fcc4:	e5933000 	ldr	r3, [r3]
  10fcc8:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  10fccc:	e3530000 	cmp	r3, #0
  10fcd0:	1a000004 	bne	10fce8 <lwip_netconn_do_close+0xf4>
  10fcd4:	e51b3008 	ldr	r3, [fp, #-8]
  10fcd8:	e5933000 	ldr	r3, [r3]
  10fcdc:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  10fce0:	e3530000 	cmp	r3, #0
  10fce4:	0a000006 	beq	10fd04 <lwip_netconn_do_close+0x110>
  10fce8:	e3060bd8 	movw	r0, #27608	; 0x6bd8
  10fcec:	e3400014 	movt	r0, #20
  10fcf0:	ebffcd07 	bl	103114 <rt_kprintf>
  10fcf4:	e3001716 	movw	r1, #1814	; 0x716
  10fcf8:	e30608bc 	movw	r0, #26812	; 0x68bc
  10fcfc:	e3400014 	movt	r0, #20
  10fd00:	ebffecdd 	bl	10b07c <sys_arch_assert>
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
  10fd04:	e51b3008 	ldr	r3, [fp, #-8]
  10fd08:	e5933000 	ldr	r3, [r3]
  10fd0c:	e3a02004 	mov	r2, #4
  10fd10:	e5832004 	str	r2, [r3, #4]
      msg->conn->current_msg = msg;
  10fd14:	e51b3008 	ldr	r3, [fp, #-8]
  10fd18:	e5933000 	ldr	r3, [r3]
  10fd1c:	e51b2008 	ldr	r2, [fp, #-8]
  10fd20:	e5832038 	str	r2, [r3, #56]	; 0x38
#if LWIP_TCPIP_CORE_LOCKING
      if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
  10fd24:	e51b3008 	ldr	r3, [fp, #-8]
  10fd28:	e5933000 	ldr	r3, [r3]
  10fd2c:	e3a01000 	mov	r1, #0
  10fd30:	e1a00003 	mov	r0, r3
  10fd34:	ebfff776 	bl	10db14 <lwip_netconn_do_close_internal>
  10fd38:	e1a03000 	mov	r3, r0
  10fd3c:	e3530000 	cmp	r3, #0
  10fd40:	0a000038 	beq	10fe28 <lwip_netconn_do_close+0x234>
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
  10fd44:	e51b3008 	ldr	r3, [fp, #-8]
  10fd48:	e5933000 	ldr	r3, [r3]
  10fd4c:	e5933004 	ldr	r3, [r3, #4]
  10fd50:	e3530004 	cmp	r3, #4
  10fd54:	0a000006 	beq	10fd74 <lwip_netconn_do_close+0x180>
  10fd58:	e3060bf4 	movw	r0, #27636	; 0x6bf4
  10fd5c:	e3400014 	movt	r0, #20
  10fd60:	ebffcceb 	bl	103114 <rt_kprintf>
  10fd64:	e300171b 	movw	r1, #1819	; 0x71b
  10fd68:	e30608bc 	movw	r0, #26812	; 0x68bc
  10fd6c:	e3400014 	movt	r0, #20
  10fd70:	ebffecc1 	bl	10b07c <sys_arch_assert>
        UNLOCK_TCPIP_CORE();
  10fd74:	e30005e4 	movw	r0, #1508	; 0x5e4
  10fd78:	e3400015 	movt	r0, #21
  10fd7c:	ebffeae9 	bl	10a928 <sys_mutex_unlock>
        sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
  10fd80:	e51b3008 	ldr	r3, [fp, #-8]
  10fd84:	e5933000 	ldr	r3, [r3]
  10fd88:	e2833010 	add	r3, r3, #16
  10fd8c:	e3a01000 	mov	r1, #0
  10fd90:	e1a00003 	mov	r0, r3
  10fd94:	ebffea67 	bl	10a738 <sys_arch_sem_wait>
        LOCK_TCPIP_CORE();
  10fd98:	e30005e4 	movw	r0, #1508	; 0x5e4
  10fd9c:	e3400015 	movt	r0, #21
  10fda0:	ebffead4 	bl	10a8f8 <sys_mutex_lock>
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
  10fda4:	e51b3008 	ldr	r3, [fp, #-8]
  10fda8:	e5933000 	ldr	r3, [r3]
  10fdac:	e5933004 	ldr	r3, [r3, #4]
  10fdb0:	e3530000 	cmp	r3, #0
  10fdb4:	0a00001b 	beq	10fe28 <lwip_netconn_do_close+0x234>
  10fdb8:	e3060bf4 	movw	r0, #27636	; 0x6bf4
  10fdbc:	e3400014 	movt	r0, #20
  10fdc0:	ebffccd3 	bl	103114 <rt_kprintf>
  10fdc4:	e300171f 	movw	r1, #1823	; 0x71f
  10fdc8:	e30608bc 	movw	r0, #26812	; 0x68bc
  10fdcc:	e3400014 	movt	r0, #20
  10fdd0:	ebffeca9 	bl	10b07c <sys_arch_assert>
      }
#else /* LWIP_TCPIP_CORE_LOCKING */
      lwip_netconn_do_close_internal(msg->conn);
#endif /* LWIP_TCPIP_CORE_LOCKING */
      /* for tcp netconns, lwip_netconn_do_close_internal ACKs the message */
      return;
  10fdd4:	ea000013 	b	10fe28 <lwip_netconn_do_close+0x234>
    }
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_CONN;
  10fdd8:	e51b3008 	ldr	r3, [fp, #-8]
  10fddc:	e3e0200a 	mvn	r2, #10
  10fde0:	e5c32004 	strb	r2, [r3, #4]
  }
  TCPIP_APIMSG_ACK(msg);
  10fde4:	e51b3008 	ldr	r3, [fp, #-8]
  10fde8:	e5933000 	ldr	r3, [r3]
  10fdec:	e3530000 	cmp	r3, #0
  10fdf0:	0a00000d 	beq	10fe2c <lwip_netconn_do_close+0x238>
  10fdf4:	ebffc910 	bl	10223c <rt_enter_critical>
  10fdf8:	e51b3008 	ldr	r3, [fp, #-8]
  10fdfc:	e5933000 	ldr	r3, [r3]
  10fe00:	e1d330dc 	ldrsb	r3, [r3, #12]
  10fe04:	e373000c 	cmn	r3, #12
  10fe08:	ba000004 	blt	10fe20 <lwip_netconn_do_close+0x22c>
  10fe0c:	e51b3008 	ldr	r3, [fp, #-8]
  10fe10:	e5933000 	ldr	r3, [r3]
  10fe14:	e51b2008 	ldr	r2, [fp, #-8]
  10fe18:	e1d220d4 	ldrsb	r2, [r2, #4]
  10fe1c:	e5c3200c 	strb	r2, [r3, #12]
  10fe20:	ebffc90b 	bl	102254 <rt_exit_critical>
  10fe24:	ea000000 	b	10fe2c <lwip_netconn_do_close+0x238>
      return;
  10fe28:	e320f000 	nop	{0}
}
  10fe2c:	e24bd004 	sub	sp, fp, #4
  10fe30:	e8bd8800 	pop	{fp, pc}

0010fe34 <lwip_netconn_do_join_leave_group>:
 *
 * @param m the api_msg_msg pointing to the connection
 */
void
lwip_netconn_do_join_leave_group(void *m)
{
  10fe34:	e92d4800 	push	{fp, lr}
  10fe38:	e28db004 	add	fp, sp, #4
  10fe3c:	e24dd010 	sub	sp, sp, #16
  10fe40:	e50b0010 	str	r0, [fp, #-16]
  struct api_msg *msg = (struct api_msg*)m;
  10fe44:	e51b3010 	ldr	r3, [fp, #-16]
  10fe48:	e50b3008 	str	r3, [fp, #-8]

  if (ERR_IS_FATAL(msg->conn->last_err)) {
  10fe4c:	e51b3008 	ldr	r3, [fp, #-8]
  10fe50:	e5933000 	ldr	r3, [r3]
  10fe54:	e1d330dc 	ldrsb	r3, [r3, #12]
  10fe58:	e373000c 	cmn	r3, #12
  10fe5c:	aa000005 	bge	10fe78 <lwip_netconn_do_join_leave_group+0x44>
    msg->err = msg->conn->last_err;
  10fe60:	e51b3008 	ldr	r3, [fp, #-8]
  10fe64:	e5933000 	ldr	r3, [r3]
  10fe68:	e1d320dc 	ldrsb	r2, [r3, #12]
  10fe6c:	e51b3008 	ldr	r3, [fp, #-8]
  10fe70:	e5c32004 	strb	r2, [r3, #4]
  10fe74:	ea00002d 	b	10ff30 <lwip_netconn_do_join_leave_group+0xfc>
  } else {
    if (msg->conn->pcb.tcp != NULL) {
  10fe78:	e51b3008 	ldr	r3, [fp, #-8]
  10fe7c:	e5933000 	ldr	r3, [r3]
  10fe80:	e5933008 	ldr	r3, [r3, #8]
  10fe84:	e3530000 	cmp	r3, #0
  10fe88:	0a000025 	beq	10ff24 <lwip_netconn_do_join_leave_group+0xf0>
      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  10fe8c:	e51b3008 	ldr	r3, [fp, #-8]
  10fe90:	e5933000 	ldr	r3, [r3]
  10fe94:	e5933000 	ldr	r3, [r3]
  10fe98:	e20330f0 	and	r3, r3, #240	; 0xf0
  10fe9c:	e3530020 	cmp	r3, #32
  10fea0:	1a00001b 	bne	10ff14 <lwip_netconn_do_join_leave_group+0xe0>
        }
        else
#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
        {
#if LWIP_IGMP
          if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
  10fea4:	e51b3008 	ldr	r3, [fp, #-8]
  10fea8:	e5933010 	ldr	r3, [r3, #16]
  10feac:	e3530000 	cmp	r3, #0
  10feb0:	1a00000b 	bne	10fee4 <lwip_netconn_do_join_leave_group+0xb0>
            msg->err = igmp_joingroup(ip_2_ip4(API_EXPR_REF(msg->msg.jl.netif_addr)),
  10feb4:	e51b3008 	ldr	r3, [fp, #-8]
  10feb8:	e593200c 	ldr	r2, [r3, #12]
              ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
  10febc:	e51b3008 	ldr	r3, [fp, #-8]
  10fec0:	e5933008 	ldr	r3, [r3, #8]
            msg->err = igmp_joingroup(ip_2_ip4(API_EXPR_REF(msg->msg.jl.netif_addr)),
  10fec4:	e1a01003 	mov	r1, r3
  10fec8:	e1a00002 	mov	r0, r2
  10fecc:	eb00828d 	bl	130908 <igmp_joingroup>
  10fed0:	e1a03000 	mov	r3, r0
  10fed4:	e1a02003 	mov	r2, r3
  10fed8:	e51b3008 	ldr	r3, [fp, #-8]
  10fedc:	e5c32004 	strb	r2, [r3, #4]
  10fee0:	ea000012 	b	10ff30 <lwip_netconn_do_join_leave_group+0xfc>
          } else {
            msg->err = igmp_leavegroup(ip_2_ip4(API_EXPR_REF(msg->msg.jl.netif_addr)),
  10fee4:	e51b3008 	ldr	r3, [fp, #-8]
  10fee8:	e593200c 	ldr	r2, [r3, #12]
              ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
  10feec:	e51b3008 	ldr	r3, [fp, #-8]
  10fef0:	e5933008 	ldr	r3, [r3, #8]
            msg->err = igmp_leavegroup(ip_2_ip4(API_EXPR_REF(msg->msg.jl.netif_addr)),
  10fef4:	e1a01003 	mov	r1, r3
  10fef8:	e1a00002 	mov	r0, r2
  10fefc:	eb00833a 	bl	130bec <igmp_leavegroup>
  10ff00:	e1a03000 	mov	r3, r0
  10ff04:	e1a02003 	mov	r2, r3
  10ff08:	e51b3008 	ldr	r3, [fp, #-8]
  10ff0c:	e5c32004 	strb	r2, [r3, #4]
  10ff10:	ea000006 	b	10ff30 <lwip_netconn_do_join_leave_group+0xfc>
#endif /* LWIP_IGMP */
        }
#endif /* LWIP_UDP */
#if (LWIP_TCP || LWIP_RAW)
      } else {
        msg->err = ERR_VAL;
  10ff14:	e51b3008 	ldr	r3, [fp, #-8]
  10ff18:	e3e02005 	mvn	r2, #5
  10ff1c:	e5c32004 	strb	r2, [r3, #4]
  10ff20:	ea000002 	b	10ff30 <lwip_netconn_do_join_leave_group+0xfc>
#endif /* (LWIP_TCP || LWIP_RAW) */
      }
    } else {
      msg->err = ERR_CONN;
  10ff24:	e51b3008 	ldr	r3, [fp, #-8]
  10ff28:	e3e0200a 	mvn	r2, #10
  10ff2c:	e5c32004 	strb	r2, [r3, #4]
    }
  }
  TCPIP_APIMSG_ACK(msg);
  10ff30:	e51b3008 	ldr	r3, [fp, #-8]
  10ff34:	e5933000 	ldr	r3, [r3]
  10ff38:	e3530000 	cmp	r3, #0
  10ff3c:	0a00000b 	beq	10ff70 <lwip_netconn_do_join_leave_group+0x13c>
  10ff40:	ebffc8bd 	bl	10223c <rt_enter_critical>
  10ff44:	e51b3008 	ldr	r3, [fp, #-8]
  10ff48:	e5933000 	ldr	r3, [r3]
  10ff4c:	e1d330dc 	ldrsb	r3, [r3, #12]
  10ff50:	e373000c 	cmn	r3, #12
  10ff54:	ba000004 	blt	10ff6c <lwip_netconn_do_join_leave_group+0x138>
  10ff58:	e51b3008 	ldr	r3, [fp, #-8]
  10ff5c:	e5933000 	ldr	r3, [r3]
  10ff60:	e51b2008 	ldr	r2, [fp, #-8]
  10ff64:	e1d220d4 	ldrsb	r2, [r2, #4]
  10ff68:	e5c3200c 	strb	r2, [r3, #12]
  10ff6c:	ebffc8b8 	bl	102254 <rt_exit_critical>
}
  10ff70:	e320f000 	nop	{0}
  10ff74:	e24bd004 	sub	sp, fp, #4
  10ff78:	e8bd8800 	pop	{fp, pc}

0010ff7c <lwip_netconn_do_dns_found>:
 * (or on timeout). A waiting application thread is waked up by
 * signaling the semaphore.
 */
static void
lwip_netconn_do_dns_found(const char *name, const ip_addr_t *ipaddr, void *arg)
{
  10ff7c:	e92d4800 	push	{fp, lr}
  10ff80:	e28db004 	add	fp, sp, #4
  10ff84:	e24dd018 	sub	sp, sp, #24
  10ff88:	e50b0010 	str	r0, [fp, #-16]
  10ff8c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  10ff90:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  struct dns_api_msg *msg = (struct dns_api_msg*)arg;
  10ff94:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  10ff98:	e50b3008 	str	r3, [fp, #-8]

  /* we trust the internal implementation to be correct :-) */
  LWIP_UNUSED_ARG(name);

  if (ipaddr == NULL) {
  10ff9c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  10ffa0:	e3530000 	cmp	r3, #0
  10ffa4:	1a000004 	bne	10ffbc <lwip_netconn_do_dns_found+0x40>
    /* timeout or memory error */
    API_EXPR_DEREF(msg->err) = ERR_VAL;
  10ffa8:	e51b3008 	ldr	r3, [fp, #-8]
  10ffac:	e593300c 	ldr	r3, [r3, #12]
  10ffb0:	e3e02005 	mvn	r2, #5
  10ffb4:	e5c32000 	strb	r2, [r3]
  10ffb8:	ea000008 	b	10ffe0 <lwip_netconn_do_dns_found+0x64>
  } else {
    /* address was resolved */
    API_EXPR_DEREF(msg->err) = ERR_OK;
  10ffbc:	e51b3008 	ldr	r3, [fp, #-8]
  10ffc0:	e593300c 	ldr	r3, [r3, #12]
  10ffc4:	e3a02000 	mov	r2, #0
  10ffc8:	e5c32000 	strb	r2, [r3]
    API_EXPR_DEREF(msg->addr) = *ipaddr;
  10ffcc:	e51b3008 	ldr	r3, [fp, #-8]
  10ffd0:	e5933004 	ldr	r3, [r3, #4]
  10ffd4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  10ffd8:	e5922000 	ldr	r2, [r2]
  10ffdc:	e5832000 	str	r2, [r3]
  }
  /* wake up the application task waiting in netconn_gethostbyname */
  sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
  10ffe0:	e51b3008 	ldr	r3, [fp, #-8]
  10ffe4:	e5933008 	ldr	r3, [r3, #8]
  10ffe8:	e1a00003 	mov	r0, r3
  10ffec:	ebffe9c6 	bl	10a70c <sys_sem_signal>
}
  10fff0:	e320f000 	nop	{0}
  10fff4:	e24bd004 	sub	sp, fp, #4
  10fff8:	e8bd8800 	pop	{fp, pc}

0010fffc <lwip_netconn_do_gethostbyname>:
 *
 * @param arg the dns_api_msg pointing to the query
 */
void
lwip_netconn_do_gethostbyname(void *arg)
{
  10fffc:	e92d4810 	push	{r4, fp, lr}
  110000:	e28db008 	add	fp, sp, #8
  110004:	e24dd01c 	sub	sp, sp, #28
  110008:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct dns_api_msg *msg = (struct dns_api_msg*)arg;
  11000c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  110010:	e50b3010 	str	r3, [fp, #-16]
  u8_t addrtype =
  110014:	e3a03000 	mov	r3, #0
  110018:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    msg->dns_addrtype;
#else
    LWIP_DNS_ADDRTYPE_DEFAULT;
#endif

  API_EXPR_DEREF(msg->err) = dns_gethostbyname_addrtype(msg->name,
  11001c:	e51b3010 	ldr	r3, [fp, #-16]
  110020:	e5930000 	ldr	r0, [r3]
  110024:	e51b3010 	ldr	r3, [fp, #-16]
  110028:	e5931004 	ldr	r1, [r3, #4]
  11002c:	e51b3010 	ldr	r3, [fp, #-16]
  110030:	e593400c 	ldr	r4, [r3, #12]
  110034:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  110038:	e58d3000 	str	r3, [sp]
  11003c:	e51b3010 	ldr	r3, [fp, #-16]
  110040:	e30f2f7c 	movw	r2, #65404	; 0xff7c
  110044:	e3402010 	movt	r2, #16
  110048:	eb0020d2 	bl	118398 <dns_gethostbyname_addrtype>
  11004c:	e1a03000 	mov	r3, r0
  110050:	e5c43000 	strb	r3, [r4]
    API_EXPR_REF(msg->addr), lwip_netconn_do_dns_found, msg, addrtype);
  if (API_EXPR_DEREF(msg->err) != ERR_INPROGRESS) {
  110054:	e51b3010 	ldr	r3, [fp, #-16]
  110058:	e593300c 	ldr	r3, [r3, #12]
  11005c:	e1d330d0 	ldrsb	r3, [r3]
  110060:	e3730005 	cmn	r3, #5
  110064:	0a000003 	beq	110078 <lwip_netconn_do_gethostbyname+0x7c>
    /* on error or immediate success, wake up the application
     * task waiting in netconn_gethostbyname */
    sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
  110068:	e51b3010 	ldr	r3, [fp, #-16]
  11006c:	e5933008 	ldr	r3, [r3, #8]
  110070:	e1a00003 	mov	r0, r3
  110074:	ebffe9a4 	bl	10a70c <sys_sem_signal>
  }
}
  110078:	e320f000 	nop	{0}
  11007c:	e24bd008 	sub	sp, fp, #8
  110080:	e8bd8810 	pop	{r4, fp, pc}

00110084 <err_to_errno>:
  EIO            /* ERR_ARG        -16     Illegal argument.        */
};

int
err_to_errno(err_t err)
{
  110084:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  110088:	e28db000 	add	fp, sp, #0
  11008c:	e24dd00c 	sub	sp, sp, #12
  110090:	e1a03000 	mov	r3, r0
  110094:	e54b3005 	strb	r3, [fp, #-5]
  if ((err > 0) || (-err >= (err_t)LWIP_ARRAYSIZE(err_to_errno_table))) {
  110098:	e15b30d5 	ldrsb	r3, [fp, #-5]
  11009c:	e3530000 	cmp	r3, #0
  1100a0:	ca000003 	bgt	1100b4 <err_to_errno+0x30>
  1100a4:	e15b30d5 	ldrsb	r3, [fp, #-5]
  1100a8:	e2633000 	rsb	r3, r3, #0
  1100ac:	e3530010 	cmp	r3, #16
  1100b0:	da000001 	ble	1100bc <err_to_errno+0x38>
    return EIO;
  1100b4:	e3a03005 	mov	r3, #5
  1100b8:	ea000004 	b	1100d0 <err_to_errno+0x4c>
  }
  return err_to_errno_table[-err];
  1100bc:	e15b30d5 	ldrsb	r3, [fp, #-5]
  1100c0:	e2632000 	rsb	r2, r3, #0
  1100c4:	e3063d58 	movw	r3, #27992	; 0x6d58
  1100c8:	e3403014 	movt	r3, #20
  1100cc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
}
  1100d0:	e1a00003 	mov	r0, r3
  1100d4:	e28bd000 	add	sp, fp, #0
  1100d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1100dc:	e12fff1e 	bx	lr

001100e0 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  1100e0:	e92d4800 	push	{fp, lr}
  1100e4:	e28db004 	add	fp, sp, #4
  1100e8:	e24dd008 	sub	sp, sp, #8
  struct netbuf *buf;

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
  1100ec:	e3a02043 	mov	r2, #67	; 0x43
  1100f0:	e3061d9c 	movw	r1, #28060	; 0x6d9c
  1100f4:	e3401014 	movt	r1, #20
  1100f8:	e3a00007 	mov	r0, #7
  1100fc:	eb002476 	bl	1192dc <memp_malloc_fn>
  110100:	e50b0008 	str	r0, [fp, #-8]
  if (buf != NULL) {
  110104:	e51b3008 	ldr	r3, [fp, #-8]
  110108:	e3530000 	cmp	r3, #0
  11010c:	0a000003 	beq	110120 <netbuf_new+0x40>
    memset(buf, 0, sizeof(struct netbuf));
  110110:	e3a02010 	mov	r2, #16
  110114:	e3a01000 	mov	r1, #0
  110118:	e51b0008 	ldr	r0, [fp, #-8]
  11011c:	eb00c4d4 	bl	141474 <memset>
  }
  return buf;
  110120:	e51b3008 	ldr	r3, [fp, #-8]
}
  110124:	e1a00003 	mov	r0, r3
  110128:	e24bd004 	sub	sp, fp, #4
  11012c:	e8bd8800 	pop	{fp, pc}

00110130 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  110130:	e92d4800 	push	{fp, lr}
  110134:	e28db004 	add	fp, sp, #4
  110138:	e24dd008 	sub	sp, sp, #8
  11013c:	e50b0008 	str	r0, [fp, #-8]
  if (buf != NULL) {
  110140:	e51b3008 	ldr	r3, [fp, #-8]
  110144:	e3530000 	cmp	r3, #0
  110148:	0a000011 	beq	110194 <netbuf_delete+0x64>
    if (buf->p != NULL) {
  11014c:	e51b3008 	ldr	r3, [fp, #-8]
  110150:	e5933000 	ldr	r3, [r3]
  110154:	e3530000 	cmp	r3, #0
  110158:	0a00000a 	beq	110188 <netbuf_delete+0x58>
      pbuf_free(buf->p);
  11015c:	e51b3008 	ldr	r3, [fp, #-8]
  110160:	e5933000 	ldr	r3, [r3]
  110164:	e1a00003 	mov	r0, r3
  110168:	eb002bd1 	bl	11b0b4 <pbuf_free>
      buf->p = buf->ptr = NULL;
  11016c:	e51b3008 	ldr	r3, [fp, #-8]
  110170:	e3a02000 	mov	r2, #0
  110174:	e5832004 	str	r2, [r3, #4]
  110178:	e51b3008 	ldr	r3, [fp, #-8]
  11017c:	e5932004 	ldr	r2, [r3, #4]
  110180:	e51b3008 	ldr	r3, [fp, #-8]
  110184:	e5832000 	str	r2, [r3]
    }
    memp_free(MEMP_NETBUF, buf);
  110188:	e51b1008 	ldr	r1, [fp, #-8]
  11018c:	e3a00007 	mov	r0, #7
  110190:	eb0024b9 	bl	11947c <memp_free>
  }
}
  110194:	e320f000 	nop	{0}
  110198:	e24bd004 	sub	sp, fp, #4
  11019c:	e8bd8800 	pop	{fp, pc}

001101a0 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  1101a0:	e92d4800 	push	{fp, lr}
  1101a4:	e28db004 	add	fp, sp, #4
  1101a8:	e24dd008 	sub	sp, sp, #8
  1101ac:	e50b0008 	str	r0, [fp, #-8]
  1101b0:	e1a03001 	mov	r3, r1
  1101b4:	e14b30ba 	strh	r3, [fp, #-10]
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  1101b8:	e51b3008 	ldr	r3, [fp, #-8]
  1101bc:	e3530000 	cmp	r3, #0
  1101c0:	1a000008 	bne	1101e8 <netbuf_alloc+0x48>
  1101c4:	e3060dcc 	movw	r0, #28108	; 0x6dcc
  1101c8:	e3400014 	movt	r0, #20
  1101cc:	ebffcbd0 	bl	103114 <rt_kprintf>
  1101d0:	e3a01068 	mov	r1, #104	; 0x68
  1101d4:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  1101d8:	e3400014 	movt	r0, #20
  1101dc:	ebffeba6 	bl	10b07c <sys_arch_assert>
  1101e0:	e3a03000 	mov	r3, #0
  1101e4:	ea000029 	b	110290 <netbuf_alloc+0xf0>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  1101e8:	e51b3008 	ldr	r3, [fp, #-8]
  1101ec:	e5933000 	ldr	r3, [r3]
  1101f0:	e3530000 	cmp	r3, #0
  1101f4:	0a000003 	beq	110208 <netbuf_alloc+0x68>
    pbuf_free(buf->p);
  1101f8:	e51b3008 	ldr	r3, [fp, #-8]
  1101fc:	e5933000 	ldr	r3, [r3]
  110200:	e1a00003 	mov	r0, r3
  110204:	eb002baa 	bl	11b0b4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  110208:	e15b30ba 	ldrh	r3, [fp, #-10]
  11020c:	e3a02000 	mov	r2, #0
  110210:	e1a01003 	mov	r1, r3
  110214:	e3a00000 	mov	r0, #0
  110218:	eb00289e 	bl	11a498 <pbuf_alloc>
  11021c:	e1a02000 	mov	r2, r0
  110220:	e51b3008 	ldr	r3, [fp, #-8]
  110224:	e5832000 	str	r2, [r3]
  if (buf->p == NULL) {
  110228:	e51b3008 	ldr	r3, [fp, #-8]
  11022c:	e5933000 	ldr	r3, [r3]
  110230:	e3530000 	cmp	r3, #0
  110234:	1a000001 	bne	110240 <netbuf_alloc+0xa0>
     return NULL;
  110238:	e3a03000 	mov	r3, #0
  11023c:	ea000013 	b	110290 <netbuf_alloc+0xf0>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  110240:	e51b3008 	ldr	r3, [fp, #-8]
  110244:	e5933000 	ldr	r3, [r3]
  110248:	e1d330ba 	ldrh	r3, [r3, #10]
  11024c:	e15b20ba 	ldrh	r2, [fp, #-10]
  110250:	e1520003 	cmp	r2, r3
  110254:	9a000006 	bls	110274 <netbuf_alloc+0xd4>
  110258:	e3060de8 	movw	r0, #28136	; 0x6de8
  11025c:	e3400014 	movt	r0, #20
  110260:	ebffcbab 	bl	103114 <rt_kprintf>
  110264:	e3a01073 	mov	r1, #115	; 0x73
  110268:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  11026c:	e3400014 	movt	r0, #20
  110270:	ebffeb81 	bl	10b07c <sys_arch_assert>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  110274:	e51b3008 	ldr	r3, [fp, #-8]
  110278:	e5932000 	ldr	r2, [r3]
  11027c:	e51b3008 	ldr	r3, [fp, #-8]
  110280:	e5832004 	str	r2, [r3, #4]
  return buf->p->payload;
  110284:	e51b3008 	ldr	r3, [fp, #-8]
  110288:	e5933000 	ldr	r3, [r3]
  11028c:	e5933004 	ldr	r3, [r3, #4]
}
  110290:	e1a00003 	mov	r0, r3
  110294:	e24bd004 	sub	sp, fp, #4
  110298:	e8bd8800 	pop	{fp, pc}

0011029c <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  11029c:	e92d4800 	push	{fp, lr}
  1102a0:	e28db004 	add	fp, sp, #4
  1102a4:	e24dd008 	sub	sp, sp, #8
  1102a8:	e50b0008 	str	r0, [fp, #-8]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  1102ac:	e51b3008 	ldr	r3, [fp, #-8]
  1102b0:	e3530000 	cmp	r3, #0
  1102b4:	1a000007 	bne	1102d8 <netbuf_free+0x3c>
  1102b8:	e3060e0c 	movw	r0, #28172	; 0x6e0c
  1102bc:	e3400014 	movt	r0, #20
  1102c0:	ebffcb93 	bl	103114 <rt_kprintf>
  1102c4:	e3a01081 	mov	r1, #129	; 0x81
  1102c8:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  1102cc:	e3400014 	movt	r0, #20
  1102d0:	ebffeb69 	bl	10b07c <sys_arch_assert>
  1102d4:	ea00000e 	b	110314 <netbuf_free+0x78>
  if (buf->p != NULL) {
  1102d8:	e51b3008 	ldr	r3, [fp, #-8]
  1102dc:	e5933000 	ldr	r3, [r3]
  1102e0:	e3530000 	cmp	r3, #0
  1102e4:	0a000003 	beq	1102f8 <netbuf_free+0x5c>
    pbuf_free(buf->p);
  1102e8:	e51b3008 	ldr	r3, [fp, #-8]
  1102ec:	e5933000 	ldr	r3, [r3]
  1102f0:	e1a00003 	mov	r0, r3
  1102f4:	eb002b6e 	bl	11b0b4 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  1102f8:	e51b3008 	ldr	r3, [fp, #-8]
  1102fc:	e3a02000 	mov	r2, #0
  110300:	e5832004 	str	r2, [r3, #4]
  110304:	e51b3008 	ldr	r3, [fp, #-8]
  110308:	e5932004 	ldr	r2, [r3, #4]
  11030c:	e51b3008 	ldr	r3, [fp, #-8]
  110310:	e5832000 	str	r2, [r3]
}
  110314:	e24bd004 	sub	sp, fp, #4
  110318:	e8bd8800 	pop	{fp, pc}

0011031c <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  11031c:	e92d4800 	push	{fp, lr}
  110320:	e28db004 	add	fp, sp, #4
  110324:	e24dd010 	sub	sp, sp, #16
  110328:	e50b0008 	str	r0, [fp, #-8]
  11032c:	e50b100c 	str	r1, [fp, #-12]
  110330:	e1a03002 	mov	r3, r2
  110334:	e14b30be 	strh	r3, [fp, #-14]
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  110338:	e51b3008 	ldr	r3, [fp, #-8]
  11033c:	e3530000 	cmp	r3, #0
  110340:	1a000008 	bne	110368 <netbuf_ref+0x4c>
  110344:	e3060e28 	movw	r0, #28200	; 0x6e28
  110348:	e3400014 	movt	r0, #20
  11034c:	ebffcb70 	bl	103114 <rt_kprintf>
  110350:	e3a01095 	mov	r1, #149	; 0x95
  110354:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  110358:	e3400014 	movt	r0, #20
  11035c:	ebffeb46 	bl	10b07c <sys_arch_assert>
  110360:	e3e0300f 	mvn	r3, #15
  110364:	ea000028 	b	11040c <netbuf_ref+0xf0>
  if (buf->p != NULL) {
  110368:	e51b3008 	ldr	r3, [fp, #-8]
  11036c:	e5933000 	ldr	r3, [r3]
  110370:	e3530000 	cmp	r3, #0
  110374:	0a000003 	beq	110388 <netbuf_ref+0x6c>
    pbuf_free(buf->p);
  110378:	e51b3008 	ldr	r3, [fp, #-8]
  11037c:	e5933000 	ldr	r3, [r3]
  110380:	e1a00003 	mov	r0, r3
  110384:	eb002b4a 	bl	11b0b4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  110388:	e3a02002 	mov	r2, #2
  11038c:	e3a01000 	mov	r1, #0
  110390:	e3a00000 	mov	r0, #0
  110394:	eb00283f 	bl	11a498 <pbuf_alloc>
  110398:	e1a02000 	mov	r2, r0
  11039c:	e51b3008 	ldr	r3, [fp, #-8]
  1103a0:	e5832000 	str	r2, [r3]
  if (buf->p == NULL) {
  1103a4:	e51b3008 	ldr	r3, [fp, #-8]
  1103a8:	e5933000 	ldr	r3, [r3]
  1103ac:	e3530000 	cmp	r3, #0
  1103b0:	1a000004 	bne	1103c8 <netbuf_ref+0xac>
    buf->ptr = NULL;
  1103b4:	e51b3008 	ldr	r3, [fp, #-8]
  1103b8:	e3a02000 	mov	r2, #0
  1103bc:	e5832004 	str	r2, [r3, #4]
    return ERR_MEM;
  1103c0:	e3e03000 	mvn	r3, #0
  1103c4:	ea000010 	b	11040c <netbuf_ref+0xf0>
  }
  ((struct pbuf_rom*)buf->p)->payload = dataptr;
  1103c8:	e51b3008 	ldr	r3, [fp, #-8]
  1103cc:	e5933000 	ldr	r3, [r3]
  1103d0:	e51b200c 	ldr	r2, [fp, #-12]
  1103d4:	e5832004 	str	r2, [r3, #4]
  buf->p->len = buf->p->tot_len = size;
  1103d8:	e51b3008 	ldr	r3, [fp, #-8]
  1103dc:	e5933000 	ldr	r3, [r3]
  1103e0:	e15b20be 	ldrh	r2, [fp, #-14]
  1103e4:	e1c320b8 	strh	r2, [r3, #8]
  1103e8:	e51b2008 	ldr	r2, [fp, #-8]
  1103ec:	e5922000 	ldr	r2, [r2]
  1103f0:	e1d330b8 	ldrh	r3, [r3, #8]
  1103f4:	e1c230ba 	strh	r3, [r2, #10]
  buf->ptr = buf->p;
  1103f8:	e51b3008 	ldr	r3, [fp, #-8]
  1103fc:	e5932000 	ldr	r2, [r3]
  110400:	e51b3008 	ldr	r3, [fp, #-8]
  110404:	e5832004 	str	r2, [r3, #4]
  return ERR_OK;
  110408:	e3a03000 	mov	r3, #0
}
  11040c:	e1a00003 	mov	r0, r3
  110410:	e24bd004 	sub	sp, fp, #4
  110414:	e8bd8800 	pop	{fp, pc}

00110418 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  110418:	e92d4800 	push	{fp, lr}
  11041c:	e28db004 	add	fp, sp, #4
  110420:	e24dd008 	sub	sp, sp, #8
  110424:	e50b0008 	str	r0, [fp, #-8]
  110428:	e50b100c 	str	r1, [fp, #-12]
  LWIP_ERROR("netbuf_chain: invalid head", (head != NULL), return;);
  11042c:	e51b3008 	ldr	r3, [fp, #-8]
  110430:	e3530000 	cmp	r3, #0
  110434:	1a000007 	bne	110458 <netbuf_chain+0x40>
  110438:	e3060e40 	movw	r0, #28224	; 0x6e40
  11043c:	e3400014 	movt	r0, #20
  110440:	ebffcb33 	bl	103114 <rt_kprintf>
  110444:	e3a010ae 	mov	r1, #174	; 0xae
  110448:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  11044c:	e3400014 	movt	r0, #20
  110450:	ebffeb09 	bl	10b07c <sys_arch_assert>
  110454:	ea000018 	b	1104bc <netbuf_chain+0xa4>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  110458:	e51b300c 	ldr	r3, [fp, #-12]
  11045c:	e3530000 	cmp	r3, #0
  110460:	1a000007 	bne	110484 <netbuf_chain+0x6c>
  110464:	e3060e5c 	movw	r0, #28252	; 0x6e5c
  110468:	e3400014 	movt	r0, #20
  11046c:	ebffcb28 	bl	103114 <rt_kprintf>
  110470:	e3a010af 	mov	r1, #175	; 0xaf
  110474:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  110478:	e3400014 	movt	r0, #20
  11047c:	ebffeafe 	bl	10b07c <sys_arch_assert>
  110480:	ea00000d 	b	1104bc <netbuf_chain+0xa4>
  pbuf_cat(head->p, tail->p);
  110484:	e51b3008 	ldr	r3, [fp, #-8]
  110488:	e5932000 	ldr	r2, [r3]
  11048c:	e51b300c 	ldr	r3, [fp, #-12]
  110490:	e5933000 	ldr	r3, [r3]
  110494:	e1a01003 	mov	r1, r3
  110498:	e1a00002 	mov	r0, r2
  11049c:	eb002bbb 	bl	11b390 <pbuf_cat>
  head->ptr = head->p;
  1104a0:	e51b3008 	ldr	r3, [fp, #-8]
  1104a4:	e5932000 	ldr	r2, [r3]
  1104a8:	e51b3008 	ldr	r3, [fp, #-8]
  1104ac:	e5832004 	str	r2, [r3, #4]
  memp_free(MEMP_NETBUF, tail);
  1104b0:	e51b100c 	ldr	r1, [fp, #-12]
  1104b4:	e3a00007 	mov	r0, #7
  1104b8:	eb0023ef 	bl	11947c <memp_free>
}
  1104bc:	e24bd004 	sub	sp, fp, #4
  1104c0:	e8bd8800 	pop	{fp, pc}

001104c4 <netbuf_data>:
 * @return ERR_OK if the information was retrieved,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  1104c4:	e92d4800 	push	{fp, lr}
  1104c8:	e28db004 	add	fp, sp, #4
  1104cc:	e24dd010 	sub	sp, sp, #16
  1104d0:	e50b0008 	str	r0, [fp, #-8]
  1104d4:	e50b100c 	str	r1, [fp, #-12]
  1104d8:	e50b2010 	str	r2, [fp, #-16]
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  1104dc:	e51b3008 	ldr	r3, [fp, #-8]
  1104e0:	e3530000 	cmp	r3, #0
  1104e4:	1a000008 	bne	11050c <netbuf_data+0x48>
  1104e8:	e3060e78 	movw	r0, #28280	; 0x6e78
  1104ec:	e3400014 	movt	r0, #20
  1104f0:	ebffcb07 	bl	103114 <rt_kprintf>
  1104f4:	e3a010c2 	mov	r1, #194	; 0xc2
  1104f8:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  1104fc:	e3400014 	movt	r0, #20
  110500:	ebffeadd 	bl	10b07c <sys_arch_assert>
  110504:	e3e0300f 	mvn	r3, #15
  110508:	ea000028 	b	1105b0 <netbuf_data+0xec>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  11050c:	e51b300c 	ldr	r3, [fp, #-12]
  110510:	e3530000 	cmp	r3, #0
  110514:	1a000008 	bne	11053c <netbuf_data+0x78>
  110518:	e3060e94 	movw	r0, #28308	; 0x6e94
  11051c:	e3400014 	movt	r0, #20
  110520:	ebffcafb 	bl	103114 <rt_kprintf>
  110524:	e3a010c3 	mov	r1, #195	; 0xc3
  110528:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  11052c:	e3400014 	movt	r0, #20
  110530:	ebffead1 	bl	10b07c <sys_arch_assert>
  110534:	e3e0300f 	mvn	r3, #15
  110538:	ea00001c 	b	1105b0 <netbuf_data+0xec>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  11053c:	e51b3010 	ldr	r3, [fp, #-16]
  110540:	e3530000 	cmp	r3, #0
  110544:	1a000008 	bne	11056c <netbuf_data+0xa8>
  110548:	e3060eb4 	movw	r0, #28340	; 0x6eb4
  11054c:	e3400014 	movt	r0, #20
  110550:	ebffcaef 	bl	103114 <rt_kprintf>
  110554:	e3a010c4 	mov	r1, #196	; 0xc4
  110558:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  11055c:	e3400014 	movt	r0, #20
  110560:	ebffeac5 	bl	10b07c <sys_arch_assert>
  110564:	e3e0300f 	mvn	r3, #15
  110568:	ea000010 	b	1105b0 <netbuf_data+0xec>

  if (buf->ptr == NULL) {
  11056c:	e51b3008 	ldr	r3, [fp, #-8]
  110570:	e5933004 	ldr	r3, [r3, #4]
  110574:	e3530000 	cmp	r3, #0
  110578:	1a000001 	bne	110584 <netbuf_data+0xc0>
    return ERR_BUF;
  11057c:	e3e03001 	mvn	r3, #1
  110580:	ea00000a 	b	1105b0 <netbuf_data+0xec>
  }
  *dataptr = buf->ptr->payload;
  110584:	e51b3008 	ldr	r3, [fp, #-8]
  110588:	e5933004 	ldr	r3, [r3, #4]
  11058c:	e5932004 	ldr	r2, [r3, #4]
  110590:	e51b300c 	ldr	r3, [fp, #-12]
  110594:	e5832000 	str	r2, [r3]
  *len = buf->ptr->len;
  110598:	e51b3008 	ldr	r3, [fp, #-8]
  11059c:	e5933004 	ldr	r3, [r3, #4]
  1105a0:	e1d320ba 	ldrh	r2, [r3, #10]
  1105a4:	e51b3010 	ldr	r3, [fp, #-16]
  1105a8:	e1c320b0 	strh	r2, [r3]
  return ERR_OK;
  1105ac:	e3a03000 	mov	r3, #0
}
  1105b0:	e1a00003 	mov	r0, r3
  1105b4:	e24bd004 	sub	sp, fp, #4
  1105b8:	e8bd8800 	pop	{fp, pc}

001105bc <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  1105bc:	e92d4800 	push	{fp, lr}
  1105c0:	e28db004 	add	fp, sp, #4
  1105c4:	e24dd008 	sub	sp, sp, #8
  1105c8:	e50b0008 	str	r0, [fp, #-8]
  LWIP_ERROR("netbuf_next: invalid buf", (buf != NULL), return -1;);
  1105cc:	e51b3008 	ldr	r3, [fp, #-8]
  1105d0:	e3530000 	cmp	r3, #0
  1105d4:	1a000008 	bne	1105fc <netbuf_next+0x40>
  1105d8:	e3060ed0 	movw	r0, #28368	; 0x6ed0
  1105dc:	e3400014 	movt	r0, #20
  1105e0:	ebffcacb 	bl	103114 <rt_kprintf>
  1105e4:	e3a010dc 	mov	r1, #220	; 0xdc
  1105e8:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  1105ec:	e3400014 	movt	r0, #20
  1105f0:	ebffeaa1 	bl	10b07c <sys_arch_assert>
  1105f4:	e3e03000 	mvn	r3, #0
  1105f8:	ea000013 	b	11064c <netbuf_next+0x90>
  if (buf->ptr->next == NULL) {
  1105fc:	e51b3008 	ldr	r3, [fp, #-8]
  110600:	e5933004 	ldr	r3, [r3, #4]
  110604:	e5933000 	ldr	r3, [r3]
  110608:	e3530000 	cmp	r3, #0
  11060c:	1a000001 	bne	110618 <netbuf_next+0x5c>
    return -1;
  110610:	e3e03000 	mvn	r3, #0
  110614:	ea00000c 	b	11064c <netbuf_next+0x90>
  }
  buf->ptr = buf->ptr->next;
  110618:	e51b3008 	ldr	r3, [fp, #-8]
  11061c:	e5933004 	ldr	r3, [r3, #4]
  110620:	e5932000 	ldr	r2, [r3]
  110624:	e51b3008 	ldr	r3, [fp, #-8]
  110628:	e5832004 	str	r2, [r3, #4]
  if (buf->ptr->next == NULL) {
  11062c:	e51b3008 	ldr	r3, [fp, #-8]
  110630:	e5933004 	ldr	r3, [r3, #4]
  110634:	e5933000 	ldr	r3, [r3]
  110638:	e3530000 	cmp	r3, #0
  11063c:	1a000001 	bne	110648 <netbuf_next+0x8c>
    return 1;
  110640:	e3a03001 	mov	r3, #1
  110644:	ea000000 	b	11064c <netbuf_next+0x90>
  }
  return 0;
  110648:	e3a03000 	mov	r3, #0
}
  11064c:	e1a00003 	mov	r0, r3
  110650:	e24bd004 	sub	sp, fp, #4
  110654:	e8bd8800 	pop	{fp, pc}

00110658 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  110658:	e92d4800 	push	{fp, lr}
  11065c:	e28db004 	add	fp, sp, #4
  110660:	e24dd008 	sub	sp, sp, #8
  110664:	e50b0008 	str	r0, [fp, #-8]
  LWIP_ERROR("netbuf_first: invalid buf", (buf != NULL), return;);
  110668:	e51b3008 	ldr	r3, [fp, #-8]
  11066c:	e3530000 	cmp	r3, #0
  110670:	1a000007 	bne	110694 <netbuf_first+0x3c>
  110674:	e3060eec 	movw	r0, #28396	; 0x6eec
  110678:	e3400014 	movt	r0, #20
  11067c:	ebffcaa4 	bl	103114 <rt_kprintf>
  110680:	e3a010f2 	mov	r1, #242	; 0xf2
  110684:	e3060d9c 	movw	r0, #28060	; 0x6d9c
  110688:	e3400014 	movt	r0, #20
  11068c:	ebffea7a 	bl	10b07c <sys_arch_assert>
  110690:	ea000003 	b	1106a4 <netbuf_first+0x4c>
  buf->ptr = buf->p;
  110694:	e51b3008 	ldr	r3, [fp, #-8]
  110698:	e5932000 	ldr	r2, [r3]
  11069c:	e51b3008 	ldr	r3, [fp, #-8]
  1106a0:	e5832004 	str	r2, [r3, #4]
}
  1106a4:	e24bd004 	sub	sp, fp, #4
  1106a8:	e8bd8800 	pop	{fp, pc}

001106ac <lwip_gethostbyname>:
 * @return an entry containing addresses of address family AF_INET
 *         for the host with name name
 */
struct hostent*
lwip_gethostbyname(const char *name)
{
  1106ac:	e92d4800 	push	{fp, lr}
  1106b0:	e28db004 	add	fp, sp, #4
  1106b4:	e24dd010 	sub	sp, sp, #16
  1106b8:	e50b0010 	str	r0, [fp, #-16]
  HOSTENT_STORAGE ip_addr_t s_hostent_addr;
  HOSTENT_STORAGE ip_addr_t *s_phostent_addr[2];
  HOSTENT_STORAGE char s_hostname[DNS_MAX_NAME_LENGTH + 1];

  /* query host IP address */
  err = netconn_gethostbyname(name, &addr);
  1106bc:	e24b300c 	sub	r3, fp, #12
  1106c0:	e1a01003 	mov	r1, r3
  1106c4:	e51b0010 	ldr	r0, [fp, #-16]
  1106c8:	ebffef98 	bl	10c530 <netconn_gethostbyname>
  1106cc:	e1a03000 	mov	r3, r0
  1106d0:	e54b3005 	strb	r3, [fp, #-5]
  if (err != ERR_OK) {
  1106d4:	e15b30d5 	ldrsb	r3, [fp, #-5]
  1106d8:	e3530000 	cmp	r3, #0
  1106dc:	0a000005 	beq	1106f8 <lwip_gethostbyname+0x4c>
    LWIP_DEBUGF(DNS_DEBUG, ("lwip_gethostbyname(%s) failed, err=%d\n", name, err));
    h_errno = HOST_NOT_FOUND;
  1106e0:	e3003580 	movw	r3, #1408	; 0x580
  1106e4:	e3403015 	movt	r3, #21
  1106e8:	e3a020d2 	mov	r2, #210	; 0xd2
  1106ec:	e5832000 	str	r2, [r3]
    return NULL;
  1106f0:	e3a03000 	mov	r3, #0
  1106f4:	ea000032 	b	1107c4 <lwip_gethostbyname+0x118>
  }

  /* fill hostent */
  s_hostent_addr = addr;
  1106f8:	e30e3a58 	movw	r3, #59992	; 0xea58
  1106fc:	e3403014 	movt	r3, #20
  110700:	e51b200c 	ldr	r2, [fp, #-12]
  110704:	e5832000 	str	r2, [r3]
  s_phostent_addr[0] = &s_hostent_addr;
  110708:	e30e3a5c 	movw	r3, #59996	; 0xea5c
  11070c:	e3403014 	movt	r3, #20
  110710:	e30e2a58 	movw	r2, #59992	; 0xea58
  110714:	e3402014 	movt	r2, #20
  110718:	e5832000 	str	r2, [r3]
  s_phostent_addr[1] = NULL;
  11071c:	e30e3a5c 	movw	r3, #59996	; 0xea5c
  110720:	e3403014 	movt	r3, #20
  110724:	e3a02000 	mov	r2, #0
  110728:	e5832004 	str	r2, [r3, #4]
  strncpy(s_hostname, name, DNS_MAX_NAME_LENGTH);
  11072c:	e3a02c01 	mov	r2, #256	; 0x100
  110730:	e51b1010 	ldr	r1, [fp, #-16]
  110734:	e30e0a64 	movw	r0, #60004	; 0xea64
  110738:	e3400014 	movt	r0, #20
  11073c:	eb00c42e 	bl	1417fc <strncpy>
  s_hostname[DNS_MAX_NAME_LENGTH] = 0;
  110740:	e30e3a64 	movw	r3, #60004	; 0xea64
  110744:	e3403014 	movt	r3, #20
  110748:	e3a02000 	mov	r2, #0
  11074c:	e5c32100 	strb	r2, [r3, #256]	; 0x100
  s_hostent.h_name = s_hostname;
  110750:	e30e3b68 	movw	r3, #60264	; 0xeb68
  110754:	e3403014 	movt	r3, #20
  110758:	e30e2a64 	movw	r2, #60004	; 0xea64
  11075c:	e3402014 	movt	r2, #20
  110760:	e5832000 	str	r2, [r3]
  s_aliases = NULL;
  110764:	e30e3b7c 	movw	r3, #60284	; 0xeb7c
  110768:	e3403014 	movt	r3, #20
  11076c:	e3a02000 	mov	r2, #0
  110770:	e5832000 	str	r2, [r3]
  s_hostent.h_aliases = &s_aliases;
  110774:	e30e3b68 	movw	r3, #60264	; 0xeb68
  110778:	e3403014 	movt	r3, #20
  11077c:	e30e2b7c 	movw	r2, #60284	; 0xeb7c
  110780:	e3402014 	movt	r2, #20
  110784:	e5832004 	str	r2, [r3, #4]
  s_hostent.h_addrtype = AF_INET;
  110788:	e30e3b68 	movw	r3, #60264	; 0xeb68
  11078c:	e3403014 	movt	r3, #20
  110790:	e3a02002 	mov	r2, #2
  110794:	e5832008 	str	r2, [r3, #8]
  s_hostent.h_length = sizeof(ip_addr_t);
  110798:	e30e3b68 	movw	r3, #60264	; 0xeb68
  11079c:	e3403014 	movt	r3, #20
  1107a0:	e3a02004 	mov	r2, #4
  1107a4:	e583200c 	str	r2, [r3, #12]
  s_hostent.h_addr_list = (char**)&s_phostent_addr;
  1107a8:	e30e3b68 	movw	r3, #60264	; 0xeb68
  1107ac:	e3403014 	movt	r3, #20
  1107b0:	e30e2a5c 	movw	r2, #59996	; 0xea5c
  1107b4:	e3402014 	movt	r2, #20
  1107b8:	e5832010 	str	r2, [r3, #16]

#if LWIP_DNS_API_HOSTENT_STORAGE
  /* this function should return the "per-thread" hostent after copy from s_hostent */
  return sys_thread_hostent(&s_hostent);
#else
  return &s_hostent;
  1107bc:	e30e3b68 	movw	r3, #60264	; 0xeb68
  1107c0:	e3403014 	movt	r3, #20
#endif /* LWIP_DNS_API_HOSTENT_STORAGE */
}
  1107c4:	e1a00003 	mov	r0, r3
  1107c8:	e24bd004 	sub	sp, fp, #4
  1107cc:	e8bd8800 	pop	{fp, pc}

001107d0 <lwip_gethostbyname_r>:
 *         is stored in *h_errnop instead of h_errno to be thread-safe
 */
int
lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
                size_t buflen, struct hostent **result, int *h_errnop)
{
  1107d0:	e92d4800 	push	{fp, lr}
  1107d4:	e28db004 	add	fp, sp, #4
  1107d8:	e24dd028 	sub	sp, sp, #40	; 0x28
  1107dc:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  1107e0:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  1107e4:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  1107e8:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
  struct gethostbyname_r_helper *h;
  char *hostname;
  size_t namelen;
  int lh_errno;

  if (h_errnop == NULL) {
  1107ec:	e59b3008 	ldr	r3, [fp, #8]
  1107f0:	e3530000 	cmp	r3, #0
  1107f4:	1a000001 	bne	110800 <lwip_gethostbyname_r+0x30>
    /* ensure h_errnop is never NULL */
    h_errnop = &lh_errno;
  1107f8:	e24b3018 	sub	r3, fp, #24
  1107fc:	e58b3008 	str	r3, [fp, #8]
  }

  if (result == NULL) {
  110800:	e59b3004 	ldr	r3, [fp, #4]
  110804:	e3530000 	cmp	r3, #0
  110808:	1a000004 	bne	110820 <lwip_gethostbyname_r+0x50>
    /* not all arguments given */
    *h_errnop = EINVAL;
  11080c:	e59b3008 	ldr	r3, [fp, #8]
  110810:	e3a02016 	mov	r2, #22
  110814:	e5832000 	str	r2, [r3]
    return -1;
  110818:	e3e03000 	mvn	r3, #0
  11081c:	ea00005a 	b	11098c <lwip_gethostbyname_r+0x1bc>
  }
  /* first thing to do: set *result to nothing */
  *result = NULL;
  110820:	e59b3004 	ldr	r3, [fp, #4]
  110824:	e3a02000 	mov	r2, #0
  110828:	e5832000 	str	r2, [r3]
  if ((name == NULL) || (ret == NULL) || (buf == NULL)) {
  11082c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110830:	e3530000 	cmp	r3, #0
  110834:	0a000005 	beq	110850 <lwip_gethostbyname_r+0x80>
  110838:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11083c:	e3530000 	cmp	r3, #0
  110840:	0a000002 	beq	110850 <lwip_gethostbyname_r+0x80>
  110844:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  110848:	e3530000 	cmp	r3, #0
  11084c:	1a000004 	bne	110864 <lwip_gethostbyname_r+0x94>
    /* not all arguments given */
    *h_errnop = EINVAL;
  110850:	e59b3008 	ldr	r3, [fp, #8]
  110854:	e3a02016 	mov	r2, #22
  110858:	e5832000 	str	r2, [r3]
    return -1;
  11085c:	e3e03000 	mvn	r3, #0
  110860:	ea000049 	b	11098c <lwip_gethostbyname_r+0x1bc>
  }

  namelen = strlen(name);
  110864:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  110868:	eb00c392 	bl	1416b8 <strlen>
  11086c:	e50b0008 	str	r0, [fp, #-8]
  if (buflen < (sizeof(struct gethostbyname_r_helper) + namelen + 1 + (MEM_ALIGNMENT - 1))) {
  110870:	e51b3008 	ldr	r3, [fp, #-8]
  110874:	e2833014 	add	r3, r3, #20
  110878:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  11087c:	e1520003 	cmp	r2, r3
  110880:	2a000004 	bcs	110898 <lwip_gethostbyname_r+0xc8>
    /* buf can't hold the data needed + a copy of name */
    *h_errnop = ERANGE;
  110884:	e59b3008 	ldr	r3, [fp, #8]
  110888:	e3a02022 	mov	r2, #34	; 0x22
  11088c:	e5832000 	str	r2, [r3]
    return -1;
  110890:	e3e03000 	mvn	r3, #0
  110894:	ea00003c 	b	11098c <lwip_gethostbyname_r+0x1bc>
  }

  h = (struct gethostbyname_r_helper*)LWIP_MEM_ALIGN(buf);
  110898:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11089c:	e2833003 	add	r3, r3, #3
  1108a0:	e3c33003 	bic	r3, r3, #3
  1108a4:	e50b300c 	str	r3, [fp, #-12]
  hostname = ((char*)h) + sizeof(struct gethostbyname_r_helper);
  1108a8:	e51b300c 	ldr	r3, [fp, #-12]
  1108ac:	e2833010 	add	r3, r3, #16
  1108b0:	e50b3010 	str	r3, [fp, #-16]

  /* query host IP address */
  err = netconn_gethostbyname(name, &h->addr);
  1108b4:	e51b300c 	ldr	r3, [fp, #-12]
  1108b8:	e2833008 	add	r3, r3, #8
  1108bc:	e1a01003 	mov	r1, r3
  1108c0:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  1108c4:	ebffef19 	bl	10c530 <netconn_gethostbyname>
  1108c8:	e1a03000 	mov	r3, r0
  1108cc:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  if (err != ERR_OK) {
  1108d0:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  1108d4:	e3530000 	cmp	r3, #0
  1108d8:	0a000004 	beq	1108f0 <lwip_gethostbyname_r+0x120>
    LWIP_DEBUGF(DNS_DEBUG, ("lwip_gethostbyname(%s) failed, err=%d\n", name, err));
    *h_errnop = HOST_NOT_FOUND;
  1108dc:	e59b3008 	ldr	r3, [fp, #8]
  1108e0:	e3a020d2 	mov	r2, #210	; 0xd2
  1108e4:	e5832000 	str	r2, [r3]
    return -1;
  1108e8:	e3e03000 	mvn	r3, #0
  1108ec:	ea000026 	b	11098c <lwip_gethostbyname_r+0x1bc>
  }

  /* copy the hostname into buf */
  MEMCPY(hostname, name, namelen);
  1108f0:	e51b2008 	ldr	r2, [fp, #-8]
  1108f4:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  1108f8:	e51b0010 	ldr	r0, [fp, #-16]
  1108fc:	eb00c1a4 	bl	140f94 <memcpy>
  hostname[namelen] = 0;
  110900:	e51b2010 	ldr	r2, [fp, #-16]
  110904:	e51b3008 	ldr	r3, [fp, #-8]
  110908:	e0823003 	add	r3, r2, r3
  11090c:	e3a02000 	mov	r2, #0
  110910:	e5c32000 	strb	r2, [r3]

  /* fill hostent */
  h->addr_list[0] = &h->addr;
  110914:	e51b300c 	ldr	r3, [fp, #-12]
  110918:	e2832008 	add	r2, r3, #8
  11091c:	e51b300c 	ldr	r3, [fp, #-12]
  110920:	e5832000 	str	r2, [r3]
  h->addr_list[1] = NULL;
  110924:	e51b300c 	ldr	r3, [fp, #-12]
  110928:	e3a02000 	mov	r2, #0
  11092c:	e5832004 	str	r2, [r3, #4]
  h->aliases = NULL;
  110930:	e51b300c 	ldr	r3, [fp, #-12]
  110934:	e3a02000 	mov	r2, #0
  110938:	e583200c 	str	r2, [r3, #12]
  ret->h_name = hostname;
  11093c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  110940:	e51b2010 	ldr	r2, [fp, #-16]
  110944:	e5832000 	str	r2, [r3]
  ret->h_aliases = &h->aliases;
  110948:	e51b300c 	ldr	r3, [fp, #-12]
  11094c:	e283200c 	add	r2, r3, #12
  110950:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  110954:	e5832004 	str	r2, [r3, #4]
  ret->h_addrtype = AF_INET;
  110958:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11095c:	e3a02002 	mov	r2, #2
  110960:	e5832008 	str	r2, [r3, #8]
  ret->h_length = sizeof(ip_addr_t);
  110964:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  110968:	e3a02004 	mov	r2, #4
  11096c:	e583200c 	str	r2, [r3, #12]
  ret->h_addr_list = (char**)&h->addr_list;
  110970:	e51b200c 	ldr	r2, [fp, #-12]
  110974:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  110978:	e5832010 	str	r2, [r3, #16]

  /* set result != NULL */
  *result = ret;
  11097c:	e59b3004 	ldr	r3, [fp, #4]
  110980:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  110984:	e5832000 	str	r2, [r3]

  /* return success */
  return 0;
  110988:	e3a03000 	mov	r3, #0
}
  11098c:	e1a00003 	mov	r0, r3
  110990:	e24bd004 	sub	sp, fp, #4
  110994:	e8bd8800 	pop	{fp, pc}

00110998 <lwip_freeaddrinfo>:
 *
 * @param ai struct addrinfo to free
 */
void
lwip_freeaddrinfo(struct addrinfo *ai)
{
  110998:	e92d4800 	push	{fp, lr}
  11099c:	e28db004 	add	fp, sp, #4
  1109a0:	e24dd010 	sub	sp, sp, #16
  1109a4:	e50b0010 	str	r0, [fp, #-16]
  struct addrinfo *next;

  while (ai != NULL) {
  1109a8:	ea000007 	b	1109cc <lwip_freeaddrinfo+0x34>
    next = ai->ai_next;
  1109ac:	e51b3010 	ldr	r3, [fp, #-16]
  1109b0:	e593301c 	ldr	r3, [r3, #28]
  1109b4:	e50b3008 	str	r3, [fp, #-8]
    memp_free(MEMP_NETDB, ai);
  1109b8:	e51b1010 	ldr	r1, [fp, #-16]
  1109bc:	e3a0000e 	mov	r0, #14
  1109c0:	eb0022ad 	bl	11947c <memp_free>
    ai = next;
  1109c4:	e51b3008 	ldr	r3, [fp, #-8]
  1109c8:	e50b3010 	str	r3, [fp, #-16]
  while (ai != NULL) {
  1109cc:	e51b3010 	ldr	r3, [fp, #-16]
  1109d0:	e3530000 	cmp	r3, #0
  1109d4:	1afffff4 	bne	1109ac <lwip_freeaddrinfo+0x14>
  }
}
  1109d8:	e320f000 	nop	{0}
  1109dc:	e24bd004 	sub	sp, fp, #4
  1109e0:	e8bd8800 	pop	{fp, pc}

001109e4 <lwip_getaddrinfo>:
 * @todo: implement AI_V4MAPPED, AI_ADDRCONFIG
 */
int
lwip_getaddrinfo(const char *nodename, const char *servname,
       const struct addrinfo *hints, struct addrinfo **res)
{
  1109e4:	e92d4800 	push	{fp, lr}
  1109e8:	e28db004 	add	fp, sp, #4
  1109ec:	e24dd038 	sub	sp, sp, #56	; 0x38
  1109f0:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  1109f4:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
  1109f8:	e50b2038 	str	r2, [fp, #-56]	; 0xffffffc8
  1109fc:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  err_t err;
  ip_addr_t addr;
  struct addrinfo *ai;
  struct sockaddr_storage *sa = NULL;
  110a00:	e3a03000 	mov	r3, #0
  110a04:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  int port_nr = 0;
  110a08:	e3a03000 	mov	r3, #0
  110a0c:	e50b3008 	str	r3, [fp, #-8]
  size_t total_size;
  size_t namelen = 0;
  110a10:	e3a03000 	mov	r3, #0
  110a14:	e50b3010 	str	r3, [fp, #-16]
  int ai_family;

  if (res == NULL) {
  110a18:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  110a1c:	e3530000 	cmp	r3, #0
  110a20:	1a000001 	bne	110a2c <lwip_getaddrinfo+0x48>
    return EAI_FAIL;
  110a24:	e3a030ca 	mov	r3, #202	; 0xca
  110a28:	ea0000d0 	b	110d70 <lwip_getaddrinfo+0x38c>
  }
  *res = NULL;
  110a2c:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  110a30:	e3a02000 	mov	r2, #0
  110a34:	e5832000 	str	r2, [r3]
  if ((nodename == NULL) && (servname == NULL)) {
  110a38:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  110a3c:	e3530000 	cmp	r3, #0
  110a40:	1a000004 	bne	110a58 <lwip_getaddrinfo+0x74>
  110a44:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  110a48:	e3530000 	cmp	r3, #0
  110a4c:	1a000001 	bne	110a58 <lwip_getaddrinfo+0x74>
    return EAI_NONAME;
  110a50:	e3a030c8 	mov	r3, #200	; 0xc8
  110a54:	ea0000c5 	b	110d70 <lwip_getaddrinfo+0x38c>
  }

  if (hints != NULL) {
  110a58:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110a5c:	e3530000 	cmp	r3, #0
  110a60:	0a00000a 	beq	110a90 <lwip_getaddrinfo+0xac>
    ai_family = hints->ai_family;
  110a64:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110a68:	e5933004 	ldr	r3, [r3, #4]
  110a6c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    if ((ai_family != AF_UNSPEC)
  110a70:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  110a74:	e3530000 	cmp	r3, #0
  110a78:	0a000006 	beq	110a98 <lwip_getaddrinfo+0xb4>
#if LWIP_IPV4
      && (ai_family != AF_INET)
  110a7c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  110a80:	e3530002 	cmp	r3, #2
  110a84:	0a000003 	beq	110a98 <lwip_getaddrinfo+0xb4>
#endif /* LWIP_IPV4 */
#if LWIP_IPV6
      && (ai_family != AF_INET6)
#endif /* LWIP_IPV6 */
      ) {
      return EAI_FAMILY;
  110a88:	e3a030cc 	mov	r3, #204	; 0xcc
  110a8c:	ea0000b7 	b	110d70 <lwip_getaddrinfo+0x38c>
    }
  } else {
    ai_family = AF_UNSPEC;
  110a90:	e3a03000 	mov	r3, #0
  110a94:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  }

  if (servname != NULL) {
  110a98:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  110a9c:	e3530000 	cmp	r3, #0
  110aa0:	0a00000a 	beq	110ad0 <lwip_getaddrinfo+0xec>
    /* service name specified: convert to port number
     * @todo?: currently, only ASCII integers (port numbers) are supported (AI_NUMERICSERV)! */
    port_nr = atoi(servname);
  110aa4:	e51b0034 	ldr	r0, [fp, #-52]	; 0xffffffcc
  110aa8:	eb00c10d 	bl	140ee4 <atoi>
  110aac:	e50b0008 	str	r0, [fp, #-8]
    if ((port_nr <= 0) || (port_nr > 0xffff)) {
  110ab0:	e51b3008 	ldr	r3, [fp, #-8]
  110ab4:	e3530000 	cmp	r3, #0
  110ab8:	da000002 	ble	110ac8 <lwip_getaddrinfo+0xe4>
  110abc:	e51b3008 	ldr	r3, [fp, #-8]
  110ac0:	e3530801 	cmp	r3, #65536	; 0x10000
  110ac4:	ba000001 	blt	110ad0 <lwip_getaddrinfo+0xec>
      return EAI_SERVICE;
  110ac8:	e3a030c9 	mov	r3, #201	; 0xc9
  110acc:	ea0000a7 	b	110d70 <lwip_getaddrinfo+0x38c>
    }
  }

  if (nodename != NULL) {
  110ad0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  110ad4:	e3530000 	cmp	r3, #0
  110ad8:	0a00001b 	beq	110b4c <lwip_getaddrinfo+0x168>
    /* service location specified, try to resolve */
    if ((hints != NULL) && (hints->ai_flags & AI_NUMERICHOST)) {
  110adc:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110ae0:	e3530000 	cmp	r3, #0
  110ae4:	0a00000d 	beq	110b20 <lwip_getaddrinfo+0x13c>
  110ae8:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110aec:	e5933000 	ldr	r3, [r3]
  110af0:	e2033004 	and	r3, r3, #4
  110af4:	e3530000 	cmp	r3, #0
  110af8:	0a000008 	beq	110b20 <lwip_getaddrinfo+0x13c>
      /* no DNS lookup, just parse for an address string */
      if (!ipaddr_aton(nodename, &addr)) {
  110afc:	e24b3028 	sub	r3, fp, #40	; 0x28
  110b00:	e1a01003 	mov	r1, r3
  110b04:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  110b08:	eb008775 	bl	1328e4 <ip4addr_aton>
  110b0c:	e1a03000 	mov	r3, r0
  110b10:	e3530000 	cmp	r3, #0
  110b14:	1a00001a 	bne	110b84 <lwip_getaddrinfo+0x1a0>
        return EAI_NONAME;
  110b18:	e3a030c8 	mov	r3, #200	; 0xc8
  110b1c:	ea000093 	b	110d70 <lwip_getaddrinfo+0x38c>
        type = NETCONN_DNS_IPV4;
      } else if (ai_family == AF_INET6) {
        type = NETCONN_DNS_IPV6;
      }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
      err = netconn_gethostbyname_addrtype(nodename, &addr, type);
  110b20:	e24b3028 	sub	r3, fp, #40	; 0x28
  110b24:	e1a01003 	mov	r1, r3
  110b28:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  110b2c:	ebffee7f 	bl	10c530 <netconn_gethostbyname>
  110b30:	e1a03000 	mov	r3, r0
  110b34:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
      if (err != ERR_OK) {
  110b38:	e15b31d9 	ldrsb	r3, [fp, #-25]	; 0xffffffe7
  110b3c:	e3530000 	cmp	r3, #0
  110b40:	0a00000f 	beq	110b84 <lwip_getaddrinfo+0x1a0>
        return EAI_FAIL;
  110b44:	e3a030ca 	mov	r3, #202	; 0xca
  110b48:	ea000088 	b	110d70 <lwip_getaddrinfo+0x38c>
      }
    }
  } else {
    /* service location specified, use loopback address */
    if ((hints != NULL) && (hints->ai_flags & AI_PASSIVE)) {
  110b4c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110b50:	e3530000 	cmp	r3, #0
  110b54:	0a000007 	beq	110b78 <lwip_getaddrinfo+0x194>
  110b58:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110b5c:	e5933000 	ldr	r3, [r3]
  110b60:	e2033001 	and	r3, r3, #1
  110b64:	e3530000 	cmp	r3, #0
  110b68:	0a000002 	beq	110b78 <lwip_getaddrinfo+0x194>
      ip_addr_set_any(ai_family == AF_INET6, &addr);
  110b6c:	e3a03000 	mov	r3, #0
  110b70:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  110b74:	ea000002 	b	110b84 <lwip_getaddrinfo+0x1a0>
    } else {
      ip_addr_set_loopback(ai_family == AF_INET6, &addr);
  110b78:	e3a0307f 	mov	r3, #127	; 0x7f
  110b7c:	e3403100 	movt	r3, #256	; 0x100
  110b80:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
    }
  }

  total_size = sizeof(struct addrinfo) + sizeof(struct sockaddr_storage);
  110b84:	e3a03030 	mov	r3, #48	; 0x30
  110b88:	e50b300c 	str	r3, [fp, #-12]
  if (nodename != NULL) {
  110b8c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  110b90:	e3530000 	cmp	r3, #0
  110b94:	0a00001a 	beq	110c04 <lwip_getaddrinfo+0x220>
    namelen = strlen(nodename);
  110b98:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  110b9c:	eb00c2c5 	bl	1416b8 <strlen>
  110ba0:	e50b0010 	str	r0, [fp, #-16]
    if (namelen > DNS_MAX_NAME_LENGTH) {
  110ba4:	e51b3010 	ldr	r3, [fp, #-16]
  110ba8:	e3530c01 	cmp	r3, #256	; 0x100
  110bac:	9a000001 	bls	110bb8 <lwip_getaddrinfo+0x1d4>
      /* invalid name length */
      return EAI_FAIL;
  110bb0:	e3a030ca 	mov	r3, #202	; 0xca
  110bb4:	ea00006d 	b	110d70 <lwip_getaddrinfo+0x38c>
    }
    LWIP_ASSERT("namelen is too long", total_size + namelen + 1 > total_size);
  110bb8:	e51b200c 	ldr	r2, [fp, #-12]
  110bbc:	e51b3010 	ldr	r3, [fp, #-16]
  110bc0:	e0823003 	add	r3, r2, r3
  110bc4:	e2833001 	add	r3, r3, #1
  110bc8:	e51b200c 	ldr	r2, [fp, #-12]
  110bcc:	e1520003 	cmp	r2, r3
  110bd0:	3a000006 	bcc	110bf0 <lwip_getaddrinfo+0x20c>
  110bd4:	e3060f08 	movw	r0, #28424	; 0x6f08
  110bd8:	e3400014 	movt	r0, #20
  110bdc:	ebffc94c 	bl	103114 <rt_kprintf>
  110be0:	e3001166 	movw	r1, #358	; 0x166
  110be4:	e3060f1c 	movw	r0, #28444	; 0x6f1c
  110be8:	e3400014 	movt	r0, #20
  110bec:	ebffe922 	bl	10b07c <sys_arch_assert>
    total_size += namelen + 1;
  110bf0:	e51b2010 	ldr	r2, [fp, #-16]
  110bf4:	e51b300c 	ldr	r3, [fp, #-12]
  110bf8:	e0823003 	add	r3, r2, r3
  110bfc:	e2833001 	add	r3, r3, #1
  110c00:	e50b300c 	str	r3, [fp, #-12]
  }
  /* If this fails, please report to lwip-devel! :-) */
  LWIP_ASSERT("total_size <= NETDB_ELEM_SIZE: please report this!",
  110c04:	e51b300c 	ldr	r3, [fp, #-12]
  110c08:	e3002131 	movw	r2, #305	; 0x131
  110c0c:	e1530002 	cmp	r3, r2
  110c10:	9a000006 	bls	110c30 <lwip_getaddrinfo+0x24c>
  110c14:	e3060f48 	movw	r0, #28488	; 0x6f48
  110c18:	e3400014 	movt	r0, #20
  110c1c:	ebffc93c 	bl	103114 <rt_kprintf>
  110c20:	e300116b 	movw	r1, #363	; 0x16b
  110c24:	e3060f1c 	movw	r0, #28444	; 0x6f1c
  110c28:	e3400014 	movt	r0, #20
  110c2c:	ebffe912 	bl	10b07c <sys_arch_assert>
    total_size <= NETDB_ELEM_SIZE);
  ai = (struct addrinfo *)memp_malloc(MEMP_NETDB);
  110c30:	e3a02f5b 	mov	r2, #364	; 0x16c
  110c34:	e3061f1c 	movw	r1, #28444	; 0x6f1c
  110c38:	e3401014 	movt	r1, #20
  110c3c:	e3a0000e 	mov	r0, #14
  110c40:	eb0021a5 	bl	1192dc <memp_malloc_fn>
  110c44:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  if (ai == NULL) {
  110c48:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110c4c:	e3530000 	cmp	r3, #0
  110c50:	1a000001 	bne	110c5c <lwip_getaddrinfo+0x278>
    return EAI_MEMORY;
  110c54:	e3a030cb 	mov	r3, #203	; 0xcb
  110c58:	ea000044 	b	110d70 <lwip_getaddrinfo+0x38c>
  }
  memset(ai, 0, total_size);
  110c5c:	e51b200c 	ldr	r2, [fp, #-12]
  110c60:	e3a01000 	mov	r1, #0
  110c64:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  110c68:	eb00c201 	bl	141474 <memset>
  /* cast through void* to get rid of alignment warnings */
  sa = (struct sockaddr_storage *)(void*)((u8_t*)ai + sizeof(struct addrinfo));
  110c6c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110c70:	e2833020 	add	r3, r3, #32
  110c74:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    sa6->sin6_port = lwip_htons((u16_t)port_nr);
    ai->ai_family = AF_INET6;
#endif /* LWIP_IPV6 */
  } else {
#if LWIP_IPV4
    struct sockaddr_in *sa4 = (struct sockaddr_in*)sa;
  110c78:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  110c7c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    /* set up sockaddr */
    inet_addr_from_ip4addr(&sa4->sin_addr, ip_2_ip4(&addr));
  110c80:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  110c84:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  110c88:	e5832004 	str	r2, [r3, #4]
    sa4->sin_family = AF_INET;
  110c8c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  110c90:	e3a02002 	mov	r2, #2
  110c94:	e5c32001 	strb	r2, [r3, #1]
    sa4->sin_len = sizeof(struct sockaddr_in);
  110c98:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  110c9c:	e3a02010 	mov	r2, #16
  110ca0:	e5c32000 	strb	r2, [r3]
    sa4->sin_port = lwip_htons((u16_t)port_nr);
  110ca4:	e51b3008 	ldr	r3, [fp, #-8]
  110ca8:	e6ff3073 	uxth	r3, r3
  110cac:	e1a00003 	mov	r0, r3
  110cb0:	eb0016c8 	bl	1167d8 <lwip_htons>
  110cb4:	e1a03000 	mov	r3, r0
  110cb8:	e1a02003 	mov	r2, r3
  110cbc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  110cc0:	e1c320b2 	strh	r2, [r3, #2]
    ai->ai_family = AF_INET;
  110cc4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110cc8:	e3a02002 	mov	r2, #2
  110ccc:	e5832004 	str	r2, [r3, #4]
#endif /* LWIP_IPV4 */
  }

  /* set up addrinfo */
  if (hints != NULL) {
  110cd0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110cd4:	e3530000 	cmp	r3, #0
  110cd8:	0a000007 	beq	110cfc <lwip_getaddrinfo+0x318>
    /* copy socktype & protocol from hints if specified */
    ai->ai_socktype = hints->ai_socktype;
  110cdc:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110ce0:	e5932008 	ldr	r2, [r3, #8]
  110ce4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110ce8:	e5832008 	str	r2, [r3, #8]
    ai->ai_protocol = hints->ai_protocol;
  110cec:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110cf0:	e593200c 	ldr	r2, [r3, #12]
  110cf4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110cf8:	e583200c 	str	r2, [r3, #12]
  }
  if (nodename != NULL) {
  110cfc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  110d00:	e3530000 	cmp	r3, #0
  110d04:	0a00000f 	beq	110d48 <lwip_getaddrinfo+0x364>
    /* copy nodename to canonname if specified */
    ai->ai_canonname = ((char*)ai + sizeof(struct addrinfo) + sizeof(struct sockaddr_storage));
  110d08:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110d0c:	e2832030 	add	r2, r3, #48	; 0x30
  110d10:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110d14:	e5832018 	str	r2, [r3, #24]
    MEMCPY(ai->ai_canonname, nodename, namelen);
  110d18:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110d1c:	e5933018 	ldr	r3, [r3, #24]
  110d20:	e51b2010 	ldr	r2, [fp, #-16]
  110d24:	e51b1030 	ldr	r1, [fp, #-48]	; 0xffffffd0
  110d28:	e1a00003 	mov	r0, r3
  110d2c:	eb00c098 	bl	140f94 <memcpy>
    ai->ai_canonname[namelen] = 0;
  110d30:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110d34:	e5932018 	ldr	r2, [r3, #24]
  110d38:	e51b3010 	ldr	r3, [fp, #-16]
  110d3c:	e0823003 	add	r3, r2, r3
  110d40:	e3a02000 	mov	r2, #0
  110d44:	e5c32000 	strb	r2, [r3]
  }
  ai->ai_addrlen = sizeof(struct sockaddr_storage);
  110d48:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110d4c:	e3a02010 	mov	r2, #16
  110d50:	e5832010 	str	r2, [r3, #16]
  ai->ai_addr = (struct sockaddr*)sa;
  110d54:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  110d58:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  110d5c:	e5832014 	str	r2, [r3, #20]

  *res = ai;
  110d60:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  110d64:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  110d68:	e5832000 	str	r2, [r3]

  return 0;
  110d6c:	e3a03000 	mov	r3, #0
}
  110d70:	e1a00003 	mov	r0, r3
  110d74:	e24bd004 	sub	sp, fp, #4
  110d78:	e8bd8800 	pop	{fp, pc}

00110d7c <netifapi_do_netif_add>:
/**
 * Call netif_add() inside the tcpip_thread context.
 */
static err_t
netifapi_do_netif_add(struct tcpip_api_call_data *m)
{
  110d7c:	e92d4810 	push	{r4, fp, lr}
  110d80:	e28db008 	add	fp, sp, #8
  110d84:	e24dd024 	sub	sp, sp, #36	; 0x24
  110d88:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  /* cast through void* to silence alignment warnings. 
   * We know it works because the structs have been instantiated as struct netifapi_msg */
  struct netifapi_msg *msg = (struct netifapi_msg*)(void*)m;
  110d8c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  110d90:	e50b3010 	str	r3, [fp, #-16]
  if (!netif_add( msg->netif,
  110d94:	e51b3010 	ldr	r3, [fp, #-16]
  110d98:	e5930004 	ldr	r0, [r3, #4]
  110d9c:	e51b3010 	ldr	r3, [fp, #-16]
  110da0:	e593c008 	ldr	ip, [r3, #8]
  110da4:	e51b3010 	ldr	r3, [fp, #-16]
  110da8:	e593e00c 	ldr	lr, [r3, #12]
  110dac:	e51b3010 	ldr	r3, [fp, #-16]
  110db0:	e5934010 	ldr	r4, [r3, #16]
  110db4:	e51b3010 	ldr	r3, [fp, #-16]
  110db8:	e5933014 	ldr	r3, [r3, #20]
  110dbc:	e51b2010 	ldr	r2, [fp, #-16]
  110dc0:	e5922018 	ldr	r2, [r2, #24]
  110dc4:	e51b1010 	ldr	r1, [fp, #-16]
  110dc8:	e591101c 	ldr	r1, [r1, #28]
  110dcc:	e58d1008 	str	r1, [sp, #8]
  110dd0:	e58d2004 	str	r2, [sp, #4]
  110dd4:	e58d3000 	str	r3, [sp]
  110dd8:	e1a03004 	mov	r3, r4
  110ddc:	e1a0200e 	mov	r2, lr
  110de0:	e1a0100c 	mov	r1, ip
  110de4:	eb0021de 	bl	119564 <netif_add>
  110de8:	e1a03000 	mov	r3, r0
  110dec:	e3530000 	cmp	r3, #0
  110df0:	1a000001 	bne	110dfc <netifapi_do_netif_add+0x80>
                  API_EXPR_REF(msg->msg.add.gw),
#endif /* LWIP_IPV4 */
                  msg->msg.add.state,
                  msg->msg.add.init,
                  msg->msg.add.input)) {
    return ERR_IF;
  110df4:	e3e0300b 	mvn	r3, #11
  110df8:	ea000000 	b	110e00 <netifapi_do_netif_add+0x84>
  } else {
    return ERR_OK;
  110dfc:	e3a03000 	mov	r3, #0
  }
}
  110e00:	e1a00003 	mov	r0, r3
  110e04:	e24bd008 	sub	sp, fp, #8
  110e08:	e8bd8810 	pop	{r4, fp, pc}

00110e0c <netifapi_do_netif_set_addr>:
/**
 * Call netif_set_addr() inside the tcpip_thread context.
 */
static err_t
netifapi_do_netif_set_addr(struct tcpip_api_call_data *m)
{
  110e0c:	e92d4800 	push	{fp, lr}
  110e10:	e28db004 	add	fp, sp, #4
  110e14:	e24dd010 	sub	sp, sp, #16
  110e18:	e50b0010 	str	r0, [fp, #-16]
  /* cast through void* to silence alignment warnings. 
   * We know it works because the structs have been instantiated as struct netifapi_msg */
  struct netifapi_msg *msg = (struct netifapi_msg*)(void*)m;
  110e1c:	e51b3010 	ldr	r3, [fp, #-16]
  110e20:	e50b3008 	str	r3, [fp, #-8]

  netif_set_addr( msg->netif,
  110e24:	e51b3008 	ldr	r3, [fp, #-8]
  110e28:	e5930004 	ldr	r0, [r3, #4]
  110e2c:	e51b3008 	ldr	r3, [fp, #-8]
  110e30:	e5931008 	ldr	r1, [r3, #8]
  110e34:	e51b3008 	ldr	r3, [fp, #-8]
  110e38:	e593200c 	ldr	r2, [r3, #12]
  110e3c:	e51b3008 	ldr	r3, [fp, #-8]
  110e40:	e5933010 	ldr	r3, [r3, #16]
  110e44:	eb00222c 	bl	1196fc <netif_set_addr>
                  API_EXPR_REF(msg->msg.add.ipaddr),
                  API_EXPR_REF(msg->msg.add.netmask),
                  API_EXPR_REF(msg->msg.add.gw));
  return ERR_OK;
  110e48:	e3a03000 	mov	r3, #0
}
  110e4c:	e1a00003 	mov	r0, r3
  110e50:	e24bd004 	sub	sp, fp, #4
  110e54:	e8bd8800 	pop	{fp, pc}

00110e58 <netifapi_do_netif_common>:
 * Call the "errtfunc" (or the "voidfunc" if "errtfunc" is NULL) inside the
 * tcpip_thread context.
 */
static err_t
netifapi_do_netif_common(struct tcpip_api_call_data *m)
{
  110e58:	e92d4800 	push	{fp, lr}
  110e5c:	e28db004 	add	fp, sp, #4
  110e60:	e24dd010 	sub	sp, sp, #16
  110e64:	e50b0010 	str	r0, [fp, #-16]
  /* cast through void* to silence alignment warnings. 
   * We know it works because the structs have been instantiated as struct netifapi_msg */
  struct netifapi_msg *msg = (struct netifapi_msg*)(void*)m;
  110e68:	e51b3010 	ldr	r3, [fp, #-16]
  110e6c:	e50b3008 	str	r3, [fp, #-8]

  if (msg->msg.common.errtfunc != NULL) {
  110e70:	e51b3008 	ldr	r3, [fp, #-8]
  110e74:	e593300c 	ldr	r3, [r3, #12]
  110e78:	e3530000 	cmp	r3, #0
  110e7c:	0a000007 	beq	110ea0 <netifapi_do_netif_common+0x48>
    return msg->msg.common.errtfunc(msg->netif);
  110e80:	e51b3008 	ldr	r3, [fp, #-8]
  110e84:	e593300c 	ldr	r3, [r3, #12]
  110e88:	e51b2008 	ldr	r2, [fp, #-8]
  110e8c:	e5922004 	ldr	r2, [r2, #4]
  110e90:	e1a00002 	mov	r0, r2
  110e94:	e12fff33 	blx	r3
  110e98:	e1a03000 	mov	r3, r0
  110e9c:	ea000006 	b	110ebc <netifapi_do_netif_common+0x64>
  } else {
    msg->msg.common.voidfunc(msg->netif);
  110ea0:	e51b3008 	ldr	r3, [fp, #-8]
  110ea4:	e5933008 	ldr	r3, [r3, #8]
  110ea8:	e51b2008 	ldr	r2, [fp, #-8]
  110eac:	e5922004 	ldr	r2, [r2, #4]
  110eb0:	e1a00002 	mov	r0, r2
  110eb4:	e12fff33 	blx	r3
    return ERR_OK;
  110eb8:	e3a03000 	mov	r3, #0
  }
}
  110ebc:	e1a00003 	mov	r0, r3
  110ec0:	e24bd004 	sub	sp, fp, #4
  110ec4:	e8bd8800 	pop	{fp, pc}

00110ec8 <netifapi_netif_add>:
netifapi_netif_add(struct netif *netif,
#if LWIP_IPV4
                   const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
#endif /* LWIP_IPV4 */
                   void *state, netif_init_fn init, netif_input_fn input)
{
  110ec8:	e92d4800 	push	{fp, lr}
  110ecc:	e28db004 	add	fp, sp, #4
  110ed0:	e24dd038 	sub	sp, sp, #56	; 0x38
  110ed4:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  110ed8:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
  110edc:	e50b2038 	str	r2, [fp, #-56]	; 0xffffffc8
  110ee0:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  err_t err;
  NETIFAPI_VAR_DECLARE(msg);
  NETIFAPI_VAR_ALLOC(msg);

#if LWIP_IPV4
  if (ipaddr == NULL) {
  110ee4:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  110ee8:	e3530000 	cmp	r3, #0
  110eec:	1a000002 	bne	110efc <netifapi_netif_add+0x34>
    ipaddr = IP4_ADDR_ANY4;
  110ef0:	e3093b24 	movw	r3, #39716	; 0x9b24
  110ef4:	e3403014 	movt	r3, #20
  110ef8:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
  }
  if (netmask == NULL) {
  110efc:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110f00:	e3530000 	cmp	r3, #0
  110f04:	1a000002 	bne	110f14 <netifapi_netif_add+0x4c>
    netmask = IP4_ADDR_ANY4;
  110f08:	e3093b24 	movw	r3, #39716	; 0x9b24
  110f0c:	e3403014 	movt	r3, #20
  110f10:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
  }
  if (gw == NULL) {
  110f14:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  110f18:	e3530000 	cmp	r3, #0
  110f1c:	1a000002 	bne	110f2c <netifapi_netif_add+0x64>
    gw = IP4_ADDR_ANY4;
  110f20:	e3093b24 	movw	r3, #39716	; 0x9b24
  110f24:	e3403014 	movt	r3, #20
  110f28:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  }
#endif /* LWIP_IPV4 */

  NETIFAPI_VAR_REF(msg).netif = netif;
  110f2c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  110f30:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
#if LWIP_IPV4
  NETIFAPI_VAR_REF(msg).msg.add.ipaddr  = NETIFAPI_VAR_REF(ipaddr);
  110f34:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  110f38:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  NETIFAPI_VAR_REF(msg).msg.add.netmask = NETIFAPI_VAR_REF(netmask);
  110f3c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110f40:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  NETIFAPI_VAR_REF(msg).msg.add.gw      = NETIFAPI_VAR_REF(gw);
  110f44:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  110f48:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
#endif /* LWIP_IPV4 */
  NETIFAPI_VAR_REF(msg).msg.add.state   = state;
  110f4c:	e59b3004 	ldr	r3, [fp, #4]
  110f50:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  NETIFAPI_VAR_REF(msg).msg.add.init    = init;
  110f54:	e59b3008 	ldr	r3, [fp, #8]
  110f58:	e50b3010 	str	r3, [fp, #-16]
  NETIFAPI_VAR_REF(msg).msg.add.input   = input;
  110f5c:	e59b300c 	ldr	r3, [fp, #12]
  110f60:	e50b300c 	str	r3, [fp, #-12]
  err = tcpip_api_call(netifapi_do_netif_add, &API_VAR_REF(msg).call);
  110f64:	e24b3028 	sub	r3, fp, #40	; 0x28
  110f68:	e1a01003 	mov	r1, r3
  110f6c:	e3000d7c 	movw	r0, #3452	; 0xd7c
  110f70:	e3400011 	movt	r0, #17
  110f74:	eb001569 	bl	116520 <tcpip_api_call>
  110f78:	e1a03000 	mov	r3, r0
  110f7c:	e54b3005 	strb	r3, [fp, #-5]
  NETIFAPI_VAR_FREE(msg);
  return err;
  110f80:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  110f84:	e1a00003 	mov	r0, r3
  110f88:	e24bd004 	sub	sp, fp, #4
  110f8c:	e8bd8800 	pop	{fp, pc}

00110f90 <netifapi_netif_set_addr>:
err_t
netifapi_netif_set_addr(struct netif *netif,
                        const ip4_addr_t *ipaddr,
                        const ip4_addr_t *netmask,
                        const ip4_addr_t *gw)
{
  110f90:	e92d4800 	push	{fp, lr}
  110f94:	e28db004 	add	fp, sp, #4
  110f98:	e24dd038 	sub	sp, sp, #56	; 0x38
  110f9c:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  110fa0:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
  110fa4:	e50b2038 	str	r2, [fp, #-56]	; 0xffffffc8
  110fa8:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  err_t err;
  NETIFAPI_VAR_DECLARE(msg);
  NETIFAPI_VAR_ALLOC(msg);

  if (ipaddr == NULL) {
  110fac:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  110fb0:	e3530000 	cmp	r3, #0
  110fb4:	1a000002 	bne	110fc4 <netifapi_netif_set_addr+0x34>
    ipaddr = IP4_ADDR_ANY4;
  110fb8:	e3093b24 	movw	r3, #39716	; 0x9b24
  110fbc:	e3403014 	movt	r3, #20
  110fc0:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
  }
  if (netmask == NULL) {
  110fc4:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  110fc8:	e3530000 	cmp	r3, #0
  110fcc:	1a000002 	bne	110fdc <netifapi_netif_set_addr+0x4c>
    netmask = IP4_ADDR_ANY4;
  110fd0:	e3093b24 	movw	r3, #39716	; 0x9b24
  110fd4:	e3403014 	movt	r3, #20
  110fd8:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
  }
  if (gw == NULL) {
  110fdc:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  110fe0:	e3530000 	cmp	r3, #0
  110fe4:	1a000002 	bne	110ff4 <netifapi_netif_set_addr+0x64>
    gw = IP4_ADDR_ANY4;
  110fe8:	e3093b24 	movw	r3, #39716	; 0x9b24
  110fec:	e3403014 	movt	r3, #20
  110ff0:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  }

  NETIFAPI_VAR_REF(msg).netif = netif;
  110ff4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  110ff8:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  NETIFAPI_VAR_REF(msg).msg.add.ipaddr  = NETIFAPI_VAR_REF(ipaddr);
  110ffc:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  111000:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  NETIFAPI_VAR_REF(msg).msg.add.netmask = NETIFAPI_VAR_REF(netmask);
  111004:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  111008:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  NETIFAPI_VAR_REF(msg).msg.add.gw      = NETIFAPI_VAR_REF(gw);
  11100c:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  111010:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  err = tcpip_api_call(netifapi_do_netif_set_addr, &API_VAR_REF(msg).call);
  111014:	e24b3028 	sub	r3, fp, #40	; 0x28
  111018:	e1a01003 	mov	r1, r3
  11101c:	e3000e0c 	movw	r0, #3596	; 0xe0c
  111020:	e3400011 	movt	r0, #17
  111024:	eb00153d 	bl	116520 <tcpip_api_call>
  111028:	e1a03000 	mov	r3, r0
  11102c:	e54b3005 	strb	r3, [fp, #-5]
  NETIFAPI_VAR_FREE(msg);
  return err;
  111030:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  111034:	e1a00003 	mov	r0, r3
  111038:	e24bd004 	sub	sp, fp, #4
  11103c:	e8bd8800 	pop	{fp, pc}

00111040 <netifapi_netif_common>:
 * @note use only for functions where there is only "netif" parameter.
 */
err_t
netifapi_netif_common(struct netif *netif, netifapi_void_fn voidfunc,
                       netifapi_errt_fn errtfunc)
{
  111040:	e92d4800 	push	{fp, lr}
  111044:	e28db004 	add	fp, sp, #4
  111048:	e24dd038 	sub	sp, sp, #56	; 0x38
  11104c:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  111050:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
  111054:	e50b2038 	str	r2, [fp, #-56]	; 0xffffffc8
  err_t err;
  NETIFAPI_VAR_DECLARE(msg);
  NETIFAPI_VAR_ALLOC(msg);

  NETIFAPI_VAR_REF(msg).netif = netif;
  111058:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  11105c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  NETIFAPI_VAR_REF(msg).msg.common.voidfunc = voidfunc;
  111060:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  111064:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  NETIFAPI_VAR_REF(msg).msg.common.errtfunc = errtfunc;
  111068:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  11106c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  err = tcpip_api_call(netifapi_do_netif_common, &API_VAR_REF(msg).call);
  111070:	e24b3028 	sub	r3, fp, #40	; 0x28
  111074:	e1a01003 	mov	r1, r3
  111078:	e3000e58 	movw	r0, #3672	; 0xe58
  11107c:	e3400011 	movt	r0, #17
  111080:	eb001526 	bl	116520 <tcpip_api_call>
  111084:	e1a03000 	mov	r3, r0
  111088:	e54b3005 	strb	r3, [fp, #-5]
  NETIFAPI_VAR_FREE(msg);
  return err;
  11108c:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  111090:	e1a00003 	mov	r0, r3
  111094:	e24bd004 	sub	sp, fp, #4
  111098:	e8bd8800 	pop	{fp, pc}

0011109c <access_is_blocking>:
static u8_t lwip_getsockopt_impl(int s, int level, int optname, void *optval, socklen_t *optlen);
static u8_t lwip_setsockopt_impl(int s, int level, int optname, const void *optval, socklen_t optlen);

/* *RT-Thread* */
int access_is_blocking(u32_t flags, struct lwip_sock *sock)
{
  11109c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1110a0:	e28db000 	add	fp, sp, #0
  1110a4:	e24dd00c 	sub	sp, sp, #12
  1110a8:	e50b0008 	str	r0, [fp, #-8]
  1110ac:	e50b100c 	str	r1, [fp, #-12]
  return !((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn));
  1110b0:	e51b3008 	ldr	r3, [fp, #-8]
  1110b4:	e2033008 	and	r3, r3, #8
  1110b8:	e3530000 	cmp	r3, #0
  1110bc:	1a000007 	bne	1110e0 <access_is_blocking+0x44>
  1110c0:	e51b300c 	ldr	r3, [fp, #-12]
  1110c4:	e5933000 	ldr	r3, [r3]
  1110c8:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  1110cc:	e2033002 	and	r3, r3, #2
  1110d0:	e3530000 	cmp	r3, #0
  1110d4:	1a000001 	bne	1110e0 <access_is_blocking+0x44>
  1110d8:	e3a03001 	mov	r3, #1
  1110dc:	ea000000 	b	1110e4 <access_is_blocking+0x48>
  1110e0:	e3a03000 	mov	r3, #0
}
  1110e4:	e1a00003 	mov	r0, r3
  1110e8:	e28bd000 	add	sp, fp, #0
  1110ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1110f0:	e12fff1e 	bx	lr

001110f4 <lwip_socket_thread_init>:
#endif /* LWIP_IPV4 && LWIP_IPV6 */

/** LWIP_NETCONN_SEM_PER_THREAD==1: initialize thread-local semaphore */
void
lwip_socket_thread_init(void)
{
  1110f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1110f8:	e28db000 	add	fp, sp, #0
   netconn_thread_init();
}
  1110fc:	e320f000 	nop	{0}
  111100:	e28bd000 	add	sp, fp, #0
  111104:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  111108:	e12fff1e 	bx	lr

0011110c <lwip_socket_thread_cleanup>:

/** LWIP_NETCONN_SEM_PER_THREAD==1: destroy thread-local semaphore */
void
lwip_socket_thread_cleanup(void)
{
  11110c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  111110:	e28db000 	add	fp, sp, #0
   netconn_thread_cleanup();
}
  111114:	e320f000 	nop	{0}
  111118:	e28bd000 	add	sp, fp, #0
  11111c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  111120:	e12fff1e 	bx	lr

00111124 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
struct lwip_sock *
get_socket(int s)
{
  111124:	e92d4800 	push	{fp, lr}
  111128:	e28db004 	add	fp, sp, #4
  11112c:	e24dd010 	sub	sp, sp, #16
  111130:	e50b0010 	str	r0, [fp, #-16]
  struct lwip_sock *sock;

  s -= LWIP_SOCKET_OFFSET;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  111134:	e51b3010 	ldr	r3, [fp, #-16]
  111138:	e3530000 	cmp	r3, #0
  11113c:	ba000002 	blt	11114c <get_socket+0x28>
  111140:	e51b3010 	ldr	r3, [fp, #-16]
  111144:	e3530007 	cmp	r3, #7
  111148:	da000005 	ble	111164 <get_socket+0x40>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s + LWIP_SOCKET_OFFSET));
    set_errno(EBADF);
  11114c:	eb009fe1 	bl	1390d8 <__errno_location>
  111150:	e1a02000 	mov	r2, r0
  111154:	e3a03009 	mov	r3, #9
  111158:	e5823000 	str	r3, [r2]
    return NULL;
  11115c:	e3a03000 	mov	r3, #0
  111160:	ea000011 	b	1111ac <get_socket+0x88>
  }

  sock = &sockets[s];
  111164:	e51b3010 	ldr	r3, [fp, #-16]
  111168:	e3a02014 	mov	r2, #20
  11116c:	e0020392 	mul	r2, r2, r3
  111170:	e30e3b80 	movw	r3, #60288	; 0xeb80
  111174:	e3403014 	movt	r3, #20
  111178:	e0823003 	add	r3, r2, r3
  11117c:	e50b3008 	str	r3, [fp, #-8]

  if (!sock->conn) {
  111180:	e51b3008 	ldr	r3, [fp, #-8]
  111184:	e5933000 	ldr	r3, [r3]
  111188:	e3530000 	cmp	r3, #0
  11118c:	1a000005 	bne	1111a8 <get_socket+0x84>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s + LWIP_SOCKET_OFFSET));
    set_errno(EBADF);
  111190:	eb009fd0 	bl	1390d8 <__errno_location>
  111194:	e1a02000 	mov	r2, r0
  111198:	e3a03009 	mov	r3, #9
  11119c:	e5823000 	str	r3, [r2]
    return NULL;
  1111a0:	e3a03000 	mov	r3, #0
  1111a4:	ea000000 	b	1111ac <get_socket+0x88>
  }

  return sock;
  1111a8:	e51b3008 	ldr	r3, [fp, #-8]
}
  1111ac:	e1a00003 	mov	r0, r3
  1111b0:	e24bd004 	sub	sp, fp, #4
  1111b4:	e8bd8800 	pop	{fp, pc}

001111b8 <tryget_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
tryget_socket(int s)
{
  1111b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1111bc:	e28db000 	add	fp, sp, #0
  1111c0:	e24dd00c 	sub	sp, sp, #12
  1111c4:	e50b0008 	str	r0, [fp, #-8]
  s -= LWIP_SOCKET_OFFSET;
  if ((s < 0) || (s >= NUM_SOCKETS)) {
  1111c8:	e51b3008 	ldr	r3, [fp, #-8]
  1111cc:	e3530000 	cmp	r3, #0
  1111d0:	ba000002 	blt	1111e0 <tryget_socket+0x28>
  1111d4:	e51b3008 	ldr	r3, [fp, #-8]
  1111d8:	e3530007 	cmp	r3, #7
  1111dc:	da000001 	ble	1111e8 <tryget_socket+0x30>
    return NULL;
  1111e0:	e3a03000 	mov	r3, #0
  1111e4:	ea000010 	b	11122c <tryget_socket+0x74>
  }
  if (!sockets[s].conn) {
  1111e8:	e30e3b80 	movw	r3, #60288	; 0xeb80
  1111ec:	e3403014 	movt	r3, #20
  1111f0:	e51b2008 	ldr	r2, [fp, #-8]
  1111f4:	e3a01014 	mov	r1, #20
  1111f8:	e0020291 	mul	r2, r1, r2
  1111fc:	e0833002 	add	r3, r3, r2
  111200:	e5933000 	ldr	r3, [r3]
  111204:	e3530000 	cmp	r3, #0
  111208:	1a000001 	bne	111214 <tryget_socket+0x5c>
    return NULL;
  11120c:	e3a03000 	mov	r3, #0
  111210:	ea000005 	b	11122c <tryget_socket+0x74>
  }
  return &sockets[s];
  111214:	e51b3008 	ldr	r3, [fp, #-8]
  111218:	e3a02014 	mov	r2, #20
  11121c:	e0020392 	mul	r2, r2, r3
  111220:	e30e3b80 	movw	r3, #60288	; 0xeb80
  111224:	e3403014 	movt	r3, #20
  111228:	e0823003 	add	r3, r2, r3
}
  11122c:	e1a00003 	mov	r0, r3
  111230:	e28bd000 	add	sp, fp, #0
  111234:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  111238:	e12fff1e 	bx	lr

0011123c <lwip_tryget_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
struct lwip_sock *
lwip_tryget_socket(int s)
{
  11123c:	e92d4800 	push	{fp, lr}
  111240:	e28db004 	add	fp, sp, #4
  111244:	e24dd008 	sub	sp, sp, #8
  111248:	e50b0008 	str	r0, [fp, #-8]
	return tryget_socket(s);
  11124c:	e51b0008 	ldr	r0, [fp, #-8]
  111250:	ebffffd8 	bl	1111b8 <tryget_socket>
  111254:	e1a03000 	mov	r3, r0
}
  111258:	e1a00003 	mov	r0, r3
  11125c:	e24bd004 	sub	sp, fp, #4
  111260:	e8bd8800 	pop	{fp, pc}

00111264 <alloc_socket>:
 *                 0 if socket has been created by socket()
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn, int accepted)
{
  111264:	e92d4800 	push	{fp, lr}
  111268:	e28db004 	add	fp, sp, #4
  11126c:	e24dd010 	sub	sp, sp, #16
  111270:	e50b0010 	str	r0, [fp, #-16]
  111274:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  111278:	e3a03000 	mov	r3, #0
  11127c:	e50b3008 	str	r3, [fp, #-8]
  111280:	ea000063 	b	111414 <alloc_socket+0x1b0>
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
  111284:	ebffc3ec 	bl	10223c <rt_enter_critical>
    if (!sockets[i].conn && (sockets[i].select_waiting == 0)) {
  111288:	e30e3b80 	movw	r3, #60288	; 0xeb80
  11128c:	e3403014 	movt	r3, #20
  111290:	e51b2008 	ldr	r2, [fp, #-8]
  111294:	e3a01014 	mov	r1, #20
  111298:	e0020291 	mul	r2, r1, r2
  11129c:	e0833002 	add	r3, r3, r2
  1112a0:	e5933000 	ldr	r3, [r3]
  1112a4:	e3530000 	cmp	r3, #0
  1112a8:	1a000055 	bne	111404 <alloc_socket+0x1a0>
  1112ac:	e30e3b80 	movw	r3, #60288	; 0xeb80
  1112b0:	e3403014 	movt	r3, #20
  1112b4:	e51b2008 	ldr	r2, [fp, #-8]
  1112b8:	e3a01014 	mov	r1, #20
  1112bc:	e0020291 	mul	r2, r1, r2
  1112c0:	e0833002 	add	r3, r3, r2
  1112c4:	e2833011 	add	r3, r3, #17
  1112c8:	e5d33000 	ldrb	r3, [r3]
  1112cc:	e3530000 	cmp	r3, #0
  1112d0:	1a00004b 	bne	111404 <alloc_socket+0x1a0>
      sockets[i].conn       = newconn;
  1112d4:	e30e3b80 	movw	r3, #60288	; 0xeb80
  1112d8:	e3403014 	movt	r3, #20
  1112dc:	e51b2008 	ldr	r2, [fp, #-8]
  1112e0:	e3a01014 	mov	r1, #20
  1112e4:	e0020291 	mul	r2, r1, r2
  1112e8:	e0833002 	add	r3, r3, r2
  1112ec:	e51b2010 	ldr	r2, [fp, #-16]
  1112f0:	e5832000 	str	r2, [r3]
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
  1112f4:	ebffc3d6 	bl	102254 <rt_exit_critical>
      sockets[i].lastdata   = NULL;
  1112f8:	e30e3b80 	movw	r3, #60288	; 0xeb80
  1112fc:	e3403014 	movt	r3, #20
  111300:	e51b2008 	ldr	r2, [fp, #-8]
  111304:	e3a01014 	mov	r1, #20
  111308:	e0020291 	mul	r2, r1, r2
  11130c:	e0833002 	add	r3, r3, r2
  111310:	e2833004 	add	r3, r3, #4
  111314:	e3a02000 	mov	r2, #0
  111318:	e5832000 	str	r2, [r3]
      sockets[i].lastoffset = 0;
  11131c:	e30e3b80 	movw	r3, #60288	; 0xeb80
  111320:	e3403014 	movt	r3, #20
  111324:	e51b2008 	ldr	r2, [fp, #-8]
  111328:	e3a01014 	mov	r1, #20
  11132c:	e0020291 	mul	r2, r1, r2
  111330:	e0833002 	add	r3, r3, r2
  111334:	e2833008 	add	r3, r3, #8
  111338:	e3a02000 	mov	r2, #0
  11133c:	e1c320b0 	strh	r2, [r3]
      sockets[i].rcvevent   = 0;
  111340:	e30e3b80 	movw	r3, #60288	; 0xeb80
  111344:	e3403014 	movt	r3, #20
  111348:	e51b2008 	ldr	r2, [fp, #-8]
  11134c:	e3a01014 	mov	r1, #20
  111350:	e0020291 	mul	r2, r1, r2
  111354:	e0833002 	add	r3, r3, r2
  111358:	e283300a 	add	r3, r3, #10
  11135c:	e3a02000 	mov	r2, #0
  111360:	e1c320b0 	strh	r2, [r3]
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
  111364:	e51b3010 	ldr	r3, [fp, #-16]
  111368:	e5933000 	ldr	r3, [r3]
  11136c:	e20330f0 	and	r3, r3, #240	; 0xf0
  111370:	e3530010 	cmp	r3, #16
  111374:	1a000002 	bne	111384 <alloc_socket+0x120>
  111378:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11137c:	e3530000 	cmp	r3, #0
  111380:	0a000001 	beq	11138c <alloc_socket+0x128>
  111384:	e3a03001 	mov	r3, #1
  111388:	ea000000 	b	111390 <alloc_socket+0x12c>
  11138c:	e3a03000 	mov	r3, #0
  111390:	e6ff2073 	uxth	r2, r3
  111394:	e30e3b80 	movw	r3, #60288	; 0xeb80
  111398:	e3403014 	movt	r3, #20
  11139c:	e51b1008 	ldr	r1, [fp, #-8]
  1113a0:	e3a00014 	mov	r0, #20
  1113a4:	e0010190 	mul	r1, r0, r1
  1113a8:	e0833001 	add	r3, r3, r1
  1113ac:	e283300c 	add	r3, r3, #12
  1113b0:	e1c320b0 	strh	r2, [r3]
      sockets[i].errevent   = 0;
  1113b4:	e30e3b80 	movw	r3, #60288	; 0xeb80
  1113b8:	e3403014 	movt	r3, #20
  1113bc:	e51b2008 	ldr	r2, [fp, #-8]
  1113c0:	e3a01014 	mov	r1, #20
  1113c4:	e0020291 	mul	r2, r1, r2
  1113c8:	e0833002 	add	r3, r3, r2
  1113cc:	e283300e 	add	r3, r3, #14
  1113d0:	e3a02000 	mov	r2, #0
  1113d4:	e1c320b0 	strh	r2, [r3]
      sockets[i].err        = 0;
  1113d8:	e30e3b80 	movw	r3, #60288	; 0xeb80
  1113dc:	e3403014 	movt	r3, #20
  1113e0:	e51b2008 	ldr	r2, [fp, #-8]
  1113e4:	e3a01014 	mov	r1, #20
  1113e8:	e0020291 	mul	r2, r1, r2
  1113ec:	e0833002 	add	r3, r3, r2
  1113f0:	e2833010 	add	r3, r3, #16
  1113f4:	e3a02000 	mov	r2, #0
  1113f8:	e5c32000 	strb	r2, [r3]
      return i + LWIP_SOCKET_OFFSET;
  1113fc:	e51b3008 	ldr	r3, [fp, #-8]
  111400:	ea000007 	b	111424 <alloc_socket+0x1c0>
    }
    SYS_ARCH_UNPROTECT(lev);
  111404:	ebffc392 	bl	102254 <rt_exit_critical>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  111408:	e51b3008 	ldr	r3, [fp, #-8]
  11140c:	e2833001 	add	r3, r3, #1
  111410:	e50b3008 	str	r3, [fp, #-8]
  111414:	e51b3008 	ldr	r3, [fp, #-8]
  111418:	e3530007 	cmp	r3, #7
  11141c:	daffff98 	ble	111284 <alloc_socket+0x20>
  }
  return -1;
  111420:	e3e03000 	mvn	r3, #0
}
  111424:	e1a00003 	mov	r0, r3
  111428:	e24bd004 	sub	sp, fp, #4
  11142c:	e8bd8800 	pop	{fp, pc}

00111430 <free_socket>:
 * @param sock the socket to free
 * @param is_tcp != 0 for TCP sockets, used to free lastdata
 */
static void
free_socket(struct lwip_sock *sock, int is_tcp)
{
  111430:	e92d4800 	push	{fp, lr}
  111434:	e28db004 	add	fp, sp, #4
  111438:	e24dd010 	sub	sp, sp, #16
  11143c:	e50b0010 	str	r0, [fp, #-16]
  111440:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  void *lastdata;

  lastdata         = sock->lastdata;
  111444:	e51b3010 	ldr	r3, [fp, #-16]
  111448:	e5933004 	ldr	r3, [r3, #4]
  11144c:	e50b3008 	str	r3, [fp, #-8]
  sock->lastdata   = NULL;
  111450:	e51b3010 	ldr	r3, [fp, #-16]
  111454:	e3a02000 	mov	r2, #0
  111458:	e5832004 	str	r2, [r3, #4]
  sock->lastoffset = 0;
  11145c:	e51b3010 	ldr	r3, [fp, #-16]
  111460:	e3a02000 	mov	r2, #0
  111464:	e1c320b8 	strh	r2, [r3, #8]
  sock->err        = 0;
  111468:	e51b3010 	ldr	r3, [fp, #-16]
  11146c:	e3a02000 	mov	r2, #0
  111470:	e5c32010 	strb	r2, [r3, #16]

  /* Protect socket array */
  SYS_ARCH_SET(sock->conn, NULL);
  111474:	ebffc370 	bl	10223c <rt_enter_critical>
  111478:	e51b3010 	ldr	r3, [fp, #-16]
  11147c:	e3a02000 	mov	r2, #0
  111480:	e5832000 	str	r2, [r3]
  111484:	ebffc372 	bl	102254 <rt_exit_critical>
  /* don't use 'sock' after this line, as another task might have allocated it */

  if (lastdata != NULL) {
  111488:	e51b3008 	ldr	r3, [fp, #-8]
  11148c:	e3530000 	cmp	r3, #0
  111490:	0a000007 	beq	1114b4 <free_socket+0x84>
    if (is_tcp) {
  111494:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111498:	e3530000 	cmp	r3, #0
  11149c:	0a000002 	beq	1114ac <free_socket+0x7c>
      pbuf_free((struct pbuf *)lastdata);
  1114a0:	e51b0008 	ldr	r0, [fp, #-8]
  1114a4:	eb002702 	bl	11b0b4 <pbuf_free>
    } else {
      netbuf_delete((struct netbuf *)lastdata);
    }
  }
}
  1114a8:	ea000001 	b	1114b4 <free_socket+0x84>
      netbuf_delete((struct netbuf *)lastdata);
  1114ac:	e51b0008 	ldr	r0, [fp, #-8]
  1114b0:	ebfffb1e 	bl	110130 <netbuf_delete>
}
  1114b4:	e320f000 	nop	{0}
  1114b8:	e24bd004 	sub	sp, fp, #4
  1114bc:	e8bd8800 	pop	{fp, pc}

001114c0 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  1114c0:	e92d4810 	push	{r4, fp, lr}
  1114c4:	e28db008 	add	fp, sp, #8
  1114c8:	e24dd05c 	sub	sp, sp, #92	; 0x5c
  1114cc:	e50b0058 	str	r0, [fp, #-88]	; 0xffffffa8
  1114d0:	e50b105c 	str	r1, [fp, #-92]	; 0xffffffa4
  1114d4:	e50b2060 	str	r2, [fp, #-96]	; 0xffffffa0
  struct lwip_sock *sock, *nsock;
  struct netconn *newconn;
  ip_addr_t naddr;
  u16_t port = 0;
  1114d8:	e3a03000 	mov	r3, #0
  1114dc:	e14b33be 	strh	r3, [fp, #-62]	; 0xffffffc2
  int newsock;
  err_t err;
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  1114e0:	e51b0058 	ldr	r0, [fp, #-88]	; 0xffffffa8
  1114e4:	ebffff0e 	bl	111124 <get_socket>
  1114e8:	e50b0010 	str	r0, [fp, #-16]
  if (!sock) {
  1114ec:	e51b3010 	ldr	r3, [fp, #-16]
  1114f0:	e3530000 	cmp	r3, #0
  1114f4:	1a000001 	bne	111500 <lwip_accept+0x40>
    return -1;
  1114f8:	e3e03000 	mvn	r3, #0
  1114fc:	ea0000fa 	b	1118ec <lwip_accept+0x42c>
  }

  if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
  111500:	e51b3010 	ldr	r3, [fp, #-16]
  111504:	e5933000 	ldr	r3, [r3]
  111508:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  11150c:	e2033002 	and	r3, r3, #2
  111510:	e3530000 	cmp	r3, #0
  111514:	0a000009 	beq	111540 <lwip_accept+0x80>
  111518:	e51b3010 	ldr	r3, [fp, #-16]
  11151c:	e1d330fa 	ldrsh	r3, [r3, #10]
  111520:	e3530000 	cmp	r3, #0
  111524:	ca000005 	bgt	111540 <lwip_accept+0x80>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): returning EWOULDBLOCK\n", s));
    set_errno(EWOULDBLOCK);
  111528:	eb009eea 	bl	1390d8 <__errno_location>
  11152c:	e1a02000 	mov	r2, r0
  111530:	e3a0300b 	mov	r3, #11
  111534:	e5823000 	str	r3, [r2]
    return -1;
  111538:	e3e03000 	mvn	r3, #0
  11153c:	ea0000ea 	b	1118ec <lwip_accept+0x42c>
  }

  /* wait for a new connection */
  err = netconn_accept(sock->conn, &newconn);
  111540:	e51b3010 	ldr	r3, [fp, #-16]
  111544:	e5933000 	ldr	r3, [r3]
  111548:	e24b2038 	sub	r2, fp, #56	; 0x38
  11154c:	e1a01002 	mov	r1, r2
  111550:	e1a00003 	mov	r0, r3
  111554:	ebffe924 	bl	10b9ec <netconn_accept>
  111558:	e1a03000 	mov	r3, r0
  11155c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  if (err != ERR_OK) {
  111560:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  111564:	e3530000 	cmp	r3, #0
  111568:	0a000035 	beq	111644 <lwip_accept+0x184>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
  11156c:	e51b3010 	ldr	r3, [fp, #-16]
  111570:	e5933000 	ldr	r3, [r3]
  111574:	e5933000 	ldr	r3, [r3]
  111578:	e20330f0 	and	r3, r3, #240	; 0xf0
  11157c:	e3530010 	cmp	r3, #16
  111580:	0a00000d 	beq	1115bc <lwip_accept+0xfc>
      sock_set_errno(sock, EOPNOTSUPP);
  111584:	e3a0305f 	mov	r3, #95	; 0x5f
  111588:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
  11158c:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  111590:	e6ef2073 	uxtb	r2, r3
  111594:	e51b3010 	ldr	r3, [fp, #-16]
  111598:	e5c32010 	strb	r2, [r3, #16]
  11159c:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  1115a0:	e3530000 	cmp	r3, #0
  1115a4:	0a000024 	beq	11163c <lwip_accept+0x17c>
  1115a8:	eb009eca 	bl	1390d8 <__errno_location>
  1115ac:	e1a02000 	mov	r2, r0
  1115b0:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  1115b4:	e5823000 	str	r3, [r2]
  1115b8:	ea00001f 	b	11163c <lwip_accept+0x17c>
    } else if (err == ERR_CLSD) {
  1115bc:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  1115c0:	e373000f 	cmn	r3, #15
  1115c4:	1a00000d 	bne	111600 <lwip_accept+0x140>
      sock_set_errno(sock, EINVAL);
  1115c8:	e3a03016 	mov	r3, #22
  1115cc:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
  1115d0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1115d4:	e6ef2073 	uxtb	r2, r3
  1115d8:	e51b3010 	ldr	r3, [fp, #-16]
  1115dc:	e5c32010 	strb	r2, [r3, #16]
  1115e0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1115e4:	e3530000 	cmp	r3, #0
  1115e8:	0a000013 	beq	11163c <lwip_accept+0x17c>
  1115ec:	eb009eb9 	bl	1390d8 <__errno_location>
  1115f0:	e1a02000 	mov	r2, r0
  1115f4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1115f8:	e5823000 	str	r3, [r2]
  1115fc:	ea00000e 	b	11163c <lwip_accept+0x17c>
    } else {
      sock_set_errno(sock, err_to_errno(err));
  111600:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  111604:	e1a00003 	mov	r0, r3
  111608:	ebfffa9d 	bl	110084 <err_to_errno>
  11160c:	e50b002c 	str	r0, [fp, #-44]	; 0xffffffd4
  111610:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  111614:	e6ef2073 	uxtb	r2, r3
  111618:	e51b3010 	ldr	r3, [fp, #-16]
  11161c:	e5c32010 	strb	r2, [r3, #16]
  111620:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  111624:	e3530000 	cmp	r3, #0
  111628:	0a000003 	beq	11163c <lwip_accept+0x17c>
  11162c:	eb009ea9 	bl	1390d8 <__errno_location>
  111630:	e1a02000 	mov	r2, r0
  111634:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  111638:	e5823000 	str	r3, [r2]
    }
    return -1;
  11163c:	e3e03000 	mvn	r3, #0
  111640:	ea0000a9 	b	1118ec <lwip_accept+0x42c>
  }
  LWIP_ASSERT("newconn != NULL", newconn != NULL);
  111644:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  111648:	e3530000 	cmp	r3, #0
  11164c:	1a000006 	bne	11166c <lwip_accept+0x1ac>
  111650:	e3060f7c 	movw	r0, #28540	; 0x6f7c
  111654:	e3400014 	movt	r0, #20
  111658:	ebffc6ad 	bl	103114 <rt_kprintf>
  11165c:	e300120a 	movw	r1, #522	; 0x20a
  111660:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  111664:	e3400014 	movt	r0, #20
  111668:	ebffe683 	bl	10b07c <sys_arch_assert>

  newsock = alloc_socket(newconn, 1);
  11166c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  111670:	e3a01001 	mov	r1, #1
  111674:	e1a00003 	mov	r0, r3
  111678:	ebfffef9 	bl	111264 <alloc_socket>
  11167c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  if (newsock == -1) {
  111680:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111684:	e3730001 	cmn	r3, #1
  111688:	1a000011 	bne	1116d4 <lwip_accept+0x214>
    netconn_delete(newconn);
  11168c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  111690:	e1a00003 	mov	r0, r3
  111694:	ebffe7e6 	bl	10b634 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  111698:	e3a03017 	mov	r3, #23
  11169c:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  1116a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1116a4:	e6ef2073 	uxtb	r2, r3
  1116a8:	e51b3010 	ldr	r3, [fp, #-16]
  1116ac:	e5c32010 	strb	r2, [r3, #16]
  1116b0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1116b4:	e3530000 	cmp	r3, #0
  1116b8:	0a000003 	beq	1116cc <lwip_accept+0x20c>
  1116bc:	eb009e85 	bl	1390d8 <__errno_location>
  1116c0:	e1a02000 	mov	r2, r0
  1116c4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1116c8:	e5823000 	str	r3, [r2]
    return -1;
  1116cc:	e3e03000 	mvn	r3, #0
  1116d0:	ea000085 	b	1118ec <lwip_accept+0x42c>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= LWIP_SOCKET_OFFSET) && (newsock < NUM_SOCKETS + LWIP_SOCKET_OFFSET));
  1116d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1116d8:	e3530000 	cmp	r3, #0
  1116dc:	ba000002 	blt	1116ec <lwip_accept+0x22c>
  1116e0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1116e4:	e3530007 	cmp	r3, #7
  1116e8:	da000006 	ble	111708 <lwip_accept+0x248>
  1116ec:	e3060fbc 	movw	r0, #28604	; 0x6fbc
  1116f0:	e3400014 	movt	r0, #20
  1116f4:	ebffc686 	bl	103114 <rt_kprintf>
  1116f8:	e3001212 	movw	r1, #530	; 0x212
  1116fc:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  111700:	e3400014 	movt	r0, #20
  111704:	ebffe65c 	bl	10b07c <sys_arch_assert>
  // LWIP_ASSERT("newconn->callback == event_callback", newconn->callback == event_callback);
  nsock = &sockets[newsock - LWIP_SOCKET_OFFSET];
  111708:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11170c:	e3a02014 	mov	r2, #20
  111710:	e0020392 	mul	r2, r2, r3
  111714:	e30e3b80 	movw	r3, #60288	; 0xeb80
  111718:	e3403014 	movt	r3, #20
  11171c:	e0823003 	add	r3, r2, r3
  111720:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  SYS_ARCH_PROTECT(lev);
  111724:	ebffc2c4 	bl	10223c <rt_enter_critical>
  nsock->rcvevent += (s16_t)(-1 - newconn->socket);
  111728:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11172c:	e1d330fa 	ldrsh	r3, [r3, #10]
  111730:	e6ff2073 	uxth	r2, r3
  111734:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  111738:	e593301c 	ldr	r3, [r3, #28]
  11173c:	e6ff3073 	uxth	r3, r3
  111740:	e0423003 	sub	r3, r2, r3
  111744:	e6ff3073 	uxth	r3, r3
  111748:	e2433001 	sub	r3, r3, #1
  11174c:	e6ff3073 	uxth	r3, r3
  111750:	e6bf2073 	sxth	r2, r3
  111754:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  111758:	e1c320ba 	strh	r2, [r3, #10]
  newconn->socket = newsock;
  11175c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  111760:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  111764:	e583201c 	str	r2, [r3, #28]
  SYS_ARCH_UNPROTECT(lev);
  111768:	ebffc2b9 	bl	102254 <rt_exit_critical>

  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
   * not be NULL if addr is valid.
   */
  if (addr != NULL) {
  11176c:	e51b305c 	ldr	r3, [fp, #-92]	; 0xffffffa4
  111770:	e3530000 	cmp	r3, #0
  111774:	0a00004e 	beq	1118b4 <lwip_accept+0x3f4>
    union sockaddr_aligned tempaddr;
    /* get the IP address and port of the remote host */
    err = netconn_peer(newconn, &naddr, &port);
  111778:	e51b0038 	ldr	r0, [fp, #-56]	; 0xffffffc8
  11177c:	e24b203e 	sub	r2, fp, #62	; 0x3e
  111780:	e24b103c 	sub	r1, fp, #60	; 0x3c
  111784:	e3a03000 	mov	r3, #0
  111788:	ebffe7c9 	bl	10b6b4 <netconn_getaddr>
  11178c:	e1a03000 	mov	r3, r0
  111790:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    if (err != ERR_OK) {
  111794:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  111798:	e3530000 	cmp	r3, #0
  11179c:	0a000016 	beq	1117fc <lwip_accept+0x33c>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
      netconn_delete(newconn);
  1117a0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1117a4:	e1a00003 	mov	r0, r3
  1117a8:	ebffe7a1 	bl	10b634 <netconn_delete>
      free_socket(nsock, 1);
  1117ac:	e3a01001 	mov	r1, #1
  1117b0:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  1117b4:	ebffff1d 	bl	111430 <free_socket>
      sock_set_errno(sock, err_to_errno(err));
  1117b8:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  1117bc:	e1a00003 	mov	r0, r3
  1117c0:	ebfffa2f 	bl	110084 <err_to_errno>
  1117c4:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  1117c8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1117cc:	e6ef2073 	uxtb	r2, r3
  1117d0:	e51b3010 	ldr	r3, [fp, #-16]
  1117d4:	e5c32010 	strb	r2, [r3, #16]
  1117d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1117dc:	e3530000 	cmp	r3, #0
  1117e0:	0a000003 	beq	1117f4 <lwip_accept+0x334>
  1117e4:	eb009e3b 	bl	1390d8 <__errno_location>
  1117e8:	e1a02000 	mov	r2, r0
  1117ec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1117f0:	e5823000 	str	r3, [r2]
      return -1;
  1117f4:	e3e03000 	mvn	r3, #0
  1117f8:	ea00003b 	b	1118ec <lwip_accept+0x42c>
    }
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
  1117fc:	e51b3060 	ldr	r3, [fp, #-96]	; 0xffffffa0
  111800:	e3530000 	cmp	r3, #0
  111804:	1a000006 	bne	111824 <lwip_accept+0x364>
  111808:	e3060fd4 	movw	r0, #28628	; 0x6fd4
  11180c:	e3400014 	movt	r0, #20
  111810:	ebffc63f 	bl	103114 <rt_kprintf>
  111814:	e300122e 	movw	r1, #558	; 0x22e
  111818:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  11181c:	e3400014 	movt	r0, #20
  111820:	ebffe615 	bl	10b07c <sys_arch_assert>

    IPADDR_PORT_TO_SOCKADDR(&tempaddr, &naddr, port);
  111824:	e24b3050 	sub	r3, fp, #80	; 0x50
  111828:	e3a02010 	mov	r2, #16
  11182c:	e5c32000 	strb	r2, [r3]
  111830:	e24b3050 	sub	r3, fp, #80	; 0x50
  111834:	e3a02002 	mov	r2, #2
  111838:	e5c32001 	strb	r2, [r3, #1]
  11183c:	e15b33be 	ldrh	r3, [fp, #-62]	; 0xffffffc2
  111840:	e24b4050 	sub	r4, fp, #80	; 0x50
  111844:	e1a00003 	mov	r0, r3
  111848:	eb0013e2 	bl	1167d8 <lwip_htons>
  11184c:	e1a03000 	mov	r3, r0
  111850:	e1c430b2 	strh	r3, [r4, #2]
  111854:	e24b3050 	sub	r3, fp, #80	; 0x50
  111858:	e51b203c 	ldr	r2, [fp, #-60]	; 0xffffffc4
  11185c:	e5832004 	str	r2, [r3, #4]
  111860:	e24b3050 	sub	r3, fp, #80	; 0x50
  111864:	e2833008 	add	r3, r3, #8
  111868:	e3a02008 	mov	r2, #8
  11186c:	e3a01000 	mov	r1, #0
  111870:	e1a00003 	mov	r0, r3
  111874:	eb00befe 	bl	141474 <memset>
    if (*addrlen > tempaddr.sa.sa_len) {
  111878:	e51b3060 	ldr	r3, [fp, #-96]	; 0xffffffa0
  11187c:	e5933000 	ldr	r3, [r3]
  111880:	e55b2050 	ldrb	r2, [fp, #-80]	; 0xffffffb0
  111884:	e1530002 	cmp	r3, r2
  111888:	9a000003 	bls	11189c <lwip_accept+0x3dc>
      *addrlen = tempaddr.sa.sa_len;
  11188c:	e55b3050 	ldrb	r3, [fp, #-80]	; 0xffffffb0
  111890:	e1a02003 	mov	r2, r3
  111894:	e51b3060 	ldr	r3, [fp, #-96]	; 0xffffffa0
  111898:	e5832000 	str	r2, [r3]
    }
    MEMCPY(addr, &tempaddr, *addrlen);
  11189c:	e51b3060 	ldr	r3, [fp, #-96]	; 0xffffffa0
  1118a0:	e5932000 	ldr	r2, [r3]
  1118a4:	e24b3050 	sub	r3, fp, #80	; 0x50
  1118a8:	e1a01003 	mov	r1, r3
  1118ac:	e51b005c 	ldr	r0, [fp, #-92]	; 0xffffffa4
  1118b0:	eb00bdb7 	bl	140f94 <memcpy>
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));
  } else {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d", s, newsock));
  }

  sock_set_errno(sock, 0);
  1118b4:	e3a03000 	mov	r3, #0
  1118b8:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  1118bc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1118c0:	e6ef2073 	uxtb	r2, r3
  1118c4:	e51b3010 	ldr	r3, [fp, #-16]
  1118c8:	e5c32010 	strb	r2, [r3, #16]
  1118cc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1118d0:	e3530000 	cmp	r3, #0
  1118d4:	0a000003 	beq	1118e8 <lwip_accept+0x428>
  1118d8:	eb009dfe 	bl	1390d8 <__errno_location>
  1118dc:	e1a02000 	mov	r2, r0
  1118e0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1118e4:	e5823000 	str	r3, [r2]
  return newsock;
  1118e8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
}
  1118ec:	e1a00003 	mov	r0, r3
  1118f0:	e24bd008 	sub	sp, fp, #8
  1118f4:	e8bd8810 	pop	{r4, fp, pc}

001118f8 <lwip_bind>:
#include <stdio.h>
int
lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
  1118f8:	e92d4800 	push	{fp, lr}
  1118fc:	e28db004 	add	fp, sp, #4
  111900:	e24dd028 	sub	sp, sp, #40	; 0x28
  111904:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  111908:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  11190c:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  struct lwip_sock *sock;
  ip_addr_t local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  111910:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  111914:	ebfffe02 	bl	111124 <get_socket>
  111918:	e50b0008 	str	r0, [fp, #-8]
  if (!sock) {
  11191c:	e51b3008 	ldr	r3, [fp, #-8]
  111920:	e3530000 	cmp	r3, #0
  111924:	1a000001 	bne	111930 <lwip_bind+0x38>
    return -1;
  111928:	e3e03000 	mvn	r3, #0
  11192c:	ea000054 	b	111a84 <lwip_bind+0x18c>
    sock_set_errno(sock, err_to_errno(ERR_VAL));
    return -1;
  }

  /* check size, family and alignment of 'name' */
  LWIP_ERROR("lwip_bind: invalid address", (IS_SOCK_ADDR_LEN_VALID(namelen) &&
  111930:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  111934:	e3530010 	cmp	r3, #16
  111938:	1a000007 	bne	11195c <lwip_bind+0x64>
  11193c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111940:	e5d33001 	ldrb	r3, [r3, #1]
  111944:	e3530002 	cmp	r3, #2
  111948:	1a000003 	bne	11195c <lwip_bind+0x64>
  11194c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111950:	e2033003 	and	r3, r3, #3
  111954:	e3530000 	cmp	r3, #0
  111958:	0a000016 	beq	1119b8 <lwip_bind+0xc0>
  11195c:	e3060ff0 	movw	r0, #28656	; 0x6ff0
  111960:	e3400014 	movt	r0, #20
  111964:	ebffc5ea 	bl	103114 <rt_kprintf>
  111968:	e3001257 	movw	r1, #599	; 0x257
  11196c:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  111970:	e3400014 	movt	r0, #20
  111974:	ebffe5c0 	bl	10b07c <sys_arch_assert>
  111978:	e3e0000f 	mvn	r0, #15
  11197c:	ebfff9c0 	bl	110084 <err_to_errno>
  111980:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  111984:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111988:	e6ef2073 	uxtb	r2, r3
  11198c:	e51b3008 	ldr	r3, [fp, #-8]
  111990:	e5c32010 	strb	r2, [r3, #16]
  111994:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111998:	e3530000 	cmp	r3, #0
  11199c:	0a000003 	beq	1119b0 <lwip_bind+0xb8>
  1119a0:	eb009dcc 	bl	1390d8 <__errno_location>
  1119a4:	e1a02000 	mov	r2, r0
  1119a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1119ac:	e5823000 	str	r3, [r2]
  1119b0:	e3e03000 	mvn	r3, #0
  1119b4:	ea000032 	b	111a84 <lwip_bind+0x18c>
             IS_SOCK_ADDR_TYPE_VALID(name) && IS_SOCK_ADDR_ALIGNED(name)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  LWIP_UNUSED_ARG(namelen);

  SOCKADDR_TO_IPADDR_PORT(name, &local_addr, local_port);
  1119b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1119bc:	e5933004 	ldr	r3, [r3, #4]
  1119c0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  1119c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1119c8:	e1d330b2 	ldrh	r3, [r3, #2]
  1119cc:	e1a00003 	mov	r0, r3
  1119d0:	eb001380 	bl	1167d8 <lwip_htons>
  1119d4:	e1a03000 	mov	r3, r0
  1119d8:	e14b30ba 	strh	r3, [fp, #-10]
    unmap_ipv4_mapped_ipv6(ip_2_ip4(&local_addr), ip_2_ip6(&local_addr));
    IP_SET_TYPE_VAL(local_addr, IPADDR_TYPE_V4);
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

  err = netconn_bind(sock->conn, &local_addr, local_port);
  1119dc:	e51b3008 	ldr	r3, [fp, #-8]
  1119e0:	e5933000 	ldr	r3, [r3]
  1119e4:	e15b20ba 	ldrh	r2, [fp, #-10]
  1119e8:	e24b101c 	sub	r1, fp, #28
  1119ec:	e1a00003 	mov	r0, r3
  1119f0:	ebffe76d 	bl	10b7ac <netconn_bind>
  1119f4:	e1a03000 	mov	r3, r0
  1119f8:	e54b300b 	strb	r3, [fp, #-11]

  if (err != ERR_OK) {
  1119fc:	e15b30db 	ldrsb	r3, [fp, #-11]
  111a00:	e3530000 	cmp	r3, #0
  111a04:	0a000010 	beq	111a4c <lwip_bind+0x154>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  111a08:	e15b30db 	ldrsb	r3, [fp, #-11]
  111a0c:	e1a00003 	mov	r0, r3
  111a10:	ebfff99b 	bl	110084 <err_to_errno>
  111a14:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  111a18:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111a1c:	e6ef2073 	uxtb	r2, r3
  111a20:	e51b3008 	ldr	r3, [fp, #-8]
  111a24:	e5c32010 	strb	r2, [r3, #16]
  111a28:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111a2c:	e3530000 	cmp	r3, #0
  111a30:	0a000003 	beq	111a44 <lwip_bind+0x14c>
  111a34:	eb009da7 	bl	1390d8 <__errno_location>
  111a38:	e1a02000 	mov	r2, r0
  111a3c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111a40:	e5823000 	str	r3, [r2]
    return -1;
  111a44:	e3e03000 	mvn	r3, #0
  111a48:	ea00000d 	b	111a84 <lwip_bind+0x18c>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  111a4c:	e3a03000 	mov	r3, #0
  111a50:	e50b3010 	str	r3, [fp, #-16]
  111a54:	e51b3010 	ldr	r3, [fp, #-16]
  111a58:	e6ef2073 	uxtb	r2, r3
  111a5c:	e51b3008 	ldr	r3, [fp, #-8]
  111a60:	e5c32010 	strb	r2, [r3, #16]
  111a64:	e51b3010 	ldr	r3, [fp, #-16]
  111a68:	e3530000 	cmp	r3, #0
  111a6c:	0a000003 	beq	111a80 <lwip_bind+0x188>
  111a70:	eb009d98 	bl	1390d8 <__errno_location>
  111a74:	e1a02000 	mov	r2, r0
  111a78:	e51b3010 	ldr	r3, [fp, #-16]
  111a7c:	e5823000 	str	r3, [r2]
  return 0;
  111a80:	e3a03000 	mov	r3, #0
}
  111a84:	e1a00003 	mov	r0, r3
  111a88:	e24bd004 	sub	sp, fp, #4
  111a8c:	e8bd8800 	pop	{fp, pc}

00111a90 <lwip_close>:

int
lwip_close(int s)
{
  111a90:	e92d4800 	push	{fp, lr}
  111a94:	e28db004 	add	fp, sp, #4
  111a98:	e24dd018 	sub	sp, sp, #24
  111a9c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct lwip_sock *sock;
  int is_tcp = 0;
  111aa0:	e3a03000 	mov	r3, #0
  111aa4:	e50b3008 	str	r3, [fp, #-8]
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  111aa8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  111aac:	ebfffd9c 	bl	111124 <get_socket>
  111ab0:	e50b000c 	str	r0, [fp, #-12]
  if (!sock) {
  111ab4:	e51b300c 	ldr	r3, [fp, #-12]
  111ab8:	e3530000 	cmp	r3, #0
  111abc:	1a000001 	bne	111ac8 <lwip_close+0x38>
    return -1;
  111ac0:	e3e03000 	mvn	r3, #0
  111ac4:	ea000038 	b	111bac <lwip_close+0x11c>
  }

  if (sock->conn != NULL) {
  111ac8:	e51b300c 	ldr	r3, [fp, #-12]
  111acc:	e5933000 	ldr	r3, [r3]
  111ad0:	e3530000 	cmp	r3, #0
  111ad4:	0a000009 	beq	111b00 <lwip_close+0x70>
    is_tcp = NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP;
  111ad8:	e51b300c 	ldr	r3, [fp, #-12]
  111adc:	e5933000 	ldr	r3, [r3]
  111ae0:	e5933000 	ldr	r3, [r3]
  111ae4:	e20330f0 	and	r3, r3, #240	; 0xf0
  111ae8:	e3530010 	cmp	r3, #16
  111aec:	03a03001 	moveq	r3, #1
  111af0:	13a03000 	movne	r3, #0
  111af4:	e6ef3073 	uxtb	r3, r3
  111af8:	e50b3008 	str	r3, [fp, #-8]
  111afc:	ea00000a 	b	111b2c <lwip_close+0x9c>
  } else {
    LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
  111b00:	e51b300c 	ldr	r3, [fp, #-12]
  111b04:	e5933004 	ldr	r3, [r3, #4]
  111b08:	e3530000 	cmp	r3, #0
  111b0c:	0a000006 	beq	111b2c <lwip_close+0x9c>
  111b10:	e307000c 	movw	r0, #28684	; 0x700c
  111b14:	e3400014 	movt	r0, #20
  111b18:	ebffc57d 	bl	103114 <rt_kprintf>
  111b1c:	e3001285 	movw	r1, #645	; 0x285
  111b20:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  111b24:	e3400014 	movt	r0, #20
  111b28:	ebffe553 	bl	10b07c <sys_arch_assert>
  }

#if LWIP_IGMP
  /* drop all possibly joined IGMP memberships */
  lwip_socket_drop_registered_memberships(s);
  111b2c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  111b30:	eb001126 	bl	115fd0 <lwip_socket_drop_registered_memberships>
#endif /* LWIP_IGMP */

  err = netconn_delete(sock->conn);
  111b34:	e51b300c 	ldr	r3, [fp, #-12]
  111b38:	e5933000 	ldr	r3, [r3]
  111b3c:	e1a00003 	mov	r0, r3
  111b40:	ebffe6bb 	bl	10b634 <netconn_delete>
  111b44:	e1a03000 	mov	r3, r0
  111b48:	e54b300d 	strb	r3, [fp, #-13]
  if (err != ERR_OK) {
  111b4c:	e15b30dd 	ldrsb	r3, [fp, #-13]
  111b50:	e3530000 	cmp	r3, #0
  111b54:	0a000010 	beq	111b9c <lwip_close+0x10c>
    sock_set_errno(sock, err_to_errno(err));
  111b58:	e15b30dd 	ldrsb	r3, [fp, #-13]
  111b5c:	e1a00003 	mov	r0, r3
  111b60:	ebfff947 	bl	110084 <err_to_errno>
  111b64:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  111b68:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111b6c:	e6ef2073 	uxtb	r2, r3
  111b70:	e51b300c 	ldr	r3, [fp, #-12]
  111b74:	e5c32010 	strb	r2, [r3, #16]
  111b78:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111b7c:	e3530000 	cmp	r3, #0
  111b80:	0a000003 	beq	111b94 <lwip_close+0x104>
  111b84:	eb009d53 	bl	1390d8 <__errno_location>
  111b88:	e1a02000 	mov	r2, r0
  111b8c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111b90:	e5823000 	str	r3, [r2]
    return -1;
  111b94:	e3e03000 	mvn	r3, #0
  111b98:	ea000003 	b	111bac <lwip_close+0x11c>
  }

  free_socket(sock, is_tcp);
  111b9c:	e51b1008 	ldr	r1, [fp, #-8]
  111ba0:	e51b000c 	ldr	r0, [fp, #-12]
  111ba4:	ebfffe21 	bl	111430 <free_socket>
  set_errno(0);
  return 0;
  111ba8:	e3a03000 	mov	r3, #0
}
  111bac:	e1a00003 	mov	r0, r3
  111bb0:	e24bd004 	sub	sp, fp, #4
  111bb4:	e8bd8800 	pop	{fp, pc}

00111bb8 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  111bb8:	e92d4800 	push	{fp, lr}
  111bbc:	e28db004 	add	fp, sp, #4
  111bc0:	e24dd030 	sub	sp, sp, #48	; 0x30
  111bc4:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  111bc8:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  111bcc:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  struct lwip_sock *sock;
  err_t err;

  sock = get_socket(s);
  111bd0:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  111bd4:	ebfffd52 	bl	111124 <get_socket>
  111bd8:	e50b000c 	str	r0, [fp, #-12]
  if (!sock) {
  111bdc:	e51b300c 	ldr	r3, [fp, #-12]
  111be0:	e3530000 	cmp	r3, #0
  111be4:	1a000001 	bne	111bf0 <lwip_connect+0x38>
    return -1;
  111be8:	e3e03000 	mvn	r3, #0
  111bec:	ea000063 	b	111d80 <lwip_connect+0x1c8>
    sock_set_errno(sock, err_to_errno(ERR_VAL));
    return -1;
  }

  LWIP_UNUSED_ARG(namelen);
  if (name->sa_family == AF_UNSPEC) {
  111bf0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  111bf4:	e5d33001 	ldrb	r3, [r3, #1]
  111bf8:	e3530000 	cmp	r3, #0
  111bfc:	1a000006 	bne	111c1c <lwip_connect+0x64>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  111c00:	e51b300c 	ldr	r3, [fp, #-12]
  111c04:	e5933000 	ldr	r3, [r3]
  111c08:	e1a00003 	mov	r0, r3
  111c0c:	ebffe73a 	bl	10b8fc <netconn_disconnect>
  111c10:	e1a03000 	mov	r3, r0
  111c14:	e54b3005 	strb	r3, [fp, #-5]
  111c18:	ea000036 	b	111cf8 <lwip_connect+0x140>
  } else {
    ip_addr_t remote_addr;
    u16_t remote_port;

    /* check size, family and alignment of 'name' */
    LWIP_ERROR("lwip_connect: invalid address", IS_SOCK_ADDR_LEN_VALID(namelen) &&
  111c1c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  111c20:	e3530010 	cmp	r3, #16
  111c24:	1a00000b 	bne	111c58 <lwip_connect+0xa0>
  111c28:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  111c2c:	e5d33001 	ldrb	r3, [r3, #1]
  111c30:	e3530000 	cmp	r3, #0
  111c34:	0a000003 	beq	111c48 <lwip_connect+0x90>
  111c38:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  111c3c:	e5d33001 	ldrb	r3, [r3, #1]
  111c40:	e3530002 	cmp	r3, #2
  111c44:	1a000003 	bne	111c58 <lwip_connect+0xa0>
  111c48:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  111c4c:	e2033003 	and	r3, r3, #3
  111c50:	e3530000 	cmp	r3, #0
  111c54:	0a000016 	beq	111cb4 <lwip_connect+0xfc>
  111c58:	e3070024 	movw	r0, #28708	; 0x7024
  111c5c:	e3400014 	movt	r0, #20
  111c60:	ebffc52b 	bl	103114 <rt_kprintf>
  111c64:	e3a01fad 	mov	r1, #692	; 0x2b4
  111c68:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  111c6c:	e3400014 	movt	r0, #20
  111c70:	ebffe501 	bl	10b07c <sys_arch_assert>
  111c74:	e3e0000f 	mvn	r0, #15
  111c78:	ebfff901 	bl	110084 <err_to_errno>
  111c7c:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  111c80:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111c84:	e6ef2073 	uxtb	r2, r3
  111c88:	e51b300c 	ldr	r3, [fp, #-12]
  111c8c:	e5c32010 	strb	r2, [r3, #16]
  111c90:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111c94:	e3530000 	cmp	r3, #0
  111c98:	0a000003 	beq	111cac <lwip_connect+0xf4>
  111c9c:	eb009d0d 	bl	1390d8 <__errno_location>
  111ca0:	e1a02000 	mov	r2, r0
  111ca4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111ca8:	e5823000 	str	r3, [r2]
  111cac:	e3e03000 	mvn	r3, #0
  111cb0:	ea000032 	b	111d80 <lwip_connect+0x1c8>
               IS_SOCK_ADDR_TYPE_VALID_OR_UNSPEC(name) && IS_SOCK_ADDR_ALIGNED(name),
               sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

    SOCKADDR_TO_IPADDR_PORT(name, &remote_addr, remote_port);
  111cb4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  111cb8:	e5933004 	ldr	r3, [r3, #4]
  111cbc:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  111cc0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  111cc4:	e1d330b2 	ldrh	r3, [r3, #2]
  111cc8:	e1a00003 	mov	r0, r3
  111ccc:	eb0012c1 	bl	1167d8 <lwip_htons>
  111cd0:	e1a03000 	mov	r3, r0
  111cd4:	e14b30be 	strh	r3, [fp, #-14]
      unmap_ipv4_mapped_ipv6(ip_2_ip4(&remote_addr), ip_2_ip6(&remote_addr));
      IP_SET_TYPE_VAL(remote_addr, IPADDR_TYPE_V4);
    }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

    err = netconn_connect(sock->conn, &remote_addr, remote_port);
  111cd8:	e51b300c 	ldr	r3, [fp, #-12]
  111cdc:	e5933000 	ldr	r3, [r3]
  111ce0:	e15b20be 	ldrh	r2, [fp, #-14]
  111ce4:	e24b1020 	sub	r1, fp, #32
  111ce8:	e1a00003 	mov	r0, r3
  111cec:	ebffe6d8 	bl	10b854 <netconn_connect>
  111cf0:	e1a03000 	mov	r3, r0
  111cf4:	e54b3005 	strb	r3, [fp, #-5]
  }

  if (err != ERR_OK) {
  111cf8:	e15b30d5 	ldrsb	r3, [fp, #-5]
  111cfc:	e3530000 	cmp	r3, #0
  111d00:	0a000010 	beq	111d48 <lwip_connect+0x190>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  111d04:	e15b30d5 	ldrsb	r3, [fp, #-5]
  111d08:	e1a00003 	mov	r0, r3
  111d0c:	ebfff8dc 	bl	110084 <err_to_errno>
  111d10:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
  111d14:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  111d18:	e6ef2073 	uxtb	r2, r3
  111d1c:	e51b300c 	ldr	r3, [fp, #-12]
  111d20:	e5c32010 	strb	r2, [r3, #16]
  111d24:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  111d28:	e3530000 	cmp	r3, #0
  111d2c:	0a000003 	beq	111d40 <lwip_connect+0x188>
  111d30:	eb009ce8 	bl	1390d8 <__errno_location>
  111d34:	e1a02000 	mov	r2, r0
  111d38:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  111d3c:	e5823000 	str	r3, [r2]
    return -1;
  111d40:	e3e03000 	mvn	r3, #0
  111d44:	ea00000d 	b	111d80 <lwip_connect+0x1c8>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  111d48:	e3a03000 	mov	r3, #0
  111d4c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  111d50:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111d54:	e6ef2073 	uxtb	r2, r3
  111d58:	e51b300c 	ldr	r3, [fp, #-12]
  111d5c:	e5c32010 	strb	r2, [r3, #16]
  111d60:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111d64:	e3530000 	cmp	r3, #0
  111d68:	0a000003 	beq	111d7c <lwip_connect+0x1c4>
  111d6c:	eb009cd9 	bl	1390d8 <__errno_location>
  111d70:	e1a02000 	mov	r2, r0
  111d74:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111d78:	e5823000 	str	r3, [r2]
  return 0;
  111d7c:	e3a03000 	mov	r3, #0
}
  111d80:	e1a00003 	mov	r0, r3
  111d84:	e24bd004 	sub	sp, fp, #4
  111d88:	e8bd8800 	pop	{fp, pc}

00111d8c <lwip_listen>:
 * @param backlog (ATTENTION: needs TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  111d8c:	e92d4800 	push	{fp, lr}
  111d90:	e28db004 	add	fp, sp, #4
  111d94:	e24dd020 	sub	sp, sp, #32
  111d98:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  111d9c:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  struct lwip_sock *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  111da0:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  111da4:	ebfffcde 	bl	111124 <get_socket>
  111da8:	e50b0008 	str	r0, [fp, #-8]
  if (!sock) {
  111dac:	e51b3008 	ldr	r3, [fp, #-8]
  111db0:	e3530000 	cmp	r3, #0
  111db4:	1a000001 	bne	111dc0 <lwip_listen+0x34>
    return -1;
  111db8:	e3e03000 	mvn	r3, #0
  111dbc:	ea000047 	b	111ee0 <lwip_listen+0x154>
  }

  /* limit the "backlog" parameter to fit in an u8_t */
  backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
  111dc0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111dc4:	e35300fe 	cmp	r3, #254	; 0xfe
  111dc8:	ca000002 	bgt	111dd8 <lwip_listen+0x4c>
  111dcc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111dd0:	e1c33fc3 	bic	r3, r3, r3, asr #31
  111dd4:	ea000000 	b	111ddc <lwip_listen+0x50>
  111dd8:	e3a030ff 	mov	r3, #255	; 0xff
  111ddc:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc

  err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
  111de0:	e51b3008 	ldr	r3, [fp, #-8]
  111de4:	e5933000 	ldr	r3, [r3]
  111de8:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  111dec:	e6ef2072 	uxtb	r2, r2
  111df0:	e1a01002 	mov	r1, r2
  111df4:	e1a00003 	mov	r0, r3
  111df8:	ebffe6dc 	bl	10b970 <netconn_listen_with_backlog>
  111dfc:	e1a03000 	mov	r3, r0
  111e00:	e54b3009 	strb	r3, [fp, #-9]

  if (err != ERR_OK) {
  111e04:	e15b30d9 	ldrsb	r3, [fp, #-9]
  111e08:	e3530000 	cmp	r3, #0
  111e0c:	0a000025 	beq	111ea8 <lwip_listen+0x11c>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
  111e10:	e51b3008 	ldr	r3, [fp, #-8]
  111e14:	e5933000 	ldr	r3, [r3]
  111e18:	e5933000 	ldr	r3, [r3]
  111e1c:	e20330f0 	and	r3, r3, #240	; 0xf0
  111e20:	e3530010 	cmp	r3, #16
  111e24:	0a00000e 	beq	111e64 <lwip_listen+0xd8>
      sock_set_errno(sock, EOPNOTSUPP);
  111e28:	e3a0305f 	mov	r3, #95	; 0x5f
  111e2c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  111e30:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111e34:	e6ef2073 	uxtb	r2, r3
  111e38:	e51b3008 	ldr	r3, [fp, #-8]
  111e3c:	e5c32010 	strb	r2, [r3, #16]
  111e40:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111e44:	e3530000 	cmp	r3, #0
  111e48:	0a000003 	beq	111e5c <lwip_listen+0xd0>
  111e4c:	eb009ca1 	bl	1390d8 <__errno_location>
  111e50:	e1a02000 	mov	r2, r0
  111e54:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111e58:	e5823000 	str	r3, [r2]
      return -1;
  111e5c:	e3e03000 	mvn	r3, #0
  111e60:	ea00001e 	b	111ee0 <lwip_listen+0x154>
    }
    sock_set_errno(sock, err_to_errno(err));
  111e64:	e15b30d9 	ldrsb	r3, [fp, #-9]
  111e68:	e1a00003 	mov	r0, r3
  111e6c:	ebfff884 	bl	110084 <err_to_errno>
  111e70:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  111e74:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111e78:	e6ef2073 	uxtb	r2, r3
  111e7c:	e51b3008 	ldr	r3, [fp, #-8]
  111e80:	e5c32010 	strb	r2, [r3, #16]
  111e84:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111e88:	e3530000 	cmp	r3, #0
  111e8c:	0a000003 	beq	111ea0 <lwip_listen+0x114>
  111e90:	eb009c90 	bl	1390d8 <__errno_location>
  111e94:	e1a02000 	mov	r2, r0
  111e98:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  111e9c:	e5823000 	str	r3, [r2]
    return -1;
  111ea0:	e3e03000 	mvn	r3, #0
  111ea4:	ea00000d 	b	111ee0 <lwip_listen+0x154>
  }

  sock_set_errno(sock, 0);
  111ea8:	e3a03000 	mov	r3, #0
  111eac:	e50b3010 	str	r3, [fp, #-16]
  111eb0:	e51b3010 	ldr	r3, [fp, #-16]
  111eb4:	e6ef2073 	uxtb	r2, r3
  111eb8:	e51b3008 	ldr	r3, [fp, #-8]
  111ebc:	e5c32010 	strb	r2, [r3, #16]
  111ec0:	e51b3010 	ldr	r3, [fp, #-16]
  111ec4:	e3530000 	cmp	r3, #0
  111ec8:	0a000003 	beq	111edc <lwip_listen+0x150>
  111ecc:	eb009c81 	bl	1390d8 <__errno_location>
  111ed0:	e1a02000 	mov	r2, r0
  111ed4:	e51b3010 	ldr	r3, [fp, #-16]
  111ed8:	e5823000 	str	r3, [r2]
  return 0;
  111edc:	e3a03000 	mov	r3, #0
}
  111ee0:	e1a00003 	mov	r0, r3
  111ee4:	e24bd004 	sub	sp, fp, #4
  111ee8:	e8bd8800 	pop	{fp, pc}

00111eec <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, size_t len, int flags,
              struct sockaddr *from, socklen_t *fromlen)
{
  111eec:	e92d4810 	push	{r4, fp, lr}
  111ef0:	e28db008 	add	fp, sp, #8
  111ef4:	e24dd05c 	sub	sp, sp, #92	; 0x5c
  111ef8:	e50b0058 	str	r0, [fp, #-88]	; 0xffffffa8
  111efc:	e50b105c 	str	r1, [fp, #-92]	; 0xffffffa4
  111f00:	e50b2060 	str	r2, [fp, #-96]	; 0xffffffa0
  111f04:	e50b3064 	str	r3, [fp, #-100]	; 0xffffff9c
  struct lwip_sock *sock;
  void             *buf = NULL;
  111f08:	e3a03000 	mov	r3, #0
  111f0c:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  struct pbuf      *p;
  u16_t            buflen, copylen;
  int              off = 0;
  111f10:	e3a03000 	mov	r3, #0
  111f14:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  u8_t             done = 0;
  111f18:	e3a03000 	mov	r3, #0
  111f1c:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
  err_t            err;
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  111f20:	e51b0058 	ldr	r0, [fp, #-88]	; 0xffffffa8
  111f24:	ebfffc7e 	bl	111124 <get_socket>
  111f28:	e50b0024 	str	r0, [fp, #-36]	; 0xffffffdc
  if (!sock) {
  111f2c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111f30:	e3530000 	cmp	r3, #0
  111f34:	1a000001 	bne	111f40 <lwip_recvfrom+0x54>
    return -1;
  111f38:	e3e03000 	mvn	r3, #0
  111f3c:	ea00015b 	b	1124b0 <lwip_recvfrom+0x5c4>
  }

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  111f40:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111f44:	e5933004 	ldr	r3, [r3, #4]
  111f48:	e3530000 	cmp	r3, #0
  111f4c:	0a000003 	beq	111f60 <lwip_recvfrom+0x74>
      buf = sock->lastdata;
  111f50:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111f54:	e5933004 	ldr	r3, [r3, #4]
  111f58:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  111f5c:	ea00007d 	b	112158 <lwip_recvfrom+0x26c>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) &&
  111f60:	e51b3064 	ldr	r3, [fp, #-100]	; 0xffffff9c
  111f64:	e2033008 	and	r3, r3, #8
  111f68:	e3530000 	cmp	r3, #0
  111f6c:	1a000005 	bne	111f88 <lwip_recvfrom+0x9c>
  111f70:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111f74:	e5933000 	ldr	r3, [r3]
  111f78:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  111f7c:	e2033002 	and	r3, r3, #2
  111f80:	e3530000 	cmp	r3, #0
  111f84:	0a00001b 	beq	111ff8 <lwip_recvfrom+0x10c>
          (sock->rcvevent <= 0)) {
  111f88:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111f8c:	e1d330fa 	ldrsh	r3, [r3, #10]
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) &&
  111f90:	e3530000 	cmp	r3, #0
  111f94:	ca000017 	bgt	111ff8 <lwip_recvfrom+0x10c>
        if (off > 0) {
  111f98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111f9c:	e3530000 	cmp	r3, #0
  111fa0:	da00000e 	ble	111fe0 <lwip_recvfrom+0xf4>
          /* already received data, return that */
          sock_set_errno(sock, 0);
  111fa4:	e3a03000 	mov	r3, #0
  111fa8:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  111fac:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  111fb0:	e6ef2073 	uxtb	r2, r3
  111fb4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111fb8:	e5c32010 	strb	r2, [r3, #16]
  111fbc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  111fc0:	e3530000 	cmp	r3, #0
  111fc4:	0a000003 	beq	111fd8 <lwip_recvfrom+0xec>
  111fc8:	eb009c42 	bl	1390d8 <__errno_location>
  111fcc:	e1a02000 	mov	r2, r0
  111fd0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  111fd4:	e5823000 	str	r3, [r2]
          return off;
  111fd8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  111fdc:	ea000133 	b	1124b0 <lwip_recvfrom+0x5c4>
        }

        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        set_errno(EWOULDBLOCK);
  111fe0:	eb009c3c 	bl	1390d8 <__errno_location>
  111fe4:	e1a02000 	mov	r2, r0
  111fe8:	e3a0300b 	mov	r3, #11
  111fec:	e5823000 	str	r3, [r2]
        return -1;
  111ff0:	e3e03000 	mvn	r3, #0
  111ff4:	ea00012d 	b	1124b0 <lwip_recvfrom+0x5c4>
      }
      /* No data was left from the previous operation, so we try to get
         some from the network. */
      if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
  111ff8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  111ffc:	e5933000 	ldr	r3, [r3]
  112000:	e5933000 	ldr	r3, [r3]
  112004:	e20330f0 	and	r3, r3, #240	; 0xf0
  112008:	e3530010 	cmp	r3, #16
  11200c:	1a000008 	bne	112034 <lwip_recvfrom+0x148>
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
  112010:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112014:	e5933000 	ldr	r3, [r3]
  112018:	e24b203c 	sub	r2, fp, #60	; 0x3c
  11201c:	e1a01002 	mov	r1, r2
  112020:	e1a00003 	mov	r0, r3
  112024:	ebffe794 	bl	10be7c <netconn_recv_tcp_pbuf>
  112028:	e1a03000 	mov	r3, r0
  11202c:	e54b301a 	strb	r3, [fp, #-26]	; 0xffffffe6
  112030:	ea000007 	b	112054 <lwip_recvfrom+0x168>
      } else {
        err = netconn_recv(sock->conn, (struct netbuf **)&buf);
  112034:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112038:	e5933000 	ldr	r3, [r3]
  11203c:	e24b203c 	sub	r2, fp, #60	; 0x3c
  112040:	e1a01002 	mov	r1, r2
  112044:	e1a00003 	mov	r0, r3
  112048:	ebffe7a8 	bl	10bef0 <netconn_recv>
  11204c:	e1a03000 	mov	r3, r0
  112050:	e54b301a 	strb	r3, [fp, #-26]	; 0xffffffe6
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
        err, buf));

      if (err != ERR_OK) {
  112054:	e15b31da 	ldrsb	r3, [fp, #-26]	; 0xffffffe6
  112058:	e3530000 	cmp	r3, #0
  11205c:	0a000030 	beq	112124 <lwip_recvfrom+0x238>
        if (off > 0) {
  112060:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  112064:	e3530000 	cmp	r3, #0
  112068:	da000017 	ble	1120cc <lwip_recvfrom+0x1e0>
          if (err == ERR_CLSD) {
  11206c:	e15b31da 	ldrsb	r3, [fp, #-26]	; 0xffffffe6
  112070:	e373000f 	cmn	r3, #15
  112074:	1a000005 	bne	112090 <lwip_recvfrom+0x1a4>
            /* closed but already received data, ensure select gets the FIN, too */
            event_callback(sock->conn, NETCONN_EVT_RCVPLUS, 0);
  112078:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11207c:	e5933000 	ldr	r3, [r3]
  112080:	e3a02000 	mov	r2, #0
  112084:	e3a01000 	mov	r1, #0
  112088:	e1a00003 	mov	r0, r3
  11208c:	eb0006bc 	bl	113b84 <event_callback>
          }
          /* already received data, return that */
          sock_set_errno(sock, 0);
  112090:	e3a03000 	mov	r3, #0
  112094:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
  112098:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  11209c:	e6ef2073 	uxtb	r2, r3
  1120a0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1120a4:	e5c32010 	strb	r2, [r3, #16]
  1120a8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1120ac:	e3530000 	cmp	r3, #0
  1120b0:	0a000003 	beq	1120c4 <lwip_recvfrom+0x1d8>
  1120b4:	eb009c07 	bl	1390d8 <__errno_location>
  1120b8:	e1a02000 	mov	r2, r0
  1120bc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1120c0:	e5823000 	str	r3, [r2]
          return off;
  1120c4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1120c8:	ea0000f8 	b	1124b0 <lwip_recvfrom+0x5c4>
        }
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
          s, lwip_strerr(err)));
        sock_set_errno(sock, err_to_errno(err));
  1120cc:	e15b31da 	ldrsb	r3, [fp, #-26]	; 0xffffffe6
  1120d0:	e1a00003 	mov	r0, r3
  1120d4:	ebfff7ea 	bl	110084 <err_to_errno>
  1120d8:	e50b002c 	str	r0, [fp, #-44]	; 0xffffffd4
  1120dc:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1120e0:	e6ef2073 	uxtb	r2, r3
  1120e4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1120e8:	e5c32010 	strb	r2, [r3, #16]
  1120ec:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1120f0:	e3530000 	cmp	r3, #0
  1120f4:	0a000003 	beq	112108 <lwip_recvfrom+0x21c>
  1120f8:	eb009bf6 	bl	1390d8 <__errno_location>
  1120fc:	e1a02000 	mov	r2, r0
  112100:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  112104:	e5823000 	str	r3, [r2]
        if (err == ERR_CLSD) {
  112108:	e15b31da 	ldrsb	r3, [fp, #-26]	; 0xffffffe6
  11210c:	e373000f 	cmn	r3, #15
  112110:	1a000001 	bne	11211c <lwip_recvfrom+0x230>
          return 0;
  112114:	e3a03000 	mov	r3, #0
  112118:	ea0000e4 	b	1124b0 <lwip_recvfrom+0x5c4>
        } else {
          return -1;
  11211c:	e3e03000 	mvn	r3, #0
  112120:	ea0000e2 	b	1124b0 <lwip_recvfrom+0x5c4>
        }
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
  112124:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  112128:	e3530000 	cmp	r3, #0
  11212c:	1a000006 	bne	11214c <lwip_recvfrom+0x260>
  112130:	e3070044 	movw	r0, #28740	; 0x7044
  112134:	e3400014 	movt	r0, #20
  112138:	ebffc3f5 	bl	103114 <rt_kprintf>
  11213c:	e3a01fcf 	mov	r1, #828	; 0x33c
  112140:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  112144:	e3400014 	movt	r0, #20
  112148:	ebffe3cb 	bl	10b07c <sys_arch_assert>
      sock->lastdata = buf;
  11214c:	e51b203c 	ldr	r2, [fp, #-60]	; 0xffffffc4
  112150:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112154:	e5832004 	str	r2, [r3, #4]
    }

    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
  112158:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11215c:	e5933000 	ldr	r3, [r3]
  112160:	e5933000 	ldr	r3, [r3]
  112164:	e20330f0 	and	r3, r3, #240	; 0xf0
  112168:	e3530010 	cmp	r3, #16
  11216c:	1a000002 	bne	11217c <lwip_recvfrom+0x290>
      p = (struct pbuf *)buf;
  112170:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  112174:	e50b3010 	str	r3, [fp, #-16]
  112178:	ea000002 	b	112188 <lwip_recvfrom+0x29c>
    } else {
      p = ((struct netbuf *)buf)->p;
  11217c:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  112180:	e5933000 	ldr	r3, [r3]
  112184:	e50b3010 	str	r3, [fp, #-16]
    }
    buflen = p->tot_len;
  112188:	e51b3010 	ldr	r3, [fp, #-16]
  11218c:	e1d330b8 	ldrh	r3, [r3, #8]
  112190:	e14b33b2 	strh	r3, [fp, #-50]	; 0xffffffce
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
      buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  112194:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112198:	e1d330b8 	ldrh	r3, [r3, #8]
  11219c:	e15b23b2 	ldrh	r2, [fp, #-50]	; 0xffffffce
  1121a0:	e0423003 	sub	r3, r2, r3
  1121a4:	e14b33b2 	strh	r3, [fp, #-50]	; 0xffffffce

    if (len > buflen) {
  1121a8:	e15b33b2 	ldrh	r3, [fp, #-50]	; 0xffffffce
  1121ac:	e51b2060 	ldr	r2, [fp, #-96]	; 0xffffffa0
  1121b0:	e1520003 	cmp	r2, r3
  1121b4:	9a000002 	bls	1121c4 <lwip_recvfrom+0x2d8>
      copylen = buflen;
  1121b8:	e15b33b2 	ldrh	r3, [fp, #-50]	; 0xffffffce
  1121bc:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  1121c0:	ea000001 	b	1121cc <lwip_recvfrom+0x2e0>
    } else {
      copylen = (u16_t)len;
  1121c4:	e51b3060 	ldr	r3, [fp, #-96]	; 0xffffffa0
  1121c8:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
  1121cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1121d0:	e51b205c 	ldr	r2, [fp, #-92]	; 0xffffffa4
  1121d4:	e0821003 	add	r1, r2, r3
  1121d8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1121dc:	e1d330b8 	ldrh	r3, [r3, #8]
  1121e0:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
  1121e4:	e51b0010 	ldr	r0, [fp, #-16]
  1121e8:	eb0025bc 	bl	11b8e0 <pbuf_copy_partial>

    off += copylen;
  1121ec:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  1121f0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1121f4:	e0823003 	add	r3, r2, r3
  1121f8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
  1121fc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112200:	e5933000 	ldr	r3, [r3]
  112204:	e5933000 	ldr	r3, [r3]
  112208:	e20330f0 	and	r3, r3, #240	; 0xf0
  11220c:	e3530010 	cmp	r3, #16
  112210:	1a000021 	bne	11229c <lwip_recvfrom+0x3b0>
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
  112214:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  112218:	e51b2060 	ldr	r2, [fp, #-96]	; 0xffffffa0
  11221c:	e1520003 	cmp	r2, r3
  112220:	2a000006 	bcs	112240 <lwip_recvfrom+0x354>
  112224:	e3070050 	movw	r0, #28752	; 0x7050
  112228:	e3400014 	movt	r0, #20
  11222c:	ebffc3b8 	bl	103114 <rt_kprintf>
  112230:	e3a01fd6 	mov	r1, #856	; 0x358
  112234:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  112238:	e3400014 	movt	r0, #20
  11223c:	ebffe38e 	bl	10b07c <sys_arch_assert>
      len -= copylen;
  112240:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  112244:	e51b2060 	ldr	r2, [fp, #-96]	; 0xffffffa0
  112248:	e0423003 	sub	r3, r2, r3
  11224c:	e50b3060 	str	r3, [fp, #-96]	; 0xffffffa0
      if ((len <= 0) ||
  112250:	e51b3060 	ldr	r3, [fp, #-96]	; 0xffffffa0
  112254:	e3530000 	cmp	r3, #0
  112258:	0a00000c 	beq	112290 <lwip_recvfrom+0x3a4>
          (p->flags & PBUF_FLAG_PUSH) ||
  11225c:	e51b3010 	ldr	r3, [fp, #-16]
  112260:	e5d3300d 	ldrb	r3, [r3, #13]
  112264:	e2033001 	and	r3, r3, #1
      if ((len <= 0) ||
  112268:	e3530000 	cmp	r3, #0
  11226c:	1a000007 	bne	112290 <lwip_recvfrom+0x3a4>
          (sock->rcvevent <= 0) ||
  112270:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112274:	e1d330fa 	ldrsh	r3, [r3, #10]
          (p->flags & PBUF_FLAG_PUSH) ||
  112278:	e3530000 	cmp	r3, #0
  11227c:	da000003 	ble	112290 <lwip_recvfrom+0x3a4>
          ((flags & MSG_PEEK) != 0)) {
  112280:	e51b3064 	ldr	r3, [fp, #-100]	; 0xffffff9c
  112284:	e2033001 	and	r3, r3, #1
          (sock->rcvevent <= 0) ||
  112288:	e3530000 	cmp	r3, #0
  11228c:	0a000004 	beq	1122a4 <lwip_recvfrom+0x3b8>
        done = 1;
  112290:	e3a03001 	mov	r3, #1
  112294:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
  112298:	ea000001 	b	1122a4 <lwip_recvfrom+0x3b8>
      }
    } else {
      done = 1;
  11229c:	e3a03001 	mov	r3, #1
  1122a0:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    }

    /* Check to see from where the data was.*/
    if (done) {
  1122a4:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
  1122a8:	e3530000 	cmp	r3, #0
  1122ac:	0a00003f 	beq	1123b0 <lwip_recvfrom+0x4c4>
#if !SOCKETS_DEBUG
      if (from && fromlen)
  1122b0:	e59b3004 	ldr	r3, [fp, #4]
  1122b4:	e3530000 	cmp	r3, #0
  1122b8:	0a00003c 	beq	1123b0 <lwip_recvfrom+0x4c4>
  1122bc:	e59b3008 	ldr	r3, [fp, #8]
  1122c0:	e3530000 	cmp	r3, #0
  1122c4:	0a000039 	beq	1123b0 <lwip_recvfrom+0x4c4>
        u16_t port;
        ip_addr_t tmpaddr;
        ip_addr_t *fromaddr;
        union sockaddr_aligned saddr;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): addr=", s));
        if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
  1122c8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1122cc:	e5933000 	ldr	r3, [r3]
  1122d0:	e5933000 	ldr	r3, [r3]
  1122d4:	e20330f0 	and	r3, r3, #240	; 0xf0
  1122d8:	e3530010 	cmp	r3, #16
  1122dc:	1a000008 	bne	112304 <lwip_recvfrom+0x418>
          fromaddr = &tmpaddr;
  1122e0:	e24b3044 	sub	r3, fp, #68	; 0x44
  1122e4:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
          netconn_getaddr(sock->conn, fromaddr, &port, 0);
  1122e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1122ec:	e5930000 	ldr	r0, [r3]
  1122f0:	e24b203e 	sub	r2, fp, #62	; 0x3e
  1122f4:	e3a03000 	mov	r3, #0
  1122f8:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  1122fc:	ebffe4ec 	bl	10b6b4 <netconn_getaddr>
  112300:	ea000005 	b	11231c <lwip_recvfrom+0x430>
        } else {
          port = netbuf_fromport((struct netbuf *)buf);
  112304:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  112308:	e1d330bc 	ldrh	r3, [r3, #12]
  11230c:	e14b33be 	strh	r3, [fp, #-62]	; 0xffffffc2
          fromaddr = netbuf_fromaddr((struct netbuf *)buf);
  112310:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  112314:	e2833008 	add	r3, r3, #8
  112318:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
          ip4_2_ipv4_mapped_ipv6(ip_2_ip6(fromaddr), ip_2_ip4(fromaddr));
          IP_SET_TYPE(fromaddr, IPADDR_TYPE_V6);
        }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

        IPADDR_PORT_TO_SOCKADDR(&saddr, fromaddr, port);
  11231c:	e24b3054 	sub	r3, fp, #84	; 0x54
  112320:	e3a02010 	mov	r2, #16
  112324:	e5c32000 	strb	r2, [r3]
  112328:	e24b3054 	sub	r3, fp, #84	; 0x54
  11232c:	e3a02002 	mov	r2, #2
  112330:	e5c32001 	strb	r2, [r3, #1]
  112334:	e15b33be 	ldrh	r3, [fp, #-62]	; 0xffffffc2
  112338:	e24b4054 	sub	r4, fp, #84	; 0x54
  11233c:	e1a00003 	mov	r0, r3
  112340:	eb001124 	bl	1167d8 <lwip_htons>
  112344:	e1a03000 	mov	r3, r0
  112348:	e1c430b2 	strh	r3, [r4, #2]
  11234c:	e24b3054 	sub	r3, fp, #84	; 0x54
  112350:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  112354:	e5922000 	ldr	r2, [r2]
  112358:	e5832004 	str	r2, [r3, #4]
  11235c:	e24b3054 	sub	r3, fp, #84	; 0x54
  112360:	e2833008 	add	r3, r3, #8
  112364:	e3a02008 	mov	r2, #8
  112368:	e3a01000 	mov	r1, #0
  11236c:	e1a00003 	mov	r0, r3
  112370:	eb00bc3f 	bl	141474 <memset>
        LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F" len=%d\n", port, off));
#if SOCKETS_DEBUG
        if (from && fromlen)
#endif /* SOCKETS_DEBUG */
        {
          if (*fromlen > saddr.sa.sa_len) {
  112374:	e59b3008 	ldr	r3, [fp, #8]
  112378:	e5933000 	ldr	r3, [r3]
  11237c:	e55b2054 	ldrb	r2, [fp, #-84]	; 0xffffffac
  112380:	e1530002 	cmp	r3, r2
  112384:	9a000003 	bls	112398 <lwip_recvfrom+0x4ac>
            *fromlen = saddr.sa.sa_len;
  112388:	e55b3054 	ldrb	r3, [fp, #-84]	; 0xffffffac
  11238c:	e1a02003 	mov	r2, r3
  112390:	e59b3008 	ldr	r3, [fp, #8]
  112394:	e5832000 	str	r2, [r3]
          }
          MEMCPY(from, &saddr, *fromlen);
  112398:	e59b3008 	ldr	r3, [fp, #8]
  11239c:	e5932000 	ldr	r2, [r3]
  1123a0:	e24b3054 	sub	r3, fp, #84	; 0x54
  1123a4:	e1a01003 	mov	r1, r3
  1123a8:	e59b0004 	ldr	r0, [fp, #4]
  1123ac:	eb00baf8 	bl	140f94 <memcpy>
        }
      }
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK) == 0) {
  1123b0:	e51b3064 	ldr	r3, [fp, #-100]	; 0xffffff9c
  1123b4:	e2033001 	and	r3, r3, #1
  1123b8:	e3530000 	cmp	r3, #0
  1123bc:	1a00002a 	bne	11246c <lwip_recvfrom+0x580>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) && (buflen - copylen > 0)) {
  1123c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1123c4:	e5933000 	ldr	r3, [r3]
  1123c8:	e5933000 	ldr	r3, [r3]
  1123cc:	e20330f0 	and	r3, r3, #240	; 0xf0
  1123d0:	e3530010 	cmp	r3, #16
  1123d4:	1a00000f 	bne	112418 <lwip_recvfrom+0x52c>
  1123d8:	e15b23b2 	ldrh	r2, [fp, #-50]	; 0xffffffce
  1123dc:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  1123e0:	e0423003 	sub	r3, r2, r3
  1123e4:	e3530000 	cmp	r3, #0
  1123e8:	da00000a 	ble	112418 <lwip_recvfrom+0x52c>
        sock->lastdata = buf;
  1123ec:	e51b203c 	ldr	r2, [fp, #-60]	; 0xffffffc4
  1123f0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1123f4:	e5832004 	str	r2, [r3, #4]
        sock->lastoffset += copylen;
  1123f8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1123fc:	e1d320b8 	ldrh	r2, [r3, #8]
  112400:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  112404:	e0823003 	add	r3, r2, r3
  112408:	e6ff2073 	uxth	r2, r3
  11240c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112410:	e1c320b8 	strh	r2, [r3, #8]
  112414:	ea000014 	b	11246c <lwip_recvfrom+0x580>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
      } else {
        sock->lastdata = NULL;
  112418:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11241c:	e3a02000 	mov	r2, #0
  112420:	e5832004 	str	r2, [r3, #4]
        sock->lastoffset = 0;
  112424:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112428:	e3a02000 	mov	r2, #0
  11242c:	e1c320b8 	strh	r2, [r3, #8]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
        if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
  112430:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112434:	e5933000 	ldr	r3, [r3]
  112438:	e5933000 	ldr	r3, [r3]
  11243c:	e20330f0 	and	r3, r3, #240	; 0xf0
  112440:	e3530010 	cmp	r3, #16
  112444:	1a000003 	bne	112458 <lwip_recvfrom+0x56c>
          pbuf_free((struct pbuf *)buf);
  112448:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  11244c:	e1a00003 	mov	r0, r3
  112450:	eb002317 	bl	11b0b4 <pbuf_free>
  112454:	ea000002 	b	112464 <lwip_recvfrom+0x578>
        } else {
          netbuf_delete((struct netbuf *)buf);
  112458:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  11245c:	e1a00003 	mov	r0, r3
  112460:	ebfff732 	bl	110130 <netbuf_delete>
        }
        buf = NULL;
  112464:	e3a03000 	mov	r3, #0
  112468:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
      }
    }
  } while (!done);
  11246c:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
  112470:	e3530000 	cmp	r3, #0
  112474:	0afffeb1 	beq	111f40 <lwip_recvfrom+0x54>

  sock_set_errno(sock, 0);
  112478:	e3a03000 	mov	r3, #0
  11247c:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
  112480:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  112484:	e6ef2073 	uxtb	r2, r3
  112488:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11248c:	e5c32010 	strb	r2, [r3, #16]
  112490:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  112494:	e3530000 	cmp	r3, #0
  112498:	0a000003 	beq	1124ac <lwip_recvfrom+0x5c0>
  11249c:	eb009b0d 	bl	1390d8 <__errno_location>
  1124a0:	e1a02000 	mov	r2, r0
  1124a4:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1124a8:	e5823000 	str	r3, [r2]
  return off;
  1124ac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
}
  1124b0:	e1a00003 	mov	r0, r3
  1124b4:	e24bd008 	sub	sp, fp, #8
  1124b8:	e8bd8810 	pop	{r4, fp, pc}

001124bc <lwip_read>:

int
lwip_read(int s, void *mem, size_t len)
{
  1124bc:	e92d4800 	push	{fp, lr}
  1124c0:	e28db004 	add	fp, sp, #4
  1124c4:	e24dd018 	sub	sp, sp, #24
  1124c8:	e50b0008 	str	r0, [fp, #-8]
  1124cc:	e50b100c 	str	r1, [fp, #-12]
  1124d0:	e50b2010 	str	r2, [fp, #-16]
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  1124d4:	e3a03000 	mov	r3, #0
  1124d8:	e58d3004 	str	r3, [sp, #4]
  1124dc:	e3a03000 	mov	r3, #0
  1124e0:	e58d3000 	str	r3, [sp]
  1124e4:	e3a03000 	mov	r3, #0
  1124e8:	e51b2010 	ldr	r2, [fp, #-16]
  1124ec:	e51b100c 	ldr	r1, [fp, #-12]
  1124f0:	e51b0008 	ldr	r0, [fp, #-8]
  1124f4:	ebfffe7c 	bl	111eec <lwip_recvfrom>
  1124f8:	e1a03000 	mov	r3, r0
}
  1124fc:	e1a00003 	mov	r0, r3
  112500:	e24bd004 	sub	sp, fp, #4
  112504:	e8bd8800 	pop	{fp, pc}

00112508 <lwip_recv>:

int
lwip_recv(int s, void *mem, size_t len, int flags)
{
  112508:	e92d4800 	push	{fp, lr}
  11250c:	e28db004 	add	fp, sp, #4
  112510:	e24dd018 	sub	sp, sp, #24
  112514:	e50b0008 	str	r0, [fp, #-8]
  112518:	e50b100c 	str	r1, [fp, #-12]
  11251c:	e50b2010 	str	r2, [fp, #-16]
  112520:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  112524:	e3a03000 	mov	r3, #0
  112528:	e58d3004 	str	r3, [sp, #4]
  11252c:	e3a03000 	mov	r3, #0
  112530:	e58d3000 	str	r3, [sp]
  112534:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112538:	e51b2010 	ldr	r2, [fp, #-16]
  11253c:	e51b100c 	ldr	r1, [fp, #-12]
  112540:	e51b0008 	ldr	r0, [fp, #-8]
  112544:	ebfffe68 	bl	111eec <lwip_recvfrom>
  112548:	e1a03000 	mov	r3, r0
}
  11254c:	e1a00003 	mov	r0, r3
  112550:	e24bd004 	sub	sp, fp, #4
  112554:	e8bd8800 	pop	{fp, pc}

00112558 <lwip_send>:

int
lwip_send(int s, const void *data, size_t size, int flags)
{
  112558:	e92d4800 	push	{fp, lr}
  11255c:	e28db004 	add	fp, sp, #4
  112560:	e24dd028 	sub	sp, sp, #40	; 0x28
  112564:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  112568:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  11256c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  112570:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  size_t written;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  112574:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  112578:	ebfffae9 	bl	111124 <get_socket>
  11257c:	e50b0008 	str	r0, [fp, #-8]
  if (!sock) {
  112580:	e51b3008 	ldr	r3, [fp, #-8]
  112584:	e3530000 	cmp	r3, #0
  112588:	1a000001 	bne	112594 <lwip_send+0x3c>
    return -1;
  11258c:	e3e03000 	mvn	r3, #0
  112590:	ea000041 	b	11269c <lwip_send+0x144>
  }

  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
  112594:	e51b3008 	ldr	r3, [fp, #-8]
  112598:	e5933000 	ldr	r3, [r3]
  11259c:	e5933000 	ldr	r3, [r3]
  1125a0:	e20330f0 	and	r3, r3, #240	; 0xf0
  1125a4:	e3530010 	cmp	r3, #16
  1125a8:	0a00000a 	beq	1125d8 <lwip_send+0x80>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  1125ac:	e3a03000 	mov	r3, #0
  1125b0:	e58d3004 	str	r3, [sp, #4]
  1125b4:	e3a03000 	mov	r3, #0
  1125b8:	e58d3000 	str	r3, [sp]
  1125bc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1125c0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1125c4:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  1125c8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1125cc:	eb0001b1 	bl	112c98 <lwip_sendto>
  1125d0:	e1a03000 	mov	r3, r0
  1125d4:	ea000030 	b	11269c <lwip_send+0x144>
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
  1125d8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1125dc:	e1a031c3 	asr	r3, r3, #3
  1125e0:	e6af3073 	sxtb	r3, r3
  1125e4:	e2033002 	and	r3, r3, #2
  1125e8:	e6af3073 	sxtb	r3, r3
  write_flags = NETCONN_COPY |
  1125ec:	e3833001 	orr	r3, r3, #1
  1125f0:	e6af2073 	sxtb	r2, r3
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
  1125f4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1125f8:	e1a030c3 	asr	r3, r3, #1
  1125fc:	e6af3073 	sxtb	r3, r3
  112600:	e2033004 	and	r3, r3, #4
  112604:	e6af3073 	sxtb	r3, r3
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
  112608:	e1823003 	orr	r3, r2, r3
  11260c:	e6af3073 	sxtb	r3, r3
  write_flags = NETCONN_COPY |
  112610:	e54b3009 	strb	r3, [fp, #-9]
  written = 0;
  112614:	e3a03000 	mov	r3, #0
  112618:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
  11261c:	e51b3008 	ldr	r3, [fp, #-8]
  112620:	e5930000 	ldr	r0, [r3]
  112624:	e55b2009 	ldrb	r2, [fp, #-9]
  112628:	e24b3014 	sub	r3, fp, #20
  11262c:	e58d3000 	str	r3, [sp]
  112630:	e1a03002 	mov	r3, r2
  112634:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  112638:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  11263c:	ebffe6ce 	bl	10c17c <netconn_write_partly>
  112640:	e1a03000 	mov	r3, r0
  112644:	e54b300a 	strb	r3, [fp, #-10]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
  sock_set_errno(sock, err_to_errno(err));
  112648:	e15b30da 	ldrsb	r3, [fp, #-10]
  11264c:	e1a00003 	mov	r0, r3
  112650:	ebfff68b 	bl	110084 <err_to_errno>
  112654:	e50b0010 	str	r0, [fp, #-16]
  112658:	e51b3010 	ldr	r3, [fp, #-16]
  11265c:	e6ef2073 	uxtb	r2, r3
  112660:	e51b3008 	ldr	r3, [fp, #-8]
  112664:	e5c32010 	strb	r2, [r3, #16]
  112668:	e51b3010 	ldr	r3, [fp, #-16]
  11266c:	e3530000 	cmp	r3, #0
  112670:	0a000003 	beq	112684 <lwip_send+0x12c>
  112674:	eb009a97 	bl	1390d8 <__errno_location>
  112678:	e1a02000 	mov	r2, r0
  11267c:	e51b3010 	ldr	r3, [fp, #-16]
  112680:	e5823000 	str	r3, [r2]
  return (err == ERR_OK ? (int)written : -1);
  112684:	e15b30da 	ldrsb	r3, [fp, #-10]
  112688:	e3530000 	cmp	r3, #0
  11268c:	1a000001 	bne	112698 <lwip_send+0x140>
  112690:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112694:	ea000000 	b	11269c <lwip_send+0x144>
  112698:	e3e03000 	mvn	r3, #0
}
  11269c:	e1a00003 	mov	r0, r3
  1126a0:	e24bd004 	sub	sp, fp, #4
  1126a4:	e8bd8800 	pop	{fp, pc}

001126a8 <lwip_sendmsg>:

int
lwip_sendmsg(int s, const struct msghdr *msg, int flags)
{
  1126a8:	e92d4800 	push	{fp, lr}
  1126ac:	e28db004 	add	fp, sp, #4
  1126b0:	e24dd058 	sub	sp, sp, #88	; 0x58
  1126b4:	e50b0048 	str	r0, [fp, #-72]	; 0xffffffb8
  1126b8:	e50b104c 	str	r1, [fp, #-76]	; 0xffffffb4
  1126bc:	e50b2050 	str	r2, [fp, #-80]	; 0xffffffb0
  int i;
#if LWIP_TCP
  u8_t write_flags;
  size_t written;
#endif
  int size = 0;
  1126c0:	e3a03000 	mov	r3, #0
  1126c4:	e50b300c 	str	r3, [fp, #-12]
  err_t err = ERR_OK;
  1126c8:	e3a03000 	mov	r3, #0
  1126cc:	e54b300d 	strb	r3, [fp, #-13]

  sock = get_socket(s);
  1126d0:	e51b0048 	ldr	r0, [fp, #-72]	; 0xffffffb8
  1126d4:	ebfffa92 	bl	111124 <get_socket>
  1126d8:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  if (!sock) {
  1126dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1126e0:	e3530000 	cmp	r3, #0
  1126e4:	1a000001 	bne	1126f0 <lwip_sendmsg+0x48>
    return -1;
  1126e8:	e3e03000 	mvn	r3, #0
  1126ec:	ea000166 	b	112c8c <lwip_sendmsg+0x5e4>
  }

  LWIP_ERROR("lwip_sendmsg: invalid msghdr", msg != NULL,
  1126f0:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  1126f4:	e3530000 	cmp	r3, #0
  1126f8:	1a000016 	bne	112758 <lwip_sendmsg+0xb0>
  1126fc:	e3070078 	movw	r0, #28792	; 0x7078
  112700:	e3400014 	movt	r0, #20
  112704:	ebffc282 	bl	103114 <rt_kprintf>
  112708:	e30013eb 	movw	r1, #1003	; 0x3eb
  11270c:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  112710:	e3400014 	movt	r0, #20
  112714:	ebffe258 	bl	10b07c <sys_arch_assert>
  112718:	e3e0000f 	mvn	r0, #15
  11271c:	ebfff658 	bl	110084 <err_to_errno>
  112720:	e50b003c 	str	r0, [fp, #-60]	; 0xffffffc4
  112724:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  112728:	e6ef2073 	uxtb	r2, r3
  11272c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112730:	e5c32010 	strb	r2, [r3, #16]
  112734:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  112738:	e3530000 	cmp	r3, #0
  11273c:	0a000003 	beq	112750 <lwip_sendmsg+0xa8>
  112740:	eb009a64 	bl	1390d8 <__errno_location>
  112744:	e1a02000 	mov	r2, r0
  112748:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  11274c:	e5823000 	str	r3, [r2]
  112750:	e3e03000 	mvn	r3, #0
  112754:	ea00014c 	b	112c8c <lwip_sendmsg+0x5e4>
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  LWIP_UNUSED_ARG(msg->msg_control);
  LWIP_UNUSED_ARG(msg->msg_controllen);
  LWIP_UNUSED_ARG(msg->msg_flags);
  LWIP_ERROR("lwip_sendmsg: invalid msghdr iov", (msg->msg_iov != NULL && msg->msg_iovlen != 0),
  112758:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  11275c:	e5933008 	ldr	r3, [r3, #8]
  112760:	e3530000 	cmp	r3, #0
  112764:	0a000003 	beq	112778 <lwip_sendmsg+0xd0>
  112768:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  11276c:	e593300c 	ldr	r3, [r3, #12]
  112770:	e3530000 	cmp	r3, #0
  112774:	1a000016 	bne	1127d4 <lwip_sendmsg+0x12c>
  112778:	e3070098 	movw	r0, #28824	; 0x7098
  11277c:	e3400014 	movt	r0, #20
  112780:	ebffc263 	bl	103114 <rt_kprintf>
  112784:	e30013f1 	movw	r1, #1009	; 0x3f1
  112788:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  11278c:	e3400014 	movt	r0, #20
  112790:	ebffe239 	bl	10b07c <sys_arch_assert>
  112794:	e3e0000f 	mvn	r0, #15
  112798:	ebfff639 	bl	110084 <err_to_errno>
  11279c:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
  1127a0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1127a4:	e6ef2073 	uxtb	r2, r3
  1127a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1127ac:	e5c32010 	strb	r2, [r3, #16]
  1127b0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1127b4:	e3530000 	cmp	r3, #0
  1127b8:	0a000003 	beq	1127cc <lwip_sendmsg+0x124>
  1127bc:	eb009a45 	bl	1390d8 <__errno_location>
  1127c0:	e1a02000 	mov	r2, r0
  1127c4:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1127c8:	e5823000 	str	r3, [r2]
  1127cc:	e3e03000 	mvn	r3, #0
  1127d0:	ea00012d 	b	112c8c <lwip_sendmsg+0x5e4>
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
  1127d4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1127d8:	e5933000 	ldr	r3, [r3]
  1127dc:	e5933000 	ldr	r3, [r3]
  1127e0:	e20330f0 	and	r3, r3, #240	; 0xf0
  1127e4:	e3530010 	cmp	r3, #16
  1127e8:	1a000069 	bne	112994 <lwip_sendmsg+0x2ec>
#if LWIP_TCP
    write_flags = NETCONN_COPY |
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
  1127ec:	e51b3050 	ldr	r3, [fp, #-80]	; 0xffffffb0
  1127f0:	e1a031c3 	asr	r3, r3, #3
  1127f4:	e6af3073 	sxtb	r3, r3
  1127f8:	e2033002 	and	r3, r3, #2
  1127fc:	e6af3073 	sxtb	r3, r3
    write_flags = NETCONN_COPY |
  112800:	e3833001 	orr	r3, r3, #1
  112804:	e6af2073 	sxtb	r2, r3
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
  112808:	e51b3050 	ldr	r3, [fp, #-80]	; 0xffffffb0
  11280c:	e1a030c3 	asr	r3, r3, #1
  112810:	e6af3073 	sxtb	r3, r3
  112814:	e2033004 	and	r3, r3, #4
  112818:	e6af3073 	sxtb	r3, r3
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
  11281c:	e1823003 	orr	r3, r2, r3
  112820:	e6af3073 	sxtb	r3, r3
    write_flags = NETCONN_COPY |
  112824:	e54b302d 	strb	r3, [fp, #-45]	; 0xffffffd3

    for (i = 0; i < msg->msg_iovlen; i++) {
  112828:	e3a03000 	mov	r3, #0
  11282c:	e50b3008 	str	r3, [fp, #-8]
  112830:	ea000041 	b	11293c <lwip_sendmsg+0x294>
      u8_t apiflags = write_flags;
  112834:	e55b302d 	ldrb	r3, [fp, #-45]	; 0xffffffd3
  112838:	e54b302e 	strb	r3, [fp, #-46]	; 0xffffffd2
      if (i + 1 < msg->msg_iovlen) {
  11283c:	e51b3008 	ldr	r3, [fp, #-8]
  112840:	e2832001 	add	r2, r3, #1
  112844:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112848:	e593300c 	ldr	r3, [r3, #12]
  11284c:	e1520003 	cmp	r2, r3
  112850:	aa000002 	bge	112860 <lwip_sendmsg+0x1b8>
        apiflags |= NETCONN_MORE;
  112854:	e55b302e 	ldrb	r3, [fp, #-46]	; 0xffffffd2
  112858:	e3833002 	orr	r3, r3, #2
  11285c:	e54b302e 	strb	r3, [fp, #-46]	; 0xffffffd2
      }
      written = 0;
  112860:	e3a03000 	mov	r3, #0
  112864:	e50b3040 	str	r3, [fp, #-64]	; 0xffffffc0
      err = netconn_write_partly(sock->conn, msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len, write_flags, &written);
  112868:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11286c:	e5930000 	ldr	r0, [r3]
  112870:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112874:	e5932008 	ldr	r2, [r3, #8]
  112878:	e51b3008 	ldr	r3, [fp, #-8]
  11287c:	e1a03183 	lsl	r3, r3, #3
  112880:	e0823003 	add	r3, r2, r3
  112884:	e5931000 	ldr	r1, [r3]
  112888:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  11288c:	e5932008 	ldr	r2, [r3, #8]
  112890:	e51b3008 	ldr	r3, [fp, #-8]
  112894:	e1a03183 	lsl	r3, r3, #3
  112898:	e0823003 	add	r3, r2, r3
  11289c:	e5932004 	ldr	r2, [r3, #4]
  1128a0:	e55bc02d 	ldrb	ip, [fp, #-45]	; 0xffffffd3
  1128a4:	e24b3040 	sub	r3, fp, #64	; 0x40
  1128a8:	e58d3000 	str	r3, [sp]
  1128ac:	e1a0300c 	mov	r3, ip
  1128b0:	ebffe631 	bl	10c17c <netconn_write_partly>
  1128b4:	e1a03000 	mov	r3, r0
  1128b8:	e54b300d 	strb	r3, [fp, #-13]
      if (err == ERR_OK) {
  1128bc:	e15b30dd 	ldrsb	r3, [fp, #-13]
  1128c0:	e3530000 	cmp	r3, #0
  1128c4:	1a00000d 	bne	112900 <lwip_sendmsg+0x258>
        size += written;
  1128c8:	e51b200c 	ldr	r2, [fp, #-12]
  1128cc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1128d0:	e0823003 	add	r3, r2, r3
  1128d4:	e50b300c 	str	r3, [fp, #-12]
        /* check that the entire IO vector was accepected, if not return a partial write */
        if (written != msg->msg_iov[i].iov_len)
  1128d8:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  1128dc:	e5932008 	ldr	r2, [r3, #8]
  1128e0:	e51b3008 	ldr	r3, [fp, #-8]
  1128e4:	e1a03183 	lsl	r3, r3, #3
  1128e8:	e0823003 	add	r3, r2, r3
  1128ec:	e5932004 	ldr	r2, [r3, #4]
  1128f0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1128f4:	e1520003 	cmp	r2, r3
  1128f8:	0a00000c 	beq	112930 <lwip_sendmsg+0x288>
          break;
  1128fc:	ea000013 	b	112950 <lwip_sendmsg+0x2a8>
      }
      /* none of this IO vector was accepted, but previous was, return partial write and conceal ERR_WOULDBLOCK */
      else if (err == ERR_WOULDBLOCK && size > 0) {
  112900:	e15b30dd 	ldrsb	r3, [fp, #-13]
  112904:	e3730007 	cmn	r3, #7
  112908:	1a000005 	bne	112924 <lwip_sendmsg+0x27c>
  11290c:	e51b300c 	ldr	r3, [fp, #-12]
  112910:	e3530000 	cmp	r3, #0
  112914:	da000002 	ble	112924 <lwip_sendmsg+0x27c>
        err = ERR_OK;
  112918:	e3a03000 	mov	r3, #0
  11291c:	e54b300d 	strb	r3, [fp, #-13]
        /* let ERR_WOULDBLOCK persist on the netconn since we are returning ERR_OK */
        break;
  112920:	ea00000a 	b	112950 <lwip_sendmsg+0x2a8>
      } else {
        size = -1;
  112924:	e3e03000 	mvn	r3, #0
  112928:	e50b300c 	str	r3, [fp, #-12]
        break;
  11292c:	ea000007 	b	112950 <lwip_sendmsg+0x2a8>
    for (i = 0; i < msg->msg_iovlen; i++) {
  112930:	e51b3008 	ldr	r3, [fp, #-8]
  112934:	e2833001 	add	r3, r3, #1
  112938:	e50b3008 	str	r3, [fp, #-8]
  11293c:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112940:	e593300c 	ldr	r3, [r3, #12]
  112944:	e51b2008 	ldr	r2, [fp, #-8]
  112948:	e1520003 	cmp	r2, r3
  11294c:	baffffb8 	blt	112834 <lwip_sendmsg+0x18c>
      }
    }
    sock_set_errno(sock, err_to_errno(err));
  112950:	e15b30dd 	ldrsb	r3, [fp, #-13]
  112954:	e1a00003 	mov	r0, r3
  112958:	ebfff5c9 	bl	110084 <err_to_errno>
  11295c:	e50b0034 	str	r0, [fp, #-52]	; 0xffffffcc
  112960:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  112964:	e6ef2073 	uxtb	r2, r3
  112968:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11296c:	e5c32010 	strb	r2, [r3, #16]
  112970:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  112974:	e3530000 	cmp	r3, #0
  112978:	0a000003 	beq	11298c <lwip_sendmsg+0x2e4>
  11297c:	eb0099d5 	bl	1390d8 <__errno_location>
  112980:	e1a02000 	mov	r2, r0
  112984:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  112988:	e5823000 	str	r3, [r2]
    return size;
  11298c:	e51b300c 	ldr	r3, [fp, #-12]
  112990:	ea0000bd 	b	112c8c <lwip_sendmsg+0x5e4>
#if LWIP_UDP || LWIP_RAW
  {
    struct netbuf *chain_buf;

    LWIP_UNUSED_ARG(flags);
    LWIP_ERROR("lwip_sendmsg: invalid msghdr name", (((msg->msg_name == NULL) && (msg->msg_namelen == 0)) ||
  112994:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112998:	e5933000 	ldr	r3, [r3]
  11299c:	e3530000 	cmp	r3, #0
  1129a0:	1a000003 	bne	1129b4 <lwip_sendmsg+0x30c>
  1129a4:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  1129a8:	e5933004 	ldr	r3, [r3, #4]
  1129ac:	e3530000 	cmp	r3, #0
  1129b0:	0a00001a 	beq	112a20 <lwip_sendmsg+0x378>
  1129b4:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  1129b8:	e5933004 	ldr	r3, [r3, #4]
  1129bc:	e3530010 	cmp	r3, #16
  1129c0:	0a000016 	beq	112a20 <lwip_sendmsg+0x378>
  1129c4:	e30700bc 	movw	r0, #28860	; 0x70bc
  1129c8:	e3400014 	movt	r0, #20
  1129cc:	ebffc1d0 	bl	103114 <rt_kprintf>
  1129d0:	e300141f 	movw	r1, #1055	; 0x41f
  1129d4:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  1129d8:	e3400014 	movt	r0, #20
  1129dc:	ebffe1a6 	bl	10b07c <sys_arch_assert>
  1129e0:	e3e0000f 	mvn	r0, #15
  1129e4:	ebfff5a6 	bl	110084 <err_to_errno>
  1129e8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1129ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1129f0:	e6ef2073 	uxtb	r2, r3
  1129f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1129f8:	e5c32010 	strb	r2, [r3, #16]
  1129fc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  112a00:	e3530000 	cmp	r3, #0
  112a04:	0a000003 	beq	112a18 <lwip_sendmsg+0x370>
  112a08:	eb0099b2 	bl	1390d8 <__errno_location>
  112a0c:	e1a02000 	mov	r2, r0
  112a10:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  112a14:	e5823000 	str	r3, [r2]
  112a18:	e3e03000 	mvn	r3, #0
  112a1c:	ea00009a 	b	112c8c <lwip_sendmsg+0x5e4>
               IS_SOCK_ADDR_LEN_VALID(msg->msg_namelen)) ,
               sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

    /* initialize chain buffer with destination */
    chain_buf = netbuf_new();
  112a20:	ebfff5ae 	bl	1100e0 <netbuf_new>
  112a24:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
    if (!chain_buf) {
  112a28:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  112a2c:	e3530000 	cmp	r3, #0
  112a30:	1a00000f 	bne	112a74 <lwip_sendmsg+0x3cc>
      sock_set_errno(sock, err_to_errno(ERR_MEM));
  112a34:	e3e00000 	mvn	r0, #0
  112a38:	ebfff591 	bl	110084 <err_to_errno>
  112a3c:	e50b002c 	str	r0, [fp, #-44]	; 0xffffffd4
  112a40:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  112a44:	e6ef2073 	uxtb	r2, r3
  112a48:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112a4c:	e5c32010 	strb	r2, [r3, #16]
  112a50:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  112a54:	e3530000 	cmp	r3, #0
  112a58:	0a000003 	beq	112a6c <lwip_sendmsg+0x3c4>
  112a5c:	eb00999d 	bl	1390d8 <__errno_location>
  112a60:	e1a02000 	mov	r2, r0
  112a64:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  112a68:	e5823000 	str	r3, [r2]
      return -1;
  112a6c:	e3e03000 	mvn	r3, #0
  112a70:	ea000085 	b	112c8c <lwip_sendmsg+0x5e4>
    }
    if (msg->msg_name) {
  112a74:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112a78:	e5933000 	ldr	r3, [r3]
  112a7c:	e3530000 	cmp	r3, #0
  112a80:	0a00000e 	beq	112ac0 <lwip_sendmsg+0x418>
      u16_t remote_port;
      SOCKADDR_TO_IPADDR_PORT((const struct sockaddr *)msg->msg_name, &chain_buf->addr, remote_port);
  112a84:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112a88:	e5933000 	ldr	r3, [r3]
  112a8c:	e5932004 	ldr	r2, [r3, #4]
  112a90:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  112a94:	e5832008 	str	r2, [r3, #8]
  112a98:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112a9c:	e5933000 	ldr	r3, [r3]
  112aa0:	e1d330b2 	ldrh	r3, [r3, #2]
  112aa4:	e1a00003 	mov	r0, r3
  112aa8:	eb000f4a 	bl	1167d8 <lwip_htons>
  112aac:	e1a03000 	mov	r3, r0
  112ab0:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
      netbuf_fromport(chain_buf) = remote_port;
  112ab4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  112ab8:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
  112abc:	e1c320bc 	strh	r2, [r3, #12]
      err = ERR_OK;
    }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
    /* create a chained netbuf from the IO vectors. NOTE: we assemble a pbuf chain
       manually to avoid having to allocate, chain, and delete a netbuf for each iov */
    for (i = 0; i < msg->msg_iovlen; i++) {
  112ac0:	e3a03000 	mov	r3, #0
  112ac4:	e50b3008 	str	r3, [fp, #-8]
  112ac8:	ea000042 	b	112bd8 <lwip_sendmsg+0x530>
      struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  112acc:	e3a02002 	mov	r2, #2
  112ad0:	e3a01000 	mov	r1, #0
  112ad4:	e3a00000 	mov	r0, #0
  112ad8:	eb001e6e 	bl	11a498 <pbuf_alloc>
  112adc:	e50b0024 	str	r0, [fp, #-36]	; 0xffffffdc
      if (p == NULL) {
  112ae0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112ae4:	e3530000 	cmp	r3, #0
  112ae8:	1a000002 	bne	112af8 <lwip_sendmsg+0x450>
        err = ERR_MEM; /* let netbuf_delete() cleanup chain_buf */
  112aec:	e3e03000 	mvn	r3, #0
  112af0:	e54b300d 	strb	r3, [fp, #-13]
        break;
  112af4:	ea00003c 	b	112bec <lwip_sendmsg+0x544>
      }
      p->payload = msg->msg_iov[i].iov_base;
  112af8:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112afc:	e5932008 	ldr	r2, [r3, #8]
  112b00:	e51b3008 	ldr	r3, [fp, #-8]
  112b04:	e1a03183 	lsl	r3, r3, #3
  112b08:	e0823003 	add	r3, r2, r3
  112b0c:	e5932000 	ldr	r2, [r3]
  112b10:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112b14:	e5832004 	str	r2, [r3, #4]
      LWIP_ASSERT("iov_len < u16_t", msg->msg_iov[i].iov_len <= 0xFFFF);
  112b18:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112b1c:	e5932008 	ldr	r2, [r3, #8]
  112b20:	e51b3008 	ldr	r3, [fp, #-8]
  112b24:	e1a03183 	lsl	r3, r3, #3
  112b28:	e0823003 	add	r3, r2, r3
  112b2c:	e5933004 	ldr	r3, [r3, #4]
  112b30:	e3530801 	cmp	r3, #65536	; 0x10000
  112b34:	3a000006 	bcc	112b54 <lwip_sendmsg+0x4ac>
  112b38:	e30700e0 	movw	r0, #28896	; 0x70e0
  112b3c:	e3400014 	movt	r0, #20
  112b40:	ebffc173 	bl	103114 <rt_kprintf>
  112b44:	e300144d 	movw	r1, #1101	; 0x44d
  112b48:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  112b4c:	e3400014 	movt	r0, #20
  112b50:	ebffe149 	bl	10b07c <sys_arch_assert>
      p->len = p->tot_len = (u16_t)msg->msg_iov[i].iov_len;
  112b54:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112b58:	e5932008 	ldr	r2, [r3, #8]
  112b5c:	e51b3008 	ldr	r3, [fp, #-8]
  112b60:	e1a03183 	lsl	r3, r3, #3
  112b64:	e0823003 	add	r3, r2, r3
  112b68:	e5933004 	ldr	r3, [r3, #4]
  112b6c:	e6ff2073 	uxth	r2, r3
  112b70:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112b74:	e1c320b8 	strh	r2, [r3, #8]
  112b78:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112b7c:	e1d320b8 	ldrh	r2, [r3, #8]
  112b80:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112b84:	e1c320ba 	strh	r2, [r3, #10]
      /* netbuf empty, add new pbuf */
      if (chain_buf->p == NULL) {
  112b88:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  112b8c:	e5933000 	ldr	r3, [r3]
  112b90:	e3530000 	cmp	r3, #0
  112b94:	1a000007 	bne	112bb8 <lwip_sendmsg+0x510>
        chain_buf->p = chain_buf->ptr = p;
  112b98:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  112b9c:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  112ba0:	e5832004 	str	r2, [r3, #4]
  112ba4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  112ba8:	e5932004 	ldr	r2, [r3, #4]
  112bac:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  112bb0:	e5832000 	str	r2, [r3]
  112bb4:	ea000004 	b	112bcc <lwip_sendmsg+0x524>
        /* add pbuf to existing pbuf chain */
      } else {
        pbuf_cat(chain_buf->p, p);
  112bb8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  112bbc:	e5933000 	ldr	r3, [r3]
  112bc0:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  112bc4:	e1a00003 	mov	r0, r3
  112bc8:	eb0021f0 	bl	11b390 <pbuf_cat>
    for (i = 0; i < msg->msg_iovlen; i++) {
  112bcc:	e51b3008 	ldr	r3, [fp, #-8]
  112bd0:	e2833001 	add	r3, r3, #1
  112bd4:	e50b3008 	str	r3, [fp, #-8]
  112bd8:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  112bdc:	e593300c 	ldr	r3, [r3, #12]
  112be0:	e51b2008 	ldr	r2, [fp, #-8]
  112be4:	e1520003 	cmp	r2, r3
  112be8:	baffffb7 	blt	112acc <lwip_sendmsg+0x424>
      }
    }
    /* save size of total chain */
    if (err == ERR_OK) {
  112bec:	e15b30dd 	ldrsb	r3, [fp, #-13]
  112bf0:	e3530000 	cmp	r3, #0
  112bf4:	1a000003 	bne	112c08 <lwip_sendmsg+0x560>
      size = netbuf_len(chain_buf);
  112bf8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  112bfc:	e5933000 	ldr	r3, [r3]
  112c00:	e1d330b8 	ldrh	r3, [r3, #8]
  112c04:	e50b300c 	str	r3, [fp, #-12]
    }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

    if (err == ERR_OK) {
  112c08:	e15b30dd 	ldrsb	r3, [fp, #-13]
  112c0c:	e3530000 	cmp	r3, #0
  112c10:	1a000006 	bne	112c30 <lwip_sendmsg+0x588>
        IP_SET_TYPE_VAL(chain_buf->addr, IPADDR_TYPE_V4);
      }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

      /* send the data */
      err = netconn_send(sock->conn, chain_buf);
  112c14:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112c18:	e5933000 	ldr	r3, [r3]
  112c1c:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  112c20:	e1a00003 	mov	r0, r3
  112c24:	ebffe534 	bl	10c0fc <netconn_send>
  112c28:	e1a03000 	mov	r3, r0
  112c2c:	e54b300d 	strb	r3, [fp, #-13]
    }

    /* deallocated the buffer */
    netbuf_delete(chain_buf);
  112c30:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  112c34:	ebfff53d 	bl	110130 <netbuf_delete>

    sock_set_errno(sock, err_to_errno(err));
  112c38:	e15b30dd 	ldrsb	r3, [fp, #-13]
  112c3c:	e1a00003 	mov	r0, r3
  112c40:	ebfff50f 	bl	110084 <err_to_errno>
  112c44:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  112c48:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  112c4c:	e6ef2073 	uxtb	r2, r3
  112c50:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112c54:	e5c32010 	strb	r2, [r3, #16]
  112c58:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  112c5c:	e3530000 	cmp	r3, #0
  112c60:	0a000003 	beq	112c74 <lwip_sendmsg+0x5cc>
  112c64:	eb00991b 	bl	1390d8 <__errno_location>
  112c68:	e1a02000 	mov	r2, r0
  112c6c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  112c70:	e5823000 	str	r3, [r2]
    return (err == ERR_OK ? size : -1);
  112c74:	e15b30dd 	ldrsb	r3, [fp, #-13]
  112c78:	e3530000 	cmp	r3, #0
  112c7c:	1a000001 	bne	112c88 <lwip_sendmsg+0x5e0>
  112c80:	e51b300c 	ldr	r3, [fp, #-12]
  112c84:	ea000000 	b	112c8c <lwip_sendmsg+0x5e4>
  112c88:	e3e03000 	mvn	r3, #0
  }
#else /* LWIP_UDP || LWIP_RAW */
  sock_set_errno(sock, err_to_errno(ERR_ARG));
  return -1;
#endif /* LWIP_UDP || LWIP_RAW */
}
  112c8c:	e1a00003 	mov	r0, r3
  112c90:	e24bd004 	sub	sp, fp, #4
  112c94:	e8bd8800 	pop	{fp, pc}

00112c98 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, size_t size, int flags,
       const struct sockaddr *to, socklen_t tolen)
{
  112c98:	e92d4800 	push	{fp, lr}
  112c9c:	e28db004 	add	fp, sp, #4
  112ca0:	e24dd038 	sub	sp, sp, #56	; 0x38
  112ca4:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  112ca8:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
  112cac:	e50b2038 	str	r2, [fp, #-56]	; 0xffffffc8
  112cb0:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  struct lwip_sock *sock;
  err_t err;
  u16_t short_size;
  u16_t remote_port;
  struct netbuf buf;
  sock = get_socket(s);
  112cb4:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  112cb8:	ebfff919 	bl	111124 <get_socket>
  112cbc:	e50b000c 	str	r0, [fp, #-12]
  if (!sock) {
  112cc0:	e51b300c 	ldr	r3, [fp, #-12]
  112cc4:	e3530000 	cmp	r3, #0
  112cc8:	1a000001 	bne	112cd4 <lwip_sendto+0x3c>
    return -1;
  112ccc:	e3e03000 	mvn	r3, #0
  112cd0:	ea000081 	b	112edc <lwip_sendto+0x244>
  }
  if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) == NETCONN_TCP) {
  112cd4:	e51b300c 	ldr	r3, [fp, #-12]
  112cd8:	e5933000 	ldr	r3, [r3]
  112cdc:	e5933000 	ldr	r3, [r3]
  112ce0:	e20330f0 	and	r3, r3, #240	; 0xf0
  112ce4:	e3530010 	cmp	r3, #16
  112ce8:	1a000006 	bne	112d08 <lwip_sendto+0x70>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  112cec:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  112cf0:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
  112cf4:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  112cf8:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  112cfc:	ebfffe15 	bl	112558 <lwip_send>
  112d00:	e1a03000 	mov	r3, r0
  112d04:	ea000074 	b	112edc <lwip_sendto+0x244>
    return -1;
#endif /* LWIP_TCP */
  }

  /* @todo: split into multiple sendto's? */
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
  112d08:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  112d0c:	e3530801 	cmp	r3, #65536	; 0x10000
  112d10:	3a000006 	bcc	112d30 <lwip_sendto+0x98>
  112d14:	e30700f0 	movw	r0, #28912	; 0x70f0
  112d18:	e3400014 	movt	r0, #20
  112d1c:	ebffc0fc 	bl	103114 <rt_kprintf>
  112d20:	e300148e 	movw	r1, #1166	; 0x48e
  112d24:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  112d28:	e3400014 	movt	r0, #20
  112d2c:	ebffe0d2 	bl	10b07c <sys_arch_assert>
  short_size = (u16_t)size;
  112d30:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  112d34:	e14b30be 	strh	r3, [fp, #-14]
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  112d38:	e59b3004 	ldr	r3, [fp, #4]
  112d3c:	e3530000 	cmp	r3, #0
  112d40:	1a000002 	bne	112d50 <lwip_sendto+0xb8>
  112d44:	e59b3008 	ldr	r3, [fp, #8]
  112d48:	e3530000 	cmp	r3, #0
  112d4c:	0a000021 	beq	112dd8 <lwip_sendto+0x140>
  112d50:	e59b3008 	ldr	r3, [fp, #8]
  112d54:	e3530010 	cmp	r3, #16
  112d58:	1a000007 	bne	112d7c <lwip_sendto+0xe4>
  112d5c:	e59b3004 	ldr	r3, [fp, #4]
  112d60:	e5d33001 	ldrb	r3, [r3, #1]
  112d64:	e3530002 	cmp	r3, #2
  112d68:	1a000003 	bne	112d7c <lwip_sendto+0xe4>
  112d6c:	e59b3004 	ldr	r3, [fp, #4]
  112d70:	e2033003 	and	r3, r3, #3
  112d74:	e3530000 	cmp	r3, #0
  112d78:	0a000016 	beq	112dd8 <lwip_sendto+0x140>
  112d7c:	e3070114 	movw	r0, #28948	; 0x7114
  112d80:	e3400014 	movt	r0, #20
  112d84:	ebffc0e2 	bl	103114 <rt_kprintf>
  112d88:	e3001493 	movw	r1, #1171	; 0x493
  112d8c:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  112d90:	e3400014 	movt	r0, #20
  112d94:	ebffe0b8 	bl	10b07c <sys_arch_assert>
  112d98:	e3e0000f 	mvn	r0, #15
  112d9c:	ebfff4b8 	bl	110084 <err_to_errno>
  112da0:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  112da4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112da8:	e6ef2073 	uxtb	r2, r3
  112dac:	e51b300c 	ldr	r3, [fp, #-12]
  112db0:	e5c32010 	strb	r2, [r3, #16]
  112db4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112db8:	e3530000 	cmp	r3, #0
  112dbc:	0a000003 	beq	112dd0 <lwip_sendto+0x138>
  112dc0:	eb0098c4 	bl	1390d8 <__errno_location>
  112dc4:	e1a02000 	mov	r2, r0
  112dc8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112dcc:	e5823000 	str	r3, [r2]
  112dd0:	e3e03000 	mvn	r3, #0
  112dd4:	ea000040 	b	112edc <lwip_sendto+0x244>
             IS_SOCK_ADDR_TYPE_VALID(to) && IS_SOCK_ADDR_ALIGNED(to))),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  LWIP_UNUSED_ARG(tolen);

  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  112dd8:	e3a03000 	mov	r3, #0
  112ddc:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  112de0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  112de4:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
#if LWIP_CHECKSUM_ON_COPY
  buf.flags = 0;
#endif /* LWIP_CHECKSUM_ON_COPY */
  if (to) {
  112de8:	e59b3004 	ldr	r3, [fp, #4]
  112dec:	e3530000 	cmp	r3, #0
  112df0:	0a000009 	beq	112e1c <lwip_sendto+0x184>
    SOCKADDR_TO_IPADDR_PORT(to, &buf.addr, remote_port);
  112df4:	e59b3004 	ldr	r3, [fp, #4]
  112df8:	e5933004 	ldr	r3, [r3, #4]
  112dfc:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  112e00:	e59b3004 	ldr	r3, [fp, #4]
  112e04:	e1d330b2 	ldrh	r3, [r3, #2]
  112e08:	e1a00003 	mov	r0, r3
  112e0c:	eb000e71 	bl	1167d8 <lwip_htons>
  112e10:	e1a03000 	mov	r3, r0
  112e14:	e14b30b8 	strh	r3, [fp, #-8]
  112e18:	ea000003 	b	112e2c <lwip_sendto+0x194>
  } else {
    remote_port = 0;
  112e1c:	e3a03000 	mov	r3, #0
  112e20:	e14b30b8 	strh	r3, [fp, #-8]
    ip_addr_set_any(NETCONNTYPE_ISIPV6(netconn_type(sock->conn)), &buf.addr);
  112e24:	e3a03000 	mov	r3, #0
  112e28:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  }
  netbuf_fromport(&buf) = remote_port;
  112e2c:	e15b30b8 	ldrh	r3, [fp, #-8]
  112e30:	e14b31bc 	strh	r3, [fp, #-28]	; 0xffffffe4
      MEMCPY(buf.p->payload, data, short_size);
    }
    err = ERR_OK;
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
  112e34:	e15b20be 	ldrh	r2, [fp, #-14]
  112e38:	e24b3028 	sub	r3, fp, #40	; 0x28
  112e3c:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  112e40:	e1a00003 	mov	r0, r3
  112e44:	ebfff534 	bl	11031c <netbuf_ref>
  112e48:	e1a03000 	mov	r3, r0
  112e4c:	e54b3005 	strb	r3, [fp, #-5]
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (err == ERR_OK) {
  112e50:	e15b30d5 	ldrsb	r3, [fp, #-5]
  112e54:	e3530000 	cmp	r3, #0
  112e58:	1a000007 	bne	112e7c <lwip_sendto+0x1e4>
      IP_SET_TYPE_VAL(buf.addr, IPADDR_TYPE_V4);
    }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

    /* send the data */
    err = netconn_send(sock->conn, &buf);
  112e5c:	e51b300c 	ldr	r3, [fp, #-12]
  112e60:	e5933000 	ldr	r3, [r3]
  112e64:	e24b2028 	sub	r2, fp, #40	; 0x28
  112e68:	e1a01002 	mov	r1, r2
  112e6c:	e1a00003 	mov	r0, r3
  112e70:	ebffe4a1 	bl	10c0fc <netconn_send>
  112e74:	e1a03000 	mov	r3, r0
  112e78:	e54b3005 	strb	r3, [fp, #-5]
  }

  /* deallocated the buffer */
  netbuf_free(&buf);
  112e7c:	e24b3028 	sub	r3, fp, #40	; 0x28
  112e80:	e1a00003 	mov	r0, r3
  112e84:	ebfff504 	bl	11029c <netbuf_free>

  sock_set_errno(sock, err_to_errno(err));
  112e88:	e15b30d5 	ldrsb	r3, [fp, #-5]
  112e8c:	e1a00003 	mov	r0, r3
  112e90:	ebfff47b 	bl	110084 <err_to_errno>
  112e94:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  112e98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  112e9c:	e6ef2073 	uxtb	r2, r3
  112ea0:	e51b300c 	ldr	r3, [fp, #-12]
  112ea4:	e5c32010 	strb	r2, [r3, #16]
  112ea8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  112eac:	e3530000 	cmp	r3, #0
  112eb0:	0a000003 	beq	112ec4 <lwip_sendto+0x22c>
  112eb4:	eb009887 	bl	1390d8 <__errno_location>
  112eb8:	e1a02000 	mov	r2, r0
  112ebc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  112ec0:	e5823000 	str	r3, [r2]
  return (err == ERR_OK ? short_size : -1);
  112ec4:	e15b30d5 	ldrsb	r3, [fp, #-5]
  112ec8:	e3530000 	cmp	r3, #0
  112ecc:	1a000001 	bne	112ed8 <lwip_sendto+0x240>
  112ed0:	e15b30be 	ldrh	r3, [fp, #-14]
  112ed4:	ea000000 	b	112edc <lwip_sendto+0x244>
  112ed8:	e3e03000 	mvn	r3, #0
}
  112edc:	e1a00003 	mov	r0, r3
  112ee0:	e24bd004 	sub	sp, fp, #4
  112ee4:	e8bd8800 	pop	{fp, pc}

00112ee8 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  112ee8:	e92d4800 	push	{fp, lr}
  112eec:	e28db004 	add	fp, sp, #4
  112ef0:	e24dd018 	sub	sp, sp, #24
  112ef4:	e50b0010 	str	r0, [fp, #-16]
  112ef8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  112efc:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  int i;

  LWIP_UNUSED_ARG(domain); /* @todo: check this */

  /* create a netconn */
  switch (type) {
  112f00:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  112f04:	e3530002 	cmp	r3, #2
  112f08:	0a00000d 	beq	112f44 <lwip_socket+0x5c>
  112f0c:	e3530003 	cmp	r3, #3
  112f10:	0a000002 	beq	112f20 <lwip_socket+0x38>
  112f14:	e3530001 	cmp	r3, #1
  112f18:	0a000016 	beq	112f78 <lwip_socket+0x90>
  112f1c:	ea00001c 	b	112f94 <lwip_socket+0xac>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_RAW),
  112f20:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  112f24:	e6ef3073 	uxtb	r3, r3
  112f28:	e3032b84 	movw	r2, #15236	; 0x3b84
  112f2c:	e3402011 	movt	r2, #17
  112f30:	e1a01003 	mov	r1, r3
  112f34:	e3a00040 	mov	r0, #64	; 0x40
  112f38:	ebffe15b 	bl	10b4ac <netconn_new_with_proto_and_callback>
  112f3c:	e50b0008 	str	r0, [fp, #-8]
                                               (u8_t)protocol, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  112f40:	ea000019 	b	112fac <lwip_socket+0xc4>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain,
  112f44:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  112f48:	e3530088 	cmp	r3, #136	; 0x88
  112f4c:	1a000001 	bne	112f58 <lwip_socket+0x70>
  112f50:	e3a03021 	mov	r3, #33	; 0x21
  112f54:	ea000000 	b	112f5c <lwip_socket+0x74>
  112f58:	e3a03020 	mov	r3, #32
  112f5c:	e3032b84 	movw	r2, #15236	; 0x3b84
  112f60:	e3402011 	movt	r2, #17
  112f64:	e3a01000 	mov	r1, #0
  112f68:	e1a00003 	mov	r0, r3
  112f6c:	ebffe14e 	bl	10b4ac <netconn_new_with_proto_and_callback>
  112f70:	e50b0008 	str	r0, [fp, #-8]
                 ((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP)) ,
                 event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  112f74:	ea00000c 	b	112fac <lwip_socket+0xc4>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_TCP), event_callback);
  112f78:	e3032b84 	movw	r2, #15236	; 0x3b84
  112f7c:	e3402011 	movt	r2, #17
  112f80:	e3a01000 	mov	r1, #0
  112f84:	e3a00010 	mov	r0, #16
  112f88:	ebffe147 	bl	10b4ac <netconn_new_with_proto_and_callback>
  112f8c:	e50b0008 	str	r0, [fp, #-8]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  112f90:	ea000005 	b	112fac <lwip_socket+0xc4>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  112f94:	eb00984f 	bl	1390d8 <__errno_location>
  112f98:	e1a02000 	mov	r2, r0
  112f9c:	e3a03016 	mov	r3, #22
  112fa0:	e5823000 	str	r3, [r2]
    return -1;
  112fa4:	e3e03000 	mvn	r3, #0
  112fa8:	ea00001b 	b	11301c <lwip_socket+0x134>
  }

  if (!conn) {
  112fac:	e51b3008 	ldr	r3, [fp, #-8]
  112fb0:	e3530000 	cmp	r3, #0
  112fb4:	1a000005 	bne	112fd0 <lwip_socket+0xe8>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  112fb8:	eb009846 	bl	1390d8 <__errno_location>
  112fbc:	e1a02000 	mov	r2, r0
  112fc0:	e3a03069 	mov	r3, #105	; 0x69
  112fc4:	e5823000 	str	r3, [r2]
    return -1;
  112fc8:	e3e03000 	mvn	r3, #0
  112fcc:	ea000012 	b	11301c <lwip_socket+0x134>
  }

  i = alloc_socket(conn, 0);
  112fd0:	e3a01000 	mov	r1, #0
  112fd4:	e51b0008 	ldr	r0, [fp, #-8]
  112fd8:	ebfff8a1 	bl	111264 <alloc_socket>
  112fdc:	e50b000c 	str	r0, [fp, #-12]

  if (i == -1) {
  112fe0:	e51b300c 	ldr	r3, [fp, #-12]
  112fe4:	e3730001 	cmn	r3, #1
  112fe8:	1a000007 	bne	11300c <lwip_socket+0x124>
    netconn_delete(conn);
  112fec:	e51b0008 	ldr	r0, [fp, #-8]
  112ff0:	ebffe18f 	bl	10b634 <netconn_delete>
    set_errno(ENFILE);
  112ff4:	eb009837 	bl	1390d8 <__errno_location>
  112ff8:	e1a02000 	mov	r2, r0
  112ffc:	e3a03017 	mov	r3, #23
  113000:	e5823000 	str	r3, [r2]
    return -1;
  113004:	e3e03000 	mvn	r3, #0
  113008:	ea000003 	b	11301c <lwip_socket+0x134>
  }
  conn->socket = i;
  11300c:	e51b3008 	ldr	r3, [fp, #-8]
  113010:	e51b200c 	ldr	r2, [fp, #-12]
  113014:	e583201c 	str	r2, [r3, #28]
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
  113018:	e51b300c 	ldr	r3, [fp, #-12]
}
  11301c:	e1a00003 	mov	r0, r3
  113020:	e24bd004 	sub	sp, fp, #4
  113024:	e8bd8800 	pop	{fp, pc}

00113028 <lwip_write>:

int
lwip_write(int s, const void *data, size_t size)
{
  113028:	e92d4800 	push	{fp, lr}
  11302c:	e28db004 	add	fp, sp, #4
  113030:	e24dd010 	sub	sp, sp, #16
  113034:	e50b0008 	str	r0, [fp, #-8]
  113038:	e50b100c 	str	r1, [fp, #-12]
  11303c:	e50b2010 	str	r2, [fp, #-16]
  return lwip_send(s, data, size, 0);
  113040:	e3a03000 	mov	r3, #0
  113044:	e51b2010 	ldr	r2, [fp, #-16]
  113048:	e51b100c 	ldr	r1, [fp, #-12]
  11304c:	e51b0008 	ldr	r0, [fp, #-8]
  113050:	ebfffd40 	bl	112558 <lwip_send>
  113054:	e1a03000 	mov	r3, r0
}
  113058:	e1a00003 	mov	r0, r3
  11305c:	e24bd004 	sub	sp, fp, #4
  113060:	e8bd8800 	pop	{fp, pc}

00113064 <lwip_writev>:

int
lwip_writev(int s, const struct iovec *iov, int iovcnt)
{
  113064:	e92d4800 	push	{fp, lr}
  113068:	e28db004 	add	fp, sp, #4
  11306c:	e24dd030 	sub	sp, sp, #48	; 0x30
  113070:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  113074:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  113078:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  struct msghdr msg;

  msg.msg_name = NULL;
  11307c:	e3a03000 	mov	r3, #0
  113080:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  msg.msg_namelen = 0;
  113084:	e3a03000 	mov	r3, #0
  113088:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  /* Hack: we have to cast via number to cast from 'const' pointer to non-const.
     Blame the opengroup standard for this inconsistency. */
  msg.msg_iov = LWIP_CONST_CAST(struct iovec *, iov);
  11308c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  113090:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  msg.msg_iovlen = iovcnt;
  113094:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  113098:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  msg.msg_control = NULL;
  11309c:	e3a03000 	mov	r3, #0
  1130a0:	e50b3010 	str	r3, [fp, #-16]
  msg.msg_controllen = 0;
  1130a4:	e3a03000 	mov	r3, #0
  1130a8:	e50b300c 	str	r3, [fp, #-12]
  msg.msg_flags = 0;
  1130ac:	e3a03000 	mov	r3, #0
  1130b0:	e50b3008 	str	r3, [fp, #-8]
  return lwip_sendmsg(s, &msg, 0);
  1130b4:	e24b3020 	sub	r3, fp, #32
  1130b8:	e3a02000 	mov	r2, #0
  1130bc:	e1a01003 	mov	r1, r3
  1130c0:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  1130c4:	ebfffd77 	bl	1126a8 <lwip_sendmsg>
  1130c8:	e1a03000 	mov	r3, r0
}
  1130cc:	e1a00003 	mov	r0, r3
  1130d0:	e24bd004 	sub	sp, fp, #4
  1130d4:	e8bd8800 	pop	{fp, pc}

001130d8 <lwip_selscan>:
 * @return number of sockets that had events (read/write/exception) (>= 0)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
             fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
{
  1130d8:	e92d4800 	push	{fp, lr}
  1130dc:	e28db004 	add	fp, sp, #4
  1130e0:	e24ddd07 	sub	sp, sp, #448	; 0x1c0
  1130e4:	e50b01b8 	str	r0, [fp, #-440]	; 0xfffffe48
  1130e8:	e50b11bc 	str	r1, [fp, #-444]	; 0xfffffe44
  1130ec:	e50b21c0 	str	r2, [fp, #-448]	; 0xfffffe40
  1130f0:	e50b31c4 	str	r3, [fp, #-452]	; 0xfffffe3c
  int i, nready = 0;
  1130f4:	e3a03000 	mov	r3, #0
  1130f8:	e50b300c 	str	r3, [fp, #-12]
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_sock *sock;
  SYS_ARCH_DECL_PROTECT(lev);

  FD_ZERO(&lreadset);
  1130fc:	e24b30b4 	sub	r3, fp, #180	; 0xb4
  113100:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  113104:	e3a03020 	mov	r3, #32
  113108:	e50b3010 	str	r3, [fp, #-16]
  11310c:	ea000007 	b	113130 <lwip_selscan+0x58>
  113110:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113114:	e2832004 	add	r2, r3, #4
  113118:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
  11311c:	e3a02000 	mov	r2, #0
  113120:	e5832000 	str	r2, [r3]
  113124:	e51b3010 	ldr	r3, [fp, #-16]
  113128:	e2433001 	sub	r3, r3, #1
  11312c:	e50b3010 	str	r3, [fp, #-16]
  113130:	e51b3010 	ldr	r3, [fp, #-16]
  113134:	e3530000 	cmp	r3, #0
  113138:	1afffff4 	bne	113110 <lwip_selscan+0x38>
  FD_ZERO(&lwriteset);
  11313c:	e24b3f4d 	sub	r3, fp, #308	; 0x134
  113140:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  113144:	e3a03020 	mov	r3, #32
  113148:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  11314c:	ea000007 	b	113170 <lwip_selscan+0x98>
  113150:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  113154:	e2832004 	add	r2, r3, #4
  113158:	e50b201c 	str	r2, [fp, #-28]	; 0xffffffe4
  11315c:	e3a02000 	mov	r2, #0
  113160:	e5832000 	str	r2, [r3]
  113164:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113168:	e2433001 	sub	r3, r3, #1
  11316c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  113170:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113174:	e3530000 	cmp	r3, #0
  113178:	1afffff4 	bne	113150 <lwip_selscan+0x78>
  FD_ZERO(&lexceptset);
  11317c:	e24b3f6d 	sub	r3, fp, #436	; 0x1b4
  113180:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  113184:	e3a03020 	mov	r3, #32
  113188:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  11318c:	ea000007 	b	1131b0 <lwip_selscan+0xd8>
  113190:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  113194:	e2832004 	add	r2, r3, #4
  113198:	e50b2024 	str	r2, [fp, #-36]	; 0xffffffdc
  11319c:	e3a02000 	mov	r2, #0
  1131a0:	e5832000 	str	r2, [r3]
  1131a4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1131a8:	e2433001 	sub	r3, r3, #1
  1131ac:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  1131b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1131b4:	e3530000 	cmp	r3, #0
  1131b8:	1afffff4 	bne	113190 <lwip_selscan+0xb8>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
  1131bc:	e3a03000 	mov	r3, #0
  1131c0:	e50b3008 	str	r3, [fp, #-8]
  1131c4:	ea0000aa 	b	113474 <lwip_selscan+0x39c>
    /* if this FD is not in the set, continue */
    if (!(readset_in && FD_ISSET(i, readset_in)) &&
  1131c8:	e51b31bc 	ldr	r3, [fp, #-444]	; 0xfffffe44
  1131cc:	e3530000 	cmp	r3, #0
  1131d0:	0a000009 	beq	1131fc <lwip_selscan+0x124>
  1131d4:	e51b3008 	ldr	r3, [fp, #-8]
  1131d8:	e1a022a3 	lsr	r2, r3, #5
  1131dc:	e51b31bc 	ldr	r3, [fp, #-444]	; 0xfffffe44
  1131e0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  1131e4:	e51b3008 	ldr	r3, [fp, #-8]
  1131e8:	e203301f 	and	r3, r3, #31
  1131ec:	e1a03332 	lsr	r3, r2, r3
  1131f0:	e2033001 	and	r3, r3, #1
  1131f4:	e3530000 	cmp	r3, #0
  1131f8:	1a000019 	bne	113264 <lwip_selscan+0x18c>
  1131fc:	e51b31c0 	ldr	r3, [fp, #-448]	; 0xfffffe40
  113200:	e3530000 	cmp	r3, #0
  113204:	0a000009 	beq	113230 <lwip_selscan+0x158>
        !(writeset_in && FD_ISSET(i, writeset_in)) &&
  113208:	e51b3008 	ldr	r3, [fp, #-8]
  11320c:	e1a022a3 	lsr	r2, r3, #5
  113210:	e51b31c0 	ldr	r3, [fp, #-448]	; 0xfffffe40
  113214:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  113218:	e51b3008 	ldr	r3, [fp, #-8]
  11321c:	e203301f 	and	r3, r3, #31
  113220:	e1a03332 	lsr	r3, r2, r3
  113224:	e2033001 	and	r3, r3, #1
  113228:	e3530000 	cmp	r3, #0
  11322c:	1a00000c 	bne	113264 <lwip_selscan+0x18c>
  113230:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  113234:	e3530000 	cmp	r3, #0
  113238:	0a000089 	beq	113464 <lwip_selscan+0x38c>
        !(exceptset_in && FD_ISSET(i, exceptset_in))) {
  11323c:	e51b3008 	ldr	r3, [fp, #-8]
  113240:	e1a022a3 	lsr	r2, r3, #5
  113244:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  113248:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  11324c:	e51b3008 	ldr	r3, [fp, #-8]
  113250:	e203301f 	and	r3, r3, #31
  113254:	e1a03332 	lsr	r3, r2, r3
  113258:	e2033001 	and	r3, r3, #1
  11325c:	e3530000 	cmp	r3, #0
  113260:	0a00007f 	beq	113464 <lwip_selscan+0x38c>
      continue;
    }
    /* First get the socket's status (protected)... */
    SYS_ARCH_PROTECT(lev);
  113264:	ebffbbf4 	bl	10223c <rt_enter_critical>
    sock = tryget_socket(i);
  113268:	e51b0008 	ldr	r0, [fp, #-8]
  11326c:	ebfff7d1 	bl	1111b8 <tryget_socket>
  113270:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
    if (sock != NULL) {
  113274:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  113278:	e3530000 	cmp	r3, #0
  11327c:	0a000076 	beq	11345c <lwip_selscan+0x384>
      void* lastdata = sock->lastdata;
  113280:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  113284:	e5933004 	ldr	r3, [r3, #4]
  113288:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
      s16_t rcvevent = sock->rcvevent;
  11328c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  113290:	e1d330ba 	ldrh	r3, [r3, #10]
  113294:	e14b32be 	strh	r3, [fp, #-46]	; 0xffffffd2
      u16_t sendevent = sock->sendevent;
  113298:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11329c:	e1d330bc 	ldrh	r3, [r3, #12]
  1132a0:	e14b33b0 	strh	r3, [fp, #-48]	; 0xffffffd0
      u16_t errevent = sock->errevent;
  1132a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1132a8:	e1d330be 	ldrh	r3, [r3, #14]
  1132ac:	e14b33b2 	strh	r3, [fp, #-50]	; 0xffffffce
      SYS_ARCH_UNPROTECT(lev);
  1132b0:	ebffbbe7 	bl	102254 <rt_exit_critical>

      /* ... then examine it: */
      /* See if netconn of this socket is ready for read */
      if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
  1132b4:	e51b31bc 	ldr	r3, [fp, #-444]	; 0xfffffe44
  1132b8:	e3530000 	cmp	r3, #0
  1132bc:	0a000021 	beq	113348 <lwip_selscan+0x270>
  1132c0:	e51b3008 	ldr	r3, [fp, #-8]
  1132c4:	e1a022a3 	lsr	r2, r3, #5
  1132c8:	e51b31bc 	ldr	r3, [fp, #-444]	; 0xfffffe44
  1132cc:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  1132d0:	e51b3008 	ldr	r3, [fp, #-8]
  1132d4:	e203301f 	and	r3, r3, #31
  1132d8:	e1a03332 	lsr	r3, r2, r3
  1132dc:	e2033001 	and	r3, r3, #1
  1132e0:	e3530000 	cmp	r3, #0
  1132e4:	0a000017 	beq	113348 <lwip_selscan+0x270>
  1132e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1132ec:	e3530000 	cmp	r3, #0
  1132f0:	1a000002 	bne	113300 <lwip_selscan+0x228>
  1132f4:	e15b32fe 	ldrsh	r3, [fp, #-46]	; 0xffffffd2
  1132f8:	e3530000 	cmp	r3, #0
  1132fc:	da000011 	ble	113348 <lwip_selscan+0x270>
        FD_SET(i, &lreadset);
  113300:	e51b3008 	ldr	r3, [fp, #-8]
  113304:	e1a022a3 	lsr	r2, r3, #5
  113308:	e1a03102 	lsl	r3, r2, #2
  11330c:	e24b1004 	sub	r1, fp, #4
  113310:	e0813003 	add	r3, r1, r3
  113314:	e51310b0 	ldr	r1, [r3, #-176]	; 0xffffff50
  113318:	e51b3008 	ldr	r3, [fp, #-8]
  11331c:	e203301f 	and	r3, r3, #31
  113320:	e3a00001 	mov	r0, #1
  113324:	e1a03310 	lsl	r3, r0, r3
  113328:	e1811003 	orr	r1, r1, r3
  11332c:	e1a03102 	lsl	r3, r2, #2
  113330:	e24b2004 	sub	r2, fp, #4
  113334:	e0823003 	add	r3, r2, r3
  113338:	e50310b0 	str	r1, [r3, #-176]	; 0xffffff50
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  11333c:	e51b300c 	ldr	r3, [fp, #-12]
  113340:	e2833001 	add	r3, r3, #1
  113344:	e50b300c 	str	r3, [fp, #-12]
      }
      /* See if netconn of this socket is ready for write */
      if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
  113348:	e51b31c0 	ldr	r3, [fp, #-448]	; 0xfffffe40
  11334c:	e3530000 	cmp	r3, #0
  113350:	0a00001e 	beq	1133d0 <lwip_selscan+0x2f8>
  113354:	e51b3008 	ldr	r3, [fp, #-8]
  113358:	e1a022a3 	lsr	r2, r3, #5
  11335c:	e51b31c0 	ldr	r3, [fp, #-448]	; 0xfffffe40
  113360:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  113364:	e51b3008 	ldr	r3, [fp, #-8]
  113368:	e203301f 	and	r3, r3, #31
  11336c:	e1a03332 	lsr	r3, r2, r3
  113370:	e2033001 	and	r3, r3, #1
  113374:	e3530000 	cmp	r3, #0
  113378:	0a000014 	beq	1133d0 <lwip_selscan+0x2f8>
  11337c:	e15b33b0 	ldrh	r3, [fp, #-48]	; 0xffffffd0
  113380:	e3530000 	cmp	r3, #0
  113384:	0a000011 	beq	1133d0 <lwip_selscan+0x2f8>
        FD_SET(i, &lwriteset);
  113388:	e51b3008 	ldr	r3, [fp, #-8]
  11338c:	e1a022a3 	lsr	r2, r3, #5
  113390:	e1a03102 	lsl	r3, r2, #2
  113394:	e24b1004 	sub	r1, fp, #4
  113398:	e0813003 	add	r3, r1, r3
  11339c:	e5131130 	ldr	r1, [r3, #-304]	; 0xfffffed0
  1133a0:	e51b3008 	ldr	r3, [fp, #-8]
  1133a4:	e203301f 	and	r3, r3, #31
  1133a8:	e3a00001 	mov	r0, #1
  1133ac:	e1a03310 	lsl	r3, r0, r3
  1133b0:	e1811003 	orr	r1, r1, r3
  1133b4:	e1a03102 	lsl	r3, r2, #2
  1133b8:	e24b2004 	sub	r2, fp, #4
  1133bc:	e0823003 	add	r3, r2, r3
  1133c0:	e5031130 	str	r1, [r3, #-304]	; 0xfffffed0
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  1133c4:	e51b300c 	ldr	r3, [fp, #-12]
  1133c8:	e2833001 	add	r3, r3, #1
  1133cc:	e50b300c 	str	r3, [fp, #-12]
      }
      /* See if netconn of this socket had an error */
      if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
  1133d0:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  1133d4:	e3530000 	cmp	r3, #0
  1133d8:	0a000022 	beq	113468 <lwip_selscan+0x390>
  1133dc:	e51b3008 	ldr	r3, [fp, #-8]
  1133e0:	e1a022a3 	lsr	r2, r3, #5
  1133e4:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  1133e8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  1133ec:	e51b3008 	ldr	r3, [fp, #-8]
  1133f0:	e203301f 	and	r3, r3, #31
  1133f4:	e1a03332 	lsr	r3, r2, r3
  1133f8:	e2033001 	and	r3, r3, #1
  1133fc:	e3530000 	cmp	r3, #0
  113400:	0a000018 	beq	113468 <lwip_selscan+0x390>
  113404:	e15b33b2 	ldrh	r3, [fp, #-50]	; 0xffffffce
  113408:	e3530000 	cmp	r3, #0
  11340c:	0a000015 	beq	113468 <lwip_selscan+0x390>
        FD_SET(i, &lexceptset);
  113410:	e51b3008 	ldr	r3, [fp, #-8]
  113414:	e1a022a3 	lsr	r2, r3, #5
  113418:	e1a03102 	lsl	r3, r2, #2
  11341c:	e24b1004 	sub	r1, fp, #4
  113420:	e0813003 	add	r3, r1, r3
  113424:	e51311b0 	ldr	r1, [r3, #-432]	; 0xfffffe50
  113428:	e51b3008 	ldr	r3, [fp, #-8]
  11342c:	e203301f 	and	r3, r3, #31
  113430:	e3a00001 	mov	r0, #1
  113434:	e1a03310 	lsl	r3, r0, r3
  113438:	e1811003 	orr	r1, r1, r3
  11343c:	e1a03102 	lsl	r3, r2, #2
  113440:	e24b2004 	sub	r2, fp, #4
  113444:	e0823003 	add	r3, r2, r3
  113448:	e50311b0 	str	r1, [r3, #-432]	; 0xfffffe50
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
        nready++;
  11344c:	e51b300c 	ldr	r3, [fp, #-12]
  113450:	e2833001 	add	r3, r3, #1
  113454:	e50b300c 	str	r3, [fp, #-12]
  113458:	ea000002 	b	113468 <lwip_selscan+0x390>
      }
    } else {
      SYS_ARCH_UNPROTECT(lev);
  11345c:	ebffbb7c 	bl	102254 <rt_exit_critical>
  113460:	ea000000 	b	113468 <lwip_selscan+0x390>
      continue;
  113464:	e320f000 	nop	{0}
  for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
  113468:	e51b3008 	ldr	r3, [fp, #-8]
  11346c:	e2833001 	add	r3, r3, #1
  113470:	e50b3008 	str	r3, [fp, #-8]
  113474:	e51b2008 	ldr	r2, [fp, #-8]
  113478:	e51b31b8 	ldr	r3, [fp, #-440]	; 0xfffffe48
  11347c:	e1520003 	cmp	r2, r3
  113480:	baffff50 	blt	1131c8 <lwip_selscan+0xf0>
      /* continue on to next FD in list */
    }
  }
  /* copy local sets to the ones provided as arguments */
  *readset_out = lreadset;
  113484:	e59b3004 	ldr	r3, [fp, #4]
  113488:	e1a00003 	mov	r0, r3
  11348c:	e24b30b4 	sub	r3, fp, #180	; 0xb4
  113490:	e3a02080 	mov	r2, #128	; 0x80
  113494:	e1a01003 	mov	r1, r3
  113498:	eb00b6bd 	bl	140f94 <memcpy>
  *writeset_out = lwriteset;
  11349c:	e59b3008 	ldr	r3, [fp, #8]
  1134a0:	e1a00003 	mov	r0, r3
  1134a4:	e24b3f4d 	sub	r3, fp, #308	; 0x134
  1134a8:	e3a02080 	mov	r2, #128	; 0x80
  1134ac:	e1a01003 	mov	r1, r3
  1134b0:	eb00b6b7 	bl	140f94 <memcpy>
  *exceptset_out = lexceptset;
  1134b4:	e59b300c 	ldr	r3, [fp, #12]
  1134b8:	e1a00003 	mov	r0, r3
  1134bc:	e24b3f6d 	sub	r3, fp, #436	; 0x1b4
  1134c0:	e3a02080 	mov	r2, #128	; 0x80
  1134c4:	e1a01003 	mov	r1, r3
  1134c8:	eb00b6b1 	bl	140f94 <memcpy>

  LWIP_ASSERT("nready >= 0", nready >= 0);
  1134cc:	e51b300c 	ldr	r3, [fp, #-12]
  1134d0:	e3530000 	cmp	r3, #0
  1134d4:	aa000006 	bge	1134f4 <lwip_selscan+0x41c>
  1134d8:	e3070134 	movw	r0, #28980	; 0x7134
  1134dc:	e3400014 	movt	r0, #20
  1134e0:	ebffbf0b 	bl	103114 <rt_kprintf>
  1134e4:	e3001569 	movw	r1, #1385	; 0x569
  1134e8:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  1134ec:	e3400014 	movt	r0, #20
  1134f0:	ebffdee1 	bl	10b07c <sys_arch_assert>
  return nready;
  1134f4:	e51b300c 	ldr	r3, [fp, #-12]
}
  1134f8:	e1a00003 	mov	r0, r3
  1134fc:	e24bd004 	sub	sp, fp, #4
  113500:	e8bd8800 	pop	{fp, pc}

00113504 <lwip_select>:

int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
  113504:	e92d4800 	push	{fp, lr}
  113508:	e28db004 	add	fp, sp, #4
  11350c:	e24ddf76 	sub	sp, sp, #472	; 0x1d8
  113510:	e50b01c0 	str	r0, [fp, #-448]	; 0xfffffe40
  113514:	e50b11c4 	str	r1, [fp, #-452]	; 0xfffffe3c
  113518:	e50b21c8 	str	r2, [fp, #-456]	; 0xfffffe38
  11351c:	e50b31cc 	str	r3, [fp, #-460]	; 0xfffffe34
  u32_t waitres = 0;
  113520:	e3a03000 	mov	r3, #0
  113524:	e50b3008 	str	r3, [fp, #-8]
                  timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
                  timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
  113528:	e24b3e1a 	sub	r3, fp, #416	; 0x1a0
  11352c:	e58d3008 	str	r3, [sp, #8]
  113530:	e24b3e12 	sub	r3, fp, #288	; 0x120
  113534:	e58d3004 	str	r3, [sp, #4]
  113538:	e24b30a0 	sub	r3, fp, #160	; 0xa0
  11353c:	e58d3000 	str	r3, [sp]
  113540:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  113544:	e51b21c8 	ldr	r2, [fp, #-456]	; 0xfffffe38
  113548:	e51b11c4 	ldr	r1, [fp, #-452]	; 0xfffffe3c
  11354c:	e51b01c0 	ldr	r0, [fp, #-448]	; 0xfffffe40
  113550:	ebfffee0 	bl	1130d8 <lwip_selscan>
  113554:	e50b000c 	str	r0, [fp, #-12]

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  113558:	e51b300c 	ldr	r3, [fp, #-12]
  11355c:	e3530000 	cmp	r3, #0
  113560:	1a000163 	bne	113af4 <lwip_select+0x5f0>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  113564:	e59b3004 	ldr	r3, [fp, #4]
  113568:	e3530000 	cmp	r3, #0
  11356c:	0a000007 	beq	113590 <lwip_select+0x8c>
  113570:	e59b3004 	ldr	r3, [fp, #4]
  113574:	e1c320d0 	ldrd	r2, [r3]
  113578:	e1923003 	orrs	r3, r2, r3
  11357c:	1a000003 	bne	113590 <lwip_select+0x8c>
  113580:	e59b3004 	ldr	r3, [fp, #4]
  113584:	e5933008 	ldr	r3, [r3, #8]
  113588:	e3530000 	cmp	r3, #0
  11358c:	0a00015a 	beq	113afc <lwip_select+0x5f8>
    /* None ready: add our semaphore to list:
       We don't actually need any dynamic memory. Our entry on the
       list is only valid while we are in this function, so it's ok
       to use local variables. */

    select_cb.next = NULL;
  113590:	e3a03000 	mov	r3, #0
  113594:	e50b31bc 	str	r3, [fp, #-444]	; 0xfffffe44
    select_cb.prev = NULL;
  113598:	e3a03000 	mov	r3, #0
  11359c:	e50b31b8 	str	r3, [fp, #-440]	; 0xfffffe48
    select_cb.readset = readset;
  1135a0:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  1135a4:	e50b31b4 	str	r3, [fp, #-436]	; 0xfffffe4c
    select_cb.writeset = writeset;
  1135a8:	e51b31c8 	ldr	r3, [fp, #-456]	; 0xfffffe38
  1135ac:	e50b31b0 	str	r3, [fp, #-432]	; 0xfffffe50
    select_cb.exceptset = exceptset;
  1135b0:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  1135b4:	e50b31ac 	str	r3, [fp, #-428]	; 0xfffffe54
    select_cb.sem_signalled = 0;
  1135b8:	e3a03000 	mov	r3, #0
  1135bc:	e50b31a8 	str	r3, [fp, #-424]	; 0xfffffe58
#if LWIP_NETCONN_SEM_PER_THREAD
    select_cb.sem = LWIP_NETCONN_THREAD_SEM_GET();
#else /* LWIP_NETCONN_SEM_PER_THREAD */
    if (sys_sem_new(&select_cb.sem, 0) != ERR_OK) {
  1135c0:	e24b3f6f 	sub	r3, fp, #444	; 0x1bc
  1135c4:	e2833018 	add	r3, r3, #24
  1135c8:	e3a01000 	mov	r1, #0
  1135cc:	e1a00003 	mov	r0, r3
  1135d0:	ebffdc17 	bl	10a634 <sys_sem_new>
  1135d4:	e1a03000 	mov	r3, r0
  1135d8:	e3530000 	cmp	r3, #0
  1135dc:	0a000005 	beq	1135f8 <lwip_select+0xf4>
      /* failed to create semaphore */
      set_errno(ENOMEM);
  1135e0:	eb0096bc 	bl	1390d8 <__errno_location>
  1135e4:	e1a02000 	mov	r2, r0
  1135e8:	e3a0300c 	mov	r3, #12
  1135ec:	e5823000 	str	r3, [r2]
      return -1;
  1135f0:	e3e03000 	mvn	r3, #0
  1135f4:	ea00015f 	b	113b78 <lwip_select+0x674>
    }
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

    /* Protect the select_cb_list */
    SYS_ARCH_PROTECT(lev);
  1135f8:	ebffbb0f 	bl	10223c <rt_enter_critical>

    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  1135fc:	e30e3c20 	movw	r3, #60448	; 0xec20
  113600:	e3403014 	movt	r3, #20
  113604:	e5933000 	ldr	r3, [r3]
  113608:	e50b31bc 	str	r3, [fp, #-444]	; 0xfffffe44
    if (select_cb_list != NULL) {
  11360c:	e30e3c20 	movw	r3, #60448	; 0xec20
  113610:	e3403014 	movt	r3, #20
  113614:	e5933000 	ldr	r3, [r3]
  113618:	e3530000 	cmp	r3, #0
  11361c:	0a000004 	beq	113634 <lwip_select+0x130>
      select_cb_list->prev = &select_cb;
  113620:	e30e3c20 	movw	r3, #60448	; 0xec20
  113624:	e3403014 	movt	r3, #20
  113628:	e5933000 	ldr	r3, [r3]
  11362c:	e24b2f6f 	sub	r2, fp, #444	; 0x1bc
  113630:	e5832004 	str	r2, [r3, #4]
    }
    select_cb_list = &select_cb;
  113634:	e30e3c20 	movw	r3, #60448	; 0xec20
  113638:	e3403014 	movt	r3, #20
  11363c:	e24b2f6f 	sub	r2, fp, #444	; 0x1bc
  113640:	e5832000 	str	r2, [r3]
    /* Increasing this counter tells event_callback that the list has changed. */
    select_cb_ctr++;
  113644:	e30e3c24 	movw	r3, #60452	; 0xec24
  113648:	e3403014 	movt	r3, #20
  11364c:	e5933000 	ldr	r3, [r3]
  113650:	e2832001 	add	r2, r3, #1
  113654:	e30e3c24 	movw	r3, #60452	; 0xec24
  113658:	e3403014 	movt	r3, #20
  11365c:	e5832000 	str	r2, [r3]

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);
  113660:	ebffbafb 	bl	102254 <rt_exit_critical>

    /* Increase select_waiting for each socket we are interested in */
    maxfdp2 = maxfdp1;
  113664:	e51b31c0 	ldr	r3, [fp, #-448]	; 0xfffffe40
  113668:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
  11366c:	e3a03000 	mov	r3, #0
  113670:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  113674:	ea000049 	b	1137a0 <lwip_select+0x29c>
      if ((readset && FD_ISSET(i, readset)) ||
  113678:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  11367c:	e3530000 	cmp	r3, #0
  113680:	0a000009 	beq	1136ac <lwip_select+0x1a8>
  113684:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113688:	e1a022a3 	lsr	r2, r3, #5
  11368c:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  113690:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  113694:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113698:	e203301f 	and	r3, r3, #31
  11369c:	e1a03332 	lsr	r3, r2, r3
  1136a0:	e2033001 	and	r3, r3, #1
  1136a4:	e3530000 	cmp	r3, #0
  1136a8:	1a000019 	bne	113714 <lwip_select+0x210>
  1136ac:	e51b31c8 	ldr	r3, [fp, #-456]	; 0xfffffe38
  1136b0:	e3530000 	cmp	r3, #0
  1136b4:	0a000009 	beq	1136e0 <lwip_select+0x1dc>
          (writeset && FD_ISSET(i, writeset)) ||
  1136b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1136bc:	e1a022a3 	lsr	r2, r3, #5
  1136c0:	e51b31c8 	ldr	r3, [fp, #-456]	; 0xfffffe38
  1136c4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  1136c8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1136cc:	e203301f 	and	r3, r3, #31
  1136d0:	e1a03332 	lsr	r3, r2, r3
  1136d4:	e2033001 	and	r3, r3, #1
  1136d8:	e3530000 	cmp	r3, #0
  1136dc:	1a00000c 	bne	113714 <lwip_select+0x210>
  1136e0:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  1136e4:	e3530000 	cmp	r3, #0
  1136e8:	0a000029 	beq	113794 <lwip_select+0x290>
          (exceptset && FD_ISSET(i, exceptset))) {
  1136ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1136f0:	e1a022a3 	lsr	r2, r3, #5
  1136f4:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  1136f8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  1136fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113700:	e203301f 	and	r3, r3, #31
  113704:	e1a03332 	lsr	r3, r2, r3
  113708:	e2033001 	and	r3, r3, #1
  11370c:	e3530000 	cmp	r3, #0
  113710:	0a00001f 	beq	113794 <lwip_select+0x290>
        struct lwip_sock *sock;
        SYS_ARCH_PROTECT(lev);
  113714:	ebffbac8 	bl	10223c <rt_enter_critical>
        sock = tryget_socket(i);
  113718:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  11371c:	ebfff6a5 	bl	1111b8 <tryget_socket>
  113720:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
        if (sock != NULL) {
  113724:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  113728:	e3530000 	cmp	r3, #0
  11372c:	0a000011 	beq	113778 <lwip_select+0x274>
          sock->select_waiting++;
  113730:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  113734:	e5d33011 	ldrb	r3, [r3, #17]
  113738:	e2833001 	add	r3, r3, #1
  11373c:	e6ef2073 	uxtb	r2, r3
  113740:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  113744:	e5c32011 	strb	r2, [r3, #17]
          LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
  113748:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11374c:	e5d33011 	ldrb	r3, [r3, #17]
  113750:	e3530000 	cmp	r3, #0
  113754:	1a00000d 	bne	113790 <lwip_select+0x28c>
  113758:	e3070140 	movw	r0, #28992	; 0x7140
  11375c:	e3400014 	movt	r0, #20
  113760:	ebffbe6b 	bl	103114 <rt_kprintf>
  113764:	e30015be 	movw	r1, #1470	; 0x5be
  113768:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  11376c:	e3400014 	movt	r0, #20
  113770:	ebffde41 	bl	10b07c <sys_arch_assert>
  113774:	ea000005 	b	113790 <lwip_select+0x28c>
        } else {
          /* Not a valid socket */
          nready = -1;
  113778:	e3e03000 	mvn	r3, #0
  11377c:	e50b300c 	str	r3, [fp, #-12]
          maxfdp2 = i;
  113780:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113784:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
          SYS_ARCH_UNPROTECT(lev);
  113788:	ebffbab1 	bl	102254 <rt_exit_critical>
          break;
  11378c:	ea000007 	b	1137b0 <lwip_select+0x2ac>
        }
        SYS_ARCH_UNPROTECT(lev);
  113790:	ebffbaaf 	bl	102254 <rt_exit_critical>
    for (i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
  113794:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113798:	e2833001 	add	r3, r3, #1
  11379c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1137a0:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  1137a4:	e51b31c0 	ldr	r3, [fp, #-448]	; 0xfffffe40
  1137a8:	e1520003 	cmp	r2, r3
  1137ac:	baffffb1 	blt	113678 <lwip_select+0x174>
      }
    }

    if (nready >= 0) {
  1137b0:	e51b300c 	ldr	r3, [fp, #-12]
  1137b4:	e3530000 	cmp	r3, #0
  1137b8:	ba00002e 	blt	113878 <lwip_select+0x374>
      /* Call lwip_selscan again: there could have been events between
         the last scan (without us on the list) and putting us on the list! */
      nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
  1137bc:	e24b3e1a 	sub	r3, fp, #416	; 0x1a0
  1137c0:	e58d3008 	str	r3, [sp, #8]
  1137c4:	e24b3e12 	sub	r3, fp, #288	; 0x120
  1137c8:	e58d3004 	str	r3, [sp, #4]
  1137cc:	e24b30a0 	sub	r3, fp, #160	; 0xa0
  1137d0:	e58d3000 	str	r3, [sp]
  1137d4:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  1137d8:	e51b21c8 	ldr	r2, [fp, #-456]	; 0xfffffe38
  1137dc:	e51b11c4 	ldr	r1, [fp, #-452]	; 0xfffffe3c
  1137e0:	e51b01c0 	ldr	r0, [fp, #-448]	; 0xfffffe40
  1137e4:	ebfffe3b 	bl	1130d8 <lwip_selscan>
  1137e8:	e50b000c 	str	r0, [fp, #-12]
      if (!nready) {
  1137ec:	e51b300c 	ldr	r3, [fp, #-12]
  1137f0:	e3530000 	cmp	r3, #0
  1137f4:	1a00001f 	bne	113878 <lwip_select+0x374>
        /* Still none ready, just wait to be woken */
        if (timeout == 0) {
  1137f8:	e59b3004 	ldr	r3, [fp, #4]
  1137fc:	e3530000 	cmp	r3, #0
  113800:	1a000002 	bne	113810 <lwip_select+0x30c>
          /* Wait forever */
          msectimeout = 0;
  113804:	e3a03000 	mov	r3, #0
  113808:	e50b3010 	str	r3, [fp, #-16]
  11380c:	ea000013 	b	113860 <lwip_select+0x35c>
        } else {
          msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  113810:	e59b3004 	ldr	r3, [fp, #4]
  113814:	e1c320d0 	ldrd	r2, [r3]
  113818:	e3a03ffa 	mov	r3, #1000	; 0x3e8
  11381c:	e0000293 	mul	r0, r3, r2
  113820:	e59b3004 	ldr	r3, [fp, #4]
  113824:	e5933008 	ldr	r3, [r3, #8]
  113828:	e2831f7d 	add	r1, r3, #500	; 0x1f4
  11382c:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  113830:	e3413062 	movt	r3, #4194	; 0x1062
  113834:	e0c32391 	smull	r2, r3, r1, r3
  113838:	e1a02343 	asr	r2, r3, #6
  11383c:	e1a03fc1 	asr	r3, r1, #31
  113840:	e0423003 	sub	r3, r2, r3
  113844:	e0803003 	add	r3, r0, r3
  113848:	e50b3010 	str	r3, [fp, #-16]
          if (msectimeout == 0) {
  11384c:	e51b3010 	ldr	r3, [fp, #-16]
  113850:	e3530000 	cmp	r3, #0
  113854:	1a000001 	bne	113860 <lwip_select+0x35c>
            /* Wait 1ms at least (0 means wait forever) */
            msectimeout = 1;
  113858:	e3a03001 	mov	r3, #1
  11385c:	e50b3010 	str	r3, [fp, #-16]
          }
        }

        waitres = sys_arch_sem_wait(SELECT_SEM_PTR(select_cb.sem), msectimeout);
  113860:	e24b3f6f 	sub	r3, fp, #444	; 0x1bc
  113864:	e2833018 	add	r3, r3, #24
  113868:	e51b1010 	ldr	r1, [fp, #-16]
  11386c:	e1a00003 	mov	r0, r3
  113870:	ebffdbb0 	bl	10a738 <sys_arch_sem_wait>
  113874:	e50b0008 	str	r0, [fp, #-8]
#endif
      }
    }

    /* Decrease select_waiting for each socket we are interested in */
    for (i = LWIP_SOCKET_OFFSET; i < maxfdp2; i++) {
  113878:	e3a03000 	mov	r3, #0
  11387c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  113880:	ea000049 	b	1139ac <lwip_select+0x4a8>
      if ((readset && FD_ISSET(i, readset)) ||
  113884:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  113888:	e3530000 	cmp	r3, #0
  11388c:	0a000009 	beq	1138b8 <lwip_select+0x3b4>
  113890:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113894:	e1a022a3 	lsr	r2, r3, #5
  113898:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  11389c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  1138a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1138a4:	e203301f 	and	r3, r3, #31
  1138a8:	e1a03332 	lsr	r3, r2, r3
  1138ac:	e2033001 	and	r3, r3, #1
  1138b0:	e3530000 	cmp	r3, #0
  1138b4:	1a000019 	bne	113920 <lwip_select+0x41c>
  1138b8:	e51b31c8 	ldr	r3, [fp, #-456]	; 0xfffffe38
  1138bc:	e3530000 	cmp	r3, #0
  1138c0:	0a000009 	beq	1138ec <lwip_select+0x3e8>
          (writeset && FD_ISSET(i, writeset)) ||
  1138c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1138c8:	e1a022a3 	lsr	r2, r3, #5
  1138cc:	e51b31c8 	ldr	r3, [fp, #-456]	; 0xfffffe38
  1138d0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  1138d4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1138d8:	e203301f 	and	r3, r3, #31
  1138dc:	e1a03332 	lsr	r3, r2, r3
  1138e0:	e2033001 	and	r3, r3, #1
  1138e4:	e3530000 	cmp	r3, #0
  1138e8:	1a00000c 	bne	113920 <lwip_select+0x41c>
  1138ec:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  1138f0:	e3530000 	cmp	r3, #0
  1138f4:	0a000029 	beq	1139a0 <lwip_select+0x49c>
          (exceptset && FD_ISSET(i, exceptset))) {
  1138f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1138fc:	e1a022a3 	lsr	r2, r3, #5
  113900:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  113904:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  113908:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11390c:	e203301f 	and	r3, r3, #31
  113910:	e1a03332 	lsr	r3, r2, r3
  113914:	e2033001 	and	r3, r3, #1
  113918:	e3530000 	cmp	r3, #0
  11391c:	0a00001f 	beq	1139a0 <lwip_select+0x49c>
        struct lwip_sock *sock;
        SYS_ARCH_PROTECT(lev);
  113920:	ebffba45 	bl	10223c <rt_enter_critical>
        sock = tryget_socket(i);
  113924:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  113928:	ebfff622 	bl	1111b8 <tryget_socket>
  11392c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
        if (sock != NULL) {
  113930:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113934:	e3530000 	cmp	r3, #0
  113938:	0a000015 	beq	113994 <lwip_select+0x490>
          /* for now, handle select_waiting==0... */
          LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
  11393c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113940:	e5d33011 	ldrb	r3, [r3, #17]
  113944:	e3530000 	cmp	r3, #0
  113948:	1a000006 	bne	113968 <lwip_select+0x464>
  11394c:	e3070140 	movw	r0, #28992	; 0x7140
  113950:	e3400014 	movt	r0, #20
  113954:	ebffbdee 	bl	103114 <rt_kprintf>
  113958:	e30015ec 	movw	r1, #1516	; 0x5ec
  11395c:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  113960:	e3400014 	movt	r0, #20
  113964:	ebffddc4 	bl	10b07c <sys_arch_assert>
          if (sock->select_waiting > 0) {
  113968:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11396c:	e5d33011 	ldrb	r3, [r3, #17]
  113970:	e3530000 	cmp	r3, #0
  113974:	0a000008 	beq	11399c <lwip_select+0x498>
            sock->select_waiting--;
  113978:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11397c:	e5d33011 	ldrb	r3, [r3, #17]
  113980:	e2433001 	sub	r3, r3, #1
  113984:	e6ef2073 	uxtb	r2, r3
  113988:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11398c:	e5c32011 	strb	r2, [r3, #17]
  113990:	ea000001 	b	11399c <lwip_select+0x498>
          }
        } else {
          /* Not a valid socket */
          nready = -1;
  113994:	e3e03000 	mvn	r3, #0
  113998:	e50b300c 	str	r3, [fp, #-12]
        }
        SYS_ARCH_UNPROTECT(lev);
  11399c:	ebffba2c 	bl	102254 <rt_exit_critical>
    for (i = LWIP_SOCKET_OFFSET; i < maxfdp2; i++) {
  1139a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1139a4:	e2833001 	add	r3, r3, #1
  1139a8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1139ac:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  1139b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1139b4:	e1520003 	cmp	r2, r3
  1139b8:	baffffb1 	blt	113884 <lwip_select+0x380>
      }
    }
    /* Take us off the list */
    SYS_ARCH_PROTECT(lev);
  1139bc:	ebffba1e 	bl	10223c <rt_enter_critical>
    if (select_cb.next != NULL) {
  1139c0:	e51b31bc 	ldr	r3, [fp, #-444]	; 0xfffffe44
  1139c4:	e3530000 	cmp	r3, #0
  1139c8:	0a000002 	beq	1139d8 <lwip_select+0x4d4>
      select_cb.next->prev = select_cb.prev;
  1139cc:	e51b31bc 	ldr	r3, [fp, #-444]	; 0xfffffe44
  1139d0:	e51b21b8 	ldr	r2, [fp, #-440]	; 0xfffffe48
  1139d4:	e5832004 	str	r2, [r3, #4]
    }
    if (select_cb_list == &select_cb) {
  1139d8:	e30e3c20 	movw	r3, #60448	; 0xec20
  1139dc:	e3403014 	movt	r3, #20
  1139e0:	e5932000 	ldr	r2, [r3]
  1139e4:	e24b3f6f 	sub	r3, fp, #444	; 0x1bc
  1139e8:	e1520003 	cmp	r2, r3
  1139ec:	1a00000e 	bne	113a2c <lwip_select+0x528>
      LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
  1139f0:	e51b31b8 	ldr	r3, [fp, #-440]	; 0xfffffe48
  1139f4:	e3530000 	cmp	r3, #0
  1139f8:	0a000006 	beq	113a18 <lwip_select+0x514>
  1139fc:	e307015c 	movw	r0, #29020	; 0x715c
  113a00:	e3400014 	movt	r0, #20
  113a04:	ebffbdc2 	bl	103114 <rt_kprintf>
  113a08:	e30015fd 	movw	r1, #1533	; 0x5fd
  113a0c:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  113a10:	e3400014 	movt	r0, #20
  113a14:	ebffdd98 	bl	10b07c <sys_arch_assert>
      select_cb_list = select_cb.next;
  113a18:	e51b21bc 	ldr	r2, [fp, #-444]	; 0xfffffe44
  113a1c:	e30e3c20 	movw	r3, #60448	; 0xec20
  113a20:	e3403014 	movt	r3, #20
  113a24:	e5832000 	str	r2, [r3]
  113a28:	ea00000c 	b	113a60 <lwip_select+0x55c>
    } else {
      LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
  113a2c:	e51b31b8 	ldr	r3, [fp, #-440]	; 0xfffffe48
  113a30:	e3530000 	cmp	r3, #0
  113a34:	1a000006 	bne	113a54 <lwip_select+0x550>
  113a38:	e3070174 	movw	r0, #29044	; 0x7174
  113a3c:	e3400014 	movt	r0, #20
  113a40:	ebffbdb3 	bl	103114 <rt_kprintf>
  113a44:	e3a01c06 	mov	r1, #1536	; 0x600
  113a48:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  113a4c:	e3400014 	movt	r0, #20
  113a50:	ebffdd89 	bl	10b07c <sys_arch_assert>
      select_cb.prev->next = select_cb.next;
  113a54:	e51b31b8 	ldr	r3, [fp, #-440]	; 0xfffffe48
  113a58:	e51b21bc 	ldr	r2, [fp, #-444]	; 0xfffffe44
  113a5c:	e5832000 	str	r2, [r3]
    }
    /* Increasing this counter tells event_callback that the list has changed. */
    select_cb_ctr++;
  113a60:	e30e3c24 	movw	r3, #60452	; 0xec24
  113a64:	e3403014 	movt	r3, #20
  113a68:	e5933000 	ldr	r3, [r3]
  113a6c:	e2832001 	add	r2, r3, #1
  113a70:	e30e3c24 	movw	r3, #60452	; 0xec24
  113a74:	e3403014 	movt	r3, #20
  113a78:	e5832000 	str	r2, [r3]
    SYS_ARCH_UNPROTECT(lev);
  113a7c:	ebffb9f4 	bl	102254 <rt_exit_critical>
    if (select_cb.sem_signalled && (!waited || (waitres == SYS_ARCH_TIMEOUT))) {
      /* don't leave the thread-local semaphore signalled */
      sys_arch_sem_wait(select_cb.sem, 1);
    }
#else /* LWIP_NETCONN_SEM_PER_THREAD */
    sys_sem_free(&select_cb.sem);
  113a80:	e24b3f6f 	sub	r3, fp, #444	; 0x1bc
  113a84:	e2833018 	add	r3, r3, #24
  113a88:	e1a00003 	mov	r0, r3
  113a8c:	ebffdb13 	bl	10a6e0 <sys_sem_free>
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

    if (nready < 0) {
  113a90:	e51b300c 	ldr	r3, [fp, #-12]
  113a94:	e3530000 	cmp	r3, #0
  113a98:	aa000005 	bge	113ab4 <lwip_select+0x5b0>
      /* This happens when a socket got closed while waiting */
      set_errno(EBADF);
  113a9c:	eb00958d 	bl	1390d8 <__errno_location>
  113aa0:	e1a02000 	mov	r2, r0
  113aa4:	e3a03009 	mov	r3, #9
  113aa8:	e5823000 	str	r3, [r2]
      return -1;
  113aac:	e3e03000 	mvn	r3, #0
  113ab0:	ea000030 	b	113b78 <lwip_select+0x674>
    }

    if (waitres == SYS_ARCH_TIMEOUT) {
  113ab4:	e51b3008 	ldr	r3, [fp, #-8]
  113ab8:	e3730001 	cmn	r3, #1
  113abc:	0a000010 	beq	113b04 <lwip_select+0x600>
         or we would have returned earlier. */
      goto return_copy_fdsets;
    }

    /* See what's set */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
  113ac0:	e24b3e1a 	sub	r3, fp, #416	; 0x1a0
  113ac4:	e58d3008 	str	r3, [sp, #8]
  113ac8:	e24b3e12 	sub	r3, fp, #288	; 0x120
  113acc:	e58d3004 	str	r3, [sp, #4]
  113ad0:	e24b30a0 	sub	r3, fp, #160	; 0xa0
  113ad4:	e58d3000 	str	r3, [sp]
  113ad8:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  113adc:	e51b21c8 	ldr	r2, [fp, #-456]	; 0xfffffe38
  113ae0:	e51b11c4 	ldr	r1, [fp, #-452]	; 0xfffffe3c
  113ae4:	e51b01c0 	ldr	r0, [fp, #-448]	; 0xfffffe40
  113ae8:	ebfffd7a 	bl	1130d8 <lwip_selscan>
  113aec:	e50b000c 	str	r0, [fp, #-12]
  113af0:	ea000004 	b	113b08 <lwip_select+0x604>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
return_copy_fdsets:
  113af4:	e320f000 	nop	{0}
  113af8:	ea000002 	b	113b08 <lwip_select+0x604>
      goto return_copy_fdsets;
  113afc:	e320f000 	nop	{0}
  113b00:	ea000000 	b	113b08 <lwip_select+0x604>
      goto return_copy_fdsets;
  113b04:	e320f000 	nop	{0}
  set_errno(0);
  if (readset) {
  113b08:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  113b0c:	e3530000 	cmp	r3, #0
  113b10:	0a000005 	beq	113b2c <lwip_select+0x628>
    *readset = lreadset;
  113b14:	e51b31c4 	ldr	r3, [fp, #-452]	; 0xfffffe3c
  113b18:	e1a00003 	mov	r0, r3
  113b1c:	e24b30a0 	sub	r3, fp, #160	; 0xa0
  113b20:	e3a02080 	mov	r2, #128	; 0x80
  113b24:	e1a01003 	mov	r1, r3
  113b28:	eb00b519 	bl	140f94 <memcpy>
  }
  if (writeset) {
  113b2c:	e51b31c8 	ldr	r3, [fp, #-456]	; 0xfffffe38
  113b30:	e3530000 	cmp	r3, #0
  113b34:	0a000005 	beq	113b50 <lwip_select+0x64c>
    *writeset = lwriteset;
  113b38:	e51b31c8 	ldr	r3, [fp, #-456]	; 0xfffffe38
  113b3c:	e1a00003 	mov	r0, r3
  113b40:	e24b3e12 	sub	r3, fp, #288	; 0x120
  113b44:	e3a02080 	mov	r2, #128	; 0x80
  113b48:	e1a01003 	mov	r1, r3
  113b4c:	eb00b510 	bl	140f94 <memcpy>
  }
  if (exceptset) {
  113b50:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  113b54:	e3530000 	cmp	r3, #0
  113b58:	0a000005 	beq	113b74 <lwip_select+0x670>
    *exceptset = lexceptset;
  113b5c:	e51b31cc 	ldr	r3, [fp, #-460]	; 0xfffffe34
  113b60:	e1a00003 	mov	r0, r3
  113b64:	e24b3e1a 	sub	r3, fp, #416	; 0x1a0
  113b68:	e3a02080 	mov	r2, #128	; 0x80
  113b6c:	e1a01003 	mov	r1, r3
  113b70:	eb00b507 	bl	140f94 <memcpy>
  }
  return nready;
  113b74:	e51b300c 	ldr	r3, [fp, #-12]
}
  113b78:	e1a00003 	mov	r0, r3
  113b7c:	e24bd004 	sub	sp, fp, #4
  113b80:	e8bd8800 	pop	{fp, pc}

00113b84 <event_callback>:
#define POLLOUT    0x2
#define POLLERR    0x4
#define UNET_WAKEUP_REQUEST         45
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  113b84:	e92d4800 	push	{fp, lr}
  113b88:	e28db004 	add	fp, sp, #4
  113b8c:	e24dd028 	sub	sp, sp, #40	; 0x28
  113b90:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  113b94:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  113b98:	e1a03002 	mov	r3, r2
  113b9c:	e14b32b6 	strh	r3, [fp, #-38]	; 0xffffffda
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  113ba0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113ba4:	e3530000 	cmp	r3, #0
  113ba8:	0a0000e5 	beq	113f44 <event_callback+0x3c0>
    s = conn->socket;
  113bac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113bb0:	e593301c 	ldr	r3, [r3, #28]
  113bb4:	e50b3008 	str	r3, [fp, #-8]
    if (s < 0) {
  113bb8:	e51b3008 	ldr	r3, [fp, #-8]
  113bbc:	e3530000 	cmp	r3, #0
  113bc0:	aa000012 	bge	113c10 <event_callback+0x8c>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
  113bc4:	ebffb99c 	bl	10223c <rt_enter_critical>
      if (conn->socket < 0) {
  113bc8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113bcc:	e593301c 	ldr	r3, [r3, #28]
  113bd0:	e3530000 	cmp	r3, #0
  113bd4:	aa000009 	bge	113c00 <event_callback+0x7c>
        if (evt == NETCONN_EVT_RCVPLUS) {
  113bd8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  113bdc:	e3530000 	cmp	r3, #0
  113be0:	1a000004 	bne	113bf8 <event_callback+0x74>
          conn->socket--;
  113be4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113be8:	e593301c 	ldr	r3, [r3, #28]
  113bec:	e2432001 	sub	r2, r3, #1
  113bf0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113bf4:	e583201c 	str	r2, [r3, #28]
        }
        SYS_ARCH_UNPROTECT(lev);
  113bf8:	ebffb995 	bl	102254 <rt_exit_critical>
        return;
  113bfc:	ea0000d3 	b	113f50 <event_callback+0x3cc>
      }
      s = conn->socket;
  113c00:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113c04:	e593301c 	ldr	r3, [r3, #28]
  113c08:	e50b3008 	str	r3, [fp, #-8]
      SYS_ARCH_UNPROTECT(lev);
  113c0c:	ebffb990 	bl	102254 <rt_exit_critical>
    }

    sock = get_socket(s);
  113c10:	e51b0008 	ldr	r0, [fp, #-8]
  113c14:	ebfff542 	bl	111124 <get_socket>
  113c18:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    if (!sock) {
  113c1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113c20:	e3530000 	cmp	r3, #0
  113c24:	0a0000c8 	beq	113f4c <event_callback+0x3c8>
    }
  } else {
    return;
  }

  SYS_ARCH_PROTECT(lev);
  113c28:	ebffb983 	bl	10223c <rt_enter_critical>
  /* Set event as required */
  switch (evt) {
  113c2c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  113c30:	e3530004 	cmp	r3, #4
  113c34:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  113c38:	ea000022 	b	113cc8 <event_callback+0x144>
  113c3c:	00113c50 	.word	0x00113c50
  113c40:	00113c74 	.word	0x00113c74
  113c44:	00113c98 	.word	0x00113c98
  113c48:	00113ca8 	.word	0x00113ca8
  113c4c:	00113cb8 	.word	0x00113cb8
    case NETCONN_EVT_RCVPLUS:
      /* *RT-Thread* need to be notified in kernel */
      sock->rcvevent++;
  113c50:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113c54:	e1d330fa 	ldrsh	r3, [r3, #10]
  113c58:	e6ff3073 	uxth	r3, r3
  113c5c:	e2833001 	add	r3, r3, #1
  113c60:	e6ff3073 	uxth	r3, r3
  113c64:	e6bf2073 	sxth	r2, r3
  113c68:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113c6c:	e1c320ba 	strh	r2, [r3, #10]
      break;
  113c70:	ea00001c 	b	113ce8 <event_callback+0x164>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  113c74:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113c78:	e1d330fa 	ldrsh	r3, [r3, #10]
  113c7c:	e6ff3073 	uxth	r3, r3
  113c80:	e2433001 	sub	r3, r3, #1
  113c84:	e6ff3073 	uxth	r3, r3
  113c88:	e6bf2073 	sxth	r2, r3
  113c8c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113c90:	e1c320ba 	strh	r2, [r3, #10]
      break;
  113c94:	ea000013 	b	113ce8 <event_callback+0x164>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  113c98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113c9c:	e3a02001 	mov	r2, #1
  113ca0:	e1c320bc 	strh	r2, [r3, #12]
      break;
  113ca4:	ea00000f 	b	113ce8 <event_callback+0x164>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  113ca8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113cac:	e3a02000 	mov	r2, #0
  113cb0:	e1c320bc 	strh	r2, [r3, #12]
      break;
  113cb4:	ea00000b 	b	113ce8 <event_callback+0x164>
    case NETCONN_EVT_ERROR:
      sock->errevent = 1;
  113cb8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113cbc:	e3a02001 	mov	r2, #1
  113cc0:	e1c320be 	strh	r2, [r3, #14]
      break;
  113cc4:	ea000007 	b	113ce8 <event_callback+0x164>
    default:
      LWIP_ASSERT("unknown event", 0);
  113cc8:	e307018c 	movw	r0, #29068	; 0x718c
  113ccc:	e3400014 	movt	r0, #20
  113cd0:	ebffbd0f 	bl	103114 <rt_kprintf>
  113cd4:	e3001679 	movw	r1, #1657	; 0x679
  113cd8:	e3060f8c 	movw	r0, #28556	; 0x6f8c
  113cdc:	e3400014 	movt	r0, #20
  113ce0:	ebffdce5 	bl	10b07c <sys_arch_assert>
      break;
  113ce4:	e320f000 	nop	{0}
  }

  int mask = 0;
  113ce8:	e3a03000 	mov	r3, #0
  113cec:	e50b3010 	str	r3, [fp, #-16]
  if (sock != NULL)
  113cf0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113cf4:	e3530000 	cmp	r3, #0
  113cf8:	0a00001b 	beq	113d6c <event_callback+0x1e8>
  {
#if LWIP_VERSION >= 0x20100ff
      if ((void*)(sock->lastdata.pbuf) || sock->rcvevent)
#else
      if ((void *)(sock->lastdata) || sock->rcvevent)
  113cfc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113d00:	e5933004 	ldr	r3, [r3, #4]
  113d04:	e3530000 	cmp	r3, #0
  113d08:	1a000003 	bne	113d1c <event_callback+0x198>
  113d0c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113d10:	e1d330fa 	ldrsh	r3, [r3, #10]
  113d14:	e3530000 	cmp	r3, #0
  113d18:	0a000002 	beq	113d28 <event_callback+0x1a4>
#endif
      {
          mask |= POLLIN;
  113d1c:	e51b3010 	ldr	r3, [fp, #-16]
  113d20:	e3833001 	orr	r3, r3, #1
  113d24:	e50b3010 	str	r3, [fp, #-16]
      }
      if (sock->sendevent)
  113d28:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113d2c:	e1d330bc 	ldrh	r3, [r3, #12]
  113d30:	e3530000 	cmp	r3, #0
  113d34:	0a000002 	beq	113d44 <event_callback+0x1c0>
      {
          mask |= POLLOUT;
  113d38:	e51b3010 	ldr	r3, [fp, #-16]
  113d3c:	e3833002 	orr	r3, r3, #2
  113d40:	e50b3010 	str	r3, [fp, #-16]
      }
      if (sock->errevent)
  113d44:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113d48:	e1d330be 	ldrh	r3, [r3, #14]
  113d4c:	e3530000 	cmp	r3, #0
  113d50:	0a000005 	beq	113d6c <event_callback+0x1e8>
      {
          mask |= POLLERR;
  113d54:	e51b3010 	ldr	r3, [fp, #-16]
  113d58:	e3833004 	orr	r3, r3, #4
  113d5c:	e50b3010 	str	r3, [fp, #-16]
          /* clean error event */
          sock->errevent = 0;
  113d60:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113d64:	e3a02000 	mov	r2, #0
  113d68:	e1c320be 	strh	r2, [r3, #14]
  //     {
  //       rt_kprintf("create msg error\n");
  //     }
  // }

  if (sock->select_waiting == 0) {
  113d6c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113d70:	e5d33011 	ldrb	r3, [r3, #17]
  113d74:	e3530000 	cmp	r3, #0
  113d78:	1a000001 	bne	113d84 <event_callback+0x200>
    /* noone is waiting for this socket, no need to check select_cb_list */
    SYS_ARCH_UNPROTECT(lev);
  113d7c:	ebffb934 	bl	102254 <rt_exit_critical>
    return;
  113d80:	ea000072 	b	113f50 <event_callback+0x3cc>
  /* NOTE: This code goes through the select_cb_list list multiple times
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  113d84:	e320f000 	nop	{0}
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
  113d88:	e30e3c20 	movw	r3, #60448	; 0xec20
  113d8c:	e3403014 	movt	r3, #20
  113d90:	e5933000 	ldr	r3, [r3]
  113d94:	e50b300c 	str	r3, [fp, #-12]
  113d98:	ea000064 	b	113f30 <event_callback+0x3ac>
    /* remember the state of select_cb_list to detect changes */
    last_select_cb_ctr = select_cb_ctr;
  113d9c:	e30e3c24 	movw	r3, #60452	; 0xec24
  113da0:	e3403014 	movt	r3, #20
  113da4:	e5933000 	ldr	r3, [r3]
  113da8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    if (scb->sem_signalled == 0) {
  113dac:	e51b300c 	ldr	r3, [fp, #-12]
  113db0:	e5933014 	ldr	r3, [r3, #20]
  113db4:	e3530000 	cmp	r3, #0
  113db8:	1a000050 	bne	113f00 <event_callback+0x37c>
      /* semaphore not signalled yet */
      int do_signal = 0;
  113dbc:	e3a03000 	mov	r3, #0
  113dc0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      /* Test this select call for our socket */
      if (sock->rcvevent > 0) {
  113dc4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113dc8:	e1d330fa 	ldrsh	r3, [r3, #10]
  113dcc:	e3530000 	cmp	r3, #0
  113dd0:	da000010 	ble	113e18 <event_callback+0x294>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
  113dd4:	e51b300c 	ldr	r3, [fp, #-12]
  113dd8:	e5933008 	ldr	r3, [r3, #8]
  113ddc:	e3530000 	cmp	r3, #0
  113de0:	0a00000c 	beq	113e18 <event_callback+0x294>
  113de4:	e51b300c 	ldr	r3, [fp, #-12]
  113de8:	e5933008 	ldr	r3, [r3, #8]
  113dec:	e51b2008 	ldr	r2, [fp, #-8]
  113df0:	e1a022a2 	lsr	r2, r2, #5
  113df4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  113df8:	e51b3008 	ldr	r3, [fp, #-8]
  113dfc:	e203301f 	and	r3, r3, #31
  113e00:	e1a03332 	lsr	r3, r2, r3
  113e04:	e2033001 	and	r3, r3, #1
  113e08:	e3530000 	cmp	r3, #0
  113e0c:	0a000001 	beq	113e18 <event_callback+0x294>
          do_signal = 1;
  113e10:	e3a03001 	mov	r3, #1
  113e14:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        }
      }
      if (sock->sendevent != 0) {
  113e18:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113e1c:	e1d330bc 	ldrh	r3, [r3, #12]
  113e20:	e3530000 	cmp	r3, #0
  113e24:	0a000013 	beq	113e78 <event_callback+0x2f4>
        if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
  113e28:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113e2c:	e3530000 	cmp	r3, #0
  113e30:	1a000010 	bne	113e78 <event_callback+0x2f4>
  113e34:	e51b300c 	ldr	r3, [fp, #-12]
  113e38:	e593300c 	ldr	r3, [r3, #12]
  113e3c:	e3530000 	cmp	r3, #0
  113e40:	0a00000c 	beq	113e78 <event_callback+0x2f4>
  113e44:	e51b300c 	ldr	r3, [fp, #-12]
  113e48:	e593300c 	ldr	r3, [r3, #12]
  113e4c:	e51b2008 	ldr	r2, [fp, #-8]
  113e50:	e1a022a2 	lsr	r2, r2, #5
  113e54:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  113e58:	e51b3008 	ldr	r3, [fp, #-8]
  113e5c:	e203301f 	and	r3, r3, #31
  113e60:	e1a03332 	lsr	r3, r2, r3
  113e64:	e2033001 	and	r3, r3, #1
  113e68:	e3530000 	cmp	r3, #0
  113e6c:	0a000001 	beq	113e78 <event_callback+0x2f4>
          do_signal = 1;
  113e70:	e3a03001 	mov	r3, #1
  113e74:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        }
      }
      if (sock->errevent != 0) {
  113e78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  113e7c:	e1d330be 	ldrh	r3, [r3, #14]
  113e80:	e3530000 	cmp	r3, #0
  113e84:	0a000013 	beq	113ed8 <event_callback+0x354>
        if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
  113e88:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113e8c:	e3530000 	cmp	r3, #0
  113e90:	1a000010 	bne	113ed8 <event_callback+0x354>
  113e94:	e51b300c 	ldr	r3, [fp, #-12]
  113e98:	e5933010 	ldr	r3, [r3, #16]
  113e9c:	e3530000 	cmp	r3, #0
  113ea0:	0a00000c 	beq	113ed8 <event_callback+0x354>
  113ea4:	e51b300c 	ldr	r3, [fp, #-12]
  113ea8:	e5933010 	ldr	r3, [r3, #16]
  113eac:	e51b2008 	ldr	r2, [fp, #-8]
  113eb0:	e1a022a2 	lsr	r2, r2, #5
  113eb4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  113eb8:	e51b3008 	ldr	r3, [fp, #-8]
  113ebc:	e203301f 	and	r3, r3, #31
  113ec0:	e1a03332 	lsr	r3, r2, r3
  113ec4:	e2033001 	and	r3, r3, #1
  113ec8:	e3530000 	cmp	r3, #0
  113ecc:	0a000001 	beq	113ed8 <event_callback+0x354>
          do_signal = 1;
  113ed0:	e3a03001 	mov	r3, #1
  113ed4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        }
      }
      if (do_signal) {
  113ed8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  113edc:	e3530000 	cmp	r3, #0
  113ee0:	0a000006 	beq	113f00 <event_callback+0x37c>
        scb->sem_signalled = 1;
  113ee4:	e51b300c 	ldr	r3, [fp, #-12]
  113ee8:	e3a02001 	mov	r2, #1
  113eec:	e5832014 	str	r2, [r3, #20]
        /* Don't call SYS_ARCH_UNPROTECT() before signaling the semaphore, as this might
           lead to the select thread taking itself off the list, invalidating the semaphore. */
        sys_sem_signal(SELECT_SEM_PTR(scb->sem));
  113ef0:	e51b300c 	ldr	r3, [fp, #-12]
  113ef4:	e2833018 	add	r3, r3, #24
  113ef8:	e1a00003 	mov	r0, r3
  113efc:	ebffda02 	bl	10a70c <sys_sem_signal>
      }
    }
    /* unlock interrupts with each step */
    SYS_ARCH_UNPROTECT(lev);
  113f00:	ebffb8d3 	bl	102254 <rt_exit_critical>
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
  113f04:	ebffb8cc 	bl	10223c <rt_enter_critical>
    if (last_select_cb_ctr != select_cb_ctr) {
  113f08:	e30e3c24 	movw	r3, #60452	; 0xec24
  113f0c:	e3403014 	movt	r3, #20
  113f10:	e5933000 	ldr	r3, [r3]
  113f14:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  113f18:	e1520003 	cmp	r2, r3
  113f1c:	0a000000 	beq	113f24 <event_callback+0x3a0>
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
  113f20:	eaffff98 	b	113d88 <event_callback+0x204>
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
  113f24:	e51b300c 	ldr	r3, [fp, #-12]
  113f28:	e5933000 	ldr	r3, [r3]
  113f2c:	e50b300c 	str	r3, [fp, #-12]
  113f30:	e51b300c 	ldr	r3, [fp, #-12]
  113f34:	e3530000 	cmp	r3, #0
  113f38:	1affff97 	bne	113d9c <event_callback+0x218>
    }
  }
  SYS_ARCH_UNPROTECT(lev);
  113f3c:	ebffb8c4 	bl	102254 <rt_exit_critical>
  113f40:	ea000002 	b	113f50 <event_callback+0x3cc>
    return;
  113f44:	e320f000 	nop	{0}
  113f48:	ea000000 	b	113f50 <event_callback+0x3cc>
      return;
  113f4c:	e320f000 	nop	{0}
}
  113f50:	e24bd004 	sub	sp, fp, #4
  113f54:	e8bd8800 	pop	{fp, pc}

00113f58 <lwip_shutdown>:
/**
 * Close one end of a full-duplex connection.
 */
int
lwip_shutdown(int s, int how)
{
  113f58:	e92d4800 	push	{fp, lr}
  113f5c:	e28db004 	add	fp, sp, #4
  113f60:	e24dd028 	sub	sp, sp, #40	; 0x28
  113f64:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  113f68:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  struct lwip_sock *sock;
  err_t err;
  u8_t shut_rx = 0, shut_tx = 0;
  113f6c:	e3a03000 	mov	r3, #0
  113f70:	e54b3005 	strb	r3, [fp, #-5]
  113f74:	e3a03000 	mov	r3, #0
  113f78:	e54b3006 	strb	r3, [fp, #-6]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));

  sock = get_socket(s);
  113f7c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  113f80:	ebfff467 	bl	111124 <get_socket>
  113f84:	e50b000c 	str	r0, [fp, #-12]
  if (!sock) {
  113f88:	e51b300c 	ldr	r3, [fp, #-12]
  113f8c:	e3530000 	cmp	r3, #0
  113f90:	1a000001 	bne	113f9c <lwip_shutdown+0x44>
    return -1;
  113f94:	e3e03000 	mvn	r3, #0
  113f98:	ea000067 	b	11413c <lwip_shutdown+0x1e4>
  }

  if (sock->conn != NULL) {
  113f9c:	e51b300c 	ldr	r3, [fp, #-12]
  113fa0:	e5933000 	ldr	r3, [r3]
  113fa4:	e3530000 	cmp	r3, #0
  113fa8:	0a000014 	beq	114000 <lwip_shutdown+0xa8>
    if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
  113fac:	e51b300c 	ldr	r3, [fp, #-12]
  113fb0:	e5933000 	ldr	r3, [r3]
  113fb4:	e5933000 	ldr	r3, [r3]
  113fb8:	e20330f0 	and	r3, r3, #240	; 0xf0
  113fbc:	e3530010 	cmp	r3, #16
  113fc0:	0a00001d 	beq	11403c <lwip_shutdown+0xe4>
      sock_set_errno(sock, EOPNOTSUPP);
  113fc4:	e3a0305f 	mov	r3, #95	; 0x5f
  113fc8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  113fcc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113fd0:	e6ef2073 	uxtb	r2, r3
  113fd4:	e51b300c 	ldr	r3, [fp, #-12]
  113fd8:	e5c32010 	strb	r2, [r3, #16]
  113fdc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113fe0:	e3530000 	cmp	r3, #0
  113fe4:	0a000003 	beq	113ff8 <lwip_shutdown+0xa0>
  113fe8:	eb00943a 	bl	1390d8 <__errno_location>
  113fec:	e1a02000 	mov	r2, r0
  113ff0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  113ff4:	e5823000 	str	r3, [r2]
      return -1;
  113ff8:	e3e03000 	mvn	r3, #0
  113ffc:	ea00004e 	b	11413c <lwip_shutdown+0x1e4>
    }
  } else {
    sock_set_errno(sock, ENOTCONN);
  114000:	e3a0306b 	mov	r3, #107	; 0x6b
  114004:	e50b3010 	str	r3, [fp, #-16]
  114008:	e51b3010 	ldr	r3, [fp, #-16]
  11400c:	e6ef2073 	uxtb	r2, r3
  114010:	e51b300c 	ldr	r3, [fp, #-12]
  114014:	e5c32010 	strb	r2, [r3, #16]
  114018:	e51b3010 	ldr	r3, [fp, #-16]
  11401c:	e3530000 	cmp	r3, #0
  114020:	0a000003 	beq	114034 <lwip_shutdown+0xdc>
  114024:	eb00942b 	bl	1390d8 <__errno_location>
  114028:	e1a02000 	mov	r2, r0
  11402c:	e51b3010 	ldr	r3, [fp, #-16]
  114030:	e5823000 	str	r3, [r2]
    return -1;
  114034:	e3e03000 	mvn	r3, #0
  114038:	ea00003f 	b	11413c <lwip_shutdown+0x1e4>
  }

  if (how == SHUT_RD) {
  11403c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114040:	e3530000 	cmp	r3, #0
  114044:	1a000002 	bne	114054 <lwip_shutdown+0xfc>
    shut_rx = 1;
  114048:	e3a03001 	mov	r3, #1
  11404c:	e54b3005 	strb	r3, [fp, #-5]
  114050:	ea00001c 	b	1140c8 <lwip_shutdown+0x170>
  } else if (how == SHUT_WR) {
  114054:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114058:	e3530001 	cmp	r3, #1
  11405c:	1a000002 	bne	11406c <lwip_shutdown+0x114>
    shut_tx = 1;
  114060:	e3a03001 	mov	r3, #1
  114064:	e54b3006 	strb	r3, [fp, #-6]
  114068:	ea000016 	b	1140c8 <lwip_shutdown+0x170>
  } else if (how == SHUT_RDWR) {
  11406c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114070:	e3530002 	cmp	r3, #2
  114074:	1a000004 	bne	11408c <lwip_shutdown+0x134>
    shut_rx = 1;
  114078:	e3a03001 	mov	r3, #1
  11407c:	e54b3005 	strb	r3, [fp, #-5]
    shut_tx = 1;
  114080:	e3a03001 	mov	r3, #1
  114084:	e54b3006 	strb	r3, [fp, #-6]
  114088:	ea00000e 	b	1140c8 <lwip_shutdown+0x170>
  } else {
    sock_set_errno(sock, EINVAL);
  11408c:	e3a03016 	mov	r3, #22
  114090:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  114094:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  114098:	e6ef2073 	uxtb	r2, r3
  11409c:	e51b300c 	ldr	r3, [fp, #-12]
  1140a0:	e5c32010 	strb	r2, [r3, #16]
  1140a4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1140a8:	e3530000 	cmp	r3, #0
  1140ac:	0a000003 	beq	1140c0 <lwip_shutdown+0x168>
  1140b0:	eb009408 	bl	1390d8 <__errno_location>
  1140b4:	e1a02000 	mov	r2, r0
  1140b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1140bc:	e5823000 	str	r3, [r2]
    return -1;
  1140c0:	e3e03000 	mvn	r3, #0
  1140c4:	ea00001c 	b	11413c <lwip_shutdown+0x1e4>
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
  1140c8:	e51b300c 	ldr	r3, [fp, #-12]
  1140cc:	e5933000 	ldr	r3, [r3]
  1140d0:	e55b2006 	ldrb	r2, [fp, #-6]
  1140d4:	e55b1005 	ldrb	r1, [fp, #-5]
  1140d8:	e1a00003 	mov	r0, r3
  1140dc:	ebffe0c3 	bl	10c3f0 <netconn_shutdown>
  1140e0:	e1a03000 	mov	r3, r0
  1140e4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb

  sock_set_errno(sock, err_to_errno(err));
  1140e8:	e15b31d5 	ldrsb	r3, [fp, #-21]	; 0xffffffeb
  1140ec:	e1a00003 	mov	r0, r3
  1140f0:	ebffefe3 	bl	110084 <err_to_errno>
  1140f4:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
  1140f8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1140fc:	e6ef2073 	uxtb	r2, r3
  114100:	e51b300c 	ldr	r3, [fp, #-12]
  114104:	e5c32010 	strb	r2, [r3, #16]
  114108:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11410c:	e3530000 	cmp	r3, #0
  114110:	0a000003 	beq	114124 <lwip_shutdown+0x1cc>
  114114:	eb0093ef 	bl	1390d8 <__errno_location>
  114118:	e1a02000 	mov	r2, r0
  11411c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  114120:	e5823000 	str	r3, [r2]
  return (err == ERR_OK ? 0 : -1);
  114124:	e15b31d5 	ldrsb	r3, [fp, #-21]	; 0xffffffeb
  114128:	e3530000 	cmp	r3, #0
  11412c:	1a000001 	bne	114138 <lwip_shutdown+0x1e0>
  114130:	e3a03000 	mov	r3, #0
  114134:	ea000000 	b	11413c <lwip_shutdown+0x1e4>
  114138:	e3e03000 	mvn	r3, #0
}
  11413c:	e1a00003 	mov	r0, r3
  114140:	e24bd004 	sub	sp, fp, #4
  114144:	e8bd8800 	pop	{fp, pc}

00114148 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  114148:	e92d4810 	push	{r4, fp, lr}
  11414c:	e28db008 	add	fp, sp, #8
  114150:	e24dd03c 	sub	sp, sp, #60	; 0x3c
  114154:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
  114158:	e50b103c 	str	r1, [fp, #-60]	; 0xffffffc4
  11415c:	e50b2040 	str	r2, [fp, #-64]	; 0xffffffc0
  114160:	e54b3041 	strb	r3, [fp, #-65]	; 0xffffffbf
  union sockaddr_aligned saddr;
  ip_addr_t naddr;
  u16_t port;
  err_t err;

  sock = get_socket(s);
  114164:	e51b0038 	ldr	r0, [fp, #-56]	; 0xffffffc8
  114168:	ebfff3ed 	bl	111124 <get_socket>
  11416c:	e50b0010 	str	r0, [fp, #-16]
  if (!sock) {
  114170:	e51b3010 	ldr	r3, [fp, #-16]
  114174:	e3530000 	cmp	r3, #0
  114178:	1a000001 	bne	114184 <lwip_getaddrname+0x3c>
    return -1;
  11417c:	e3e03000 	mvn	r3, #0
  114180:	ea00004d 	b	1142bc <lwip_getaddrname+0x174>
  }

  /* get the IP address and port */
  err = netconn_getaddr(sock->conn, &naddr, &port, local);
  114184:	e51b3010 	ldr	r3, [fp, #-16]
  114188:	e5930000 	ldr	r0, [r3]
  11418c:	e55b3041 	ldrb	r3, [fp, #-65]	; 0xffffffbf
  114190:	e24b2032 	sub	r2, fp, #50	; 0x32
  114194:	e24b1030 	sub	r1, fp, #48	; 0x30
  114198:	ebffdd45 	bl	10b6b4 <netconn_getaddr>
  11419c:	e1a03000 	mov	r3, r0
  1141a0:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  if (err != ERR_OK) {
  1141a4:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  1141a8:	e3530000 	cmp	r3, #0
  1141ac:	0a000010 	beq	1141f4 <lwip_getaddrname+0xac>
    sock_set_errno(sock, err_to_errno(err));
  1141b0:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  1141b4:	e1a00003 	mov	r0, r3
  1141b8:	ebffefb1 	bl	110084 <err_to_errno>
  1141bc:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
  1141c0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1141c4:	e6ef2073 	uxtb	r2, r3
  1141c8:	e51b3010 	ldr	r3, [fp, #-16]
  1141cc:	e5c32010 	strb	r2, [r3, #16]
  1141d0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1141d4:	e3530000 	cmp	r3, #0
  1141d8:	0a000003 	beq	1141ec <lwip_getaddrname+0xa4>
  1141dc:	eb0093bd 	bl	1390d8 <__errno_location>
  1141e0:	e1a02000 	mov	r2, r0
  1141e4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1141e8:	e5823000 	str	r3, [r2]
    return -1;
  1141ec:	e3e03000 	mvn	r3, #0
  1141f0:	ea000031 	b	1142bc <lwip_getaddrname+0x174>
    ip4_2_ipv4_mapped_ipv6(ip_2_ip6(&naddr), ip_2_ip4(&naddr));
    IP_SET_TYPE_VAL(naddr, IPADDR_TYPE_V6);
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

  IPADDR_PORT_TO_SOCKADDR(&saddr, &naddr, port);
  1141f4:	e24b302c 	sub	r3, fp, #44	; 0x2c
  1141f8:	e3a02010 	mov	r2, #16
  1141fc:	e5c32000 	strb	r2, [r3]
  114200:	e24b302c 	sub	r3, fp, #44	; 0x2c
  114204:	e3a02002 	mov	r2, #2
  114208:	e5c32001 	strb	r2, [r3, #1]
  11420c:	e15b33b2 	ldrh	r3, [fp, #-50]	; 0xffffffce
  114210:	e24b402c 	sub	r4, fp, #44	; 0x2c
  114214:	e1a00003 	mov	r0, r3
  114218:	eb00096e 	bl	1167d8 <lwip_htons>
  11421c:	e1a03000 	mov	r3, r0
  114220:	e1c430b2 	strh	r3, [r4, #2]
  114224:	e24b302c 	sub	r3, fp, #44	; 0x2c
  114228:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  11422c:	e5832004 	str	r2, [r3, #4]
  114230:	e24b302c 	sub	r3, fp, #44	; 0x2c
  114234:	e2833008 	add	r3, r3, #8
  114238:	e3a02008 	mov	r2, #8
  11423c:	e3a01000 	mov	r1, #0
  114240:	e1a00003 	mov	r0, r3
  114244:	eb00b48a 	bl	141474 <memset>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print_val(SOCKETS_DEBUG, naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", port));

  if (*namelen > saddr.sa.sa_len) {
  114248:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  11424c:	e5933000 	ldr	r3, [r3]
  114250:	e55b202c 	ldrb	r2, [fp, #-44]	; 0xffffffd4
  114254:	e1530002 	cmp	r3, r2
  114258:	9a000003 	bls	11426c <lwip_getaddrname+0x124>
    *namelen = saddr.sa.sa_len;
  11425c:	e55b302c 	ldrb	r3, [fp, #-44]	; 0xffffffd4
  114260:	e1a02003 	mov	r2, r3
  114264:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  114268:	e5832000 	str	r2, [r3]
  }
  MEMCPY(name, &saddr, *namelen);
  11426c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  114270:	e5932000 	ldr	r2, [r3]
  114274:	e24b302c 	sub	r3, fp, #44	; 0x2c
  114278:	e1a01003 	mov	r1, r3
  11427c:	e51b003c 	ldr	r0, [fp, #-60]	; 0xffffffc4
  114280:	eb00b343 	bl	140f94 <memcpy>

  sock_set_errno(sock, 0);
  114284:	e3a03000 	mov	r3, #0
  114288:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  11428c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  114290:	e6ef2073 	uxtb	r2, r3
  114294:	e51b3010 	ldr	r3, [fp, #-16]
  114298:	e5c32010 	strb	r2, [r3, #16]
  11429c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1142a0:	e3530000 	cmp	r3, #0
  1142a4:	0a000003 	beq	1142b8 <lwip_getaddrname+0x170>
  1142a8:	eb00938a 	bl	1390d8 <__errno_location>
  1142ac:	e1a02000 	mov	r2, r0
  1142b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1142b4:	e5823000 	str	r3, [r2]
  return 0;
  1142b8:	e3a03000 	mov	r3, #0
}
  1142bc:	e1a00003 	mov	r0, r3
  1142c0:	e24bd008 	sub	sp, fp, #8
  1142c4:	e8bd8810 	pop	{r4, fp, pc}

001142c8 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  1142c8:	e92d4800 	push	{fp, lr}
  1142cc:	e28db004 	add	fp, sp, #4
  1142d0:	e24dd010 	sub	sp, sp, #16
  1142d4:	e50b0008 	str	r0, [fp, #-8]
  1142d8:	e50b100c 	str	r1, [fp, #-12]
  1142dc:	e50b2010 	str	r2, [fp, #-16]
  return lwip_getaddrname(s, name, namelen, 0);
  1142e0:	e3a03000 	mov	r3, #0
  1142e4:	e51b2010 	ldr	r2, [fp, #-16]
  1142e8:	e51b100c 	ldr	r1, [fp, #-12]
  1142ec:	e51b0008 	ldr	r0, [fp, #-8]
  1142f0:	ebffff94 	bl	114148 <lwip_getaddrname>
  1142f4:	e1a03000 	mov	r3, r0
}
  1142f8:	e1a00003 	mov	r0, r3
  1142fc:	e24bd004 	sub	sp, fp, #4
  114300:	e8bd8800 	pop	{fp, pc}

00114304 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  114304:	e92d4800 	push	{fp, lr}
  114308:	e28db004 	add	fp, sp, #4
  11430c:	e24dd010 	sub	sp, sp, #16
  114310:	e50b0008 	str	r0, [fp, #-8]
  114314:	e50b100c 	str	r1, [fp, #-12]
  114318:	e50b2010 	str	r2, [fp, #-16]
  return lwip_getaddrname(s, name, namelen, 1);
  11431c:	e3a03001 	mov	r3, #1
  114320:	e51b2010 	ldr	r2, [fp, #-16]
  114324:	e51b100c 	ldr	r1, [fp, #-12]
  114328:	e51b0008 	ldr	r0, [fp, #-8]
  11432c:	ebffff85 	bl	114148 <lwip_getaddrname>
  114330:	e1a03000 	mov	r3, r0
}
  114334:	e1a00003 	mov	r0, r3
  114338:	e24bd004 	sub	sp, fp, #4
  11433c:	e8bd8800 	pop	{fp, pc}

00114340 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  114340:	e92d4800 	push	{fp, lr}
  114344:	e28db004 	add	fp, sp, #4
  114348:	e24dd028 	sub	sp, sp, #40	; 0x28
  11434c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  114350:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  114354:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  114358:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  u8_t err;
  struct lwip_sock *sock = get_socket(s);
  11435c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  114360:	ebfff36f 	bl	111124 <get_socket>
  114364:	e50b0008 	str	r0, [fp, #-8]
#if !LWIP_TCPIP_CORE_LOCKING
  LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
#endif /* !LWIP_TCPIP_CORE_LOCKING */

  if (!sock) {
  114368:	e51b3008 	ldr	r3, [fp, #-8]
  11436c:	e3530000 	cmp	r3, #0
  114370:	1a000001 	bne	11437c <lwip_getsockopt+0x3c>
    return -1;
  114374:	e3e03000 	mvn	r3, #0
  114378:	ea000036 	b	114458 <lwip_getsockopt+0x118>
  }

  if ((NULL == optval) || (NULL == optlen)) {
  11437c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  114380:	e3530000 	cmp	r3, #0
  114384:	0a000002 	beq	114394 <lwip_getsockopt+0x54>
  114388:	e59b3004 	ldr	r3, [fp, #4]
  11438c:	e3530000 	cmp	r3, #0
  114390:	1a00000e 	bne	1143d0 <lwip_getsockopt+0x90>
    sock_set_errno(sock, EFAULT);
  114394:	e3a0300e 	mov	r3, #14
  114398:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  11439c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1143a0:	e6ef2073 	uxtb	r2, r3
  1143a4:	e51b3008 	ldr	r3, [fp, #-8]
  1143a8:	e5c32010 	strb	r2, [r3, #16]
  1143ac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1143b0:	e3530000 	cmp	r3, #0
  1143b4:	0a000003 	beq	1143c8 <lwip_getsockopt+0x88>
  1143b8:	eb009346 	bl	1390d8 <__errno_location>
  1143bc:	e1a02000 	mov	r2, r0
  1143c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1143c4:	e5823000 	str	r3, [r2]
    return -1;
  1143c8:	e3e03000 	mvn	r3, #0
  1143cc:	ea000021 	b	114458 <lwip_getsockopt+0x118>
  }

#if LWIP_TCPIP_CORE_LOCKING
  /* core-locking can just call the -impl function */
  LOCK_TCPIP_CORE();
  1143d0:	e30005e4 	movw	r0, #1508	; 0x5e4
  1143d4:	e3400015 	movt	r0, #21
  1143d8:	ebffd946 	bl	10a8f8 <sys_mutex_lock>
  err = lwip_getsockopt_impl(s, level, optname, optval, optlen);
  1143dc:	e59b3004 	ldr	r3, [fp, #4]
  1143e0:	e58d3000 	str	r3, [sp]
  1143e4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1143e8:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1143ec:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  1143f0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1143f4:	eb00001a 	bl	114464 <lwip_getsockopt_impl>
  1143f8:	e1a03000 	mov	r3, r0
  1143fc:	e54b3009 	strb	r3, [fp, #-9]
  UNLOCK_TCPIP_CORE();
  114400:	e30005e4 	movw	r0, #1508	; 0x5e4
  114404:	e3400015 	movt	r0, #21
  114408:	ebffd946 	bl	10a928 <sys_mutex_unlock>
  /* maybe lwip_getsockopt_internal has changed err */
  err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
  LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sock_set_errno(sock, err);
  11440c:	e55b3009 	ldrb	r3, [fp, #-9]
  114410:	e50b3010 	str	r3, [fp, #-16]
  114414:	e51b3010 	ldr	r3, [fp, #-16]
  114418:	e6ef2073 	uxtb	r2, r3
  11441c:	e51b3008 	ldr	r3, [fp, #-8]
  114420:	e5c32010 	strb	r2, [r3, #16]
  114424:	e51b3010 	ldr	r3, [fp, #-16]
  114428:	e3530000 	cmp	r3, #0
  11442c:	0a000003 	beq	114440 <lwip_getsockopt+0x100>
  114430:	eb009328 	bl	1390d8 <__errno_location>
  114434:	e1a02000 	mov	r2, r0
  114438:	e51b3010 	ldr	r3, [fp, #-16]
  11443c:	e5823000 	str	r3, [r2]
  return err ? -1 : 0;
  114440:	e55b3009 	ldrb	r3, [fp, #-9]
  114444:	e3530000 	cmp	r3, #0
  114448:	0a000001 	beq	114454 <lwip_getsockopt+0x114>
  11444c:	e3e03000 	mvn	r3, #0
  114450:	ea000000 	b	114458 <lwip_getsockopt+0x118>
  114454:	e3a03000 	mov	r3, #0
}
  114458:	e1a00003 	mov	r0, r3
  11445c:	e24bd004 	sub	sp, fp, #4
  114460:	e8bd8800 	pop	{fp, pc}

00114464 <lwip_getsockopt_impl>:
/** lwip_getsockopt_impl: the actual implementation of getsockopt:
 * same argument as lwip_getsockopt, either called directly or through callback
 */
static u8_t
lwip_getsockopt_impl(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  114464:	e92d4800 	push	{fp, lr}
  114468:	e28db004 	add	fp, sp, #4
  11446c:	e24dd028 	sub	sp, sp, #40	; 0x28
  114470:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  114474:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  114478:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  11447c:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
  u8_t err = 0;
  114480:	e3a03000 	mov	r3, #0
  114484:	e54b3005 	strb	r3, [fp, #-5]
  struct lwip_sock *sock = tryget_socket(s);
  114488:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  11448c:	ebfff349 	bl	1111b8 <tryget_socket>
  114490:	e50b000c 	str	r0, [fp, #-12]
  if (!sock) {
  114494:	e51b300c 	ldr	r3, [fp, #-12]
  114498:	e3530000 	cmp	r3, #0
  11449c:	1a000001 	bne	1144a8 <lwip_getsockopt_impl+0x44>
    return EBADF;
  1144a0:	e3a03009 	mov	r3, #9
  1144a4:	ea00026a 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  }

  switch (level) {
  1144a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1144ac:	e3530006 	cmp	r3, #6
  1144b0:	0a0001fb 	beq	114ca4 <lwip_getsockopt_impl+0x840>
  1144b4:	e3530006 	cmp	r3, #6
  1144b8:	ca000002 	bgt	1144c8 <lwip_getsockopt_impl+0x64>
  1144bc:	e3530000 	cmp	r3, #0
  1144c0:	0a000155 	beq	114a1c <lwip_getsockopt_impl+0x5b8>
  1144c4:	ea00025e 	b	114e44 <lwip_getsockopt_impl+0x9e0>
  1144c8:	e35300ff 	cmp	r3, #255	; 0xff
  1144cc:	0a000258 	beq	114e34 <lwip_getsockopt_impl+0x9d0>
  1144d0:	e3002fff 	movw	r2, #4095	; 0xfff
  1144d4:	e1530002 	cmp	r3, r2
  1144d8:	1a000259 	bne	114e44 <lwip_getsockopt_impl+0x9e0>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  1144dc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1144e0:	e3012002 	movw	r2, #4098	; 0x1002
  1144e4:	e1530002 	cmp	r3, r2
  1144e8:	0a000114 	beq	114940 <lwip_getsockopt_impl+0x4dc>
  1144ec:	e3012002 	movw	r2, #4098	; 0x1002
  1144f0:	e1530002 	cmp	r3, r2
  1144f4:	ca00000b 	bgt	114528 <lwip_getsockopt_impl+0xc4>
  1144f8:	e3530004 	cmp	r3, #4
  1144fc:	0a000049 	beq	114628 <lwip_getsockopt_impl+0x1c4>
  114500:	e3530004 	cmp	r3, #4
  114504:	ca000002 	bgt	114514 <lwip_getsockopt_impl+0xb0>
  114508:	e3530002 	cmp	r3, #2
  11450c:	0a000019 	beq	114578 <lwip_getsockopt_impl+0x114>
  114510:	ea00013d 	b	114a0c <lwip_getsockopt_impl+0x5a8>
  114514:	e3530008 	cmp	r3, #8
  114518:	0a000042 	beq	114628 <lwip_getsockopt_impl+0x1c4>
  11451c:	e3530020 	cmp	r3, #32
  114520:	0a000040 	beq	114628 <lwip_getsockopt_impl+0x1c4>
  114524:	ea000138 	b	114a0c <lwip_getsockopt_impl+0x5a8>
  114528:	e3012007 	movw	r2, #4103	; 0x1007
  11452c:	e1530002 	cmp	r3, r2
  114530:	0a000082 	beq	114740 <lwip_getsockopt_impl+0x2dc>
  114534:	e3012007 	movw	r2, #4103	; 0x1007
  114538:	e1530002 	cmp	r3, r2
  11453c:	ca000006 	bgt	11455c <lwip_getsockopt_impl+0xf8>
  114540:	e3012005 	movw	r2, #4101	; 0x1005
  114544:	e1530002 	cmp	r3, r2
  114548:	0a0000ae 	beq	114808 <lwip_getsockopt_impl+0x3a4>
  11454c:	e3012006 	movw	r2, #4102	; 0x1006
  114550:	e1530002 	cmp	r3, r2
  114554:	0a0000d2 	beq	1148a4 <lwip_getsockopt_impl+0x440>
  114558:	ea00012b 	b	114a0c <lwip_getsockopt_impl+0x5a8>
  11455c:	e3012008 	movw	r2, #4104	; 0x1008
  114560:	e1530002 	cmp	r3, r2
  114564:	0a00004a 	beq	114694 <lwip_getsockopt_impl+0x230>
  114568:	e301200a 	movw	r2, #4106	; 0x100a
  11456c:	e1530002 	cmp	r3, r2
  114570:	0a000104 	beq	114988 <lwip_getsockopt_impl+0x524>
  114574:	ea000124 	b	114a0c <lwip_getsockopt_impl+0x5a8>

#if LWIP_TCP
    case SO_ACCEPTCONN:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
  114578:	e59b3004 	ldr	r3, [fp, #4]
  11457c:	e5933000 	ldr	r3, [r3]
  114580:	e3530003 	cmp	r3, #3
  114584:	8a000001 	bhi	114590 <lwip_getsockopt_impl+0x12c>
  114588:	e3a03016 	mov	r3, #22
  11458c:	ea000230 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114590:	e51b300c 	ldr	r3, [fp, #-12]
  114594:	e5933000 	ldr	r3, [r3]
  114598:	e3530000 	cmp	r3, #0
  11459c:	0a000004 	beq	1145b4 <lwip_getsockopt_impl+0x150>
  1145a0:	e51b300c 	ldr	r3, [fp, #-12]
  1145a4:	e5933000 	ldr	r3, [r3]
  1145a8:	e5933008 	ldr	r3, [r3, #8]
  1145ac:	e3530000 	cmp	r3, #0
  1145b0:	1a000001 	bne	1145bc <lwip_getsockopt_impl+0x158>
  1145b4:	e3a03016 	mov	r3, #22
  1145b8:	ea000225 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_TCP) {
  1145bc:	e51b300c 	ldr	r3, [fp, #-12]
  1145c0:	e5933000 	ldr	r3, [r3]
  1145c4:	e5933000 	ldr	r3, [r3]
  1145c8:	e20330f0 	and	r3, r3, #240	; 0xf0
  1145cc:	e3530010 	cmp	r3, #16
  1145d0:	0a000001 	beq	1145dc <lwip_getsockopt_impl+0x178>
        return ENOPROTOOPT;
  1145d4:	e3a0305c 	mov	r3, #92	; 0x5c
  1145d8:	ea00021d 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      }
      if ((sock->conn->pcb.tcp != NULL) && (sock->conn->pcb.tcp->state == LISTEN)) {
  1145dc:	e51b300c 	ldr	r3, [fp, #-12]
  1145e0:	e5933000 	ldr	r3, [r3]
  1145e4:	e5933008 	ldr	r3, [r3, #8]
  1145e8:	e3530000 	cmp	r3, #0
  1145ec:	0a000009 	beq	114618 <lwip_getsockopt_impl+0x1b4>
  1145f0:	e51b300c 	ldr	r3, [fp, #-12]
  1145f4:	e5933000 	ldr	r3, [r3]
  1145f8:	e5933008 	ldr	r3, [r3, #8]
  1145fc:	e5933014 	ldr	r3, [r3, #20]
  114600:	e3530001 	cmp	r3, #1
  114604:	1a000003 	bne	114618 <lwip_getsockopt_impl+0x1b4>
        *(int*)optval = 1;
  114608:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11460c:	e3a02001 	mov	r2, #1
  114610:	e5832000 	str	r2, [r3]
      } else {
        *(int*)optval = 0;
      }
      break;
  114614:	ea0000ff 	b	114a18 <lwip_getsockopt_impl+0x5b4>
        *(int*)optval = 0;
  114618:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11461c:	e3a02000 	mov	r2, #0
  114620:	e5832000 	str	r2, [r3]
      break;
  114624:	ea0000fb 	b	114a18 <lwip_getsockopt_impl+0x5b4>
    case SO_BROADCAST:
    case SO_KEEPALIVE:
#if SO_REUSE
    case SO_REUSEADDR:
#endif /* SO_REUSE */
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
  114628:	e59b3004 	ldr	r3, [fp, #4]
  11462c:	e5933000 	ldr	r3, [r3]
  114630:	e3530003 	cmp	r3, #3
  114634:	8a000001 	bhi	114640 <lwip_getsockopt_impl+0x1dc>
  114638:	e3a03016 	mov	r3, #22
  11463c:	ea000204 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114640:	e51b300c 	ldr	r3, [fp, #-12]
  114644:	e5933000 	ldr	r3, [r3]
  114648:	e3530000 	cmp	r3, #0
  11464c:	0a000004 	beq	114664 <lwip_getsockopt_impl+0x200>
  114650:	e51b300c 	ldr	r3, [fp, #-12]
  114654:	e5933000 	ldr	r3, [r3]
  114658:	e5933008 	ldr	r3, [r3, #8]
  11465c:	e3530000 	cmp	r3, #0
  114660:	1a000001 	bne	11466c <lwip_getsockopt_impl+0x208>
  114664:	e3a03016 	mov	r3, #22
  114668:	ea0001f9 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      *(int*)optval = ip_get_option(sock->conn->pcb.ip, optname);
  11466c:	e51b300c 	ldr	r3, [fp, #-12]
  114670:	e5933000 	ldr	r3, [r3]
  114674:	e5933008 	ldr	r3, [r3, #8]
  114678:	e5d33008 	ldrb	r3, [r3, #8]
  11467c:	e1a02003 	mov	r2, r3
  114680:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  114684:	e0022003 	and	r2, r2, r3
  114688:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11468c:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  114690:	ea0000e0 	b	114a18 <lwip_getsockopt_impl+0x5b4>

    case SO_TYPE:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, int);
  114694:	e59b3004 	ldr	r3, [fp, #4]
  114698:	e5933000 	ldr	r3, [r3]
  11469c:	e3530003 	cmp	r3, #3
  1146a0:	8a000001 	bhi	1146ac <lwip_getsockopt_impl+0x248>
  1146a4:	e3a03016 	mov	r3, #22
  1146a8:	ea0001e9 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  1146ac:	e51b300c 	ldr	r3, [fp, #-12]
  1146b0:	e5933000 	ldr	r3, [r3]
  1146b4:	e3530000 	cmp	r3, #0
  1146b8:	1a000001 	bne	1146c4 <lwip_getsockopt_impl+0x260>
  1146bc:	e3a03016 	mov	r3, #22
  1146c0:	ea0001e3 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      switch (NETCONNTYPE_GROUP(netconn_type(sock->conn))) {
  1146c4:	e51b300c 	ldr	r3, [fp, #-12]
  1146c8:	e5933000 	ldr	r3, [r3]
  1146cc:	e5933000 	ldr	r3, [r3]
  1146d0:	e20330f0 	and	r3, r3, #240	; 0xf0
  1146d4:	e3530020 	cmp	r3, #32
  1146d8:	0a00000c 	beq	114710 <lwip_getsockopt_impl+0x2ac>
  1146dc:	e3530040 	cmp	r3, #64	; 0x40
  1146e0:	0a000002 	beq	1146f0 <lwip_getsockopt_impl+0x28c>
  1146e4:	e3530010 	cmp	r3, #16
  1146e8:	0a000004 	beq	114700 <lwip_getsockopt_impl+0x29c>
  1146ec:	ea00000b 	b	114720 <lwip_getsockopt_impl+0x2bc>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  1146f0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1146f4:	e3a02003 	mov	r2, #3
  1146f8:	e5832000 	str	r2, [r3]
        break;
  1146fc:	ea00000e 	b	11473c <lwip_getsockopt_impl+0x2d8>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  114700:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114704:	e3a02001 	mov	r2, #1
  114708:	e5832000 	str	r2, [r3]
        break;
  11470c:	ea00000a 	b	11473c <lwip_getsockopt_impl+0x2d8>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  114710:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114714:	e3a02002 	mov	r2, #2
  114718:	e5832000 	str	r2, [r3]
        break;
  11471c:	ea000006 	b	11473c <lwip_getsockopt_impl+0x2d8>
      default: /* unrecognized socket type */
        *(int*)optval = netconn_type(sock->conn);
  114720:	e51b300c 	ldr	r3, [fp, #-12]
  114724:	e5933000 	ldr	r3, [r3]
  114728:	e5933000 	ldr	r3, [r3]
  11472c:	e1a02003 	mov	r2, r3
  114730:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114734:	e5832000 	str	r2, [r3]
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (netconn_type(sock->conn)) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
  114738:	ea0000b6 	b	114a18 <lwip_getsockopt_impl+0x5b4>
  11473c:	ea0000b5 	b	114a18 <lwip_getsockopt_impl+0x5b4>

    case SO_ERROR:
      LWIP_SOCKOPT_CHECK_OPTLEN(*optlen, int);
  114740:	e59b3004 	ldr	r3, [fp, #4]
  114744:	e5933000 	ldr	r3, [r3]
  114748:	e3530003 	cmp	r3, #3
  11474c:	8a000001 	bhi	114758 <lwip_getsockopt_impl+0x2f4>
  114750:	e3a03016 	mov	r3, #22
  114754:	ea0001be 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      /* only overwrite ERR_OK or temporary errors */
      if (((sock->err == 0) || (sock->err == EINPROGRESS)) && (sock->conn != NULL)) {
  114758:	e51b300c 	ldr	r3, [fp, #-12]
  11475c:	e5d33010 	ldrb	r3, [r3, #16]
  114760:	e3530000 	cmp	r3, #0
  114764:	0a000003 	beq	114778 <lwip_getsockopt_impl+0x314>
  114768:	e51b300c 	ldr	r3, [fp, #-12]
  11476c:	e5d33010 	ldrb	r3, [r3, #16]
  114770:	e3530073 	cmp	r3, #115	; 0x73
  114774:	1a000014 	bne	1147cc <lwip_getsockopt_impl+0x368>
  114778:	e51b300c 	ldr	r3, [fp, #-12]
  11477c:	e5933000 	ldr	r3, [r3]
  114780:	e3530000 	cmp	r3, #0
  114784:	0a000010 	beq	1147cc <lwip_getsockopt_impl+0x368>
        sock_set_errno(sock, err_to_errno(sock->conn->last_err));
  114788:	e51b300c 	ldr	r3, [fp, #-12]
  11478c:	e5933000 	ldr	r3, [r3]
  114790:	e1d330dc 	ldrsb	r3, [r3, #12]
  114794:	e1a00003 	mov	r0, r3
  114798:	ebffee39 	bl	110084 <err_to_errno>
  11479c:	e50b0010 	str	r0, [fp, #-16]
  1147a0:	e51b3010 	ldr	r3, [fp, #-16]
  1147a4:	e6ef2073 	uxtb	r2, r3
  1147a8:	e51b300c 	ldr	r3, [fp, #-12]
  1147ac:	e5c32010 	strb	r2, [r3, #16]
  1147b0:	e51b3010 	ldr	r3, [fp, #-16]
  1147b4:	e3530000 	cmp	r3, #0
  1147b8:	0a000003 	beq	1147cc <lwip_getsockopt_impl+0x368>
  1147bc:	eb009245 	bl	1390d8 <__errno_location>
  1147c0:	e1a02000 	mov	r2, r0
  1147c4:	e51b3010 	ldr	r3, [fp, #-16]
  1147c8:	e5823000 	str	r3, [r2]
      }
      *(int *)optval = (sock->err == 0xFF ? (int)-1 : (int)sock->err);
  1147cc:	e51b300c 	ldr	r3, [fp, #-12]
  1147d0:	e5d33010 	ldrb	r3, [r3, #16]
  1147d4:	e35300ff 	cmp	r3, #255	; 0xff
  1147d8:	0a000003 	beq	1147ec <lwip_getsockopt_impl+0x388>
  1147dc:	e51b300c 	ldr	r3, [fp, #-12]
  1147e0:	e5d33010 	ldrb	r3, [r3, #16]
  1147e4:	e1a02003 	mov	r2, r3
  1147e8:	ea000000 	b	1147f0 <lwip_getsockopt_impl+0x38c>
  1147ec:	e3e02000 	mvn	r2, #0
  1147f0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1147f4:	e5832000 	str	r2, [r3]
      sock->err = 0;
  1147f8:	e51b300c 	ldr	r3, [fp, #-12]
  1147fc:	e3a02000 	mov	r2, #0
  114800:	e5c32010 	strb	r2, [r3, #16]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  114804:	ea000083 	b	114a18 <lwip_getsockopt_impl+0x5b4>

#if LWIP_SO_SNDTIMEO
    case SO_SNDTIMEO:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
  114808:	e59b3004 	ldr	r3, [fp, #4]
  11480c:	e5933000 	ldr	r3, [r3]
  114810:	e353000f 	cmp	r3, #15
  114814:	8a000001 	bhi	114820 <lwip_getsockopt_impl+0x3bc>
  114818:	e3a03016 	mov	r3, #22
  11481c:	ea00018c 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114820:	e51b300c 	ldr	r3, [fp, #-12]
  114824:	e5933000 	ldr	r3, [r3]
  114828:	e3530000 	cmp	r3, #0
  11482c:	1a000001 	bne	114838 <lwip_getsockopt_impl+0x3d4>
  114830:	e3a03016 	mov	r3, #22
  114834:	ea000186 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      LWIP_SO_SNDRCVTIMEO_SET(optval, netconn_get_sendtimeout(sock->conn));
  114838:	e51b300c 	ldr	r3, [fp, #-12]
  11483c:	e5933000 	ldr	r3, [r3]
  114840:	e5933020 	ldr	r3, [r3, #32]
  114844:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  114848:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  11484c:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  114850:	e3413062 	movt	r3, #4194	; 0x1062
  114854:	e0832392 	umull	r2, r3, r2, r3
  114858:	e1a03323 	lsr	r3, r3, #6
  11485c:	e1a02003 	mov	r2, r3
  114860:	e3a03000 	mov	r3, #0
  114864:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  114868:	e1c120f0 	strd	r2, [r1]
  11486c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  114870:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  114874:	e3413062 	movt	r3, #4194	; 0x1062
  114878:	e0832391 	umull	r2, r3, r1, r3
  11487c:	e1a03323 	lsr	r3, r3, #6
  114880:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  114884:	e0030392 	mul	r3, r2, r3
  114888:	e0413003 	sub	r3, r1, r3
  11488c:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  114890:	e0030392 	mul	r3, r2, r3
  114894:	e1a02003 	mov	r2, r3
  114898:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11489c:	e5832008 	str	r2, [r3, #8]
      break;
  1148a0:	ea00005c 	b	114a18 <lwip_getsockopt_impl+0x5b4>
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
  1148a4:	e59b3004 	ldr	r3, [fp, #4]
  1148a8:	e5933000 	ldr	r3, [r3]
  1148ac:	e353000f 	cmp	r3, #15
  1148b0:	8a000001 	bhi	1148bc <lwip_getsockopt_impl+0x458>
  1148b4:	e3a03016 	mov	r3, #22
  1148b8:	ea000165 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  1148bc:	e51b300c 	ldr	r3, [fp, #-12]
  1148c0:	e5933000 	ldr	r3, [r3]
  1148c4:	e3530000 	cmp	r3, #0
  1148c8:	1a000001 	bne	1148d4 <lwip_getsockopt_impl+0x470>
  1148cc:	e3a03016 	mov	r3, #22
  1148d0:	ea00015f 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      LWIP_SO_SNDRCVTIMEO_SET(optval, netconn_get_recvtimeout(sock->conn));
  1148d4:	e51b300c 	ldr	r3, [fp, #-12]
  1148d8:	e5933000 	ldr	r3, [r3]
  1148dc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  1148e0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1148e4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  1148e8:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  1148ec:	e3413062 	movt	r3, #4194	; 0x1062
  1148f0:	e0832392 	umull	r2, r3, r2, r3
  1148f4:	e1a03323 	lsr	r3, r3, #6
  1148f8:	e1a02003 	mov	r2, r3
  1148fc:	e3a03000 	mov	r3, #0
  114900:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  114904:	e1c120f0 	strd	r2, [r1]
  114908:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  11490c:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  114910:	e3413062 	movt	r3, #4194	; 0x1062
  114914:	e0832391 	umull	r2, r3, r1, r3
  114918:	e1a03323 	lsr	r3, r3, #6
  11491c:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  114920:	e0030392 	mul	r3, r2, r3
  114924:	e0413003 	sub	r3, r1, r3
  114928:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  11492c:	e0030392 	mul	r3, r2, r3
  114930:	e1a02003 	mov	r2, r3
  114934:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114938:	e5832008 	str	r2, [r3, #8]
      break;
  11493c:	ea000035 	b	114a18 <lwip_getsockopt_impl+0x5b4>
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
    case SO_RCVBUF:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, *optlen, int);
  114940:	e59b3004 	ldr	r3, [fp, #4]
  114944:	e5933000 	ldr	r3, [r3]
  114948:	e3530003 	cmp	r3, #3
  11494c:	8a000001 	bhi	114958 <lwip_getsockopt_impl+0x4f4>
  114950:	e3a03016 	mov	r3, #22
  114954:	ea00013e 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114958:	e51b300c 	ldr	r3, [fp, #-12]
  11495c:	e5933000 	ldr	r3, [r3]
  114960:	e3530000 	cmp	r3, #0
  114964:	1a000001 	bne	114970 <lwip_getsockopt_impl+0x50c>
  114968:	e3a03016 	mov	r3, #22
  11496c:	ea000138 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      *(int *)optval = netconn_get_recvbufsize(sock->conn);
  114970:	e51b300c 	ldr	r3, [fp, #-12]
  114974:	e5933000 	ldr	r3, [r3]
  114978:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  11497c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114980:	e5832000 	str	r2, [r3]
      break;
  114984:	ea000023 	b	114a18 <lwip_getsockopt_impl+0x5b4>
      }
      break;
#endif /* LWIP_SO_LINGER */
#if LWIP_UDP
    case SO_NO_CHECK:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_UDP);
  114988:	e59b3004 	ldr	r3, [fp, #4]
  11498c:	e5933000 	ldr	r3, [r3]
  114990:	e3530003 	cmp	r3, #3
  114994:	8a000001 	bhi	1149a0 <lwip_getsockopt_impl+0x53c>
  114998:	e3a03016 	mov	r3, #22
  11499c:	ea00012c 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  1149a0:	e51b300c 	ldr	r3, [fp, #-12]
  1149a4:	e5933000 	ldr	r3, [r3]
  1149a8:	e3530000 	cmp	r3, #0
  1149ac:	0a000004 	beq	1149c4 <lwip_getsockopt_impl+0x560>
  1149b0:	e51b300c 	ldr	r3, [fp, #-12]
  1149b4:	e5933000 	ldr	r3, [r3]
  1149b8:	e5933008 	ldr	r3, [r3, #8]
  1149bc:	e3530000 	cmp	r3, #0
  1149c0:	1a000001 	bne	1149cc <lwip_getsockopt_impl+0x568>
  1149c4:	e3a03016 	mov	r3, #22
  1149c8:	ea000121 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  1149cc:	e51b300c 	ldr	r3, [fp, #-12]
  1149d0:	e5933000 	ldr	r3, [r3]
  1149d4:	e5933000 	ldr	r3, [r3]
  1149d8:	e20330f0 	and	r3, r3, #240	; 0xf0
  1149dc:	e3530020 	cmp	r3, #32
  1149e0:	0a000001 	beq	1149ec <lwip_getsockopt_impl+0x588>
  1149e4:	e3a0305c 	mov	r3, #92	; 0x5c
  1149e8:	ea000119 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      if ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0) {
        /* this flag is only available for UDP, not for UDP lite */
        return EAFNOSUPPORT;
      }
#endif /* LWIP_UDPLITE */
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  1149ec:	e51b300c 	ldr	r3, [fp, #-12]
  1149f0:	e5933000 	ldr	r3, [r3]
  1149f4:	e5933008 	ldr	r3, [r3, #8]
  1149f8:	e5d33010 	ldrb	r3, [r3, #16]
  1149fc:	e2032001 	and	r2, r3, #1
  114a00:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114a04:	e5832000 	str	r2, [r3]
      break;
  114a08:	ea000002 	b	114a18 <lwip_getsockopt_impl+0x5b4>
#endif /* LWIP_UDP*/
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  114a0c:	e3a0305c 	mov	r3, #92	; 0x5c
  114a10:	e54b3005 	strb	r3, [fp, #-5]
      break;
  114a14:	e320f000 	nop	{0}
    }  /* switch (optname) */
    break;
  114a18:	ea00010c 	b	114e50 <lwip_getsockopt_impl+0x9ec>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  114a1c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  114a20:	e2433001 	sub	r3, r3, #1
  114a24:	e3530006 	cmp	r3, #6
  114a28:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  114a2c:	ea000098 	b	114c94 <lwip_getsockopt_impl+0x830>
  114a30:	00114ab0 	.word	0x00114ab0
  114a34:	00114a4c 	.word	0x00114a4c
  114a38:	00114c94 	.word	0x00114c94
  114a3c:	00114c94 	.word	0x00114c94
  114a40:	00114b14 	.word	0x00114b14
  114a44:	00114b94 	.word	0x00114b94
  114a48:	00114c14 	.word	0x00114c14
    case IP_TTL:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
  114a4c:	e59b3004 	ldr	r3, [fp, #4]
  114a50:	e5933000 	ldr	r3, [r3]
  114a54:	e3530003 	cmp	r3, #3
  114a58:	8a000001 	bhi	114a64 <lwip_getsockopt_impl+0x600>
  114a5c:	e3a03016 	mov	r3, #22
  114a60:	ea0000fb 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114a64:	e51b300c 	ldr	r3, [fp, #-12]
  114a68:	e5933000 	ldr	r3, [r3]
  114a6c:	e3530000 	cmp	r3, #0
  114a70:	0a000004 	beq	114a88 <lwip_getsockopt_impl+0x624>
  114a74:	e51b300c 	ldr	r3, [fp, #-12]
  114a78:	e5933000 	ldr	r3, [r3]
  114a7c:	e5933008 	ldr	r3, [r3, #8]
  114a80:	e3530000 	cmp	r3, #0
  114a84:	1a000001 	bne	114a90 <lwip_getsockopt_impl+0x62c>
  114a88:	e3a03016 	mov	r3, #22
  114a8c:	ea0000f0 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  114a90:	e51b300c 	ldr	r3, [fp, #-12]
  114a94:	e5933000 	ldr	r3, [r3]
  114a98:	e5933008 	ldr	r3, [r3, #8]
  114a9c:	e5d3300a 	ldrb	r3, [r3, #10]
  114aa0:	e1a02003 	mov	r2, r3
  114aa4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114aa8:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  114aac:	ea00007b 	b	114ca0 <lwip_getsockopt_impl+0x83c>
    case IP_TOS:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, int);
  114ab0:	e59b3004 	ldr	r3, [fp, #4]
  114ab4:	e5933000 	ldr	r3, [r3]
  114ab8:	e3530003 	cmp	r3, #3
  114abc:	8a000001 	bhi	114ac8 <lwip_getsockopt_impl+0x664>
  114ac0:	e3a03016 	mov	r3, #22
  114ac4:	ea0000e2 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114ac8:	e51b300c 	ldr	r3, [fp, #-12]
  114acc:	e5933000 	ldr	r3, [r3]
  114ad0:	e3530000 	cmp	r3, #0
  114ad4:	0a000004 	beq	114aec <lwip_getsockopt_impl+0x688>
  114ad8:	e51b300c 	ldr	r3, [fp, #-12]
  114adc:	e5933000 	ldr	r3, [r3]
  114ae0:	e5933008 	ldr	r3, [r3, #8]
  114ae4:	e3530000 	cmp	r3, #0
  114ae8:	1a000001 	bne	114af4 <lwip_getsockopt_impl+0x690>
  114aec:	e3a03016 	mov	r3, #22
  114af0:	ea0000d7 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      *(int*)optval = sock->conn->pcb.ip->tos;
  114af4:	e51b300c 	ldr	r3, [fp, #-12]
  114af8:	e5933000 	ldr	r3, [r3]
  114afc:	e5933008 	ldr	r3, [r3, #8]
  114b00:	e5d33009 	ldrb	r3, [r3, #9]
  114b04:	e1a02003 	mov	r2, r3
  114b08:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114b0c:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  114b10:	ea000062 	b	114ca0 <lwip_getsockopt_impl+0x83c>
#if LWIP_MULTICAST_TX_OPTIONS
    case IP_MULTICAST_TTL:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, u8_t);
  114b14:	e59b3004 	ldr	r3, [fp, #4]
  114b18:	e5933000 	ldr	r3, [r3]
  114b1c:	e3530000 	cmp	r3, #0
  114b20:	1a000001 	bne	114b2c <lwip_getsockopt_impl+0x6c8>
  114b24:	e3a03016 	mov	r3, #22
  114b28:	ea0000c9 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114b2c:	e51b300c 	ldr	r3, [fp, #-12]
  114b30:	e5933000 	ldr	r3, [r3]
  114b34:	e3530000 	cmp	r3, #0
  114b38:	0a000004 	beq	114b50 <lwip_getsockopt_impl+0x6ec>
  114b3c:	e51b300c 	ldr	r3, [fp, #-12]
  114b40:	e5933000 	ldr	r3, [r3]
  114b44:	e5933008 	ldr	r3, [r3, #8]
  114b48:	e3530000 	cmp	r3, #0
  114b4c:	1a000001 	bne	114b58 <lwip_getsockopt_impl+0x6f4>
  114b50:	e3a03016 	mov	r3, #22
  114b54:	ea0000be 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_UDP) {
  114b58:	e51b300c 	ldr	r3, [fp, #-12]
  114b5c:	e5933000 	ldr	r3, [r3]
  114b60:	e5933000 	ldr	r3, [r3]
  114b64:	e20330f0 	and	r3, r3, #240	; 0xf0
  114b68:	e3530020 	cmp	r3, #32
  114b6c:	0a000001 	beq	114b78 <lwip_getsockopt_impl+0x714>
        return ENOPROTOOPT;
  114b70:	e3a0305c 	mov	r3, #92	; 0x5c
  114b74:	ea0000b6 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      }
      *(u8_t*)optval = udp_get_multicast_ttl(sock->conn->pcb.udp);
  114b78:	e51b300c 	ldr	r3, [fp, #-12]
  114b7c:	e5933000 	ldr	r3, [r3]
  114b80:	e5933008 	ldr	r3, [r3, #8]
  114b84:	e5d3201c 	ldrb	r2, [r3, #28]
  114b88:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114b8c:	e5c32000 	strb	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  114b90:	ea000042 	b	114ca0 <lwip_getsockopt_impl+0x83c>
    case IP_MULTICAST_IF:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, struct in_addr);
  114b94:	e59b3004 	ldr	r3, [fp, #4]
  114b98:	e5933000 	ldr	r3, [r3]
  114b9c:	e3530003 	cmp	r3, #3
  114ba0:	8a000001 	bhi	114bac <lwip_getsockopt_impl+0x748>
  114ba4:	e3a03016 	mov	r3, #22
  114ba8:	ea0000a9 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114bac:	e51b300c 	ldr	r3, [fp, #-12]
  114bb0:	e5933000 	ldr	r3, [r3]
  114bb4:	e3530000 	cmp	r3, #0
  114bb8:	0a000004 	beq	114bd0 <lwip_getsockopt_impl+0x76c>
  114bbc:	e51b300c 	ldr	r3, [fp, #-12]
  114bc0:	e5933000 	ldr	r3, [r3]
  114bc4:	e5933008 	ldr	r3, [r3, #8]
  114bc8:	e3530000 	cmp	r3, #0
  114bcc:	1a000001 	bne	114bd8 <lwip_getsockopt_impl+0x774>
  114bd0:	e3a03016 	mov	r3, #22
  114bd4:	ea00009e 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_UDP) {
  114bd8:	e51b300c 	ldr	r3, [fp, #-12]
  114bdc:	e5933000 	ldr	r3, [r3]
  114be0:	e5933000 	ldr	r3, [r3]
  114be4:	e20330f0 	and	r3, r3, #240	; 0xf0
  114be8:	e3530020 	cmp	r3, #32
  114bec:	0a000001 	beq	114bf8 <lwip_getsockopt_impl+0x794>
        return ENOPROTOOPT;
  114bf0:	e3a0305c 	mov	r3, #92	; 0x5c
  114bf4:	ea000096 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      }
      inet_addr_from_ip4addr((struct in_addr*)optval, udp_get_multicast_netif_addr(sock->conn->pcb.udp));
  114bf8:	e51b300c 	ldr	r3, [fp, #-12]
  114bfc:	e5933000 	ldr	r3, [r3]
  114c00:	e5933008 	ldr	r3, [r3, #8]
  114c04:	e5932018 	ldr	r2, [r3, #24]
  114c08:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114c0c:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%"X32_F"\n",
                  s, *(u32_t *)optval));
      break;
  114c10:	ea000022 	b	114ca0 <lwip_getsockopt_impl+0x83c>
    case IP_MULTICAST_LOOP:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, *optlen, u8_t);
  114c14:	e59b3004 	ldr	r3, [fp, #4]
  114c18:	e5933000 	ldr	r3, [r3]
  114c1c:	e3530000 	cmp	r3, #0
  114c20:	1a000001 	bne	114c2c <lwip_getsockopt_impl+0x7c8>
  114c24:	e3a03016 	mov	r3, #22
  114c28:	ea000089 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114c2c:	e51b300c 	ldr	r3, [fp, #-12]
  114c30:	e5933000 	ldr	r3, [r3]
  114c34:	e3530000 	cmp	r3, #0
  114c38:	0a000004 	beq	114c50 <lwip_getsockopt_impl+0x7ec>
  114c3c:	e51b300c 	ldr	r3, [fp, #-12]
  114c40:	e5933000 	ldr	r3, [r3]
  114c44:	e5933008 	ldr	r3, [r3, #8]
  114c48:	e3530000 	cmp	r3, #0
  114c4c:	1a000001 	bne	114c58 <lwip_getsockopt_impl+0x7f4>
  114c50:	e3a03016 	mov	r3, #22
  114c54:	ea00007e 	b	114e54 <lwip_getsockopt_impl+0x9f0>
      if ((sock->conn->pcb.udp->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) {
  114c58:	e51b300c 	ldr	r3, [fp, #-12]
  114c5c:	e5933000 	ldr	r3, [r3]
  114c60:	e5933008 	ldr	r3, [r3, #8]
  114c64:	e5d33010 	ldrb	r3, [r3, #16]
  114c68:	e2033008 	and	r3, r3, #8
  114c6c:	e3530000 	cmp	r3, #0
  114c70:	0a000003 	beq	114c84 <lwip_getsockopt_impl+0x820>
        *(u8_t*)optval = 1;
  114c74:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114c78:	e3a02001 	mov	r2, #1
  114c7c:	e5c32000 	strb	r2, [r3]
      } else {
        *(u8_t*)optval = 0;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_LOOP) = %d\n",
                  s, *(int *)optval));
      break;
  114c80:	ea000006 	b	114ca0 <lwip_getsockopt_impl+0x83c>
        *(u8_t*)optval = 0;
  114c84:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114c88:	e3a02000 	mov	r2, #0
  114c8c:	e5c32000 	strb	r2, [r3]
      break;
  114c90:	ea000002 	b	114ca0 <lwip_getsockopt_impl+0x83c>
#endif /* LWIP_MULTICAST_TX_OPTIONS */
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  114c94:	e3a0305c 	mov	r3, #92	; 0x5c
  114c98:	e54b3005 	strb	r3, [fp, #-5]
      break;
  114c9c:	e320f000 	nop	{0}
    }  /* switch (optname) */
    break;
  114ca0:	ea00006a 	b	114e50 <lwip_getsockopt_impl+0x9ec>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    /* Special case: all IPPROTO_TCP option take an int */
    LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, *optlen, int, NETCONN_TCP);
  114ca4:	e59b3004 	ldr	r3, [fp, #4]
  114ca8:	e5933000 	ldr	r3, [r3]
  114cac:	e3530003 	cmp	r3, #3
  114cb0:	8a000001 	bhi	114cbc <lwip_getsockopt_impl+0x858>
  114cb4:	e3a03016 	mov	r3, #22
  114cb8:	ea000065 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114cbc:	e51b300c 	ldr	r3, [fp, #-12]
  114cc0:	e5933000 	ldr	r3, [r3]
  114cc4:	e3530000 	cmp	r3, #0
  114cc8:	0a000004 	beq	114ce0 <lwip_getsockopt_impl+0x87c>
  114ccc:	e51b300c 	ldr	r3, [fp, #-12]
  114cd0:	e5933000 	ldr	r3, [r3]
  114cd4:	e5933008 	ldr	r3, [r3, #8]
  114cd8:	e3530000 	cmp	r3, #0
  114cdc:	1a000001 	bne	114ce8 <lwip_getsockopt_impl+0x884>
  114ce0:	e3a03016 	mov	r3, #22
  114ce4:	ea00005a 	b	114e54 <lwip_getsockopt_impl+0x9f0>
  114ce8:	e51b300c 	ldr	r3, [fp, #-12]
  114cec:	e5933000 	ldr	r3, [r3]
  114cf0:	e5933000 	ldr	r3, [r3]
  114cf4:	e20330f0 	and	r3, r3, #240	; 0xf0
  114cf8:	e3530010 	cmp	r3, #16
  114cfc:	0a000001 	beq	114d08 <lwip_getsockopt_impl+0x8a4>
  114d00:	e3a0305c 	mov	r3, #92	; 0x5c
  114d04:	ea000052 	b	114e54 <lwip_getsockopt_impl+0x9f0>
    if (sock->conn->pcb.tcp->state == LISTEN) {
  114d08:	e51b300c 	ldr	r3, [fp, #-12]
  114d0c:	e5933000 	ldr	r3, [r3]
  114d10:	e5933008 	ldr	r3, [r3, #8]
  114d14:	e5933014 	ldr	r3, [r3, #20]
  114d18:	e3530001 	cmp	r3, #1
  114d1c:	1a000001 	bne	114d28 <lwip_getsockopt_impl+0x8c4>
      return EINVAL;
  114d20:	e3a03016 	mov	r3, #22
  114d24:	ea00004a 	b	114e54 <lwip_getsockopt_impl+0x9f0>
    }
    switch (optname) {
  114d28:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  114d2c:	e2433001 	sub	r3, r3, #1
  114d30:	e3530004 	cmp	r3, #4
  114d34:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  114d38:	ea000039 	b	114e24 <lwip_getsockopt_impl+0x9c0>
  114d3c:	00114d50 	.word	0x00114d50
  114d40:	00114d84 	.word	0x00114d84
  114d44:	00114da4 	.word	0x00114da4
  114d48:	00114dd4 	.word	0x00114dd4
  114d4c:	00114e04 	.word	0x00114e04
    case TCP_NODELAY:
      *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
  114d50:	e51b300c 	ldr	r3, [fp, #-12]
  114d54:	e5933000 	ldr	r3, [r3]
  114d58:	e5933008 	ldr	r3, [r3, #8]
  114d5c:	e5d3301e 	ldrb	r3, [r3, #30]
  114d60:	e2033040 	and	r3, r3, #64	; 0x40
  114d64:	e3530000 	cmp	r3, #0
  114d68:	13a03001 	movne	r3, #1
  114d6c:	03a03000 	moveq	r3, #0
  114d70:	e6ef3073 	uxtb	r3, r3
  114d74:	e1a02003 	mov	r2, r3
  114d78:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114d7c:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  114d80:	ea00002a 	b	114e30 <lwip_getsockopt_impl+0x9cc>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  114d84:	e51b300c 	ldr	r3, [fp, #-12]
  114d88:	e5933000 	ldr	r3, [r3]
  114d8c:	e5933008 	ldr	r3, [r3, #8]
  114d90:	e5933094 	ldr	r3, [r3, #148]	; 0x94
  114d94:	e1a02003 	mov	r2, r3
  114d98:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114d9c:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
  114da0:	ea000022 	b	114e30 <lwip_getsockopt_impl+0x9cc>

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_idle/1000);
  114da4:	e51b300c 	ldr	r3, [fp, #-12]
  114da8:	e5933000 	ldr	r3, [r3]
  114dac:	e5933008 	ldr	r3, [r3, #8]
  114db0:	e5932094 	ldr	r2, [r3, #148]	; 0x94
  114db4:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  114db8:	e3413062 	movt	r3, #4194	; 0x1062
  114dbc:	e0832392 	umull	r2, r3, r2, r3
  114dc0:	e1a03323 	lsr	r3, r3, #6
  114dc4:	e1a02003 	mov	r2, r3
  114dc8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114dcc:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) = %d\n",
                  s, *(int *)optval));
      break;
  114dd0:	ea000016 	b	114e30 <lwip_getsockopt_impl+0x9cc>
    case TCP_KEEPINTVL:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_intvl/1000);
  114dd4:	e51b300c 	ldr	r3, [fp, #-12]
  114dd8:	e5933000 	ldr	r3, [r3]
  114ddc:	e5933008 	ldr	r3, [r3, #8]
  114de0:	e5932098 	ldr	r2, [r3, #152]	; 0x98
  114de4:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  114de8:	e3413062 	movt	r3, #4194	; 0x1062
  114dec:	e0832392 	umull	r2, r3, r2, r3
  114df0:	e1a03323 	lsr	r3, r3, #6
  114df4:	e1a02003 	mov	r2, r3
  114df8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114dfc:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) = %d\n",
                  s, *(int *)optval));
      break;
  114e00:	ea00000a 	b	114e30 <lwip_getsockopt_impl+0x9cc>
    case TCP_KEEPCNT:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_cnt;
  114e04:	e51b300c 	ldr	r3, [fp, #-12]
  114e08:	e5933000 	ldr	r3, [r3]
  114e0c:	e5933008 	ldr	r3, [r3, #8]
  114e10:	e593309c 	ldr	r3, [r3, #156]	; 0x9c
  114e14:	e1a02003 	mov	r2, r3
  114e18:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  114e1c:	e5832000 	str	r2, [r3]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) = %d\n",
                  s, *(int *)optval));
      break;
  114e20:	ea000002 	b	114e30 <lwip_getsockopt_impl+0x9cc>
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  114e24:	e3a0305c 	mov	r3, #92	; 0x5c
  114e28:	e54b3005 	strb	r3, [fp, #-5]
      break;
  114e2c:	e320f000 	nop	{0}
    }  /* switch (optname) */
    break;
  114e30:	ea000006 	b	114e50 <lwip_getsockopt_impl+0x9ec>
      break;
#endif /* LWIP_IPV6 && LWIP_RAW */
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_RAW, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  114e34:	e3a0305c 	mov	r3, #92	; 0x5c
  114e38:	e54b3005 	strb	r3, [fp, #-5]
      break;
  114e3c:	e320f000 	nop	{0}
    }  /* switch (optname) */
    break;
  114e40:	ea000002 	b	114e50 <lwip_getsockopt_impl+0x9ec>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                s, level, optname));
    err = ENOPROTOOPT;
  114e44:	e3a0305c 	mov	r3, #92	; 0x5c
  114e48:	e54b3005 	strb	r3, [fp, #-5]
    break;
  114e4c:	e320f000 	nop	{0}
  } /* switch (level) */

  return err;
  114e50:	e55b3005 	ldrb	r3, [fp, #-5]
}
  114e54:	e1a00003 	mov	r0, r3
  114e58:	e24bd004 	sub	sp, fp, #4
  114e5c:	e8bd8800 	pop	{fp, pc}

00114e60 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  114e60:	e92d4800 	push	{fp, lr}
  114e64:	e28db004 	add	fp, sp, #4
  114e68:	e24dd028 	sub	sp, sp, #40	; 0x28
  114e6c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  114e70:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  114e74:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  114e78:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  u8_t err = 0;
  114e7c:	e3a03000 	mov	r3, #0
  114e80:	e54b3005 	strb	r3, [fp, #-5]
  struct lwip_sock *sock = get_socket(s);
  114e84:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  114e88:	ebfff0a5 	bl	111124 <get_socket>
  114e8c:	e50b000c 	str	r0, [fp, #-12]
#if !LWIP_TCPIP_CORE_LOCKING
  LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
#endif /* !LWIP_TCPIP_CORE_LOCKING */

  if (!sock) {
  114e90:	e51b300c 	ldr	r3, [fp, #-12]
  114e94:	e3530000 	cmp	r3, #0
  114e98:	1a000001 	bne	114ea4 <lwip_setsockopt+0x44>
    return -1;
  114e9c:	e3e03000 	mvn	r3, #0
  114ea0:	ea000033 	b	114f74 <lwip_setsockopt+0x114>
  }

  if (NULL == optval) {
  114ea4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  114ea8:	e3530000 	cmp	r3, #0
  114eac:	1a00000e 	bne	114eec <lwip_setsockopt+0x8c>
    sock_set_errno(sock, EFAULT);
  114eb0:	e3a0300e 	mov	r3, #14
  114eb4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  114eb8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  114ebc:	e6ef2073 	uxtb	r2, r3
  114ec0:	e51b300c 	ldr	r3, [fp, #-12]
  114ec4:	e5c32010 	strb	r2, [r3, #16]
  114ec8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  114ecc:	e3530000 	cmp	r3, #0
  114ed0:	0a000003 	beq	114ee4 <lwip_setsockopt+0x84>
  114ed4:	eb00907f 	bl	1390d8 <__errno_location>
  114ed8:	e1a02000 	mov	r2, r0
  114edc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  114ee0:	e5823000 	str	r3, [r2]
    return -1;
  114ee4:	e3e03000 	mvn	r3, #0
  114ee8:	ea000021 	b	114f74 <lwip_setsockopt+0x114>
  }

#if LWIP_TCPIP_CORE_LOCKING
  /* core-locking can just call the -impl function */
  LOCK_TCPIP_CORE();
  114eec:	e30005e4 	movw	r0, #1508	; 0x5e4
  114ef0:	e3400015 	movt	r0, #21
  114ef4:	ebffd67f 	bl	10a8f8 <sys_mutex_lock>
  err = lwip_setsockopt_impl(s, level, optname, optval, optlen);
  114ef8:	e59b3004 	ldr	r3, [fp, #4]
  114efc:	e58d3000 	str	r3, [sp]
  114f00:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  114f04:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  114f08:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  114f0c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  114f10:	eb00001a 	bl	114f80 <lwip_setsockopt_impl>
  114f14:	e1a03000 	mov	r3, r0
  114f18:	e54b3005 	strb	r3, [fp, #-5]
  UNLOCK_TCPIP_CORE();
  114f1c:	e30005e4 	movw	r0, #1508	; 0x5e4
  114f20:	e3400015 	movt	r0, #21
  114f24:	ebffd67f 	bl	10a928 <sys_mutex_unlock>
  /* maybe lwip_getsockopt_internal has changed err */
  err = LWIP_SETGETSOCKOPT_DATA_VAR_REF(data).err;
  LWIP_SETGETSOCKOPT_DATA_VAR_FREE(data);
#endif  /* LWIP_TCPIP_CORE_LOCKING */

  sock_set_errno(sock, err);
  114f28:	e55b3005 	ldrb	r3, [fp, #-5]
  114f2c:	e50b3010 	str	r3, [fp, #-16]
  114f30:	e51b3010 	ldr	r3, [fp, #-16]
  114f34:	e6ef2073 	uxtb	r2, r3
  114f38:	e51b300c 	ldr	r3, [fp, #-12]
  114f3c:	e5c32010 	strb	r2, [r3, #16]
  114f40:	e51b3010 	ldr	r3, [fp, #-16]
  114f44:	e3530000 	cmp	r3, #0
  114f48:	0a000003 	beq	114f5c <lwip_setsockopt+0xfc>
  114f4c:	eb009061 	bl	1390d8 <__errno_location>
  114f50:	e1a02000 	mov	r2, r0
  114f54:	e51b3010 	ldr	r3, [fp, #-16]
  114f58:	e5823000 	str	r3, [r2]
  return err ? -1 : 0;
  114f5c:	e55b3005 	ldrb	r3, [fp, #-5]
  114f60:	e3530000 	cmp	r3, #0
  114f64:	0a000001 	beq	114f70 <lwip_setsockopt+0x110>
  114f68:	e3e03000 	mvn	r3, #0
  114f6c:	ea000000 	b	114f74 <lwip_setsockopt+0x114>
  114f70:	e3a03000 	mov	r3, #0
}
  114f74:	e1a00003 	mov	r0, r3
  114f78:	e24bd004 	sub	sp, fp, #4
  114f7c:	e8bd8800 	pop	{fp, pc}

00114f80 <lwip_setsockopt_impl>:
/** lwip_setsockopt_impl: the actual implementation of setsockopt:
 * same argument as lwip_setsockopt, either called directly or through callback
 */
static u8_t
lwip_setsockopt_impl(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  114f80:	e92d4800 	push	{fp, lr}
  114f84:	e28db004 	add	fp, sp, #4
  114f88:	e24dd028 	sub	sp, sp, #40	; 0x28
  114f8c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  114f90:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  114f94:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  114f98:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
  u8_t err = 0;
  114f9c:	e3a03000 	mov	r3, #0
  114fa0:	e54b3005 	strb	r3, [fp, #-5]
  struct lwip_sock *sock = tryget_socket(s);
  114fa4:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  114fa8:	ebfff082 	bl	1111b8 <tryget_socket>
  114fac:	e50b000c 	str	r0, [fp, #-12]
  if (!sock) {
  114fb0:	e51b300c 	ldr	r3, [fp, #-12]
  114fb4:	e3530000 	cmp	r3, #0
  114fb8:	1a000001 	bne	114fc4 <lwip_setsockopt_impl+0x44>
    return EBADF;
  114fbc:	e3a03009 	mov	r3, #9
  114fc0:	ea000248 	b	1158e8 <lwip_setsockopt_impl+0x968>
  }

  switch (level) {
  114fc4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  114fc8:	e3530006 	cmp	r3, #6
  114fcc:	0a0001d3 	beq	115720 <lwip_setsockopt_impl+0x7a0>
  114fd0:	e3530006 	cmp	r3, #6
  114fd4:	ca000002 	bgt	114fe4 <lwip_setsockopt_impl+0x64>
  114fd8:	e3530000 	cmp	r3, #0
  114fdc:	0a0000d2 	beq	11532c <lwip_setsockopt_impl+0x3ac>
  114fe0:	ea00023c 	b	1158d8 <lwip_setsockopt_impl+0x958>
  114fe4:	e35300ff 	cmp	r3, #255	; 0xff
  114fe8:	0a000236 	beq	1158c8 <lwip_setsockopt_impl+0x948>
  114fec:	e3002fff 	movw	r2, #4095	; 0xfff
  114ff0:	e1530002 	cmp	r3, r2
  114ff4:	1a000237 	bne	1158d8 <lwip_setsockopt_impl+0x958>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  114ff8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  114ffc:	e3012002 	movw	r2, #4098	; 0x1002
  115000:	e1530002 	cmp	r3, r2
  115004:	0a000081 	beq	115210 <lwip_setsockopt_impl+0x290>
  115008:	e3012002 	movw	r2, #4098	; 0x1002
  11500c:	e1530002 	cmp	r3, r2
  115010:	ca000006 	bgt	115030 <lwip_setsockopt_impl+0xb0>
  115014:	e3530008 	cmp	r3, #8
  115018:	0a00000e 	beq	115058 <lwip_setsockopt_impl+0xd8>
  11501c:	e3530020 	cmp	r3, #32
  115020:	0a00000c 	beq	115058 <lwip_setsockopt_impl+0xd8>
  115024:	e3530004 	cmp	r3, #4
  115028:	0a00000a 	beq	115058 <lwip_setsockopt_impl+0xd8>
  11502c:	ea0000ba 	b	11531c <lwip_setsockopt_impl+0x39c>
  115030:	e3012006 	movw	r2, #4102	; 0x1006
  115034:	e1530002 	cmp	r3, r2
  115038:	0a000057 	beq	11519c <lwip_setsockopt_impl+0x21c>
  11503c:	e301200a 	movw	r2, #4106	; 0x100a
  115040:	e1530002 	cmp	r3, r2
  115044:	0a000082 	beq	115254 <lwip_setsockopt_impl+0x2d4>
  115048:	e3012005 	movw	r2, #4101	; 0x1005
  11504c:	e1530002 	cmp	r3, r2
  115050:	0a000034 	beq	115128 <lwip_setsockopt_impl+0x1a8>
  115054:	ea0000b0 	b	11531c <lwip_setsockopt_impl+0x39c>
    case SO_BROADCAST:
    case SO_KEEPALIVE:
#if SO_REUSE
    case SO_REUSEADDR:
#endif /* SO_REUSE */
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
  115058:	e59b3004 	ldr	r3, [fp, #4]
  11505c:	e3530003 	cmp	r3, #3
  115060:	8a000001 	bhi	11506c <lwip_setsockopt_impl+0xec>
  115064:	e3a03016 	mov	r3, #22
  115068:	ea00021e 	b	1158e8 <lwip_setsockopt_impl+0x968>
  11506c:	e51b300c 	ldr	r3, [fp, #-12]
  115070:	e5933000 	ldr	r3, [r3]
  115074:	e3530000 	cmp	r3, #0
  115078:	0a000004 	beq	115090 <lwip_setsockopt_impl+0x110>
  11507c:	e51b300c 	ldr	r3, [fp, #-12]
  115080:	e5933000 	ldr	r3, [r3]
  115084:	e5933008 	ldr	r3, [r3, #8]
  115088:	e3530000 	cmp	r3, #0
  11508c:	1a000001 	bne	115098 <lwip_setsockopt_impl+0x118>
  115090:	e3a03016 	mov	r3, #22
  115094:	ea000213 	b	1158e8 <lwip_setsockopt_impl+0x968>
      if (*(const int*)optval) {
  115098:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11509c:	e5933000 	ldr	r3, [r3]
  1150a0:	e3530000 	cmp	r3, #0
  1150a4:	0a00000e 	beq	1150e4 <lwip_setsockopt_impl+0x164>
        ip_set_option(sock->conn->pcb.ip, optname);
  1150a8:	e51b300c 	ldr	r3, [fp, #-12]
  1150ac:	e5933000 	ldr	r3, [r3]
  1150b0:	e5933008 	ldr	r3, [r3, #8]
  1150b4:	e5d33008 	ldrb	r3, [r3, #8]
  1150b8:	e6af2073 	sxtb	r2, r3
  1150bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1150c0:	e6af3073 	sxtb	r3, r3
  1150c4:	e1823003 	orr	r3, r2, r3
  1150c8:	e6af2073 	sxtb	r2, r3
  1150cc:	e51b300c 	ldr	r3, [fp, #-12]
  1150d0:	e5933000 	ldr	r3, [r3]
  1150d4:	e5933008 	ldr	r3, [r3, #8]
  1150d8:	e6ef2072 	uxtb	r2, r2
  1150dc:	e5c32008 	strb	r2, [r3, #8]
      } else {
        ip_reset_option(sock->conn->pcb.ip, optname);
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(const int*)optval?"on":"off")));
      break;
  1150e0:	ea000090 	b	115328 <lwip_setsockopt_impl+0x3a8>
        ip_reset_option(sock->conn->pcb.ip, optname);
  1150e4:	e51b300c 	ldr	r3, [fp, #-12]
  1150e8:	e5933000 	ldr	r3, [r3]
  1150ec:	e5933008 	ldr	r3, [r3, #8]
  1150f0:	e5d33008 	ldrb	r3, [r3, #8]
  1150f4:	e6af2073 	sxtb	r2, r3
  1150f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1150fc:	e6af3073 	sxtb	r3, r3
  115100:	e1e03003 	mvn	r3, r3
  115104:	e6af3073 	sxtb	r3, r3
  115108:	e0033002 	and	r3, r3, r2
  11510c:	e6af2073 	sxtb	r2, r3
  115110:	e51b300c 	ldr	r3, [fp, #-12]
  115114:	e5933000 	ldr	r3, [r3]
  115118:	e5933008 	ldr	r3, [r3, #8]
  11511c:	e6ef2072 	uxtb	r2, r2
  115120:	e5c32008 	strb	r2, [r3, #8]
      break;
  115124:	ea00007f 	b	115328 <lwip_setsockopt_impl+0x3a8>
    /* SO_TYPE is get-only */
    /* SO_ERROR is get-only */

#if LWIP_SO_SNDTIMEO
    case SO_SNDTIMEO:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
  115128:	e59b3004 	ldr	r3, [fp, #4]
  11512c:	e353000f 	cmp	r3, #15
  115130:	8a000001 	bhi	11513c <lwip_setsockopt_impl+0x1bc>
  115134:	e3a03016 	mov	r3, #22
  115138:	ea0001ea 	b	1158e8 <lwip_setsockopt_impl+0x968>
  11513c:	e51b300c 	ldr	r3, [fp, #-12]
  115140:	e5933000 	ldr	r3, [r3]
  115144:	e3530000 	cmp	r3, #0
  115148:	1a000001 	bne	115154 <lwip_setsockopt_impl+0x1d4>
  11514c:	e3a03016 	mov	r3, #22
  115150:	ea0001e4 	b	1158e8 <lwip_setsockopt_impl+0x968>
      netconn_set_sendtimeout(sock->conn, LWIP_SO_SNDRCVTIMEO_GET_MS(optval));
  115154:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  115158:	e1c320d0 	ldrd	r2, [r3]
  11515c:	e3a03ffa 	mov	r3, #1000	; 0x3e8
  115160:	e0010293 	mul	r1, r3, r2
  115164:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  115168:	e5933008 	ldr	r3, [r3, #8]
  11516c:	e2833ff9 	add	r3, r3, #996	; 0x3e4
  115170:	e2833003 	add	r3, r3, #3
  115174:	e1a02003 	mov	r2, r3
  115178:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  11517c:	e3413062 	movt	r3, #4194	; 0x1062
  115180:	e0832392 	umull	r2, r3, r2, r3
  115184:	e1a03323 	lsr	r3, r3, #6
  115188:	e0812003 	add	r2, r1, r3
  11518c:	e51b300c 	ldr	r3, [fp, #-12]
  115190:	e5933000 	ldr	r3, [r3]
  115194:	e5832020 	str	r2, [r3, #32]
      break;
  115198:	ea000062 	b	115328 <lwip_setsockopt_impl+0x3a8>
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, LWIP_SO_SNDRCVTIMEO_OPTTYPE);
  11519c:	e59b3004 	ldr	r3, [fp, #4]
  1151a0:	e353000f 	cmp	r3, #15
  1151a4:	8a000001 	bhi	1151b0 <lwip_setsockopt_impl+0x230>
  1151a8:	e3a03016 	mov	r3, #22
  1151ac:	ea0001cd 	b	1158e8 <lwip_setsockopt_impl+0x968>
  1151b0:	e51b300c 	ldr	r3, [fp, #-12]
  1151b4:	e5933000 	ldr	r3, [r3]
  1151b8:	e3530000 	cmp	r3, #0
  1151bc:	1a000001 	bne	1151c8 <lwip_setsockopt_impl+0x248>
  1151c0:	e3a03016 	mov	r3, #22
  1151c4:	ea0001c7 	b	1158e8 <lwip_setsockopt_impl+0x968>
      netconn_set_recvtimeout(sock->conn, (int)LWIP_SO_SNDRCVTIMEO_GET_MS(optval));
  1151c8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1151cc:	e1c320d0 	ldrd	r2, [r3]
  1151d0:	e3a03ffa 	mov	r3, #1000	; 0x3e8
  1151d4:	e0010293 	mul	r1, r3, r2
  1151d8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1151dc:	e5933008 	ldr	r3, [r3, #8]
  1151e0:	e2833ff9 	add	r3, r3, #996	; 0x3e4
  1151e4:	e2833003 	add	r3, r3, #3
  1151e8:	e1a02003 	mov	r2, r3
  1151ec:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  1151f0:	e3413062 	movt	r3, #4194	; 0x1062
  1151f4:	e0832392 	umull	r2, r3, r2, r3
  1151f8:	e1a03323 	lsr	r3, r3, #6
  1151fc:	e0812003 	add	r2, r1, r3
  115200:	e51b300c 	ldr	r3, [fp, #-12]
  115204:	e5933000 	ldr	r3, [r3]
  115208:	e5832024 	str	r2, [r3, #36]	; 0x24
      break;
  11520c:	ea000045 	b	115328 <lwip_setsockopt_impl+0x3a8>
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
    case SO_RCVBUF:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN(sock, optlen, int);
  115210:	e59b3004 	ldr	r3, [fp, #4]
  115214:	e3530003 	cmp	r3, #3
  115218:	8a000001 	bhi	115224 <lwip_setsockopt_impl+0x2a4>
  11521c:	e3a03016 	mov	r3, #22
  115220:	ea0001b0 	b	1158e8 <lwip_setsockopt_impl+0x968>
  115224:	e51b300c 	ldr	r3, [fp, #-12]
  115228:	e5933000 	ldr	r3, [r3]
  11522c:	e3530000 	cmp	r3, #0
  115230:	1a000001 	bne	11523c <lwip_setsockopt_impl+0x2bc>
  115234:	e3a03016 	mov	r3, #22
  115238:	ea0001aa 	b	1158e8 <lwip_setsockopt_impl+0x968>
      netconn_set_recvbufsize(sock->conn, *(const int*)optval);
  11523c:	e51b300c 	ldr	r3, [fp, #-12]
  115240:	e5933000 	ldr	r3, [r3]
  115244:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  115248:	e5922000 	ldr	r2, [r2]
  11524c:	e5832028 	str	r2, [r3, #40]	; 0x28
      break;
  115250:	ea000034 	b	115328 <lwip_setsockopt_impl+0x3a8>
      }
      break;
#endif /* LWIP_SO_LINGER */
#if LWIP_UDP
    case SO_NO_CHECK:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_UDP);
  115254:	e59b3004 	ldr	r3, [fp, #4]
  115258:	e3530003 	cmp	r3, #3
  11525c:	8a000001 	bhi	115268 <lwip_setsockopt_impl+0x2e8>
  115260:	e3a03016 	mov	r3, #22
  115264:	ea00019f 	b	1158e8 <lwip_setsockopt_impl+0x968>
  115268:	e51b300c 	ldr	r3, [fp, #-12]
  11526c:	e5933000 	ldr	r3, [r3]
  115270:	e3530000 	cmp	r3, #0
  115274:	0a000004 	beq	11528c <lwip_setsockopt_impl+0x30c>
  115278:	e51b300c 	ldr	r3, [fp, #-12]
  11527c:	e5933000 	ldr	r3, [r3]
  115280:	e5933008 	ldr	r3, [r3, #8]
  115284:	e3530000 	cmp	r3, #0
  115288:	1a000001 	bne	115294 <lwip_setsockopt_impl+0x314>
  11528c:	e3a03016 	mov	r3, #22
  115290:	ea000194 	b	1158e8 <lwip_setsockopt_impl+0x968>
  115294:	e51b300c 	ldr	r3, [fp, #-12]
  115298:	e5933000 	ldr	r3, [r3]
  11529c:	e5933000 	ldr	r3, [r3]
  1152a0:	e20330f0 	and	r3, r3, #240	; 0xf0
  1152a4:	e3530020 	cmp	r3, #32
  1152a8:	0a000001 	beq	1152b4 <lwip_setsockopt_impl+0x334>
  1152ac:	e3a0305c 	mov	r3, #92	; 0x5c
  1152b0:	ea00018c 	b	1158e8 <lwip_setsockopt_impl+0x968>
      if ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0) {
        /* this flag is only available for UDP, not for UDP lite */
        return EAFNOSUPPORT;
      }
#endif /* LWIP_UDPLITE */
      if (*(const int*)optval) {
  1152b4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1152b8:	e5933000 	ldr	r3, [r3]
  1152bc:	e3530000 	cmp	r3, #0
  1152c0:	0a00000a 	beq	1152f0 <lwip_setsockopt_impl+0x370>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  1152c4:	e51b300c 	ldr	r3, [fp, #-12]
  1152c8:	e5933000 	ldr	r3, [r3]
  1152cc:	e5933008 	ldr	r3, [r3, #8]
  1152d0:	e5d32010 	ldrb	r2, [r3, #16]
  1152d4:	e51b300c 	ldr	r3, [fp, #-12]
  1152d8:	e5933000 	ldr	r3, [r3]
  1152dc:	e5933008 	ldr	r3, [r3, #8]
  1152e0:	e3822001 	orr	r2, r2, #1
  1152e4:	e6ef2072 	uxtb	r2, r2
  1152e8:	e5c32010 	strb	r2, [r3, #16]
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
  1152ec:	ea00000d 	b	115328 <lwip_setsockopt_impl+0x3a8>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  1152f0:	e51b300c 	ldr	r3, [fp, #-12]
  1152f4:	e5933000 	ldr	r3, [r3]
  1152f8:	e5933008 	ldr	r3, [r3, #8]
  1152fc:	e5d32010 	ldrb	r2, [r3, #16]
  115300:	e51b300c 	ldr	r3, [fp, #-12]
  115304:	e5933000 	ldr	r3, [r3]
  115308:	e5933008 	ldr	r3, [r3, #8]
  11530c:	e3c22001 	bic	r2, r2, #1
  115310:	e6ef2072 	uxtb	r2, r2
  115314:	e5c32010 	strb	r2, [r3, #16]
      break;
  115318:	ea000002 	b	115328 <lwip_setsockopt_impl+0x3a8>
#endif /* LWIP_UDP */
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  11531c:	e3a0305c 	mov	r3, #92	; 0x5c
  115320:	e54b3005 	strb	r3, [fp, #-5]
      break;
  115324:	e320f000 	nop	{0}
    }  /* switch (optname) */
    break;
  115328:	ea00016d 	b	1158e4 <lwip_setsockopt_impl+0x964>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  11532c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  115330:	e2433001 	sub	r3, r3, #1
  115334:	e3530006 	cmp	r3, #6
  115338:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  11533c:	ea0000f2 	b	11570c <lwip_setsockopt_impl+0x78c>
  115340:	001153bc 	.word	0x001153bc
  115344:	0011535c 	.word	0x0011535c
  115348:	001155e4 	.word	0x001155e4
  11534c:	001155e4 	.word	0x001155e4
  115350:	0011541c 	.word	0x0011541c
  115354:	00115498 	.word	0x00115498
  115358:	0011551c 	.word	0x0011551c
    case IP_TTL:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
  11535c:	e59b3004 	ldr	r3, [fp, #4]
  115360:	e3530003 	cmp	r3, #3
  115364:	8a000001 	bhi	115370 <lwip_setsockopt_impl+0x3f0>
  115368:	e3a03016 	mov	r3, #22
  11536c:	ea00015d 	b	1158e8 <lwip_setsockopt_impl+0x968>
  115370:	e51b300c 	ldr	r3, [fp, #-12]
  115374:	e5933000 	ldr	r3, [r3]
  115378:	e3530000 	cmp	r3, #0
  11537c:	0a000004 	beq	115394 <lwip_setsockopt_impl+0x414>
  115380:	e51b300c 	ldr	r3, [fp, #-12]
  115384:	e5933000 	ldr	r3, [r3]
  115388:	e5933008 	ldr	r3, [r3, #8]
  11538c:	e3530000 	cmp	r3, #0
  115390:	1a000001 	bne	11539c <lwip_setsockopt_impl+0x41c>
  115394:	e3a03016 	mov	r3, #22
  115398:	ea000152 	b	1158e8 <lwip_setsockopt_impl+0x968>
      sock->conn->pcb.ip->ttl = (u8_t)(*(const int*)optval);
  11539c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1153a0:	e5932000 	ldr	r2, [r3]
  1153a4:	e51b300c 	ldr	r3, [fp, #-12]
  1153a8:	e5933000 	ldr	r3, [r3]
  1153ac:	e5933008 	ldr	r3, [r3, #8]
  1153b0:	e6ef2072 	uxtb	r2, r2
  1153b4:	e5c3200a 	strb	r2, [r3, #10]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  1153b8:	ea0000d7 	b	11571c <lwip_setsockopt_impl+0x79c>
    case IP_TOS:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB(sock, optlen, int);
  1153bc:	e59b3004 	ldr	r3, [fp, #4]
  1153c0:	e3530003 	cmp	r3, #3
  1153c4:	8a000001 	bhi	1153d0 <lwip_setsockopt_impl+0x450>
  1153c8:	e3a03016 	mov	r3, #22
  1153cc:	ea000145 	b	1158e8 <lwip_setsockopt_impl+0x968>
  1153d0:	e51b300c 	ldr	r3, [fp, #-12]
  1153d4:	e5933000 	ldr	r3, [r3]
  1153d8:	e3530000 	cmp	r3, #0
  1153dc:	0a000004 	beq	1153f4 <lwip_setsockopt_impl+0x474>
  1153e0:	e51b300c 	ldr	r3, [fp, #-12]
  1153e4:	e5933000 	ldr	r3, [r3]
  1153e8:	e5933008 	ldr	r3, [r3, #8]
  1153ec:	e3530000 	cmp	r3, #0
  1153f0:	1a000001 	bne	1153fc <lwip_setsockopt_impl+0x47c>
  1153f4:	e3a03016 	mov	r3, #22
  1153f8:	ea00013a 	b	1158e8 <lwip_setsockopt_impl+0x968>
      sock->conn->pcb.ip->tos = (u8_t)(*(const int*)optval);
  1153fc:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  115400:	e5932000 	ldr	r2, [r3]
  115404:	e51b300c 	ldr	r3, [fp, #-12]
  115408:	e5933000 	ldr	r3, [r3]
  11540c:	e5933008 	ldr	r3, [r3, #8]
  115410:	e6ef2072 	uxtb	r2, r2
  115414:	e5c32009 	strb	r2, [r3, #9]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  115418:	ea0000bf 	b	11571c <lwip_setsockopt_impl+0x79c>
#if LWIP_MULTICAST_TX_OPTIONS
    case IP_MULTICAST_TTL:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, u8_t, NETCONN_UDP);
  11541c:	e59b3004 	ldr	r3, [fp, #4]
  115420:	e3530000 	cmp	r3, #0
  115424:	1a000001 	bne	115430 <lwip_setsockopt_impl+0x4b0>
  115428:	e3a03016 	mov	r3, #22
  11542c:	ea00012d 	b	1158e8 <lwip_setsockopt_impl+0x968>
  115430:	e51b300c 	ldr	r3, [fp, #-12]
  115434:	e5933000 	ldr	r3, [r3]
  115438:	e3530000 	cmp	r3, #0
  11543c:	0a000004 	beq	115454 <lwip_setsockopt_impl+0x4d4>
  115440:	e51b300c 	ldr	r3, [fp, #-12]
  115444:	e5933000 	ldr	r3, [r3]
  115448:	e5933008 	ldr	r3, [r3, #8]
  11544c:	e3530000 	cmp	r3, #0
  115450:	1a000001 	bne	11545c <lwip_setsockopt_impl+0x4dc>
  115454:	e3a03016 	mov	r3, #22
  115458:	ea000122 	b	1158e8 <lwip_setsockopt_impl+0x968>
  11545c:	e51b300c 	ldr	r3, [fp, #-12]
  115460:	e5933000 	ldr	r3, [r3]
  115464:	e5933000 	ldr	r3, [r3]
  115468:	e20330f0 	and	r3, r3, #240	; 0xf0
  11546c:	e3530020 	cmp	r3, #32
  115470:	0a000001 	beq	11547c <lwip_setsockopt_impl+0x4fc>
  115474:	e3a0305c 	mov	r3, #92	; 0x5c
  115478:	ea00011a 	b	1158e8 <lwip_setsockopt_impl+0x968>
      udp_set_multicast_ttl(sock->conn->pcb.udp, (u8_t)(*(const u8_t*)optval));
  11547c:	e51b300c 	ldr	r3, [fp, #-12]
  115480:	e5933000 	ldr	r3, [r3]
  115484:	e5933008 	ldr	r3, [r3, #8]
  115488:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  11548c:	e5d22000 	ldrb	r2, [r2]
  115490:	e5c3201c 	strb	r2, [r3, #28]
      break;
  115494:	ea0000a0 	b	11571c <lwip_setsockopt_impl+0x79c>
    case IP_MULTICAST_IF:
      {
        ip4_addr_t if_addr;
        LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, struct in_addr, NETCONN_UDP);
  115498:	e59b3004 	ldr	r3, [fp, #4]
  11549c:	e3530003 	cmp	r3, #3
  1154a0:	8a000001 	bhi	1154ac <lwip_setsockopt_impl+0x52c>
  1154a4:	e3a03016 	mov	r3, #22
  1154a8:	ea00010e 	b	1158e8 <lwip_setsockopt_impl+0x968>
  1154ac:	e51b300c 	ldr	r3, [fp, #-12]
  1154b0:	e5933000 	ldr	r3, [r3]
  1154b4:	e3530000 	cmp	r3, #0
  1154b8:	0a000004 	beq	1154d0 <lwip_setsockopt_impl+0x550>
  1154bc:	e51b300c 	ldr	r3, [fp, #-12]
  1154c0:	e5933000 	ldr	r3, [r3]
  1154c4:	e5933008 	ldr	r3, [r3, #8]
  1154c8:	e3530000 	cmp	r3, #0
  1154cc:	1a000001 	bne	1154d8 <lwip_setsockopt_impl+0x558>
  1154d0:	e3a03016 	mov	r3, #22
  1154d4:	ea000103 	b	1158e8 <lwip_setsockopt_impl+0x968>
  1154d8:	e51b300c 	ldr	r3, [fp, #-12]
  1154dc:	e5933000 	ldr	r3, [r3]
  1154e0:	e5933000 	ldr	r3, [r3]
  1154e4:	e20330f0 	and	r3, r3, #240	; 0xf0
  1154e8:	e3530020 	cmp	r3, #32
  1154ec:	0a000001 	beq	1154f8 <lwip_setsockopt_impl+0x578>
  1154f0:	e3a0305c 	mov	r3, #92	; 0x5c
  1154f4:	ea0000fb 	b	1158e8 <lwip_setsockopt_impl+0x968>
        inet_addr_to_ip4addr(&if_addr, (const struct in_addr*)optval);
  1154f8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1154fc:	e5933000 	ldr	r3, [r3]
  115500:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        udp_set_multicast_netif_addr(sock->conn->pcb.udp, &if_addr);
  115504:	e51b300c 	ldr	r3, [fp, #-12]
  115508:	e5933000 	ldr	r3, [r3]
  11550c:	e5933008 	ldr	r3, [r3, #8]
  115510:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  115514:	e5832018 	str	r2, [r3, #24]
      }
      break;
  115518:	ea00007f 	b	11571c <lwip_setsockopt_impl+0x79c>
    case IP_MULTICAST_LOOP:
      LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, u8_t, NETCONN_UDP);
  11551c:	e59b3004 	ldr	r3, [fp, #4]
  115520:	e3530000 	cmp	r3, #0
  115524:	1a000001 	bne	115530 <lwip_setsockopt_impl+0x5b0>
  115528:	e3a03016 	mov	r3, #22
  11552c:	ea0000ed 	b	1158e8 <lwip_setsockopt_impl+0x968>
  115530:	e51b300c 	ldr	r3, [fp, #-12]
  115534:	e5933000 	ldr	r3, [r3]
  115538:	e3530000 	cmp	r3, #0
  11553c:	0a000004 	beq	115554 <lwip_setsockopt_impl+0x5d4>
  115540:	e51b300c 	ldr	r3, [fp, #-12]
  115544:	e5933000 	ldr	r3, [r3]
  115548:	e5933008 	ldr	r3, [r3, #8]
  11554c:	e3530000 	cmp	r3, #0
  115550:	1a000001 	bne	11555c <lwip_setsockopt_impl+0x5dc>
  115554:	e3a03016 	mov	r3, #22
  115558:	ea0000e2 	b	1158e8 <lwip_setsockopt_impl+0x968>
  11555c:	e51b300c 	ldr	r3, [fp, #-12]
  115560:	e5933000 	ldr	r3, [r3]
  115564:	e5933000 	ldr	r3, [r3]
  115568:	e20330f0 	and	r3, r3, #240	; 0xf0
  11556c:	e3530020 	cmp	r3, #32
  115570:	0a000001 	beq	11557c <lwip_setsockopt_impl+0x5fc>
  115574:	e3a0305c 	mov	r3, #92	; 0x5c
  115578:	ea0000da 	b	1158e8 <lwip_setsockopt_impl+0x968>
      if (*(const u8_t*)optval) {
  11557c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  115580:	e5d33000 	ldrb	r3, [r3]
  115584:	e3530000 	cmp	r3, #0
  115588:	0a00000a 	beq	1155b8 <lwip_setsockopt_impl+0x638>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_MULTICAST_LOOP);
  11558c:	e51b300c 	ldr	r3, [fp, #-12]
  115590:	e5933000 	ldr	r3, [r3]
  115594:	e5933008 	ldr	r3, [r3, #8]
  115598:	e5d32010 	ldrb	r2, [r3, #16]
  11559c:	e51b300c 	ldr	r3, [fp, #-12]
  1155a0:	e5933000 	ldr	r3, [r3]
  1155a4:	e5933008 	ldr	r3, [r3, #8]
  1155a8:	e3822008 	orr	r2, r2, #8
  1155ac:	e6ef2072 	uxtb	r2, r2
  1155b0:	e5c32010 	strb	r2, [r3, #16]
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_MULTICAST_LOOP);
      }
      break;
  1155b4:	ea000058 	b	11571c <lwip_setsockopt_impl+0x79c>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_MULTICAST_LOOP);
  1155b8:	e51b300c 	ldr	r3, [fp, #-12]
  1155bc:	e5933000 	ldr	r3, [r3]
  1155c0:	e5933008 	ldr	r3, [r3, #8]
  1155c4:	e5d32010 	ldrb	r2, [r3, #16]
  1155c8:	e51b300c 	ldr	r3, [fp, #-12]
  1155cc:	e5933000 	ldr	r3, [r3]
  1155d0:	e5933008 	ldr	r3, [r3, #8]
  1155d4:	e3c22008 	bic	r2, r2, #8
  1155d8:	e6ef2072 	uxtb	r2, r2
  1155dc:	e5c32010 	strb	r2, [r3, #16]
      break;
  1155e0:	ea00004d 	b	11571c <lwip_setsockopt_impl+0x79c>
    case IP_DROP_MEMBERSHIP:
      {
        /* If this is a TCP or a RAW socket, ignore these options. */
        /* @todo: assign membership to this socket so that it is dropped when closing the socket */
        err_t igmp_err;
        const struct ip_mreq *imr = (const struct ip_mreq *)optval;
  1155e4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1155e8:	e50b3010 	str	r3, [fp, #-16]
        ip4_addr_t if_addr;
        ip4_addr_t multi_addr;
        LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, struct ip_mreq, NETCONN_UDP);
  1155ec:	e59b3004 	ldr	r3, [fp, #4]
  1155f0:	e3530007 	cmp	r3, #7
  1155f4:	8a000001 	bhi	115600 <lwip_setsockopt_impl+0x680>
  1155f8:	e3a03016 	mov	r3, #22
  1155fc:	ea0000b9 	b	1158e8 <lwip_setsockopt_impl+0x968>
  115600:	e51b300c 	ldr	r3, [fp, #-12]
  115604:	e5933000 	ldr	r3, [r3]
  115608:	e3530000 	cmp	r3, #0
  11560c:	0a000004 	beq	115624 <lwip_setsockopt_impl+0x6a4>
  115610:	e51b300c 	ldr	r3, [fp, #-12]
  115614:	e5933000 	ldr	r3, [r3]
  115618:	e5933008 	ldr	r3, [r3, #8]
  11561c:	e3530000 	cmp	r3, #0
  115620:	1a000001 	bne	11562c <lwip_setsockopt_impl+0x6ac>
  115624:	e3a03016 	mov	r3, #22
  115628:	ea0000ae 	b	1158e8 <lwip_setsockopt_impl+0x968>
  11562c:	e51b300c 	ldr	r3, [fp, #-12]
  115630:	e5933000 	ldr	r3, [r3]
  115634:	e5933000 	ldr	r3, [r3]
  115638:	e20330f0 	and	r3, r3, #240	; 0xf0
  11563c:	e3530020 	cmp	r3, #32
  115640:	0a000001 	beq	11564c <lwip_setsockopt_impl+0x6cc>
  115644:	e3a0305c 	mov	r3, #92	; 0x5c
  115648:	ea0000a6 	b	1158e8 <lwip_setsockopt_impl+0x968>
        inet_addr_to_ip4addr(&if_addr, &imr->imr_interface);
  11564c:	e51b3010 	ldr	r3, [fp, #-16]
  115650:	e5933004 	ldr	r3, [r3, #4]
  115654:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        inet_addr_to_ip4addr(&multi_addr, &imr->imr_multiaddr);
  115658:	e51b3010 	ldr	r3, [fp, #-16]
  11565c:	e5933000 	ldr	r3, [r3]
  115660:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
        if (optname == IP_ADD_MEMBERSHIP) {
  115664:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  115668:	e3530003 	cmp	r3, #3
  11566c:	1a000014 	bne	1156c4 <lwip_setsockopt_impl+0x744>
          if (!lwip_socket_register_membership(s, &if_addr, &multi_addr)) {
  115670:	e24b201c 	sub	r2, fp, #28
  115674:	e24b3018 	sub	r3, fp, #24
  115678:	e1a01003 	mov	r1, r3
  11567c:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  115680:	eb0001ba 	bl	115d70 <lwip_socket_register_membership>
  115684:	e1a03000 	mov	r3, r0
  115688:	e3530000 	cmp	r3, #0
  11568c:	1a000004 	bne	1156a4 <lwip_setsockopt_impl+0x724>
            /* cannot track membership (out of memory) */
            err = ENOMEM;
  115690:	e3a0300c 	mov	r3, #12
  115694:	e54b3005 	strb	r3, [fp, #-5]
            igmp_err = ERR_OK;
  115698:	e3a03000 	mov	r3, #0
  11569c:	e54b3006 	strb	r3, [fp, #-6]
  1156a0:	ea000013 	b	1156f4 <lwip_setsockopt_impl+0x774>
          } else {
            igmp_err = igmp_joingroup(&if_addr, &multi_addr);
  1156a4:	e24b201c 	sub	r2, fp, #28
  1156a8:	e24b3018 	sub	r3, fp, #24
  1156ac:	e1a01002 	mov	r1, r2
  1156b0:	e1a00003 	mov	r0, r3
  1156b4:	eb006c93 	bl	130908 <igmp_joingroup>
  1156b8:	e1a03000 	mov	r3, r0
  1156bc:	e54b3006 	strb	r3, [fp, #-6]
  1156c0:	ea00000b 	b	1156f4 <lwip_setsockopt_impl+0x774>
          }
        } else {
          igmp_err = igmp_leavegroup(&if_addr, &multi_addr);
  1156c4:	e24b201c 	sub	r2, fp, #28
  1156c8:	e24b3018 	sub	r3, fp, #24
  1156cc:	e1a01002 	mov	r1, r2
  1156d0:	e1a00003 	mov	r0, r3
  1156d4:	eb006d44 	bl	130bec <igmp_leavegroup>
  1156d8:	e1a03000 	mov	r3, r0
  1156dc:	e54b3006 	strb	r3, [fp, #-6]
          lwip_socket_unregister_membership(s, &if_addr, &multi_addr);
  1156e0:	e24b201c 	sub	r2, fp, #28
  1156e4:	e24b3018 	sub	r3, fp, #24
  1156e8:	e1a01003 	mov	r1, r3
  1156ec:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  1156f0:	eb0001e0 	bl	115e78 <lwip_socket_unregister_membership>
        }
        if (igmp_err != ERR_OK) {
  1156f4:	e15b30d6 	ldrsb	r3, [fp, #-6]
  1156f8:	e3530000 	cmp	r3, #0
  1156fc:	0a000005 	beq	115718 <lwip_setsockopt_impl+0x798>
          err = EADDRNOTAVAIL;
  115700:	e3a03063 	mov	r3, #99	; 0x63
  115704:	e54b3005 	strb	r3, [fp, #-5]
        }
      }
      break;
  115708:	ea000002 	b	115718 <lwip_setsockopt_impl+0x798>
#endif /* LWIP_IGMP */
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  11570c:	e3a0305c 	mov	r3, #92	; 0x5c
  115710:	e54b3005 	strb	r3, [fp, #-5]
      break;
  115714:	ea000000 	b	11571c <lwip_setsockopt_impl+0x79c>
      break;
  115718:	e320f000 	nop	{0}
    }  /* switch (optname) */
    break;
  11571c:	ea000070 	b	1158e4 <lwip_setsockopt_impl+0x964>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    /* Special case: all IPPROTO_TCP option take an int */
    LWIP_SOCKOPT_CHECK_OPTLEN_CONN_PCB_TYPE(sock, optlen, int, NETCONN_TCP);
  115720:	e59b3004 	ldr	r3, [fp, #4]
  115724:	e3530003 	cmp	r3, #3
  115728:	8a000001 	bhi	115734 <lwip_setsockopt_impl+0x7b4>
  11572c:	e3a03016 	mov	r3, #22
  115730:	ea00006c 	b	1158e8 <lwip_setsockopt_impl+0x968>
  115734:	e51b300c 	ldr	r3, [fp, #-12]
  115738:	e5933000 	ldr	r3, [r3]
  11573c:	e3530000 	cmp	r3, #0
  115740:	0a000004 	beq	115758 <lwip_setsockopt_impl+0x7d8>
  115744:	e51b300c 	ldr	r3, [fp, #-12]
  115748:	e5933000 	ldr	r3, [r3]
  11574c:	e5933008 	ldr	r3, [r3, #8]
  115750:	e3530000 	cmp	r3, #0
  115754:	1a000001 	bne	115760 <lwip_setsockopt_impl+0x7e0>
  115758:	e3a03016 	mov	r3, #22
  11575c:	ea000061 	b	1158e8 <lwip_setsockopt_impl+0x968>
  115760:	e51b300c 	ldr	r3, [fp, #-12]
  115764:	e5933000 	ldr	r3, [r3]
  115768:	e5933000 	ldr	r3, [r3]
  11576c:	e20330f0 	and	r3, r3, #240	; 0xf0
  115770:	e3530010 	cmp	r3, #16
  115774:	0a000001 	beq	115780 <lwip_setsockopt_impl+0x800>
  115778:	e3a0305c 	mov	r3, #92	; 0x5c
  11577c:	ea000059 	b	1158e8 <lwip_setsockopt_impl+0x968>
    if (sock->conn->pcb.tcp->state == LISTEN) {
  115780:	e51b300c 	ldr	r3, [fp, #-12]
  115784:	e5933000 	ldr	r3, [r3]
  115788:	e5933008 	ldr	r3, [r3, #8]
  11578c:	e5933014 	ldr	r3, [r3, #20]
  115790:	e3530001 	cmp	r3, #1
  115794:	1a000001 	bne	1157a0 <lwip_setsockopt_impl+0x820>
      return EINVAL;
  115798:	e3a03016 	mov	r3, #22
  11579c:	ea000051 	b	1158e8 <lwip_setsockopt_impl+0x968>
    }
    switch (optname) {
  1157a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1157a4:	e2433001 	sub	r3, r3, #1
  1157a8:	e3530004 	cmp	r3, #4
  1157ac:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  1157b0:	ea000040 	b	1158b8 <lwip_setsockopt_impl+0x938>
  1157b4:	001157c8 	.word	0x001157c8
  1157b8:	00115830 	.word	0x00115830
  1157bc:	0011584c 	.word	0x0011584c
  1157c0:	00115874 	.word	0x00115874
  1157c4:	0011589c 	.word	0x0011589c
    case TCP_NODELAY:
      if (*(const int*)optval) {
  1157c8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1157cc:	e5933000 	ldr	r3, [r3]
  1157d0:	e3530000 	cmp	r3, #0
  1157d4:	0a00000a 	beq	115804 <lwip_setsockopt_impl+0x884>
        tcp_nagle_disable(sock->conn->pcb.tcp);
  1157d8:	e51b300c 	ldr	r3, [fp, #-12]
  1157dc:	e5933000 	ldr	r3, [r3]
  1157e0:	e5933008 	ldr	r3, [r3, #8]
  1157e4:	e5d3201e 	ldrb	r2, [r3, #30]
  1157e8:	e51b300c 	ldr	r3, [fp, #-12]
  1157ec:	e5933000 	ldr	r3, [r3]
  1157f0:	e5933008 	ldr	r3, [r3, #8]
  1157f4:	e3822040 	orr	r2, r2, #64	; 0x40
  1157f8:	e6ef2072 	uxtb	r2, r2
  1157fc:	e5c3201e 	strb	r2, [r3, #30]
      } else {
        tcp_nagle_enable(sock->conn->pcb.tcp);
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(const int *)optval)?"on":"off") );
      break;
  115800:	ea00002f 	b	1158c4 <lwip_setsockopt_impl+0x944>
        tcp_nagle_enable(sock->conn->pcb.tcp);
  115804:	e51b300c 	ldr	r3, [fp, #-12]
  115808:	e5933000 	ldr	r3, [r3]
  11580c:	e5933008 	ldr	r3, [r3, #8]
  115810:	e5d3201e 	ldrb	r2, [r3, #30]
  115814:	e51b300c 	ldr	r3, [fp, #-12]
  115818:	e5933000 	ldr	r3, [r3]
  11581c:	e5933008 	ldr	r3, [r3, #8]
  115820:	e3c22040 	bic	r2, r2, #64	; 0x40
  115824:	e6ef2072 	uxtb	r2, r2
  115828:	e5c3201e 	strb	r2, [r3, #30]
      break;
  11582c:	ea000024 	b	1158c4 <lwip_setsockopt_impl+0x944>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(const int*)optval);
  115830:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  115834:	e5932000 	ldr	r2, [r3]
  115838:	e51b300c 	ldr	r3, [fp, #-12]
  11583c:	e5933000 	ldr	r3, [r3]
  115840:	e5933008 	ldr	r3, [r3, #8]
  115844:	e5832094 	str	r2, [r3, #148]	; 0x94
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
  115848:	ea00001d 	b	1158c4 <lwip_setsockopt_impl+0x944>

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      sock->conn->pcb.tcp->keep_idle = 1000*(u32_t)(*(const int*)optval);
  11584c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  115850:	e5933000 	ldr	r3, [r3]
  115854:	e1a01003 	mov	r1, r3
  115858:	e51b300c 	ldr	r3, [fp, #-12]
  11585c:	e5933000 	ldr	r3, [r3]
  115860:	e5933008 	ldr	r3, [r3, #8]
  115864:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  115868:	e0020192 	mul	r2, r2, r1
  11586c:	e5832094 	str	r2, [r3, #148]	; 0x94
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
  115870:	ea000013 	b	1158c4 <lwip_setsockopt_impl+0x944>
    case TCP_KEEPINTVL:
      sock->conn->pcb.tcp->keep_intvl = 1000*(u32_t)(*(const int*)optval);
  115874:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  115878:	e5933000 	ldr	r3, [r3]
  11587c:	e1a01003 	mov	r1, r3
  115880:	e51b300c 	ldr	r3, [fp, #-12]
  115884:	e5933000 	ldr	r3, [r3]
  115888:	e5933008 	ldr	r3, [r3, #8]
  11588c:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  115890:	e0020192 	mul	r2, r2, r1
  115894:	e5832098 	str	r2, [r3, #152]	; 0x98
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_intvl));
      break;
  115898:	ea000009 	b	1158c4 <lwip_setsockopt_impl+0x944>
    case TCP_KEEPCNT:
      sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(const int*)optval);
  11589c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1158a0:	e5932000 	ldr	r2, [r3]
  1158a4:	e51b300c 	ldr	r3, [fp, #-12]
  1158a8:	e5933000 	ldr	r3, [r3]
  1158ac:	e5933008 	ldr	r3, [r3, #8]
  1158b0:	e583209c 	str	r2, [r3, #156]	; 0x9c
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
  1158b4:	ea000002 	b	1158c4 <lwip_setsockopt_impl+0x944>
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  1158b8:	e3a0305c 	mov	r3, #92	; 0x5c
  1158bc:	e54b3005 	strb	r3, [fp, #-5]
      break;
  1158c0:	e320f000 	nop	{0}
    }  /* switch (optname) */
    break;
  1158c4:	ea000006 	b	1158e4 <lwip_setsockopt_impl+0x964>
      break;
#endif /* LWIP_IPV6 && LWIP_RAW */
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_RAW, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  1158c8:	e3a0305c 	mov	r3, #92	; 0x5c
  1158cc:	e54b3005 	strb	r3, [fp, #-5]
      break;
  1158d0:	e320f000 	nop	{0}
    }  /* switch (optname) */
    break;
  1158d4:	ea000002 	b	1158e4 <lwip_setsockopt_impl+0x964>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  1158d8:	e3a0305c 	mov	r3, #92	; 0x5c
  1158dc:	e54b3005 	strb	r3, [fp, #-5]
    break;
  1158e0:	e320f000 	nop	{0}
  }  /* switch (level) */

  return err;
  1158e4:	e55b3005 	ldrb	r3, [fp, #-5]
}
  1158e8:	e1a00003 	mov	r0, r3
  1158ec:	e24bd004 	sub	sp, fp, #4
  1158f0:	e8bd8800 	pop	{fp, pc}

001158f4 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  1158f4:	e92d4800 	push	{fp, lr}
  1158f8:	e28db004 	add	fp, sp, #4
  1158fc:	e24dd038 	sub	sp, sp, #56	; 0x38
  115900:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  115904:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
  115908:	e50b2038 	str	r2, [fp, #-56]	; 0xffffffc8
  struct lwip_sock *sock = get_socket(s);
  11590c:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  115910:	ebffee03 	bl	111124 <get_socket>
  115914:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  u8_t val;
#if LWIP_SO_RCVBUF
  u16_t buflen = 0;
  115918:	e3a03000 	mov	r3, #0
  11591c:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  if (!sock) {
  115920:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115924:	e3530000 	cmp	r3, #0
  115928:	1a000001 	bne	115934 <lwip_ioctl+0x40>
    return -1;
  11592c:	e3e03000 	mvn	r3, #0
  115930:	ea000093 	b	115b84 <lwip_ioctl+0x290>
  }

  switch (cmd) {
  115934:	e51b2034 	ldr	r2, [fp, #-52]	; 0xffffffcc
  115938:	e306367f 	movw	r3, #26239	; 0x667f
  11593c:	e3483004 	movt	r3, #32772	; 0x8004
  115940:	e1520003 	cmp	r2, r3
  115944:	0a00000e 	beq	115984 <lwip_ioctl+0x90>
  115948:	e306367e 	movw	r3, #26238	; 0x667e
  11594c:	e3443004 	movt	r3, #16388	; 0x4004
  115950:	e1520003 	cmp	r2, r3
  115954:	0a000057 	beq	115ab8 <lwip_ioctl+0x1c4>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
    sock_set_errno(sock, 0);
    return 0;

  default:
    break;
  115958:	e320f000 	nop	{0}
  } /* switch (cmd) */
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
  sock_set_errno(sock, ENOSYS); /* not yet implemented */
  11595c:	e3a03026 	mov	r3, #38	; 0x26
  115960:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  115964:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  115968:	e6ef2073 	uxtb	r2, r3
  11596c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115970:	e5c32010 	strb	r2, [r3, #16]
  115974:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  115978:	e3530000 	cmp	r3, #0
  11597c:	0a00007f 	beq	115b80 <lwip_ioctl+0x28c>
  115980:	ea00007a 	b	115b70 <lwip_ioctl+0x27c>
    if (!argp) {
  115984:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  115988:	e3530000 	cmp	r3, #0
  11598c:	1a00000e 	bne	1159cc <lwip_ioctl+0xd8>
      sock_set_errno(sock, EINVAL);
  115990:	e3a03016 	mov	r3, #22
  115994:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  115998:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11599c:	e6ef2073 	uxtb	r2, r3
  1159a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1159a4:	e5c32010 	strb	r2, [r3, #16]
  1159a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1159ac:	e3530000 	cmp	r3, #0
  1159b0:	0a000003 	beq	1159c4 <lwip_ioctl+0xd0>
  1159b4:	eb008dc7 	bl	1390d8 <__errno_location>
  1159b8:	e1a02000 	mov	r2, r0
  1159bc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1159c0:	e5823000 	str	r3, [r2]
      return -1;
  1159c4:	e3e03000 	mvn	r3, #0
  1159c8:	ea00006d 	b	115b84 <lwip_ioctl+0x290>
    SYS_ARCH_GET(sock->conn->recv_avail, recv_avail);
  1159cc:	ebffb21a 	bl	10223c <rt_enter_critical>
  1159d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1159d4:	e5933000 	ldr	r3, [r3]
  1159d8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  1159dc:	e50b300c 	str	r3, [fp, #-12]
  1159e0:	ebffb21b 	bl	102254 <rt_exit_critical>
    if (recv_avail < 0) {
  1159e4:	e51b300c 	ldr	r3, [fp, #-12]
  1159e8:	e3530000 	cmp	r3, #0
  1159ec:	aa000001 	bge	1159f8 <lwip_ioctl+0x104>
      recv_avail = 0;
  1159f0:	e3a03000 	mov	r3, #0
  1159f4:	e50b300c 	str	r3, [fp, #-12]
    *((int*)argp) = recv_avail;
  1159f8:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1159fc:	e51b200c 	ldr	r2, [fp, #-12]
  115a00:	e5832000 	str	r2, [r3]
    if (sock->lastdata) {
  115a04:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115a08:	e5933004 	ldr	r3, [r3, #4]
  115a0c:	e3530000 	cmp	r3, #0
  115a10:	0a000019 	beq	115a7c <lwip_ioctl+0x188>
      struct pbuf *p = (struct pbuf *)sock->lastdata;
  115a14:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115a18:	e5933004 	ldr	r3, [r3, #4]
  115a1c:	e50b3010 	str	r3, [fp, #-16]
      if (NETCONNTYPE_GROUP(netconn_type(sock->conn)) != NETCONN_TCP) {
  115a20:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115a24:	e5933000 	ldr	r3, [r3]
  115a28:	e5933000 	ldr	r3, [r3]
  115a2c:	e20330f0 	and	r3, r3, #240	; 0xf0
  115a30:	e3530010 	cmp	r3, #16
  115a34:	0a000002 	beq	115a44 <lwip_ioctl+0x150>
        p = ((struct netbuf *)p)->p;
  115a38:	e51b3010 	ldr	r3, [fp, #-16]
  115a3c:	e5933000 	ldr	r3, [r3]
  115a40:	e50b3010 	str	r3, [fp, #-16]
      buflen = p->tot_len;
  115a44:	e51b3010 	ldr	r3, [fp, #-16]
  115a48:	e1d330b8 	ldrh	r3, [r3, #8]
  115a4c:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
      buflen -= sock->lastoffset;
  115a50:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115a54:	e1d330b8 	ldrh	r3, [r3, #8]
  115a58:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  115a5c:	e0423003 	sub	r3, r2, r3
  115a60:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
      *((int*)argp) += buflen;
  115a64:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  115a68:	e5932000 	ldr	r2, [r3]
  115a6c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  115a70:	e0822003 	add	r2, r2, r3
  115a74:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  115a78:	e5832000 	str	r2, [r3]
    sock_set_errno(sock, 0);
  115a7c:	e3a03000 	mov	r3, #0
  115a80:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  115a84:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  115a88:	e6ef2073 	uxtb	r2, r3
  115a8c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115a90:	e5c32010 	strb	r2, [r3, #16]
  115a94:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  115a98:	e3530000 	cmp	r3, #0
  115a9c:	0a000003 	beq	115ab0 <lwip_ioctl+0x1bc>
  115aa0:	eb008d8c 	bl	1390d8 <__errno_location>
  115aa4:	e1a02000 	mov	r2, r0
  115aa8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  115aac:	e5823000 	str	r3, [r2]
    return 0;
  115ab0:	e3a03000 	mov	r3, #0
  115ab4:	ea000032 	b	115b84 <lwip_ioctl+0x290>
    val = 0;
  115ab8:	e3a03000 	mov	r3, #0
  115abc:	e54b3005 	strb	r3, [fp, #-5]
    if (argp && *(u32_t*)argp) {
  115ac0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  115ac4:	e3530000 	cmp	r3, #0
  115ac8:	0a000005 	beq	115ae4 <lwip_ioctl+0x1f0>
  115acc:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  115ad0:	e5933000 	ldr	r3, [r3]
  115ad4:	e3530000 	cmp	r3, #0
  115ad8:	0a000001 	beq	115ae4 <lwip_ioctl+0x1f0>
      val = 1;
  115adc:	e3a03001 	mov	r3, #1
  115ae0:	e54b3005 	strb	r3, [fp, #-5]
    netconn_set_nonblocking(sock->conn, val);
  115ae4:	e55b3005 	ldrb	r3, [fp, #-5]
  115ae8:	e3530000 	cmp	r3, #0
  115aec:	0a000008 	beq	115b14 <lwip_ioctl+0x220>
  115af0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115af4:	e5933000 	ldr	r3, [r3]
  115af8:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
  115afc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115b00:	e5933000 	ldr	r3, [r3]
  115b04:	e3822002 	orr	r2, r2, #2
  115b08:	e6ef2072 	uxtb	r2, r2
  115b0c:	e5c32030 	strb	r2, [r3, #48]	; 0x30
  115b10:	ea000007 	b	115b34 <lwip_ioctl+0x240>
  115b14:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115b18:	e5933000 	ldr	r3, [r3]
  115b1c:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
  115b20:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115b24:	e5933000 	ldr	r3, [r3]
  115b28:	e3c22002 	bic	r2, r2, #2
  115b2c:	e6ef2072 	uxtb	r2, r2
  115b30:	e5c32030 	strb	r2, [r3, #48]	; 0x30
    sock_set_errno(sock, 0);
  115b34:	e3a03000 	mov	r3, #0
  115b38:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  115b3c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  115b40:	e6ef2073 	uxtb	r2, r3
  115b44:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115b48:	e5c32010 	strb	r2, [r3, #16]
  115b4c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  115b50:	e3530000 	cmp	r3, #0
  115b54:	0a000003 	beq	115b68 <lwip_ioctl+0x274>
  115b58:	eb008d5e 	bl	1390d8 <__errno_location>
  115b5c:	e1a02000 	mov	r2, r0
  115b60:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  115b64:	e5823000 	str	r3, [r2]
    return 0;
  115b68:	e3a03000 	mov	r3, #0
  115b6c:	ea000004 	b	115b84 <lwip_ioctl+0x290>
  sock_set_errno(sock, ENOSYS); /* not yet implemented */
  115b70:	eb008d58 	bl	1390d8 <__errno_location>
  115b74:	e1a02000 	mov	r2, r0
  115b78:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  115b7c:	e5823000 	str	r3, [r2]
  return -1;
  115b80:	e3e03000 	mvn	r3, #0
}
  115b84:	e1a00003 	mov	r0, r3
  115b88:	e24bd004 	sub	sp, fp, #4
  115b8c:	e8bd8800 	pop	{fp, pc}

00115b90 <lwip_fcntl>:
 * Currently only the commands F_GETFL and F_SETFL are implemented.
 * Only the flag O_NONBLOCK is implemented.
 */
int
lwip_fcntl(int s, int cmd, int val)
{
  115b90:	e92d4800 	push	{fp, lr}
  115b94:	e28db004 	add	fp, sp, #4
  115b98:	e24dd028 	sub	sp, sp, #40	; 0x28
  115b9c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  115ba0:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  115ba4:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  struct lwip_sock *sock = get_socket(s);
  115ba8:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  115bac:	ebffed5c 	bl	111124 <get_socket>
  115bb0:	e50b000c 	str	r0, [fp, #-12]
  int ret = -1;
  115bb4:	e3e03000 	mvn	r3, #0
  115bb8:	e50b3008 	str	r3, [fp, #-8]

  if (!sock) {
  115bbc:	e51b300c 	ldr	r3, [fp, #-12]
  115bc0:	e3530000 	cmp	r3, #0
  115bc4:	1a000001 	bne	115bd0 <lwip_fcntl+0x40>
    return -1;
  115bc8:	e3e03000 	mvn	r3, #0
  115bcc:	ea000064 	b	115d64 <lwip_fcntl+0x1d4>
  }

  switch (cmd) {
  115bd0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  115bd4:	e3530003 	cmp	r3, #3
  115bd8:	0a000002 	beq	115be8 <lwip_fcntl+0x58>
  115bdc:	e3530004 	cmp	r3, #4
  115be0:	0a000014 	beq	115c38 <lwip_fcntl+0xa8>
  115be4:	ea00004a 	b	115d14 <lwip_fcntl+0x184>
  case F_GETFL:
    ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
  115be8:	e51b300c 	ldr	r3, [fp, #-12]
  115bec:	e5933000 	ldr	r3, [r3]
  115bf0:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
  115bf4:	e1a03503 	lsl	r3, r3, #10
  115bf8:	e2033b02 	and	r3, r3, #2048	; 0x800
  115bfc:	e50b3008 	str	r3, [fp, #-8]
    sock_set_errno(sock, 0);
  115c00:	e3a03000 	mov	r3, #0
  115c04:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  115c08:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  115c0c:	e6ef2073 	uxtb	r2, r3
  115c10:	e51b300c 	ldr	r3, [fp, #-12]
  115c14:	e5c32010 	strb	r2, [r3, #16]
  115c18:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  115c1c:	e3530000 	cmp	r3, #0
  115c20:	0a000049 	beq	115d4c <lwip_fcntl+0x1bc>
  115c24:	eb008d2b 	bl	1390d8 <__errno_location>
  115c28:	e1a02000 	mov	r2, r0
  115c2c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  115c30:	e5823000 	str	r3, [r2]
    break;
  115c34:	ea000044 	b	115d4c <lwip_fcntl+0x1bc>
  case F_SETFL:
    if ((val & ~O_NONBLOCK) == 0) {
  115c38:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  115c3c:	e3c33b02 	bic	r3, r3, #2048	; 0x800
  115c40:	e3530000 	cmp	r3, #0
  115c44:	1a000024 	bne	115cdc <lwip_fcntl+0x14c>
      /* only O_NONBLOCK, all other bits are zero */
      netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
  115c48:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  115c4c:	e2033b02 	and	r3, r3, #2048	; 0x800
  115c50:	e3530000 	cmp	r3, #0
  115c54:	0a000008 	beq	115c7c <lwip_fcntl+0xec>
  115c58:	e51b300c 	ldr	r3, [fp, #-12]
  115c5c:	e5933000 	ldr	r3, [r3]
  115c60:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
  115c64:	e51b300c 	ldr	r3, [fp, #-12]
  115c68:	e5933000 	ldr	r3, [r3]
  115c6c:	e3822002 	orr	r2, r2, #2
  115c70:	e6ef2072 	uxtb	r2, r2
  115c74:	e5c32030 	strb	r2, [r3, #48]	; 0x30
  115c78:	ea000007 	b	115c9c <lwip_fcntl+0x10c>
  115c7c:	e51b300c 	ldr	r3, [fp, #-12]
  115c80:	e5933000 	ldr	r3, [r3]
  115c84:	e5d32030 	ldrb	r2, [r3, #48]	; 0x30
  115c88:	e51b300c 	ldr	r3, [fp, #-12]
  115c8c:	e5933000 	ldr	r3, [r3]
  115c90:	e3c22002 	bic	r2, r2, #2
  115c94:	e6ef2072 	uxtb	r2, r2
  115c98:	e5c32030 	strb	r2, [r3, #48]	; 0x30
      ret = 0;
  115c9c:	e3a03000 	mov	r3, #0
  115ca0:	e50b3008 	str	r3, [fp, #-8]
      sock_set_errno(sock, 0);
  115ca4:	e3a03000 	mov	r3, #0
  115ca8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  115cac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115cb0:	e6ef2073 	uxtb	r2, r3
  115cb4:	e51b300c 	ldr	r3, [fp, #-12]
  115cb8:	e5c32010 	strb	r2, [r3, #16]
  115cbc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115cc0:	e3530000 	cmp	r3, #0
  115cc4:	0a000022 	beq	115d54 <lwip_fcntl+0x1c4>
  115cc8:	eb008d02 	bl	1390d8 <__errno_location>
  115ccc:	e1a02000 	mov	r2, r0
  115cd0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115cd4:	e5823000 	str	r3, [r2]
    } else {
      sock_set_errno(sock, ENOSYS); /* not yet implemented */
    }
    break;
  115cd8:	ea00001d 	b	115d54 <lwip_fcntl+0x1c4>
      sock_set_errno(sock, ENOSYS); /* not yet implemented */
  115cdc:	e3a03026 	mov	r3, #38	; 0x26
  115ce0:	e50b3010 	str	r3, [fp, #-16]
  115ce4:	e51b3010 	ldr	r3, [fp, #-16]
  115ce8:	e6ef2073 	uxtb	r2, r3
  115cec:	e51b300c 	ldr	r3, [fp, #-12]
  115cf0:	e5c32010 	strb	r2, [r3, #16]
  115cf4:	e51b3010 	ldr	r3, [fp, #-16]
  115cf8:	e3530000 	cmp	r3, #0
  115cfc:	0a000014 	beq	115d54 <lwip_fcntl+0x1c4>
  115d00:	eb008cf4 	bl	1390d8 <__errno_location>
  115d04:	e1a02000 	mov	r2, r0
  115d08:	e51b3010 	ldr	r3, [fp, #-16]
  115d0c:	e5823000 	str	r3, [r2]
    break;
  115d10:	ea00000f 	b	115d54 <lwip_fcntl+0x1c4>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  115d14:	e3a03026 	mov	r3, #38	; 0x26
  115d18:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  115d1c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  115d20:	e6ef2073 	uxtb	r2, r3
  115d24:	e51b300c 	ldr	r3, [fp, #-12]
  115d28:	e5c32010 	strb	r2, [r3, #16]
  115d2c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  115d30:	e3530000 	cmp	r3, #0
  115d34:	0a000008 	beq	115d5c <lwip_fcntl+0x1cc>
  115d38:	eb008ce6 	bl	1390d8 <__errno_location>
  115d3c:	e1a02000 	mov	r2, r0
  115d40:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  115d44:	e5823000 	str	r3, [r2]
    break;
  115d48:	ea000003 	b	115d5c <lwip_fcntl+0x1cc>
    break;
  115d4c:	e320f000 	nop	{0}
  115d50:	ea000002 	b	115d60 <lwip_fcntl+0x1d0>
    break;
  115d54:	e320f000 	nop	{0}
  115d58:	ea000000 	b	115d60 <lwip_fcntl+0x1d0>
    break;
  115d5c:	e320f000 	nop	{0}
  }
  return ret;
  115d60:	e51b3008 	ldr	r3, [fp, #-8]
}
  115d64:	e1a00003 	mov	r0, r3
  115d68:	e24bd004 	sub	sp, fp, #4
  115d6c:	e8bd8800 	pop	{fp, pc}

00115d70 <lwip_socket_register_membership>:
 *
 * @return 1 on success, 0 on failure
 */
static int
lwip_socket_register_membership(int s, const ip4_addr_t *if_addr, const ip4_addr_t *multi_addr)
{
  115d70:	e92d4800 	push	{fp, lr}
  115d74:	e28db004 	add	fp, sp, #4
  115d78:	e24dd018 	sub	sp, sp, #24
  115d7c:	e50b0010 	str	r0, [fp, #-16]
  115d80:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  115d84:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  struct lwip_sock *sock = get_socket(s);
  115d88:	e51b0010 	ldr	r0, [fp, #-16]
  115d8c:	ebffece4 	bl	111124 <get_socket>
  115d90:	e50b000c 	str	r0, [fp, #-12]
  int i;

  if (!sock) {
  115d94:	e51b300c 	ldr	r3, [fp, #-12]
  115d98:	e3530000 	cmp	r3, #0
  115d9c:	1a000001 	bne	115da8 <lwip_socket_register_membership+0x38>
    return 0;
  115da0:	e3a03000 	mov	r3, #0
  115da4:	ea000030 	b	115e6c <lwip_socket_register_membership+0xfc>
  }

  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
  115da8:	e3a03000 	mov	r3, #0
  115dac:	e50b3008 	str	r3, [fp, #-8]
  115db0:	ea000029 	b	115e5c <lwip_socket_register_membership+0xec>
    if (socket_ipv4_multicast_memberships[i].sock == NULL) {
  115db4:	e3003584 	movw	r3, #1412	; 0x584
  115db8:	e3403015 	movt	r3, #21
  115dbc:	e51b2008 	ldr	r2, [fp, #-8]
  115dc0:	e3a0100c 	mov	r1, #12
  115dc4:	e0020291 	mul	r2, r1, r2
  115dc8:	e0833002 	add	r3, r3, r2
  115dcc:	e5933000 	ldr	r3, [r3]
  115dd0:	e3530000 	cmp	r3, #0
  115dd4:	1a00001d 	bne	115e50 <lwip_socket_register_membership+0xe0>
      socket_ipv4_multicast_memberships[i].sock = sock;
  115dd8:	e3003584 	movw	r3, #1412	; 0x584
  115ddc:	e3403015 	movt	r3, #21
  115de0:	e51b2008 	ldr	r2, [fp, #-8]
  115de4:	e3a0100c 	mov	r1, #12
  115de8:	e0020291 	mul	r2, r1, r2
  115dec:	e0833002 	add	r3, r3, r2
  115df0:	e51b200c 	ldr	r2, [fp, #-12]
  115df4:	e5832000 	str	r2, [r3]
      ip4_addr_copy(socket_ipv4_multicast_memberships[i].if_addr, *if_addr);
  115df8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115dfc:	e5932000 	ldr	r2, [r3]
  115e00:	e3003584 	movw	r3, #1412	; 0x584
  115e04:	e3403015 	movt	r3, #21
  115e08:	e51b1008 	ldr	r1, [fp, #-8]
  115e0c:	e3a0000c 	mov	r0, #12
  115e10:	e0010190 	mul	r1, r0, r1
  115e14:	e0833001 	add	r3, r3, r1
  115e18:	e2833004 	add	r3, r3, #4
  115e1c:	e5832000 	str	r2, [r3]
      ip4_addr_copy(socket_ipv4_multicast_memberships[i].multi_addr, *multi_addr);
  115e20:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  115e24:	e5932000 	ldr	r2, [r3]
  115e28:	e3003584 	movw	r3, #1412	; 0x584
  115e2c:	e3403015 	movt	r3, #21
  115e30:	e51b1008 	ldr	r1, [fp, #-8]
  115e34:	e3a0000c 	mov	r0, #12
  115e38:	e0010190 	mul	r1, r0, r1
  115e3c:	e0833001 	add	r3, r3, r1
  115e40:	e2833008 	add	r3, r3, #8
  115e44:	e5832000 	str	r2, [r3]
      return 1;
  115e48:	e3a03001 	mov	r3, #1
  115e4c:	ea000006 	b	115e6c <lwip_socket_register_membership+0xfc>
  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
  115e50:	e51b3008 	ldr	r3, [fp, #-8]
  115e54:	e2833001 	add	r3, r3, #1
  115e58:	e50b3008 	str	r3, [fp, #-8]
  115e5c:	e51b3008 	ldr	r3, [fp, #-8]
  115e60:	e3530007 	cmp	r3, #7
  115e64:	daffffd2 	ble	115db4 <lwip_socket_register_membership+0x44>
    }
  }
  return 0;
  115e68:	e3a03000 	mov	r3, #0
}
  115e6c:	e1a00003 	mov	r0, r3
  115e70:	e24bd004 	sub	sp, fp, #4
  115e74:	e8bd8800 	pop	{fp, pc}

00115e78 <lwip_socket_unregister_membership>:
 *
 * ATTENTION: this function is called from tcpip_thread (or under CORE_LOCK).
 */
static void
lwip_socket_unregister_membership(int s, const ip4_addr_t *if_addr, const ip4_addr_t *multi_addr)
{
  115e78:	e92d4800 	push	{fp, lr}
  115e7c:	e28db004 	add	fp, sp, #4
  115e80:	e24dd018 	sub	sp, sp, #24
  115e84:	e50b0010 	str	r0, [fp, #-16]
  115e88:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  115e8c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  struct lwip_sock *sock = get_socket(s);
  115e90:	e51b0010 	ldr	r0, [fp, #-16]
  115e94:	ebffeca2 	bl	111124 <get_socket>
  115e98:	e50b000c 	str	r0, [fp, #-12]
  int i;

  if (!sock) {
  115e9c:	e51b300c 	ldr	r3, [fp, #-12]
  115ea0:	e3530000 	cmp	r3, #0
  115ea4:	0a000046 	beq	115fc4 <lwip_socket_unregister_membership+0x14c>
    return;
  }

  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
  115ea8:	e3a03000 	mov	r3, #0
  115eac:	e50b3008 	str	r3, [fp, #-8]
  115eb0:	ea00003f 	b	115fb4 <lwip_socket_unregister_membership+0x13c>
    if ((socket_ipv4_multicast_memberships[i].sock == sock) &&
  115eb4:	e3003584 	movw	r3, #1412	; 0x584
  115eb8:	e3403015 	movt	r3, #21
  115ebc:	e51b2008 	ldr	r2, [fp, #-8]
  115ec0:	e3a0100c 	mov	r1, #12
  115ec4:	e0020291 	mul	r2, r1, r2
  115ec8:	e0833002 	add	r3, r3, r2
  115ecc:	e5933000 	ldr	r3, [r3]
  115ed0:	e51b200c 	ldr	r2, [fp, #-12]
  115ed4:	e1520003 	cmp	r2, r3
  115ed8:	1a000032 	bne	115fa8 <lwip_socket_unregister_membership+0x130>
        ip4_addr_cmp(&socket_ipv4_multicast_memberships[i].if_addr, if_addr) &&
  115edc:	e3003584 	movw	r3, #1412	; 0x584
  115ee0:	e3403015 	movt	r3, #21
  115ee4:	e51b2008 	ldr	r2, [fp, #-8]
  115ee8:	e3a0100c 	mov	r1, #12
  115eec:	e0020291 	mul	r2, r1, r2
  115ef0:	e0833002 	add	r3, r3, r2
  115ef4:	e2833004 	add	r3, r3, #4
  115ef8:	e5932000 	ldr	r2, [r3]
  115efc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  115f00:	e5933000 	ldr	r3, [r3]
    if ((socket_ipv4_multicast_memberships[i].sock == sock) &&
  115f04:	e1520003 	cmp	r2, r3
  115f08:	1a000026 	bne	115fa8 <lwip_socket_unregister_membership+0x130>
        ip4_addr_cmp(&socket_ipv4_multicast_memberships[i].multi_addr, multi_addr)) {
  115f0c:	e3003584 	movw	r3, #1412	; 0x584
  115f10:	e3403015 	movt	r3, #21
  115f14:	e51b2008 	ldr	r2, [fp, #-8]
  115f18:	e3a0100c 	mov	r1, #12
  115f1c:	e0020291 	mul	r2, r1, r2
  115f20:	e0833002 	add	r3, r3, r2
  115f24:	e2833008 	add	r3, r3, #8
  115f28:	e5932000 	ldr	r2, [r3]
  115f2c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  115f30:	e5933000 	ldr	r3, [r3]
        ip4_addr_cmp(&socket_ipv4_multicast_memberships[i].if_addr, if_addr) &&
  115f34:	e1520003 	cmp	r2, r3
  115f38:	1a00001a 	bne	115fa8 <lwip_socket_unregister_membership+0x130>
      socket_ipv4_multicast_memberships[i].sock = NULL;
  115f3c:	e3003584 	movw	r3, #1412	; 0x584
  115f40:	e3403015 	movt	r3, #21
  115f44:	e51b2008 	ldr	r2, [fp, #-8]
  115f48:	e3a0100c 	mov	r1, #12
  115f4c:	e0020291 	mul	r2, r1, r2
  115f50:	e0833002 	add	r3, r3, r2
  115f54:	e3a02000 	mov	r2, #0
  115f58:	e5832000 	str	r2, [r3]
      ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].if_addr);
  115f5c:	e3003584 	movw	r3, #1412	; 0x584
  115f60:	e3403015 	movt	r3, #21
  115f64:	e51b2008 	ldr	r2, [fp, #-8]
  115f68:	e3a0100c 	mov	r1, #12
  115f6c:	e0020291 	mul	r2, r1, r2
  115f70:	e0833002 	add	r3, r3, r2
  115f74:	e2833004 	add	r3, r3, #4
  115f78:	e3a02000 	mov	r2, #0
  115f7c:	e5832000 	str	r2, [r3]
      ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].multi_addr);
  115f80:	e3003584 	movw	r3, #1412	; 0x584
  115f84:	e3403015 	movt	r3, #21
  115f88:	e51b2008 	ldr	r2, [fp, #-8]
  115f8c:	e3a0100c 	mov	r1, #12
  115f90:	e0020291 	mul	r2, r1, r2
  115f94:	e0833002 	add	r3, r3, r2
  115f98:	e2833008 	add	r3, r3, #8
  115f9c:	e3a02000 	mov	r2, #0
  115fa0:	e5832000 	str	r2, [r3]
      return;
  115fa4:	ea000007 	b	115fc8 <lwip_socket_unregister_membership+0x150>
  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
  115fa8:	e51b3008 	ldr	r3, [fp, #-8]
  115fac:	e2833001 	add	r3, r3, #1
  115fb0:	e50b3008 	str	r3, [fp, #-8]
  115fb4:	e51b3008 	ldr	r3, [fp, #-8]
  115fb8:	e3530007 	cmp	r3, #7
  115fbc:	daffffbc 	ble	115eb4 <lwip_socket_unregister_membership+0x3c>
  115fc0:	ea000000 	b	115fc8 <lwip_socket_unregister_membership+0x150>
    return;
  115fc4:	e320f000 	nop	{0}
    }
  }
}
  115fc8:	e24bd004 	sub	sp, fp, #4
  115fcc:	e8bd8800 	pop	{fp, pc}

00115fd0 <lwip_socket_drop_registered_memberships>:
 *
 * ATTENTION: this function is NOT called from tcpip_thread (or under CORE_LOCK).
 */
static void
lwip_socket_drop_registered_memberships(int s)
{
  115fd0:	e92d4800 	push	{fp, lr}
  115fd4:	e28db004 	add	fp, sp, #4
  115fd8:	e24dd018 	sub	sp, sp, #24
  115fdc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct lwip_sock *sock = get_socket(s);
  115fe0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  115fe4:	ebffec4e 	bl	111124 <get_socket>
  115fe8:	e50b000c 	str	r0, [fp, #-12]
  int i;

  if (!sock) {
  115fec:	e51b300c 	ldr	r3, [fp, #-12]
  115ff0:	e3530000 	cmp	r3, #0
  115ff4:	0a000045 	beq	116110 <lwip_socket_drop_registered_memberships+0x140>
    return;
  }

  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
  115ff8:	e3a03000 	mov	r3, #0
  115ffc:	e50b3008 	str	r3, [fp, #-8]
  116000:	ea00003e 	b	116100 <lwip_socket_drop_registered_memberships+0x130>
    if (socket_ipv4_multicast_memberships[i].sock == sock) {
  116004:	e3003584 	movw	r3, #1412	; 0x584
  116008:	e3403015 	movt	r3, #21
  11600c:	e51b2008 	ldr	r2, [fp, #-8]
  116010:	e3a0100c 	mov	r1, #12
  116014:	e0020291 	mul	r2, r1, r2
  116018:	e0833002 	add	r3, r3, r2
  11601c:	e5933000 	ldr	r3, [r3]
  116020:	e51b200c 	ldr	r2, [fp, #-12]
  116024:	e1520003 	cmp	r2, r3
  116028:	1a000031 	bne	1160f4 <lwip_socket_drop_registered_memberships+0x124>
      ip_addr_t multi_addr, if_addr;
      ip_addr_copy_from_ip4(multi_addr, socket_ipv4_multicast_memberships[i].multi_addr);
  11602c:	e3003584 	movw	r3, #1412	; 0x584
  116030:	e3403015 	movt	r3, #21
  116034:	e51b2008 	ldr	r2, [fp, #-8]
  116038:	e3a0100c 	mov	r1, #12
  11603c:	e0020291 	mul	r2, r1, r2
  116040:	e0833002 	add	r3, r3, r2
  116044:	e2833008 	add	r3, r3, #8
  116048:	e5933000 	ldr	r3, [r3]
  11604c:	e50b3010 	str	r3, [fp, #-16]
      ip_addr_copy_from_ip4(if_addr, socket_ipv4_multicast_memberships[i].if_addr);
  116050:	e3003584 	movw	r3, #1412	; 0x584
  116054:	e3403015 	movt	r3, #21
  116058:	e51b2008 	ldr	r2, [fp, #-8]
  11605c:	e3a0100c 	mov	r1, #12
  116060:	e0020291 	mul	r2, r1, r2
  116064:	e0833002 	add	r3, r3, r2
  116068:	e2833004 	add	r3, r3, #4
  11606c:	e5933000 	ldr	r3, [r3]
  116070:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      socket_ipv4_multicast_memberships[i].sock = NULL;
  116074:	e3003584 	movw	r3, #1412	; 0x584
  116078:	e3403015 	movt	r3, #21
  11607c:	e51b2008 	ldr	r2, [fp, #-8]
  116080:	e3a0100c 	mov	r1, #12
  116084:	e0020291 	mul	r2, r1, r2
  116088:	e0833002 	add	r3, r3, r2
  11608c:	e3a02000 	mov	r2, #0
  116090:	e5832000 	str	r2, [r3]
      ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].if_addr);
  116094:	e3003584 	movw	r3, #1412	; 0x584
  116098:	e3403015 	movt	r3, #21
  11609c:	e51b2008 	ldr	r2, [fp, #-8]
  1160a0:	e3a0100c 	mov	r1, #12
  1160a4:	e0020291 	mul	r2, r1, r2
  1160a8:	e0833002 	add	r3, r3, r2
  1160ac:	e2833004 	add	r3, r3, #4
  1160b0:	e3a02000 	mov	r2, #0
  1160b4:	e5832000 	str	r2, [r3]
      ip4_addr_set_zero(&socket_ipv4_multicast_memberships[i].multi_addr);
  1160b8:	e3003584 	movw	r3, #1412	; 0x584
  1160bc:	e3403015 	movt	r3, #21
  1160c0:	e51b2008 	ldr	r2, [fp, #-8]
  1160c4:	e3a0100c 	mov	r1, #12
  1160c8:	e0020291 	mul	r2, r1, r2
  1160cc:	e0833002 	add	r3, r3, r2
  1160d0:	e2833008 	add	r3, r3, #8
  1160d4:	e3a02000 	mov	r2, #0
  1160d8:	e5832000 	str	r2, [r3]

      netconn_join_leave_group(sock->conn, &multi_addr, &if_addr, NETCONN_LEAVE);
  1160dc:	e51b300c 	ldr	r3, [fp, #-12]
  1160e0:	e5930000 	ldr	r0, [r3]
  1160e4:	e24b2014 	sub	r2, fp, #20
  1160e8:	e24b1010 	sub	r1, fp, #16
  1160ec:	e3a03001 	mov	r3, #1
  1160f0:	ebffd8dc 	bl	10c468 <netconn_join_leave_group>
  for (i = 0; i < LWIP_SOCKET_MAX_MEMBERSHIPS; i++) {
  1160f4:	e51b3008 	ldr	r3, [fp, #-8]
  1160f8:	e2833001 	add	r3, r3, #1
  1160fc:	e50b3008 	str	r3, [fp, #-8]
  116100:	e51b3008 	ldr	r3, [fp, #-8]
  116104:	e3530007 	cmp	r3, #7
  116108:	daffffbd 	ble	116004 <lwip_socket_drop_registered_memberships+0x34>
  11610c:	ea000000 	b	116114 <lwip_socket_drop_registered_memberships+0x144>
    return;
  116110:	e320f000 	nop	{0}
    }
  }
}
  116114:	e24bd004 	sub	sp, fp, #4
  116118:	e8bd8800 	pop	{fp, pc}

0011611c <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  11611c:	e92d4800 	push	{fp, lr}
  116120:	e28db004 	add	fp, sp, #4
  116124:	e24dd010 	sub	sp, sp, #16
  116128:	e50b0010 	str	r0, [fp, #-16]
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
  11612c:	e30e3c28 	movw	r3, #60456	; 0xec28
  116130:	e3403014 	movt	r3, #20
  116134:	e5933000 	ldr	r3, [r3]
  116138:	e3530000 	cmp	r3, #0
  11613c:	0a000007 	beq	116160 <tcpip_thread+0x44>
    tcpip_init_done(tcpip_init_done_arg);
  116140:	e30e3c28 	movw	r3, #60456	; 0xec28
  116144:	e3403014 	movt	r3, #20
  116148:	e5932000 	ldr	r2, [r3]
  11614c:	e30e3c2c 	movw	r3, #60460	; 0xec2c
  116150:	e3403014 	movt	r3, #20
  116154:	e5933000 	ldr	r3, [r3]
  116158:	e1a00003 	mov	r0, r3
  11615c:	e12fff32 	blx	r2
  }

  LOCK_TCPIP_CORE();
  116160:	e30005e4 	movw	r0, #1508	; 0x5e4
  116164:	e3400015 	movt	r0, #21
  116168:	ebffd1e2 	bl	10a8f8 <sys_mutex_lock>
  while (1) {                          /* MAIN Loop */
    UNLOCK_TCPIP_CORE();
  11616c:	e30005e4 	movw	r0, #1508	; 0x5e4
  116170:	e3400015 	movt	r0, #21
  116174:	ebffd1eb 	bl	10a928 <sys_mutex_unlock>
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    TCPIP_MBOX_FETCH(&mbox, (void **)&msg);
  116178:	e24b3008 	sub	r3, fp, #8
  11617c:	e1a01003 	mov	r1, r3
  116180:	e30e0c30 	movw	r0, #60464	; 0xec30
  116184:	e3400014 	movt	r0, #20
  116188:	eb004661 	bl	127b14 <sys_timeouts_mbox_fetch>
    LOCK_TCPIP_CORE();
  11618c:	e30005e4 	movw	r0, #1508	; 0x5e4
  116190:	e3400015 	movt	r0, #21
  116194:	ebffd1d7 	bl	10a8f8 <sys_mutex_lock>
    if (msg == NULL) {
  116198:	e51b3008 	ldr	r3, [fp, #-8]
  11619c:	e3530000 	cmp	r3, #0
  1161a0:	1a000007 	bne	1161c4 <tcpip_thread+0xa8>
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: NULL\n"));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
  1161a4:	e307019c 	movw	r0, #29084	; 0x719c
  1161a8:	e3400014 	movt	r0, #20
  1161ac:	ebffb3d8 	bl	103114 <rt_kprintf>
  1161b0:	e3a01069 	mov	r1, #105	; 0x69
  1161b4:	e30701bc 	movw	r0, #29116	; 0x71bc
  1161b8:	e3400014 	movt	r0, #20
  1161bc:	ebffd3ae 	bl	10b07c <sys_arch_assert>
      continue;
  1161c0:	ea00002e 	b	116280 <tcpip_thread+0x164>
    }
    switch (msg->type) {
  1161c4:	e51b3008 	ldr	r3, [fp, #-8]
  1161c8:	e5933000 	ldr	r3, [r3]
  1161cc:	e3530003 	cmp	r3, #3
  1161d0:	0a000010 	beq	116218 <tcpip_thread+0xfc>
  1161d4:	e3530004 	cmp	r3, #4
  1161d8:	0a000019 	beq	116244 <tcpip_thread+0x128>
  1161dc:	e3530002 	cmp	r3, #2
  1161e0:	1a00001e 	bne	116260 <tcpip_thread+0x144>
#endif /* !LWIP_TCPIP_CORE_LOCKING */

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
      msg->msg.inp.input_fn(msg->msg.inp.p, msg->msg.inp.netif);
  1161e4:	e51b3008 	ldr	r3, [fp, #-8]
  1161e8:	e593300c 	ldr	r3, [r3, #12]
  1161ec:	e51b2008 	ldr	r2, [fp, #-8]
  1161f0:	e5920004 	ldr	r0, [r2, #4]
  1161f4:	e51b2008 	ldr	r2, [fp, #-8]
  1161f8:	e5922008 	ldr	r2, [r2, #8]
  1161fc:	e1a01002 	mov	r1, r2
  116200:	e12fff33 	blx	r3
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  116204:	e51b3008 	ldr	r3, [fp, #-8]
  116208:	e1a01003 	mov	r1, r3
  11620c:	e3a0000a 	mov	r0, #10
  116210:	eb000c99 	bl	11947c <memp_free>
      break;
  116214:	ea000019 	b	116280 <tcpip_thread+0x164>
      break;
#endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
  116218:	e51b3008 	ldr	r3, [fp, #-8]
  11621c:	e5933004 	ldr	r3, [r3, #4]
  116220:	e51b2008 	ldr	r2, [fp, #-8]
  116224:	e5922008 	ldr	r2, [r2, #8]
  116228:	e1a00002 	mov	r0, r2
  11622c:	e12fff33 	blx	r3
      memp_free(MEMP_TCPIP_MSG_API, msg);
  116230:	e51b3008 	ldr	r3, [fp, #-8]
  116234:	e1a01003 	mov	r1, r3
  116238:	e3a00009 	mov	r0, #9
  11623c:	eb000c8e 	bl	11947c <memp_free>
      break;
  116240:	ea00000e 	b	116280 <tcpip_thread+0x164>

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
  116244:	e51b3008 	ldr	r3, [fp, #-8]
  116248:	e5933004 	ldr	r3, [r3, #4]
  11624c:	e51b2008 	ldr	r2, [fp, #-8]
  116250:	e5922008 	ldr	r2, [r2, #8]
  116254:	e1a00002 	mov	r0, r2
  116258:	e12fff33 	blx	r3
      break;
  11625c:	ea000007 	b	116280 <tcpip_thread+0x164>

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
  116260:	e307019c 	movw	r0, #29084	; 0x719c
  116264:	e3400014 	movt	r0, #20
  116268:	ebffb3a9 	bl	103114 <rt_kprintf>
  11626c:	e3a0109b 	mov	r1, #155	; 0x9b
  116270:	e30701bc 	movw	r0, #29116	; 0x71bc
  116274:	e3400014 	movt	r0, #20
  116278:	ebffd37f 	bl	10b07c <sys_arch_assert>
      break;
  11627c:	e320f000 	nop	{0}
    UNLOCK_TCPIP_CORE();
  116280:	eaffffb9 	b	11616c <tcpip_thread+0x50>

00116284 <tcpip_inpkt>:
 * @param inp the network interface on which the packet was received
 * @param input_fn input function to call
 */
err_t
tcpip_inpkt(struct pbuf *p, struct netif *inp, netif_input_fn input_fn)
{
  116284:	e92d4800 	push	{fp, lr}
  116288:	e28db004 	add	fp, sp, #4
  11628c:	e24dd018 	sub	sp, sp, #24
  116290:	e50b0010 	str	r0, [fp, #-16]
  116294:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  116298:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(mbox));
  11629c:	e30e0c30 	movw	r0, #60464	; 0xec30
  1162a0:	e3400014 	movt	r0, #20
  1162a4:	ebffd32b 	bl	10af58 <sys_mbox_valid>
  1162a8:	e1a03000 	mov	r3, r0
  1162ac:	e3530000 	cmp	r3, #0
  1162b0:	1a000006 	bne	1162d0 <tcpip_inpkt+0x4c>
  1162b4:	e30701e8 	movw	r0, #29160	; 0x71e8
  1162b8:	e3400014 	movt	r0, #20
  1162bc:	ebffb394 	bl	103114 <rt_kprintf>
  1162c0:	e3a010b5 	mov	r1, #181	; 0xb5
  1162c4:	e30701bc 	movw	r0, #29116	; 0x71bc
  1162c8:	e3400014 	movt	r0, #20
  1162cc:	ebffd36a 	bl	10b07c <sys_arch_assert>

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
  1162d0:	e3a020b7 	mov	r2, #183	; 0xb7
  1162d4:	e30711bc 	movw	r1, #29116	; 0x71bc
  1162d8:	e3401014 	movt	r1, #20
  1162dc:	e3a0000a 	mov	r0, #10
  1162e0:	eb000bfd 	bl	1192dc <memp_malloc_fn>
  1162e4:	e50b0008 	str	r0, [fp, #-8]
  if (msg == NULL) {
  1162e8:	e51b3008 	ldr	r3, [fp, #-8]
  1162ec:	e3530000 	cmp	r3, #0
  1162f0:	1a000001 	bne	1162fc <tcpip_inpkt+0x78>
    return ERR_MEM;
  1162f4:	e3e03000 	mvn	r3, #0
  1162f8:	ea000018 	b	116360 <tcpip_inpkt+0xdc>
  }

  msg->type = TCPIP_MSG_INPKT;
  1162fc:	e51b3008 	ldr	r3, [fp, #-8]
  116300:	e3a02002 	mov	r2, #2
  116304:	e5832000 	str	r2, [r3]
  msg->msg.inp.p = p;
  116308:	e51b3008 	ldr	r3, [fp, #-8]
  11630c:	e51b2010 	ldr	r2, [fp, #-16]
  116310:	e5832004 	str	r2, [r3, #4]
  msg->msg.inp.netif = inp;
  116314:	e51b3008 	ldr	r3, [fp, #-8]
  116318:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  11631c:	e5832008 	str	r2, [r3, #8]
  msg->msg.inp.input_fn = input_fn;
  116320:	e51b3008 	ldr	r3, [fp, #-8]
  116324:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  116328:	e583200c 	str	r2, [r3, #12]
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
  11632c:	e51b1008 	ldr	r1, [fp, #-8]
  116330:	e30e0c30 	movw	r0, #60464	; 0xec30
  116334:	e3400014 	movt	r0, #20
  116338:	ebffd2a8 	bl	10ade0 <sys_mbox_trypost>
  11633c:	e1a03000 	mov	r3, r0
  116340:	e3530000 	cmp	r3, #0
  116344:	0a000004 	beq	11635c <tcpip_inpkt+0xd8>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  116348:	e51b1008 	ldr	r1, [fp, #-8]
  11634c:	e3a0000a 	mov	r0, #10
  116350:	eb000c49 	bl	11947c <memp_free>
    return ERR_MEM;
  116354:	e3e03000 	mvn	r3, #0
  116358:	ea000000 	b	116360 <tcpip_inpkt+0xdc>
  }
  return ERR_OK;
  11635c:	e3a03000 	mov	r3, #0
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
  116360:	e1a00003 	mov	r0, r3
  116364:	e24bd004 	sub	sp, fp, #4
  116368:	e8bd8800 	pop	{fp, pc}

0011636c <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  11636c:	e92d4800 	push	{fp, lr}
  116370:	e28db004 	add	fp, sp, #4
  116374:	e24dd008 	sub	sp, sp, #8
  116378:	e50b0008 	str	r0, [fp, #-8]
  11637c:	e50b100c 	str	r1, [fp, #-12]
#if LWIP_ETHERNET
  if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
  116380:	e51b300c 	ldr	r3, [fp, #-12]
  116384:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  116388:	e2033018 	and	r3, r3, #24
  11638c:	e3530000 	cmp	r3, #0
  116390:	0a000006 	beq	1163b0 <tcpip_input+0x44>
    return tcpip_inpkt(p, inp, ethernet_input);
  116394:	e3082e00 	movw	r2, #36352	; 0x8e00
  116398:	e3402012 	movt	r2, #18
  11639c:	e51b100c 	ldr	r1, [fp, #-12]
  1163a0:	e51b0008 	ldr	r0, [fp, #-8]
  1163a4:	ebffffb6 	bl	116284 <tcpip_inpkt>
  1163a8:	e1a03000 	mov	r3, r0
  1163ac:	ea000005 	b	1163c8 <tcpip_input+0x5c>
  } else
#endif /* LWIP_ETHERNET */
  return tcpip_inpkt(p, inp, ip_input);
  1163b0:	e3012630 	movw	r2, #5680	; 0x1630
  1163b4:	e3402013 	movt	r2, #19
  1163b8:	e51b100c 	ldr	r1, [fp, #-12]
  1163bc:	e51b0008 	ldr	r0, [fp, #-8]
  1163c0:	ebffffaf 	bl	116284 <tcpip_inpkt>
  1163c4:	e1a03000 	mov	r3, r0
}
  1163c8:	e1a00003 	mov	r0, r3
  1163cc:	e24bd004 	sub	sp, fp, #4
  1163d0:	e8bd8800 	pop	{fp, pc}

001163d4 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
  1163d4:	e92d4800 	push	{fp, lr}
  1163d8:	e28db004 	add	fp, sp, #4
  1163dc:	e24dd018 	sub	sp, sp, #24
  1163e0:	e50b0010 	str	r0, [fp, #-16]
  1163e4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1163e8:	e1a03002 	mov	r3, r2
  1163ec:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(mbox));
  1163f0:	e30e0c30 	movw	r0, #60464	; 0xec30
  1163f4:	e3400014 	movt	r0, #20
  1163f8:	ebffd2d6 	bl	10af58 <sys_mbox_valid>
  1163fc:	e1a03000 	mov	r3, r0
  116400:	e3530000 	cmp	r3, #0
  116404:	1a000006 	bne	116424 <tcpip_callback_with_block+0x50>
  116408:	e30701e8 	movw	r0, #29160	; 0x71e8
  11640c:	e3400014 	movt	r0, #20
  116410:	ebffb33f 	bl	103114 <rt_kprintf>
  116414:	e3a010ee 	mov	r1, #238	; 0xee
  116418:	e30701bc 	movw	r0, #29116	; 0x71bc
  11641c:	e3400014 	movt	r0, #20
  116420:	ebffd315 	bl	10b07c <sys_arch_assert>

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
  116424:	e3a020f0 	mov	r2, #240	; 0xf0
  116428:	e30711bc 	movw	r1, #29116	; 0x71bc
  11642c:	e3401014 	movt	r1, #20
  116430:	e3a00009 	mov	r0, #9
  116434:	eb000ba8 	bl	1192dc <memp_malloc_fn>
  116438:	e50b0008 	str	r0, [fp, #-8]
  if (msg == NULL) {
  11643c:	e51b3008 	ldr	r3, [fp, #-8]
  116440:	e3530000 	cmp	r3, #0
  116444:	1a000001 	bne	116450 <tcpip_callback_with_block+0x7c>
    return ERR_MEM;
  116448:	e3e03000 	mvn	r3, #0
  11644c:	ea00001d 	b	1164c8 <tcpip_callback_with_block+0xf4>
  }

  msg->type = TCPIP_MSG_CALLBACK;
  116450:	e51b3008 	ldr	r3, [fp, #-8]
  116454:	e3a02003 	mov	r2, #3
  116458:	e5832000 	str	r2, [r3]
  msg->msg.cb.function = function;
  11645c:	e51b3008 	ldr	r3, [fp, #-8]
  116460:	e51b2010 	ldr	r2, [fp, #-16]
  116464:	e5832004 	str	r2, [r3, #4]
  msg->msg.cb.ctx = ctx;
  116468:	e51b3008 	ldr	r3, [fp, #-8]
  11646c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  116470:	e5832008 	str	r2, [r3, #8]
  if (block) {
  116474:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  116478:	e3530000 	cmp	r3, #0
  11647c:	0a000004 	beq	116494 <tcpip_callback_with_block+0xc0>
    sys_mbox_post(&mbox, msg);
  116480:	e51b1008 	ldr	r1, [fp, #-8]
  116484:	e30e0c30 	movw	r0, #60464	; 0xec30
  116488:	e3400014 	movt	r0, #20
  11648c:	ebffd248 	bl	10adb4 <sys_mbox_post>
  116490:	ea00000b 	b	1164c4 <tcpip_callback_with_block+0xf0>
  } else {
    if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
  116494:	e51b1008 	ldr	r1, [fp, #-8]
  116498:	e30e0c30 	movw	r0, #60464	; 0xec30
  11649c:	e3400014 	movt	r0, #20
  1164a0:	ebffd24e 	bl	10ade0 <sys_mbox_trypost>
  1164a4:	e1a03000 	mov	r3, r0
  1164a8:	e3530000 	cmp	r3, #0
  1164ac:	0a000004 	beq	1164c4 <tcpip_callback_with_block+0xf0>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  1164b0:	e51b1008 	ldr	r1, [fp, #-8]
  1164b4:	e3a00009 	mov	r0, #9
  1164b8:	eb000bef 	bl	11947c <memp_free>
      return ERR_MEM;
  1164bc:	e3e03000 	mvn	r3, #0
  1164c0:	ea000000 	b	1164c8 <tcpip_callback_with_block+0xf4>
    }
  }
  return ERR_OK;
  1164c4:	e3a03000 	mov	r3, #0
}
  1164c8:	e1a00003 	mov	r0, r3
  1164cc:	e24bd004 	sub	sp, fp, #4
  1164d0:	e8bd8800 	pop	{fp, pc}

001164d4 <tcpip_send_msg_wait_sem>:
 * @param sem semaphore to wait on
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_send_msg_wait_sem(tcpip_callback_fn fn, void *apimsg, sys_sem_t* sem)
{
  1164d4:	e92d4800 	push	{fp, lr}
  1164d8:	e28db004 	add	fp, sp, #4
  1164dc:	e24dd010 	sub	sp, sp, #16
  1164e0:	e50b0008 	str	r0, [fp, #-8]
  1164e4:	e50b100c 	str	r1, [fp, #-12]
  1164e8:	e50b2010 	str	r2, [fp, #-16]
#if LWIP_TCPIP_CORE_LOCKING
  LWIP_UNUSED_ARG(sem);
  LOCK_TCPIP_CORE();
  1164ec:	e30005e4 	movw	r0, #1508	; 0x5e4
  1164f0:	e3400015 	movt	r0, #21
  1164f4:	ebffd0ff 	bl	10a8f8 <sys_mutex_lock>
  fn(apimsg);
  1164f8:	e51b3008 	ldr	r3, [fp, #-8]
  1164fc:	e51b000c 	ldr	r0, [fp, #-12]
  116500:	e12fff33 	blx	r3
  UNLOCK_TCPIP_CORE();
  116504:	e30005e4 	movw	r0, #1508	; 0x5e4
  116508:	e3400015 	movt	r0, #21
  11650c:	ebffd105 	bl	10a928 <sys_mutex_unlock>
  return ERR_OK;
  116510:	e3a03000 	mov	r3, #0
  sys_mbox_post(&mbox, &TCPIP_MSG_VAR_REF(msg));
  sys_arch_sem_wait(sem, 0);
  TCPIP_MSG_VAR_FREE(msg);
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING */
}
  116514:	e1a00003 	mov	r0, r3
  116518:	e24bd004 	sub	sp, fp, #4
  11651c:	e8bd8800 	pop	{fp, pc}

00116520 <tcpip_api_call>:
 * @param call Call parameters
 * @return Return value from tcpip_api_call_fn
 */
err_t
tcpip_api_call(tcpip_api_call_fn fn, struct tcpip_api_call_data *call)
{
  116520:	e92d4800 	push	{fp, lr}
  116524:	e28db004 	add	fp, sp, #4
  116528:	e24dd010 	sub	sp, sp, #16
  11652c:	e50b0010 	str	r0, [fp, #-16]
  116530:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
#if LWIP_TCPIP_CORE_LOCKING
  err_t err;
  LOCK_TCPIP_CORE();
  116534:	e30005e4 	movw	r0, #1508	; 0x5e4
  116538:	e3400015 	movt	r0, #21
  11653c:	ebffd0ed 	bl	10a8f8 <sys_mutex_lock>
  err = fn(call);
  116540:	e51b3010 	ldr	r3, [fp, #-16]
  116544:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  116548:	e12fff33 	blx	r3
  11654c:	e1a03000 	mov	r3, r0
  116550:	e54b3005 	strb	r3, [fp, #-5]
  UNLOCK_TCPIP_CORE();
  116554:	e30005e4 	movw	r0, #1508	; 0x5e4
  116558:	e3400015 	movt	r0, #21
  11655c:	ebffd0f1 	bl	10a928 <sys_mutex_unlock>
  return err;
  116560:	e15b30d5 	ldrsb	r3, [fp, #-5]
  sys_sem_free(&call->sem);
#endif /* LWIP_NETCONN_SEM_PER_THREAD */

  return call->err;
#endif /* LWIP_TCPIP_CORE_LOCKING */
}
  116564:	e1a00003 	mov	r0, r3
  116568:	e24bd004 	sub	sp, fp, #4
  11656c:	e8bd8800 	pop	{fp, pc}

00116570 <tcpip_callbackmsg_new>:
 * @param ctx parameter passed to function
 * @return a struct pointer to pass to tcpip_trycallback().
 */
struct tcpip_callback_msg*
tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
{
  116570:	e92d4800 	push	{fp, lr}
  116574:	e28db004 	add	fp, sp, #4
  116578:	e24dd010 	sub	sp, sp, #16
  11657c:	e50b0010 	str	r0, [fp, #-16]
  116580:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
  116584:	e30021a1 	movw	r2, #417	; 0x1a1
  116588:	e30711bc 	movw	r1, #29116	; 0x71bc
  11658c:	e3401014 	movt	r1, #20
  116590:	e3a00009 	mov	r0, #9
  116594:	eb000b50 	bl	1192dc <memp_malloc_fn>
  116598:	e50b0008 	str	r0, [fp, #-8]
  if (msg == NULL) {
  11659c:	e51b3008 	ldr	r3, [fp, #-8]
  1165a0:	e3530000 	cmp	r3, #0
  1165a4:	1a000001 	bne	1165b0 <tcpip_callbackmsg_new+0x40>
    return NULL;
  1165a8:	e3a03000 	mov	r3, #0
  1165ac:	ea000009 	b	1165d8 <tcpip_callbackmsg_new+0x68>
  }
  msg->type = TCPIP_MSG_CALLBACK_STATIC;
  1165b0:	e51b3008 	ldr	r3, [fp, #-8]
  1165b4:	e3a02004 	mov	r2, #4
  1165b8:	e5832000 	str	r2, [r3]
  msg->msg.cb.function = function;
  1165bc:	e51b3008 	ldr	r3, [fp, #-8]
  1165c0:	e51b2010 	ldr	r2, [fp, #-16]
  1165c4:	e5832004 	str	r2, [r3, #4]
  msg->msg.cb.ctx = ctx;
  1165c8:	e51b3008 	ldr	r3, [fp, #-8]
  1165cc:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  1165d0:	e5832008 	str	r2, [r3, #8]
  return (struct tcpip_callback_msg*)msg;
  1165d4:	e51b3008 	ldr	r3, [fp, #-8]
}
  1165d8:	e1a00003 	mov	r0, r3
  1165dc:	e24bd004 	sub	sp, fp, #4
  1165e0:	e8bd8800 	pop	{fp, pc}

001165e4 <tcpip_callbackmsg_delete>:
 *
 * @param msg the message to free
 */
void
tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg)
{
  1165e4:	e92d4800 	push	{fp, lr}
  1165e8:	e28db004 	add	fp, sp, #4
  1165ec:	e24dd008 	sub	sp, sp, #8
  1165f0:	e50b0008 	str	r0, [fp, #-8]
  memp_free(MEMP_TCPIP_MSG_API, msg);
  1165f4:	e51b1008 	ldr	r1, [fp, #-8]
  1165f8:	e3a00009 	mov	r0, #9
  1165fc:	eb000b9e 	bl	11947c <memp_free>
}
  116600:	e320f000 	nop	{0}
  116604:	e24bd004 	sub	sp, fp, #4
  116608:	e8bd8800 	pop	{fp, pc}

0011660c <tcpip_trycallback>:
 * @param msg pointer to the message to post
 * @return sys_mbox_trypost() return code
 */
err_t
tcpip_trycallback(struct tcpip_callback_msg* msg)
{
  11660c:	e92d4800 	push	{fp, lr}
  116610:	e28db004 	add	fp, sp, #4
  116614:	e24dd008 	sub	sp, sp, #8
  116618:	e50b0008 	str	r0, [fp, #-8]
  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(mbox));
  11661c:	e30e0c30 	movw	r0, #60464	; 0xec30
  116620:	e3400014 	movt	r0, #20
  116624:	ebffd24b 	bl	10af58 <sys_mbox_valid>
  116628:	e1a03000 	mov	r3, r0
  11662c:	e3530000 	cmp	r3, #0
  116630:	1a000006 	bne	116650 <tcpip_trycallback+0x44>
  116634:	e30701e8 	movw	r0, #29160	; 0x71e8
  116638:	e3400014 	movt	r0, #20
  11663c:	ebffb2b4 	bl	103114 <rt_kprintf>
  116640:	e3a01d07 	mov	r1, #448	; 0x1c0
  116644:	e30701bc 	movw	r0, #29116	; 0x71bc
  116648:	e3400014 	movt	r0, #20
  11664c:	ebffd28a 	bl	10b07c <sys_arch_assert>
  return sys_mbox_trypost(&mbox, msg);
  116650:	e51b1008 	ldr	r1, [fp, #-8]
  116654:	e30e0c30 	movw	r0, #60464	; 0xec30
  116658:	e3400014 	movt	r0, #20
  11665c:	ebffd1df 	bl	10ade0 <sys_mbox_trypost>
  116660:	e1a03000 	mov	r3, r0
}
  116664:	e1a00003 	mov	r0, r3
  116668:	e24bd004 	sub	sp, fp, #4
  11666c:	e8bd8800 	pop	{fp, pc}

00116670 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
  116670:	e92d4800 	push	{fp, lr}
  116674:	e28db004 	add	fp, sp, #4
  116678:	e24dd010 	sub	sp, sp, #16
  11667c:	e50b0008 	str	r0, [fp, #-8]
  116680:	e50b100c 	str	r1, [fp, #-12]
  lwip_init();
  116684:	eb0009b8 	bl	118d6c <lwip_init>

  tcpip_init_done = initfunc;
  116688:	e30e3c28 	movw	r3, #60456	; 0xec28
  11668c:	e3403014 	movt	r3, #20
  116690:	e51b2008 	ldr	r2, [fp, #-8]
  116694:	e5832000 	str	r2, [r3]
  tcpip_init_done_arg = arg;
  116698:	e30e3c2c 	movw	r3, #60460	; 0xec2c
  11669c:	e3403014 	movt	r3, #20
  1166a0:	e51b200c 	ldr	r2, [fp, #-12]
  1166a4:	e5832000 	str	r2, [r3]
  if (sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
  1166a8:	e3001101 	movw	r1, #257	; 0x101
  1166ac:	e30e0c30 	movw	r0, #60464	; 0xec30
  1166b0:	e3400014 	movt	r0, #20
  1166b4:	ebffd124 	bl	10ab4c <sys_mbox_new>
  1166b8:	e1a03000 	mov	r3, r0
  1166bc:	e3530000 	cmp	r3, #0
  1166c0:	0a000006 	beq	1166e0 <tcpip_init+0x70>
    LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
  1166c4:	e30701f8 	movw	r0, #29176	; 0x71f8
  1166c8:	e3400014 	movt	r0, #20
  1166cc:	ebffb290 	bl	103114 <rt_kprintf>
  1166d0:	e30011d5 	movw	r1, #469	; 0x1d5
  1166d4:	e30701bc 	movw	r0, #29116	; 0x71bc
  1166d8:	e3400014 	movt	r0, #20
  1166dc:	ebffd266 	bl	10b07c <sys_arch_assert>
  }
#if LWIP_TCPIP_CORE_LOCKING
  if (sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
  1166e0:	e30005e4 	movw	r0, #1508	; 0x5e4
  1166e4:	e3400015 	movt	r0, #21
  1166e8:	ebffd05a 	bl	10a858 <sys_mutex_new>
  1166ec:	e1a03000 	mov	r3, r0
  1166f0:	e3530000 	cmp	r3, #0
  1166f4:	0a000006 	beq	116714 <tcpip_init+0xa4>
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  1166f8:	e307021c 	movw	r0, #29212	; 0x721c
  1166fc:	e3400014 	movt	r0, #20
  116700:	ebffb283 	bl	103114 <rt_kprintf>
  116704:	e30011d9 	movw	r1, #473	; 0x1d9
  116708:	e30701bc 	movw	r0, #29116	; 0x71bc
  11670c:	e3400014 	movt	r0, #20
  116710:	ebffd259 	bl	10b07c <sys_arch_assert>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  116714:	e3a03019 	mov	r3, #25
  116718:	e58d3000 	str	r3, [sp]
  11671c:	e3a03a02 	mov	r3, #8192	; 0x2000
  116720:	e3a02000 	mov	r2, #0
  116724:	e306111c 	movw	r1, #24860	; 0x611c
  116728:	e3401011 	movt	r1, #17
  11672c:	e3070240 	movw	r0, #29248	; 0x7240
  116730:	e3400014 	movt	r0, #20
  116734:	ebffd21c 	bl	10afac <sys_thread_new>
}
  116738:	e320f000 	nop	{0}
  11673c:	e24bd004 	sub	sp, fp, #4
  116740:	e8bd8800 	pop	{fp, pc}

00116744 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  116744:	e92d4800 	push	{fp, lr}
  116748:	e28db004 	add	fp, sp, #4
  11674c:	e24dd010 	sub	sp, sp, #16
  116750:	e50b0010 	str	r0, [fp, #-16]
  struct pbuf *q = (struct pbuf *)p;
  116754:	e51b3010 	ldr	r3, [fp, #-16]
  116758:	e50b3008 	str	r3, [fp, #-8]
  pbuf_free(q);
  11675c:	e51b0008 	ldr	r0, [fp, #-8]
  116760:	eb001253 	bl	11b0b4 <pbuf_free>
}
  116764:	e320f000 	nop	{0}
  116768:	e24bd004 	sub	sp, fp, #4
  11676c:	e8bd8800 	pop	{fp, pc}

00116770 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  116770:	e92d4800 	push	{fp, lr}
  116774:	e28db004 	add	fp, sp, #4
  116778:	e24dd008 	sub	sp, sp, #8
  11677c:	e50b0008 	str	r0, [fp, #-8]
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  116780:	e3a02000 	mov	r2, #0
  116784:	e51b1008 	ldr	r1, [fp, #-8]
  116788:	e3060744 	movw	r0, #26436	; 0x6744
  11678c:	e3400011 	movt	r0, #17
  116790:	ebffff0f 	bl	1163d4 <tcpip_callback_with_block>
  116794:	e1a03000 	mov	r3, r0
}
  116798:	e1a00003 	mov	r0, r3
  11679c:	e24bd004 	sub	sp, fp, #4
  1167a0:	e8bd8800 	pop	{fp, pc}

001167a4 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  1167a4:	e92d4800 	push	{fp, lr}
  1167a8:	e28db004 	add	fp, sp, #4
  1167ac:	e24dd008 	sub	sp, sp, #8
  1167b0:	e50b0008 	str	r0, [fp, #-8]
  return tcpip_callback_with_block(mem_free, m, 0);
  1167b4:	e3a02000 	mov	r2, #0
  1167b8:	e51b1008 	ldr	r1, [fp, #-8]
  1167bc:	e30b01b0 	movw	r0, #45488	; 0xb1b0
  1167c0:	e3400010 	movt	r0, #16
  1167c4:	ebffff02 	bl	1163d4 <tcpip_callback_with_block>
  1167c8:	e1a03000 	mov	r3, r0
}
  1167cc:	e1a00003 	mov	r0, r3
  1167d0:	e24bd004 	sub	sp, fp, #4
  1167d4:	e8bd8800 	pop	{fp, pc}

001167d8 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  1167d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1167dc:	e28db000 	add	fp, sp, #0
  1167e0:	e24dd00c 	sub	sp, sp, #12
  1167e4:	e1a03000 	mov	r3, r0
  1167e8:	e14b30b6 	strh	r3, [fp, #-6]
  return (u16_t)PP_HTONS(n);
  1167ec:	e15b30b6 	ldrh	r3, [fp, #-6]
  1167f0:	e6bf3fb3 	rev16	r3, r3
  1167f4:	e6ff3073 	uxth	r3, r3
}
  1167f8:	e1a00003 	mov	r0, r3
  1167fc:	e28bd000 	add	sp, fp, #0
  116800:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  116804:	e12fff1e 	bx	lr

00116808 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
  116808:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11680c:	e28db000 	add	fp, sp, #0
  116810:	e24dd00c 	sub	sp, sp, #12
  116814:	e50b0008 	str	r0, [fp, #-8]
  return (u32_t)PP_HTONL(n);
  116818:	e51b3008 	ldr	r3, [fp, #-8]
  11681c:	e1a02c03 	lsl	r2, r3, #24
  116820:	e51b3008 	ldr	r3, [fp, #-8]
  116824:	e1a03403 	lsl	r3, r3, #8
  116828:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
  11682c:	e1822003 	orr	r2, r2, r3
  116830:	e51b3008 	ldr	r3, [fp, #-8]
  116834:	e1a03423 	lsr	r3, r3, #8
  116838:	e2033cff 	and	r3, r3, #65280	; 0xff00
  11683c:	e1822003 	orr	r2, r2, r3
  116840:	e51b3008 	ldr	r3, [fp, #-8]
  116844:	e1a03c23 	lsr	r3, r3, #24
  116848:	e1823003 	orr	r3, r2, r3
}
  11684c:	e1a00003 	mov	r0, r3
  116850:	e28bd000 	add	sp, fp, #0
  116854:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  116858:	e12fff1e 	bx	lr

0011685c <lwip_strnstr>:
 * lwIP default implementation for strnstr() non-standard function.
 * This can be \#defined to strnstr() depending on your platform port.
 */
char*
lwip_strnstr(const char* buffer, const char* token, size_t n)
{
  11685c:	e92d4800 	push	{fp, lr}
  116860:	e28db004 	add	fp, sp, #4
  116864:	e24dd018 	sub	sp, sp, #24
  116868:	e50b0010 	str	r0, [fp, #-16]
  11686c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  116870:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  const char* p;
  size_t tokenlen = strlen(token);
  116874:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  116878:	eb00ab8e 	bl	1416b8 <strlen>
  11687c:	e50b000c 	str	r0, [fp, #-12]
  if (tokenlen == 0) {
  116880:	e51b300c 	ldr	r3, [fp, #-12]
  116884:	e3530000 	cmp	r3, #0
  116888:	1a000001 	bne	116894 <lwip_strnstr+0x38>
    return LWIP_CONST_CAST(char *, buffer);
  11688c:	e51b3010 	ldr	r3, [fp, #-16]
  116890:	ea000021 	b	11691c <lwip_strnstr+0xc0>
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
  116894:	e51b3010 	ldr	r3, [fp, #-16]
  116898:	e50b3008 	str	r3, [fp, #-8]
  11689c:	ea000011 	b	1168e8 <lwip_strnstr+0x8c>
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
  1168a0:	e51b3008 	ldr	r3, [fp, #-8]
  1168a4:	e5d32000 	ldrb	r2, [r3]
  1168a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1168ac:	e5d33000 	ldrb	r3, [r3]
  1168b0:	e1520003 	cmp	r2, r3
  1168b4:	1a000008 	bne	1168dc <lwip_strnstr+0x80>
  1168b8:	e51b200c 	ldr	r2, [fp, #-12]
  1168bc:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1168c0:	e51b0008 	ldr	r0, [fp, #-8]
  1168c4:	eb00aba7 	bl	141768 <strncmp>
  1168c8:	e1a03000 	mov	r3, r0
  1168cc:	e3530000 	cmp	r3, #0
  1168d0:	1a000001 	bne	1168dc <lwip_strnstr+0x80>
      return LWIP_CONST_CAST(char *, p);
  1168d4:	e51b3008 	ldr	r3, [fp, #-8]
  1168d8:	ea00000f 	b	11691c <lwip_strnstr+0xc0>
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
  1168dc:	e51b3008 	ldr	r3, [fp, #-8]
  1168e0:	e2833001 	add	r3, r3, #1
  1168e4:	e50b3008 	str	r3, [fp, #-8]
  1168e8:	e51b3008 	ldr	r3, [fp, #-8]
  1168ec:	e5d33000 	ldrb	r3, [r3]
  1168f0:	e3530000 	cmp	r3, #0
  1168f4:	0a000007 	beq	116918 <lwip_strnstr+0xbc>
  1168f8:	e51b2008 	ldr	r2, [fp, #-8]
  1168fc:	e51b300c 	ldr	r3, [fp, #-12]
  116900:	e0822003 	add	r2, r2, r3
  116904:	e51b1010 	ldr	r1, [fp, #-16]
  116908:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11690c:	e0813003 	add	r3, r1, r3
  116910:	e1520003 	cmp	r2, r3
  116914:	9affffe1 	bls	1168a0 <lwip_strnstr+0x44>
    }
  }
  return NULL;
  116918:	e3a03000 	mov	r3, #0
}
  11691c:	e1a00003 	mov	r0, r3
  116920:	e24bd004 	sub	sp, fp, #4
  116924:	e8bd8800 	pop	{fp, pc}

00116928 <lwip_stricmp>:
 * lwIP default implementation for stricmp() non-standard function.
 * This can be \#defined to stricmp() depending on your platform port.
 */
int
lwip_stricmp(const char* str1, const char* str2)
{
  116928:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11692c:	e28db000 	add	fp, sp, #0
  116930:	e24dd014 	sub	sp, sp, #20
  116934:	e50b0010 	str	r0, [fp, #-16]
  116938:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  char c1, c2;

  do {
    c1 = *str1++;
  11693c:	e51b3010 	ldr	r3, [fp, #-16]
  116940:	e2832001 	add	r2, r3, #1
  116944:	e50b2010 	str	r2, [fp, #-16]
  116948:	e5d33000 	ldrb	r3, [r3]
  11694c:	e54b3005 	strb	r3, [fp, #-5]
    c2 = *str2++;
  116950:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  116954:	e2832001 	add	r2, r3, #1
  116958:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
  11695c:	e5d33000 	ldrb	r3, [r3]
  116960:	e54b3006 	strb	r3, [fp, #-6]
    if (c1 != c2) {
  116964:	e55b2005 	ldrb	r2, [fp, #-5]
  116968:	e55b3006 	ldrb	r3, [fp, #-6]
  11696c:	e1520003 	cmp	r2, r3
  116970:	0a000014 	beq	1169c8 <lwip_stricmp+0xa0>
      char c1_upc = c1 | 0x20;
  116974:	e55b3005 	ldrb	r3, [fp, #-5]
  116978:	e3833020 	orr	r3, r3, #32
  11697c:	e54b3007 	strb	r3, [fp, #-7]
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
  116980:	e55b3007 	ldrb	r3, [fp, #-7]
  116984:	e3530060 	cmp	r3, #96	; 0x60
  116988:	9a00000b 	bls	1169bc <lwip_stricmp+0x94>
  11698c:	e55b3007 	ldrb	r3, [fp, #-7]
  116990:	e353007a 	cmp	r3, #122	; 0x7a
  116994:	8a000008 	bhi	1169bc <lwip_stricmp+0x94>
        /* characters are not equal an one is in the alphabet range:
        downcase both chars and check again */
        char c2_upc = c2 | 0x20;
  116998:	e55b3006 	ldrb	r3, [fp, #-6]
  11699c:	e3833020 	orr	r3, r3, #32
  1169a0:	e54b3008 	strb	r3, [fp, #-8]
        if (c1_upc != c2_upc) {
  1169a4:	e55b2007 	ldrb	r2, [fp, #-7]
  1169a8:	e55b3008 	ldrb	r3, [fp, #-8]
  1169ac:	e1520003 	cmp	r2, r3
  1169b0:	0a000003 	beq	1169c4 <lwip_stricmp+0x9c>
          /* still not equal */
          /* don't care for < or > */
          return 1;
  1169b4:	e3a03001 	mov	r3, #1
  1169b8:	ea000006 	b	1169d8 <lwip_stricmp+0xb0>
        }
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
  1169bc:	e3a03001 	mov	r3, #1
  1169c0:	ea000004 	b	1169d8 <lwip_stricmp+0xb0>
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
  1169c4:	e320f000 	nop	{0}
      }
    }
  } while (c1 != 0);
  1169c8:	e55b3005 	ldrb	r3, [fp, #-5]
  1169cc:	e3530000 	cmp	r3, #0
  1169d0:	1affffd9 	bne	11693c <lwip_stricmp+0x14>
  return 0;
  1169d4:	e3a03000 	mov	r3, #0
}
  1169d8:	e1a00003 	mov	r0, r3
  1169dc:	e28bd000 	add	sp, fp, #0
  1169e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1169e4:	e12fff1e 	bx	lr

001169e8 <lwip_strnicmp>:
 * lwIP default implementation for strnicmp() non-standard function.
 * This can be \#defined to strnicmp() depending on your platform port.
 */
int
lwip_strnicmp(const char* str1, const char* str2, size_t len)
{
  1169e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1169ec:	e28db000 	add	fp, sp, #0
  1169f0:	e24dd01c 	sub	sp, sp, #28
  1169f4:	e50b0010 	str	r0, [fp, #-16]
  1169f8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1169fc:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  char c1, c2;

  do {
    c1 = *str1++;
  116a00:	e51b3010 	ldr	r3, [fp, #-16]
  116a04:	e2832001 	add	r2, r3, #1
  116a08:	e50b2010 	str	r2, [fp, #-16]
  116a0c:	e5d33000 	ldrb	r3, [r3]
  116a10:	e54b3005 	strb	r3, [fp, #-5]
    c2 = *str2++;
  116a14:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  116a18:	e2832001 	add	r2, r3, #1
  116a1c:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
  116a20:	e5d33000 	ldrb	r3, [r3]
  116a24:	e54b3006 	strb	r3, [fp, #-6]
    if (c1 != c2) {
  116a28:	e55b2005 	ldrb	r2, [fp, #-5]
  116a2c:	e55b3006 	ldrb	r3, [fp, #-6]
  116a30:	e1520003 	cmp	r2, r3
  116a34:	0a000014 	beq	116a8c <lwip_strnicmp+0xa4>
      char c1_upc = c1 | 0x20;
  116a38:	e55b3005 	ldrb	r3, [fp, #-5]
  116a3c:	e3833020 	orr	r3, r3, #32
  116a40:	e54b3007 	strb	r3, [fp, #-7]
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
  116a44:	e55b3007 	ldrb	r3, [fp, #-7]
  116a48:	e3530060 	cmp	r3, #96	; 0x60
  116a4c:	9a00000b 	bls	116a80 <lwip_strnicmp+0x98>
  116a50:	e55b3007 	ldrb	r3, [fp, #-7]
  116a54:	e353007a 	cmp	r3, #122	; 0x7a
  116a58:	8a000008 	bhi	116a80 <lwip_strnicmp+0x98>
        /* characters are not equal an one is in the alphabet range:
        downcase both chars and check again */
        char c2_upc = c2 | 0x20;
  116a5c:	e55b3006 	ldrb	r3, [fp, #-6]
  116a60:	e3833020 	orr	r3, r3, #32
  116a64:	e54b3008 	strb	r3, [fp, #-8]
        if (c1_upc != c2_upc) {
  116a68:	e55b2007 	ldrb	r2, [fp, #-7]
  116a6c:	e55b3008 	ldrb	r3, [fp, #-8]
  116a70:	e1520003 	cmp	r2, r3
  116a74:	0a000003 	beq	116a88 <lwip_strnicmp+0xa0>
          /* still not equal */
          /* don't care for < or > */
          return 1;
  116a78:	e3a03001 	mov	r3, #1
  116a7c:	ea00000b 	b	116ab0 <lwip_strnicmp+0xc8>
        }
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
  116a80:	e3a03001 	mov	r3, #1
  116a84:	ea000009 	b	116ab0 <lwip_strnicmp+0xc8>
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
  116a88:	e320f000 	nop	{0}
      }
    }
  } while (len-- && c1 != 0);
  116a8c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  116a90:	e2432001 	sub	r2, r3, #1
  116a94:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  116a98:	e3530000 	cmp	r3, #0
  116a9c:	0a000002 	beq	116aac <lwip_strnicmp+0xc4>
  116aa0:	e55b3005 	ldrb	r3, [fp, #-5]
  116aa4:	e3530000 	cmp	r3, #0
  116aa8:	1affffd4 	bne	116a00 <lwip_strnicmp+0x18>
  return 0;
  116aac:	e3a03000 	mov	r3, #0
}
  116ab0:	e1a00003 	mov	r0, r3
  116ab4:	e28bd000 	add	sp, fp, #0
  116ab8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  116abc:	e12fff1e 	bx	lr

00116ac0 <lwip_itoa>:
 * lwIP default implementation for itoa() non-standard function.
 * This can be \#defined to itoa() or snprintf(result, bufsize, "%d", number) depending on your platform port.
 */
void
lwip_itoa(char* result, size_t bufsize, int number)
{
  116ac0:	e92d4800 	push	{fp, lr}
  116ac4:	e28db004 	add	fp, sp, #4
  116ac8:	e24dd028 	sub	sp, sp, #40	; 0x28
  116acc:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  116ad0:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  116ad4:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  const int base = 10;
  116ad8:	e3a0300a 	mov	r3, #10
  116adc:	e50b3010 	str	r3, [fp, #-16]
  char* ptr = result, *ptr1 = result, tmp_char;
  116ae0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  116ae4:	e50b3008 	str	r3, [fp, #-8]
  116ae8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  116aec:	e50b300c 	str	r3, [fp, #-12]
  int tmp_value;
  LWIP_UNUSED_ARG(bufsize);

  do {
    tmp_value = number;
  116af0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  116af4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    number /= base;
  116af8:	e51b1010 	ldr	r1, [fp, #-16]
  116afc:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  116b00:	eb00885e 	bl	138c80 <__divsi3>
  116b04:	e1a03000 	mov	r3, r0
  116b08:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
    *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"[35 + (tmp_value - number * base)];
  116b0c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  116b10:	e51b2010 	ldr	r2, [fp, #-16]
  116b14:	e0030392 	mul	r3, r2, r3
  116b18:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  116b1c:	e0423003 	sub	r3, r2, r3
  116b20:	e2831023 	add	r1, r3, #35	; 0x23
  116b24:	e51b2008 	ldr	r2, [fp, #-8]
  116b28:	e2823001 	add	r3, r2, #1
  116b2c:	e50b3008 	str	r3, [fp, #-8]
  116b30:	e3073248 	movw	r3, #29256	; 0x7248
  116b34:	e3403014 	movt	r3, #20
  116b38:	e7d33001 	ldrb	r3, [r3, r1]
  116b3c:	e5c23000 	strb	r3, [r2]
  } while(number);
  116b40:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  116b44:	e3530000 	cmp	r3, #0
  116b48:	1affffe8 	bne	116af0 <lwip_itoa+0x30>

   /* Apply negative sign */
  if (tmp_value < 0) {
  116b4c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  116b50:	e3530000 	cmp	r3, #0
  116b54:	aa000004 	bge	116b6c <lwip_itoa+0xac>
     *ptr++ = '-';
  116b58:	e51b3008 	ldr	r3, [fp, #-8]
  116b5c:	e2832001 	add	r2, r3, #1
  116b60:	e50b2008 	str	r2, [fp, #-8]
  116b64:	e3a0202d 	mov	r2, #45	; 0x2d
  116b68:	e5c32000 	strb	r2, [r3]
  }
  *ptr-- = '\0';
  116b6c:	e51b3008 	ldr	r3, [fp, #-8]
  116b70:	e2432001 	sub	r2, r3, #1
  116b74:	e50b2008 	str	r2, [fp, #-8]
  116b78:	e3a02000 	mov	r2, #0
  116b7c:	e5c32000 	strb	r2, [r3]
  while(ptr1 < ptr) {
  116b80:	ea00000d 	b	116bbc <lwip_itoa+0xfc>
    tmp_char = *ptr;
  116b84:	e51b3008 	ldr	r3, [fp, #-8]
  116b88:	e5d33000 	ldrb	r3, [r3]
  116b8c:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    *ptr--= *ptr1;
  116b90:	e51b3008 	ldr	r3, [fp, #-8]
  116b94:	e2432001 	sub	r2, r3, #1
  116b98:	e50b2008 	str	r2, [fp, #-8]
  116b9c:	e51b200c 	ldr	r2, [fp, #-12]
  116ba0:	e5d22000 	ldrb	r2, [r2]
  116ba4:	e5c32000 	strb	r2, [r3]
    *ptr1++ = tmp_char;
  116ba8:	e51b300c 	ldr	r3, [fp, #-12]
  116bac:	e2832001 	add	r2, r3, #1
  116bb0:	e50b200c 	str	r2, [fp, #-12]
  116bb4:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
  116bb8:	e5c32000 	strb	r2, [r3]
  while(ptr1 < ptr) {
  116bbc:	e51b200c 	ldr	r2, [fp, #-12]
  116bc0:	e51b3008 	ldr	r3, [fp, #-8]
  116bc4:	e1520003 	cmp	r2, r3
  116bc8:	3affffed 	bcc	116b84 <lwip_itoa+0xc4>
  }
}
  116bcc:	e320f000 	nop	{0}
  116bd0:	e24bd004 	sub	sp, fp, #4
  116bd4:	e8bd8800 	pop	{fp, pc}

00116bd8 <dns_init>:
 * Initialize the resolver: set up the UDP pcb and configure the default server
 * (if DNS_SERVER_ADDRESS is set).
 */
void
dns_init(void)
{
  116bd8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  116bdc:	e28db000 	add	fp, sp, #0
#endif

#if DNS_LOCAL_HOSTLIST
  dns_init_local();
#endif
}
  116be0:	e320f000 	nop	{0}
  116be4:	e28bd000 	add	sp, fp, #0
  116be8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  116bec:	e12fff1e 	bx	lr

00116bf0 <dns_setserver>:
 * @param numdns the index of the DNS server to set must be < DNS_MAX_SERVERS
 * @param dnsserver IP address of the DNS server to set
 */
void
dns_setserver(u8_t numdns, const ip_addr_t *dnsserver)
{
  116bf0:	e92d4800 	push	{fp, lr}
  116bf4:	e28db004 	add	fp, sp, #4
  116bf8:	e24dd008 	sub	sp, sp, #8
  116bfc:	e1a03000 	mov	r3, r0
  116c00:	e50b100c 	str	r1, [fp, #-12]
  116c04:	e54b3005 	strb	r3, [fp, #-5]
  if (numdns < DNS_MAX_SERVERS) {
  116c08:	e55b3005 	ldrb	r3, [fp, #-5]
  116c0c:	e3530001 	cmp	r3, #1
  116c10:	8a00001f 	bhi	116c94 <dns_setserver+0xa4>
    if (dnsserver != NULL) {
  116c14:	e51b300c 	ldr	r3, [fp, #-12]
  116c18:	e3530000 	cmp	r3, #0
  116c1c:	0a000015 	beq	116c78 <dns_setserver+0x88>
      dns_servers[numdns] = (*dnsserver);
  116c20:	e55b2005 	ldrb	r2, [fp, #-5]
  116c24:	e30f30b8 	movw	r3, #61624	; 0xf0b8
  116c28:	e3403014 	movt	r3, #20
  116c2c:	e51b100c 	ldr	r1, [fp, #-12]
  116c30:	e5911000 	ldr	r1, [r1]
  116c34:	e7831102 	str	r1, [r3, r2, lsl #2]
      extern struct netif *netif_default;
      extern struct netdev *netdev_get_by_name(const char *name);
      extern void netdev_low_level_set_dns_server(struct netdev *netdev, uint8_t dns_num, const ip_addr_t *dns_server);

      /* set network interface device DNS server address */
      if (netif_default) {
  116c38:	e3063838 	movw	r3, #26680	; 0x6838
  116c3c:	e3403057 	movt	r3, #87	; 0x57
  116c40:	e5933000 	ldr	r3, [r3]
  116c44:	e3530000 	cmp	r3, #0
  116c48:	0a000011 	beq	116c94 <dns_setserver+0xa4>
        netdev_low_level_set_dns_server(netdev_get_by_name(netif_default->name), numdns, dnsserver);
  116c4c:	e3063838 	movw	r3, #26680	; 0x6838
  116c50:	e3403057 	movt	r3, #87	; 0x57
  116c54:	e5933000 	ldr	r3, [r3]
  116c58:	e2833042 	add	r3, r3, #66	; 0x42
  116c5c:	e1a00003 	mov	r0, r3
  116c60:	ebffba29 	bl	10550c <netdev_get_by_name>
  116c64:	e55b3005 	ldrb	r3, [fp, #-5]
  116c68:	e51b200c 	ldr	r2, [fp, #-12]
  116c6c:	e1a01003 	mov	r1, r3
  116c70:	ebffbdb3 	bl	106344 <netdev_low_level_set_dns_server>
#endif /* RT_USING_NETDEV */
    } else {
      dns_servers[numdns] = *IP_ADDR_ANY;
    }
  }
}
  116c74:	ea000006 	b	116c94 <dns_setserver+0xa4>
      dns_servers[numdns] = *IP_ADDR_ANY;
  116c78:	e55b1005 	ldrb	r1, [fp, #-5]
  116c7c:	e30f30b8 	movw	r3, #61624	; 0xf0b8
  116c80:	e3403014 	movt	r3, #20
  116c84:	e3092b24 	movw	r2, #39716	; 0x9b24
  116c88:	e3402014 	movt	r2, #20
  116c8c:	e5922000 	ldr	r2, [r2]
  116c90:	e7832101 	str	r2, [r3, r1, lsl #2]
}
  116c94:	e320f000 	nop	{0}
  116c98:	e24bd004 	sub	sp, fp, #4
  116c9c:	e8bd8800 	pop	{fp, pc}

00116ca0 <dns_getserver>:
 * @return IP address of the indexed DNS server or "ip_addr_any" if the DNS
 *         server has not been configured.
 */
const ip_addr_t*
dns_getserver(u8_t numdns)
{
  116ca0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  116ca4:	e28db000 	add	fp, sp, #0
  116ca8:	e24dd00c 	sub	sp, sp, #12
  116cac:	e1a03000 	mov	r3, r0
  116cb0:	e54b3005 	strb	r3, [fp, #-5]
  if (numdns < DNS_MAX_SERVERS) {
  116cb4:	e55b3005 	ldrb	r3, [fp, #-5]
  116cb8:	e3530001 	cmp	r3, #1
  116cbc:	8a000005 	bhi	116cd8 <dns_getserver+0x38>
    return &dns_servers[numdns];
  116cc0:	e55b3005 	ldrb	r3, [fp, #-5]
  116cc4:	e1a02103 	lsl	r2, r3, #2
  116cc8:	e30f30b8 	movw	r3, #61624	; 0xf0b8
  116ccc:	e3403014 	movt	r3, #20
  116cd0:	e0823003 	add	r3, r2, r3
  116cd4:	ea000001 	b	116ce0 <dns_getserver+0x40>
  } else {
    return IP_ADDR_ANY;
  116cd8:	e3093b24 	movw	r3, #39716	; 0x9b24
  116cdc:	e3403014 	movt	r3, #20
  }
}
  116ce0:	e1a00003 	mov	r0, r3
  116ce4:	e28bd000 	add	sp, fp, #0
  116ce8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  116cec:	e12fff1e 	bx	lr

00116cf0 <dns_tmr>:
 * The DNS resolver client timer - handle retries and timeouts and should
 * be called every DNS_TMR_INTERVAL milliseconds (every second by default).
 */
void
dns_tmr(void)
{
  116cf0:	e92d4800 	push	{fp, lr}
  116cf4:	e28db004 	add	fp, sp, #4
  LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
  dns_check_entries();
  116cf8:	eb000360 	bl	117a80 <dns_check_entries>
}
  116cfc:	e320f000 	nop	{0}
  116d00:	e8bd8800 	pop	{fp, pc}

00116d04 <dns_lookup>:
 *         was not found in the cached dns_table.
 * @return ERR_OK if found, ERR_ARG if not found
 */
static err_t
dns_lookup(const char *name, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
{
  116d04:	e92d4800 	push	{fp, lr}
  116d08:	e28db004 	add	fp, sp, #4
  116d0c:	e24dd010 	sub	sp, sp, #16
  116d10:	e50b0010 	str	r0, [fp, #-16]
  116d14:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    return ERR_OK;
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
  116d18:	e3a03000 	mov	r3, #0
  116d1c:	e54b3005 	strb	r3, [fp, #-5]
  116d20:	ea000029 	b	116dcc <dns_lookup+0xc8>
    if ((dns_table[i].state == DNS_STATE_DONE) &&
  116d24:	e55b2005 	ldrb	r2, [fp, #-5]
  116d28:	e30e3c48 	movw	r3, #60488	; 0xec48
  116d2c:	e3403014 	movt	r3, #20
  116d30:	e3a01e11 	mov	r1, #272	; 0x110
  116d34:	e0020291 	mul	r2, r1, r2
  116d38:	e0833002 	add	r3, r3, r2
  116d3c:	e283300a 	add	r3, r3, #10
  116d40:	e5d33000 	ldrb	r3, [r3]
  116d44:	e3530003 	cmp	r3, #3
  116d48:	1a00001c 	bne	116dc0 <dns_lookup+0xbc>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0) &&
  116d4c:	e55b3005 	ldrb	r3, [fp, #-5]
  116d50:	e3a02e11 	mov	r2, #272	; 0x110
  116d54:	e0030392 	mul	r3, r2, r3
  116d58:	e2832010 	add	r2, r3, #16
  116d5c:	e30e3c48 	movw	r3, #60488	; 0xec48
  116d60:	e3403014 	movt	r3, #20
  116d64:	e0823003 	add	r3, r2, r3
  116d68:	e3a02c01 	mov	r2, #256	; 0x100
  116d6c:	e1a01003 	mov	r1, r3
  116d70:	e51b0010 	ldr	r0, [fp, #-16]
  116d74:	ebffff1b 	bl	1169e8 <lwip_strnicmp>
  116d78:	e1a03000 	mov	r3, r0
    if ((dns_table[i].state == DNS_STATE_DONE) &&
  116d7c:	e3530000 	cmp	r3, #0
  116d80:	1a00000e 	bne	116dc0 <dns_lookup+0xbc>
        LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, dns_table[i].ipaddr)) {
      LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
      ip_addr_debug_print(DNS_DEBUG, &(dns_table[i].ipaddr));
      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
      if (addr) {
  116d84:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  116d88:	e3530000 	cmp	r3, #0
  116d8c:	0a000009 	beq	116db8 <dns_lookup+0xb4>
        ip_addr_copy(*addr, dns_table[i].ipaddr);
  116d90:	e55b2005 	ldrb	r2, [fp, #-5]
  116d94:	e30e3c48 	movw	r3, #60488	; 0xec48
  116d98:	e3403014 	movt	r3, #20
  116d9c:	e3a01e11 	mov	r1, #272	; 0x110
  116da0:	e0020291 	mul	r2, r1, r2
  116da4:	e0833002 	add	r3, r3, r2
  116da8:	e2833004 	add	r3, r3, #4
  116dac:	e5932000 	ldr	r2, [r3]
  116db0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  116db4:	e5832000 	str	r2, [r3]
      }
      return ERR_OK;
  116db8:	e3a03000 	mov	r3, #0
  116dbc:	ea000006 	b	116ddc <dns_lookup+0xd8>
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
  116dc0:	e55b3005 	ldrb	r3, [fp, #-5]
  116dc4:	e2833001 	add	r3, r3, #1
  116dc8:	e54b3005 	strb	r3, [fp, #-5]
  116dcc:	e55b3005 	ldrb	r3, [fp, #-5]
  116dd0:	e3530003 	cmp	r3, #3
  116dd4:	9affffd2 	bls	116d24 <dns_lookup+0x20>
    }
  }

  return ERR_ARG;
  116dd8:	e3e0300f 	mvn	r3, #15
}
  116ddc:	e1a00003 	mov	r0, r3
  116de0:	e24bd004 	sub	sp, fp, #4
  116de4:	e8bd8800 	pop	{fp, pc}

00116de8 <dns_compare_name>:
 * @param start_offset offset into p where the name starts
 * @return 0xFFFF: names differ, other: names equal -> offset behind name
 */
static u16_t
dns_compare_name(const char *query, struct pbuf* p, u16_t start_offset)
{
  116de8:	e92d4800 	push	{fp, lr}
  116dec:	e28db004 	add	fp, sp, #4
  116df0:	e24dd020 	sub	sp, sp, #32
  116df4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  116df8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  116dfc:	e1a03002 	mov	r3, r2
  116e00:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
  int n;
  u16_t response_offset = start_offset;
  116e04:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  116e08:	e14b30ba 	strh	r3, [fp, #-10]

  do {
    n = pbuf_try_get_at(p, response_offset++);
  116e0c:	e15b30ba 	ldrh	r3, [fp, #-10]
  116e10:	e2832001 	add	r2, r3, #1
  116e14:	e14b20ba 	strh	r2, [fp, #-10]
  116e18:	e1a01003 	mov	r1, r3
  116e1c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  116e20:	eb001460 	bl	11bfa8 <pbuf_try_get_at>
  116e24:	e50b0008 	str	r0, [fp, #-8]
    if (n < 0) {
  116e28:	e51b3008 	ldr	r3, [fp, #-8]
  116e2c:	e3530000 	cmp	r3, #0
  116e30:	aa000001 	bge	116e3c <dns_compare_name+0x54>
      return 0xFFFF;
  116e34:	e30f3fff 	movw	r3, #65535	; 0xffff
  116e38:	ea000036 	b	116f18 <dns_compare_name+0x130>
    }
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
  116e3c:	e51b3008 	ldr	r3, [fp, #-8]
  116e40:	e20330c0 	and	r3, r3, #192	; 0xc0
  116e44:	e35300c0 	cmp	r3, #192	; 0xc0
  116e48:	1a00001c 	bne	116ec0 <dns_compare_name+0xd8>
      /* Compressed name: cannot be equal since we don't send them */
      return 0xFFFF;
  116e4c:	e30f3fff 	movw	r3, #65535	; 0xffff
  116e50:	ea000030 	b	116f18 <dns_compare_name+0x130>
    } else {
      /* Not compressed name */
      while (n > 0) {
        int c = pbuf_try_get_at(p, response_offset);
  116e54:	e15b30ba 	ldrh	r3, [fp, #-10]
  116e58:	e1a01003 	mov	r1, r3
  116e5c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  116e60:	eb001450 	bl	11bfa8 <pbuf_try_get_at>
  116e64:	e50b0010 	str	r0, [fp, #-16]
        if (c < 0) {
  116e68:	e51b3010 	ldr	r3, [fp, #-16]
  116e6c:	e3530000 	cmp	r3, #0
  116e70:	aa000001 	bge	116e7c <dns_compare_name+0x94>
          return 0xFFFF;
  116e74:	e30f3fff 	movw	r3, #65535	; 0xffff
  116e78:	ea000026 	b	116f18 <dns_compare_name+0x130>
        }
        if ((*query) != (u8_t)c) {
  116e7c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  116e80:	e5d32000 	ldrb	r2, [r3]
  116e84:	e51b3010 	ldr	r3, [fp, #-16]
  116e88:	e6ef3073 	uxtb	r3, r3
  116e8c:	e1520003 	cmp	r2, r3
  116e90:	0a000001 	beq	116e9c <dns_compare_name+0xb4>
          return 0xFFFF;
  116e94:	e30f3fff 	movw	r3, #65535	; 0xffff
  116e98:	ea00001e 	b	116f18 <dns_compare_name+0x130>
        }
        ++response_offset;
  116e9c:	e15b30ba 	ldrh	r3, [fp, #-10]
  116ea0:	e2833001 	add	r3, r3, #1
  116ea4:	e14b30ba 	strh	r3, [fp, #-10]
        ++query;
  116ea8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  116eac:	e2833001 	add	r3, r3, #1
  116eb0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        --n;
  116eb4:	e51b3008 	ldr	r3, [fp, #-8]
  116eb8:	e2433001 	sub	r3, r3, #1
  116ebc:	e50b3008 	str	r3, [fp, #-8]
      while (n > 0) {
  116ec0:	e51b3008 	ldr	r3, [fp, #-8]
  116ec4:	e3530000 	cmp	r3, #0
  116ec8:	caffffe1 	bgt	116e54 <dns_compare_name+0x6c>
      }
      ++query;
  116ecc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  116ed0:	e2833001 	add	r3, r3, #1
  116ed4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    }
    n = pbuf_try_get_at(p, response_offset);
  116ed8:	e15b30ba 	ldrh	r3, [fp, #-10]
  116edc:	e1a01003 	mov	r1, r3
  116ee0:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  116ee4:	eb00142f 	bl	11bfa8 <pbuf_try_get_at>
  116ee8:	e50b0008 	str	r0, [fp, #-8]
    if (n < 0) {
  116eec:	e51b3008 	ldr	r3, [fp, #-8]
  116ef0:	e3530000 	cmp	r3, #0
  116ef4:	aa000001 	bge	116f00 <dns_compare_name+0x118>
      return 0xFFFF;
  116ef8:	e30f3fff 	movw	r3, #65535	; 0xffff
  116efc:	ea000005 	b	116f18 <dns_compare_name+0x130>
    }
  } while (n != 0);
  116f00:	e51b3008 	ldr	r3, [fp, #-8]
  116f04:	e3530000 	cmp	r3, #0
  116f08:	1affffbf 	bne	116e0c <dns_compare_name+0x24>

  return response_offset + 1;
  116f0c:	e15b30ba 	ldrh	r3, [fp, #-10]
  116f10:	e2833001 	add	r3, r3, #1
  116f14:	e6ff3073 	uxth	r3, r3
}
  116f18:	e1a00003 	mov	r0, r3
  116f1c:	e24bd004 	sub	sp, fp, #4
  116f20:	e8bd8800 	pop	{fp, pc}

00116f24 <dns_skip_name>:
 * @param query_idx start index into p pointing to encoded DNS name in the DNS server response
 * @return index to end of the name
 */
static u16_t
dns_skip_name(struct pbuf* p, u16_t query_idx)
{
  116f24:	e92d4800 	push	{fp, lr}
  116f28:	e28db004 	add	fp, sp, #4
  116f2c:	e24dd010 	sub	sp, sp, #16
  116f30:	e50b0010 	str	r0, [fp, #-16]
  116f34:	e1a03001 	mov	r3, r1
  116f38:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  int n;
  u16_t offset = query_idx;
  116f3c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  116f40:	e14b30b6 	strh	r3, [fp, #-6]

  do {
    n = pbuf_try_get_at(p, offset++);
  116f44:	e15b30b6 	ldrh	r3, [fp, #-6]
  116f48:	e2832001 	add	r2, r3, #1
  116f4c:	e14b20b6 	strh	r2, [fp, #-6]
  116f50:	e1a01003 	mov	r1, r3
  116f54:	e51b0010 	ldr	r0, [fp, #-16]
  116f58:	eb001412 	bl	11bfa8 <pbuf_try_get_at>
  116f5c:	e50b000c 	str	r0, [fp, #-12]
    if (n < 0) {
  116f60:	e51b300c 	ldr	r3, [fp, #-12]
  116f64:	e3530000 	cmp	r3, #0
  116f68:	aa000001 	bge	116f74 <dns_skip_name+0x50>
      return 0xFFFF;
  116f6c:	e30f3fff 	movw	r3, #65535	; 0xffff
  116f70:	ea000023 	b	117004 <dns_skip_name+0xe0>
    }
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
  116f74:	e51b300c 	ldr	r3, [fp, #-12]
  116f78:	e20330c0 	and	r3, r3, #192	; 0xc0
  116f7c:	e35300c0 	cmp	r3, #192	; 0xc0
  116f80:	0a00001b 	beq	116ff4 <dns_skip_name+0xd0>
      /* Compressed name: since we only want to skip it (not check it), stop here */
      break;
    } else {
      /* Not compressed name */
      if (offset + n >= p->tot_len) {
  116f84:	e15b20b6 	ldrh	r2, [fp, #-6]
  116f88:	e51b300c 	ldr	r3, [fp, #-12]
  116f8c:	e0823003 	add	r3, r2, r3
  116f90:	e51b2010 	ldr	r2, [fp, #-16]
  116f94:	e1d220b8 	ldrh	r2, [r2, #8]
  116f98:	e1530002 	cmp	r3, r2
  116f9c:	ba000001 	blt	116fa8 <dns_skip_name+0x84>
        return 0xFFFF;
  116fa0:	e30f3fff 	movw	r3, #65535	; 0xffff
  116fa4:	ea000016 	b	117004 <dns_skip_name+0xe0>
      }
      offset = (u16_t)(offset + n);
  116fa8:	e51b300c 	ldr	r3, [fp, #-12]
  116fac:	e6ff2073 	uxth	r2, r3
  116fb0:	e15b30b6 	ldrh	r3, [fp, #-6]
  116fb4:	e0823003 	add	r3, r2, r3
  116fb8:	e14b30b6 	strh	r3, [fp, #-6]
    }
    n = pbuf_try_get_at(p, offset);
  116fbc:	e15b30b6 	ldrh	r3, [fp, #-6]
  116fc0:	e1a01003 	mov	r1, r3
  116fc4:	e51b0010 	ldr	r0, [fp, #-16]
  116fc8:	eb0013f6 	bl	11bfa8 <pbuf_try_get_at>
  116fcc:	e50b000c 	str	r0, [fp, #-12]
    if (n < 0) {
  116fd0:	e51b300c 	ldr	r3, [fp, #-12]
  116fd4:	e3530000 	cmp	r3, #0
  116fd8:	aa000001 	bge	116fe4 <dns_skip_name+0xc0>
      return 0xFFFF;
  116fdc:	e30f3fff 	movw	r3, #65535	; 0xffff
  116fe0:	ea000007 	b	117004 <dns_skip_name+0xe0>
    }
  } while (n != 0);
  116fe4:	e51b300c 	ldr	r3, [fp, #-12]
  116fe8:	e3530000 	cmp	r3, #0
  116fec:	1affffd4 	bne	116f44 <dns_skip_name+0x20>
  116ff0:	ea000000 	b	116ff8 <dns_skip_name+0xd4>
      break;
  116ff4:	e320f000 	nop	{0}

  return offset + 1;
  116ff8:	e15b30b6 	ldrh	r3, [fp, #-6]
  116ffc:	e2833001 	add	r3, r3, #1
  117000:	e6ff3073 	uxth	r3, r3
}
  117004:	e1a00003 	mov	r0, r3
  117008:	e24bd004 	sub	sp, fp, #4
  11700c:	e8bd8800 	pop	{fp, pc}

00117010 <dns_send>:
 * @param idx the DNS table entry index for which to send a request
 * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise
 */
static err_t
dns_send(u8_t idx)
{
  117010:	e92d4800 	push	{fp, lr}
  117014:	e28db004 	add	fp, sp, #4
  117018:	e24dd040 	sub	sp, sp, #64	; 0x40
  11701c:	e1a03000 	mov	r3, r0
  117020:	e54b303d 	strb	r3, [fp, #-61]	; 0xffffffc3
  struct pbuf *p;
  u16_t query_idx, copy_len;
  const char *hostname, *hostname_part;
  u8_t n;
  u8_t pcb_idx;
  struct dns_table_entry* entry = &dns_table[idx];
  117024:	e55b303d 	ldrb	r3, [fp, #-61]	; 0xffffffc3
  117028:	e3a02e11 	mov	r2, #272	; 0x110
  11702c:	e0020392 	mul	r2, r2, r3
  117030:	e30e3c48 	movw	r3, #60488	; 0xec48
  117034:	e3403014 	movt	r3, #20
  117038:	e0823003 	add	r3, r2, r3
  11703c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

  LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
              (u16_t)(entry->server_idx), entry->name));
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
  117040:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  117044:	e5d3300b 	ldrb	r3, [r3, #11]
  117048:	e3530001 	cmp	r3, #1
  11704c:	9a000006 	bls	11706c <dns_send+0x5c>
  117050:	e3070294 	movw	r0, #29332	; 0x7294
  117054:	e3400014 	movt	r0, #20
  117058:	ebffb02d 	bl	103114 <rt_kprintf>
  11705c:	e30012fa 	movw	r1, #762	; 0x2fa
  117060:	e30702ac 	movw	r0, #29356	; 0x72ac
  117064:	e3400014 	movt	r0, #20
  117068:	ebffd003 	bl	10b07c <sys_arch_assert>
  if (ip_addr_isany_val(dns_servers[entry->server_idx])
  11706c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  117070:	e5d3300b 	ldrb	r3, [r3, #11]
  117074:	e1a02003 	mov	r2, r3
  117078:	e30f30b8 	movw	r3, #61624	; 0xf0b8
  11707c:	e3403014 	movt	r3, #20
  117080:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  117084:	e3530000 	cmp	r3, #0
  117088:	1a000008 	bne	1170b0 <dns_send+0xa0>
      && !entry->is_mdns
#endif
    ) {
    /* DNS server not valid anymore, e.g. PPP netif has been shut down */
    /* call specified callback function if provided */
    dns_call_found(idx, NULL);
  11708c:	e55b303d 	ldrb	r3, [fp, #-61]	; 0xffffffc3
  117090:	e3a01000 	mov	r1, #0
  117094:	e1a00003 	mov	r0, r3
  117098:	eb00010f 	bl	1174dc <dns_call_found>
    /* flush this entry */
    entry->state = DNS_STATE_UNUSED;
  11709c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1170a0:	e3a02000 	mov	r2, #0
  1170a4:	e5c3200a 	strb	r2, [r3, #10]
    return ERR_OK;
  1170a8:	e3a03000 	mov	r3, #0
  1170ac:	ea000089 	b	1172d8 <dns_send+0x2c8>
  }

  /* if here, we have either a new query or a retry on a previous query to process */
  p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
  1170b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1170b4:	e2833010 	add	r3, r3, #16
  1170b8:	e1a00003 	mov	r0, r3
  1170bc:	eb00a97d 	bl	1416b8 <strlen>
  1170c0:	e1a03000 	mov	r3, r0
  1170c4:	e6ff3073 	uxth	r3, r3
  1170c8:	e2833012 	add	r3, r3, #18
  1170cc:	e6ff3073 	uxth	r3, r3
  1170d0:	e3a02000 	mov	r2, #0
  1170d4:	e1a01003 	mov	r1, r3
  1170d8:	e3a00000 	mov	r0, #0
  1170dc:	eb000ced 	bl	11a498 <pbuf_alloc>
  1170e0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
                 SIZEOF_DNS_QUERY), PBUF_RAM);
  if (p != NULL) {
  1170e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1170e8:	e3530000 	cmp	r3, #0
  1170ec:	0a000076 	beq	1172cc <dns_send+0x2bc>
    const ip_addr_t* dst;
    u16_t dst_port;
    /* fill dns header */
    memset(&hdr, 0, SIZEOF_DNS_HDR);
  1170f0:	e24b3034 	sub	r3, fp, #52	; 0x34
  1170f4:	e3a0200c 	mov	r2, #12
  1170f8:	e3a01000 	mov	r1, #0
  1170fc:	e1a00003 	mov	r0, r3
  117100:	eb00a8db 	bl	141474 <memset>
    hdr.id = lwip_htons(entry->txid);
  117104:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  117108:	e1d330b8 	ldrh	r3, [r3, #8]
  11710c:	e1a00003 	mov	r0, r3
  117110:	ebfffdb0 	bl	1167d8 <lwip_htons>
  117114:	e1a03000 	mov	r3, r0
  117118:	e14b33b4 	strh	r3, [fp, #-52]	; 0xffffffcc
    hdr.flags1 = DNS_FLAG1_RD;
  11711c:	e3a03001 	mov	r3, #1
  117120:	e54b3032 	strb	r3, [fp, #-50]	; 0xffffffce
    hdr.numquestions = PP_HTONS(1);
  117124:	e3a03c01 	mov	r3, #256	; 0x100
  117128:	e14b33b0 	strh	r3, [fp, #-48]	; 0xffffffd0
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
  11712c:	e24b3034 	sub	r3, fp, #52	; 0x34
  117130:	e3a0200c 	mov	r2, #12
  117134:	e1a01003 	mov	r1, r3
  117138:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  11713c:	eb00128f 	bl	11bb80 <pbuf_take>
    hostname = entry->name;
  117140:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  117144:	e2833010 	add	r3, r3, #16
  117148:	e50b300c 	str	r3, [fp, #-12]
    --hostname;
  11714c:	e51b300c 	ldr	r3, [fp, #-12]
  117150:	e2433001 	sub	r3, r3, #1
  117154:	e50b300c 	str	r3, [fp, #-12]

    /* convert hostname into suitable query format. */
    query_idx = SIZEOF_DNS_HDR;
  117158:	e3a0300c 	mov	r3, #12
  11715c:	e14b30b8 	strh	r3, [fp, #-8]
    do {
      ++hostname;
  117160:	e51b300c 	ldr	r3, [fp, #-12]
  117164:	e2833001 	add	r3, r3, #1
  117168:	e50b300c 	str	r3, [fp, #-12]
      hostname_part = hostname;
  11716c:	e51b300c 	ldr	r3, [fp, #-12]
  117170:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
  117174:	e3a03000 	mov	r3, #0
  117178:	e54b300d 	strb	r3, [fp, #-13]
  11717c:	ea000005 	b	117198 <dns_send+0x188>
        ++n;
  117180:	e55b300d 	ldrb	r3, [fp, #-13]
  117184:	e2833001 	add	r3, r3, #1
  117188:	e54b300d 	strb	r3, [fp, #-13]
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
  11718c:	e51b300c 	ldr	r3, [fp, #-12]
  117190:	e2833001 	add	r3, r3, #1
  117194:	e50b300c 	str	r3, [fp, #-12]
  117198:	e51b300c 	ldr	r3, [fp, #-12]
  11719c:	e5d33000 	ldrb	r3, [r3]
  1171a0:	e353002e 	cmp	r3, #46	; 0x2e
  1171a4:	0a000003 	beq	1171b8 <dns_send+0x1a8>
  1171a8:	e51b300c 	ldr	r3, [fp, #-12]
  1171ac:	e5d33000 	ldrb	r3, [r3]
  1171b0:	e3530000 	cmp	r3, #0
  1171b4:	1afffff1 	bne	117180 <dns_send+0x170>
      }
      copy_len = (u16_t)(hostname - hostname_part);
  1171b8:	e51b200c 	ldr	r2, [fp, #-12]
  1171bc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1171c0:	e0423003 	sub	r3, r2, r3
  1171c4:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
      pbuf_put_at(p, query_idx, n);
  1171c8:	e55b200d 	ldrb	r2, [fp, #-13]
  1171cc:	e15b30b8 	ldrh	r3, [fp, #-8]
  1171d0:	e1a01003 	mov	r1, r3
  1171d4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1171d8:	eb001390 	bl	11c020 <pbuf_put_at>
      pbuf_take_at(p, hostname_part, copy_len, query_idx + 1);
  1171dc:	e15b30b8 	ldrh	r3, [fp, #-8]
  1171e0:	e2833001 	add	r3, r3, #1
  1171e4:	e6ff3073 	uxth	r3, r3
  1171e8:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
  1171ec:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  1171f0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1171f4:	eb0012de 	bl	11bd74 <pbuf_take_at>
      query_idx += n + 1;
  1171f8:	e55b300d 	ldrb	r3, [fp, #-13]
  1171fc:	e6ff2073 	uxth	r2, r3
  117200:	e15b30b8 	ldrh	r3, [fp, #-8]
  117204:	e0823003 	add	r3, r2, r3
  117208:	e6ff3073 	uxth	r3, r3
  11720c:	e2833001 	add	r3, r3, #1
  117210:	e14b30b8 	strh	r3, [fp, #-8]
    } while (*hostname != 0);
  117214:	e51b300c 	ldr	r3, [fp, #-12]
  117218:	e5d33000 	ldrb	r3, [r3]
  11721c:	e3530000 	cmp	r3, #0
  117220:	1affffce 	bne	117160 <dns_send+0x150>
    pbuf_put_at(p, query_idx, 0);
  117224:	e15b30b8 	ldrh	r3, [fp, #-8]
  117228:	e3a02000 	mov	r2, #0
  11722c:	e1a01003 	mov	r1, r3
  117230:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  117234:	eb001379 	bl	11c020 <pbuf_put_at>
    query_idx++;
  117238:	e15b30b8 	ldrh	r3, [fp, #-8]
  11723c:	e2833001 	add	r3, r3, #1
  117240:	e14b30b8 	strh	r3, [fp, #-8]

    /* fill dns query */
    if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype)) {
      qry.type = PP_HTONS(DNS_RRTYPE_AAAA);
    } else {
      qry.type = PP_HTONS(DNS_RRTYPE_A);
  117244:	e3a03c01 	mov	r3, #256	; 0x100
  117248:	e14b33b8 	strh	r3, [fp, #-56]	; 0xffffffc8
    }
    qry.cls = PP_HTONS(DNS_RRCLASS_IN);
  11724c:	e3a03c01 	mov	r3, #256	; 0x100
  117250:	e14b33b6 	strh	r3, [fp, #-54]	; 0xffffffca
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
  117254:	e15b30b8 	ldrh	r3, [fp, #-8]
  117258:	e24b1038 	sub	r1, fp, #56	; 0x38
  11725c:	e3a02004 	mov	r2, #4
  117260:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  117264:	eb0012c2 	bl	11bd74 <pbuf_take_at>

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
    pcb_idx = entry->pcb_idx;
  117268:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11726c:	e5d3300f 	ldrb	r3, [r3, #15]
  117270:	e54b301f 	strb	r3, [fp, #-31]	; 0xffffffe1
      }
#endif
    } else
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
    {
      dst_port = DNS_SERVER_PORT;
  117274:	e3a03035 	mov	r3, #53	; 0x35
  117278:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
      dst = &dns_servers[entry->server_idx];
  11727c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  117280:	e5d3300b 	ldrb	r3, [r3, #11]
  117284:	e1a02103 	lsl	r2, r3, #2
  117288:	e30f30b8 	movw	r3, #61624	; 0xf0b8
  11728c:	e3403014 	movt	r3, #20
  117290:	e0823003 	add	r3, r2, r3
  117294:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
    }
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
  117298:	e55b201f 	ldrb	r2, [fp, #-31]	; 0xffffffe1
  11729c:	e30e3c34 	movw	r3, #60468	; 0xec34
  1172a0:	e3403014 	movt	r3, #20
  1172a4:	e7930102 	ldr	r0, [r3, r2, lsl #2]
  1172a8:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  1172ac:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  1172b0:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  1172b4:	eb00441c 	bl	12832c <udp_sendto>
  1172b8:	e1a03000 	mov	r3, r0
  1172bc:	e54b3005 	strb	r3, [fp, #-5]

    /* free pbuf */
    pbuf_free(p);
  1172c0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1172c4:	eb000f7a 	bl	11b0b4 <pbuf_free>
  1172c8:	ea000001 	b	1172d4 <dns_send+0x2c4>
  } else {
    err = ERR_MEM;
  1172cc:	e3e03000 	mvn	r3, #0
  1172d0:	e54b3005 	strb	r3, [fp, #-5]
  }

  return err;
  1172d4:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  1172d8:	e1a00003 	mov	r0, r3
  1172dc:	e24bd004 	sub	sp, fp, #4
  1172e0:	e8bd8800 	pop	{fp, pc}

001172e4 <dns_alloc_random_port>:

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
static struct udp_pcb*
dns_alloc_random_port(void)
{
  1172e4:	e92d4800 	push	{fp, lr}
  1172e8:	e28db004 	add	fp, sp, #4
  1172ec:	e24dd010 	sub	sp, sp, #16
  err_t err;
  struct udp_pcb* ret;

  ret = udp_new_ip_type(IPADDR_TYPE_ANY);
  1172f0:	e3a0002e 	mov	r0, #46	; 0x2e
  1172f4:	eb00468a 	bl	128d24 <udp_new_ip_type>
  1172f8:	e50b000c 	str	r0, [fp, #-12]
  if (ret == NULL) {
  1172fc:	e51b300c 	ldr	r3, [fp, #-12]
  117300:	e3530000 	cmp	r3, #0
  117304:	1a000001 	bne	117310 <dns_alloc_random_port+0x2c>
    /* out of memory, have to reuse an existing pcb */
    return NULL;
  117308:	e3a03000 	mov	r3, #0
  11730c:	ea000020 	b	117394 <dns_alloc_random_port+0xb0>
  }
  do {
    u16_t port = (u16_t)DNS_RAND_TXID();
  117310:	eb009c1d 	bl	13e38c <rand>
  117314:	e1a03000 	mov	r3, r0
  117318:	e14b30be 	strh	r3, [fp, #-14]
    if (!DNS_PORT_ALLOWED(port)) {
  11731c:	e15b30be 	ldrh	r3, [fp, #-14]
  117320:	e3530b01 	cmp	r3, #1024	; 0x400
  117324:	2a000002 	bcs	117334 <dns_alloc_random_port+0x50>
      /* this port is not allowed, try again */
      err = ERR_USE;
  117328:	e3e03007 	mvn	r3, #7
  11732c:	e54b3005 	strb	r3, [fp, #-5]
      continue;
  117330:	ea000007 	b	117354 <dns_alloc_random_port+0x70>
    }
    err = udp_bind(ret, IP_ANY_TYPE, port);
  117334:	e15b30be 	ldrh	r3, [fp, #-14]
  117338:	e1a02003 	mov	r2, r3
  11733c:	e3091b24 	movw	r1, #39716	; 0x9b24
  117340:	e3401014 	movt	r1, #20
  117344:	e51b000c 	ldr	r0, [fp, #-12]
  117348:	eb004540 	bl	128850 <udp_bind>
  11734c:	e1a03000 	mov	r3, r0
  117350:	e54b3005 	strb	r3, [fp, #-5]
  } while (err == ERR_USE);
  117354:	e15b30d5 	ldrsb	r3, [fp, #-5]
  117358:	e3730008 	cmn	r3, #8
  11735c:	0affffeb 	beq	117310 <dns_alloc_random_port+0x2c>
  if (err != ERR_OK) {
  117360:	e15b30d5 	ldrsb	r3, [fp, #-5]
  117364:	e3530000 	cmp	r3, #0
  117368:	0a000003 	beq	11737c <dns_alloc_random_port+0x98>
    udp_remove(ret);
  11736c:	e51b000c 	ldr	r0, [fp, #-12]
  117370:	eb004620 	bl	128bf8 <udp_remove>
    return NULL;
  117374:	e3a03000 	mov	r3, #0
  117378:	ea000005 	b	117394 <dns_alloc_random_port+0xb0>
  }
  udp_recv(ret, dns_recv, NULL);
  11737c:	e3a02000 	mov	r2, #0
  117380:	e3071b8c 	movw	r1, #31628	; 0x7b8c
  117384:	e3401011 	movt	r1, #17
  117388:	e51b000c 	ldr	r0, [fp, #-12]
  11738c:	eb004609 	bl	128bb8 <udp_recv>
  return ret;
  117390:	e51b300c 	ldr	r3, [fp, #-12]
}
  117394:	e1a00003 	mov	r0, r3
  117398:	e24bd004 	sub	sp, fp, #4
  11739c:	e8bd8800 	pop	{fp, pc}

001173a0 <dns_alloc_pcb>:
 *
 * @return an index into dns_pcbs
 */
static u8_t
dns_alloc_pcb(void)
{
  1173a0:	e92d4810 	push	{r4, fp, lr}
  1173a4:	e28db008 	add	fp, sp, #8
  1173a8:	e24dd00c 	sub	sp, sp, #12
  u8_t i;
  u8_t idx;

  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
  1173ac:	e3a03000 	mov	r3, #0
  1173b0:	e54b300d 	strb	r3, [fp, #-13]
  1173b4:	ea000008 	b	1173dc <dns_alloc_pcb+0x3c>
    if (dns_pcbs[i] == NULL) {
  1173b8:	e55b200d 	ldrb	r2, [fp, #-13]
  1173bc:	e30e3c34 	movw	r3, #60468	; 0xec34
  1173c0:	e3403014 	movt	r3, #20
  1173c4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  1173c8:	e3530000 	cmp	r3, #0
  1173cc:	0a000006 	beq	1173ec <dns_alloc_pcb+0x4c>
  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
  1173d0:	e55b300d 	ldrb	r3, [fp, #-13]
  1173d4:	e2833001 	add	r3, r3, #1
  1173d8:	e54b300d 	strb	r3, [fp, #-13]
  1173dc:	e55b300d 	ldrb	r3, [fp, #-13]
  1173e0:	e3530003 	cmp	r3, #3
  1173e4:	9afffff3 	bls	1173b8 <dns_alloc_pcb+0x18>
  1173e8:	ea000000 	b	1173f0 <dns_alloc_pcb+0x50>
      break;
  1173ec:	e320f000 	nop	{0}
    }
  }
  if (i < DNS_MAX_SOURCE_PORTS) {
  1173f0:	e55b300d 	ldrb	r3, [fp, #-13]
  1173f4:	e3530003 	cmp	r3, #3
  1173f8:	8a000011 	bhi	117444 <dns_alloc_pcb+0xa4>
    dns_pcbs[i] = dns_alloc_random_port();
  1173fc:	e55b400d 	ldrb	r4, [fp, #-13]
  117400:	ebffffb7 	bl	1172e4 <dns_alloc_random_port>
  117404:	e1a02000 	mov	r2, r0
  117408:	e30e3c34 	movw	r3, #60468	; 0xec34
  11740c:	e3403014 	movt	r3, #20
  117410:	e7832104 	str	r2, [r3, r4, lsl #2]
    if (dns_pcbs[i] != NULL) {
  117414:	e55b200d 	ldrb	r2, [fp, #-13]
  117418:	e30e3c34 	movw	r3, #60468	; 0xec34
  11741c:	e3403014 	movt	r3, #20
  117420:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  117424:	e3530000 	cmp	r3, #0
  117428:	0a000005 	beq	117444 <dns_alloc_pcb+0xa4>
      /* succeeded */
      dns_last_pcb_idx = i;
  11742c:	e30e3c44 	movw	r3, #60484	; 0xec44
  117430:	e3403014 	movt	r3, #20
  117434:	e55b200d 	ldrb	r2, [fp, #-13]
  117438:	e5c32000 	strb	r2, [r3]
      return i;
  11743c:	e55b300d 	ldrb	r3, [fp, #-13]
  117440:	ea000022 	b	1174d0 <dns_alloc_pcb+0x130>
    }
  }
  /* if we come here, creating a new UDP pcb failed, so we have to use
     an already existing one */
  for (i = 0, idx = dns_last_pcb_idx + 1; i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
  117444:	e3a03000 	mov	r3, #0
  117448:	e54b300d 	strb	r3, [fp, #-13]
  11744c:	e30e3c44 	movw	r3, #60484	; 0xec44
  117450:	e3403014 	movt	r3, #20
  117454:	e5d33000 	ldrb	r3, [r3]
  117458:	e2833001 	add	r3, r3, #1
  11745c:	e54b300e 	strb	r3, [fp, #-14]
  117460:	ea000016 	b	1174c0 <dns_alloc_pcb+0x120>
    if (idx >= DNS_MAX_SOURCE_PORTS) {
  117464:	e55b300e 	ldrb	r3, [fp, #-14]
  117468:	e3530003 	cmp	r3, #3
  11746c:	9a000001 	bls	117478 <dns_alloc_pcb+0xd8>
      idx = 0;
  117470:	e3a03000 	mov	r3, #0
  117474:	e54b300e 	strb	r3, [fp, #-14]
    }
    if (dns_pcbs[idx] != NULL) {
  117478:	e55b200e 	ldrb	r2, [fp, #-14]
  11747c:	e30e3c34 	movw	r3, #60468	; 0xec34
  117480:	e3403014 	movt	r3, #20
  117484:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  117488:	e3530000 	cmp	r3, #0
  11748c:	0a000005 	beq	1174a8 <dns_alloc_pcb+0x108>
      dns_last_pcb_idx = idx;
  117490:	e30e3c44 	movw	r3, #60484	; 0xec44
  117494:	e3403014 	movt	r3, #20
  117498:	e55b200e 	ldrb	r2, [fp, #-14]
  11749c:	e5c32000 	strb	r2, [r3]
      return idx;
  1174a0:	e55b300e 	ldrb	r3, [fp, #-14]
  1174a4:	ea000009 	b	1174d0 <dns_alloc_pcb+0x130>
  for (i = 0, idx = dns_last_pcb_idx + 1; i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
  1174a8:	e55b300d 	ldrb	r3, [fp, #-13]
  1174ac:	e2833001 	add	r3, r3, #1
  1174b0:	e54b300d 	strb	r3, [fp, #-13]
  1174b4:	e55b300e 	ldrb	r3, [fp, #-14]
  1174b8:	e2833001 	add	r3, r3, #1
  1174bc:	e54b300e 	strb	r3, [fp, #-14]
  1174c0:	e55b300d 	ldrb	r3, [fp, #-13]
  1174c4:	e3530003 	cmp	r3, #3
  1174c8:	9affffe5 	bls	117464 <dns_alloc_pcb+0xc4>
    }
  }
  return DNS_MAX_SOURCE_PORTS;
  1174cc:	e3a03004 	mov	r3, #4
}
  1174d0:	e1a00003 	mov	r0, r3
  1174d4:	e24bd008 	sub	sp, fp, #8
  1174d8:	e8bd8810 	pop	{r4, fp, pc}

001174dc <dns_call_found>:
 * @param idx dns table index of the entry that is resolved or removed
 * @param addr IP address for the hostname (or NULL on error or memory shortage)
 */
static void
dns_call_found(u8_t idx, ip_addr_t* addr)
{
  1174dc:	e92d4810 	push	{r4, fp, lr}
  1174e0:	e28db008 	add	fp, sp, #8
  1174e4:	e24dd014 	sub	sp, sp, #20
  1174e8:	e1a03000 	mov	r3, r0
  1174ec:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  1174f0:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    }
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
  1174f4:	e3a03000 	mov	r3, #0
  1174f8:	e54b300d 	strb	r3, [fp, #-13]
  1174fc:	ea000037 	b	1175e0 <dns_call_found+0x104>
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
  117500:	e55b200d 	ldrb	r2, [fp, #-13]
  117504:	e30f3088 	movw	r3, #61576	; 0xf088
  117508:	e3403014 	movt	r3, #20
  11750c:	e3a0100c 	mov	r1, #12
  117510:	e0020291 	mul	r2, r1, r2
  117514:	e0833002 	add	r3, r3, r2
  117518:	e5933000 	ldr	r3, [r3]
  11751c:	e3530000 	cmp	r3, #0
  117520:	0a00002b 	beq	1175d4 <dns_call_found+0xf8>
  117524:	e55b200d 	ldrb	r2, [fp, #-13]
  117528:	e30f3088 	movw	r3, #61576	; 0xf088
  11752c:	e3403014 	movt	r3, #20
  117530:	e3a0100c 	mov	r1, #12
  117534:	e0020291 	mul	r2, r1, r2
  117538:	e0833002 	add	r3, r3, r2
  11753c:	e2833008 	add	r3, r3, #8
  117540:	e5d33000 	ldrb	r3, [r3]
  117544:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
  117548:	e1520003 	cmp	r2, r3
  11754c:	1a000020 	bne	1175d4 <dns_call_found+0xf8>
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
  117550:	e55b200d 	ldrb	r2, [fp, #-13]
  117554:	e30f3088 	movw	r3, #61576	; 0xf088
  117558:	e3403014 	movt	r3, #20
  11755c:	e3a0100c 	mov	r1, #12
  117560:	e0020291 	mul	r2, r1, r2
  117564:	e0833002 	add	r3, r3, r2
  117568:	e5934000 	ldr	r4, [r3]
  11756c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  117570:	e3a02e11 	mov	r2, #272	; 0x110
  117574:	e0030392 	mul	r3, r2, r3
  117578:	e2832010 	add	r2, r3, #16
  11757c:	e30e3c48 	movw	r3, #60488	; 0xec48
  117580:	e3403014 	movt	r3, #20
  117584:	e0820003 	add	r0, r2, r3
  117588:	e55b200d 	ldrb	r2, [fp, #-13]
  11758c:	e30f3088 	movw	r3, #61576	; 0xf088
  117590:	e3403014 	movt	r3, #20
  117594:	e3a0100c 	mov	r1, #12
  117598:	e0020291 	mul	r2, r1, r2
  11759c:	e0833002 	add	r3, r3, r2
  1175a0:	e2833004 	add	r3, r3, #4
  1175a4:	e5933000 	ldr	r3, [r3]
  1175a8:	e1a02003 	mov	r2, r3
  1175ac:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  1175b0:	e12fff34 	blx	r4
      /* flush this entry */
      dns_requests[i].found = NULL;
  1175b4:	e55b200d 	ldrb	r2, [fp, #-13]
  1175b8:	e30f3088 	movw	r3, #61576	; 0xf088
  1175bc:	e3403014 	movt	r3, #20
  1175c0:	e3a0100c 	mov	r1, #12
  1175c4:	e0020291 	mul	r2, r1, r2
  1175c8:	e0833002 	add	r3, r3, r2
  1175cc:	e3a02000 	mov	r2, #0
  1175d0:	e5832000 	str	r2, [r3]
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
  1175d4:	e55b300d 	ldrb	r3, [fp, #-13]
  1175d8:	e2833001 	add	r3, r3, #1
  1175dc:	e54b300d 	strb	r3, [fp, #-13]
  1175e0:	e55b300d 	ldrb	r3, [fp, #-13]
  1175e4:	e3530003 	cmp	r3, #3
  1175e8:	9affffc4 	bls	117500 <dns_call_found+0x24>
  }
  dns_requests[idx].found = NULL;
#endif
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  /* close the pcb used unless other request are using it */
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
  1175ec:	e3a03000 	mov	r3, #0
  1175f0:	e54b300d 	strb	r3, [fp, #-13]
  1175f4:	ea00002d 	b	1176b0 <dns_call_found+0x1d4>
    if (i == idx) {
  1175f8:	e55b200d 	ldrb	r2, [fp, #-13]
  1175fc:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  117600:	e1520003 	cmp	r2, r3
  117604:	0a000025 	beq	1176a0 <dns_call_found+0x1c4>
      continue; /* only check other requests */
    }
    if (dns_table[i].state == DNS_STATE_ASKING) {
  117608:	e55b200d 	ldrb	r2, [fp, #-13]
  11760c:	e30e3c48 	movw	r3, #60488	; 0xec48
  117610:	e3403014 	movt	r3, #20
  117614:	e3a01e11 	mov	r1, #272	; 0x110
  117618:	e0020291 	mul	r2, r1, r2
  11761c:	e0833002 	add	r3, r3, r2
  117620:	e283300a 	add	r3, r3, #10
  117624:	e5d33000 	ldrb	r3, [r3]
  117628:	e3530002 	cmp	r3, #2
  11762c:	1a00001c 	bne	1176a4 <dns_call_found+0x1c8>
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
  117630:	e55b200d 	ldrb	r2, [fp, #-13]
  117634:	e30e3c48 	movw	r3, #60488	; 0xec48
  117638:	e3403014 	movt	r3, #20
  11763c:	e3a01e11 	mov	r1, #272	; 0x110
  117640:	e0020291 	mul	r2, r1, r2
  117644:	e0833002 	add	r3, r3, r2
  117648:	e283300f 	add	r3, r3, #15
  11764c:	e5d32000 	ldrb	r2, [r3]
  117650:	e55b1015 	ldrb	r1, [fp, #-21]	; 0xffffffeb
  117654:	e30e3c48 	movw	r3, #60488	; 0xec48
  117658:	e3403014 	movt	r3, #20
  11765c:	e3a00e11 	mov	r0, #272	; 0x110
  117660:	e0010190 	mul	r1, r0, r1
  117664:	e0833001 	add	r3, r3, r1
  117668:	e283300f 	add	r3, r3, #15
  11766c:	e5d33000 	ldrb	r3, [r3]
  117670:	e1520003 	cmp	r2, r3
  117674:	1a00000a 	bne	1176a4 <dns_call_found+0x1c8>
        /* another request is still using the same pcb */
        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
  117678:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
  11767c:	e30e3c48 	movw	r3, #60488	; 0xec48
  117680:	e3403014 	movt	r3, #20
  117684:	e3a01e11 	mov	r1, #272	; 0x110
  117688:	e0020291 	mul	r2, r1, r2
  11768c:	e0833002 	add	r3, r3, r2
  117690:	e283300f 	add	r3, r3, #15
  117694:	e3a02004 	mov	r2, #4
  117698:	e5c32000 	strb	r2, [r3]
        break;
  11769c:	ea000006 	b	1176bc <dns_call_found+0x1e0>
      continue; /* only check other requests */
  1176a0:	e320f000 	nop	{0}
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
  1176a4:	e55b300d 	ldrb	r3, [fp, #-13]
  1176a8:	e2833001 	add	r3, r3, #1
  1176ac:	e54b300d 	strb	r3, [fp, #-13]
  1176b0:	e55b300d 	ldrb	r3, [fp, #-13]
  1176b4:	e3530003 	cmp	r3, #3
  1176b8:	9affffce 	bls	1175f8 <dns_call_found+0x11c>
      }
    }
  }
  if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
  1176bc:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
  1176c0:	e30e3c48 	movw	r3, #60488	; 0xec48
  1176c4:	e3403014 	movt	r3, #20
  1176c8:	e3a01e11 	mov	r1, #272	; 0x110
  1176cc:	e0020291 	mul	r2, r1, r2
  1176d0:	e0833002 	add	r3, r3, r2
  1176d4:	e283300f 	add	r3, r3, #15
  1176d8:	e5d33000 	ldrb	r3, [r3]
  1176dc:	e3530003 	cmp	r3, #3
  1176e0:	8a000023 	bhi	117774 <dns_call_found+0x298>
    /* if we come here, the pcb is not used any more and can be removed */
    udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
  1176e4:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
  1176e8:	e30e3c48 	movw	r3, #60488	; 0xec48
  1176ec:	e3403014 	movt	r3, #20
  1176f0:	e3a01e11 	mov	r1, #272	; 0x110
  1176f4:	e0020291 	mul	r2, r1, r2
  1176f8:	e0833002 	add	r3, r3, r2
  1176fc:	e283300f 	add	r3, r3, #15
  117700:	e5d33000 	ldrb	r3, [r3]
  117704:	e1a02003 	mov	r2, r3
  117708:	e30e3c34 	movw	r3, #60468	; 0xec34
  11770c:	e3403014 	movt	r3, #20
  117710:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  117714:	e1a00003 	mov	r0, r3
  117718:	eb004536 	bl	128bf8 <udp_remove>
    dns_pcbs[dns_table[idx].pcb_idx] = NULL;
  11771c:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
  117720:	e30e3c48 	movw	r3, #60488	; 0xec48
  117724:	e3403014 	movt	r3, #20
  117728:	e3a01e11 	mov	r1, #272	; 0x110
  11772c:	e0020291 	mul	r2, r1, r2
  117730:	e0833002 	add	r3, r3, r2
  117734:	e283300f 	add	r3, r3, #15
  117738:	e5d33000 	ldrb	r3, [r3]
  11773c:	e1a01003 	mov	r1, r3
  117740:	e30e3c34 	movw	r3, #60468	; 0xec34
  117744:	e3403014 	movt	r3, #20
  117748:	e3a02000 	mov	r2, #0
  11774c:	e7832101 	str	r2, [r3, r1, lsl #2]
    dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
  117750:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
  117754:	e30e3c48 	movw	r3, #60488	; 0xec48
  117758:	e3403014 	movt	r3, #20
  11775c:	e3a01e11 	mov	r1, #272	; 0x110
  117760:	e0020291 	mul	r2, r1, r2
  117764:	e0833002 	add	r3, r3, r2
  117768:	e283300f 	add	r3, r3, #15
  11776c:	e3a02004 	mov	r2, #4
  117770:	e5c32000 	strb	r2, [r3]
  }
#endif
}
  117774:	e320f000 	nop	{0}
  117778:	e24bd008 	sub	sp, fp, #8
  11777c:	e8bd8810 	pop	{r4, fp, pc}

00117780 <dns_create_txid>:

/* Create a query transmission ID that is unique for all outstanding queries */
static u16_t
dns_create_txid(void)
{
  117780:	e92d4800 	push	{fp, lr}
  117784:	e28db004 	add	fp, sp, #4
  117788:	e24dd008 	sub	sp, sp, #8
  u16_t txid;
  u8_t i;

again:
  txid = (u16_t)DNS_RAND_TXID();
  11778c:	eb009afe 	bl	13e38c <rand>
  117790:	e1a03000 	mov	r3, r0
  117794:	e14b30b8 	strh	r3, [fp, #-8]

  /* check whether the ID is unique */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
  117798:	e3a03000 	mov	r3, #0
  11779c:	e54b3005 	strb	r3, [fp, #-5]
  1177a0:	ea000018 	b	117808 <dns_create_txid+0x88>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
  1177a4:	e55b2005 	ldrb	r2, [fp, #-5]
  1177a8:	e30e3c48 	movw	r3, #60488	; 0xec48
  1177ac:	e3403014 	movt	r3, #20
  1177b0:	e3a01e11 	mov	r1, #272	; 0x110
  1177b4:	e0020291 	mul	r2, r1, r2
  1177b8:	e0833002 	add	r3, r3, r2
  1177bc:	e283300a 	add	r3, r3, #10
  1177c0:	e5d33000 	ldrb	r3, [r3]
  1177c4:	e3530002 	cmp	r3, #2
  1177c8:	1a00000b 	bne	1177fc <dns_create_txid+0x7c>
        (dns_table[i].txid == txid)) {
  1177cc:	e55b2005 	ldrb	r2, [fp, #-5]
  1177d0:	e30e3c48 	movw	r3, #60488	; 0xec48
  1177d4:	e3403014 	movt	r3, #20
  1177d8:	e3a01e11 	mov	r1, #272	; 0x110
  1177dc:	e0020291 	mul	r2, r1, r2
  1177e0:	e0833002 	add	r3, r3, r2
  1177e4:	e2833008 	add	r3, r3, #8
  1177e8:	e1d330b0 	ldrh	r3, [r3]
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
  1177ec:	e15b20b8 	ldrh	r2, [fp, #-8]
  1177f0:	e1520003 	cmp	r2, r3
  1177f4:	1a000000 	bne	1177fc <dns_create_txid+0x7c>
      /* ID already used by another pending query */
      goto again;
  1177f8:	eaffffe3 	b	11778c <dns_create_txid+0xc>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
  1177fc:	e55b3005 	ldrb	r3, [fp, #-5]
  117800:	e2833001 	add	r3, r3, #1
  117804:	e54b3005 	strb	r3, [fp, #-5]
  117808:	e55b3005 	ldrb	r3, [fp, #-5]
  11780c:	e3530003 	cmp	r3, #3
  117810:	9affffe3 	bls	1177a4 <dns_create_txid+0x24>
    }
  }

  return txid;
  117814:	e15b30b8 	ldrh	r3, [fp, #-8]
}
  117818:	e1a00003 	mov	r0, r3
  11781c:	e24bd004 	sub	sp, fp, #4
  117820:	e8bd8800 	pop	{fp, pc}

00117824 <dns_check_entry>:
 *
 * @param i index of the dns_table entry to check
 */
static void
dns_check_entry(u8_t i)
{
  117824:	e92d4800 	push	{fp, lr}
  117828:	e28db004 	add	fp, sp, #4
  11782c:	e24dd010 	sub	sp, sp, #16
  117830:	e1a03000 	mov	r3, r0
  117834:	e54b300d 	strb	r3, [fp, #-13]
  err_t err;
  struct dns_table_entry *entry = &dns_table[i];
  117838:	e55b300d 	ldrb	r3, [fp, #-13]
  11783c:	e3a02e11 	mov	r2, #272	; 0x110
  117840:	e0020392 	mul	r2, r2, r3
  117844:	e30e3c48 	movw	r3, #60488	; 0xec48
  117848:	e3403014 	movt	r3, #20
  11784c:	e0823003 	add	r3, r2, r3
  117850:	e50b3008 	str	r3, [fp, #-8]

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
  117854:	e55b300d 	ldrb	r3, [fp, #-13]
  117858:	e3530003 	cmp	r3, #3
  11785c:	9a000006 	bls	11787c <dns_check_entry+0x58>
  117860:	e30702d8 	movw	r0, #29400	; 0x72d8
  117864:	e3400014 	movt	r0, #20
  117868:	ebffae29 	bl	103114 <rt_kprintf>
  11786c:	e3001405 	movw	r1, #1029	; 0x405
  117870:	e30702ac 	movw	r0, #29356	; 0x72ac
  117874:	e3400014 	movt	r0, #20
  117878:	ebffcdff 	bl	10b07c <sys_arch_assert>

  switch (entry->state) {
  11787c:	e51b3008 	ldr	r3, [fp, #-8]
  117880:	e5d3300a 	ldrb	r3, [r3, #10]
  117884:	e3530003 	cmp	r3, #3
  117888:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  11788c:	ea00006b 	b	117a40 <dns_check_entry+0x21c>
  117890:	00117a60 	.word	0x00117a60
  117894:	001178a0 	.word	0x001178a0
  117898:	001178fc 	.word	0x001178fc
  11789c:	001179fc 	.word	0x001179fc
    case DNS_STATE_NEW:
      /* initialize new entry */
      entry->txid = dns_create_txid();
  1178a0:	ebffffb6 	bl	117780 <dns_create_txid>
  1178a4:	e1a03000 	mov	r3, r0
  1178a8:	e1a02003 	mov	r2, r3
  1178ac:	e51b3008 	ldr	r3, [fp, #-8]
  1178b0:	e1c320b8 	strh	r2, [r3, #8]
      entry->state = DNS_STATE_ASKING;
  1178b4:	e51b3008 	ldr	r3, [fp, #-8]
  1178b8:	e3a02002 	mov	r2, #2
  1178bc:	e5c3200a 	strb	r2, [r3, #10]
      entry->server_idx = 0;
  1178c0:	e51b3008 	ldr	r3, [fp, #-8]
  1178c4:	e3a02000 	mov	r2, #0
  1178c8:	e5c3200b 	strb	r2, [r3, #11]
      entry->tmr = 1;
  1178cc:	e51b3008 	ldr	r3, [fp, #-8]
  1178d0:	e3a02001 	mov	r2, #1
  1178d4:	e5c3200c 	strb	r2, [r3, #12]
      entry->retries = 0;
  1178d8:	e51b3008 	ldr	r3, [fp, #-8]
  1178dc:	e3a02000 	mov	r2, #0
  1178e0:	e5c3200d 	strb	r2, [r3, #13]

      /* send DNS packet for this entry */
      err = dns_send(i);
  1178e4:	e55b300d 	ldrb	r3, [fp, #-13]
  1178e8:	e1a00003 	mov	r0, r3
  1178ec:	ebfffdc7 	bl	117010 <dns_send>
  1178f0:	e1a03000 	mov	r3, r0
  1178f4:	e54b3009 	strb	r3, [fp, #-9]
      if (err != ERR_OK) {
        LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                    ("dns_send returned error: %s\n", lwip_strerr(err)));
      }
      break;
  1178f8:	ea00005d 	b	117a74 <dns_check_entry+0x250>
    case DNS_STATE_ASKING:
      if (--entry->tmr == 0) {
  1178fc:	e51b3008 	ldr	r3, [fp, #-8]
  117900:	e5d3300c 	ldrb	r3, [r3, #12]
  117904:	e2433001 	sub	r3, r3, #1
  117908:	e6ef2073 	uxtb	r2, r3
  11790c:	e51b3008 	ldr	r3, [fp, #-8]
  117910:	e5c3200c 	strb	r2, [r3, #12]
  117914:	e51b3008 	ldr	r3, [fp, #-8]
  117918:	e5d3300c 	ldrb	r3, [r3, #12]
  11791c:	e3530000 	cmp	r3, #0
  117920:	1a000050 	bne	117a68 <dns_check_entry+0x244>
        if (++entry->retries == DNS_MAX_RETRIES) {
  117924:	e51b3008 	ldr	r3, [fp, #-8]
  117928:	e5d3300d 	ldrb	r3, [r3, #13]
  11792c:	e2833001 	add	r3, r3, #1
  117930:	e6ef2073 	uxtb	r2, r3
  117934:	e51b3008 	ldr	r3, [fp, #-8]
  117938:	e5c3200d 	strb	r2, [r3, #13]
  11793c:	e51b3008 	ldr	r3, [fp, #-8]
  117940:	e5d3300d 	ldrb	r3, [r3, #13]
  117944:	e3530004 	cmp	r3, #4
  117948:	1a000021 	bne	1179d4 <dns_check_entry+0x1b0>
          if ((entry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[entry->server_idx + 1])
  11794c:	e51b3008 	ldr	r3, [fp, #-8]
  117950:	e5d3300b 	ldrb	r3, [r3, #11]
  117954:	e2833001 	add	r3, r3, #1
  117958:	e3530001 	cmp	r3, #1
  11795c:	ca000014 	bgt	1179b4 <dns_check_entry+0x190>
  117960:	e51b3008 	ldr	r3, [fp, #-8]
  117964:	e5d3300b 	ldrb	r3, [r3, #11]
  117968:	e2832001 	add	r2, r3, #1
  11796c:	e30f30b8 	movw	r3, #61624	; 0xf0b8
  117970:	e3403014 	movt	r3, #20
  117974:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  117978:	e3530000 	cmp	r3, #0
  11797c:	0a00000c 	beq	1179b4 <dns_check_entry+0x190>
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
            && !entry->is_mdns
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
            ) {
            /* change of server */
            entry->server_idx++;
  117980:	e51b3008 	ldr	r3, [fp, #-8]
  117984:	e5d3300b 	ldrb	r3, [r3, #11]
  117988:	e2833001 	add	r3, r3, #1
  11798c:	e6ef2073 	uxtb	r2, r3
  117990:	e51b3008 	ldr	r3, [fp, #-8]
  117994:	e5c3200b 	strb	r2, [r3, #11]
            entry->tmr = 1;
  117998:	e51b3008 	ldr	r3, [fp, #-8]
  11799c:	e3a02001 	mov	r2, #1
  1179a0:	e5c3200c 	strb	r2, [r3, #12]
            entry->retries = 0;
  1179a4:	e51b3008 	ldr	r3, [fp, #-8]
  1179a8:	e3a02000 	mov	r2, #0
  1179ac:	e5c3200d 	strb	r2, [r3, #13]
  1179b0:	ea00000b 	b	1179e4 <dns_check_entry+0x1c0>
          } else {
            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", entry->name));
            /* call specified callback function if provided */
            dns_call_found(i, NULL);
  1179b4:	e55b300d 	ldrb	r3, [fp, #-13]
  1179b8:	e3a01000 	mov	r1, #0
  1179bc:	e1a00003 	mov	r0, r3
  1179c0:	ebfffec5 	bl	1174dc <dns_call_found>
            /* flush this entry */
            entry->state = DNS_STATE_UNUSED;
  1179c4:	e51b3008 	ldr	r3, [fp, #-8]
  1179c8:	e3a02000 	mov	r2, #0
  1179cc:	e5c3200a 	strb	r2, [r3, #10]
            break;
  1179d0:	ea000027 	b	117a74 <dns_check_entry+0x250>
          }
        } else {
          /* wait longer for the next retry */
          entry->tmr = entry->retries;
  1179d4:	e51b3008 	ldr	r3, [fp, #-8]
  1179d8:	e5d3200d 	ldrb	r2, [r3, #13]
  1179dc:	e51b3008 	ldr	r3, [fp, #-8]
  1179e0:	e5c3200c 	strb	r2, [r3, #12]
        }

        /* send DNS packet for this entry */
        err = dns_send(i);
  1179e4:	e55b300d 	ldrb	r3, [fp, #-13]
  1179e8:	e1a00003 	mov	r0, r3
  1179ec:	ebfffd87 	bl	117010 <dns_send>
  1179f0:	e1a03000 	mov	r3, r0
  1179f4:	e54b3009 	strb	r3, [fp, #-9]
        if (err != ERR_OK) {
          LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                      ("dns_send returned error: %s\n", lwip_strerr(err)));
        }
      }
      break;
  1179f8:	ea00001a 	b	117a68 <dns_check_entry+0x244>
    case DNS_STATE_DONE:
      /* if the time to live is nul */
      if ((entry->ttl == 0) || (--entry->ttl == 0)) {
  1179fc:	e51b3008 	ldr	r3, [fp, #-8]
  117a00:	e5933000 	ldr	r3, [r3]
  117a04:	e3530000 	cmp	r3, #0
  117a08:	0a000008 	beq	117a30 <dns_check_entry+0x20c>
  117a0c:	e51b3008 	ldr	r3, [fp, #-8]
  117a10:	e5933000 	ldr	r3, [r3]
  117a14:	e2432001 	sub	r2, r3, #1
  117a18:	e51b3008 	ldr	r3, [fp, #-8]
  117a1c:	e5832000 	str	r2, [r3]
  117a20:	e51b3008 	ldr	r3, [fp, #-8]
  117a24:	e5933000 	ldr	r3, [r3]
  117a28:	e3530000 	cmp	r3, #0
  117a2c:	1a00000f 	bne	117a70 <dns_check_entry+0x24c>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", entry->name));
        /* flush this entry, there cannot be any related pending entries in this state */
        entry->state = DNS_STATE_UNUSED;
  117a30:	e51b3008 	ldr	r3, [fp, #-8]
  117a34:	e3a02000 	mov	r2, #0
  117a38:	e5c3200a 	strb	r2, [r3, #10]
      }
      break;
  117a3c:	ea00000b 	b	117a70 <dns_check_entry+0x24c>
    case DNS_STATE_UNUSED:
      /* nothing to do */
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
  117a40:	e30702f4 	movw	r0, #29428	; 0x72f4
  117a44:	e3400014 	movt	r0, #20
  117a48:	ebffadb1 	bl	103114 <rt_kprintf>
  117a4c:	e3001444 	movw	r1, #1092	; 0x444
  117a50:	e30702ac 	movw	r0, #29356	; 0x72ac
  117a54:	e3400014 	movt	r0, #20
  117a58:	ebffcd87 	bl	10b07c <sys_arch_assert>
      break;
  117a5c:	ea000004 	b	117a74 <dns_check_entry+0x250>
      break;
  117a60:	e320f000 	nop	{0}
  117a64:	ea000002 	b	117a74 <dns_check_entry+0x250>
      break;
  117a68:	e320f000 	nop	{0}
  117a6c:	ea000000 	b	117a74 <dns_check_entry+0x250>
      break;
  117a70:	e320f000 	nop	{0}
  }
}
  117a74:	e320f000 	nop	{0}
  117a78:	e24bd004 	sub	sp, fp, #4
  117a7c:	e8bd8800 	pop	{fp, pc}

00117a80 <dns_check_entries>:
/**
 * Call dns_check_entry for each entry in dns_table - check all entries.
 */
static void
dns_check_entries(void)
{
  117a80:	e92d4800 	push	{fp, lr}
  117a84:	e28db004 	add	fp, sp, #4
  117a88:	e24dd008 	sub	sp, sp, #8
  u8_t i;

  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
  117a8c:	e3a03000 	mov	r3, #0
  117a90:	e54b3005 	strb	r3, [fp, #-5]
  117a94:	ea000005 	b	117ab0 <dns_check_entries+0x30>
    dns_check_entry(i);
  117a98:	e55b3005 	ldrb	r3, [fp, #-5]
  117a9c:	e1a00003 	mov	r0, r3
  117aa0:	ebffff5f 	bl	117824 <dns_check_entry>
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
  117aa4:	e55b3005 	ldrb	r3, [fp, #-5]
  117aa8:	e2833001 	add	r3, r3, #1
  117aac:	e54b3005 	strb	r3, [fp, #-5]
  117ab0:	e55b3005 	ldrb	r3, [fp, #-5]
  117ab4:	e3530003 	cmp	r3, #3
  117ab8:	9afffff6 	bls	117a98 <dns_check_entries+0x18>
  }
}
  117abc:	e320f000 	nop	{0}
  117ac0:	e24bd004 	sub	sp, fp, #4
  117ac4:	e8bd8800 	pop	{fp, pc}

00117ac8 <dns_correct_response>:
/**
 * Save TTL and call dns_call_found for correct response.
 */
static void
dns_correct_response(u8_t idx, u32_t ttl)
{
  117ac8:	e92d4800 	push	{fp, lr}
  117acc:	e28db004 	add	fp, sp, #4
  117ad0:	e24dd010 	sub	sp, sp, #16
  117ad4:	e1a03000 	mov	r3, r0
  117ad8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  117adc:	e54b300d 	strb	r3, [fp, #-13]
  struct dns_table_entry *entry = &dns_table[idx];
  117ae0:	e55b300d 	ldrb	r3, [fp, #-13]
  117ae4:	e3a02e11 	mov	r2, #272	; 0x110
  117ae8:	e0020392 	mul	r2, r2, r3
  117aec:	e30e3c48 	movw	r3, #60488	; 0xec48
  117af0:	e3403014 	movt	r3, #20
  117af4:	e0823003 	add	r3, r2, r3
  117af8:	e50b3008 	str	r3, [fp, #-8]

  entry->state = DNS_STATE_DONE;
  117afc:	e51b3008 	ldr	r3, [fp, #-8]
  117b00:	e3a02003 	mov	r2, #3
  117b04:	e5c3200a 	strb	r2, [r3, #10]
  LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", entry->name));
  ip_addr_debug_print(DNS_DEBUG, (&(entry->ipaddr)));
  LWIP_DEBUGF(DNS_DEBUG, ("\n"));

  /* read the answer resource record's TTL, and maximize it if needed */
  entry->ttl = ttl;
  117b08:	e51b3008 	ldr	r3, [fp, #-8]
  117b0c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  117b10:	e5832000 	str	r2, [r3]
  if (entry->ttl > DNS_MAX_TTL) {
  117b14:	e51b3008 	ldr	r3, [fp, #-8]
  117b18:	e5932000 	ldr	r2, [r3]
  117b1c:	e3a03dea 	mov	r3, #14976	; 0x3a80
  117b20:	e3403009 	movt	r3, #9
  117b24:	e1520003 	cmp	r2, r3
  117b28:	9a000003 	bls	117b3c <dns_correct_response+0x74>
    entry->ttl = DNS_MAX_TTL;
  117b2c:	e51b2008 	ldr	r2, [fp, #-8]
  117b30:	e3a03dea 	mov	r3, #14976	; 0x3a80
  117b34:	e3403009 	movt	r3, #9
  117b38:	e5823000 	str	r3, [r2]
  }
  dns_call_found(idx, &entry->ipaddr);
  117b3c:	e51b3008 	ldr	r3, [fp, #-8]
  117b40:	e2832004 	add	r2, r3, #4
  117b44:	e55b300d 	ldrb	r3, [fp, #-13]
  117b48:	e1a01002 	mov	r1, r2
  117b4c:	e1a00003 	mov	r0, r3
  117b50:	ebfffe61 	bl	1174dc <dns_call_found>

  if (entry->ttl == 0) {
  117b54:	e51b3008 	ldr	r3, [fp, #-8]
  117b58:	e5933000 	ldr	r3, [r3]
  117b5c:	e3530000 	cmp	r3, #0
  117b60:	1a000006 	bne	117b80 <dns_correct_response+0xb8>
    /* RFC 883, page 29: "Zero values are
       interpreted to mean that the RR can only be used for the
       transaction in progress, and should not be cached."
       -> flush this entry now */
    /* entry reused during callback? */
    if (entry->state == DNS_STATE_DONE) {
  117b64:	e51b3008 	ldr	r3, [fp, #-8]
  117b68:	e5d3300a 	ldrb	r3, [r3, #10]
  117b6c:	e3530003 	cmp	r3, #3
  117b70:	1a000002 	bne	117b80 <dns_correct_response+0xb8>
      entry->state = DNS_STATE_UNUSED;
  117b74:	e51b3008 	ldr	r3, [fp, #-8]
  117b78:	e3a02000 	mov	r2, #0
  117b7c:	e5c3200a 	strb	r2, [r3, #10]
    }
  }
}
  117b80:	e320f000 	nop	{0}
  117b84:	e24bd004 	sub	sp, fp, #4
  117b88:	e8bd8800 	pop	{fp, pc}

00117b8c <dns_recv>:
/**
 * Receive input function for DNS response packets arriving for the dns UDP pcb.
 */
static void
dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
  117b8c:	e92d4810 	push	{r4, fp, lr}
  117b90:	e28db008 	add	fp, sp, #8
  117b94:	e24dd044 	sub	sp, sp, #68	; 0x44
  117b98:	e50b0040 	str	r0, [fp, #-64]	; 0xffffffc0
  117b9c:	e50b1044 	str	r1, [fp, #-68]	; 0xffffffbc
  117ba0:	e50b2048 	str	r2, [fp, #-72]	; 0xffffffb8
  117ba4:	e50b304c 	str	r3, [fp, #-76]	; 0xffffffb4
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(port);

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY)) {
  117ba8:	e51b3048 	ldr	r3, [fp, #-72]	; 0xffffffb8
  117bac:	e1d330b8 	ldrh	r3, [r3, #8]
  117bb0:	e353000f 	cmp	r3, #15
  117bb4:	9a0000c8 	bls	117edc <dns_recv+0x350>
    /* free pbuf and return */
    goto memerr;
  }

  /* copy dns payload inside static buffer for processing */
  if (pbuf_copy_partial(p, &hdr, SIZEOF_DNS_HDR, 0) == SIZEOF_DNS_HDR) {
  117bb8:	e24b1028 	sub	r1, fp, #40	; 0x28
  117bbc:	e3a03000 	mov	r3, #0
  117bc0:	e3a0200c 	mov	r2, #12
  117bc4:	e51b0048 	ldr	r0, [fp, #-72]	; 0xffffffb8
  117bc8:	eb000f44 	bl	11b8e0 <pbuf_copy_partial>
  117bcc:	e1a03000 	mov	r3, r0
  117bd0:	e353000c 	cmp	r3, #12
  117bd4:	1a0000c2 	bne	117ee4 <dns_recv+0x358>
    /* Match the ID in the DNS header with the name table. */
    txid = lwip_htons(hdr.id);
  117bd8:	e15b32b8 	ldrh	r3, [fp, #-40]	; 0xffffffd8
  117bdc:	e1a00003 	mov	r0, r3
  117be0:	ebfffafc 	bl	1167d8 <lwip_htons>
  117be4:	e1a03000 	mov	r3, r0
  117be8:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
  117bec:	e3a03000 	mov	r3, #0
  117bf0:	e54b300d 	strb	r3, [fp, #-13]
  117bf4:	ea0000b4 	b	117ecc <dns_recv+0x340>
      const struct dns_table_entry *entry = &dns_table[i];
  117bf8:	e55b300d 	ldrb	r3, [fp, #-13]
  117bfc:	e3a02e11 	mov	r2, #272	; 0x110
  117c00:	e0020392 	mul	r2, r2, r3
  117c04:	e30e3c48 	movw	r3, #60488	; 0xec48
  117c08:	e3403014 	movt	r3, #20
  117c0c:	e0823003 	add	r3, r2, r3
  117c10:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
      if ((entry->state == DNS_STATE_ASKING) &&
  117c14:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  117c18:	e5d3300a 	ldrb	r3, [r3, #10]
  117c1c:	e3530002 	cmp	r3, #2
  117c20:	1a0000a6 	bne	117ec0 <dns_recv+0x334>
          (entry->txid == txid)) {
  117c24:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  117c28:	e1d330b8 	ldrh	r3, [r3, #8]
      if ((entry->state == DNS_STATE_ASKING) &&
  117c2c:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
  117c30:	e1520003 	cmp	r2, r3
  117c34:	1a0000a1 	bne	117ec0 <dns_recv+0x334>

        /* We only care about the question(s) and the answers. The authrr
           and the extrarr are simply discarded. */
        nquestions = lwip_htons(hdr.numquestions);
  117c38:	e15b32b4 	ldrh	r3, [fp, #-36]	; 0xffffffdc
  117c3c:	e1a00003 	mov	r0, r3
  117c40:	ebfffae4 	bl	1167d8 <lwip_htons>
  117c44:	e1a03000 	mov	r3, r0
  117c48:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
        nanswers   = lwip_htons(hdr.numanswers);
  117c4c:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  117c50:	e1a00003 	mov	r0, r3
  117c54:	ebfffadf 	bl	1167d8 <lwip_htons>
  117c58:	e1a03000 	mov	r3, r0
  117c5c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee

        /* Check for correct response. */
        if ((hdr.flags1 & DNS_FLAG1_RESPONSE) == 0) {
  117c60:	e55b3026 	ldrb	r3, [fp, #-38]	; 0xffffffda
  117c64:	e6af3073 	sxtb	r3, r3
  117c68:	e3530000 	cmp	r3, #0
  117c6c:	aa00009e 	bge	117eec <dns_recv+0x360>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": not a response\n", entry->name));
          goto memerr; /* ignore this packet */
        }
        if (nquestions != 1) {
  117c70:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  117c74:	e3530001 	cmp	r3, #1
  117c78:	1a00009d 	bne	117ef4 <dns_recv+0x368>
        if (!entry->is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
        {
          /* Check whether response comes from the same network address to which the
             question was sent. (RFC 5452) */
          if (!ip_addr_cmp(addr, &dns_servers[entry->server_idx])) {
  117c7c:	e51b304c 	ldr	r3, [fp, #-76]	; 0xffffffb4
  117c80:	e5932000 	ldr	r2, [r3]
  117c84:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  117c88:	e5d3300b 	ldrb	r3, [r3, #11]
  117c8c:	e1a01003 	mov	r1, r3
  117c90:	e30f30b8 	movw	r3, #61624	; 0xf0b8
  117c94:	e3403014 	movt	r3, #20
  117c98:	e7933101 	ldr	r3, [r3, r1, lsl #2]
  117c9c:	e1520003 	cmp	r2, r3
  117ca0:	1a000095 	bne	117efc <dns_recv+0x370>
          }
        }

        /* Check if the name in the "question" part match with the name in the entry and
           skip it if equal. */
        res_idx = dns_compare_name(entry->name, p, SIZEOF_DNS_HDR);
  117ca4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  117ca8:	e2833010 	add	r3, r3, #16
  117cac:	e3a0200c 	mov	r2, #12
  117cb0:	e51b1048 	ldr	r1, [fp, #-72]	; 0xffffffb8
  117cb4:	e1a00003 	mov	r0, r3
  117cb8:	ebfffc4a 	bl	116de8 <dns_compare_name>
  117cbc:	e1a03000 	mov	r3, r0
  117cc0:	e14b31b0 	strh	r3, [fp, #-16]
        if (res_idx == 0xFFFF) {
  117cc4:	e15b31b0 	ldrh	r3, [fp, #-16]
  117cc8:	e30f2fff 	movw	r2, #65535	; 0xffff
  117ccc:	e1530002 	cmp	r3, r2
  117cd0:	0a00008b 	beq	117f04 <dns_recv+0x378>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto memerr; /* ignore this packet */
        }

        /* check if "question" part matches the request */
        if (pbuf_copy_partial(p, &qry, SIZEOF_DNS_QUERY, res_idx) != SIZEOF_DNS_QUERY) {
  117cd4:	e15b31b0 	ldrh	r3, [fp, #-16]
  117cd8:	e24b1038 	sub	r1, fp, #56	; 0x38
  117cdc:	e3a02004 	mov	r2, #4
  117ce0:	e51b0048 	ldr	r0, [fp, #-72]	; 0xffffffb8
  117ce4:	eb000efd 	bl	11b8e0 <pbuf_copy_partial>
  117ce8:	e1a03000 	mov	r3, r0
  117cec:	e3530004 	cmp	r3, #4
  117cf0:	1a000085 	bne	117f0c <dns_recv+0x380>
          goto memerr; /* ignore this packet */
        }
        if ((qry.cls != PP_HTONS(DNS_RRCLASS_IN)) ||
  117cf4:	e15b33b6 	ldrh	r3, [fp, #-54]	; 0xffffffca
  117cf8:	e3530c01 	cmp	r3, #256	; 0x100
  117cfc:	1a000078 	bne	117ee4 <dns_recv+0x358>
          (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
          (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_A)))) {
  117d00:	e15b33b8 	ldrh	r3, [fp, #-56]	; 0xffffffc8
          (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
  117d04:	e3530c01 	cmp	r3, #256	; 0x100
  117d08:	1a000075 	bne	117ee4 <dns_recv+0x358>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto memerr; /* ignore this packet */
        }
        /* skip the rest of the "question" part */
        res_idx += SIZEOF_DNS_QUERY;
  117d0c:	e15b31b0 	ldrh	r3, [fp, #-16]
  117d10:	e2833004 	add	r3, r3, #4
  117d14:	e14b31b0 	strh	r3, [fp, #-16]

        /* Check for error. If so, call callback to inform. */
        if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
  117d18:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
  117d1c:	e203300f 	and	r3, r3, #15
  117d20:	e3530000 	cmp	r3, #0
  117d24:	1a000055 	bne	117e80 <dns_recv+0x2f4>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", entry->name));
        } else {
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
  117d28:	ea00004c 	b	117e60 <dns_recv+0x2d4>
            /* skip answer resource record's host name */
            res_idx = dns_skip_name(p, res_idx);
  117d2c:	e15b31b0 	ldrh	r3, [fp, #-16]
  117d30:	e1a01003 	mov	r1, r3
  117d34:	e51b0048 	ldr	r0, [fp, #-72]	; 0xffffffb8
  117d38:	ebfffc79 	bl	116f24 <dns_skip_name>
  117d3c:	e1a03000 	mov	r3, r0
  117d40:	e14b31b0 	strh	r3, [fp, #-16]
            if (res_idx == 0xFFFF) {
  117d44:	e15b31b0 	ldrh	r3, [fp, #-16]
  117d48:	e30f2fff 	movw	r2, #65535	; 0xffff
  117d4c:	e1530002 	cmp	r3, r2
  117d50:	0a00006f 	beq	117f14 <dns_recv+0x388>
              goto memerr; /* ignore this packet */
            }

            /* Check for IP address type and Internet class. Others are discarded. */
            if (pbuf_copy_partial(p, &ans, SIZEOF_DNS_ANSWER, res_idx) != SIZEOF_DNS_ANSWER) {
  117d54:	e15b31b0 	ldrh	r3, [fp, #-16]
  117d58:	e24b1034 	sub	r1, fp, #52	; 0x34
  117d5c:	e3a0200a 	mov	r2, #10
  117d60:	e51b0048 	ldr	r0, [fp, #-72]	; 0xffffffb8
  117d64:	eb000edd 	bl	11b8e0 <pbuf_copy_partial>
  117d68:	e1a03000 	mov	r3, r0
  117d6c:	e353000a 	cmp	r3, #10
  117d70:	1a000069 	bne	117f1c <dns_recv+0x390>
              goto memerr; /* ignore this packet */
            }
            res_idx += SIZEOF_DNS_ANSWER;
  117d74:	e15b31b0 	ldrh	r3, [fp, #-16]
  117d78:	e283300a 	add	r3, r3, #10
  117d7c:	e14b31b0 	strh	r3, [fp, #-16]

            if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
  117d80:	e15b33b2 	ldrh	r3, [fp, #-50]	; 0xffffffce
  117d84:	e3530c01 	cmp	r3, #256	; 0x100
  117d88:	1a000021 	bne	117e14 <dns_recv+0x288>
#if LWIP_IPV4
              if ((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.len == PP_HTONS(sizeof(ip4_addr_t)))) {
  117d8c:	e15b33b4 	ldrh	r3, [fp, #-52]	; 0xffffffcc
  117d90:	e3530c01 	cmp	r3, #256	; 0x100
  117d94:	1a00001e 	bne	117e14 <dns_recv+0x288>
  117d98:	e15b32bc 	ldrh	r3, [fp, #-44]	; 0xffffffd4
  117d9c:	e3530b01 	cmp	r3, #1024	; 0x400
  117da0:	1a00001b 	bne	117e14 <dns_recv+0x288>
                if (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
                {
                  ip4_addr_t ip4addr;
                  /* read the IP address after answer resource record's header */
                  if (pbuf_copy_partial(p, &ip4addr, sizeof(ip4_addr_t), res_idx) != sizeof(ip4_addr_t)) {
  117da4:	e15b31b0 	ldrh	r3, [fp, #-16]
  117da8:	e24b103c 	sub	r1, fp, #60	; 0x3c
  117dac:	e3a02004 	mov	r2, #4
  117db0:	e51b0048 	ldr	r0, [fp, #-72]	; 0xffffffb8
  117db4:	eb000ec9 	bl	11b8e0 <pbuf_copy_partial>
  117db8:	e1a03000 	mov	r3, r0
  117dbc:	e3530004 	cmp	r3, #4
  117dc0:	1a000057 	bne	117f24 <dns_recv+0x398>
                    goto memerr; /* ignore this packet */
                  }
                  ip_addr_copy_from_ip4(dns_table[i].ipaddr, ip4addr);
  117dc4:	e55b100d 	ldrb	r1, [fp, #-13]
  117dc8:	e51b203c 	ldr	r2, [fp, #-60]	; 0xffffffc4
  117dcc:	e30e3c48 	movw	r3, #60488	; 0xec48
  117dd0:	e3403014 	movt	r3, #20
  117dd4:	e3a00e11 	mov	r0, #272	; 0x110
  117dd8:	e0010190 	mul	r1, r0, r1
  117ddc:	e0833001 	add	r3, r3, r1
  117de0:	e2833004 	add	r3, r3, #4
  117de4:	e5832000 	str	r2, [r3]
                  pbuf_free(p);
  117de8:	e51b0048 	ldr	r0, [fp, #-72]	; 0xffffffb8
  117dec:	eb000cb0 	bl	11b0b4 <pbuf_free>
                  /* handle correct response */
                  dns_correct_response(i, lwip_ntohl(ans.ttl));
  117df0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  117df4:	e1a00003 	mov	r0, r3
  117df8:	ebfffa82 	bl	116808 <lwip_htonl>
  117dfc:	e1a02000 	mov	r2, r0
  117e00:	e55b300d 	ldrb	r3, [fp, #-13]
  117e04:	e1a01002 	mov	r1, r2
  117e08:	e1a00003 	mov	r0, r3
  117e0c:	ebffff2d 	bl	117ac8 <dns_correct_response>
  117e10:	ea000049 	b	117f3c <dns_recv+0x3b0>
                }
              }
#endif /* LWIP_IPV6 */
            }
            /* skip this answer */
            if ((int)(res_idx + lwip_htons(ans.len)) > 0xFFFF) {
  117e14:	e15b41b0 	ldrh	r4, [fp, #-16]
  117e18:	e15b32bc 	ldrh	r3, [fp, #-44]	; 0xffffffd4
  117e1c:	e1a00003 	mov	r0, r3
  117e20:	ebfffa6c 	bl	1167d8 <lwip_htons>
  117e24:	e1a03000 	mov	r3, r0
  117e28:	e0843003 	add	r3, r4, r3
  117e2c:	e3530801 	cmp	r3, #65536	; 0x10000
  117e30:	aa00003d 	bge	117f2c <dns_recv+0x3a0>
              goto memerr; /* ignore this packet */
            }
            res_idx += lwip_htons(ans.len);
  117e34:	e15b32bc 	ldrh	r3, [fp, #-44]	; 0xffffffd4
  117e38:	e1a00003 	mov	r0, r3
  117e3c:	ebfffa65 	bl	1167d8 <lwip_htons>
  117e40:	e1a03000 	mov	r3, r0
  117e44:	e1a02003 	mov	r2, r3
  117e48:	e15b31b0 	ldrh	r3, [fp, #-16]
  117e4c:	e0823003 	add	r3, r2, r3
  117e50:	e14b31b0 	strh	r3, [fp, #-16]
            --nanswers;
  117e54:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  117e58:	e2433001 	sub	r3, r3, #1
  117e5c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
  117e60:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  117e64:	e3530000 	cmp	r3, #0
  117e68:	0a000004 	beq	117e80 <dns_recv+0x2f4>
  117e6c:	e51b3048 	ldr	r3, [fp, #-72]	; 0xffffffb8
  117e70:	e1d330b8 	ldrh	r3, [r3, #8]
  117e74:	e15b21b0 	ldrh	r2, [fp, #-16]
  117e78:	e1520003 	cmp	r2, r3
  117e7c:	3affffaa 	bcc	117d2c <dns_recv+0x1a0>
          }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", entry->name));
        }
        /* call callback to indicate error, clean up memory and return */
        pbuf_free(p);
  117e80:	e51b0048 	ldr	r0, [fp, #-72]	; 0xffffffb8
  117e84:	eb000c8a 	bl	11b0b4 <pbuf_free>
        dns_call_found(i, NULL);
  117e88:	e55b300d 	ldrb	r3, [fp, #-13]
  117e8c:	e3a01000 	mov	r1, #0
  117e90:	e1a00003 	mov	r0, r3
  117e94:	ebfffd90 	bl	1174dc <dns_call_found>
        dns_table[i].state = DNS_STATE_UNUSED;
  117e98:	e55b200d 	ldrb	r2, [fp, #-13]
  117e9c:	e30e3c48 	movw	r3, #60488	; 0xec48
  117ea0:	e3403014 	movt	r3, #20
  117ea4:	e3a01e11 	mov	r1, #272	; 0x110
  117ea8:	e0020291 	mul	r2, r1, r2
  117eac:	e0833002 	add	r3, r3, r2
  117eb0:	e283300a 	add	r3, r3, #10
  117eb4:	e3a02000 	mov	r2, #0
  117eb8:	e5c32000 	strb	r2, [r3]
        return;
  117ebc:	ea00001e 	b	117f3c <dns_recv+0x3b0>
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
  117ec0:	e55b300d 	ldrb	r3, [fp, #-13]
  117ec4:	e2833001 	add	r3, r3, #1
  117ec8:	e54b300d 	strb	r3, [fp, #-13]
  117ecc:	e55b300d 	ldrb	r3, [fp, #-13]
  117ed0:	e3530003 	cmp	r3, #3
  117ed4:	9affff47 	bls	117bf8 <dns_recv+0x6c>
      }
    }
  }

memerr:
  117ed8:	ea000001 	b	117ee4 <dns_recv+0x358>
    goto memerr;
  117edc:	e320f000 	nop	{0}
  117ee0:	ea000012 	b	117f30 <dns_recv+0x3a4>
memerr:
  117ee4:	e320f000 	nop	{0}
  117ee8:	ea000010 	b	117f30 <dns_recv+0x3a4>
          goto memerr; /* ignore this packet */
  117eec:	e320f000 	nop	{0}
  117ef0:	ea00000e 	b	117f30 <dns_recv+0x3a4>
          goto memerr; /* ignore this packet */
  117ef4:	e320f000 	nop	{0}
  117ef8:	ea00000c 	b	117f30 <dns_recv+0x3a4>
            goto memerr; /* ignore this packet */
  117efc:	e320f000 	nop	{0}
  117f00:	ea00000a 	b	117f30 <dns_recv+0x3a4>
          goto memerr; /* ignore this packet */
  117f04:	e320f000 	nop	{0}
  117f08:	ea000008 	b	117f30 <dns_recv+0x3a4>
          goto memerr; /* ignore this packet */
  117f0c:	e320f000 	nop	{0}
  117f10:	ea000006 	b	117f30 <dns_recv+0x3a4>
              goto memerr; /* ignore this packet */
  117f14:	e320f000 	nop	{0}
  117f18:	ea000004 	b	117f30 <dns_recv+0x3a4>
              goto memerr; /* ignore this packet */
  117f1c:	e320f000 	nop	{0}
  117f20:	ea000002 	b	117f30 <dns_recv+0x3a4>
                    goto memerr; /* ignore this packet */
  117f24:	e320f000 	nop	{0}
  117f28:	ea000000 	b	117f30 <dns_recv+0x3a4>
              goto memerr; /* ignore this packet */
  117f2c:	e320f000 	nop	{0}
  /* deallocate memory and return */
  pbuf_free(p);
  117f30:	e51b0048 	ldr	r0, [fp, #-72]	; 0xffffffb8
  117f34:	eb000c5e 	bl	11b0b4 <pbuf_free>
  return;
  117f38:	e320f000 	nop	{0}
}
  117f3c:	e24bd008 	sub	sp, fp, #8
  117f40:	e8bd8810 	pop	{r4, fp, pc}

00117f44 <dns_enqueue>:
 * @return err_t return code.
 */
static err_t
dns_enqueue(const char *name, size_t hostnamelen, dns_found_callback found,
            void *callback_arg LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype) LWIP_DNS_ISMDNS_ARG(u8_t is_mdns))
{
  117f44:	e92d4800 	push	{fp, lr}
  117f48:	e28db004 	add	fp, sp, #4
  117f4c:	e24dd028 	sub	sp, sp, #40	; 0x28
  117f50:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  117f54:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  117f58:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  117f5c:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
  u8_t i;
  u8_t lseq, lseqi;
  struct dns_table_entry *entry = NULL;
  117f60:	e3a03000 	mov	r3, #0
  117f64:	e50b300c 	str	r3, [fp, #-12]
  struct dns_req_entry* req;

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  u8_t r;
  /* check for duplicate entries */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
  117f68:	e3a03000 	mov	r3, #0
  117f6c:	e54b3005 	strb	r3, [fp, #-5]
  117f70:	ea000048 	b	118098 <dns_enqueue+0x154>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
  117f74:	e55b2005 	ldrb	r2, [fp, #-5]
  117f78:	e30e3c48 	movw	r3, #60488	; 0xec48
  117f7c:	e3403014 	movt	r3, #20
  117f80:	e3a01e11 	mov	r1, #272	; 0x110
  117f84:	e0020291 	mul	r2, r1, r2
  117f88:	e0833002 	add	r3, r3, r2
  117f8c:	e283300a 	add	r3, r3, #10
  117f90:	e5d33000 	ldrb	r3, [r3]
  117f94:	e3530002 	cmp	r3, #2
  117f98:	1a00003b 	bne	11808c <dns_enqueue+0x148>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0)) {
  117f9c:	e55b3005 	ldrb	r3, [fp, #-5]
  117fa0:	e3a02e11 	mov	r2, #272	; 0x110
  117fa4:	e0030392 	mul	r3, r2, r3
  117fa8:	e2832010 	add	r2, r3, #16
  117fac:	e30e3c48 	movw	r3, #60488	; 0xec48
  117fb0:	e3403014 	movt	r3, #20
  117fb4:	e0823003 	add	r3, r2, r3
  117fb8:	e3a02c01 	mov	r2, #256	; 0x100
  117fbc:	e1a01003 	mov	r1, r3
  117fc0:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  117fc4:	ebfffa87 	bl	1169e8 <lwip_strnicmp>
  117fc8:	e1a03000 	mov	r3, r0
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
  117fcc:	e3530000 	cmp	r3, #0
  117fd0:	1a00002d 	bne	11808c <dns_enqueue+0x148>
           for the same host should not be that common */
        continue;
      }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
      /* this is a duplicate entry, find a free request entry */
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
  117fd4:	e3a03000 	mov	r3, #0
  117fd8:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  117fdc:	ea000027 	b	118080 <dns_enqueue+0x13c>
        if (dns_requests[r].found == 0) {
  117fe0:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  117fe4:	e30f3088 	movw	r3, #61576	; 0xf088
  117fe8:	e3403014 	movt	r3, #20
  117fec:	e3a0100c 	mov	r1, #12
  117ff0:	e0020291 	mul	r2, r1, r2
  117ff4:	e0833002 	add	r3, r3, r2
  117ff8:	e5933000 	ldr	r3, [r3]
  117ffc:	e3530000 	cmp	r3, #0
  118000:	1a00001b 	bne	118074 <dns_enqueue+0x130>
          dns_requests[r].found = found;
  118004:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  118008:	e30f3088 	movw	r3, #61576	; 0xf088
  11800c:	e3403014 	movt	r3, #20
  118010:	e3a0100c 	mov	r1, #12
  118014:	e0020291 	mul	r2, r1, r2
  118018:	e0833002 	add	r3, r3, r2
  11801c:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  118020:	e5832000 	str	r2, [r3]
          dns_requests[r].arg = callback_arg;
  118024:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  118028:	e30f3088 	movw	r3, #61576	; 0xf088
  11802c:	e3403014 	movt	r3, #20
  118030:	e3a0100c 	mov	r1, #12
  118034:	e0020291 	mul	r2, r1, r2
  118038:	e0833002 	add	r3, r3, r2
  11803c:	e2833004 	add	r3, r3, #4
  118040:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  118044:	e5832000 	str	r2, [r3]
          dns_requests[r].dns_table_idx = i;
  118048:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  11804c:	e30f3088 	movw	r3, #61576	; 0xf088
  118050:	e3403014 	movt	r3, #20
  118054:	e3a0100c 	mov	r1, #12
  118058:	e0020291 	mul	r2, r1, r2
  11805c:	e0833002 	add	r3, r3, r2
  118060:	e2833008 	add	r3, r3, #8
  118064:	e55b2005 	ldrb	r2, [fp, #-5]
  118068:	e5c32000 	strb	r2, [r3]
          LWIP_DNS_SET_ADDRTYPE(dns_requests[r].reqaddrtype, dns_addrtype);
          LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": duplicate request\n", name));
          return ERR_INPROGRESS;
  11806c:	e3e03004 	mvn	r3, #4
  118070:	ea0000b3 	b	118344 <dns_enqueue+0x400>
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
  118074:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  118078:	e2833001 	add	r3, r3, #1
  11807c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  118080:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  118084:	e3530003 	cmp	r3, #3
  118088:	9affffd4 	bls	117fe0 <dns_enqueue+0x9c>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
  11808c:	e55b3005 	ldrb	r3, [fp, #-5]
  118090:	e2833001 	add	r3, r3, #1
  118094:	e54b3005 	strb	r3, [fp, #-5]
  118098:	e55b3005 	ldrb	r3, [fp, #-5]
  11809c:	e3530003 	cmp	r3, #3
  1180a0:	9affffb3 	bls	117f74 <dns_enqueue+0x30>
  }
  /* no duplicate entries found */
#endif

  /* search an unused entry, or the oldest one */
  lseq = 0;
  1180a4:	e3a03000 	mov	r3, #0
  1180a8:	e54b3006 	strb	r3, [fp, #-6]
  lseqi = DNS_TABLE_SIZE;
  1180ac:	e3a03004 	mov	r3, #4
  1180b0:	e54b3007 	strb	r3, [fp, #-7]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
  1180b4:	e3a03000 	mov	r3, #0
  1180b8:	e54b3005 	strb	r3, [fp, #-5]
  1180bc:	ea000020 	b	118144 <dns_enqueue+0x200>
    entry = &dns_table[i];
  1180c0:	e55b3005 	ldrb	r3, [fp, #-5]
  1180c4:	e3a02e11 	mov	r2, #272	; 0x110
  1180c8:	e0020392 	mul	r2, r2, r3
  1180cc:	e30e3c48 	movw	r3, #60488	; 0xec48
  1180d0:	e3403014 	movt	r3, #20
  1180d4:	e0823003 	add	r3, r2, r3
  1180d8:	e50b300c 	str	r3, [fp, #-12]
    /* is it an unused entry ? */
    if (entry->state == DNS_STATE_UNUSED) {
  1180dc:	e51b300c 	ldr	r3, [fp, #-12]
  1180e0:	e5d3300a 	ldrb	r3, [r3, #10]
  1180e4:	e3530000 	cmp	r3, #0
  1180e8:	0a000019 	beq	118154 <dns_enqueue+0x210>
      break;
    }
    /* check if this is the oldest completed entry */
    if (entry->state == DNS_STATE_DONE) {
  1180ec:	e51b300c 	ldr	r3, [fp, #-12]
  1180f0:	e5d3300a 	ldrb	r3, [r3, #10]
  1180f4:	e3530003 	cmp	r3, #3
  1180f8:	1a00000e 	bne	118138 <dns_enqueue+0x1f4>
      u8_t age = dns_seqno - entry->seqno;
  1180fc:	e30e3c45 	movw	r3, #60485	; 0xec45
  118100:	e3403014 	movt	r3, #20
  118104:	e5d32000 	ldrb	r2, [r3]
  118108:	e51b300c 	ldr	r3, [fp, #-12]
  11810c:	e5d3300e 	ldrb	r3, [r3, #14]
  118110:	e0423003 	sub	r3, r2, r3
  118114:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
      if (age > lseq) {
  118118:	e55b2012 	ldrb	r2, [fp, #-18]	; 0xffffffee
  11811c:	e55b3006 	ldrb	r3, [fp, #-6]
  118120:	e1520003 	cmp	r2, r3
  118124:	9a000003 	bls	118138 <dns_enqueue+0x1f4>
        lseq = age;
  118128:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
  11812c:	e54b3006 	strb	r3, [fp, #-6]
        lseqi = i;
  118130:	e55b3005 	ldrb	r3, [fp, #-5]
  118134:	e54b3007 	strb	r3, [fp, #-7]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
  118138:	e55b3005 	ldrb	r3, [fp, #-5]
  11813c:	e2833001 	add	r3, r3, #1
  118140:	e54b3005 	strb	r3, [fp, #-5]
  118144:	e55b3005 	ldrb	r3, [fp, #-5]
  118148:	e3530003 	cmp	r3, #3
  11814c:	9affffdb 	bls	1180c0 <dns_enqueue+0x17c>
  118150:	ea000000 	b	118158 <dns_enqueue+0x214>
      break;
  118154:	e320f000 	nop	{0}
      }
    }
  }

  /* if we don't have found an unused entry, use the oldest completed one */
  if (i == DNS_TABLE_SIZE) {
  118158:	e55b3005 	ldrb	r3, [fp, #-5]
  11815c:	e3530004 	cmp	r3, #4
  118160:	1a000017 	bne	1181c4 <dns_enqueue+0x280>
    if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
  118164:	e55b3007 	ldrb	r3, [fp, #-7]
  118168:	e3530003 	cmp	r3, #3
  11816c:	8a000009 	bhi	118198 <dns_enqueue+0x254>
  118170:	e55b2007 	ldrb	r2, [fp, #-7]
  118174:	e30e3c48 	movw	r3, #60488	; 0xec48
  118178:	e3403014 	movt	r3, #20
  11817c:	e3a01e11 	mov	r1, #272	; 0x110
  118180:	e0020291 	mul	r2, r1, r2
  118184:	e0833002 	add	r3, r3, r2
  118188:	e283300a 	add	r3, r3, #10
  11818c:	e5d33000 	ldrb	r3, [r3]
  118190:	e3530003 	cmp	r3, #3
  118194:	0a000001 	beq	1181a0 <dns_enqueue+0x25c>
      /* no entry can be used now, table is full */
      LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
      return ERR_MEM;
  118198:	e3e03000 	mvn	r3, #0
  11819c:	ea000068 	b	118344 <dns_enqueue+0x400>
    } else {
      /* use the oldest completed one */
      i = lseqi;
  1181a0:	e55b3007 	ldrb	r3, [fp, #-7]
  1181a4:	e54b3005 	strb	r3, [fp, #-5]
      entry = &dns_table[i];
  1181a8:	e55b3005 	ldrb	r3, [fp, #-5]
  1181ac:	e3a02e11 	mov	r2, #272	; 0x110
  1181b0:	e0020392 	mul	r2, r2, r3
  1181b4:	e30e3c48 	movw	r3, #60488	; 0xec48
  1181b8:	e3403014 	movt	r3, #20
  1181bc:	e0823003 	add	r3, r2, r3
  1181c0:	e50b300c 	str	r3, [fp, #-12]
    }
  }

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  /* find a free request entry */
  req = NULL;
  1181c4:	e3a03000 	mov	r3, #0
  1181c8:	e50b3010 	str	r3, [fp, #-16]
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
  1181cc:	e3a03000 	mov	r3, #0
  1181d0:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  1181d4:	ea000013 	b	118228 <dns_enqueue+0x2e4>
    if (dns_requests[r].found == NULL) {
  1181d8:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  1181dc:	e30f3088 	movw	r3, #61576	; 0xf088
  1181e0:	e3403014 	movt	r3, #20
  1181e4:	e3a0100c 	mov	r1, #12
  1181e8:	e0020291 	mul	r2, r1, r2
  1181ec:	e0833002 	add	r3, r3, r2
  1181f0:	e5933000 	ldr	r3, [r3]
  1181f4:	e3530000 	cmp	r3, #0
  1181f8:	1a000007 	bne	11821c <dns_enqueue+0x2d8>
      req = &dns_requests[r];
  1181fc:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  118200:	e3a0200c 	mov	r2, #12
  118204:	e0020392 	mul	r2, r2, r3
  118208:	e30f3088 	movw	r3, #61576	; 0xf088
  11820c:	e3403014 	movt	r3, #20
  118210:	e0823003 	add	r3, r2, r3
  118214:	e50b3010 	str	r3, [fp, #-16]
      break;
  118218:	ea000005 	b	118234 <dns_enqueue+0x2f0>
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
  11821c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  118220:	e2833001 	add	r3, r3, #1
  118224:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  118228:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  11822c:	e3530003 	cmp	r3, #3
  118230:	9affffe8 	bls	1181d8 <dns_enqueue+0x294>
    }
  }
  if (req == NULL) {
  118234:	e51b3010 	ldr	r3, [fp, #-16]
  118238:	e3530000 	cmp	r3, #0
  11823c:	1a000001 	bne	118248 <dns_enqueue+0x304>
    /* no request entry can be used now, table is full */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS request entries table is full\n", name));
    return ERR_MEM;
  118240:	e3e03000 	mvn	r3, #0
  118244:	ea00003e 	b	118344 <dns_enqueue+0x400>
  }
  req->dns_table_idx = i;
  118248:	e51b3010 	ldr	r3, [fp, #-16]
  11824c:	e55b2005 	ldrb	r2, [fp, #-5]
  118250:	e5c32008 	strb	r2, [r3, #8]

  /* use this entry */
  LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));

  /* fill the entry */
  entry->state = DNS_STATE_NEW;
  118254:	e51b300c 	ldr	r3, [fp, #-12]
  118258:	e3a02001 	mov	r2, #1
  11825c:	e5c3200a 	strb	r2, [r3, #10]
  entry->seqno = dns_seqno;
  118260:	e30e3c45 	movw	r3, #60485	; 0xec45
  118264:	e3403014 	movt	r3, #20
  118268:	e5d32000 	ldrb	r2, [r3]
  11826c:	e51b300c 	ldr	r3, [fp, #-12]
  118270:	e5c3200e 	strb	r2, [r3, #14]
  LWIP_DNS_SET_ADDRTYPE(entry->reqaddrtype, dns_addrtype);
  LWIP_DNS_SET_ADDRTYPE(req->reqaddrtype, dns_addrtype);
  req->found = found;
  118274:	e51b3010 	ldr	r3, [fp, #-16]
  118278:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  11827c:	e5832000 	str	r2, [r3]
  req->arg   = callback_arg;
  118280:	e51b3010 	ldr	r3, [fp, #-16]
  118284:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  118288:	e5832004 	str	r2, [r3, #4]
  namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH-1);
  11828c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  118290:	e35300ff 	cmp	r3, #255	; 0xff
  118294:	31a03003 	movcc	r3, r3
  118298:	23a030ff 	movcs	r3, #255	; 0xff
  11829c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  MEMCPY(entry->name, name, namelen);
  1182a0:	e51b300c 	ldr	r3, [fp, #-12]
  1182a4:	e2833010 	add	r3, r3, #16
  1182a8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1182ac:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  1182b0:	e1a00003 	mov	r0, r3
  1182b4:	eb00a336 	bl	140f94 <memcpy>
  entry->name[namelen] = 0;
  1182b8:	e51b200c 	ldr	r2, [fp, #-12]
  1182bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1182c0:	e0823003 	add	r3, r2, r3
  1182c4:	e2833010 	add	r3, r3, #16
  1182c8:	e3a02000 	mov	r2, #0
  1182cc:	e5c32000 	strb	r2, [r3]

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  entry->pcb_idx = dns_alloc_pcb();
  1182d0:	ebfffc32 	bl	1173a0 <dns_alloc_pcb>
  1182d4:	e1a03000 	mov	r3, r0
  1182d8:	e1a02003 	mov	r2, r3
  1182dc:	e51b300c 	ldr	r3, [fp, #-12]
  1182e0:	e5c3200f 	strb	r2, [r3, #15]
  if (entry->pcb_idx >= DNS_MAX_SOURCE_PORTS) {
  1182e4:	e51b300c 	ldr	r3, [fp, #-12]
  1182e8:	e5d3300f 	ldrb	r3, [r3, #15]
  1182ec:	e3530003 	cmp	r3, #3
  1182f0:	9a000007 	bls	118314 <dns_enqueue+0x3d0>
    /* failed to get a UDP pcb */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": failed to allocate a pcb\n", name));
    entry->state = DNS_STATE_UNUSED;
  1182f4:	e51b300c 	ldr	r3, [fp, #-12]
  1182f8:	e3a02000 	mov	r2, #0
  1182fc:	e5c3200a 	strb	r2, [r3, #10]
    req->found = NULL;
  118300:	e51b3010 	ldr	r3, [fp, #-16]
  118304:	e3a02000 	mov	r2, #0
  118308:	e5832000 	str	r2, [r3]
    return ERR_MEM;
  11830c:	e3e03000 	mvn	r3, #0
  118310:	ea00000b 	b	118344 <dns_enqueue+0x400>

#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  entry->is_mdns = is_mdns;
#endif

  dns_seqno++;
  118314:	e30e3c45 	movw	r3, #60485	; 0xec45
  118318:	e3403014 	movt	r3, #20
  11831c:	e5d33000 	ldrb	r3, [r3]
  118320:	e2833001 	add	r3, r3, #1
  118324:	e6ef2073 	uxtb	r2, r3
  118328:	e30e3c45 	movw	r3, #60485	; 0xec45
  11832c:	e3403014 	movt	r3, #20
  118330:	e5c32000 	strb	r2, [r3]

  /* force to send query without waiting timer */
  dns_check_entry(i);
  118334:	e55b3005 	ldrb	r3, [fp, #-5]
  118338:	e1a00003 	mov	r0, r3
  11833c:	ebfffd38 	bl	117824 <dns_check_entry>

  /* dns query is enqueued */
  return ERR_INPROGRESS;
  118340:	e3e03004 	mvn	r3, #4
}
  118344:	e1a00003 	mov	r0, r3
  118348:	e24bd004 	sub	sp, fp, #4
  11834c:	e8bd8800 	pop	{fp, pc}

00118350 <dns_gethostbyname>:
 * @return a err_t return code.
 */
err_t
dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                  void *callback_arg)
{
  118350:	e92d4800 	push	{fp, lr}
  118354:	e28db004 	add	fp, sp, #4
  118358:	e24dd018 	sub	sp, sp, #24
  11835c:	e50b0008 	str	r0, [fp, #-8]
  118360:	e50b100c 	str	r1, [fp, #-12]
  118364:	e50b2010 	str	r2, [fp, #-16]
  118368:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_DEFAULT);
  11836c:	e3a03000 	mov	r3, #0
  118370:	e58d3000 	str	r3, [sp]
  118374:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  118378:	e51b2010 	ldr	r2, [fp, #-16]
  11837c:	e51b100c 	ldr	r1, [fp, #-12]
  118380:	e51b0008 	ldr	r0, [fp, #-8]
  118384:	eb000003 	bl	118398 <dns_gethostbyname_addrtype>
  118388:	e1a03000 	mov	r3, r0
}
  11838c:	e1a00003 	mov	r0, r3
  118390:	e24bd004 	sub	sp, fp, #4
  118394:	e8bd8800 	pop	{fp, pc}

00118398 <dns_gethostbyname_addrtype>:
 *                     - LWIP_DNS_ADDRTYPE_IPV6: try to resolve IPv6 only
 */
err_t
dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                           void *callback_arg, u8_t dns_addrtype)
{
  118398:	e92d4800 	push	{fp, lr}
  11839c:	e28db004 	add	fp, sp, #4
  1183a0:	e24dd018 	sub	sp, sp, #24
  1183a4:	e50b0010 	str	r0, [fp, #-16]
  1183a8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1183ac:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  1183b0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  u8_t is_mdns;
#endif
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((addr == NULL) ||
  1183b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1183b8:	e3530000 	cmp	r3, #0
  1183bc:	0a000006 	beq	1183dc <dns_gethostbyname_addrtype+0x44>
  1183c0:	e51b3010 	ldr	r3, [fp, #-16]
  1183c4:	e3530000 	cmp	r3, #0
  1183c8:	0a000003 	beq	1183dc <dns_gethostbyname_addrtype+0x44>
      (!hostname) || (!hostname[0])) {
  1183cc:	e51b3010 	ldr	r3, [fp, #-16]
  1183d0:	e5d33000 	ldrb	r3, [r3]
  1183d4:	e3530000 	cmp	r3, #0
  1183d8:	1a000001 	bne	1183e4 <dns_gethostbyname_addrtype+0x4c>
    return ERR_ARG;
  1183dc:	e3e0300f 	mvn	r3, #15
  1183e0:	ea000024 	b	118478 <dns_gethostbyname_addrtype+0xe0>
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
  if (dns_pcbs[0] == NULL) {
    return ERR_ARG;
  }
#endif
  hostnamelen = strlen(hostname);
  1183e4:	e51b0010 	ldr	r0, [fp, #-16]
  1183e8:	eb00a4b2 	bl	1416b8 <strlen>
  1183ec:	e50b0008 	str	r0, [fp, #-8]
  if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
  1183f0:	e51b3008 	ldr	r3, [fp, #-8]
  1183f4:	e35300ff 	cmp	r3, #255	; 0xff
  1183f8:	9a000001 	bls	118404 <dns_gethostbyname_addrtype+0x6c>
    LWIP_DEBUGF(DNS_DEBUG, ("dns_gethostbyname: name too long to resolve"));
    return ERR_ARG;
  1183fc:	e3e0300f 	mvn	r3, #15
  118400:	ea00001c 	b	118478 <dns_gethostbyname_addrtype+0xe0>
    return ERR_OK;
  }
#endif /* LWIP_HAVE_LOOPIF */

  /* host name already in octet notation? set ip addr and return ERR_OK */
  if (ipaddr_aton(hostname, addr)) {
  118404:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  118408:	e51b0010 	ldr	r0, [fp, #-16]
  11840c:	eb006934 	bl	1328e4 <ip4addr_aton>
  118410:	e1a03000 	mov	r3, r0
  118414:	e3530000 	cmp	r3, #0
  118418:	0a000001 	beq	118424 <dns_gethostbyname_addrtype+0x8c>
#if LWIP_IPV4 && LWIP_IPV6
    if ((IP_IS_V6(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV4)) ||
        (IP_IS_V4(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV6)))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
    {
      return ERR_OK;
  11841c:	e3a03000 	mov	r3, #0
  118420:	ea000014 	b	118478 <dns_gethostbyname_addrtype+0xe0>
    }
  }
  /* already have this address cached? */
  if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
  118424:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  118428:	e51b0010 	ldr	r0, [fp, #-16]
  11842c:	ebfffa34 	bl	116d04 <dns_lookup>
  118430:	e1a03000 	mov	r3, r0
  118434:	e3530000 	cmp	r3, #0
  118438:	1a000001 	bne	118444 <dns_gethostbyname_addrtype+0xac>
    return ERR_OK;
  11843c:	e3a03000 	mov	r3, #0
  118440:	ea00000c 	b	118478 <dns_gethostbyname_addrtype+0xe0>

  if (!is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
  {
    /* prevent calling found callback if no server is set, return error instead */
    if (ip_addr_isany_val(dns_servers[0])) {
  118444:	e30f30b8 	movw	r3, #61624	; 0xf0b8
  118448:	e3403014 	movt	r3, #20
  11844c:	e5933000 	ldr	r3, [r3]
  118450:	e3530000 	cmp	r3, #0
  118454:	1a000001 	bne	118460 <dns_gethostbyname_addrtype+0xc8>
      return ERR_VAL;
  118458:	e3e03005 	mvn	r3, #5
  11845c:	ea000005 	b	118478 <dns_gethostbyname_addrtype+0xe0>
    }
  }

  /* queue query with specified callback */
  return dns_enqueue(hostname, hostnamelen, found, callback_arg LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)
  118460:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  118464:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  118468:	e51b1008 	ldr	r1, [fp, #-8]
  11846c:	e51b0010 	ldr	r0, [fp, #-16]
  118470:	ebfffeb3 	bl	117f44 <dns_enqueue>
  118474:	e1a03000 	mov	r3, r0
     LWIP_DNS_ISMDNS_ARG(is_mdns));
}
  118478:	e1a00003 	mov	r0, r3
  11847c:	e24bd004 	sub	sp, fp, #4
  118480:	e8bd8800 	pop	{fp, pc}

00118484 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
  118484:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  118488:	e28db000 	add	fp, sp, #0
  11848c:	e24dd024 	sub	sp, sp, #36	; 0x24
  118490:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  118494:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  const u8_t *pb = (const u8_t *)dataptr;
  118498:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11849c:	e50b3008 	str	r3, [fp, #-8]
  const u16_t *ps;
  u16_t t = 0;
  1184a0:	e3a03000 	mov	r3, #0
  1184a4:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  u32_t sum = 0;
  1184a8:	e3a03000 	mov	r3, #0
  1184ac:	e50b3010 	str	r3, [fp, #-16]
  int odd = ((mem_ptr_t)pb & 1);
  1184b0:	e51b3008 	ldr	r3, [fp, #-8]
  1184b4:	e2033001 	and	r3, r3, #1
  1184b8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

  /* Get aligned to u16_t */
  if (odd && len > 0) {
  1184bc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1184c0:	e3530000 	cmp	r3, #0
  1184c4:	0a00000c 	beq	1184fc <lwip_standard_chksum+0x78>
  1184c8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1184cc:	e3530000 	cmp	r3, #0
  1184d0:	da000009 	ble	1184fc <lwip_standard_chksum+0x78>
    ((u8_t *)&t)[1] = *pb++;
  1184d4:	e51b2008 	ldr	r2, [fp, #-8]
  1184d8:	e2823001 	add	r3, r2, #1
  1184dc:	e50b3008 	str	r3, [fp, #-8]
  1184e0:	e24b3016 	sub	r3, fp, #22
  1184e4:	e2833001 	add	r3, r3, #1
  1184e8:	e5d22000 	ldrb	r2, [r2]
  1184ec:	e5c32000 	strb	r2, [r3]
    len--;
  1184f0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1184f4:	e2433001 	sub	r3, r3, #1
  1184f8:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
  1184fc:	e51b3008 	ldr	r3, [fp, #-8]
  118500:	e50b300c 	str	r3, [fp, #-12]
  while (len > 1) {
  118504:	ea00000a 	b	118534 <lwip_standard_chksum+0xb0>
    sum += *ps++;
  118508:	e51b300c 	ldr	r3, [fp, #-12]
  11850c:	e2832002 	add	r2, r3, #2
  118510:	e50b200c 	str	r2, [fp, #-12]
  118514:	e1d330b0 	ldrh	r3, [r3]
  118518:	e1a02003 	mov	r2, r3
  11851c:	e51b3010 	ldr	r3, [fp, #-16]
  118520:	e0833002 	add	r3, r3, r2
  118524:	e50b3010 	str	r3, [fp, #-16]
    len -= 2;
  118528:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11852c:	e2433002 	sub	r3, r3, #2
  118530:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  while (len > 1) {
  118534:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  118538:	e3530001 	cmp	r3, #1
  11853c:	cafffff1 	bgt	118508 <lwip_standard_chksum+0x84>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
  118540:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  118544:	e3530000 	cmp	r3, #0
  118548:	da000003 	ble	11855c <lwip_standard_chksum+0xd8>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
  11854c:	e24b3016 	sub	r3, fp, #22
  118550:	e51b200c 	ldr	r2, [fp, #-12]
  118554:	e5d22000 	ldrb	r2, [r2]
  118558:	e5c32000 	strb	r2, [r3]
  }

  /* Add end bytes */
  sum += t;
  11855c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  118560:	e1a02003 	mov	r2, r3
  118564:	e51b3010 	ldr	r3, [fp, #-16]
  118568:	e0833002 	add	r3, r3, r2
  11856c:	e50b3010 	str	r3, [fp, #-16]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
  118570:	e51b3010 	ldr	r3, [fp, #-16]
  118574:	e1a02823 	lsr	r2, r3, #16
  118578:	e51b3010 	ldr	r3, [fp, #-16]
  11857c:	e6ff3073 	uxth	r3, r3
  118580:	e0823003 	add	r3, r2, r3
  118584:	e50b3010 	str	r3, [fp, #-16]
  sum = FOLD_U32T(sum);
  118588:	e51b3010 	ldr	r3, [fp, #-16]
  11858c:	e1a02823 	lsr	r2, r3, #16
  118590:	e51b3010 	ldr	r3, [fp, #-16]
  118594:	e6ff3073 	uxth	r3, r3
  118598:	e0823003 	add	r3, r2, r3
  11859c:	e50b3010 	str	r3, [fp, #-16]

  /* Swap if alignment was odd */
  if (odd) {
  1185a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1185a4:	e3530000 	cmp	r3, #0
  1185a8:	0a000007 	beq	1185cc <lwip_standard_chksum+0x148>
    sum = SWAP_BYTES_IN_WORD(sum);
  1185ac:	e51b3010 	ldr	r3, [fp, #-16]
  1185b0:	e1a03403 	lsl	r3, r3, #8
  1185b4:	e6ff2073 	uxth	r2, r3
  1185b8:	e51b3010 	ldr	r3, [fp, #-16]
  1185bc:	e1a03423 	lsr	r3, r3, #8
  1185c0:	e6ef3073 	uxtb	r3, r3
  1185c4:	e1823003 	orr	r3, r2, r3
  1185c8:	e50b3010 	str	r3, [fp, #-16]
  }

  return (u16_t)sum;
  1185cc:	e51b3010 	ldr	r3, [fp, #-16]
  1185d0:	e6ff3073 	uxth	r3, r3
}
  1185d4:	e1a00003 	mov	r0, r3
  1185d8:	e28bd000 	add	sp, fp, #0
  1185dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1185e0:	e12fff1e 	bx	lr

001185e4 <inet_cksum_pseudo_base>:
#endif

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_base(struct pbuf *p, u8_t proto, u16_t proto_len, u32_t acc)
{
  1185e4:	e92d4800 	push	{fp, lr}
  1185e8:	e28db004 	add	fp, sp, #4
  1185ec:	e24dd018 	sub	sp, sp, #24
  1185f0:	e50b0010 	str	r0, [fp, #-16]
  1185f4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  1185f8:	e1a03001 	mov	r3, r1
  1185fc:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  118600:	e1a03002 	mov	r3, r2
  118604:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  struct pbuf *q;
  u8_t swapped = 0;
  118608:	e3a03000 	mov	r3, #0
  11860c:	e54b3009 	strb	r3, [fp, #-9]

  /* iterate through all pbuf in chain */
  for (q = p; q != NULL; q = q->next) {
  118610:	e51b3010 	ldr	r3, [fp, #-16]
  118614:	e50b3008 	str	r3, [fp, #-8]
  118618:	ea000025 	b	1186b4 <inet_cksum_pseudo_base+0xd0>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  11861c:	e51b3008 	ldr	r3, [fp, #-8]
  118620:	e5932004 	ldr	r2, [r3, #4]
  118624:	e51b3008 	ldr	r3, [fp, #-8]
  118628:	e1d330ba 	ldrh	r3, [r3, #10]
  11862c:	e1a01003 	mov	r1, r3
  118630:	e1a00002 	mov	r0, r2
  118634:	ebffff92 	bl	118484 <lwip_standard_chksum>
  118638:	e1a03000 	mov	r3, r0
  11863c:	e1a02003 	mov	r2, r3
  118640:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118644:	e0833002 	add	r3, r3, r2
  118648:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  11864c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118650:	e1a02823 	lsr	r2, r3, #16
  118654:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118658:	e6ff3073 	uxth	r3, r3
  11865c:	e0823003 	add	r3, r2, r3
  118660:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    if (q->len % 2 != 0) {
  118664:	e51b3008 	ldr	r3, [fp, #-8]
  118668:	e1d330ba 	ldrh	r3, [r3, #10]
  11866c:	e2033001 	and	r3, r3, #1
  118670:	e6ff3073 	uxth	r3, r3
  118674:	e3530000 	cmp	r3, #0
  118678:	0a00000a 	beq	1186a8 <inet_cksum_pseudo_base+0xc4>
      swapped = 1 - swapped;
  11867c:	e55b3009 	ldrb	r3, [fp, #-9]
  118680:	e2633001 	rsb	r3, r3, #1
  118684:	e54b3009 	strb	r3, [fp, #-9]
      acc = SWAP_BYTES_IN_WORD(acc);
  118688:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11868c:	e1a03403 	lsl	r3, r3, #8
  118690:	e6ff2073 	uxth	r2, r3
  118694:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118698:	e1a03423 	lsr	r3, r3, #8
  11869c:	e6ef3073 	uxtb	r3, r3
  1186a0:	e1823003 	orr	r3, r2, r3
  1186a4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  for (q = p; q != NULL; q = q->next) {
  1186a8:	e51b3008 	ldr	r3, [fp, #-8]
  1186ac:	e5933000 	ldr	r3, [r3]
  1186b0:	e50b3008 	str	r3, [fp, #-8]
  1186b4:	e51b3008 	ldr	r3, [fp, #-8]
  1186b8:	e3530000 	cmp	r3, #0
  1186bc:	1affffd6 	bne	11861c <inet_cksum_pseudo_base+0x38>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  1186c0:	e55b3009 	ldrb	r3, [fp, #-9]
  1186c4:	e3530000 	cmp	r3, #0
  1186c8:	0a000007 	beq	1186ec <inet_cksum_pseudo_base+0x108>
    acc = SWAP_BYTES_IN_WORD(acc);
  1186cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1186d0:	e1a03403 	lsl	r3, r3, #8
  1186d4:	e6ff2073 	uxth	r2, r3
  1186d8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1186dc:	e1a03423 	lsr	r3, r3, #8
  1186e0:	e6ef3073 	uxtb	r3, r3
  1186e4:	e1823003 	orr	r3, r2, r3
  1186e8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
  1186ec:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  1186f0:	e6ff3073 	uxth	r3, r3
  1186f4:	e1a00003 	mov	r0, r3
  1186f8:	ebfff836 	bl	1167d8 <lwip_htons>
  1186fc:	e1a03000 	mov	r3, r0
  118700:	e1a02003 	mov	r2, r3
  118704:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118708:	e0833002 	add	r3, r3, r2
  11870c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  acc += (u32_t)lwip_htons(proto_len);
  118710:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
  118714:	e1a00003 	mov	r0, r3
  118718:	ebfff82e 	bl	1167d8 <lwip_htons>
  11871c:	e1a03000 	mov	r3, r0
  118720:	e1a02003 	mov	r2, r3
  118724:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118728:	e0833002 	add	r3, r3, r2
  11872c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
  118730:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118734:	e1a02823 	lsr	r2, r3, #16
  118738:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11873c:	e6ff3073 	uxth	r3, r3
  118740:	e0823003 	add	r3, r2, r3
  118744:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  acc = FOLD_U32T(acc);
  118748:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11874c:	e1a02823 	lsr	r2, r3, #16
  118750:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118754:	e6ff3073 	uxth	r3, r3
  118758:	e0823003 	add	r3, r2, r3
  11875c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  118760:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118764:	e6ff3073 	uxth	r3, r3
  118768:	e1e03003 	mvn	r3, r3
  11876c:	e6ff3073 	uxth	r3, r3
}
  118770:	e1a00003 	mov	r0, r3
  118774:	e24bd004 	sub	sp, fp, #4
  118778:	e8bd8800 	pop	{fp, pc}

0011877c <inet_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
       const ip4_addr_t *src, const ip4_addr_t *dest)
{
  11877c:	e92d4800 	push	{fp, lr}
  118780:	e28db004 	add	fp, sp, #4
  118784:	e24dd018 	sub	sp, sp, #24
  118788:	e50b0010 	str	r0, [fp, #-16]
  11878c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  118790:	e1a03001 	mov	r3, r1
  118794:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  118798:	e1a03002 	mov	r3, r2
  11879c:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
  1187a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1187a4:	e5933000 	ldr	r3, [r3]
  1187a8:	e50b3008 	str	r3, [fp, #-8]
  acc = (addr & 0xffffUL);
  1187ac:	e51b3008 	ldr	r3, [fp, #-8]
  1187b0:	e6ff3073 	uxth	r3, r3
  1187b4:	e50b300c 	str	r3, [fp, #-12]
  acc += ((addr >> 16) & 0xffffUL);
  1187b8:	e51b3008 	ldr	r3, [fp, #-8]
  1187bc:	e1a03823 	lsr	r3, r3, #16
  1187c0:	e51b200c 	ldr	r2, [fp, #-12]
  1187c4:	e0823003 	add	r3, r2, r3
  1187c8:	e50b300c 	str	r3, [fp, #-12]
  addr = ip4_addr_get_u32(dest);
  1187cc:	e59b3004 	ldr	r3, [fp, #4]
  1187d0:	e5933000 	ldr	r3, [r3]
  1187d4:	e50b3008 	str	r3, [fp, #-8]
  acc += (addr & 0xffffUL);
  1187d8:	e51b3008 	ldr	r3, [fp, #-8]
  1187dc:	e6ff3073 	uxth	r3, r3
  1187e0:	e51b200c 	ldr	r2, [fp, #-12]
  1187e4:	e0823003 	add	r3, r2, r3
  1187e8:	e50b300c 	str	r3, [fp, #-12]
  acc += ((addr >> 16) & 0xffffUL);
  1187ec:	e51b3008 	ldr	r3, [fp, #-8]
  1187f0:	e1a03823 	lsr	r3, r3, #16
  1187f4:	e51b200c 	ldr	r2, [fp, #-12]
  1187f8:	e0823003 	add	r3, r2, r3
  1187fc:	e50b300c 	str	r3, [fp, #-12]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
  118800:	e51b300c 	ldr	r3, [fp, #-12]
  118804:	e1a02823 	lsr	r2, r3, #16
  118808:	e51b300c 	ldr	r3, [fp, #-12]
  11880c:	e6ff3073 	uxth	r3, r3
  118810:	e0823003 	add	r3, r2, r3
  118814:	e50b300c 	str	r3, [fp, #-12]
  acc = FOLD_U32T(acc);
  118818:	e51b300c 	ldr	r3, [fp, #-12]
  11881c:	e1a02823 	lsr	r2, r3, #16
  118820:	e51b300c 	ldr	r3, [fp, #-12]
  118824:	e6ff3073 	uxth	r3, r3
  118828:	e0823003 	add	r3, r2, r3
  11882c:	e50b300c 	str	r3, [fp, #-12]

  return inet_cksum_pseudo_base(p, proto, proto_len, acc);
  118830:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
  118834:	e55b1011 	ldrb	r1, [fp, #-17]	; 0xffffffef
  118838:	e51b300c 	ldr	r3, [fp, #-12]
  11883c:	e51b0010 	ldr	r0, [fp, #-16]
  118840:	ebffff67 	bl	1185e4 <inet_cksum_pseudo_base>
  118844:	e1a03000 	mov	r3, r0
}
  118848:	e1a00003 	mov	r0, r3
  11884c:	e24bd004 	sub	sp, fp, #4
  118850:	e8bd8800 	pop	{fp, pc}

00118854 <ip_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
       const ip_addr_t *src, const ip_addr_t *dest)
{
  118854:	e92d4800 	push	{fp, lr}
  118858:	e28db004 	add	fp, sp, #4
  11885c:	e24dd018 	sub	sp, sp, #24
  118860:	e50b0008 	str	r0, [fp, #-8]
  118864:	e50b3010 	str	r3, [fp, #-16]
  118868:	e1a03001 	mov	r3, r1
  11886c:	e54b3009 	strb	r3, [fp, #-9]
  118870:	e1a03002 	mov	r3, r2
  118874:	e14b30bc 	strh	r3, [fp, #-12]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo(p, proto, proto_len, ip_2_ip4(src), ip_2_ip4(dest));
  118878:	e15b20bc 	ldrh	r2, [fp, #-12]
  11887c:	e55b1009 	ldrb	r1, [fp, #-9]
  118880:	e59b3004 	ldr	r3, [fp, #4]
  118884:	e58d3000 	str	r3, [sp]
  118888:	e51b3010 	ldr	r3, [fp, #-16]
  11888c:	e51b0008 	ldr	r0, [fp, #-8]
  118890:	ebffffb9 	bl	11877c <inet_chksum_pseudo>
  118894:	e1a03000 	mov	r3, r0
  }
#endif /* LWIP_IPV4 */
}
  118898:	e1a00003 	mov	r0, r3
  11889c:	e24bd004 	sub	sp, fp, #4
  1188a0:	e8bd8800 	pop	{fp, pc}

001188a4 <inet_cksum_pseudo_partial_base>:

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_partial_base(struct pbuf *p, u8_t proto, u16_t proto_len,
       u16_t chksum_len, u32_t acc)
{
  1188a4:	e92d4800 	push	{fp, lr}
  1188a8:	e28db004 	add	fp, sp, #4
  1188ac:	e24dd018 	sub	sp, sp, #24
  1188b0:	e50b0010 	str	r0, [fp, #-16]
  1188b4:	e1a00001 	mov	r0, r1
  1188b8:	e1a01002 	mov	r1, r2
  1188bc:	e1a02003 	mov	r2, r3
  1188c0:	e1a03000 	mov	r3, r0
  1188c4:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  1188c8:	e1a03001 	mov	r3, r1
  1188cc:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  1188d0:	e1a03002 	mov	r3, r2
  1188d4:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  struct pbuf *q;
  u8_t swapped = 0;
  1188d8:	e3a03000 	mov	r3, #0
  1188dc:	e54b3009 	strb	r3, [fp, #-9]
  u16_t chklen;

  /* iterate through all pbuf in chain */
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  1188e0:	e51b3010 	ldr	r3, [fp, #-16]
  1188e4:	e50b3008 	str	r3, [fp, #-8]
  1188e8:	ea00003c 	b	1189e0 <inet_cksum_pseudo_partial_base+0x13c>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  1188ec:	e51b3008 	ldr	r3, [fp, #-8]
  1188f0:	e1d330ba 	ldrh	r3, [r3, #10]
  1188f4:	e14b30bc 	strh	r3, [fp, #-12]
    if (chklen > chksum_len) {
  1188f8:	e15b20bc 	ldrh	r2, [fp, #-12]
  1188fc:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  118900:	e1520003 	cmp	r2, r3
  118904:	9a000001 	bls	118910 <inet_cksum_pseudo_partial_base+0x6c>
      chklen = chksum_len;
  118908:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  11890c:	e14b30bc 	strh	r3, [fp, #-12]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  118910:	e51b3008 	ldr	r3, [fp, #-8]
  118914:	e5933004 	ldr	r3, [r3, #4]
  118918:	e15b20bc 	ldrh	r2, [fp, #-12]
  11891c:	e1a01002 	mov	r1, r2
  118920:	e1a00003 	mov	r0, r3
  118924:	ebfffed6 	bl	118484 <lwip_standard_chksum>
  118928:	e1a03000 	mov	r3, r0
  11892c:	e1a02003 	mov	r2, r3
  118930:	e59b3004 	ldr	r3, [fp, #4]
  118934:	e0833002 	add	r3, r3, r2
  118938:	e58b3004 	str	r3, [fp, #4]
    chksum_len -= chklen;
  11893c:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  118940:	e15b30bc 	ldrh	r3, [fp, #-12]
  118944:	e0423003 	sub	r3, r2, r3
  118948:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  11894c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  118950:	e3072ffe 	movw	r2, #32766	; 0x7ffe
  118954:	e1530002 	cmp	r3, r2
  118958:	9a000006 	bls	118978 <inet_cksum_pseudo_partial_base+0xd4>
  11895c:	e3070314 	movw	r0, #29460	; 0x7314
  118960:	e3400014 	movt	r0, #20
  118964:	ebffa9ea 	bl	103114 <rt_kprintf>
  118968:	e3a01e1a 	mov	r1, #416	; 0x1a0
  11896c:	e3070320 	movw	r0, #29472	; 0x7320
  118970:	e3400014 	movt	r0, #20
  118974:	ebffc9c0 	bl	10b07c <sys_arch_assert>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  118978:	e59b3004 	ldr	r3, [fp, #4]
  11897c:	e1a02823 	lsr	r2, r3, #16
  118980:	e59b3004 	ldr	r3, [fp, #4]
  118984:	e6ff3073 	uxth	r3, r3
  118988:	e0823003 	add	r3, r2, r3
  11898c:	e58b3004 	str	r3, [fp, #4]
    if (q->len % 2 != 0) {
  118990:	e51b3008 	ldr	r3, [fp, #-8]
  118994:	e1d330ba 	ldrh	r3, [r3, #10]
  118998:	e2033001 	and	r3, r3, #1
  11899c:	e6ff3073 	uxth	r3, r3
  1189a0:	e3530000 	cmp	r3, #0
  1189a4:	0a00000a 	beq	1189d4 <inet_cksum_pseudo_partial_base+0x130>
      swapped = 1 - swapped;
  1189a8:	e55b3009 	ldrb	r3, [fp, #-9]
  1189ac:	e2633001 	rsb	r3, r3, #1
  1189b0:	e54b3009 	strb	r3, [fp, #-9]
      acc = SWAP_BYTES_IN_WORD(acc);
  1189b4:	e59b3004 	ldr	r3, [fp, #4]
  1189b8:	e1a03403 	lsl	r3, r3, #8
  1189bc:	e6ff2073 	uxth	r2, r3
  1189c0:	e59b3004 	ldr	r3, [fp, #4]
  1189c4:	e1a03423 	lsr	r3, r3, #8
  1189c8:	e6ef3073 	uxtb	r3, r3
  1189cc:	e1823003 	orr	r3, r2, r3
  1189d0:	e58b3004 	str	r3, [fp, #4]
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  1189d4:	e51b3008 	ldr	r3, [fp, #-8]
  1189d8:	e5933000 	ldr	r3, [r3]
  1189dc:	e50b3008 	str	r3, [fp, #-8]
  1189e0:	e51b3008 	ldr	r3, [fp, #-8]
  1189e4:	e3530000 	cmp	r3, #0
  1189e8:	0a000002 	beq	1189f8 <inet_cksum_pseudo_partial_base+0x154>
  1189ec:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  1189f0:	e3530000 	cmp	r3, #0
  1189f4:	1affffbc 	bne	1188ec <inet_cksum_pseudo_partial_base+0x48>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  1189f8:	e55b3009 	ldrb	r3, [fp, #-9]
  1189fc:	e3530000 	cmp	r3, #0
  118a00:	0a000007 	beq	118a24 <inet_cksum_pseudo_partial_base+0x180>
    acc = SWAP_BYTES_IN_WORD(acc);
  118a04:	e59b3004 	ldr	r3, [fp, #4]
  118a08:	e1a03403 	lsl	r3, r3, #8
  118a0c:	e6ff2073 	uxth	r2, r3
  118a10:	e59b3004 	ldr	r3, [fp, #4]
  118a14:	e1a03423 	lsr	r3, r3, #8
  118a18:	e6ef3073 	uxtb	r3, r3
  118a1c:	e1823003 	orr	r3, r2, r3
  118a20:	e58b3004 	str	r3, [fp, #4]
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
  118a24:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  118a28:	e6ff3073 	uxth	r3, r3
  118a2c:	e1a00003 	mov	r0, r3
  118a30:	ebfff768 	bl	1167d8 <lwip_htons>
  118a34:	e1a03000 	mov	r3, r0
  118a38:	e1a02003 	mov	r2, r3
  118a3c:	e59b3004 	ldr	r3, [fp, #4]
  118a40:	e0833002 	add	r3, r3, r2
  118a44:	e58b3004 	str	r3, [fp, #4]
  acc += (u32_t)lwip_htons(proto_len);
  118a48:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
  118a4c:	e1a00003 	mov	r0, r3
  118a50:	ebfff760 	bl	1167d8 <lwip_htons>
  118a54:	e1a03000 	mov	r3, r0
  118a58:	e1a02003 	mov	r2, r3
  118a5c:	e59b3004 	ldr	r3, [fp, #4]
  118a60:	e0833002 	add	r3, r3, r2
  118a64:	e58b3004 	str	r3, [fp, #4]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
  118a68:	e59b3004 	ldr	r3, [fp, #4]
  118a6c:	e1a02823 	lsr	r2, r3, #16
  118a70:	e59b3004 	ldr	r3, [fp, #4]
  118a74:	e6ff3073 	uxth	r3, r3
  118a78:	e0823003 	add	r3, r2, r3
  118a7c:	e58b3004 	str	r3, [fp, #4]
  acc = FOLD_U32T(acc);
  118a80:	e59b3004 	ldr	r3, [fp, #4]
  118a84:	e1a02823 	lsr	r2, r3, #16
  118a88:	e59b3004 	ldr	r3, [fp, #4]
  118a8c:	e6ff3073 	uxth	r3, r3
  118a90:	e0823003 	add	r3, r2, r3
  118a94:	e58b3004 	str	r3, [fp, #4]
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  118a98:	e59b3004 	ldr	r3, [fp, #4]
  118a9c:	e6ff3073 	uxth	r3, r3
  118aa0:	e1e03003 	mvn	r3, r3
  118aa4:	e6ff3073 	uxth	r3, r3
}
  118aa8:	e1a00003 	mov	r0, r3
  118aac:	e24bd004 	sub	sp, fp, #4
  118ab0:	e8bd8800 	pop	{fp, pc}

00118ab4 <inet_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
       u16_t chksum_len, const ip4_addr_t *src, const ip4_addr_t *dest)
{
  118ab4:	e92d4800 	push	{fp, lr}
  118ab8:	e28db004 	add	fp, sp, #4
  118abc:	e24dd020 	sub	sp, sp, #32
  118ac0:	e50b0010 	str	r0, [fp, #-16]
  118ac4:	e1a00001 	mov	r0, r1
  118ac8:	e1a01002 	mov	r1, r2
  118acc:	e1a02003 	mov	r2, r3
  118ad0:	e1a03000 	mov	r3, r0
  118ad4:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  118ad8:	e1a03001 	mov	r3, r1
  118adc:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  118ae0:	e1a03002 	mov	r3, r2
  118ae4:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
  118ae8:	e59b3004 	ldr	r3, [fp, #4]
  118aec:	e5933000 	ldr	r3, [r3]
  118af0:	e50b3008 	str	r3, [fp, #-8]
  acc = (addr & 0xffffUL);
  118af4:	e51b3008 	ldr	r3, [fp, #-8]
  118af8:	e6ff3073 	uxth	r3, r3
  118afc:	e50b300c 	str	r3, [fp, #-12]
  acc += ((addr >> 16) & 0xffffUL);
  118b00:	e51b3008 	ldr	r3, [fp, #-8]
  118b04:	e1a03823 	lsr	r3, r3, #16
  118b08:	e51b200c 	ldr	r2, [fp, #-12]
  118b0c:	e0823003 	add	r3, r2, r3
  118b10:	e50b300c 	str	r3, [fp, #-12]
  addr = ip4_addr_get_u32(dest);
  118b14:	e59b3008 	ldr	r3, [fp, #8]
  118b18:	e5933000 	ldr	r3, [r3]
  118b1c:	e50b3008 	str	r3, [fp, #-8]
  acc += (addr & 0xffffUL);
  118b20:	e51b3008 	ldr	r3, [fp, #-8]
  118b24:	e6ff3073 	uxth	r3, r3
  118b28:	e51b200c 	ldr	r2, [fp, #-12]
  118b2c:	e0823003 	add	r3, r2, r3
  118b30:	e50b300c 	str	r3, [fp, #-12]
  acc += ((addr >> 16) & 0xffffUL);
  118b34:	e51b3008 	ldr	r3, [fp, #-8]
  118b38:	e1a03823 	lsr	r3, r3, #16
  118b3c:	e51b200c 	ldr	r2, [fp, #-12]
  118b40:	e0823003 	add	r3, r2, r3
  118b44:	e50b300c 	str	r3, [fp, #-12]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
  118b48:	e51b300c 	ldr	r3, [fp, #-12]
  118b4c:	e1a02823 	lsr	r2, r3, #16
  118b50:	e51b300c 	ldr	r3, [fp, #-12]
  118b54:	e6ff3073 	uxth	r3, r3
  118b58:	e0823003 	add	r3, r2, r3
  118b5c:	e50b300c 	str	r3, [fp, #-12]
  acc = FOLD_U32T(acc);
  118b60:	e51b300c 	ldr	r3, [fp, #-12]
  118b64:	e1a02823 	lsr	r2, r3, #16
  118b68:	e51b300c 	ldr	r3, [fp, #-12]
  118b6c:	e6ff3073 	uxth	r3, r3
  118b70:	e0823003 	add	r3, r2, r3
  118b74:	e50b300c 	str	r3, [fp, #-12]

  return inet_cksum_pseudo_partial_base(p, proto, proto_len, chksum_len, acc);
  118b78:	e15b01b6 	ldrh	r0, [fp, #-22]	; 0xffffffea
  118b7c:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
  118b80:	e55b1011 	ldrb	r1, [fp, #-17]	; 0xffffffef
  118b84:	e51b300c 	ldr	r3, [fp, #-12]
  118b88:	e58d3000 	str	r3, [sp]
  118b8c:	e1a03000 	mov	r3, r0
  118b90:	e51b0010 	ldr	r0, [fp, #-16]
  118b94:	ebffff42 	bl	1188a4 <inet_cksum_pseudo_partial_base>
  118b98:	e1a03000 	mov	r3, r0
}
  118b9c:	e1a00003 	mov	r0, r3
  118ba0:	e24bd004 	sub	sp, fp, #4
  118ba4:	e8bd8800 	pop	{fp, pc}

00118ba8 <ip_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
       u16_t chksum_len, const ip_addr_t *src, const ip_addr_t *dest)
{
  118ba8:	e92d4800 	push	{fp, lr}
  118bac:	e28db004 	add	fp, sp, #4
  118bb0:	e24dd018 	sub	sp, sp, #24
  118bb4:	e50b0008 	str	r0, [fp, #-8]
  118bb8:	e1a00001 	mov	r0, r1
  118bbc:	e1a01002 	mov	r1, r2
  118bc0:	e1a02003 	mov	r2, r3
  118bc4:	e1a03000 	mov	r3, r0
  118bc8:	e54b3009 	strb	r3, [fp, #-9]
  118bcc:	e1a03001 	mov	r3, r1
  118bd0:	e14b30bc 	strh	r3, [fp, #-12]
  118bd4:	e1a03002 	mov	r3, r2
  118bd8:	e14b30be 	strh	r3, [fp, #-14]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo_partial(p, proto, proto_len, chksum_len, ip_2_ip4(src), ip_2_ip4(dest));
  118bdc:	e15b00be 	ldrh	r0, [fp, #-14]
  118be0:	e15b20bc 	ldrh	r2, [fp, #-12]
  118be4:	e55b1009 	ldrb	r1, [fp, #-9]
  118be8:	e59b3008 	ldr	r3, [fp, #8]
  118bec:	e58d3004 	str	r3, [sp, #4]
  118bf0:	e59b3004 	ldr	r3, [fp, #4]
  118bf4:	e58d3000 	str	r3, [sp]
  118bf8:	e1a03000 	mov	r3, r0
  118bfc:	e51b0008 	ldr	r0, [fp, #-8]
  118c00:	ebffffab 	bl	118ab4 <inet_chksum_pseudo_partial>
  118c04:	e1a03000 	mov	r3, r0
  }
#endif /* LWIP_IPV4 */
}
  118c08:	e1a00003 	mov	r0, r3
  118c0c:	e24bd004 	sub	sp, fp, #4
  118c10:	e8bd8800 	pop	{fp, pc}

00118c14 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
  118c14:	e92d4800 	push	{fp, lr}
  118c18:	e28db004 	add	fp, sp, #4
  118c1c:	e24dd008 	sub	sp, sp, #8
  118c20:	e50b0008 	str	r0, [fp, #-8]
  118c24:	e1a03001 	mov	r3, r1
  118c28:	e14b30ba 	strh	r3, [fp, #-10]
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
  118c2c:	e15b30ba 	ldrh	r3, [fp, #-10]
  118c30:	e1a01003 	mov	r1, r3
  118c34:	e51b0008 	ldr	r0, [fp, #-8]
  118c38:	ebfffe11 	bl	118484 <lwip_standard_chksum>
  118c3c:	e1a03000 	mov	r3, r0
  118c40:	e1e03003 	mvn	r3, r3
  118c44:	e6ff3073 	uxth	r3, r3
}
  118c48:	e1a00003 	mov	r0, r3
  118c4c:	e24bd004 	sub	sp, fp, #4
  118c50:	e8bd8800 	pop	{fp, pc}

00118c54 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  118c54:	e92d4800 	push	{fp, lr}
  118c58:	e28db004 	add	fp, sp, #4
  118c5c:	e24dd018 	sub	sp, sp, #24
  118c60:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  118c64:	e3a03000 	mov	r3, #0
  118c68:	e50b3008 	str	r3, [fp, #-8]
  swapped = 0;
  118c6c:	e3a03000 	mov	r3, #0
  118c70:	e54b300d 	strb	r3, [fp, #-13]
  for (q = p; q != NULL; q = q->next) {
  118c74:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  118c78:	e50b300c 	str	r3, [fp, #-12]
  118c7c:	ea000025 	b	118d18 <inet_chksum_pbuf+0xc4>
    acc += LWIP_CHKSUM(q->payload, q->len);
  118c80:	e51b300c 	ldr	r3, [fp, #-12]
  118c84:	e5932004 	ldr	r2, [r3, #4]
  118c88:	e51b300c 	ldr	r3, [fp, #-12]
  118c8c:	e1d330ba 	ldrh	r3, [r3, #10]
  118c90:	e1a01003 	mov	r1, r3
  118c94:	e1a00002 	mov	r0, r2
  118c98:	ebfffdf9 	bl	118484 <lwip_standard_chksum>
  118c9c:	e1a03000 	mov	r3, r0
  118ca0:	e1a02003 	mov	r2, r3
  118ca4:	e51b3008 	ldr	r3, [fp, #-8]
  118ca8:	e0833002 	add	r3, r3, r2
  118cac:	e50b3008 	str	r3, [fp, #-8]
    acc = FOLD_U32T(acc);
  118cb0:	e51b3008 	ldr	r3, [fp, #-8]
  118cb4:	e1a02823 	lsr	r2, r3, #16
  118cb8:	e51b3008 	ldr	r3, [fp, #-8]
  118cbc:	e6ff3073 	uxth	r3, r3
  118cc0:	e0823003 	add	r3, r2, r3
  118cc4:	e50b3008 	str	r3, [fp, #-8]
    if (q->len % 2 != 0) {
  118cc8:	e51b300c 	ldr	r3, [fp, #-12]
  118ccc:	e1d330ba 	ldrh	r3, [r3, #10]
  118cd0:	e2033001 	and	r3, r3, #1
  118cd4:	e6ff3073 	uxth	r3, r3
  118cd8:	e3530000 	cmp	r3, #0
  118cdc:	0a00000a 	beq	118d0c <inet_chksum_pbuf+0xb8>
      swapped = 1 - swapped;
  118ce0:	e55b300d 	ldrb	r3, [fp, #-13]
  118ce4:	e2633001 	rsb	r3, r3, #1
  118ce8:	e54b300d 	strb	r3, [fp, #-13]
      acc = SWAP_BYTES_IN_WORD(acc);
  118cec:	e51b3008 	ldr	r3, [fp, #-8]
  118cf0:	e1a03403 	lsl	r3, r3, #8
  118cf4:	e6ff2073 	uxth	r2, r3
  118cf8:	e51b3008 	ldr	r3, [fp, #-8]
  118cfc:	e1a03423 	lsr	r3, r3, #8
  118d00:	e6ef3073 	uxtb	r3, r3
  118d04:	e1823003 	orr	r3, r2, r3
  118d08:	e50b3008 	str	r3, [fp, #-8]
  for (q = p; q != NULL; q = q->next) {
  118d0c:	e51b300c 	ldr	r3, [fp, #-12]
  118d10:	e5933000 	ldr	r3, [r3]
  118d14:	e50b300c 	str	r3, [fp, #-12]
  118d18:	e51b300c 	ldr	r3, [fp, #-12]
  118d1c:	e3530000 	cmp	r3, #0
  118d20:	1affffd6 	bne	118c80 <inet_chksum_pbuf+0x2c>
    }
  }

  if (swapped) {
  118d24:	e55b300d 	ldrb	r3, [fp, #-13]
  118d28:	e3530000 	cmp	r3, #0
  118d2c:	0a000007 	beq	118d50 <inet_chksum_pbuf+0xfc>
    acc = SWAP_BYTES_IN_WORD(acc);
  118d30:	e51b3008 	ldr	r3, [fp, #-8]
  118d34:	e1a03403 	lsl	r3, r3, #8
  118d38:	e6ff2073 	uxth	r2, r3
  118d3c:	e51b3008 	ldr	r3, [fp, #-8]
  118d40:	e1a03423 	lsr	r3, r3, #8
  118d44:	e6ef3073 	uxtb	r3, r3
  118d48:	e1823003 	orr	r3, r2, r3
  118d4c:	e50b3008 	str	r3, [fp, #-8]
  }
  return (u16_t)~(acc & 0xffffUL);
  118d50:	e51b3008 	ldr	r3, [fp, #-8]
  118d54:	e6ff3073 	uxth	r3, r3
  118d58:	e1e03003 	mvn	r3, r3
  118d5c:	e6ff3073 	uxth	r3, r3
}
  118d60:	e1a00003 	mov	r0, r3
  118d64:	e24bd004 	sub	sp, fp, #4
  118d68:	e8bd8800 	pop	{fp, pc}

00118d6c <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
  118d6c:	e92d4800 	push	{fp, lr}
  118d70:	e28db004 	add	fp, sp, #4
  118d74:	e24dd008 	sub	sp, sp, #8
#ifndef LWIP_SKIP_PACKING_CHECK
  LWIP_ASSERT("Struct packing not implemented correctly. Check your lwIP port.", sizeof(struct packed_struct_test) == PACKED_STRUCT_TEST_EXPECTED_SIZE);
#endif

  /* Modules initialization */
  stats_init();
  118d78:	eb000f7b 	bl	11cb6c <stats_init>
#if !NO_SYS
  sys_init();
  118d7c:	ebffc621 	bl	10a608 <sys_init>
#endif /* !NO_SYS */
  mem_init();
  118d80:	ebffc8dc 	bl	10b0f8 <mem_init>
  memp_init();
  118d84:	eb0000c6 	bl	1190a4 <memp_init>
  pbuf_init();
  netif_init();
  118d88:	eb0001d9 	bl	1194f4 <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
  118d8c:	eb003b7f 	bl	127b90 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
  118d90:	eb001109 	bl	11d1bc <tcp_init>
#endif /* LWIP_TCP */
#if LWIP_IGMP
  igmp_init();
  118d94:	eb005cdc 	bl	13010c <igmp_init>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
  118d98:	ebfff78e 	bl	116bd8 <dns_init>
#if PPP_SUPPORT
  ppp_init();
#endif
 
#if LWIP_TIMERS
  sys_timeouts_init();
  118d9c:	eb0039d6 	bl	1274fc <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
  118da0:	e320f000 	nop	{0}
  118da4:	e24bd004 	sub	sp, fp, #4
  118da8:	e8bd8800 	pop	{fp, pc}

00118dac <memp_overflow_check_element_overflow>:
 * @param p the memp element to check
 * @param desc the pool p comes from
 */
static void
memp_overflow_check_element_overflow(struct memp *p, const struct memp_desc *desc)
{
  118dac:	e92d4800 	push	{fp, lr}
  118db0:	e28db004 	add	fp, sp, #4
  118db4:	e24dd090 	sub	sp, sp, #144	; 0x90
  118db8:	e50b0090 	str	r0, [fp, #-144]	; 0xffffff70
  118dbc:	e50b1094 	str	r1, [fp, #-148]	; 0xffffff6c
#if MEMP_SANITY_REGION_AFTER_ALIGNED > 0
  u16_t k;
  u8_t *m;
  m = (u8_t*)p + MEMP_SIZE + desc->size;
  118dc0:	e51b3094 	ldr	r3, [fp, #-148]	; 0xffffff6c
  118dc4:	e1d330b8 	ldrh	r3, [r3, #8]
  118dc8:	e283301c 	add	r3, r3, #28
  118dcc:	e51b2090 	ldr	r2, [fp, #-144]	; 0xffffff70
  118dd0:	e0823003 	add	r3, r2, r3
  118dd4:	e50b300c 	str	r3, [fp, #-12]
  for (k = 0; k < MEMP_SANITY_REGION_AFTER_ALIGNED; k++) {
  118dd8:	e3a03000 	mov	r3, #0
  118ddc:	e14b30b6 	strh	r3, [fp, #-6]
  118de0:	ea000022 	b	118e70 <memp_overflow_check_element_overflow+0xc4>
    if (m[k] != 0xcd) {
  118de4:	e15b30b6 	ldrh	r3, [fp, #-6]
  118de8:	e51b200c 	ldr	r2, [fp, #-12]
  118dec:	e0823003 	add	r3, r2, r3
  118df0:	e5d33000 	ldrb	r3, [r3]
  118df4:	e35300cd 	cmp	r3, #205	; 0xcd
  118df8:	0a000019 	beq	118e64 <memp_overflow_check_element_overflow+0xb8>
      char errstr[128] = "detected memp overflow in pool ";
  118dfc:	e30735d8 	movw	r3, #30168	; 0x75d8
  118e00:	e3403014 	movt	r3, #20
  118e04:	e24bc08c 	sub	ip, fp, #140	; 0x8c
  118e08:	e1a0e003 	mov	lr, r3
  118e0c:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
  118e10:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  118e14:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
  118e18:	e88c000f 	stm	ip, {r0, r1, r2, r3}
  118e1c:	e24b306c 	sub	r3, fp, #108	; 0x6c
  118e20:	e3a02060 	mov	r2, #96	; 0x60
  118e24:	e3a01000 	mov	r1, #0
  118e28:	e1a00003 	mov	r0, r3
  118e2c:	eb00a190 	bl	141474 <memset>
      strcat(errstr, desc->desc);
  118e30:	e51b3094 	ldr	r3, [fp, #-148]	; 0xffffff6c
  118e34:	e5932000 	ldr	r2, [r3]
  118e38:	e24b308c 	sub	r3, fp, #140	; 0x8c
  118e3c:	e1a01002 	mov	r1, r2
  118e40:	e1a00003 	mov	r0, r3
  118e44:	eb00a1f0 	bl	14160c <strcat>
      LWIP_ASSERT(errstr, 0);
  118e48:	e24b308c 	sub	r3, fp, #140	; 0x8c
  118e4c:	e1a00003 	mov	r0, r3
  118e50:	ebffa8af 	bl	103114 <rt_kprintf>
  118e54:	e3a0108a 	mov	r1, #138	; 0x8a
  118e58:	e30705ac 	movw	r0, #30124	; 0x75ac
  118e5c:	e3400014 	movt	r0, #20
  118e60:	ebffc885 	bl	10b07c <sys_arch_assert>
  for (k = 0; k < MEMP_SANITY_REGION_AFTER_ALIGNED; k++) {
  118e64:	e15b30b6 	ldrh	r3, [fp, #-6]
  118e68:	e2833001 	add	r3, r3, #1
  118e6c:	e14b30b6 	strh	r3, [fp, #-6]
  118e70:	e15b30b6 	ldrh	r3, [fp, #-6]
  118e74:	e353000f 	cmp	r3, #15
  118e78:	9affffd9 	bls	118de4 <memp_overflow_check_element_overflow+0x38>
  }
#else /* MEMP_SANITY_REGION_AFTER_ALIGNED > 0 */
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(desc);
#endif /* MEMP_SANITY_REGION_AFTER_ALIGNED > 0 */
}
  118e7c:	e320f000 	nop	{0}
  118e80:	e24bd004 	sub	sp, fp, #4
  118e84:	e8bd8800 	pop	{fp, pc}

00118e88 <memp_overflow_check_element_underflow>:
 * @param p the memp element to check
 * @param desc the pool p comes from
 */
static void
memp_overflow_check_element_underflow(struct memp *p, const struct memp_desc *desc)
{
  118e88:	e92d4800 	push	{fp, lr}
  118e8c:	e28db004 	add	fp, sp, #4
  118e90:	e24dd090 	sub	sp, sp, #144	; 0x90
  118e94:	e50b0090 	str	r0, [fp, #-144]	; 0xffffff70
  118e98:	e50b1094 	str	r1, [fp, #-148]	; 0xffffff6c
#if MEMP_SANITY_REGION_BEFORE_ALIGNED > 0
  u16_t k;
  u8_t *m;
  m = (u8_t*)p + MEMP_SIZE - MEMP_SANITY_REGION_BEFORE_ALIGNED;
  118e9c:	e51b3090 	ldr	r3, [fp, #-144]	; 0xffffff70
  118ea0:	e283300c 	add	r3, r3, #12
  118ea4:	e50b300c 	str	r3, [fp, #-12]
  for (k = 0; k < MEMP_SANITY_REGION_BEFORE_ALIGNED; k++) {
  118ea8:	e3a03000 	mov	r3, #0
  118eac:	e14b30b6 	strh	r3, [fp, #-6]
  118eb0:	ea000024 	b	118f48 <memp_overflow_check_element_underflow+0xc0>
    if (m[k] != 0xcd) {
  118eb4:	e15b30b6 	ldrh	r3, [fp, #-6]
  118eb8:	e51b200c 	ldr	r2, [fp, #-12]
  118ebc:	e0823003 	add	r3, r2, r3
  118ec0:	e5d33000 	ldrb	r3, [r3]
  118ec4:	e35300cd 	cmp	r3, #205	; 0xcd
  118ec8:	0a00001b 	beq	118f3c <memp_overflow_check_element_underflow+0xb4>
      char errstr[128] = "detected memp underflow in pool ";
  118ecc:	e3073658 	movw	r3, #30296	; 0x7658
  118ed0:	e3403014 	movt	r3, #20
  118ed4:	e24bc08c 	sub	ip, fp, #140	; 0x8c
  118ed8:	e1a0e003 	mov	lr, r3
  118edc:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
  118ee0:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  118ee4:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
  118ee8:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  118eec:	e59e3000 	ldr	r3, [lr]
  118ef0:	e5cc3000 	strb	r3, [ip]
  118ef4:	e24b306b 	sub	r3, fp, #107	; 0x6b
  118ef8:	e3a0205f 	mov	r2, #95	; 0x5f
  118efc:	e3a01000 	mov	r1, #0
  118f00:	e1a00003 	mov	r0, r3
  118f04:	eb00a15a 	bl	141474 <memset>
      strcat(errstr, desc->desc);
  118f08:	e51b3094 	ldr	r3, [fp, #-148]	; 0xffffff6c
  118f0c:	e5932000 	ldr	r2, [r3]
  118f10:	e24b308c 	sub	r3, fp, #140	; 0x8c
  118f14:	e1a01002 	mov	r1, r2
  118f18:	e1a00003 	mov	r0, r3
  118f1c:	eb00a1ba 	bl	14160c <strcat>
      LWIP_ASSERT(errstr, 0);
  118f20:	e24b308c 	sub	r3, fp, #140	; 0x8c
  118f24:	e1a00003 	mov	r0, r3
  118f28:	ebffa879 	bl	103114 <rt_kprintf>
  118f2c:	e3a010a5 	mov	r1, #165	; 0xa5
  118f30:	e30705ac 	movw	r0, #30124	; 0x75ac
  118f34:	e3400014 	movt	r0, #20
  118f38:	ebffc84f 	bl	10b07c <sys_arch_assert>
  for (k = 0; k < MEMP_SANITY_REGION_BEFORE_ALIGNED; k++) {
  118f3c:	e15b30b6 	ldrh	r3, [fp, #-6]
  118f40:	e2833001 	add	r3, r3, #1
  118f44:	e14b30b6 	strh	r3, [fp, #-6]
  118f48:	e15b30b6 	ldrh	r3, [fp, #-6]
  118f4c:	e353000f 	cmp	r3, #15
  118f50:	9affffd7 	bls	118eb4 <memp_overflow_check_element_underflow+0x2c>
  }
#else /* MEMP_SANITY_REGION_BEFORE_ALIGNED > 0 */
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(desc);
#endif /* MEMP_SANITY_REGION_BEFORE_ALIGNED > 0 */
}
  118f54:	e320f000 	nop	{0}
  118f58:	e24bd004 	sub	sp, fp, #4
  118f5c:	e8bd8800 	pop	{fp, pc}

00118f60 <memp_overflow_init_element>:
/**
 * Initialize the restricted area of on memp element.
 */
static void
memp_overflow_init_element(struct memp *p, const struct memp_desc *desc)
{
  118f60:	e92d4800 	push	{fp, lr}
  118f64:	e28db004 	add	fp, sp, #4
  118f68:	e24dd010 	sub	sp, sp, #16
  118f6c:	e50b0010 	str	r0, [fp, #-16]
  118f70:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
#if MEMP_SANITY_REGION_BEFORE_ALIGNED > 0 || MEMP_SANITY_REGION_AFTER_ALIGNED > 0
  u8_t *m;
#if MEMP_SANITY_REGION_BEFORE_ALIGNED > 0
  m = (u8_t*)p + MEMP_SIZE - MEMP_SANITY_REGION_BEFORE_ALIGNED;
  118f74:	e51b3010 	ldr	r3, [fp, #-16]
  118f78:	e283300c 	add	r3, r3, #12
  118f7c:	e50b3008 	str	r3, [fp, #-8]
  memset(m, 0xcd, MEMP_SANITY_REGION_BEFORE_ALIGNED);
  118f80:	e3a02010 	mov	r2, #16
  118f84:	e3a010cd 	mov	r1, #205	; 0xcd
  118f88:	e51b0008 	ldr	r0, [fp, #-8]
  118f8c:	eb00a138 	bl	141474 <memset>
#endif
#if MEMP_SANITY_REGION_AFTER_ALIGNED > 0
  m = (u8_t*)p + MEMP_SIZE + desc->size;
  118f90:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  118f94:	e1d330b8 	ldrh	r3, [r3, #8]
  118f98:	e283301c 	add	r3, r3, #28
  118f9c:	e51b2010 	ldr	r2, [fp, #-16]
  118fa0:	e0823003 	add	r3, r2, r3
  118fa4:	e50b3008 	str	r3, [fp, #-8]
  memset(m, 0xcd, MEMP_SANITY_REGION_AFTER_ALIGNED);
  118fa8:	e3a02010 	mov	r2, #16
  118fac:	e3a010cd 	mov	r1, #205	; 0xcd
  118fb0:	e51b0008 	ldr	r0, [fp, #-8]
  118fb4:	eb00a12e 	bl	141474 <memset>
#endif
#else /* MEMP_SANITY_REGION_BEFORE_ALIGNED > 0 || MEMP_SANITY_REGION_AFTER_ALIGNED > 0 */
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(desc);
#endif /* MEMP_SANITY_REGION_BEFORE_ALIGNED > 0 || MEMP_SANITY_REGION_AFTER_ALIGNED > 0 */
}
  118fb8:	e320f000 	nop	{0}
  118fbc:	e24bd004 	sub	sp, fp, #4
  118fc0:	e8bd8800 	pop	{fp, pc}

00118fc4 <memp_init_pool>:
 *
 * @param desc pool to initialize
 */
void
memp_init_pool(const struct memp_desc *desc)
{
  118fc4:	e92d4800 	push	{fp, lr}
  118fc8:	e28db004 	add	fp, sp, #4
  118fcc:	e24dd010 	sub	sp, sp, #16
  118fd0:	e50b0010 	str	r0, [fp, #-16]
  LWIP_UNUSED_ARG(desc);
#else
  int i;
  struct memp *memp;

  *desc->tab = NULL;
  118fd4:	e51b3010 	ldr	r3, [fp, #-16]
  118fd8:	e5933010 	ldr	r3, [r3, #16]
  118fdc:	e3a02000 	mov	r2, #0
  118fe0:	e5832000 	str	r2, [r3]
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
  118fe4:	e51b3010 	ldr	r3, [fp, #-16]
  118fe8:	e593300c 	ldr	r3, [r3, #12]
  118fec:	e2833003 	add	r3, r3, #3
  118ff0:	e3c33003 	bic	r3, r3, #3
  118ff4:	e50b300c 	str	r3, [fp, #-12]
  /* create a linked list of memp elements */
  for (i = 0; i < desc->num; ++i) {
  118ff8:	e3a03000 	mov	r3, #0
  118ffc:	e50b3008 	str	r3, [fp, #-8]
  119000:	ea000014 	b	119058 <memp_init_pool+0x94>
    memp->next = *desc->tab;
  119004:	e51b3010 	ldr	r3, [fp, #-16]
  119008:	e5933010 	ldr	r3, [r3, #16]
  11900c:	e5932000 	ldr	r2, [r3]
  119010:	e51b300c 	ldr	r3, [fp, #-12]
  119014:	e5832000 	str	r2, [r3]
    *desc->tab = memp;
  119018:	e51b3010 	ldr	r3, [fp, #-16]
  11901c:	e5933010 	ldr	r3, [r3, #16]
  119020:	e51b200c 	ldr	r2, [fp, #-12]
  119024:	e5832000 	str	r2, [r3]
#if MEMP_OVERFLOW_CHECK
    memp_overflow_init_element(memp, desc);
  119028:	e51b1010 	ldr	r1, [fp, #-16]
  11902c:	e51b000c 	ldr	r0, [fp, #-12]
  119030:	ebffffca 	bl	118f60 <memp_overflow_init_element>
#endif /* MEMP_OVERFLOW_CHECK */
   /* cast through void* to get rid of alignment warnings */
   memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
  119034:	e51b3010 	ldr	r3, [fp, #-16]
  119038:	e1d330b8 	ldrh	r3, [r3, #8]
#if MEMP_OVERFLOW_CHECK
      + MEMP_SANITY_REGION_AFTER_ALIGNED
  11903c:	e283302c 	add	r3, r3, #44	; 0x2c
   memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
  119040:	e51b200c 	ldr	r2, [fp, #-12]
  119044:	e0823003 	add	r3, r2, r3
  119048:	e50b300c 	str	r3, [fp, #-12]
  for (i = 0; i < desc->num; ++i) {
  11904c:	e51b3008 	ldr	r3, [fp, #-8]
  119050:	e2833001 	add	r3, r3, #1
  119054:	e50b3008 	str	r3, [fp, #-8]
  119058:	e51b3010 	ldr	r3, [fp, #-16]
  11905c:	e1d330ba 	ldrh	r3, [r3, #10]
  119060:	e1a02003 	mov	r2, r3
  119064:	e51b3008 	ldr	r3, [fp, #-8]
  119068:	e1530002 	cmp	r3, r2
  11906c:	baffffe4 	blt	119004 <memp_init_pool+0x40>
#endif
    );
  }
#if MEMP_STATS
  desc->stats->avail = desc->num;
  119070:	e51b3010 	ldr	r3, [fp, #-16]
  119074:	e5933004 	ldr	r3, [r3, #4]
  119078:	e51b2010 	ldr	r2, [fp, #-16]
  11907c:	e1d220ba 	ldrh	r2, [r2, #10]
  119080:	e1c320b6 	strh	r2, [r3, #6]
#endif /* MEMP_STATS */
#endif /* !MEMP_MEM_MALLOC */

#if MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY)
  desc->stats->name  = desc->desc;
  119084:	e51b3010 	ldr	r3, [fp, #-16]
  119088:	e5933004 	ldr	r3, [r3, #4]
  11908c:	e51b2010 	ldr	r2, [fp, #-16]
  119090:	e5922000 	ldr	r2, [r2]
  119094:	e5832000 	str	r2, [r3]
#endif /* MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY) */
}
  119098:	e320f000 	nop	{0}
  11909c:	e24bd004 	sub	sp, fp, #4
  1190a0:	e8bd8800 	pop	{fp, pc}

001190a4 <memp_init>:
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  1190a4:	e92d4800 	push	{fp, lr}
  1190a8:	e28db004 	add	fp, sp, #4
  1190ac:	e24dd008 	sub	sp, sp, #8
  u16_t i;

  /* for every pool: */
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
  1190b0:	e3a03000 	mov	r3, #0
  1190b4:	e14b30b6 	strh	r3, [fp, #-6]
  1190b8:	ea000014 	b	119110 <memp_init+0x6c>
    memp_init_pool(memp_pools[i]);
  1190bc:	e15b20b6 	ldrh	r2, [fp, #-6]
  1190c0:	e3073568 	movw	r3, #30056	; 0x7568
  1190c4:	e3403014 	movt	r3, #20
  1190c8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  1190cc:	e1a00003 	mov	r0, r3
  1190d0:	ebffffbb 	bl	118fc4 <memp_init_pool>

#if LWIP_STATS && MEMP_STATS
    lwip_stats.memp[i] = memp_pools[i]->stats;
  1190d4:	e15b20b6 	ldrh	r2, [fp, #-6]
  1190d8:	e3073568 	movw	r3, #30056	; 0x7568
  1190dc:	e3403014 	movt	r3, #20
  1190e0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
  1190e4:	e15b30b6 	ldrh	r3, [fp, #-6]
  1190e8:	e5921004 	ldr	r1, [r2, #4]
  1190ec:	e3062840 	movw	r2, #26688	; 0x6840
  1190f0:	e3402057 	movt	r2, #87	; 0x57
  1190f4:	e2833034 	add	r3, r3, #52	; 0x34
  1190f8:	e1a03103 	lsl	r3, r3, #2
  1190fc:	e0823003 	add	r3, r2, r3
  119100:	e5831004 	str	r1, [r3, #4]
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
  119104:	e15b30b6 	ldrh	r3, [fp, #-6]
  119108:	e2833001 	add	r3, r3, #1
  11910c:	e14b30b6 	strh	r3, [fp, #-6]
  119110:	e15b30b6 	ldrh	r3, [fp, #-6]
  119114:	e3530010 	cmp	r3, #16
  119118:	9affffe7 	bls	1190bc <memp_init+0x18>

#if MEMP_OVERFLOW_CHECK >= 2
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
}
  11911c:	e320f000 	nop	{0}
  119120:	e24bd004 	sub	sp, fp, #4
  119124:	e8bd8800 	pop	{fp, pc}

00119128 <do_memp_malloc_pool_fn>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char* file, const int line)
#endif
{
  119128:	e92d4800 	push	{fp, lr}
  11912c:	e28db004 	add	fp, sp, #4
  119130:	e24dd018 	sub	sp, sp, #24
  119134:	e50b0010 	str	r0, [fp, #-16]
  119138:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  11913c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8

#if MEMP_MEM_MALLOC
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);
  119140:	ebffa43d 	bl	10223c <rt_enter_critical>

  memp = *desc->tab;
  119144:	e51b3010 	ldr	r3, [fp, #-16]
  119148:	e5933010 	ldr	r3, [r3, #16]
  11914c:	e5933000 	ldr	r3, [r3]
  119150:	e50b3008 	str	r3, [fp, #-8]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
  119154:	e51b3008 	ldr	r3, [fp, #-8]
  119158:	e3530000 	cmp	r3, #0
  11915c:	0a000036 	beq	11923c <do_memp_malloc_pool_fn+0x114>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element_overflow(memp, desc);
  119160:	e51b1010 	ldr	r1, [fp, #-16]
  119164:	e51b0008 	ldr	r0, [fp, #-8]
  119168:	ebffff0f 	bl	118dac <memp_overflow_check_element_overflow>
    memp_overflow_check_element_underflow(memp, desc);
  11916c:	e51b1010 	ldr	r1, [fp, #-16]
  119170:	e51b0008 	ldr	r0, [fp, #-8]
  119174:	ebffff43 	bl	118e88 <memp_overflow_check_element_underflow>
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
  119178:	e51b3010 	ldr	r3, [fp, #-16]
  11917c:	e5933010 	ldr	r3, [r3, #16]
  119180:	e51b2008 	ldr	r2, [fp, #-8]
  119184:	e5922000 	ldr	r2, [r2]
  119188:	e5832000 	str	r2, [r3]
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
  11918c:	e51b3008 	ldr	r3, [fp, #-8]
  119190:	e3a02000 	mov	r2, #0
  119194:	e5832000 	str	r2, [r3]
#endif /* MEMP_OVERFLOW_CHECK */
#endif /* !MEMP_MEM_MALLOC */
#if MEMP_OVERFLOW_CHECK
    memp->file = file;
  119198:	e51b3008 	ldr	r3, [fp, #-8]
  11919c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  1191a0:	e5832004 	str	r2, [r3, #4]
    memp->line = line;
  1191a4:	e51b3008 	ldr	r3, [fp, #-8]
  1191a8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1191ac:	e5832008 	str	r2, [r3, #8]
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  1191b0:	e51b3008 	ldr	r3, [fp, #-8]
  1191b4:	e2033003 	and	r3, r3, #3
  1191b8:	e3530000 	cmp	r3, #0
  1191bc:	0a000006 	beq	1191dc <do_memp_malloc_pool_fn+0xb4>
  1191c0:	e30706d8 	movw	r0, #30424	; 0x76d8
  1191c4:	e3400014 	movt	r0, #20
  1191c8:	ebffa7d1 	bl	103114 <rt_kprintf>
  1191cc:	e3001149 	movw	r1, #329	; 0x149
  1191d0:	e30705ac 	movw	r0, #30124	; 0x75ac
  1191d4:	e3400014 	movt	r0, #20
  1191d8:	ebffc7a7 	bl	10b07c <sys_arch_assert>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
#if MEMP_STATS
    desc->stats->used++;
  1191dc:	e51b3010 	ldr	r3, [fp, #-16]
  1191e0:	e5933004 	ldr	r3, [r3, #4]
  1191e4:	e1d320b8 	ldrh	r2, [r3, #8]
  1191e8:	e2822001 	add	r2, r2, #1
  1191ec:	e6ff2072 	uxth	r2, r2
  1191f0:	e1c320b8 	strh	r2, [r3, #8]
    if (desc->stats->used > desc->stats->max) {
  1191f4:	e51b3010 	ldr	r3, [fp, #-16]
  1191f8:	e5933004 	ldr	r3, [r3, #4]
  1191fc:	e1d320b8 	ldrh	r2, [r3, #8]
  119200:	e51b3010 	ldr	r3, [fp, #-16]
  119204:	e5933004 	ldr	r3, [r3, #4]
  119208:	e1d330ba 	ldrh	r3, [r3, #10]
  11920c:	e1520003 	cmp	r2, r3
  119210:	9a000005 	bls	11922c <do_memp_malloc_pool_fn+0x104>
      desc->stats->max = desc->stats->used;
  119214:	e51b3010 	ldr	r3, [fp, #-16]
  119218:	e5932004 	ldr	r2, [r3, #4]
  11921c:	e51b3010 	ldr	r3, [fp, #-16]
  119220:	e5933004 	ldr	r3, [r3, #4]
  119224:	e1d220b8 	ldrh	r2, [r2, #8]
  119228:	e1c320ba 	strh	r2, [r3, #10]
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
  11922c:	ebffa408 	bl	102254 <rt_exit_critical>
    /* cast through u8_t* to get rid of alignment warnings */
    return ((u8_t*)memp + MEMP_SIZE);
  119230:	e51b3008 	ldr	r3, [fp, #-8]
  119234:	e283301c 	add	r3, r3, #28
  119238:	ea000007 	b	11925c <do_memp_malloc_pool_fn+0x134>
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
#if MEMP_STATS
    desc->stats->err++;
  11923c:	e51b3010 	ldr	r3, [fp, #-16]
  119240:	e5933004 	ldr	r3, [r3, #4]
  119244:	e1d320b4 	ldrh	r2, [r3, #4]
  119248:	e2822001 	add	r2, r2, #1
  11924c:	e6ff2072 	uxth	r2, r2
  119250:	e1c320b4 	strh	r2, [r3, #4]
#endif
  }

  SYS_ARCH_UNPROTECT(old_level);
  119254:	ebffa3fe 	bl	102254 <rt_exit_critical>
  return NULL;
  119258:	e3a03000 	mov	r3, #0
}
  11925c:	e1a00003 	mov	r0, r3
  119260:	e24bd004 	sub	sp, fp, #4
  119264:	e8bd8800 	pop	{fp, pc}

00119268 <memp_malloc_pool_fn>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc_pool(const struct memp_desc *desc)
#else
memp_malloc_pool_fn(const struct memp_desc *desc, const char* file, const int line)
#endif
{
  119268:	e92d4800 	push	{fp, lr}
  11926c:	e28db004 	add	fp, sp, #4
  119270:	e24dd010 	sub	sp, sp, #16
  119274:	e50b0008 	str	r0, [fp, #-8]
  119278:	e50b100c 	str	r1, [fp, #-12]
  11927c:	e50b2010 	str	r2, [fp, #-16]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
  119280:	e51b3008 	ldr	r3, [fp, #-8]
  119284:	e3530000 	cmp	r3, #0
  119288:	1a000006 	bne	1192a8 <memp_malloc_pool_fn+0x40>
  11928c:	e30706fc 	movw	r0, #30460	; 0x76fc
  119290:	e3400014 	movt	r0, #20
  119294:	ebffa79e 	bl	103114 <rt_kprintf>
  119298:	e3a01f5b 	mov	r1, #364	; 0x16c
  11929c:	e30705ac 	movw	r0, #30124	; 0x75ac
  1192a0:	e3400014 	movt	r0, #20
  1192a4:	ebffc774 	bl	10b07c <sys_arch_assert>
  if (desc == NULL) {
  1192a8:	e51b3008 	ldr	r3, [fp, #-8]
  1192ac:	e3530000 	cmp	r3, #0
  1192b0:	1a000001 	bne	1192bc <memp_malloc_pool_fn+0x54>
    return NULL;
  1192b4:	e3a03000 	mov	r3, #0
  1192b8:	ea000004 	b	1192d0 <memp_malloc_pool_fn+0x68>
  }

#if !MEMP_OVERFLOW_CHECK
  return do_memp_malloc_pool(desc);
#else
  return do_memp_malloc_pool_fn(desc, file, line);
  1192bc:	e51b2010 	ldr	r2, [fp, #-16]
  1192c0:	e51b100c 	ldr	r1, [fp, #-12]
  1192c4:	e51b0008 	ldr	r0, [fp, #-8]
  1192c8:	ebffff96 	bl	119128 <do_memp_malloc_pool_fn>
  1192cc:	e1a03000 	mov	r3, r0
#endif
}
  1192d0:	e1a00003 	mov	r0, r3
  1192d4:	e24bd004 	sub	sp, fp, #4
  1192d8:	e8bd8800 	pop	{fp, pc}

001192dc <memp_malloc_fn>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  1192dc:	e92d4800 	push	{fp, lr}
  1192e0:	e28db004 	add	fp, sp, #4
  1192e4:	e24dd018 	sub	sp, sp, #24
  1192e8:	e50b0010 	str	r0, [fp, #-16]
  1192ec:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1192f0:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  void *memp;
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  1192f4:	e51b3010 	ldr	r3, [fp, #-16]
  1192f8:	e3530010 	cmp	r3, #16
  1192fc:	9a000008 	bls	119324 <memp_malloc_fn+0x48>
  119300:	e3070710 	movw	r0, #30480	; 0x7710
  119304:	e3400014 	movt	r0, #20
  119308:	ebffa781 	bl	103114 <rt_kprintf>
  11930c:	e3001187 	movw	r1, #391	; 0x187
  119310:	e30705ac 	movw	r0, #30124	; 0x75ac
  119314:	e3400014 	movt	r0, #20
  119318:	ebffc757 	bl	10b07c <sys_arch_assert>
  11931c:	e3a03000 	mov	r3, #0
  119320:	ea000009 	b	11934c <memp_malloc_fn+0x70>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

#if !MEMP_OVERFLOW_CHECK
  memp = do_memp_malloc_pool(memp_pools[type]);
#else
  memp = do_memp_malloc_pool_fn(memp_pools[type], file, line);
  119324:	e3073568 	movw	r3, #30056	; 0x7568
  119328:	e3403014 	movt	r3, #20
  11932c:	e51b2010 	ldr	r2, [fp, #-16]
  119330:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  119334:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  119338:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  11933c:	e1a00003 	mov	r0, r3
  119340:	ebffff78 	bl	119128 <do_memp_malloc_pool_fn>
  119344:	e50b0008 	str	r0, [fp, #-8]
#endif

  return memp;
  119348:	e51b3008 	ldr	r3, [fp, #-8]
}
  11934c:	e1a00003 	mov	r0, r3
  119350:	e24bd004 	sub	sp, fp, #4
  119354:	e8bd8800 	pop	{fp, pc}

00119358 <do_memp_free_pool>:

static void
do_memp_free_pool(const struct memp_desc* desc, void *mem)
{
  119358:	e92d4800 	push	{fp, lr}
  11935c:	e28db004 	add	fp, sp, #4
  119360:	e24dd010 	sub	sp, sp, #16
  119364:	e50b0010 	str	r0, [fp, #-16]
  119368:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
  11936c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  119370:	e2033003 	and	r3, r3, #3
  119374:	e3530000 	cmp	r3, #0
  119378:	0a000006 	beq	119398 <do_memp_free_pool+0x40>
  11937c:	e3070730 	movw	r0, #30512	; 0x7730
  119380:	e3400014 	movt	r0, #20
  119384:	ebffa762 	bl	103114 <rt_kprintf>
  119388:	e300119d 	movw	r1, #413	; 0x19d
  11938c:	e30705ac 	movw	r0, #30124	; 0x75ac
  119390:	e3400014 	movt	r0, #20
  119394:	ebffc738 	bl	10b07c <sys_arch_assert>
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
  119398:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11939c:	e243301c 	sub	r3, r3, #28
  1193a0:	e50b3008 	str	r3, [fp, #-8]

  SYS_ARCH_PROTECT(old_level);
  1193a4:	ebffa3a4 	bl	10223c <rt_enter_critical>

#if MEMP_OVERFLOW_CHECK == 1
  memp_overflow_check_element_overflow(memp, desc);
  1193a8:	e51b1010 	ldr	r1, [fp, #-16]
  1193ac:	e51b0008 	ldr	r0, [fp, #-8]
  1193b0:	ebfffe7d 	bl	118dac <memp_overflow_check_element_overflow>
  memp_overflow_check_element_underflow(memp, desc);
  1193b4:	e51b1010 	ldr	r1, [fp, #-16]
  1193b8:	e51b0008 	ldr	r0, [fp, #-8]
  1193bc:	ebfffeb1 	bl	118e88 <memp_overflow_check_element_underflow>
#endif /* MEMP_OVERFLOW_CHECK */

#if MEMP_STATS
  desc->stats->used--;
  1193c0:	e51b3010 	ldr	r3, [fp, #-16]
  1193c4:	e5933004 	ldr	r3, [r3, #4]
  1193c8:	e1d320b8 	ldrh	r2, [r3, #8]
  1193cc:	e2422001 	sub	r2, r2, #1
  1193d0:	e6ff2072 	uxth	r2, r2
  1193d4:	e1c320b8 	strh	r2, [r3, #8]
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
  1193d8:	e51b3010 	ldr	r3, [fp, #-16]
  1193dc:	e5933010 	ldr	r3, [r3, #16]
  1193e0:	e5932000 	ldr	r2, [r3]
  1193e4:	e51b3008 	ldr	r3, [fp, #-8]
  1193e8:	e5832000 	str	r2, [r3]
  *desc->tab = memp;
  1193ec:	e51b3010 	ldr	r3, [fp, #-16]
  1193f0:	e5933010 	ldr	r3, [r3, #16]
  1193f4:	e51b2008 	ldr	r2, [fp, #-8]
  1193f8:	e5832000 	str	r2, [r3]

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
  1193fc:	ebffa394 	bl	102254 <rt_exit_critical>
#endif /* !MEMP_MEM_MALLOC */
}
  119400:	e320f000 	nop	{0}
  119404:	e24bd004 	sub	sp, fp, #4
  119408:	e8bd8800 	pop	{fp, pc}

0011940c <memp_free_pool>:
 * @param desc the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free_pool(const struct memp_desc* desc, void *mem)
{
  11940c:	e92d4800 	push	{fp, lr}
  119410:	e28db004 	add	fp, sp, #4
  119414:	e24dd008 	sub	sp, sp, #8
  119418:	e50b0008 	str	r0, [fp, #-8]
  11941c:	e50b100c 	str	r1, [fp, #-12]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
  119420:	e51b3008 	ldr	r3, [fp, #-8]
  119424:	e3530000 	cmp	r3, #0
  119428:	1a000006 	bne	119448 <memp_free_pool+0x3c>
  11942c:	e30706fc 	movw	r0, #30460	; 0x76fc
  119430:	e3400014 	movt	r0, #20
  119434:	ebffa736 	bl	103114 <rt_kprintf>
  119438:	e30011c6 	movw	r1, #454	; 0x1c6
  11943c:	e30705ac 	movw	r0, #30124	; 0x75ac
  119440:	e3400014 	movt	r0, #20
  119444:	ebffc70c 	bl	10b07c <sys_arch_assert>
  if ((desc == NULL) || (mem == NULL)) {
  119448:	e51b3008 	ldr	r3, [fp, #-8]
  11944c:	e3530000 	cmp	r3, #0
  119450:	0a000006 	beq	119470 <memp_free_pool+0x64>
  119454:	e51b300c 	ldr	r3, [fp, #-12]
  119458:	e3530000 	cmp	r3, #0
  11945c:	0a000003 	beq	119470 <memp_free_pool+0x64>
    return;
  }

  do_memp_free_pool(desc, mem);
  119460:	e51b100c 	ldr	r1, [fp, #-12]
  119464:	e51b0008 	ldr	r0, [fp, #-8]
  119468:	ebffffba 	bl	119358 <do_memp_free_pool>
  11946c:	ea000000 	b	119474 <memp_free_pool+0x68>
    return;
  119470:	e320f000 	nop	{0}
}
  119474:	e24bd004 	sub	sp, fp, #4
  119478:	e8bd8800 	pop	{fp, pc}

0011947c <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  11947c:	e92d4800 	push	{fp, lr}
  119480:	e28db004 	add	fp, sp, #4
  119484:	e24dd008 	sub	sp, sp, #8
  119488:	e50b0008 	str	r0, [fp, #-8]
  11948c:	e50b100c 	str	r1, [fp, #-12]
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
  119490:	e51b3008 	ldr	r3, [fp, #-8]
  119494:	e3530010 	cmp	r3, #16
  119498:	9a000007 	bls	1194bc <memp_free+0x40>
  11949c:	e3070750 	movw	r0, #30544	; 0x7750
  1194a0:	e3400014 	movt	r0, #20
  1194a4:	ebffa71a 	bl	103114 <rt_kprintf>
  1194a8:	e30011db 	movw	r1, #475	; 0x1db
  1194ac:	e30705ac 	movw	r0, #30124	; 0x75ac
  1194b0:	e3400014 	movt	r0, #20
  1194b4:	ebffc6f0 	bl	10b07c <sys_arch_assert>
  1194b8:	ea00000b 	b	1194ec <memp_free+0x70>

  if (mem == NULL) {
  1194bc:	e51b300c 	ldr	r3, [fp, #-12]
  1194c0:	e3530000 	cmp	r3, #0
  1194c4:	0a000007 	beq	1194e8 <memp_free+0x6c>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
  1194c8:	e3073568 	movw	r3, #30056	; 0x7568
  1194cc:	e3403014 	movt	r3, #20
  1194d0:	e51b2008 	ldr	r2, [fp, #-8]
  1194d4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  1194d8:	e51b100c 	ldr	r1, [fp, #-12]
  1194dc:	e1a00003 	mov	r0, r3
  1194e0:	ebffff9c 	bl	119358 <do_memp_free_pool>
  1194e4:	ea000000 	b	1194ec <memp_free+0x70>
    return;
  1194e8:	e320f000 	nop	{0}
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
  1194ec:	e24bd004 	sub	sp, fp, #4
  1194f0:	e8bd8800 	pop	{fp, pc}

001194f4 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
  1194f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1194f8:	e28db000 	add	fp, sp, #0

  netif_set_link_up(&loop_netif);
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
  1194fc:	e320f000 	nop	{0}
  119500:	e28bd000 	add	sp, fp, #0
  119504:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  119508:	e12fff1e 	bx	lr

0011950c <netif_input>:
 * Only works if the netif driver correctly sets
 * NETIF_FLAG_ETHARP and/or NETIF_FLAG_ETHERNET flag!
 */
err_t
netif_input(struct pbuf *p, struct netif *inp)
{
  11950c:	e92d4800 	push	{fp, lr}
  119510:	e28db004 	add	fp, sp, #4
  119514:	e24dd008 	sub	sp, sp, #8
  119518:	e50b0008 	str	r0, [fp, #-8]
  11951c:	e50b100c 	str	r1, [fp, #-12]
#if LWIP_ETHERNET
  if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
  119520:	e51b300c 	ldr	r3, [fp, #-12]
  119524:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119528:	e2033018 	and	r3, r3, #24
  11952c:	e3530000 	cmp	r3, #0
  119530:	0a000004 	beq	119548 <netif_input+0x3c>
    return ethernet_input(p, inp);
  119534:	e51b100c 	ldr	r1, [fp, #-12]
  119538:	e51b0008 	ldr	r0, [fp, #-8]
  11953c:	eb003e2f 	bl	128e00 <ethernet_input>
  119540:	e1a03000 	mov	r3, r0
  119544:	ea000003 	b	119558 <netif_input+0x4c>
  } else
#endif /* LWIP_ETHERNET */
  return ip_input(p, inp);
  119548:	e51b100c 	ldr	r1, [fp, #-12]
  11954c:	e51b0008 	ldr	r0, [fp, #-8]
  119550:	eb006036 	bl	131630 <ip4_input>
  119554:	e1a03000 	mov	r3, r0
}
  119558:	e1a00003 	mov	r0, r3
  11955c:	e24bd004 	sub	sp, fp, #4
  119560:	e8bd8800 	pop	{fp, pc}

00119564 <netif_add>:
netif_add(struct netif *netif,
#if LWIP_IPV4
          const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
#endif /* LWIP_IPV4 */
          void *state, netif_init_fn init, netif_input_fn input)
{
  119564:	e92d4800 	push	{fp, lr}
  119568:	e28db004 	add	fp, sp, #4
  11956c:	e24dd010 	sub	sp, sp, #16
  119570:	e50b0008 	str	r0, [fp, #-8]
  119574:	e50b100c 	str	r1, [fp, #-12]
  119578:	e50b2010 	str	r2, [fp, #-16]
  11957c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
#if LWIP_IPV6
  s8_t i;
#endif
  LWIP_ASSERT("No init function given", init != NULL);
  119580:	e59b3008 	ldr	r3, [fp, #8]
  119584:	e3530000 	cmp	r3, #0
  119588:	1a000006 	bne	1195a8 <netif_add+0x44>
  11958c:	e307076c 	movw	r0, #30572	; 0x776c
  119590:	e3400014 	movt	r0, #20
  119594:	ebffa6de 	bl	103114 <rt_kprintf>
  119598:	e3001105 	movw	r1, #261	; 0x105
  11959c:	e3070784 	movw	r0, #30596	; 0x7784
  1195a0:	e3400014 	movt	r0, #20
  1195a4:	ebffc6b4 	bl	10b07c <sys_arch_assert>

  /* reset new interface configuration state */
#if LWIP_IPV4
  ip_addr_set_zero_ip4(&netif->ip_addr);
  1195a8:	e51b3008 	ldr	r3, [fp, #-8]
  1195ac:	e3a02000 	mov	r2, #0
  1195b0:	e5832004 	str	r2, [r3, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
  1195b4:	e51b3008 	ldr	r3, [fp, #-8]
  1195b8:	e3a02000 	mov	r2, #0
  1195bc:	e5832008 	str	r2, [r3, #8]
  ip_addr_set_zero_ip4(&netif->gw);
  1195c0:	e51b3008 	ldr	r3, [fp, #-8]
  1195c4:	e3a02000 	mov	r2, #0
  1195c8:	e583200c 	str	r2, [r3, #12]
    netif->ip6_addr_state[i] = IP6_ADDR_INVALID;
  }
  netif->output_ip6 = netif_null_output_ip6;
#endif /* LWIP_IPV6 */
  NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);
  netif->flags = 0;
  1195cc:	e51b3008 	ldr	r3, [fp, #-8]
  1195d0:	e3a02000 	mov	r2, #0
  1195d4:	e5c32041 	strb	r2, [r3, #65]	; 0x41
#ifdef netif_get_client_data
  memset(netif->client_data, 0, sizeof(netif->client_data));
  1195d8:	e51b3008 	ldr	r3, [fp, #-8]
  1195dc:	e2833028 	add	r3, r3, #40	; 0x28
  1195e0:	e3a02008 	mov	r2, #8
  1195e4:	e3a01000 	mov	r1, #0
  1195e8:	e1a00003 	mov	r0, r3
  1195ec:	eb009fa0 	bl	141474 <memset>
#if LWIP_IPV6_AUTOCONFIG
  /* IPv6 address autoconfiguration not enabled by default */
  netif->ip6_autoconfig_enabled = 0;
#endif /* LWIP_IPV6_AUTOCONFIG */
#if LWIP_IPV6_SEND_ROUTER_SOLICIT
  netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
  1195f0:	e51b3008 	ldr	r3, [fp, #-8]
  1195f4:	e3a02003 	mov	r2, #3
  1195f8:	e5c32030 	strb	r2, [r3, #48]	; 0x30
#endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
  1195fc:	e51b3008 	ldr	r3, [fp, #-8]
  119600:	e3a02000 	mov	r2, #0
  119604:	e583201c 	str	r2, [r3, #28]
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
  119608:	e51b3008 	ldr	r3, [fp, #-8]
  11960c:	e3a02000 	mov	r2, #0
  119610:	e5832020 	str	r2, [r3, #32]
#endif /* LWIP_NETIF_LINK_CALLBACK */
#if LWIP_IGMP
  netif->igmp_mac_filter = NULL;
  119614:	e51b3008 	ldr	r3, [fp, #-8]
  119618:	e3a02000 	mov	r2, #0
  11961c:	e583207c 	str	r2, [r3, #124]	; 0x7c
#endif /* LWIP_IGMP */
#if LWIP_IPV6 && LWIP_IPV6_MLD
  netif->mld_mac_filter = NULL;
#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
#if ENABLE_LOOPBACK
  netif->loop_first = NULL;
  119620:	e51b3008 	ldr	r3, [fp, #-8]
  119624:	e3a02000 	mov	r2, #0
  119628:	e5832080 	str	r2, [r3, #128]	; 0x80
  netif->loop_last = NULL;
  11962c:	e51b3008 	ldr	r3, [fp, #-8]
  119630:	e3a02000 	mov	r2, #0
  119634:	e5832084 	str	r2, [r3, #132]	; 0x84
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  119638:	e51b3008 	ldr	r3, [fp, #-8]
  11963c:	e59b2004 	ldr	r2, [fp, #4]
  119640:	e5832024 	str	r2, [r3, #36]	; 0x24
  netif->num = netif_num++;
  119644:	e30f3214 	movw	r3, #61972	; 0xf214
  119648:	e3403014 	movt	r3, #20
  11964c:	e5d32000 	ldrb	r2, [r3]
  119650:	e2823001 	add	r3, r2, #1
  119654:	e6ef1073 	uxtb	r1, r3
  119658:	e30f3214 	movw	r3, #61972	; 0xf214
  11965c:	e3403014 	movt	r3, #20
  119660:	e5c31000 	strb	r1, [r3]
  119664:	e51b3008 	ldr	r3, [fp, #-8]
  119668:	e5c32044 	strb	r2, [r3, #68]	; 0x44
  netif->input = input;
  11966c:	e51b3008 	ldr	r3, [fp, #-8]
  119670:	e59b200c 	ldr	r2, [fp, #12]
  119674:	e5832010 	str	r2, [r3, #16]
  NETIF_SET_HWADDRHINT(netif, NULL);
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */
#if LWIP_IPV4
  netif_set_addr(netif, ipaddr, netmask, gw);
  119678:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11967c:	e51b2010 	ldr	r2, [fp, #-16]
  119680:	e51b100c 	ldr	r1, [fp, #-12]
  119684:	e51b0008 	ldr	r0, [fp, #-8]
  119688:	eb00001b 	bl	1196fc <netif_set_addr>
#endif /* LWIP_IPV4 */
  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  11968c:	e59b3008 	ldr	r3, [fp, #8]
  119690:	e51b0008 	ldr	r0, [fp, #-8]
  119694:	e12fff33 	blx	r3
  119698:	e1a03000 	mov	r3, r0
  11969c:	e3530000 	cmp	r3, #0
  1196a0:	0a000001 	beq	1196ac <netif_add+0x148>
    return NULL;
  1196a4:	e3a03000 	mov	r3, #0
  1196a8:	ea000010 	b	1196f0 <netif_add+0x18c>
  }
  /* add this netif to the list */
  netif->next = netif_list;
  1196ac:	e3063834 	movw	r3, #26676	; 0x6834
  1196b0:	e3403057 	movt	r3, #87	; 0x57
  1196b4:	e5932000 	ldr	r2, [r3]
  1196b8:	e51b3008 	ldr	r3, [fp, #-8]
  1196bc:	e5832000 	str	r2, [r3]
  netif_list = netif;
  1196c0:	e3063834 	movw	r3, #26676	; 0x6834
  1196c4:	e3403057 	movt	r3, #87	; 0x57
  1196c8:	e51b2008 	ldr	r2, [fp, #-8]
  1196cc:	e5832000 	str	r2, [r3]
  mib2_netif_added(netif);
#if LWIP_IGMP
  /* start IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
  1196d0:	e51b3008 	ldr	r3, [fp, #-8]
  1196d4:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  1196d8:	e2033020 	and	r3, r3, #32
  1196dc:	e3530000 	cmp	r3, #0
  1196e0:	0a000001 	beq	1196ec <netif_add+0x188>
    igmp_start(netif);
  1196e4:	e51b0008 	ldr	r0, [fp, #-8]
  1196e8:	eb005a97 	bl	13014c <igmp_start>
  ip4_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip4_addr_debug_print(NETIF_DEBUG, gw);
#endif /* LWIP_IPV4 */
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  1196ec:	e51b3008 	ldr	r3, [fp, #-8]
}
  1196f0:	e1a00003 	mov	r0, r3
  1196f4:	e24bd004 	sub	sp, fp, #4
  1196f8:	e8bd8800 	pop	{fp, pc}

001196fc <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
    const ip4_addr_t *gw)
{
  1196fc:	e92d4800 	push	{fp, lr}
  119700:	e28db004 	add	fp, sp, #4
  119704:	e24dd010 	sub	sp, sp, #16
  119708:	e50b0008 	str	r0, [fp, #-8]
  11970c:	e50b100c 	str	r1, [fp, #-12]
  119710:	e50b2010 	str	r2, [fp, #-16]
  119714:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  if (ip4_addr_isany(ipaddr)) {
  119718:	e51b300c 	ldr	r3, [fp, #-12]
  11971c:	e3530000 	cmp	r3, #0
  119720:	0a000003 	beq	119734 <netif_set_addr+0x38>
  119724:	e51b300c 	ldr	r3, [fp, #-12]
  119728:	e5933000 	ldr	r3, [r3]
  11972c:	e3530000 	cmp	r3, #0
  119730:	1a000009 	bne	11975c <netif_set_addr+0x60>
    /* when removing an address, we have to remove it *before* changing netmask/gw
       to ensure that tcp RST segment can be sent correctly */
    netif_set_ipaddr(netif, ipaddr);
  119734:	e51b100c 	ldr	r1, [fp, #-12]
  119738:	e51b0008 	ldr	r0, [fp, #-8]
  11973c:	eb00009d 	bl	1199b8 <netif_set_ipaddr>
    netif_set_netmask(netif, netmask);
  119740:	e51b1010 	ldr	r1, [fp, #-16]
  119744:	e51b0008 	ldr	r0, [fp, #-8]
  119748:	eb0000fa 	bl	119b38 <netif_set_netmask>
    netif_set_gw(netif, gw);
  11974c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  119750:	e51b0008 	ldr	r0, [fp, #-8]
  119754:	eb0000de 	bl	119ad4 <netif_set_gw>
  119758:	ea000008 	b	119780 <netif_set_addr+0x84>
  } else {
    netif_set_netmask(netif, netmask);
  11975c:	e51b1010 	ldr	r1, [fp, #-16]
  119760:	e51b0008 	ldr	r0, [fp, #-8]
  119764:	eb0000f3 	bl	119b38 <netif_set_netmask>
    netif_set_gw(netif, gw);
  119768:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  11976c:	e51b0008 	ldr	r0, [fp, #-8]
  119770:	eb0000d7 	bl	119ad4 <netif_set_gw>
    /* set ipaddr last to ensure netmask/gw have been set when status callback is called */
    netif_set_ipaddr(netif, ipaddr);
  119774:	e51b100c 	ldr	r1, [fp, #-12]
  119778:	e51b0008 	ldr	r0, [fp, #-8]
  11977c:	eb00008d 	bl	1199b8 <netif_set_ipaddr>
  }
}
  119780:	e320f000 	nop	{0}
  119784:	e24bd004 	sub	sp, fp, #4
  119788:	e8bd8800 	pop	{fp, pc}

0011978c <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
  11978c:	e92d4800 	push	{fp, lr}
  119790:	e28db004 	add	fp, sp, #4
  119794:	e24dd010 	sub	sp, sp, #16
  119798:	e50b0010 	str	r0, [fp, #-16]
#if LWIP_IPV6
  int i;
#endif

  if (netif == NULL) {
  11979c:	e51b3010 	ldr	r3, [fp, #-16]
  1197a0:	e3530000 	cmp	r3, #0
  1197a4:	0a00004e 	beq	1198e4 <netif_remove+0x158>
    return;
  }

#if LWIP_IPV4
  if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
  1197a8:	e51b3010 	ldr	r3, [fp, #-16]
  1197ac:	e2833004 	add	r3, r3, #4
  1197b0:	e5933000 	ldr	r3, [r3]
  1197b4:	e3530000 	cmp	r3, #0
  1197b8:	0a00000e 	beq	1197f8 <netif_remove+0x6c>
#if LWIP_TCP
    tcp_netif_ip_addr_changed(netif_ip_addr4(netif), NULL);
  1197bc:	e51b3010 	ldr	r3, [fp, #-16]
  1197c0:	e2833004 	add	r3, r3, #4
  1197c4:	e3a01000 	mov	r1, #0
  1197c8:	e1a00003 	mov	r0, r3
  1197cc:	eb001aea 	bl	12037c <tcp_netif_ip_addr_changed>
#endif /* LWIP_TCP */
#if LWIP_UDP
    udp_netif_ip_addr_changed(netif_ip_addr4(netif), NULL);
  1197d0:	e51b3010 	ldr	r3, [fp, #-16]
  1197d4:	e2833004 	add	r3, r3, #4
  1197d8:	e3a01000 	mov	r1, #0
  1197dc:	e1a00003 	mov	r0, r3
  1197e0:	eb003d5a 	bl	128d50 <udp_netif_ip_addr_changed>
#endif /* LWIP_UDP */
#if LWIP_RAW
    raw_netif_ip_addr_changed(netif_ip_addr4(netif), NULL);
  1197e4:	e51b3010 	ldr	r3, [fp, #-16]
  1197e8:	e2833004 	add	r3, r3, #4
  1197ec:	e3a01000 	mov	r1, #0
  1197f0:	e1a00003 	mov	r0, r3
  1197f4:	eb000cb0 	bl	11cabc <raw_netif_ip_addr_changed>
#endif /* LWIP_RAW */
  }

#if LWIP_IGMP
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
  1197f8:	e51b3010 	ldr	r3, [fp, #-16]
  1197fc:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119800:	e2033020 	and	r3, r3, #32
  119804:	e3530000 	cmp	r3, #0
  119808:	0a000001 	beq	119814 <netif_remove+0x88>
    igmp_stop(netif);
  11980c:	e51b0010 	ldr	r0, [fp, #-16]
  119810:	eb005a73 	bl	1301e4 <igmp_stop>
#if LWIP_IPV6_MLD
  /* stop MLD processing */
  mld6_stop(netif);
#endif /* LWIP_IPV6_MLD */
#endif /* LWIP_IPV6 */
  if (netif_is_up(netif)) {
  119814:	e51b3010 	ldr	r3, [fp, #-16]
  119818:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  11981c:	e2033001 	and	r3, r3, #1
  119820:	e6ef3073 	uxtb	r3, r3
  119824:	e3530000 	cmp	r3, #0
  119828:	0a000001 	beq	119834 <netif_remove+0xa8>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
  11982c:	e51b0010 	ldr	r0, [fp, #-16]
  119830:	eb00013a 	bl	119d20 <netif_set_down>
  }

  mib2_remove_ip4(netif);

  /* this netif is default? */
  if (netif_default == netif) {
  119834:	e3063838 	movw	r3, #26680	; 0x6838
  119838:	e3403057 	movt	r3, #87	; 0x57
  11983c:	e5933000 	ldr	r3, [r3]
  119840:	e51b2010 	ldr	r2, [fp, #-16]
  119844:	e1520003 	cmp	r2, r3
  119848:	1a000001 	bne	119854 <netif_remove+0xc8>
    /* reset default netif */
    netif_set_default(NULL);
  11984c:	e3a00000 	mov	r0, #0
  119850:	eb0000d1 	bl	119b9c <netif_set_default>
  }
  /*  is it the first netif? */
  if (netif_list == netif) {
  119854:	e3063834 	movw	r3, #26676	; 0x6834
  119858:	e3403057 	movt	r3, #87	; 0x57
  11985c:	e5933000 	ldr	r3, [r3]
  119860:	e51b2010 	ldr	r2, [fp, #-16]
  119864:	e1520003 	cmp	r2, r3
  119868:	1a000005 	bne	119884 <netif_remove+0xf8>
    netif_list = netif->next;
  11986c:	e51b3010 	ldr	r3, [fp, #-16]
  119870:	e5932000 	ldr	r2, [r3]
  119874:	e3063834 	movw	r3, #26676	; 0x6834
  119878:	e3403057 	movt	r3, #87	; 0x57
  11987c:	e5832000 	str	r2, [r3]
  119880:	ea000018 	b	1198e8 <netif_remove+0x15c>
  } else {
    /*  look for netif further down the list */
    struct netif * tmp_netif;
    for (tmp_netif = netif_list; tmp_netif != NULL; tmp_netif = tmp_netif->next) {
  119884:	e3063834 	movw	r3, #26676	; 0x6834
  119888:	e3403057 	movt	r3, #87	; 0x57
  11988c:	e5933000 	ldr	r3, [r3]
  119890:	e50b3008 	str	r3, [fp, #-8]
  119894:	ea00000c 	b	1198cc <netif_remove+0x140>
      if (tmp_netif->next == netif) {
  119898:	e51b3008 	ldr	r3, [fp, #-8]
  11989c:	e5933000 	ldr	r3, [r3]
  1198a0:	e51b2010 	ldr	r2, [fp, #-16]
  1198a4:	e1520003 	cmp	r2, r3
  1198a8:	1a000004 	bne	1198c0 <netif_remove+0x134>
        tmp_netif->next = netif->next;
  1198ac:	e51b3010 	ldr	r3, [fp, #-16]
  1198b0:	e5932000 	ldr	r2, [r3]
  1198b4:	e51b3008 	ldr	r3, [fp, #-8]
  1198b8:	e5832000 	str	r2, [r3]
        break;
  1198bc:	ea000005 	b	1198d8 <netif_remove+0x14c>
    for (tmp_netif = netif_list; tmp_netif != NULL; tmp_netif = tmp_netif->next) {
  1198c0:	e51b3008 	ldr	r3, [fp, #-8]
  1198c4:	e5933000 	ldr	r3, [r3]
  1198c8:	e50b3008 	str	r3, [fp, #-8]
  1198cc:	e51b3008 	ldr	r3, [fp, #-8]
  1198d0:	e3530000 	cmp	r3, #0
  1198d4:	1affffef 	bne	119898 <netif_remove+0x10c>
      }
    }
    if (tmp_netif == NULL) {
  1198d8:	e51b3008 	ldr	r3, [fp, #-8]
  1198dc:	e3530000 	cmp	r3, #0
  1198e0:	ea000000 	b	1198e8 <netif_remove+0x15c>
    return;
  1198e4:	e320f000 	nop	{0}
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  1198e8:	e24bd004 	sub	sp, fp, #4
  1198ec:	e8bd8800 	pop	{fp, pc}

001198f0 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(const char *name)
{
  1198f0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1198f4:	e28db000 	add	fp, sp, #0
  1198f8:	e24dd014 	sub	sp, sp, #20
  1198fc:	e50b0010 	str	r0, [fp, #-16]
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  119900:	e51b3010 	ldr	r3, [fp, #-16]
  119904:	e3530000 	cmp	r3, #0
  119908:	1a000001 	bne	119914 <netif_find+0x24>
    return NULL;
  11990c:	e3a03000 	mov	r3, #0
  119910:	ea000024 	b	1199a8 <netif_find+0xb8>
  }

  num = (u8_t)(name[2] - '0');
  119914:	e51b3010 	ldr	r3, [fp, #-16]
  119918:	e2833002 	add	r3, r3, #2
  11991c:	e5d33000 	ldrb	r3, [r3]
  119920:	e2433030 	sub	r3, r3, #48	; 0x30
  119924:	e54b3009 	strb	r3, [fp, #-9]

  for (netif = netif_list; netif != NULL; netif = netif->next) {
  119928:	e3063834 	movw	r3, #26676	; 0x6834
  11992c:	e3403057 	movt	r3, #87	; 0x57
  119930:	e5933000 	ldr	r3, [r3]
  119934:	e50b3008 	str	r3, [fp, #-8]
  119938:	ea000016 	b	119998 <netif_find+0xa8>
    if (num == netif->num &&
  11993c:	e51b3008 	ldr	r3, [fp, #-8]
  119940:	e5d33044 	ldrb	r3, [r3, #68]	; 0x44
  119944:	e55b2009 	ldrb	r2, [fp, #-9]
  119948:	e1520003 	cmp	r2, r3
  11994c:	1a00000e 	bne	11998c <netif_find+0x9c>
       name[0] == netif->name[0] &&
  119950:	e51b3010 	ldr	r3, [fp, #-16]
  119954:	e5d32000 	ldrb	r2, [r3]
  119958:	e51b3008 	ldr	r3, [fp, #-8]
  11995c:	e5d33042 	ldrb	r3, [r3, #66]	; 0x42
    if (num == netif->num &&
  119960:	e1520003 	cmp	r2, r3
  119964:	1a000008 	bne	11998c <netif_find+0x9c>
       name[1] == netif->name[1]) {
  119968:	e51b3010 	ldr	r3, [fp, #-16]
  11996c:	e2833001 	add	r3, r3, #1
  119970:	e5d32000 	ldrb	r2, [r3]
  119974:	e51b3008 	ldr	r3, [fp, #-8]
  119978:	e5d33043 	ldrb	r3, [r3, #67]	; 0x43
       name[0] == netif->name[0] &&
  11997c:	e1520003 	cmp	r2, r3
  119980:	1a000001 	bne	11998c <netif_find+0x9c>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  119984:	e51b3008 	ldr	r3, [fp, #-8]
  119988:	ea000006 	b	1199a8 <netif_find+0xb8>
  for (netif = netif_list; netif != NULL; netif = netif->next) {
  11998c:	e51b3008 	ldr	r3, [fp, #-8]
  119990:	e5933000 	ldr	r3, [r3]
  119994:	e50b3008 	str	r3, [fp, #-8]
  119998:	e51b3008 	ldr	r3, [fp, #-8]
  11999c:	e3530000 	cmp	r3, #0
  1199a0:	1affffe5 	bne	11993c <netif_find+0x4c>
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  1199a4:	e3a03000 	mov	r3, #0
}
  1199a8:	e1a00003 	mov	r0, r3
  1199ac:	e28bd000 	add	sp, fp, #0
  1199b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1199b4:	e12fff1e 	bx	lr

001199b8 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr)
{
  1199b8:	e92d4800 	push	{fp, lr}
  1199bc:	e28db004 	add	fp, sp, #4
  1199c0:	e24dd010 	sub	sp, sp, #16
  1199c4:	e50b0010 	str	r0, [fp, #-16]
  1199c8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  ip_addr_t new_addr;
  *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
  1199cc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1199d0:	e3530000 	cmp	r3, #0
  1199d4:	0a000003 	beq	1199e8 <netif_set_ipaddr+0x30>
  1199d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1199dc:	e5933000 	ldr	r3, [r3]
  1199e0:	e50b3008 	str	r3, [fp, #-8]
  1199e4:	ea000003 	b	1199f8 <netif_set_ipaddr+0x40>
  1199e8:	e3093b24 	movw	r3, #39716	; 0x9b24
  1199ec:	e3403014 	movt	r3, #20
  1199f0:	e5933000 	ldr	r3, [r3]
  1199f4:	e50b3008 	str	r3, [fp, #-8]
  IP_SET_TYPE_VAL(new_addr, IPADDR_TYPE_V4);

  /* address is actually being changed? */
  if (ip4_addr_cmp(ip_2_ip4(&new_addr), netif_ip4_addr(netif)) == 0) {
  1199f8:	e51b2008 	ldr	r2, [fp, #-8]
  1199fc:	e51b3010 	ldr	r3, [fp, #-16]
  119a00:	e2833004 	add	r3, r3, #4
  119a04:	e5933000 	ldr	r3, [r3]
  119a08:	e1520003 	cmp	r2, r3
  119a0c:	0a00002d 	beq	119ac8 <netif_set_ipaddr+0x110>
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
#if LWIP_TCP
    tcp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
  119a10:	e51b3010 	ldr	r3, [fp, #-16]
  119a14:	e2833004 	add	r3, r3, #4
  119a18:	e24b2008 	sub	r2, fp, #8
  119a1c:	e1a01002 	mov	r1, r2
  119a20:	e1a00003 	mov	r0, r3
  119a24:	eb001a54 	bl	12037c <tcp_netif_ip_addr_changed>
#endif /* LWIP_TCP */
#if LWIP_UDP
    udp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
  119a28:	e51b3010 	ldr	r3, [fp, #-16]
  119a2c:	e2833004 	add	r3, r3, #4
  119a30:	e24b2008 	sub	r2, fp, #8
  119a34:	e1a01002 	mov	r1, r2
  119a38:	e1a00003 	mov	r0, r3
  119a3c:	eb003cc3 	bl	128d50 <udp_netif_ip_addr_changed>
#endif /* LWIP_UDP */
#if LWIP_RAW
    raw_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
  119a40:	e51b3010 	ldr	r3, [fp, #-16]
  119a44:	e2833004 	add	r3, r3, #4
  119a48:	e24b2008 	sub	r2, fp, #8
  119a4c:	e1a01002 	mov	r1, r2
  119a50:	e1a00003 	mov	r0, r3
  119a54:	eb000c18 	bl	11cabc <raw_netif_ip_addr_changed>
#endif /* LWIP_RAW */

    mib2_remove_ip4(netif);
    mib2_remove_route_ip4(0, netif);
    /* set new IP address to netif */
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
  119a58:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  119a5c:	e3530000 	cmp	r3, #0
  119a60:	0a000002 	beq	119a70 <netif_set_ipaddr+0xb8>
  119a64:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  119a68:	e5933000 	ldr	r3, [r3]
  119a6c:	ea000000 	b	119a74 <netif_set_ipaddr+0xbc>
  119a70:	e3a03000 	mov	r3, #0
  119a74:	e51b2010 	ldr	r2, [fp, #-16]
  119a78:	e5823004 	str	r3, [r2, #4]
    IP_SET_TYPE_VAL(netif->ip_addr, IPADDR_TYPE_V4);
    mib2_add_ip4(netif);
    mib2_add_route_ip4(0, netif);

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
  119a7c:	e3a01001 	mov	r1, #1
  119a80:	e51b0010 	ldr	r0, [fp, #-16]
  119a84:	eb000082 	bl	119c94 <netif_issue_reports>

    NETIF_STATUS_CALLBACK(netif);
  119a88:	e51b3010 	ldr	r3, [fp, #-16]
  119a8c:	e593301c 	ldr	r3, [r3, #28]
  119a90:	e3530000 	cmp	r3, #0
  119a94:	0a000003 	beq	119aa8 <netif_set_ipaddr+0xf0>
  119a98:	e51b3010 	ldr	r3, [fp, #-16]
  119a9c:	e593301c 	ldr	r3, [r3, #28]
  119aa0:	e51b0010 	ldr	r0, [fp, #-16]
  119aa4:	e12fff33 	blx	r3

#ifdef RT_USING_NETDEV
    /* rt-thread sal network interface device set IP address operations */
    netdev_low_level_set_ipaddr(netdev_get_by_name(netif->name), (ip_addr_t *)ipaddr);
  119aa8:	e51b3010 	ldr	r3, [fp, #-16]
  119aac:	e2833042 	add	r3, r3, #66	; 0x42
  119ab0:	e1a00003 	mov	r0, r3
  119ab4:	ebffae94 	bl	10550c <netdev_get_by_name>
  119ab8:	e1a03000 	mov	r3, r0
  119abc:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  119ac0:	e1a00003 	mov	r0, r3
  119ac4:	ebffb160 	bl	10604c <netdev_low_level_set_ipaddr>
    netif->name[0], netif->name[1],
    ip4_addr1_16(netif_ip4_addr(netif)),
    ip4_addr2_16(netif_ip4_addr(netif)),
    ip4_addr3_16(netif_ip4_addr(netif)),
    ip4_addr4_16(netif_ip4_addr(netif))));
}
  119ac8:	e320f000 	nop	{0}
  119acc:	e24bd004 	sub	sp, fp, #4
  119ad0:	e8bd8800 	pop	{fp, pc}

00119ad4 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, const ip4_addr_t *gw)
{
  119ad4:	e92d4800 	push	{fp, lr}
  119ad8:	e28db004 	add	fp, sp, #4
  119adc:	e24dd008 	sub	sp, sp, #8
  119ae0:	e50b0008 	str	r0, [fp, #-8]
  119ae4:	e50b100c 	str	r1, [fp, #-12]
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
  119ae8:	e51b300c 	ldr	r3, [fp, #-12]
  119aec:	e3530000 	cmp	r3, #0
  119af0:	0a000002 	beq	119b00 <netif_set_gw+0x2c>
  119af4:	e51b300c 	ldr	r3, [fp, #-12]
  119af8:	e5933000 	ldr	r3, [r3]
  119afc:	ea000000 	b	119b04 <netif_set_gw+0x30>
  119b00:	e3a03000 	mov	r3, #0
  119b04:	e51b2008 	ldr	r2, [fp, #-8]
  119b08:	e582300c 	str	r3, [r2, #12]
    ip4_addr3_16(netif_ip4_gw(netif)),
    ip4_addr4_16(netif_ip4_gw(netif))));

#ifdef RT_USING_NETDEV
  /* rt_thread network interface device set gateway address */
  netdev_low_level_set_gw(netdev_get_by_name(netif->name), (ip_addr_t *)gw);
  119b0c:	e51b3008 	ldr	r3, [fp, #-8]
  119b10:	e2833042 	add	r3, r3, #66	; 0x42
  119b14:	e1a00003 	mov	r0, r3
  119b18:	ebffae7b 	bl	10550c <netdev_get_by_name>
  119b1c:	e1a03000 	mov	r3, r0
  119b20:	e51b100c 	ldr	r1, [fp, #-12]
  119b24:	e1a00003 	mov	r0, r3
  119b28:	ebffb1c3 	bl	10623c <netdev_low_level_set_gw>
#endif /* RT_USING_NETDEV */
}
  119b2c:	e320f000 	nop	{0}
  119b30:	e24bd004 	sub	sp, fp, #4
  119b34:	e8bd8800 	pop	{fp, pc}

00119b38 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, const ip4_addr_t *netmask)
{
  119b38:	e92d4800 	push	{fp, lr}
  119b3c:	e28db004 	add	fp, sp, #4
  119b40:	e24dd008 	sub	sp, sp, #8
  119b44:	e50b0008 	str	r0, [fp, #-8]
  119b48:	e50b100c 	str	r1, [fp, #-12]
  mib2_remove_route_ip4(0, netif);
  /* set new netmask to netif */
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
  119b4c:	e51b300c 	ldr	r3, [fp, #-12]
  119b50:	e3530000 	cmp	r3, #0
  119b54:	0a000002 	beq	119b64 <netif_set_netmask+0x2c>
  119b58:	e51b300c 	ldr	r3, [fp, #-12]
  119b5c:	e5933000 	ldr	r3, [r3]
  119b60:	ea000000 	b	119b68 <netif_set_netmask+0x30>
  119b64:	e3a03000 	mov	r3, #0
  119b68:	e51b2008 	ldr	r2, [fp, #-8]
  119b6c:	e5823008 	str	r3, [r2, #8]
    ip4_addr3_16(netif_ip4_netmask(netif)),
    ip4_addr4_16(netif_ip4_netmask(netif))));

#ifdef RT_USING_NETDEV
  /* rt-thread network interface device set netmask address */
  netdev_low_level_set_netmask(netdev_get_by_name(netif->name), (ip_addr_t *)netmask);
  119b70:	e51b3008 	ldr	r3, [fp, #-8]
  119b74:	e2833042 	add	r3, r3, #66	; 0x42
  119b78:	e1a00003 	mov	r0, r3
  119b7c:	ebffae62 	bl	10550c <netdev_get_by_name>
  119b80:	e1a03000 	mov	r3, r0
  119b84:	e51b100c 	ldr	r1, [fp, #-12]
  119b88:	e1a00003 	mov	r0, r3
  119b8c:	ebffb168 	bl	106134 <netdev_low_level_set_netmask>
#endif /* RT_USING_NETDEV */
}
  119b90:	e320f000 	nop	{0}
  119b94:	e24bd004 	sub	sp, fp, #4
  119b98:	e8bd8800 	pop	{fp, pc}

00119b9c <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  119b9c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  119ba0:	e28db000 	add	fp, sp, #0
  119ba4:	e24dd00c 	sub	sp, sp, #12
  119ba8:	e50b0008 	str	r0, [fp, #-8]
    mib2_remove_route_ip4(1, netif);
  } else {
    /* install default route */
    mib2_add_route_ip4(1, netif);
  }
  netif_default = netif;
  119bac:	e3063838 	movw	r3, #26680	; 0x6838
  119bb0:	e3403057 	movt	r3, #87	; 0x57
  119bb4:	e51b2008 	ldr	r2, [fp, #-8]
  119bb8:	e5832000 	str	r2, [r3]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  119bbc:	e320f000 	nop	{0}
  119bc0:	e28bd000 	add	sp, fp, #0
  119bc4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  119bc8:	e12fff1e 	bx	lr

00119bcc <netif_set_up>:
 * Bring an interface up, available for processing
 * traffic.
 */
void
netif_set_up(struct netif *netif)
{
  119bcc:	e92d4800 	push	{fp, lr}
  119bd0:	e28db004 	add	fp, sp, #4
  119bd4:	e24dd008 	sub	sp, sp, #8
  119bd8:	e50b0008 	str	r0, [fp, #-8]
  if (!(netif->flags & NETIF_FLAG_UP)) {
  119bdc:	e51b3008 	ldr	r3, [fp, #-8]
  119be0:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119be4:	e2033001 	and	r3, r3, #1
  119be8:	e3530000 	cmp	r3, #0
  119bec:	1a000025 	bne	119c88 <netif_set_up+0xbc>
    netif->flags |= NETIF_FLAG_UP;
  119bf0:	e51b3008 	ldr	r3, [fp, #-8]
  119bf4:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119bf8:	e3833001 	orr	r3, r3, #1
  119bfc:	e6ef2073 	uxtb	r2, r3
  119c00:	e51b3008 	ldr	r3, [fp, #-8]
  119c04:	e5c32041 	strb	r2, [r3, #65]	; 0x41

    MIB2_COPY_SYSUPTIME_TO(&netif->ts);
  119c08:	ebffc534 	bl	10b0e0 <sys_now>
  119c0c:	e1a02000 	mov	r2, r0
  119c10:	e30c3ccd 	movw	r3, #52429	; 0xcccd
  119c14:	e34c3ccc 	movt	r3, #52428	; 0xcccc
  119c18:	e0832392 	umull	r2, r3, r2, r3
  119c1c:	e1a021a3 	lsr	r2, r3, #3
  119c20:	e51b3008 	ldr	r3, [fp, #-8]
  119c24:	e583204c 	str	r2, [r3, #76]	; 0x4c

    NETIF_STATUS_CALLBACK(netif);
  119c28:	e51b3008 	ldr	r3, [fp, #-8]
  119c2c:	e593301c 	ldr	r3, [r3, #28]
  119c30:	e3530000 	cmp	r3, #0
  119c34:	0a000003 	beq	119c48 <netif_set_up+0x7c>
  119c38:	e51b3008 	ldr	r3, [fp, #-8]
  119c3c:	e593301c 	ldr	r3, [r3, #28]
  119c40:	e51b0008 	ldr	r0, [fp, #-8]
  119c44:	e12fff33 	blx	r3

    if (netif->flags & NETIF_FLAG_LINK_UP) {
  119c48:	e51b3008 	ldr	r3, [fp, #-8]
  119c4c:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119c50:	e2033004 	and	r3, r3, #4
  119c54:	e3530000 	cmp	r3, #0
  119c58:	0a000002 	beq	119c68 <netif_set_up+0x9c>
      netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4|NETIF_REPORT_TYPE_IPV6);
  119c5c:	e3a01003 	mov	r1, #3
  119c60:	e51b0008 	ldr	r0, [fp, #-8]
  119c64:	eb00000a 	bl	119c94 <netif_issue_reports>
    }

#ifdef RT_USING_NETDEV
    /* rt-thread network interface device set up status */
    netdev_low_level_set_status(netdev_get_by_name(netif->name), RT_TRUE);
  119c68:	e51b3008 	ldr	r3, [fp, #-8]
  119c6c:	e2833042 	add	r3, r3, #66	; 0x42
  119c70:	e1a00003 	mov	r0, r3
  119c74:	ebffae24 	bl	10550c <netdev_get_by_name>
  119c78:	e1a03000 	mov	r3, r0
  119c7c:	e3a01001 	mov	r1, #1
  119c80:	e1a00003 	mov	r0, r3
  119c84:	ebffb1ea 	bl	106434 <netdev_low_level_set_status>
#endif /* RT_USING_NETDEV */
  }
}
  119c88:	e320f000 	nop	{0}
  119c8c:	e24bd004 	sub	sp, fp, #4
  119c90:	e8bd8800 	pop	{fp, pc}

00119c94 <netif_issue_reports>:

/** Send ARP/IGMP/MLD/RS events, e.g. on link-up/netif-up or addr-change
 */
static void
netif_issue_reports(struct netif* netif, u8_t report_type)
{
  119c94:	e92d4800 	push	{fp, lr}
  119c98:	e28db004 	add	fp, sp, #4
  119c9c:	e24dd008 	sub	sp, sp, #8
  119ca0:	e50b0008 	str	r0, [fp, #-8]
  119ca4:	e1a03001 	mov	r3, r1
  119ca8:	e54b3009 	strb	r3, [fp, #-9]
#if LWIP_IPV4
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
  119cac:	e55b3009 	ldrb	r3, [fp, #-9]
  119cb0:	e2033001 	and	r3, r3, #1
  119cb4:	e3530000 	cmp	r3, #0
  119cb8:	0a000015 	beq	119d14 <netif_issue_reports+0x80>
      !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
  119cbc:	e51b3008 	ldr	r3, [fp, #-8]
  119cc0:	e2833004 	add	r3, r3, #4
  119cc4:	e5933000 	ldr	r3, [r3]
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
  119cc8:	e3530000 	cmp	r3, #0
  119ccc:	0a000010 	beq	119d14 <netif_issue_reports+0x80>
#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
  119cd0:	e51b3008 	ldr	r3, [fp, #-8]
  119cd4:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119cd8:	e2033008 	and	r3, r3, #8
  119cdc:	e3530000 	cmp	r3, #0
  119ce0:	0a000004 	beq	119cf8 <netif_issue_reports+0x64>
      etharp_gratuitous(netif);
  119ce4:	e51b3008 	ldr	r3, [fp, #-8]
  119ce8:	e2833004 	add	r3, r3, #4
  119cec:	e1a01003 	mov	r1, r3
  119cf0:	e51b0008 	ldr	r0, [fp, #-8]
  119cf4:	eb00567f 	bl	12f6f8 <etharp_request>
    }
#endif /* LWIP_ARP */

#if LWIP_IGMP
    /* resend IGMP memberships */
    if (netif->flags & NETIF_FLAG_IGMP) {
  119cf8:	e51b3008 	ldr	r3, [fp, #-8]
  119cfc:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119d00:	e2033020 	and	r3, r3, #32
  119d04:	e3530000 	cmp	r3, #0
  119d08:	0a000001 	beq	119d14 <netif_issue_reports+0x80>
      igmp_report_groups(netif);
  119d0c:	e51b0008 	ldr	r0, [fp, #-8]
  119d10:	eb005958 	bl	130278 <igmp_report_groups>
    /* Send Router Solicitation messages. */
    netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
#endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
  }
#endif /* LWIP_IPV6 */
}
  119d14:	e320f000 	nop	{0}
  119d18:	e24bd004 	sub	sp, fp, #4
  119d1c:	e8bd8800 	pop	{fp, pc}

00119d20 <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
  119d20:	e92d4800 	push	{fp, lr}
  119d24:	e28db004 	add	fp, sp, #4
  119d28:	e24dd008 	sub	sp, sp, #8
  119d2c:	e50b0008 	str	r0, [fp, #-8]
  if (netif->flags & NETIF_FLAG_UP) {
  119d30:	e51b3008 	ldr	r3, [fp, #-8]
  119d34:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119d38:	e2033001 	and	r3, r3, #1
  119d3c:	e3530000 	cmp	r3, #0
  119d40:	0a000024 	beq	119dd8 <netif_set_down+0xb8>
    netif->flags &= ~NETIF_FLAG_UP;
  119d44:	e51b3008 	ldr	r3, [fp, #-8]
  119d48:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119d4c:	e3c33001 	bic	r3, r3, #1
  119d50:	e6ef2073 	uxtb	r2, r3
  119d54:	e51b3008 	ldr	r3, [fp, #-8]
  119d58:	e5c32041 	strb	r2, [r3, #65]	; 0x41
    MIB2_COPY_SYSUPTIME_TO(&netif->ts);
  119d5c:	ebffc4df 	bl	10b0e0 <sys_now>
  119d60:	e1a02000 	mov	r2, r0
  119d64:	e30c3ccd 	movw	r3, #52429	; 0xcccd
  119d68:	e34c3ccc 	movt	r3, #52428	; 0xcccc
  119d6c:	e0832392 	umull	r2, r3, r2, r3
  119d70:	e1a021a3 	lsr	r2, r3, #3
  119d74:	e51b3008 	ldr	r3, [fp, #-8]
  119d78:	e583204c 	str	r2, [r3, #76]	; 0x4c

#if LWIP_IPV4 && LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
  119d7c:	e51b3008 	ldr	r3, [fp, #-8]
  119d80:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119d84:	e2033008 	and	r3, r3, #8
  119d88:	e3530000 	cmp	r3, #0
  119d8c:	0a000001 	beq	119d98 <netif_set_down+0x78>
      etharp_cleanup_netif(netif);
  119d90:	e51b0008 	ldr	r0, [fp, #-8]
  119d94:	eb00519d 	bl	12e410 <etharp_cleanup_netif>

#if LWIP_IPV6
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
  119d98:	e51b3008 	ldr	r3, [fp, #-8]
  119d9c:	e593301c 	ldr	r3, [r3, #28]
  119da0:	e3530000 	cmp	r3, #0
  119da4:	0a000003 	beq	119db8 <netif_set_down+0x98>
  119da8:	e51b3008 	ldr	r3, [fp, #-8]
  119dac:	e593301c 	ldr	r3, [r3, #28]
  119db0:	e51b0008 	ldr	r0, [fp, #-8]
  119db4:	e12fff33 	blx	r3

#ifdef RT_USING_NETDEV
    /* rt-thread network interface device set down status */
    netdev_low_level_set_status(netdev_get_by_name(netif->name), RT_FALSE);
  119db8:	e51b3008 	ldr	r3, [fp, #-8]
  119dbc:	e2833042 	add	r3, r3, #66	; 0x42
  119dc0:	e1a00003 	mov	r0, r3
  119dc4:	ebffadd0 	bl	10550c <netdev_get_by_name>
  119dc8:	e1a03000 	mov	r3, r0
  119dcc:	e3a01000 	mov	r1, #0
  119dd0:	e1a00003 	mov	r0, r3
  119dd4:	ebffb196 	bl	106434 <netdev_low_level_set_status>
#endif /* RT_USING_NETDEV */
  }
}
  119dd8:	e320f000 	nop	{0}
  119ddc:	e24bd004 	sub	sp, fp, #4
  119de0:	e8bd8800 	pop	{fp, pc}

00119de4 <netif_set_status_callback>:
 * @ingroup netif
 * Set callback to be called when interface is brought up/down or address is changed while up
 */
void
netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
  119de4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  119de8:	e28db000 	add	fp, sp, #0
  119dec:	e24dd00c 	sub	sp, sp, #12
  119df0:	e50b0008 	str	r0, [fp, #-8]
  119df4:	e50b100c 	str	r1, [fp, #-12]
  if (netif) {
  119df8:	e51b3008 	ldr	r3, [fp, #-8]
  119dfc:	e3530000 	cmp	r3, #0
  119e00:	0a000002 	beq	119e10 <netif_set_status_callback+0x2c>
    netif->status_callback = status_callback;
  119e04:	e51b3008 	ldr	r3, [fp, #-8]
  119e08:	e51b200c 	ldr	r2, [fp, #-12]
  119e0c:	e583201c 	str	r2, [r3, #28]
  }
}
  119e10:	e320f000 	nop	{0}
  119e14:	e28bd000 	add	sp, fp, #0
  119e18:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  119e1c:	e12fff1e 	bx	lr

00119e20 <netif_set_link_up>:
 * @ingroup netif
 * Called by a driver when its link goes up
 */
void
netif_set_link_up(struct netif *netif)
{
  119e20:	e92d4800 	push	{fp, lr}
  119e24:	e28db004 	add	fp, sp, #4
  119e28:	e24dd008 	sub	sp, sp, #8
  119e2c:	e50b0008 	str	r0, [fp, #-8]
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
  119e30:	e51b3008 	ldr	r3, [fp, #-8]
  119e34:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119e38:	e2033004 	and	r3, r3, #4
  119e3c:	e3530000 	cmp	r3, #0
  119e40:	1a00001f 	bne	119ec4 <netif_set_link_up+0xa4>
    netif->flags |= NETIF_FLAG_LINK_UP;
  119e44:	e51b3008 	ldr	r3, [fp, #-8]
  119e48:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119e4c:	e3833004 	orr	r3, r3, #4
  119e50:	e6ef2073 	uxtb	r2, r3
  119e54:	e51b3008 	ldr	r3, [fp, #-8]
  119e58:	e5c32041 	strb	r2, [r3, #65]	; 0x41

#if LWIP_DHCP
    dhcp_network_changed(netif);
  119e5c:	e51b0008 	ldr	r0, [fp, #-8]
  119e60:	eb0044de 	bl	12b1e0 <dhcp_network_changed>

#if LWIP_AUTOIP
    autoip_network_changed(netif);
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
  119e64:	e51b3008 	ldr	r3, [fp, #-8]
  119e68:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119e6c:	e2033001 	and	r3, r3, #1
  119e70:	e3530000 	cmp	r3, #0
  119e74:	0a000002 	beq	119e84 <netif_set_link_up+0x64>
      netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4|NETIF_REPORT_TYPE_IPV6);
  119e78:	e3a01003 	mov	r1, #3
  119e7c:	e51b0008 	ldr	r0, [fp, #-8]
  119e80:	ebffff83 	bl	119c94 <netif_issue_reports>
    }
    NETIF_LINK_CALLBACK(netif);
  119e84:	e51b3008 	ldr	r3, [fp, #-8]
  119e88:	e5933020 	ldr	r3, [r3, #32]
  119e8c:	e3530000 	cmp	r3, #0
  119e90:	0a000003 	beq	119ea4 <netif_set_link_up+0x84>
  119e94:	e51b3008 	ldr	r3, [fp, #-8]
  119e98:	e5933020 	ldr	r3, [r3, #32]
  119e9c:	e51b0008 	ldr	r0, [fp, #-8]
  119ea0:	e12fff33 	blx	r3

#ifdef RT_USING_NETDEV
    /* rt-thread network interface device set link up status */
    netdev_low_level_set_link_status(netdev_get_by_name(netif->name), RT_TRUE);
  119ea4:	e51b3008 	ldr	r3, [fp, #-8]
  119ea8:	e2833042 	add	r3, r3, #66	; 0x42
  119eac:	e1a00003 	mov	r0, r3
  119eb0:	ebffad95 	bl	10550c <netdev_get_by_name>
  119eb4:	e1a03000 	mov	r3, r0
  119eb8:	e3a01001 	mov	r1, #1
  119ebc:	e1a00003 	mov	r0, r3
  119ec0:	ebffb18b 	bl	1064f4 <netdev_low_level_set_link_status>
#endif /* RT_USING_NETDEV */
  }
}
  119ec4:	e320f000 	nop	{0}
  119ec8:	e24bd004 	sub	sp, fp, #4
  119ecc:	e8bd8800 	pop	{fp, pc}

00119ed0 <netif_set_link_down>:
 * @ingroup netif
 * Called by a driver when its link goes down
 */
void
netif_set_link_down(struct netif *netif )
{
  119ed0:	e92d4800 	push	{fp, lr}
  119ed4:	e28db004 	add	fp, sp, #4
  119ed8:	e24dd008 	sub	sp, sp, #8
  119edc:	e50b0008 	str	r0, [fp, #-8]
  if (netif->flags & NETIF_FLAG_LINK_UP) {
  119ee0:	e51b3008 	ldr	r3, [fp, #-8]
  119ee4:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119ee8:	e2033004 	and	r3, r3, #4
  119eec:	e3530000 	cmp	r3, #0
  119ef0:	0a000015 	beq	119f4c <netif_set_link_down+0x7c>
    netif->flags &= ~NETIF_FLAG_LINK_UP;
  119ef4:	e51b3008 	ldr	r3, [fp, #-8]
  119ef8:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  119efc:	e3c33004 	bic	r3, r3, #4
  119f00:	e6ef2073 	uxtb	r2, r3
  119f04:	e51b3008 	ldr	r3, [fp, #-8]
  119f08:	e5c32041 	strb	r2, [r3, #65]	; 0x41
    NETIF_LINK_CALLBACK(netif);
  119f0c:	e51b3008 	ldr	r3, [fp, #-8]
  119f10:	e5933020 	ldr	r3, [r3, #32]
  119f14:	e3530000 	cmp	r3, #0
  119f18:	0a000003 	beq	119f2c <netif_set_link_down+0x5c>
  119f1c:	e51b3008 	ldr	r3, [fp, #-8]
  119f20:	e5933020 	ldr	r3, [r3, #32]
  119f24:	e51b0008 	ldr	r0, [fp, #-8]
  119f28:	e12fff33 	blx	r3

#ifdef RT_USING_NETDEV
    /* rt-thread network interface device set link down status */
    netdev_low_level_set_link_status(netdev_get_by_name(netif->name), RT_FALSE);
  119f2c:	e51b3008 	ldr	r3, [fp, #-8]
  119f30:	e2833042 	add	r3, r3, #66	; 0x42
  119f34:	e1a00003 	mov	r0, r3
  119f38:	ebffad73 	bl	10550c <netdev_get_by_name>
  119f3c:	e1a03000 	mov	r3, r0
  119f40:	e3a01000 	mov	r1, #0
  119f44:	e1a00003 	mov	r0, r3
  119f48:	ebffb169 	bl	1064f4 <netdev_low_level_set_link_status>
#endif /* RT_USING_NETDEV */
  }
}
  119f4c:	e320f000 	nop	{0}
  119f50:	e24bd004 	sub	sp, fp, #4
  119f54:	e8bd8800 	pop	{fp, pc}

00119f58 <netif_set_link_callback>:
 * @ingroup netif
 * Set callback to be called when link is brought up/down
 */
void
netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
  119f58:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  119f5c:	e28db000 	add	fp, sp, #0
  119f60:	e24dd00c 	sub	sp, sp, #12
  119f64:	e50b0008 	str	r0, [fp, #-8]
  119f68:	e50b100c 	str	r1, [fp, #-12]
  if (netif) {
  119f6c:	e51b3008 	ldr	r3, [fp, #-8]
  119f70:	e3530000 	cmp	r3, #0
  119f74:	0a000002 	beq	119f84 <netif_set_link_callback+0x2c>
    netif->link_callback = link_callback;
  119f78:	e51b3008 	ldr	r3, [fp, #-8]
  119f7c:	e51b200c 	ldr	r2, [fp, #-12]
  119f80:	e5832020 	str	r2, [r3, #32]
  }
}
  119f84:	e320f000 	nop	{0}
  119f88:	e28bd000 	add	sp, fp, #0
  119f8c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  119f90:	e12fff1e 	bx	lr

00119f94 <netif_loop_output>:
 * @return ERR_OK if the packet has been sent
 *         ERR_MEM if the pbuf used to copy the packet couldn't be allocated
 */
err_t
netif_loop_output(struct netif *netif, struct pbuf *p)
{
  119f94:	e92d4800 	push	{fp, lr}
  119f98:	e28db004 	add	fp, sp, #4
  119f9c:	e24dd018 	sub	sp, sp, #24
  119fa0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  119fa4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
   * if not they are adjusted for 'netif'. */
#if MIB2_STATS
#if LWIP_HAVE_LOOPIF
  struct netif *stats_if = &loop_netif;
#else /* LWIP_HAVE_LOOPIF */
  struct netif *stats_if = netif;
  119fa8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  119fac:	e50b300c 	str	r3, [fp, #-12]
#endif /* LWIP_HAVE_LOOPIF */
#endif /* MIB2_STATS */
  SYS_ARCH_DECL_PROTECT(lev);

  /* Allocate a new pbuf */
  r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  119fb0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  119fb4:	e1d330b8 	ldrh	r3, [r3, #8]
  119fb8:	e3a02000 	mov	r2, #0
  119fbc:	e1a01003 	mov	r1, r3
  119fc0:	e3a00002 	mov	r0, #2
  119fc4:	eb000133 	bl	11a498 <pbuf_alloc>
  119fc8:	e50b0010 	str	r0, [fp, #-16]
  if (r == NULL) {
  119fcc:	e51b3010 	ldr	r3, [fp, #-16]
  119fd0:	e3530000 	cmp	r3, #0
  119fd4:	1a000016 	bne	11a034 <netif_loop_output+0xa0>
    LINK_STATS_INC(link.memerr);
  119fd8:	e3063840 	movw	r3, #26688	; 0x6840
  119fdc:	e3403057 	movt	r3, #87	; 0x57
  119fe0:	e1d330bc 	ldrh	r3, [r3, #12]
  119fe4:	e2833001 	add	r3, r3, #1
  119fe8:	e6ff2073 	uxth	r2, r3
  119fec:	e3063840 	movw	r3, #26688	; 0x6840
  119ff0:	e3403057 	movt	r3, #87	; 0x57
  119ff4:	e1c320bc 	strh	r2, [r3, #12]
    LINK_STATS_INC(link.drop);
  119ff8:	e3063840 	movw	r3, #26688	; 0x6840
  119ffc:	e3403057 	movt	r3, #87	; 0x57
  11a000:	e1d330b6 	ldrh	r3, [r3, #6]
  11a004:	e2833001 	add	r3, r3, #1
  11a008:	e6ff2073 	uxth	r2, r3
  11a00c:	e3063840 	movw	r3, #26688	; 0x6840
  11a010:	e3403057 	movt	r3, #87	; 0x57
  11a014:	e1c320b6 	strh	r2, [r3, #6]
    MIB2_STATS_NETIF_INC(stats_if, ifoutdiscards);
  11a018:	e51b300c 	ldr	r3, [fp, #-12]
  11a01c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  11a020:	e2832001 	add	r2, r3, #1
  11a024:	e51b300c 	ldr	r3, [fp, #-12]
  11a028:	e5832074 	str	r2, [r3, #116]	; 0x74
    return ERR_MEM;
  11a02c:	e3e03000 	mvn	r3, #0
  11a030:	ea000063 	b	11a1c4 <netif_loop_output+0x230>
  }
  netif->loop_cnt_current += clen;
#endif /* LWIP_LOOPBACK_MAX_PBUFS */

  /* Copy the whole pbuf queue p into the single pbuf r */
  if ((err = pbuf_copy(r, p)) != ERR_OK) {
  11a034:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  11a038:	e51b0010 	ldr	r0, [fp, #-16]
  11a03c:	eb000571 	bl	11b608 <pbuf_copy>
  11a040:	e1a03000 	mov	r3, r0
  11a044:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  11a048:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  11a04c:	e3530000 	cmp	r3, #0
  11a050:	0a000018 	beq	11a0b8 <netif_loop_output+0x124>
    pbuf_free(r);
  11a054:	e51b0010 	ldr	r0, [fp, #-16]
  11a058:	eb000415 	bl	11b0b4 <pbuf_free>
    LINK_STATS_INC(link.memerr);
  11a05c:	e3063840 	movw	r3, #26688	; 0x6840
  11a060:	e3403057 	movt	r3, #87	; 0x57
  11a064:	e1d330bc 	ldrh	r3, [r3, #12]
  11a068:	e2833001 	add	r3, r3, #1
  11a06c:	e6ff2073 	uxth	r2, r3
  11a070:	e3063840 	movw	r3, #26688	; 0x6840
  11a074:	e3403057 	movt	r3, #87	; 0x57
  11a078:	e1c320bc 	strh	r2, [r3, #12]
    LINK_STATS_INC(link.drop);
  11a07c:	e3063840 	movw	r3, #26688	; 0x6840
  11a080:	e3403057 	movt	r3, #87	; 0x57
  11a084:	e1d330b6 	ldrh	r3, [r3, #6]
  11a088:	e2833001 	add	r3, r3, #1
  11a08c:	e6ff2073 	uxth	r2, r3
  11a090:	e3063840 	movw	r3, #26688	; 0x6840
  11a094:	e3403057 	movt	r3, #87	; 0x57
  11a098:	e1c320b6 	strh	r2, [r3, #6]
    MIB2_STATS_NETIF_INC(stats_if, ifoutdiscards);
  11a09c:	e51b300c 	ldr	r3, [fp, #-12]
  11a0a0:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  11a0a4:	e2832001 	add	r2, r3, #1
  11a0a8:	e51b300c 	ldr	r3, [fp, #-12]
  11a0ac:	e5832074 	str	r2, [r3, #116]	; 0x74
    return err;
  11a0b0:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  11a0b4:	ea000042 	b	11a1c4 <netif_loop_output+0x230>

  /* Put the packet on a linked list which gets emptied through calling
     netif_poll(). */

  /* let last point to the last pbuf in chain r */
  for (last = r; last->next != NULL; last = last->next);
  11a0b8:	e51b3010 	ldr	r3, [fp, #-16]
  11a0bc:	e50b3008 	str	r3, [fp, #-8]
  11a0c0:	ea000002 	b	11a0d0 <netif_loop_output+0x13c>
  11a0c4:	e51b3008 	ldr	r3, [fp, #-8]
  11a0c8:	e5933000 	ldr	r3, [r3]
  11a0cc:	e50b3008 	str	r3, [fp, #-8]
  11a0d0:	e51b3008 	ldr	r3, [fp, #-8]
  11a0d4:	e5933000 	ldr	r3, [r3]
  11a0d8:	e3530000 	cmp	r3, #0
  11a0dc:	1afffff8 	bne	11a0c4 <netif_loop_output+0x130>

  SYS_ARCH_PROTECT(lev);
  11a0e0:	ebffa055 	bl	10223c <rt_enter_critical>
  if (netif->loop_first != NULL) {
  11a0e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a0e8:	e5933080 	ldr	r3, [r3, #128]	; 0x80
  11a0ec:	e3530000 	cmp	r3, #0
  11a0f0:	0a000012 	beq	11a140 <netif_loop_output+0x1ac>
    LWIP_ASSERT("if first != NULL, last must also be != NULL", netif->loop_last != NULL);
  11a0f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a0f8:	e5933084 	ldr	r3, [r3, #132]	; 0x84
  11a0fc:	e3530000 	cmp	r3, #0
  11a100:	1a000006 	bne	11a120 <netif_loop_output+0x18c>
  11a104:	e30707b4 	movw	r0, #30644	; 0x77b4
  11a108:	e3400014 	movt	r0, #20
  11a10c:	ebffa400 	bl	103114 <rt_kprintf>
  11a110:	e3001382 	movw	r1, #898	; 0x382
  11a114:	e3070784 	movw	r0, #30596	; 0x7784
  11a118:	e3400014 	movt	r0, #20
  11a11c:	ebffc3d6 	bl	10b07c <sys_arch_assert>
    netif->loop_last->next = r;
  11a120:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a124:	e5933084 	ldr	r3, [r3, #132]	; 0x84
  11a128:	e51b2010 	ldr	r2, [fp, #-16]
  11a12c:	e5832000 	str	r2, [r3]
    netif->loop_last = last;
  11a130:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a134:	e51b2008 	ldr	r2, [fp, #-8]
  11a138:	e5832084 	str	r2, [r3, #132]	; 0x84
  11a13c:	ea000005 	b	11a158 <netif_loop_output+0x1c4>
  } else {
    netif->loop_first = r;
  11a140:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a144:	e51b2010 	ldr	r2, [fp, #-16]
  11a148:	e5832080 	str	r2, [r3, #128]	; 0x80
    netif->loop_last = last;
  11a14c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a150:	e51b2008 	ldr	r2, [fp, #-8]
  11a154:	e5832084 	str	r2, [r3, #132]	; 0x84
  }
  SYS_ARCH_UNPROTECT(lev);
  11a158:	ebffa03d 	bl	102254 <rt_exit_critical>

  LINK_STATS_INC(link.xmit);
  11a15c:	e3063840 	movw	r3, #26688	; 0x6840
  11a160:	e3403057 	movt	r3, #87	; 0x57
  11a164:	e1d330b0 	ldrh	r3, [r3]
  11a168:	e2833001 	add	r3, r3, #1
  11a16c:	e6ff2073 	uxth	r2, r3
  11a170:	e3063840 	movw	r3, #26688	; 0x6840
  11a174:	e3403057 	movt	r3, #87	; 0x57
  11a178:	e1c320b0 	strh	r2, [r3]
  MIB2_STATS_NETIF_ADD(stats_if, ifoutoctets, p->tot_len);
  11a17c:	e51b300c 	ldr	r3, [fp, #-12]
  11a180:	e5933068 	ldr	r3, [r3, #104]	; 0x68
  11a184:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  11a188:	e1d220b8 	ldrh	r2, [r2, #8]
  11a18c:	e0832002 	add	r2, r3, r2
  11a190:	e51b300c 	ldr	r3, [fp, #-12]
  11a194:	e5832068 	str	r2, [r3, #104]	; 0x68
  MIB2_STATS_NETIF_INC(stats_if, ifoutucastpkts);
  11a198:	e51b300c 	ldr	r3, [fp, #-12]
  11a19c:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  11a1a0:	e2832001 	add	r2, r3, #1
  11a1a4:	e51b300c 	ldr	r3, [fp, #-12]
  11a1a8:	e583206c 	str	r2, [r3, #108]	; 0x6c

#if LWIP_NETIF_LOOPBACK_MULTITHREADING
  /* For multithreading environment, schedule a call to netif_poll */
  tcpip_callback_with_block((tcpip_callback_fn)netif_poll, netif, 0);
  11a1ac:	e3a02000 	mov	r2, #0
  11a1b0:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  11a1b4:	e30a01d0 	movw	r0, #41424	; 0xa1d0
  11a1b8:	e3400011 	movt	r0, #17
  11a1bc:	ebfff084 	bl	1163d4 <tcpip_callback_with_block>
#endif /* LWIP_NETIF_LOOPBACK_MULTITHREADING */

  return ERR_OK;
  11a1c0:	e3a03000 	mov	r3, #0
}
  11a1c4:	e1a00003 	mov	r0, r3
  11a1c8:	e24bd004 	sub	sp, fp, #4
  11a1cc:	e8bd8800 	pop	{fp, pc}

0011a1d0 <netif_poll>:
 * netif_loop_output() are put on a list that is passed to netif->input() by
 * netif_poll().
 */
void
netif_poll(struct netif *netif)
{
  11a1d0:	e92d4800 	push	{fp, lr}
  11a1d4:	e28db004 	add	fp, sp, #4
  11a1d8:	e24dd018 	sub	sp, sp, #24
  11a1dc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
   * if not they are adjusted for 'netif'. */
#if MIB2_STATS
#if LWIP_HAVE_LOOPIF
  struct netif *stats_if = &loop_netif;
#else /* LWIP_HAVE_LOOPIF */
  struct netif *stats_if = netif;
  11a1e0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a1e4:	e50b300c 	str	r3, [fp, #-12]
#endif /* LWIP_HAVE_LOOPIF */
#endif /* MIB2_STATS */
  SYS_ARCH_DECL_PROTECT(lev);

  /* Get a packet from the list. With SYS_LIGHTWEIGHT_PROT=1, this is protected */
  SYS_ARCH_PROTECT(lev);
  11a1e8:	ebffa013 	bl	10223c <rt_enter_critical>
  while (netif->loop_first != NULL) {
  11a1ec:	ea000056 	b	11a34c <netif_poll+0x17c>
    struct pbuf *in, *in_end;
#if LWIP_LOOPBACK_MAX_PBUFS
    u8_t clen = 1;
#endif /* LWIP_LOOPBACK_MAX_PBUFS */

    in = in_end = netif->loop_first;
  11a1f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a1f4:	e5933080 	ldr	r3, [r3, #128]	; 0x80
  11a1f8:	e50b3008 	str	r3, [fp, #-8]
  11a1fc:	e51b3008 	ldr	r3, [fp, #-8]
  11a200:	e50b3010 	str	r3, [fp, #-16]
    while (in_end->len != in_end->tot_len) {
  11a204:	ea00000d 	b	11a240 <netif_poll+0x70>
      LWIP_ASSERT("bogus pbuf: len != tot_len but next == NULL!", in_end->next != NULL);
  11a208:	e51b3008 	ldr	r3, [fp, #-8]
  11a20c:	e5933000 	ldr	r3, [r3]
  11a210:	e3530000 	cmp	r3, #0
  11a214:	1a000006 	bne	11a234 <netif_poll+0x64>
  11a218:	e30707e0 	movw	r0, #30688	; 0x77e0
  11a21c:	e3400014 	movt	r0, #20
  11a220:	ebffa3bb 	bl	103114 <rt_kprintf>
  11a224:	e30013ca 	movw	r1, #970	; 0x3ca
  11a228:	e3070784 	movw	r0, #30596	; 0x7784
  11a22c:	e3400014 	movt	r0, #20
  11a230:	ebffc391 	bl	10b07c <sys_arch_assert>
      in_end = in_end->next;
  11a234:	e51b3008 	ldr	r3, [fp, #-8]
  11a238:	e5933000 	ldr	r3, [r3]
  11a23c:	e50b3008 	str	r3, [fp, #-8]
    while (in_end->len != in_end->tot_len) {
  11a240:	e51b3008 	ldr	r3, [fp, #-8]
  11a244:	e1d320ba 	ldrh	r2, [r3, #10]
  11a248:	e51b3008 	ldr	r3, [fp, #-8]
  11a24c:	e1d330b8 	ldrh	r3, [r3, #8]
  11a250:	e1520003 	cmp	r2, r3
  11a254:	1affffeb 	bne	11a208 <netif_poll+0x38>
      ((netif->loop_cnt_current - clen) < netif->loop_cnt_current));
    netif->loop_cnt_current -= clen;
#endif /* LWIP_LOOPBACK_MAX_PBUFS */

    /* 'in_end' now points to the last pbuf from 'in' */
    if (in_end == netif->loop_last) {
  11a258:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a25c:	e5933084 	ldr	r3, [r3, #132]	; 0x84
  11a260:	e51b2008 	ldr	r2, [fp, #-8]
  11a264:	e1520003 	cmp	r2, r3
  11a268:	1a000007 	bne	11a28c <netif_poll+0xbc>
      /* this was the last pbuf in the list */
      netif->loop_first = netif->loop_last = NULL;
  11a26c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a270:	e3a02000 	mov	r2, #0
  11a274:	e5832084 	str	r2, [r3, #132]	; 0x84
  11a278:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a27c:	e5932084 	ldr	r2, [r3, #132]	; 0x84
  11a280:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a284:	e5832080 	str	r2, [r3, #128]	; 0x80
  11a288:	ea00000e 	b	11a2c8 <netif_poll+0xf8>
    } else {
      /* pop the pbuf off the list */
      netif->loop_first = in_end->next;
  11a28c:	e51b3008 	ldr	r3, [fp, #-8]
  11a290:	e5932000 	ldr	r2, [r3]
  11a294:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a298:	e5832080 	str	r2, [r3, #128]	; 0x80
      LWIP_ASSERT("should not be null since first != last!", netif->loop_first != NULL);
  11a29c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a2a0:	e5933080 	ldr	r3, [r3, #128]	; 0x80
  11a2a4:	e3530000 	cmp	r3, #0
  11a2a8:	1a000006 	bne	11a2c8 <netif_poll+0xf8>
  11a2ac:	e3070810 	movw	r0, #30736	; 0x7810
  11a2b0:	e3400014 	movt	r0, #20
  11a2b4:	ebffa396 	bl	103114 <rt_kprintf>
  11a2b8:	e30013de 	movw	r1, #990	; 0x3de
  11a2bc:	e3070784 	movw	r0, #30596	; 0x7784
  11a2c0:	e3400014 	movt	r0, #20
  11a2c4:	ebffc36c 	bl	10b07c <sys_arch_assert>
    }
    /* De-queue the pbuf from its successors on the 'loop_' list. */
    in_end->next = NULL;
  11a2c8:	e51b3008 	ldr	r3, [fp, #-8]
  11a2cc:	e3a02000 	mov	r2, #0
  11a2d0:	e5832000 	str	r2, [r3]
    SYS_ARCH_UNPROTECT(lev);
  11a2d4:	ebff9fde 	bl	102254 <rt_exit_critical>

    LINK_STATS_INC(link.recv);
  11a2d8:	e3063840 	movw	r3, #26688	; 0x6840
  11a2dc:	e3403057 	movt	r3, #87	; 0x57
  11a2e0:	e1d330b2 	ldrh	r3, [r3, #2]
  11a2e4:	e2833001 	add	r3, r3, #1
  11a2e8:	e6ff2073 	uxth	r2, r3
  11a2ec:	e3063840 	movw	r3, #26688	; 0x6840
  11a2f0:	e3403057 	movt	r3, #87	; 0x57
  11a2f4:	e1c320b2 	strh	r2, [r3, #2]
    MIB2_STATS_NETIF_ADD(stats_if, ifinoctets, in->tot_len);
  11a2f8:	e51b300c 	ldr	r3, [fp, #-12]
  11a2fc:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  11a300:	e51b2010 	ldr	r2, [fp, #-16]
  11a304:	e1d220b8 	ldrh	r2, [r2, #8]
  11a308:	e0832002 	add	r2, r3, r2
  11a30c:	e51b300c 	ldr	r3, [fp, #-12]
  11a310:	e5832050 	str	r2, [r3, #80]	; 0x50
    MIB2_STATS_NETIF_INC(stats_if, ifinucastpkts);
  11a314:	e51b300c 	ldr	r3, [fp, #-12]
  11a318:	e5933054 	ldr	r3, [r3, #84]	; 0x54
  11a31c:	e2832001 	add	r2, r3, #1
  11a320:	e51b300c 	ldr	r3, [fp, #-12]
  11a324:	e5832054 	str	r2, [r3, #84]	; 0x54
    /* loopback packets are always IP packets! */
    if (ip_input(in, netif) != ERR_OK) {
  11a328:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  11a32c:	e51b0010 	ldr	r0, [fp, #-16]
  11a330:	eb005cbe 	bl	131630 <ip4_input>
  11a334:	e1a03000 	mov	r3, r0
  11a338:	e3530000 	cmp	r3, #0
  11a33c:	0a000001 	beq	11a348 <netif_poll+0x178>
      pbuf_free(in);
  11a340:	e51b0010 	ldr	r0, [fp, #-16]
  11a344:	eb00035a 	bl	11b0b4 <pbuf_free>
    }
    SYS_ARCH_PROTECT(lev);
  11a348:	ebff9fbb 	bl	10223c <rt_enter_critical>
  while (netif->loop_first != NULL) {
  11a34c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a350:	e5933080 	ldr	r3, [r3, #128]	; 0x80
  11a354:	e3530000 	cmp	r3, #0
  11a358:	1affffa4 	bne	11a1f0 <netif_poll+0x20>
  }
  SYS_ARCH_UNPROTECT(lev);
  11a35c:	ebff9fbc 	bl	102254 <rt_exit_critical>
}
  11a360:	e320f000 	nop	{0}
  11a364:	e24bd004 	sub	sp, fp, #4
  11a368:	e8bd8800 	pop	{fp, pc}

0011a36c <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
  11a36c:	e92d4800 	push	{fp, lr}
  11a370:	e28db004 	add	fp, sp, #4
  11a374:	e24dd008 	sub	sp, sp, #8
  struct tcp_pcb* pcb;
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
  11a378:	ebff9faf 	bl	10223c <rt_enter_critical>
  11a37c:	e306383c 	movw	r3, #26684	; 0x683c
  11a380:	e3403057 	movt	r3, #87	; 0x57
  11a384:	e3a02000 	mov	r2, #0
  11a388:	e5c32000 	strb	r2, [r3]
  11a38c:	ebff9fb0 	bl	102254 <rt_exit_critical>

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
  11a390:	e3063a30 	movw	r3, #27184	; 0x6a30
  11a394:	e3403057 	movt	r3, #87	; 0x57
  11a398:	e5933000 	ldr	r3, [r3]
  11a39c:	e50b3008 	str	r3, [fp, #-8]
  11a3a0:	ea00000e 	b	11a3e0 <pbuf_free_ooseq+0x74>
    if (NULL != pcb->ooseq) {
  11a3a4:	e51b3008 	ldr	r3, [fp, #-8]
  11a3a8:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  11a3ac:	e3530000 	cmp	r3, #0
  11a3b0:	0a000007 	beq	11a3d4 <pbuf_free_ooseq+0x68>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_segs_free(pcb->ooseq);
  11a3b4:	e51b3008 	ldr	r3, [fp, #-8]
  11a3b8:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  11a3bc:	e1a00003 	mov	r0, r3
  11a3c0:	eb00149b 	bl	11f634 <tcp_segs_free>
      pcb->ooseq = NULL;
  11a3c4:	e51b3008 	ldr	r3, [fp, #-8]
  11a3c8:	e3a02000 	mov	r2, #0
  11a3cc:	e5832074 	str	r2, [r3, #116]	; 0x74
      return;
  11a3d0:	ea000005 	b	11a3ec <pbuf_free_ooseq+0x80>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
  11a3d4:	e51b3008 	ldr	r3, [fp, #-8]
  11a3d8:	e593300c 	ldr	r3, [r3, #12]
  11a3dc:	e50b3008 	str	r3, [fp, #-8]
  11a3e0:	e51b3008 	ldr	r3, [fp, #-8]
  11a3e4:	e3530000 	cmp	r3, #0
  11a3e8:	1affffed 	bne	11a3a4 <pbuf_free_ooseq+0x38>
    }
  }
}
  11a3ec:	e24bd004 	sub	sp, fp, #4
  11a3f0:	e8bd8800 	pop	{fp, pc}

0011a3f4 <pbuf_free_ooseq_callback>:
/**
 * Just a callback function for tcpip_callback() that calls pbuf_free_ooseq().
 */
static void
pbuf_free_ooseq_callback(void *arg)
{
  11a3f4:	e92d4800 	push	{fp, lr}
  11a3f8:	e28db004 	add	fp, sp, #4
  11a3fc:	e24dd008 	sub	sp, sp, #8
  11a400:	e50b0008 	str	r0, [fp, #-8]
  LWIP_UNUSED_ARG(arg);
  pbuf_free_ooseq();
  11a404:	ebffffd8 	bl	11a36c <pbuf_free_ooseq>
}
  11a408:	e320f000 	nop	{0}
  11a40c:	e24bd004 	sub	sp, fp, #4
  11a410:	e8bd8800 	pop	{fp, pc}

0011a414 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
  11a414:	e92d4800 	push	{fp, lr}
  11a418:	e28db004 	add	fp, sp, #4
  11a41c:	e24dd008 	sub	sp, sp, #8
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
#else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
  u8_t queued;
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
  11a420:	ebff9f85 	bl	10223c <rt_enter_critical>
  queued = pbuf_free_ooseq_pending;
  11a424:	e306383c 	movw	r3, #26684	; 0x683c
  11a428:	e3403057 	movt	r3, #87	; 0x57
  11a42c:	e5d33000 	ldrb	r3, [r3]
  11a430:	e54b3005 	strb	r3, [fp, #-5]
  pbuf_free_ooseq_pending = 1;
  11a434:	e306383c 	movw	r3, #26684	; 0x683c
  11a438:	e3403057 	movt	r3, #87	; 0x57
  11a43c:	e3a02001 	mov	r2, #1
  11a440:	e5c32000 	strb	r2, [r3]
  SYS_ARCH_UNPROTECT(old_level);
  11a444:	ebff9f82 	bl	102254 <rt_exit_critical>

  if (!queued) {
  11a448:	e55b3005 	ldrb	r3, [fp, #-5]
  11a44c:	e3530000 	cmp	r3, #0
  11a450:	1a00000d 	bne	11a48c <pbuf_pool_is_empty+0x78>
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  11a454:	e3a02000 	mov	r2, #0
  11a458:	e3a01000 	mov	r1, #0
  11a45c:	e30a03f4 	movw	r0, #41972	; 0xa3f4
  11a460:	e3400011 	movt	r0, #17
  11a464:	ebffefda 	bl	1163d4 <tcpip_callback_with_block>
  11a468:	e1a03000 	mov	r3, r0
  11a46c:	e3530000 	cmp	r3, #0
  11a470:	0a000005 	beq	11a48c <pbuf_pool_is_empty+0x78>
  11a474:	ebff9f70 	bl	10223c <rt_enter_critical>
  11a478:	e306383c 	movw	r3, #26684	; 0x683c
  11a47c:	e3403057 	movt	r3, #87	; 0x57
  11a480:	e3a02000 	mov	r2, #0
  11a484:	e5c32000 	strb	r2, [r3]
  11a488:	ebff9f71 	bl	102254 <rt_exit_critical>
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
  11a48c:	e320f000 	nop	{0}
  11a490:	e24bd004 	sub	sp, fp, #4
  11a494:	e8bd8800 	pop	{fp, pc}

0011a498 <pbuf_alloc>:
 * is the first pbuf of a pbuf chain.
 */
#include <stdio.h>
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  11a498:	e92d4800 	push	{fp, lr}
  11a49c:	e28db004 	add	fp, sp, #4
  11a4a0:	e24dd028 	sub	sp, sp, #40	; 0x28
  11a4a4:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  11a4a8:	e1a03001 	mov	r3, r1
  11a4ac:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  11a4b0:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
  11a4b4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11a4b8:	e3530004 	cmp	r3, #4
  11a4bc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  11a4c0:	ea000013 	b	11a514 <pbuf_alloc+0x7c>
  11a4c4:	0011a4d8 	.word	0x0011a4d8
  11a4c8:	0011a4e4 	.word	0x0011a4e4
  11a4cc:	0011a4f0 	.word	0x0011a4f0
  11a4d0:	0011a4fc 	.word	0x0011a4fc
  11a4d4:	0011a508 	.word	0x0011a508
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
  11a4d8:	e3a03038 	mov	r3, #56	; 0x38
  11a4dc:	e14b30be 	strh	r3, [fp, #-14]
    break;
  11a4e0:	ea000014 	b	11a538 <pbuf_alloc+0xa0>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
  11a4e4:	e3a03024 	mov	r3, #36	; 0x24
  11a4e8:	e14b30be 	strh	r3, [fp, #-14]
    break;
  11a4ec:	ea000011 	b	11a538 <pbuf_alloc+0xa0>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
  11a4f0:	e3a03010 	mov	r3, #16
  11a4f4:	e14b30be 	strh	r3, [fp, #-14]
    break;
  11a4f8:	ea00000e 	b	11a538 <pbuf_alloc+0xa0>
  case PBUF_RAW_TX:
    /* add room for encapsulating link layer headers (e.g. 802.11) */
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
  11a4fc:	e3a03000 	mov	r3, #0
  11a500:	e14b30be 	strh	r3, [fp, #-14]
    break;
  11a504:	ea00000b 	b	11a538 <pbuf_alloc+0xa0>
  case PBUF_RAW:
    /* no offset (e.g. RX buffers or chain successors) */
    offset = 0;
  11a508:	e3a03000 	mov	r3, #0
  11a50c:	e14b30be 	strh	r3, [fp, #-14]
    break;
  11a510:	ea000008 	b	11a538 <pbuf_alloc+0xa0>
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  11a514:	e3070838 	movw	r0, #30776	; 0x7838
  11a518:	e3400014 	movt	r0, #20
  11a51c:	ebffa2fc 	bl	103114 <rt_kprintf>
  11a520:	e3001117 	movw	r1, #279	; 0x117
  11a524:	e3070854 	movw	r0, #30804	; 0x7854
  11a528:	e3400014 	movt	r0, #20
  11a52c:	ebffc2d2 	bl	10b07c <sys_arch_assert>
    return NULL;
  11a530:	e3a03000 	mov	r3, #0
  11a534:	ea000139 	b	11aa20 <pbuf_alloc+0x588>
  }

  switch (type) {
  11a538:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11a53c:	e3530003 	cmp	r3, #3
  11a540:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  11a544:	ea000124 	b	11a9dc <pbuf_alloc+0x544>
  11a548:	0011a864 	.word	0x0011a864
  11a54c:	0011a968 	.word	0x0011a968
  11a550:	0011a968 	.word	0x0011a968
  11a554:	0011a558 	.word	0x0011a558
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
  11a558:	e300211e 	movw	r2, #286	; 0x11e
  11a55c:	e3071854 	movw	r1, #30804	; 0x7854
  11a560:	e3401014 	movt	r1, #20
  11a564:	e3a00010 	mov	r0, #16
  11a568:	ebfffb5b 	bl	1192dc <memp_malloc_fn>
  11a56c:	e50b0008 	str	r0, [fp, #-8]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  11a570:	e51b3008 	ldr	r3, [fp, #-8]
  11a574:	e3530000 	cmp	r3, #0
  11a578:	1a000002 	bne	11a588 <pbuf_alloc+0xf0>
      PBUF_POOL_IS_EMPTY();
  11a57c:	ebffffa4 	bl	11a414 <pbuf_pool_is_empty>
      return NULL;
  11a580:	e3a03000 	mov	r3, #0
  11a584:	ea000125 	b	11aa20 <pbuf_alloc+0x588>
    }
    p->type = type;
  11a588:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11a58c:	e6ef2073 	uxtb	r2, r3
  11a590:	e51b3008 	ldr	r3, [fp, #-8]
  11a594:	e5c3200c 	strb	r2, [r3, #12]
    p->next = NULL;
  11a598:	e51b3008 	ldr	r3, [fp, #-8]
  11a59c:	e3a02000 	mov	r2, #0
  11a5a0:	e5832000 	str	r2, [r3]

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  11a5a4:	e15b30be 	ldrh	r3, [fp, #-14]
  11a5a8:	e2833010 	add	r3, r3, #16
  11a5ac:	e51b2008 	ldr	r2, [fp, #-8]
  11a5b0:	e0823003 	add	r3, r2, r3
  11a5b4:	e2833003 	add	r3, r3, #3
  11a5b8:	e3c33003 	bic	r3, r3, #3
  11a5bc:	e1a02003 	mov	r2, r3
  11a5c0:	e51b3008 	ldr	r3, [fp, #-8]
  11a5c4:	e5832004 	str	r2, [r3, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
  11a5c8:	e51b3008 	ldr	r3, [fp, #-8]
  11a5cc:	e5933004 	ldr	r3, [r3, #4]
  11a5d0:	e2033003 	and	r3, r3, #3
  11a5d4:	e3530000 	cmp	r3, #0
  11a5d8:	0a000006 	beq	11a5f8 <pbuf_alloc+0x160>
  11a5dc:	e3070880 	movw	r0, #30848	; 0x7880
  11a5e0:	e3400014 	movt	r0, #20
  11a5e4:	ebffa2ca 	bl	103114 <rt_kprintf>
  11a5e8:	e300112a 	movw	r1, #298	; 0x12a
  11a5ec:	e3070854 	movw	r0, #30804	; 0x7854
  11a5f0:	e3400014 	movt	r0, #20
  11a5f4:	ebffc2a0 	bl	10b07c <sys_arch_assert>
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  11a5f8:	e51b3008 	ldr	r3, [fp, #-8]
  11a5fc:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  11a600:	e1c320b8 	strh	r2, [r3, #8]
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  11a604:	e15b30be 	ldrh	r3, [fp, #-14]
  11a608:	e2833003 	add	r3, r3, #3
  11a60c:	e3c33003 	bic	r3, r3, #3
  11a610:	e2633e5e 	rsb	r3, r3, #1504	; 0x5e0
  11a614:	e283300c 	add	r3, r3, #12
  11a618:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  11a61c:	e1530002 	cmp	r3, r2
  11a620:	31a03003 	movcc	r3, r3
  11a624:	21a03002 	movcs	r3, r2
  11a628:	e6ff2073 	uxth	r2, r3
  11a62c:	e51b3008 	ldr	r3, [fp, #-8]
  11a630:	e1c320ba 	strh	r2, [r3, #10]
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  11a634:	e51b3008 	ldr	r3, [fp, #-8]
  11a638:	e5933004 	ldr	r3, [r3, #4]
  11a63c:	e51b2008 	ldr	r2, [fp, #-8]
  11a640:	e1d220ba 	ldrh	r2, [r2, #10]
  11a644:	e0832002 	add	r2, r3, r2
  11a648:	e51b3008 	ldr	r3, [fp, #-8]
  11a64c:	e2833e5f 	add	r3, r3, #1520	; 0x5f0
  11a650:	e283300c 	add	r3, r3, #12
  11a654:	e1520003 	cmp	r2, r3
  11a658:	9a000006 	bls	11a678 <pbuf_alloc+0x1e0>
  11a65c:	e30708b0 	movw	r0, #30896	; 0x78b0
  11a660:	e3400014 	movt	r0, #20
  11a664:	ebffa2aa 	bl	103114 <rt_kprintf>
  11a668:	e3001131 	movw	r1, #305	; 0x131
  11a66c:	e3070854 	movw	r0, #30804	; 0x7854
  11a670:	e3400014 	movt	r0, #20
  11a674:	ebffc280 	bl	10b07c <sys_arch_assert>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
  11a678:	e15b30be 	ldrh	r3, [fp, #-14]
  11a67c:	e2833003 	add	r3, r3, #3
  11a680:	e3c33003 	bic	r3, r3, #3
  11a684:	e30025ec 	movw	r2, #1516	; 0x5ec
  11a688:	e1530002 	cmp	r3, r2
  11a68c:	1a000006 	bne	11a6ac <pbuf_alloc+0x214>
  11a690:	e30708e4 	movw	r0, #30948	; 0x78e4
  11a694:	e3400014 	movt	r0, #20
  11a698:	ebffa29d 	bl	103114 <rt_kprintf>
  11a69c:	e3001133 	movw	r1, #307	; 0x133
  11a6a0:	e3070854 	movw	r0, #30804	; 0x7854
  11a6a4:	e3400014 	movt	r0, #20
  11a6a8:	ebffc273 	bl	10b07c <sys_arch_assert>
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  11a6ac:	e51b3008 	ldr	r3, [fp, #-8]
  11a6b0:	e3a02001 	mov	r2, #1
  11a6b4:	e1c320be 	strh	r2, [r3, #14]

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  11a6b8:	e51b3008 	ldr	r3, [fp, #-8]
  11a6bc:	e50b300c 	str	r3, [fp, #-12]
    /* remaining length to be allocated */
    rem_len = length - p->len;
  11a6c0:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  11a6c4:	e51b2008 	ldr	r2, [fp, #-8]
  11a6c8:	e1d220ba 	ldrh	r2, [r2, #10]
  11a6cc:	e0433002 	sub	r3, r3, r2
  11a6d0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  11a6d4:	ea00005e 	b	11a854 <pbuf_alloc+0x3bc>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
  11a6d8:	e300213f 	movw	r2, #319	; 0x13f
  11a6dc:	e3071854 	movw	r1, #30804	; 0x7854
  11a6e0:	e3401014 	movt	r1, #20
  11a6e4:	e3a00010 	mov	r0, #16
  11a6e8:	ebfffafb 	bl	1192dc <memp_malloc_fn>
  11a6ec:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
      if (q == NULL) {
  11a6f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a6f4:	e3530000 	cmp	r3, #0
  11a6f8:	1a000004 	bne	11a710 <pbuf_alloc+0x278>
        PBUF_POOL_IS_EMPTY();
  11a6fc:	ebffff44 	bl	11a414 <pbuf_pool_is_empty>
        /* free chain so far allocated */
        pbuf_free(p);
  11a700:	e51b0008 	ldr	r0, [fp, #-8]
  11a704:	eb00026a 	bl	11b0b4 <pbuf_free>
        /* bail out unsuccessfully */
        return NULL;
  11a708:	e3a03000 	mov	r3, #0
  11a70c:	ea0000c3 	b	11aa20 <pbuf_alloc+0x588>
      }
      q->type = type;
  11a710:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11a714:	e6ef2073 	uxtb	r2, r3
  11a718:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a71c:	e5c3200c 	strb	r2, [r3, #12]
      q->flags = 0;
  11a720:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a724:	e3a02000 	mov	r2, #0
  11a728:	e5c3200d 	strb	r2, [r3, #13]
      q->next = NULL;
  11a72c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a730:	e3a02000 	mov	r2, #0
  11a734:	e5832000 	str	r2, [r3]
      /* make previous pbuf point to this pbuf */
      r->next = q;
  11a738:	e51b300c 	ldr	r3, [fp, #-12]
  11a73c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  11a740:	e5832000 	str	r2, [r3]
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  11a744:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11a748:	e30f2ffe 	movw	r2, #65534	; 0xfffe
  11a74c:	e1530002 	cmp	r3, r2
  11a750:	da000006 	ble	11a770 <pbuf_alloc+0x2d8>
  11a754:	e3070918 	movw	r0, #31000	; 0x7918
  11a758:	e3400014 	movt	r0, #20
  11a75c:	ebffa26c 	bl	103114 <rt_kprintf>
  11a760:	e300114d 	movw	r1, #333	; 0x14d
  11a764:	e3070854 	movw	r0, #30804	; 0x7854
  11a768:	e3400014 	movt	r0, #20
  11a76c:	ebffc242 	bl	10b07c <sys_arch_assert>
      q->tot_len = (u16_t)rem_len;
  11a770:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11a774:	e6ff2073 	uxth	r2, r3
  11a778:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a77c:	e1c320b8 	strh	r2, [r3, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  11a780:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11a784:	e6ff3073 	uxth	r3, r3
  11a788:	e30025ec 	movw	r2, #1516	; 0x5ec
  11a78c:	e1530002 	cmp	r3, r2
  11a790:	31a03003 	movcc	r3, r3
  11a794:	21a03002 	movcs	r3, r2
  11a798:	e6ff2073 	uxth	r2, r3
  11a79c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a7a0:	e1c320ba 	strh	r2, [r3, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  11a7a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a7a8:	e2832010 	add	r2, r3, #16
  11a7ac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a7b0:	e5832004 	str	r2, [r3, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  11a7b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a7b8:	e5933004 	ldr	r3, [r3, #4]
  11a7bc:	e2033003 	and	r3, r3, #3
  11a7c0:	e3530000 	cmp	r3, #0
  11a7c4:	0a000006 	beq	11a7e4 <pbuf_alloc+0x34c>
  11a7c8:	e307092c 	movw	r0, #31020	; 0x792c
  11a7cc:	e3400014 	movt	r0, #20
  11a7d0:	ebffa24f 	bl	103114 <rt_kprintf>
  11a7d4:	e3001153 	movw	r1, #339	; 0x153
  11a7d8:	e3070854 	movw	r0, #30804	; 0x7854
  11a7dc:	e3400014 	movt	r0, #20
  11a7e0:	ebffc225 	bl	10b07c <sys_arch_assert>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  11a7e4:	e51b3008 	ldr	r3, [fp, #-8]
  11a7e8:	e5933004 	ldr	r3, [r3, #4]
  11a7ec:	e51b2008 	ldr	r2, [fp, #-8]
  11a7f0:	e1d220ba 	ldrh	r2, [r2, #10]
  11a7f4:	e0832002 	add	r2, r3, r2
  11a7f8:	e51b3008 	ldr	r3, [fp, #-8]
  11a7fc:	e2833e5f 	add	r3, r3, #1520	; 0x5f0
  11a800:	e283300c 	add	r3, r3, #12
  11a804:	e1520003 	cmp	r2, r3
  11a808:	9a000006 	bls	11a828 <pbuf_alloc+0x390>
  11a80c:	e30708b0 	movw	r0, #30896	; 0x78b0
  11a810:	e3400014 	movt	r0, #20
  11a814:	ebffa23e 	bl	103114 <rt_kprintf>
  11a818:	e3001156 	movw	r1, #342	; 0x156
  11a81c:	e3070854 	movw	r0, #30804	; 0x7854
  11a820:	e3400014 	movt	r0, #20
  11a824:	ebffc214 	bl	10b07c <sys_arch_assert>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  11a828:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a82c:	e3a02001 	mov	r2, #1
  11a830:	e1c320be 	strh	r2, [r3, #14]
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  11a834:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a838:	e1d330ba 	ldrh	r3, [r3, #10]
  11a83c:	e1a02003 	mov	r2, r3
  11a840:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11a844:	e0433002 	sub	r3, r3, r2
  11a848:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      /* remember this pbuf for linkage in next iteration */
      r = q;
  11a84c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11a850:	e50b300c 	str	r3, [fp, #-12]
    while (rem_len > 0) {
  11a854:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11a858:	e3530000 	cmp	r3, #0
  11a85c:	caffff9d 	bgt	11a6d8 <pbuf_alloc+0x240>
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  11a860:	ea000067 	b	11aa04 <pbuf_alloc+0x56c>
  case PBUF_RAM:
    {
      mem_size_t alloc_len = LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length);
  11a864:	e15b30be 	ldrh	r3, [fp, #-14]
  11a868:	e2833013 	add	r3, r3, #19
  11a86c:	e6ff3073 	uxth	r3, r3
  11a870:	e3c33003 	bic	r3, r3, #3
  11a874:	e6ff2073 	uxth	r2, r3
  11a878:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  11a87c:	e2833003 	add	r3, r3, #3
  11a880:	e6ff3073 	uxth	r3, r3
  11a884:	e3c33003 	bic	r3, r3, #3
  11a888:	e6ff3073 	uxth	r3, r3
  11a88c:	e0823003 	add	r3, r2, r3
  11a890:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
      
      /* bug #50040: Check for integer overflow when calculating alloc_len */
      if (alloc_len < LWIP_MEM_ALIGN_SIZE(length)) {
  11a894:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
  11a898:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  11a89c:	e2833003 	add	r3, r3, #3
  11a8a0:	e3c33003 	bic	r3, r3, #3
  11a8a4:	e1520003 	cmp	r2, r3
  11a8a8:	2a000001 	bcs	11a8b4 <pbuf_alloc+0x41c>
        return NULL;
  11a8ac:	e3a03000 	mov	r3, #0
  11a8b0:	ea00005a 	b	11aa20 <pbuf_alloc+0x588>
      }
    
      /* If pbuf is to be allocated in RAM, allocate memory for it. */
      p = (struct pbuf*)mem_malloc(alloc_len);
  11a8b4:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  11a8b8:	e1a00003 	mov	r0, r3
  11a8bc:	ebffc22f 	bl	10b180 <mem_malloc>
  11a8c0:	e50b0008 	str	r0, [fp, #-8]
    }

    if (p == NULL) {
  11a8c4:	e51b3008 	ldr	r3, [fp, #-8]
  11a8c8:	e3530000 	cmp	r3, #0
  11a8cc:	1a000001 	bne	11a8d8 <pbuf_alloc+0x440>
      return NULL;
  11a8d0:	e3a03000 	mov	r3, #0
  11a8d4:	ea000051 	b	11aa20 <pbuf_alloc+0x588>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  11a8d8:	e15b30be 	ldrh	r3, [fp, #-14]
  11a8dc:	e2833010 	add	r3, r3, #16
  11a8e0:	e51b2008 	ldr	r2, [fp, #-8]
  11a8e4:	e0823003 	add	r3, r2, r3
  11a8e8:	e2833003 	add	r3, r3, #3
  11a8ec:	e3c33003 	bic	r3, r3, #3
  11a8f0:	e1a02003 	mov	r2, r3
  11a8f4:	e51b3008 	ldr	r3, [fp, #-8]
  11a8f8:	e5832004 	str	r2, [r3, #4]
    p->len = p->tot_len = length;
  11a8fc:	e51b3008 	ldr	r3, [fp, #-8]
  11a900:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  11a904:	e1c320b8 	strh	r2, [r3, #8]
  11a908:	e51b3008 	ldr	r3, [fp, #-8]
  11a90c:	e1d320b8 	ldrh	r2, [r3, #8]
  11a910:	e51b3008 	ldr	r3, [fp, #-8]
  11a914:	e1c320ba 	strh	r2, [r3, #10]
    p->next = NULL;
  11a918:	e51b3008 	ldr	r3, [fp, #-8]
  11a91c:	e3a02000 	mov	r2, #0
  11a920:	e5832000 	str	r2, [r3]
    p->type = type;
  11a924:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11a928:	e6ef2073 	uxtb	r2, r3
  11a92c:	e51b3008 	ldr	r3, [fp, #-8]
  11a930:	e5c3200c 	strb	r2, [r3, #12]

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  11a934:	e51b3008 	ldr	r3, [fp, #-8]
  11a938:	e5933004 	ldr	r3, [r3, #4]
  11a93c:	e2033003 	and	r3, r3, #3
  11a940:	e3530000 	cmp	r3, #0
  11a944:	0a00002d 	beq	11aa00 <pbuf_alloc+0x568>
  11a948:	e307095c 	movw	r0, #31068	; 0x795c
  11a94c:	e3400014 	movt	r0, #20
  11a950:	ebffa1ef 	bl	103114 <rt_kprintf>
  11a954:	e3a01f5e 	mov	r1, #376	; 0x178
  11a958:	e3070854 	movw	r0, #30804	; 0x7854
  11a95c:	e3400014 	movt	r0, #20
  11a960:	ebffc1c5 	bl	10b07c <sys_arch_assert>
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  11a964:	ea000025 	b	11aa00 <pbuf_alloc+0x568>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
  11a968:	e300217f 	movw	r2, #383	; 0x17f
  11a96c:	e3071854 	movw	r1, #30804	; 0x7854
  11a970:	e3401014 	movt	r1, #20
  11a974:	e3a0000f 	mov	r0, #15
  11a978:	ebfffa57 	bl	1192dc <memp_malloc_fn>
  11a97c:	e50b0008 	str	r0, [fp, #-8]
    if (p == NULL) {
  11a980:	e51b3008 	ldr	r3, [fp, #-8]
  11a984:	e3530000 	cmp	r3, #0
  11a988:	1a000001 	bne	11a994 <pbuf_alloc+0x4fc>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  11a98c:	e3a03000 	mov	r3, #0
  11a990:	ea000022 	b	11aa20 <pbuf_alloc+0x588>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  11a994:	e51b3008 	ldr	r3, [fp, #-8]
  11a998:	e3a02000 	mov	r2, #0
  11a99c:	e5832004 	str	r2, [r3, #4]
    p->len = p->tot_len = length;
  11a9a0:	e51b3008 	ldr	r3, [fp, #-8]
  11a9a4:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  11a9a8:	e1c320b8 	strh	r2, [r3, #8]
  11a9ac:	e51b3008 	ldr	r3, [fp, #-8]
  11a9b0:	e1d320b8 	ldrh	r2, [r3, #8]
  11a9b4:	e51b3008 	ldr	r3, [fp, #-8]
  11a9b8:	e1c320ba 	strh	r2, [r3, #10]
    p->next = NULL;
  11a9bc:	e51b3008 	ldr	r3, [fp, #-8]
  11a9c0:	e3a02000 	mov	r2, #0
  11a9c4:	e5832000 	str	r2, [r3]
    p->type = type;
  11a9c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11a9cc:	e6ef2073 	uxtb	r2, r3
  11a9d0:	e51b3008 	ldr	r3, [fp, #-8]
  11a9d4:	e5c3200c 	strb	r2, [r3, #12]
    break;
  11a9d8:	ea000009 	b	11aa04 <pbuf_alloc+0x56c>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  11a9dc:	e3070988 	movw	r0, #31112	; 0x7988
  11a9e0:	e3400014 	movt	r0, #20
  11a9e4:	ebffa1ca 	bl	103114 <rt_kprintf>
  11a9e8:	e300118d 	movw	r1, #397	; 0x18d
  11a9ec:	e3070854 	movw	r0, #30804	; 0x7854
  11a9f0:	e3400014 	movt	r0, #20
  11a9f4:	ebffc1a0 	bl	10b07c <sys_arch_assert>
    return NULL;
  11a9f8:	e3a03000 	mov	r3, #0
  11a9fc:	ea000007 	b	11aa20 <pbuf_alloc+0x588>
    break;
  11aa00:	e320f000 	nop	{0}
  }
  /* set reference count */
  p->ref = 1;
  11aa04:	e51b3008 	ldr	r3, [fp, #-8]
  11aa08:	e3a02001 	mov	r2, #1
  11aa0c:	e1c320be 	strh	r2, [r3, #14]
  /* set flags */
  p->flags = 0;
  11aa10:	e51b3008 	ldr	r3, [fp, #-8]
  11aa14:	e3a02000 	mov	r2, #0
  11aa18:	e5c3200d 	strb	r2, [r3, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  11aa1c:	e51b3008 	ldr	r3, [fp, #-8]
}
  11aa20:	e1a00003 	mov	r0, r3
  11aa24:	e24bd004 	sub	sp, fp, #4
  11aa28:	e8bd8800 	pop	{fp, pc}

0011aa2c <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
  11aa2c:	e92d4800 	push	{fp, lr}
  11aa30:	e28db004 	add	fp, sp, #4
  11aa34:	e24dd018 	sub	sp, sp, #24
  11aa38:	e50b0010 	str	r0, [fp, #-16]
  11aa3c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  11aa40:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  11aa44:	e1a03001 	mov	r3, r1
  11aa48:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
  11aa4c:	e51b3010 	ldr	r3, [fp, #-16]
  11aa50:	e3530004 	cmp	r3, #4
  11aa54:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  11aa58:	ea000013 	b	11aaac <pbuf_alloced_custom+0x80>
  11aa5c:	0011aa70 	.word	0x0011aa70
  11aa60:	0011aa7c 	.word	0x0011aa7c
  11aa64:	0011aa88 	.word	0x0011aa88
  11aa68:	0011aa94 	.word	0x0011aa94
  11aa6c:	0011aaa0 	.word	0x0011aaa0
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
  11aa70:	e3a03038 	mov	r3, #56	; 0x38
  11aa74:	e14b30b6 	strh	r3, [fp, #-6]
    break;
  11aa78:	ea000014 	b	11aad0 <pbuf_alloced_custom+0xa4>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
  11aa7c:	e3a03024 	mov	r3, #36	; 0x24
  11aa80:	e14b30b6 	strh	r3, [fp, #-6]
    break;
  11aa84:	ea000011 	b	11aad0 <pbuf_alloced_custom+0xa4>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
  11aa88:	e3a03010 	mov	r3, #16
  11aa8c:	e14b30b6 	strh	r3, [fp, #-6]
    break;
  11aa90:	ea00000e 	b	11aad0 <pbuf_alloced_custom+0xa4>
  case PBUF_RAW_TX:
    /* add room for encapsulating link layer headers (e.g. 802.11) */
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
  11aa94:	e3a03000 	mov	r3, #0
  11aa98:	e14b30b6 	strh	r3, [fp, #-6]
    break;
  11aa9c:	ea00000b 	b	11aad0 <pbuf_alloced_custom+0xa4>
  case PBUF_RAW:
    offset = 0;
  11aaa0:	e3a03000 	mov	r3, #0
  11aaa4:	e14b30b6 	strh	r3, [fp, #-6]
    break;
  11aaa8:	ea000008 	b	11aad0 <pbuf_alloced_custom+0xa4>
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
  11aaac:	e30709a4 	movw	r0, #31140	; 0x79a4
  11aab0:	e3400014 	movt	r0, #20
  11aab4:	ebffa196 	bl	103114 <rt_kprintf>
  11aab8:	e30011c6 	movw	r1, #454	; 0x1c6
  11aabc:	e3070854 	movw	r0, #30804	; 0x7854
  11aac0:	e3400014 	movt	r0, #20
  11aac4:	ebffc16c 	bl	10b07c <sys_arch_assert>
    return NULL;
  11aac8:	e3a03000 	mov	r3, #0
  11aacc:	ea00002c 	b	11ab84 <pbuf_alloced_custom+0x158>
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
  11aad0:	e15b30b6 	ldrh	r3, [fp, #-6]
  11aad4:	e2833003 	add	r3, r3, #3
  11aad8:	e3c32003 	bic	r2, r3, #3
  11aadc:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11aae0:	e0822003 	add	r2, r2, r3
  11aae4:	e1db30b8 	ldrh	r3, [fp, #8]
  11aae8:	e1520003 	cmp	r2, r3
  11aaec:	9a000001 	bls	11aaf8 <pbuf_alloced_custom+0xcc>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
  11aaf0:	e3a03000 	mov	r3, #0
  11aaf4:	ea000022 	b	11ab84 <pbuf_alloced_custom+0x158>
  }

  p->pbuf.next = NULL;
  11aaf8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11aafc:	e3a02000 	mov	r2, #0
  11ab00:	e5832000 	str	r2, [r3]
  if (payload_mem != NULL) {
  11ab04:	e59b3004 	ldr	r3, [fp, #4]
  11ab08:	e3530000 	cmp	r3, #0
  11ab0c:	0a000007 	beq	11ab30 <pbuf_alloced_custom+0x104>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
  11ab10:	e15b30b6 	ldrh	r3, [fp, #-6]
  11ab14:	e2833003 	add	r3, r3, #3
  11ab18:	e3c33003 	bic	r3, r3, #3
  11ab1c:	e59b2004 	ldr	r2, [fp, #4]
  11ab20:	e0822003 	add	r2, r2, r3
  11ab24:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ab28:	e5832004 	str	r2, [r3, #4]
  11ab2c:	ea000002 	b	11ab3c <pbuf_alloced_custom+0x110>
  } else {
    p->pbuf.payload = NULL;
  11ab30:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ab34:	e3a02000 	mov	r2, #0
  11ab38:	e5832004 	str	r2, [r3, #4]
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
  11ab3c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ab40:	e3a02002 	mov	r2, #2
  11ab44:	e5c3200d 	strb	r2, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
  11ab48:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ab4c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
  11ab50:	e1c320b8 	strh	r2, [r3, #8]
  11ab54:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ab58:	e1d320b8 	ldrh	r2, [r3, #8]
  11ab5c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ab60:	e1c320ba 	strh	r2, [r3, #10]
  p->pbuf.type = type;
  11ab64:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11ab68:	e6ef2073 	uxtb	r2, r3
  11ab6c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ab70:	e5c3200c 	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
  11ab74:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ab78:	e3a02001 	mov	r2, #1
  11ab7c:	e1c320be 	strh	r2, [r3, #14]
  return &p->pbuf;
  11ab80:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
}
  11ab84:	e1a00003 	mov	r0, r3
  11ab88:	e24bd004 	sub	sp, fp, #4
  11ab8c:	e8bd8800 	pop	{fp, pc}

0011ab90 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  11ab90:	e92d4800 	push	{fp, lr}
  11ab94:	e28db004 	add	fp, sp, #4
  11ab98:	e24dd018 	sub	sp, sp, #24
  11ab9c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  11aba0:	e1a03001 	mov	r3, r1
  11aba4:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  11aba8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11abac:	e3530000 	cmp	r3, #0
  11abb0:	1a000006 	bne	11abd0 <pbuf_realloc+0x40>
  11abb4:	e30709c8 	movw	r0, #31176	; 0x79c8
  11abb8:	e3400014 	movt	r0, #20
  11abbc:	ebffa154 	bl	103114 <rt_kprintf>
  11abc0:	e3a01f7d 	mov	r1, #500	; 0x1f4
  11abc4:	e3070854 	movw	r0, #30804	; 0x7854
  11abc8:	e3400014 	movt	r0, #20
  11abcc:	ebffc12a 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  11abd0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11abd4:	e5d3300c 	ldrb	r3, [r3, #12]
  11abd8:	e3530003 	cmp	r3, #3
  11abdc:	0a000012 	beq	11ac2c <pbuf_realloc+0x9c>
  11abe0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11abe4:	e5d3300c 	ldrb	r3, [r3, #12]
  11abe8:	e3530001 	cmp	r3, #1
  11abec:	0a00000e 	beq	11ac2c <pbuf_realloc+0x9c>
  11abf0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11abf4:	e5d3300c 	ldrb	r3, [r3, #12]
  11abf8:	e3530000 	cmp	r3, #0
  11abfc:	0a00000a 	beq	11ac2c <pbuf_realloc+0x9c>
  11ac00:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11ac04:	e5d3300c 	ldrb	r3, [r3, #12]
  11ac08:	e3530002 	cmp	r3, #2
  11ac0c:	0a000006 	beq	11ac2c <pbuf_realloc+0x9c>
  11ac10:	e30709e0 	movw	r0, #31200	; 0x79e0
  11ac14:	e3400014 	movt	r0, #20
  11ac18:	ebffa13d 	bl	103114 <rt_kprintf>
  11ac1c:	e3a01f7e 	mov	r1, #504	; 0x1f8
  11ac20:	e3070854 	movw	r0, #30804	; 0x7854
  11ac24:	e3400014 	movt	r0, #20
  11ac28:	ebffc113 	bl	10b07c <sys_arch_assert>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  11ac2c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11ac30:	e1d330b8 	ldrh	r3, [r3, #8]
  11ac34:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
  11ac38:	e1520003 	cmp	r2, r3
  11ac3c:	2a00006b 	bcs	11adf0 <pbuf_realloc+0x260>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  11ac40:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  11ac44:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  11ac48:	e1d220b8 	ldrh	r2, [r2, #8]
  11ac4c:	e0433002 	sub	r3, r3, r2
  11ac50:	e50b3010 	str	r3, [fp, #-16]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  11ac54:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  11ac58:	e14b30ba 	strh	r3, [fp, #-10]
  q = p;
  11ac5c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11ac60:	e50b3008 	str	r3, [fp, #-8]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  11ac64:	ea000024 	b	11acfc <pbuf_realloc+0x16c>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  11ac68:	e51b3008 	ldr	r3, [fp, #-8]
  11ac6c:	e1d330ba 	ldrh	r3, [r3, #10]
  11ac70:	e15b20ba 	ldrh	r2, [fp, #-10]
  11ac74:	e0423003 	sub	r3, r2, r3
  11ac78:	e14b30ba 	strh	r3, [fp, #-10]
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  11ac7c:	e51b3010 	ldr	r3, [fp, #-16]
  11ac80:	e30f2ffe 	movw	r2, #65534	; 0xfffe
  11ac84:	e1530002 	cmp	r3, r2
  11ac88:	da000006 	ble	11aca8 <pbuf_realloc+0x118>
  11ac8c:	e30709fc 	movw	r0, #31228	; 0x79fc
  11ac90:	e3400014 	movt	r0, #20
  11ac94:	ebffa11e 	bl	103114 <rt_kprintf>
  11ac98:	e3a01f83 	mov	r1, #524	; 0x20c
  11ac9c:	e3070854 	movw	r0, #30804	; 0x7854
  11aca0:	e3400014 	movt	r0, #20
  11aca4:	ebffc0f4 	bl	10b07c <sys_arch_assert>
    q->tot_len += (u16_t)grow;
  11aca8:	e51b3008 	ldr	r3, [fp, #-8]
  11acac:	e1d320b8 	ldrh	r2, [r3, #8]
  11acb0:	e51b3010 	ldr	r3, [fp, #-16]
  11acb4:	e6ff3073 	uxth	r3, r3
  11acb8:	e0823003 	add	r3, r2, r3
  11acbc:	e6ff2073 	uxth	r2, r3
  11acc0:	e51b3008 	ldr	r3, [fp, #-8]
  11acc4:	e1c320b8 	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
  11acc8:	e51b3008 	ldr	r3, [fp, #-8]
  11accc:	e5933000 	ldr	r3, [r3]
  11acd0:	e50b3008 	str	r3, [fp, #-8]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  11acd4:	e51b3008 	ldr	r3, [fp, #-8]
  11acd8:	e3530000 	cmp	r3, #0
  11acdc:	1a000006 	bne	11acfc <pbuf_realloc+0x16c>
  11ace0:	e3070a10 	movw	r0, #31248	; 0x7a10
  11ace4:	e3400014 	movt	r0, #20
  11ace8:	ebffa109 	bl	103114 <rt_kprintf>
  11acec:	e3a01e21 	mov	r1, #528	; 0x210
  11acf0:	e3070854 	movw	r0, #30804	; 0x7854
  11acf4:	e3400014 	movt	r0, #20
  11acf8:	ebffc0df 	bl	10b07c <sys_arch_assert>
  while (rem_len > q->len) {
  11acfc:	e51b3008 	ldr	r3, [fp, #-8]
  11ad00:	e1d330ba 	ldrh	r3, [r3, #10]
  11ad04:	e15b20ba 	ldrh	r2, [fp, #-10]
  11ad08:	e1520003 	cmp	r2, r3
  11ad0c:	8affffd5 	bhi	11ac68 <pbuf_realloc+0xd8>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)
  11ad10:	e51b3008 	ldr	r3, [fp, #-8]
  11ad14:	e5d3300c 	ldrb	r3, [r3, #12]
  11ad18:	e3530000 	cmp	r3, #0
  11ad1c:	1a000020 	bne	11ada4 <pbuf_realloc+0x214>
  11ad20:	e51b3008 	ldr	r3, [fp, #-8]
  11ad24:	e1d330ba 	ldrh	r3, [r3, #10]
  11ad28:	e15b20ba 	ldrh	r2, [fp, #-10]
  11ad2c:	e1520003 	cmp	r2, r3
  11ad30:	0a00001b 	beq	11ada4 <pbuf_realloc+0x214>
#if LWIP_SUPPORT_CUSTOM_PBUF
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
  11ad34:	e51b3008 	ldr	r3, [fp, #-8]
  11ad38:	e5d3300d 	ldrb	r3, [r3, #13]
  11ad3c:	e2033002 	and	r3, r3, #2
  11ad40:	e3530000 	cmp	r3, #0
  11ad44:	1a000016 	bne	11ada4 <pbuf_realloc+0x214>
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
     ) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
  11ad48:	e51b3008 	ldr	r3, [fp, #-8]
  11ad4c:	e5933004 	ldr	r3, [r3, #4]
  11ad50:	e1a02003 	mov	r2, r3
  11ad54:	e51b3008 	ldr	r3, [fp, #-8]
  11ad58:	e0423003 	sub	r3, r2, r3
  11ad5c:	e6ff2073 	uxth	r2, r3
  11ad60:	e15b30ba 	ldrh	r3, [fp, #-10]
  11ad64:	e0823003 	add	r3, r2, r3
  11ad68:	e6ff3073 	uxth	r3, r3
  11ad6c:	e1a01003 	mov	r1, r3
  11ad70:	e51b0008 	ldr	r0, [fp, #-8]
  11ad74:	ebffc0f6 	bl	10b154 <mem_trim>
  11ad78:	e50b0008 	str	r0, [fp, #-8]
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  11ad7c:	e51b3008 	ldr	r3, [fp, #-8]
  11ad80:	e3530000 	cmp	r3, #0
  11ad84:	1a000006 	bne	11ada4 <pbuf_realloc+0x214>
  11ad88:	e3070a28 	movw	r0, #31272	; 0x7a28
  11ad8c:	e3400014 	movt	r0, #20
  11ad90:	ebffa0df 	bl	103114 <rt_kprintf>
  11ad94:	e300121e 	movw	r1, #542	; 0x21e
  11ad98:	e3070854 	movw	r0, #30804	; 0x7854
  11ad9c:	e3400014 	movt	r0, #20
  11ada0:	ebffc0b5 	bl	10b07c <sys_arch_assert>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  11ada4:	e51b3008 	ldr	r3, [fp, #-8]
  11ada8:	e15b20ba 	ldrh	r2, [fp, #-10]
  11adac:	e1c320ba 	strh	r2, [r3, #10]
  q->tot_len = q->len;
  11adb0:	e51b3008 	ldr	r3, [fp, #-8]
  11adb4:	e1d320ba 	ldrh	r2, [r3, #10]
  11adb8:	e51b3008 	ldr	r3, [fp, #-8]
  11adbc:	e1c320b8 	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  11adc0:	e51b3008 	ldr	r3, [fp, #-8]
  11adc4:	e5933000 	ldr	r3, [r3]
  11adc8:	e3530000 	cmp	r3, #0
  11adcc:	0a000003 	beq	11ade0 <pbuf_realloc+0x250>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  11add0:	e51b3008 	ldr	r3, [fp, #-8]
  11add4:	e5933000 	ldr	r3, [r3]
  11add8:	e1a00003 	mov	r0, r3
  11addc:	eb0000b4 	bl	11b0b4 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  11ade0:	e51b3008 	ldr	r3, [fp, #-8]
  11ade4:	e3a02000 	mov	r2, #0
  11ade8:	e5832000 	str	r2, [r3]
  11adec:	ea000000 	b	11adf4 <pbuf_realloc+0x264>
    return;
  11adf0:	e320f000 	nop	{0}

}
  11adf4:	e24bd004 	sub	sp, fp, #4
  11adf8:	e8bd8800 	pop	{fp, pc}

0011adfc <pbuf_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
  11adfc:	e92d4800 	push	{fp, lr}
  11ae00:	e28db004 	add	fp, sp, #4
  11ae04:	e24dd010 	sub	sp, sp, #16
  11ae08:	e50b0010 	str	r0, [fp, #-16]
  11ae0c:	e1a03001 	mov	r3, r1
  11ae10:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  11ae14:	e1a03002 	mov	r3, r2
  11ae18:	e54b3013 	strb	r3, [fp, #-19]	; 0xffffffed
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  11ae1c:	e51b3010 	ldr	r3, [fp, #-16]
  11ae20:	e3530000 	cmp	r3, #0
  11ae24:	1a000006 	bne	11ae44 <pbuf_header_impl+0x48>
  11ae28:	e3070a44 	movw	r0, #31300	; 0x7a44
  11ae2c:	e3400014 	movt	r0, #20
  11ae30:	ebffa0b7 	bl	103114 <rt_kprintf>
  11ae34:	e3a01d09 	mov	r1, #576	; 0x240
  11ae38:	e3070854 	movw	r0, #30804	; 0x7854
  11ae3c:	e3400014 	movt	r0, #20
  11ae40:	ebffc08d 	bl	10b07c <sys_arch_assert>
  if ((header_size_increment == 0) || (p == NULL)) {
  11ae44:	e15b31f2 	ldrsh	r3, [fp, #-18]	; 0xffffffee
  11ae48:	e3530000 	cmp	r3, #0
  11ae4c:	0a000002 	beq	11ae5c <pbuf_header_impl+0x60>
  11ae50:	e51b3010 	ldr	r3, [fp, #-16]
  11ae54:	e3530000 	cmp	r3, #0
  11ae58:	1a000001 	bne	11ae64 <pbuf_header_impl+0x68>
    return 0;
  11ae5c:	e3a03000 	mov	r3, #0
  11ae60:	ea000072 	b	11b030 <pbuf_header_impl+0x234>
  }

  if (header_size_increment < 0) {
  11ae64:	e15b31f2 	ldrsh	r3, [fp, #-18]	; 0xffffffee
  11ae68:	e3530000 	cmp	r3, #0
  11ae6c:	aa000010 	bge	11aeb4 <pbuf_header_impl+0xb8>
    increment_magnitude = (u16_t)-header_size_increment;
  11ae70:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11ae74:	e2633000 	rsb	r3, r3, #0
  11ae78:	e14b30b6 	strh	r3, [fp, #-6]
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  11ae7c:	e51b3010 	ldr	r3, [fp, #-16]
  11ae80:	e1d330ba 	ldrh	r3, [r3, #10]
  11ae84:	e15b20b6 	ldrh	r2, [fp, #-6]
  11ae88:	e1520003 	cmp	r2, r3
  11ae8c:	9a00000a 	bls	11aebc <pbuf_header_impl+0xc0>
  11ae90:	e3070a50 	movw	r0, #31312	; 0x7a50
  11ae94:	e3400014 	movt	r0, #20
  11ae98:	ebffa09d 	bl	103114 <rt_kprintf>
  11ae9c:	e3a01f92 	mov	r1, #584	; 0x248
  11aea0:	e3070854 	movw	r0, #30804	; 0x7854
  11aea4:	e3400014 	movt	r0, #20
  11aea8:	ebffc073 	bl	10b07c <sys_arch_assert>
  11aeac:	e3a03001 	mov	r3, #1
  11aeb0:	ea00005e 	b	11b030 <pbuf_header_impl+0x234>
  } else {
    increment_magnitude = (u16_t)header_size_increment;
  11aeb4:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11aeb8:	e14b30b6 	strh	r3, [fp, #-6]
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  11aebc:	e51b3010 	ldr	r3, [fp, #-16]
  11aec0:	e5d3300c 	ldrb	r3, [r3, #12]
  11aec4:	e14b30b8 	strh	r3, [fp, #-8]
  /* remember current payload pointer */
  payload = p->payload;
  11aec8:	e51b3010 	ldr	r3, [fp, #-16]
  11aecc:	e5933004 	ldr	r3, [r3, #4]
  11aed0:	e50b300c 	str	r3, [fp, #-12]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  11aed4:	e15b30b8 	ldrh	r3, [fp, #-8]
  11aed8:	e3530000 	cmp	r3, #0
  11aedc:	0a000002 	beq	11aeec <pbuf_header_impl+0xf0>
  11aee0:	e15b30b8 	ldrh	r3, [fp, #-8]
  11aee4:	e3530003 	cmp	r3, #3
  11aee8:	1a000011 	bne	11af34 <pbuf_header_impl+0x138>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  11aeec:	e51b3010 	ldr	r3, [fp, #-16]
  11aef0:	e5932004 	ldr	r2, [r3, #4]
  11aef4:	e15b31f2 	ldrsh	r3, [fp, #-18]	; 0xffffffee
  11aef8:	e2633000 	rsb	r3, r3, #0
  11aefc:	e0822003 	add	r2, r2, r3
  11af00:	e51b3010 	ldr	r3, [fp, #-16]
  11af04:	e5832004 	str	r2, [r3, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  11af08:	e51b3010 	ldr	r3, [fp, #-16]
  11af0c:	e5932004 	ldr	r2, [r3, #4]
  11af10:	e51b3010 	ldr	r3, [fp, #-16]
  11af14:	e2833010 	add	r3, r3, #16
  11af18:	e1520003 	cmp	r2, r3
  11af1c:	2a000034 	bcs	11aff4 <pbuf_header_impl+0x1f8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
      /* restore old payload pointer */
      p->payload = payload;
  11af20:	e51b3010 	ldr	r3, [fp, #-16]
  11af24:	e51b200c 	ldr	r2, [fp, #-12]
  11af28:	e5832004 	str	r2, [r3, #4]
      /* bail out unsuccessfully */
      return 1;
  11af2c:	e3a03001 	mov	r3, #1
  11af30:	ea00003e 	b	11b030 <pbuf_header_impl+0x234>
    }
  /* pbuf types referring to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  11af34:	e15b30b8 	ldrh	r3, [fp, #-8]
  11af38:	e3530002 	cmp	r3, #2
  11af3c:	0a000002 	beq	11af4c <pbuf_header_impl+0x150>
  11af40:	e15b30b8 	ldrh	r3, [fp, #-8]
  11af44:	e3530001 	cmp	r3, #1
  11af48:	1a000020 	bne	11afd0 <pbuf_header_impl+0x1d4>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  11af4c:	e15b31f2 	ldrsh	r3, [fp, #-18]	; 0xffffffee
  11af50:	e3530000 	cmp	r3, #0
  11af54:	aa00000c 	bge	11af8c <pbuf_header_impl+0x190>
  11af58:	e51b3010 	ldr	r3, [fp, #-16]
  11af5c:	e1d330ba 	ldrh	r3, [r3, #10]
  11af60:	e15b20b6 	ldrh	r2, [fp, #-6]
  11af64:	e1520003 	cmp	r2, r3
  11af68:	8a000007 	bhi	11af8c <pbuf_header_impl+0x190>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  11af6c:	e51b3010 	ldr	r3, [fp, #-16]
  11af70:	e5932004 	ldr	r2, [r3, #4]
  11af74:	e15b31f2 	ldrsh	r3, [fp, #-18]	; 0xffffffee
  11af78:	e2633000 	rsb	r3, r3, #0
  11af7c:	e0822003 	add	r2, r2, r3
  11af80:	e51b3010 	ldr	r3, [fp, #-16]
  11af84:	e5832004 	str	r2, [r3, #4]
  11af88:	ea00000f 	b	11afcc <pbuf_header_impl+0x1d0>
    } else if ((header_size_increment > 0) && force) {
  11af8c:	e15b31f2 	ldrsh	r3, [fp, #-18]	; 0xffffffee
  11af90:	e3530000 	cmp	r3, #0
  11af94:	da00000a 	ble	11afc4 <pbuf_header_impl+0x1c8>
  11af98:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
  11af9c:	e3530000 	cmp	r3, #0
  11afa0:	0a000007 	beq	11afc4 <pbuf_header_impl+0x1c8>
      p->payload = (u8_t *)p->payload - header_size_increment;
  11afa4:	e51b3010 	ldr	r3, [fp, #-16]
  11afa8:	e5932004 	ldr	r2, [r3, #4]
  11afac:	e15b31f2 	ldrsh	r3, [fp, #-18]	; 0xffffffee
  11afb0:	e2633000 	rsb	r3, r3, #0
  11afb4:	e0822003 	add	r2, r2, r3
  11afb8:	e51b3010 	ldr	r3, [fp, #-16]
  11afbc:	e5832004 	str	r2, [r3, #4]
  11afc0:	ea000001 	b	11afcc <pbuf_header_impl+0x1d0>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccessfully */
      return 1;
  11afc4:	e3a03001 	mov	r3, #1
  11afc8:	ea000018 	b	11b030 <pbuf_header_impl+0x234>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  11afcc:	ea000008 	b	11aff4 <pbuf_header_impl+0x1f8>
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  11afd0:	e3070a70 	movw	r0, #31344	; 0x7a70
  11afd4:	e3400014 	movt	r0, #20
  11afd8:	ebffa04d 	bl	103114 <rt_kprintf>
  11afdc:	e3a01f9e 	mov	r1, #632	; 0x278
  11afe0:	e3070854 	movw	r0, #30804	; 0x7854
  11afe4:	e3400014 	movt	r0, #20
  11afe8:	ebffc023 	bl	10b07c <sys_arch_assert>
    return 1;
  11afec:	e3a03001 	mov	r3, #1
  11aff0:	ea00000e 	b	11b030 <pbuf_header_impl+0x234>
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  11aff4:	e51b3010 	ldr	r3, [fp, #-16]
  11aff8:	e1d320ba 	ldrh	r2, [r3, #10]
  11affc:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11b000:	e0823003 	add	r3, r2, r3
  11b004:	e6ff2073 	uxth	r2, r3
  11b008:	e51b3010 	ldr	r3, [fp, #-16]
  11b00c:	e1c320ba 	strh	r2, [r3, #10]
  p->tot_len += header_size_increment;
  11b010:	e51b3010 	ldr	r3, [fp, #-16]
  11b014:	e1d320b8 	ldrh	r2, [r3, #8]
  11b018:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11b01c:	e0823003 	add	r3, r2, r3
  11b020:	e6ff2073 	uxth	r2, r3
  11b024:	e51b3010 	ldr	r3, [fp, #-16]
  11b028:	e1c320b8 	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  11b02c:	e3a03000 	mov	r3, #0
}
  11b030:	e1a00003 	mov	r0, r3
  11b034:	e24bd004 	sub	sp, fp, #4
  11b038:	e8bd8800 	pop	{fp, pc}

0011b03c <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  11b03c:	e92d4800 	push	{fp, lr}
  11b040:	e28db004 	add	fp, sp, #4
  11b044:	e24dd008 	sub	sp, sp, #8
  11b048:	e50b0008 	str	r0, [fp, #-8]
  11b04c:	e1a03001 	mov	r3, r1
  11b050:	e14b30ba 	strh	r3, [fp, #-10]
   return pbuf_header_impl(p, header_size_increment, 0);
  11b054:	e15b30fa 	ldrsh	r3, [fp, #-10]
  11b058:	e3a02000 	mov	r2, #0
  11b05c:	e1a01003 	mov	r1, r3
  11b060:	e51b0008 	ldr	r0, [fp, #-8]
  11b064:	ebffff64 	bl	11adfc <pbuf_header_impl>
  11b068:	e1a03000 	mov	r3, r0
}
  11b06c:	e1a00003 	mov	r0, r3
  11b070:	e24bd004 	sub	sp, fp, #4
  11b074:	e8bd8800 	pop	{fp, pc}

0011b078 <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
  11b078:	e92d4800 	push	{fp, lr}
  11b07c:	e28db004 	add	fp, sp, #4
  11b080:	e24dd008 	sub	sp, sp, #8
  11b084:	e50b0008 	str	r0, [fp, #-8]
  11b088:	e1a03001 	mov	r3, r1
  11b08c:	e14b30ba 	strh	r3, [fp, #-10]
   return pbuf_header_impl(p, header_size_increment, 1);
  11b090:	e15b30fa 	ldrsh	r3, [fp, #-10]
  11b094:	e3a02001 	mov	r2, #1
  11b098:	e1a01003 	mov	r1, r3
  11b09c:	e51b0008 	ldr	r0, [fp, #-8]
  11b0a0:	ebffff55 	bl	11adfc <pbuf_header_impl>
  11b0a4:	e1a03000 	mov	r3, r0
}
  11b0a8:	e1a00003 	mov	r0, r3
  11b0ac:	e24bd004 	sub	sp, fp, #4
  11b0b0:	e8bd8800 	pop	{fp, pc}

0011b0b4 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  11b0b4:	e92d4800 	push	{fp, lr}
  11b0b8:	e28db004 	add	fp, sp, #4
  11b0bc:	e24dd018 	sub	sp, sp, #24
  11b0c0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  11b0c4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b0c8:	e3530000 	cmp	r3, #0
  11b0cc:	1a00000b 	bne	11b100 <pbuf_free+0x4c>
    LWIP_ASSERT("p != NULL", p != NULL);
  11b0d0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b0d4:	e3530000 	cmp	r3, #0
  11b0d8:	1a000006 	bne	11b0f8 <pbuf_free+0x44>
  11b0dc:	e3070a44 	movw	r0, #31300	; 0x7a44
  11b0e0:	e3400014 	movt	r0, #20
  11b0e4:	ebffa00a 	bl	103114 <rt_kprintf>
  11b0e8:	e30012d3 	movw	r1, #723	; 0x2d3
  11b0ec:	e3070854 	movw	r0, #30804	; 0x7854
  11b0f0:	e3400014 	movt	r0, #20
  11b0f4:	ebffbfe0 	bl	10b07c <sys_arch_assert>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  11b0f8:	e3a03000 	mov	r3, #0
  11b0fc:	ea00006e 	b	11b2bc <pbuf_free+0x208>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  11b100:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b104:	e5d3300c 	ldrb	r3, [r3, #12]
  11b108:	e3530000 	cmp	r3, #0
  11b10c:	0a000012 	beq	11b15c <pbuf_free+0xa8>
  11b110:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b114:	e5d3300c 	ldrb	r3, [r3, #12]
  11b118:	e3530001 	cmp	r3, #1
  11b11c:	0a00000e 	beq	11b15c <pbuf_free+0xa8>
  11b120:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b124:	e5d3300c 	ldrb	r3, [r3, #12]
  11b128:	e3530002 	cmp	r3, #2
  11b12c:	0a00000a 	beq	11b15c <pbuf_free+0xa8>
  11b130:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b134:	e5d3300c 	ldrb	r3, [r3, #12]
  11b138:	e3530003 	cmp	r3, #3
  11b13c:	0a000006 	beq	11b15c <pbuf_free+0xa8>
  11b140:	e3070a80 	movw	r0, #31360	; 0x7a80
  11b144:	e3400014 	movt	r0, #20
  11b148:	ebff9ff1 	bl	103114 <rt_kprintf>
  11b14c:	e30012df 	movw	r1, #735	; 0x2df
  11b150:	e3070854 	movw	r0, #30804	; 0x7854
  11b154:	e3400014 	movt	r0, #20
  11b158:	ebffbfc7 	bl	10b07c <sys_arch_assert>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  11b15c:	e3a03000 	mov	r3, #0
  11b160:	e54b3005 	strb	r3, [fp, #-5]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  11b164:	ea000050 	b	11b2ac <pbuf_free+0x1f8>
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
  11b168:	ebff9c33 	bl	10223c <rt_enter_critical>
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  11b16c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b170:	e1d330be 	ldrh	r3, [r3, #14]
  11b174:	e3530000 	cmp	r3, #0
  11b178:	1a000006 	bne	11b198 <pbuf_free+0xe4>
  11b17c:	e3070a98 	movw	r0, #31384	; 0x7a98
  11b180:	e3400014 	movt	r0, #20
  11b184:	ebff9fe2 	bl	103114 <rt_kprintf>
  11b188:	e3a01fbb 	mov	r1, #748	; 0x2ec
  11b18c:	e3070854 	movw	r0, #30804	; 0x7854
  11b190:	e3400014 	movt	r0, #20
  11b194:	ebffbfb8 	bl	10b07c <sys_arch_assert>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  11b198:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b19c:	e1d330be 	ldrh	r3, [r3, #14]
  11b1a0:	e2433001 	sub	r3, r3, #1
  11b1a4:	e6ff2073 	uxth	r2, r3
  11b1a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b1ac:	e1c320be 	strh	r2, [r3, #14]
  11b1b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b1b4:	e1d330be 	ldrh	r3, [r3, #14]
  11b1b8:	e14b30b8 	strh	r3, [fp, #-8]
    SYS_ARCH_UNPROTECT(old_level);
  11b1bc:	ebff9c24 	bl	102254 <rt_exit_critical>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  11b1c0:	e15b30b8 	ldrh	r3, [fp, #-8]
  11b1c4:	e3530000 	cmp	r3, #0
  11b1c8:	1a000035 	bne	11b2a4 <pbuf_free+0x1f0>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  11b1cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b1d0:	e5933000 	ldr	r3, [r3]
  11b1d4:	e50b300c 	str	r3, [fp, #-12]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  11b1d8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b1dc:	e5d3300c 	ldrb	r3, [r3, #12]
  11b1e0:	e14b30be 	strh	r3, [fp, #-14]
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
  11b1e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b1e8:	e5d3300d 	ldrb	r3, [r3, #13]
  11b1ec:	e2033002 	and	r3, r3, #2
  11b1f0:	e3530000 	cmp	r3, #0
  11b1f4:	0a000011 	beq	11b240 <pbuf_free+0x18c>
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
  11b1f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b1fc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
  11b200:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b204:	e5933010 	ldr	r3, [r3, #16]
  11b208:	e3530000 	cmp	r3, #0
  11b20c:	1a000006 	bne	11b22c <pbuf_free+0x178>
  11b210:	e3070ab0 	movw	r0, #31408	; 0x7ab0
  11b214:	e3400014 	movt	r0, #20
  11b218:	ebff9fbd 	bl	103114 <rt_kprintf>
  11b21c:	e30012fa 	movw	r1, #762	; 0x2fa
  11b220:	e3070854 	movw	r0, #30804	; 0x7854
  11b224:	e3400014 	movt	r0, #20
  11b228:	ebffbf93 	bl	10b07c <sys_arch_assert>
        pc->custom_free_function(p);
  11b22c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b230:	e5933010 	ldr	r3, [r3, #16]
  11b234:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  11b238:	e12fff33 	blx	r3
  11b23c:	ea000012 	b	11b28c <pbuf_free+0x1d8>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
  11b240:	e15b30be 	ldrh	r3, [fp, #-14]
  11b244:	e3530003 	cmp	r3, #3
  11b248:	1a000003 	bne	11b25c <pbuf_free+0x1a8>
          memp_free(MEMP_PBUF_POOL, p);
  11b24c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  11b250:	e3a00010 	mov	r0, #16
  11b254:	ebfff888 	bl	11947c <memp_free>
  11b258:	ea00000b 	b	11b28c <pbuf_free+0x1d8>
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
  11b25c:	e15b30be 	ldrh	r3, [fp, #-14]
  11b260:	e3530001 	cmp	r3, #1
  11b264:	0a000002 	beq	11b274 <pbuf_free+0x1c0>
  11b268:	e15b30be 	ldrh	r3, [fp, #-14]
  11b26c:	e3530002 	cmp	r3, #2
  11b270:	1a000003 	bne	11b284 <pbuf_free+0x1d0>
          memp_free(MEMP_PBUF, p);
  11b274:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  11b278:	e3a0000f 	mov	r0, #15
  11b27c:	ebfff87e 	bl	11947c <memp_free>
  11b280:	ea000001 	b	11b28c <pbuf_free+0x1d8>
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
  11b284:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  11b288:	ebffbfc8 	bl	10b1b0 <mem_free>
        }
      }
      count++;
  11b28c:	e55b3005 	ldrb	r3, [fp, #-5]
  11b290:	e2833001 	add	r3, r3, #1
  11b294:	e54b3005 	strb	r3, [fp, #-5]
      /* proceed to next pbuf */
      p = q;
  11b298:	e51b300c 	ldr	r3, [fp, #-12]
  11b29c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  11b2a0:	ea000001 	b	11b2ac <pbuf_free+0x1f8>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  11b2a4:	e3a03000 	mov	r3, #0
  11b2a8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  while (p != NULL) {
  11b2ac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b2b0:	e3530000 	cmp	r3, #0
  11b2b4:	1affffab 	bne	11b168 <pbuf_free+0xb4>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  11b2b8:	e55b3005 	ldrb	r3, [fp, #-5]
}
  11b2bc:	e1a00003 	mov	r0, r3
  11b2c0:	e24bd004 	sub	sp, fp, #4
  11b2c4:	e8bd8800 	pop	{fp, pc}

0011b2c8 <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
  11b2c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11b2cc:	e28db000 	add	fp, sp, #0
  11b2d0:	e24dd014 	sub	sp, sp, #20
  11b2d4:	e50b0010 	str	r0, [fp, #-16]
  u16_t len;

  len = 0;
  11b2d8:	e3a03000 	mov	r3, #0
  11b2dc:	e14b30b6 	strh	r3, [fp, #-6]
  while (p != NULL) {
  11b2e0:	ea000005 	b	11b2fc <pbuf_clen+0x34>
    ++len;
  11b2e4:	e15b30b6 	ldrh	r3, [fp, #-6]
  11b2e8:	e2833001 	add	r3, r3, #1
  11b2ec:	e14b30b6 	strh	r3, [fp, #-6]
    p = p->next;
  11b2f0:	e51b3010 	ldr	r3, [fp, #-16]
  11b2f4:	e5933000 	ldr	r3, [r3]
  11b2f8:	e50b3010 	str	r3, [fp, #-16]
  while (p != NULL) {
  11b2fc:	e51b3010 	ldr	r3, [fp, #-16]
  11b300:	e3530000 	cmp	r3, #0
  11b304:	1afffff6 	bne	11b2e4 <pbuf_clen+0x1c>
  }
  return len;
  11b308:	e15b30b6 	ldrh	r3, [fp, #-6]
}
  11b30c:	e1a00003 	mov	r0, r3
  11b310:	e28bd000 	add	sp, fp, #0
  11b314:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11b318:	e12fff1e 	bx	lr

0011b31c <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  11b31c:	e92d4800 	push	{fp, lr}
  11b320:	e28db004 	add	fp, sp, #4
  11b324:	e24dd008 	sub	sp, sp, #8
  11b328:	e50b0008 	str	r0, [fp, #-8]
  /* pbuf given? */
  if (p != NULL) {
  11b32c:	e51b3008 	ldr	r3, [fp, #-8]
  11b330:	e3530000 	cmp	r3, #0
  11b334:	0a000012 	beq	11b384 <pbuf_ref+0x68>
    SYS_ARCH_INC(p->ref, 1);
  11b338:	ebff9bbf 	bl	10223c <rt_enter_critical>
  11b33c:	e51b3008 	ldr	r3, [fp, #-8]
  11b340:	e1d330be 	ldrh	r3, [r3, #14]
  11b344:	e2833001 	add	r3, r3, #1
  11b348:	e6ff2073 	uxth	r2, r3
  11b34c:	e51b3008 	ldr	r3, [fp, #-8]
  11b350:	e1c320be 	strh	r2, [r3, #14]
  11b354:	ebff9bbe 	bl	102254 <rt_exit_critical>
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
  11b358:	e51b3008 	ldr	r3, [fp, #-8]
  11b35c:	e1d330be 	ldrh	r3, [r3, #14]
  11b360:	e3530000 	cmp	r3, #0
  11b364:	1a000006 	bne	11b384 <pbuf_ref+0x68>
  11b368:	e3070ad4 	movw	r0, #31444	; 0x7ad4
  11b36c:	e3400014 	movt	r0, #20
  11b370:	ebff9f67 	bl	103114 <rt_kprintf>
  11b374:	e300133a 	movw	r1, #826	; 0x33a
  11b378:	e3070854 	movw	r0, #30804	; 0x7854
  11b37c:	e3400014 	movt	r0, #20
  11b380:	ebffbf3d 	bl	10b07c <sys_arch_assert>
  }
}
  11b384:	e320f000 	nop	{0}
  11b388:	e24bd004 	sub	sp, fp, #4
  11b38c:	e8bd8800 	pop	{fp, pc}

0011b390 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  11b390:	e92d4800 	push	{fp, lr}
  11b394:	e28db004 	add	fp, sp, #4
  11b398:	e24dd010 	sub	sp, sp, #16
  11b39c:	e50b0010 	str	r0, [fp, #-16]
  11b3a0:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  11b3a4:	e51b3010 	ldr	r3, [fp, #-16]
  11b3a8:	e3530000 	cmp	r3, #0
  11b3ac:	0a000002 	beq	11b3bc <pbuf_cat+0x2c>
  11b3b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b3b4:	e3530000 	cmp	r3, #0
  11b3b8:	1a000007 	bne	11b3dc <pbuf_cat+0x4c>
  11b3bc:	e3070ae8 	movw	r0, #31464	; 0x7ae8
  11b3c0:	e3400014 	movt	r0, #20
  11b3c4:	ebff9f52 	bl	103114 <rt_kprintf>
  11b3c8:	e300134e 	movw	r1, #846	; 0x34e
  11b3cc:	e3070854 	movw	r0, #30804	; 0x7854
  11b3d0:	e3400014 	movt	r0, #20
  11b3d4:	ebffbf28 	bl	10b07c <sys_arch_assert>
  11b3d8:	ea000034 	b	11b4b0 <pbuf_cat+0x120>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  11b3dc:	e51b3010 	ldr	r3, [fp, #-16]
  11b3e0:	e50b3008 	str	r3, [fp, #-8]
  11b3e4:	ea00000a 	b	11b414 <pbuf_cat+0x84>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  11b3e8:	e51b3008 	ldr	r3, [fp, #-8]
  11b3ec:	e1d320b8 	ldrh	r2, [r3, #8]
  11b3f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b3f4:	e1d330b8 	ldrh	r3, [r3, #8]
  11b3f8:	e0823003 	add	r3, r2, r3
  11b3fc:	e6ff2073 	uxth	r2, r3
  11b400:	e51b3008 	ldr	r3, [fp, #-8]
  11b404:	e1c320b8 	strh	r2, [r3, #8]
  for (p = h; p->next != NULL; p = p->next) {
  11b408:	e51b3008 	ldr	r3, [fp, #-8]
  11b40c:	e5933000 	ldr	r3, [r3]
  11b410:	e50b3008 	str	r3, [fp, #-8]
  11b414:	e51b3008 	ldr	r3, [fp, #-8]
  11b418:	e5933000 	ldr	r3, [r3]
  11b41c:	e3530000 	cmp	r3, #0
  11b420:	1afffff0 	bne	11b3e8 <pbuf_cat+0x58>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  11b424:	e51b3008 	ldr	r3, [fp, #-8]
  11b428:	e1d320b8 	ldrh	r2, [r3, #8]
  11b42c:	e51b3008 	ldr	r3, [fp, #-8]
  11b430:	e1d330ba 	ldrh	r3, [r3, #10]
  11b434:	e1520003 	cmp	r2, r3
  11b438:	0a000006 	beq	11b458 <pbuf_cat+0xc8>
  11b43c:	e3070b20 	movw	r0, #31520	; 0x7b20
  11b440:	e3400014 	movt	r0, #20
  11b444:	ebff9f32 	bl	103114 <rt_kprintf>
  11b448:	e3001356 	movw	r1, #854	; 0x356
  11b44c:	e3070854 	movw	r0, #30804	; 0x7854
  11b450:	e3400014 	movt	r0, #20
  11b454:	ebffbf08 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  11b458:	e51b3008 	ldr	r3, [fp, #-8]
  11b45c:	e5933000 	ldr	r3, [r3]
  11b460:	e3530000 	cmp	r3, #0
  11b464:	0a000006 	beq	11b484 <pbuf_cat+0xf4>
  11b468:	e3070b50 	movw	r0, #31568	; 0x7b50
  11b46c:	e3400014 	movt	r0, #20
  11b470:	ebff9f27 	bl	103114 <rt_kprintf>
  11b474:	e3001357 	movw	r1, #855	; 0x357
  11b478:	e3070854 	movw	r0, #30804	; 0x7854
  11b47c:	e3400014 	movt	r0, #20
  11b480:	ebffbefd 	bl	10b07c <sys_arch_assert>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  11b484:	e51b3008 	ldr	r3, [fp, #-8]
  11b488:	e1d320b8 	ldrh	r2, [r3, #8]
  11b48c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b490:	e1d330b8 	ldrh	r3, [r3, #8]
  11b494:	e0823003 	add	r3, r2, r3
  11b498:	e6ff2073 	uxth	r2, r3
  11b49c:	e51b3008 	ldr	r3, [fp, #-8]
  11b4a0:	e1c320b8 	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  11b4a4:	e51b3008 	ldr	r3, [fp, #-8]
  11b4a8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  11b4ac:	e5832000 	str	r2, [r3]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  11b4b0:	e24bd004 	sub	sp, fp, #4
  11b4b4:	e8bd8800 	pop	{fp, pc}

0011b4b8 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  11b4b8:	e92d4800 	push	{fp, lr}
  11b4bc:	e28db004 	add	fp, sp, #4
  11b4c0:	e24dd008 	sub	sp, sp, #8
  11b4c4:	e50b0008 	str	r0, [fp, #-8]
  11b4c8:	e50b100c 	str	r1, [fp, #-12]
  pbuf_cat(h, t);
  11b4cc:	e51b100c 	ldr	r1, [fp, #-12]
  11b4d0:	e51b0008 	ldr	r0, [fp, #-8]
  11b4d4:	ebffffad 	bl	11b390 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  11b4d8:	e51b000c 	ldr	r0, [fp, #-12]
  11b4dc:	ebffff8e 	bl	11b31c <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  11b4e0:	e320f000 	nop	{0}
  11b4e4:	e24bd004 	sub	sp, fp, #4
  11b4e8:	e8bd8800 	pop	{fp, pc}

0011b4ec <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  11b4ec:	e92d4800 	push	{fp, lr}
  11b4f0:	e28db004 	add	fp, sp, #4
  11b4f4:	e24dd010 	sub	sp, sp, #16
  11b4f8:	e50b0010 	str	r0, [fp, #-16]
  struct pbuf *q;
  u8_t tail_gone = 1;
  11b4fc:	e3a03001 	mov	r3, #1
  11b500:	e54b3005 	strb	r3, [fp, #-5]
  /* tail */
  q = p->next;
  11b504:	e51b3010 	ldr	r3, [fp, #-16]
  11b508:	e5933000 	ldr	r3, [r3]
  11b50c:	e50b300c 	str	r3, [fp, #-12]
  /* pbuf has successor in chain? */
  if (q != NULL) {
  11b510:	e51b300c 	ldr	r3, [fp, #-12]
  11b514:	e3530000 	cmp	r3, #0
  11b518:	0a000024 	beq	11b5b0 <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  11b51c:	e51b300c 	ldr	r3, [fp, #-12]
  11b520:	e1d330b8 	ldrh	r3, [r3, #8]
  11b524:	e1a02003 	mov	r2, r3
  11b528:	e51b3010 	ldr	r3, [fp, #-16]
  11b52c:	e1d330b8 	ldrh	r3, [r3, #8]
  11b530:	e1a01003 	mov	r1, r3
  11b534:	e51b3010 	ldr	r3, [fp, #-16]
  11b538:	e1d330ba 	ldrh	r3, [r3, #10]
  11b53c:	e0413003 	sub	r3, r1, r3
  11b540:	e1520003 	cmp	r2, r3
  11b544:	0a000006 	beq	11b564 <pbuf_dechain+0x78>
  11b548:	e3070b60 	movw	r0, #31584	; 0x7b60
  11b54c:	e3400014 	movt	r0, #20
  11b550:	ebff9eef 	bl	103114 <rt_kprintf>
  11b554:	e300138d 	movw	r1, #909	; 0x38d
  11b558:	e3070854 	movw	r0, #30804	; 0x7854
  11b55c:	e3400014 	movt	r0, #20
  11b560:	ebffbec5 	bl	10b07c <sys_arch_assert>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  11b564:	e51b3010 	ldr	r3, [fp, #-16]
  11b568:	e1d320b8 	ldrh	r2, [r3, #8]
  11b56c:	e51b3010 	ldr	r3, [fp, #-16]
  11b570:	e1d330ba 	ldrh	r3, [r3, #10]
  11b574:	e0423003 	sub	r3, r2, r3
  11b578:	e6ff2073 	uxth	r2, r3
  11b57c:	e51b300c 	ldr	r3, [fp, #-12]
  11b580:	e1c320b8 	strh	r2, [r3, #8]
    /* decouple pbuf from remainder */
    p->next = NULL;
  11b584:	e51b3010 	ldr	r3, [fp, #-16]
  11b588:	e3a02000 	mov	r2, #0
  11b58c:	e5832000 	str	r2, [r3]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  11b590:	e51b3010 	ldr	r3, [fp, #-16]
  11b594:	e1d320ba 	ldrh	r2, [r3, #10]
  11b598:	e51b3010 	ldr	r3, [fp, #-16]
  11b59c:	e1c320b8 	strh	r2, [r3, #8]
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  11b5a0:	e51b000c 	ldr	r0, [fp, #-12]
  11b5a4:	ebfffec2 	bl	11b0b4 <pbuf_free>
  11b5a8:	e1a03000 	mov	r3, r0
  11b5ac:	e54b3005 	strb	r3, [fp, #-5]
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  11b5b0:	e51b3010 	ldr	r3, [fp, #-16]
  11b5b4:	e1d320b8 	ldrh	r2, [r3, #8]
  11b5b8:	e51b3010 	ldr	r3, [fp, #-16]
  11b5bc:	e1d330ba 	ldrh	r3, [r3, #10]
  11b5c0:	e1520003 	cmp	r2, r3
  11b5c4:	0a000006 	beq	11b5e4 <pbuf_dechain+0xf8>
  11b5c8:	e3070b84 	movw	r0, #31620	; 0x7b84
  11b5cc:	e3400014 	movt	r0, #20
  11b5d0:	ebff9ecf 	bl	103114 <rt_kprintf>
  11b5d4:	e300139e 	movw	r1, #926	; 0x39e
  11b5d8:	e3070854 	movw	r0, #30804	; 0x7854
  11b5dc:	e3400014 	movt	r0, #20
  11b5e0:	ebffbea5 	bl	10b07c <sys_arch_assert>
  return ((tail_gone > 0) ? NULL : q);
  11b5e4:	e55b3005 	ldrb	r3, [fp, #-5]
  11b5e8:	e3530000 	cmp	r3, #0
  11b5ec:	1a000001 	bne	11b5f8 <pbuf_dechain+0x10c>
  11b5f0:	e51b300c 	ldr	r3, [fp, #-12]
  11b5f4:	ea000000 	b	11b5fc <pbuf_dechain+0x110>
  11b5f8:	e3a03000 	mov	r3, #0
}
  11b5fc:	e1a00003 	mov	r0, r3
  11b600:	e24bd004 	sub	sp, fp, #4
  11b604:	e8bd8800 	pop	{fp, pc}

0011b608 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
  11b608:	e92d4800 	push	{fp, lr}
  11b60c:	e28db004 	add	fp, sp, #4
  11b610:	e24dd010 	sub	sp, sp, #16
  11b614:	e50b0010 	str	r0, [fp, #-16]
  11b618:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  u16_t offset_to=0, offset_from=0, len;
  11b61c:	e3a03000 	mov	r3, #0
  11b620:	e14b30b6 	strh	r3, [fp, #-6]
  11b624:	e3a03000 	mov	r3, #0
  11b628:	e14b30b8 	strh	r3, [fp, #-8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (const void*)p_to, (const void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  11b62c:	e51b3010 	ldr	r3, [fp, #-16]
  11b630:	e3530000 	cmp	r3, #0
  11b634:	0a000008 	beq	11b65c <pbuf_copy+0x54>
  11b638:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b63c:	e3530000 	cmp	r3, #0
  11b640:	0a000005 	beq	11b65c <pbuf_copy+0x54>
  11b644:	e51b3010 	ldr	r3, [fp, #-16]
  11b648:	e1d320b8 	ldrh	r2, [r3, #8]
  11b64c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b650:	e1d330b8 	ldrh	r3, [r3, #8]
  11b654:	e1520003 	cmp	r2, r3
  11b658:	2a000008 	bcs	11b680 <pbuf_copy+0x78>
  11b65c:	e3070b9c 	movw	r0, #31644	; 0x7b9c
  11b660:	e3400014 	movt	r0, #20
  11b664:	ebff9eaa 	bl	103114 <rt_kprintf>
  11b668:	e30013be 	movw	r1, #958	; 0x3be
  11b66c:	e3070854 	movw	r0, #30804	; 0x7854
  11b670:	e3400014 	movt	r0, #20
  11b674:	ebffbe80 	bl	10b07c <sys_arch_assert>
  11b678:	e3e0300f 	mvn	r3, #15
  11b67c:	ea000094 	b	11b8d4 <pbuf_copy+0x2cc>

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  11b680:	e51b3010 	ldr	r3, [fp, #-16]
  11b684:	e1d330ba 	ldrh	r3, [r3, #10]
  11b688:	e1a02003 	mov	r2, r3
  11b68c:	e15b30b6 	ldrh	r3, [fp, #-6]
  11b690:	e0422003 	sub	r2, r2, r3
  11b694:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b698:	e1d330ba 	ldrh	r3, [r3, #10]
  11b69c:	e1a01003 	mov	r1, r3
  11b6a0:	e15b30b8 	ldrh	r3, [fp, #-8]
  11b6a4:	e0413003 	sub	r3, r1, r3
  11b6a8:	e1520003 	cmp	r2, r3
  11b6ac:	ba000005 	blt	11b6c8 <pbuf_copy+0xc0>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  11b6b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b6b4:	e1d320ba 	ldrh	r2, [r3, #10]
  11b6b8:	e15b30b8 	ldrh	r3, [fp, #-8]
  11b6bc:	e0423003 	sub	r3, r2, r3
  11b6c0:	e14b30ba 	strh	r3, [fp, #-10]
  11b6c4:	ea000004 	b	11b6dc <pbuf_copy+0xd4>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  11b6c8:	e51b3010 	ldr	r3, [fp, #-16]
  11b6cc:	e1d320ba 	ldrh	r2, [r3, #10]
  11b6d0:	e15b30b6 	ldrh	r3, [fp, #-6]
  11b6d4:	e0423003 	sub	r3, r2, r3
  11b6d8:	e14b30ba 	strh	r3, [fp, #-10]
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  11b6dc:	e51b3010 	ldr	r3, [fp, #-16]
  11b6e0:	e5932004 	ldr	r2, [r3, #4]
  11b6e4:	e15b30b6 	ldrh	r3, [fp, #-6]
  11b6e8:	e0820003 	add	r0, r2, r3
  11b6ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b6f0:	e5932004 	ldr	r2, [r3, #4]
  11b6f4:	e15b30b8 	ldrh	r3, [fp, #-8]
  11b6f8:	e0823003 	add	r3, r2, r3
  11b6fc:	e15b20ba 	ldrh	r2, [fp, #-10]
  11b700:	e1a01003 	mov	r1, r3
  11b704:	eb009622 	bl	140f94 <memcpy>
    offset_to += len;
  11b708:	e15b20b6 	ldrh	r2, [fp, #-6]
  11b70c:	e15b30ba 	ldrh	r3, [fp, #-10]
  11b710:	e0823003 	add	r3, r2, r3
  11b714:	e14b30b6 	strh	r3, [fp, #-6]
    offset_from += len;
  11b718:	e15b20b8 	ldrh	r2, [fp, #-8]
  11b71c:	e15b30ba 	ldrh	r3, [fp, #-10]
  11b720:	e0823003 	add	r3, r2, r3
  11b724:	e14b30b8 	strh	r3, [fp, #-8]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  11b728:	e51b3010 	ldr	r3, [fp, #-16]
  11b72c:	e1d330ba 	ldrh	r3, [r3, #10]
  11b730:	e15b20b6 	ldrh	r2, [fp, #-6]
  11b734:	e1520003 	cmp	r2, r3
  11b738:	9a000006 	bls	11b758 <pbuf_copy+0x150>
  11b73c:	e3070bcc 	movw	r0, #31692	; 0x7bcc
  11b740:	e3400014 	movt	r0, #20
  11b744:	ebff9e72 	bl	103114 <rt_kprintf>
  11b748:	e30013ce 	movw	r1, #974	; 0x3ce
  11b74c:	e3070854 	movw	r0, #30804	; 0x7854
  11b750:	e3400014 	movt	r0, #20
  11b754:	ebffbe48 	bl	10b07c <sys_arch_assert>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  11b758:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b75c:	e1d330ba 	ldrh	r3, [r3, #10]
  11b760:	e15b20b8 	ldrh	r2, [fp, #-8]
  11b764:	e1520003 	cmp	r2, r3
  11b768:	9a000006 	bls	11b788 <pbuf_copy+0x180>
  11b76c:	e3070be4 	movw	r0, #31716	; 0x7be4
  11b770:	e3400014 	movt	r0, #20
  11b774:	ebff9e66 	bl	103114 <rt_kprintf>
  11b778:	e30013cf 	movw	r1, #975	; 0x3cf
  11b77c:	e3070854 	movw	r0, #30804	; 0x7854
  11b780:	e3400014 	movt	r0, #20
  11b784:	ebffbe3c 	bl	10b07c <sys_arch_assert>
    if (offset_from >= p_from->len) {
  11b788:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b78c:	e1d330ba 	ldrh	r3, [r3, #10]
  11b790:	e15b20b8 	ldrh	r2, [fp, #-8]
  11b794:	e1520003 	cmp	r2, r3
  11b798:	3a000004 	bcc	11b7b0 <pbuf_copy+0x1a8>
      /* on to next p_from (if any) */
      offset_from = 0;
  11b79c:	e3a03000 	mov	r3, #0
  11b7a0:	e14b30b8 	strh	r3, [fp, #-8]
      p_from = p_from->next;
  11b7a4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b7a8:	e5933000 	ldr	r3, [r3]
  11b7ac:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    }
    if (offset_to == p_to->len) {
  11b7b0:	e51b3010 	ldr	r3, [fp, #-16]
  11b7b4:	e1d330ba 	ldrh	r3, [r3, #10]
  11b7b8:	e15b20b6 	ldrh	r2, [fp, #-6]
  11b7bc:	e1520003 	cmp	r2, r3
  11b7c0:	1a000013 	bne	11b814 <pbuf_copy+0x20c>
      /* on to next p_to (if any) */
      offset_to = 0;
  11b7c4:	e3a03000 	mov	r3, #0
  11b7c8:	e14b30b6 	strh	r3, [fp, #-6]
      p_to = p_to->next;
  11b7cc:	e51b3010 	ldr	r3, [fp, #-16]
  11b7d0:	e5933000 	ldr	r3, [r3]
  11b7d4:	e50b3010 	str	r3, [fp, #-16]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
  11b7d8:	e51b3010 	ldr	r3, [fp, #-16]
  11b7dc:	e3530000 	cmp	r3, #0
  11b7e0:	1a00000b 	bne	11b814 <pbuf_copy+0x20c>
  11b7e4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b7e8:	e3530000 	cmp	r3, #0
  11b7ec:	0a000008 	beq	11b814 <pbuf_copy+0x20c>
  11b7f0:	e3070c00 	movw	r0, #31744	; 0x7c00
  11b7f4:	e3400014 	movt	r0, #20
  11b7f8:	ebff9e45 	bl	103114 <rt_kprintf>
  11b7fc:	e30013d9 	movw	r1, #985	; 0x3d9
  11b800:	e3070854 	movw	r0, #30804	; 0x7854
  11b804:	e3400014 	movt	r0, #20
  11b808:	ebffbe1b 	bl	10b07c <sys_arch_assert>
  11b80c:	e3e0300f 	mvn	r3, #15
  11b810:	ea00002f 	b	11b8d4 <pbuf_copy+0x2cc>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  11b814:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b818:	e3530000 	cmp	r3, #0
  11b81c:	0a000012 	beq	11b86c <pbuf_copy+0x264>
  11b820:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b824:	e1d320ba 	ldrh	r2, [r3, #10]
  11b828:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b82c:	e1d330b8 	ldrh	r3, [r3, #8]
  11b830:	e1520003 	cmp	r2, r3
  11b834:	1a00000c 	bne	11b86c <pbuf_copy+0x264>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
  11b838:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b83c:	e5933000 	ldr	r3, [r3]
  11b840:	e3530000 	cmp	r3, #0
  11b844:	0a000008 	beq	11b86c <pbuf_copy+0x264>
  11b848:	e3070c10 	movw	r0, #31760	; 0x7c10
  11b84c:	e3400014 	movt	r0, #20
  11b850:	ebff9e2f 	bl	103114 <rt_kprintf>
  11b854:	e30013df 	movw	r1, #991	; 0x3df
  11b858:	e3070854 	movw	r0, #30804	; 0x7854
  11b85c:	e3400014 	movt	r0, #20
  11b860:	ebffbe05 	bl	10b07c <sys_arch_assert>
  11b864:	e3e03005 	mvn	r3, #5
  11b868:	ea000019 	b	11b8d4 <pbuf_copy+0x2cc>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  11b86c:	e51b3010 	ldr	r3, [fp, #-16]
  11b870:	e3530000 	cmp	r3, #0
  11b874:	0a000012 	beq	11b8c4 <pbuf_copy+0x2bc>
  11b878:	e51b3010 	ldr	r3, [fp, #-16]
  11b87c:	e1d320ba 	ldrh	r2, [r3, #10]
  11b880:	e51b3010 	ldr	r3, [fp, #-16]
  11b884:	e1d330b8 	ldrh	r3, [r3, #8]
  11b888:	e1520003 	cmp	r2, r3
  11b88c:	1a00000c 	bne	11b8c4 <pbuf_copy+0x2bc>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
  11b890:	e51b3010 	ldr	r3, [fp, #-16]
  11b894:	e5933000 	ldr	r3, [r3]
  11b898:	e3530000 	cmp	r3, #0
  11b89c:	0a000008 	beq	11b8c4 <pbuf_copy+0x2bc>
  11b8a0:	e3070c10 	movw	r0, #31760	; 0x7c10
  11b8a4:	e3400014 	movt	r0, #20
  11b8a8:	ebff9e19 	bl	103114 <rt_kprintf>
  11b8ac:	e3a01ff9 	mov	r1, #996	; 0x3e4
  11b8b0:	e3070854 	movw	r0, #30804	; 0x7854
  11b8b4:	e3400014 	movt	r0, #20
  11b8b8:	ebffbdef 	bl	10b07c <sys_arch_assert>
  11b8bc:	e3e03005 	mvn	r3, #5
  11b8c0:	ea000003 	b	11b8d4 <pbuf_copy+0x2cc>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  11b8c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11b8c8:	e3530000 	cmp	r3, #0
  11b8cc:	1affff6b 	bne	11b680 <pbuf_copy+0x78>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
  11b8d0:	e3a03000 	mov	r3, #0
}
  11b8d4:	e1a00003 	mov	r0, r3
  11b8d8:	e24bd004 	sub	sp, fp, #4
  11b8dc:	e8bd8800 	pop	{fp, pc}

0011b8e0 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  11b8e0:	e92d4800 	push	{fp, lr}
  11b8e4:	e28db004 	add	fp, sp, #4
  11b8e8:	e24dd020 	sub	sp, sp, #32
  11b8ec:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  11b8f0:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  11b8f4:	e1a01002 	mov	r1, r2
  11b8f8:	e1a02003 	mov	r2, r3
  11b8fc:	e1a03001 	mov	r3, r1
  11b900:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
  11b904:	e1a03002 	mov	r3, r2
  11b908:	e14b32b0 	strh	r3, [fp, #-32]	; 0xffffffe0
  const struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  11b90c:	e3a03000 	mov	r3, #0
  11b910:	e14b30be 	strh	r3, [fp, #-14]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  11b914:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b918:	e3530000 	cmp	r3, #0
  11b91c:	1a000008 	bne	11b944 <pbuf_copy_partial+0x64>
  11b920:	e3070c3c 	movw	r0, #31804	; 0x7c3c
  11b924:	e3400014 	movt	r0, #20
  11b928:	ebff9df9 	bl	103114 <rt_kprintf>
  11b92c:	e30013ff 	movw	r1, #1023	; 0x3ff
  11b930:	e3070854 	movw	r0, #30804	; 0x7854
  11b934:	e3400014 	movt	r0, #20
  11b938:	ebffbdcf 	bl	10b07c <sys_arch_assert>
  11b93c:	e3a03000 	mov	r3, #0
  11b940:	ea000053 	b	11ba94 <pbuf_copy_partial+0x1b4>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  11b944:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11b948:	e3530000 	cmp	r3, #0
  11b94c:	1a000008 	bne	11b974 <pbuf_copy_partial+0x94>
  11b950:	e3070c5c 	movw	r0, #31836	; 0x7c5c
  11b954:	e3400014 	movt	r0, #20
  11b958:	ebff9ded 	bl	103114 <rt_kprintf>
  11b95c:	e3a01b01 	mov	r1, #1024	; 0x400
  11b960:	e3070854 	movw	r0, #30804	; 0x7854
  11b964:	e3400014 	movt	r0, #20
  11b968:	ebffbdc3 	bl	10b07c <sys_arch_assert>
  11b96c:	e3a03000 	mov	r3, #0
  11b970:	ea000047 	b	11ba94 <pbuf_copy_partial+0x1b4>

  left = 0;
  11b974:	e3a03000 	mov	r3, #0
  11b978:	e14b30ba 	strh	r3, [fp, #-10]

  if ((buf == NULL) || (dataptr == NULL)) {
  11b97c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b980:	e3530000 	cmp	r3, #0
  11b984:	0a000002 	beq	11b994 <pbuf_copy_partial+0xb4>
  11b988:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11b98c:	e3530000 	cmp	r3, #0
  11b990:	1a000001 	bne	11b99c <pbuf_copy_partial+0xbc>
    return 0;
  11b994:	e3a03000 	mov	r3, #0
  11b998:	ea00003d 	b	11ba94 <pbuf_copy_partial+0x1b4>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
  11b99c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11b9a0:	e50b3008 	str	r3, [fp, #-8]
  11b9a4:	ea000033 	b	11ba78 <pbuf_copy_partial+0x198>
    if ((offset != 0) && (offset >= p->len)) {
  11b9a8:	e15b32b0 	ldrh	r3, [fp, #-32]	; 0xffffffe0
  11b9ac:	e3530000 	cmp	r3, #0
  11b9b0:	0a00000a 	beq	11b9e0 <pbuf_copy_partial+0x100>
  11b9b4:	e51b3008 	ldr	r3, [fp, #-8]
  11b9b8:	e1d330ba 	ldrh	r3, [r3, #10]
  11b9bc:	e15b22b0 	ldrh	r2, [fp, #-32]	; 0xffffffe0
  11b9c0:	e1520003 	cmp	r2, r3
  11b9c4:	3a000005 	bcc	11b9e0 <pbuf_copy_partial+0x100>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  11b9c8:	e51b3008 	ldr	r3, [fp, #-8]
  11b9cc:	e1d330ba 	ldrh	r3, [r3, #10]
  11b9d0:	e15b22b0 	ldrh	r2, [fp, #-32]	; 0xffffffe0
  11b9d4:	e0423003 	sub	r3, r2, r3
  11b9d8:	e14b32b0 	strh	r3, [fp, #-32]	; 0xffffffe0
  11b9dc:	ea000022 	b	11ba6c <pbuf_copy_partial+0x18c>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  11b9e0:	e51b3008 	ldr	r3, [fp, #-8]
  11b9e4:	e1d320ba 	ldrh	r2, [r3, #10]
  11b9e8:	e15b32b0 	ldrh	r3, [fp, #-32]	; 0xffffffe0
  11b9ec:	e0423003 	sub	r3, r2, r3
  11b9f0:	e14b30bc 	strh	r3, [fp, #-12]
      if (buf_copy_len > len) {
  11b9f4:	e15b20bc 	ldrh	r2, [fp, #-12]
  11b9f8:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  11b9fc:	e1520003 	cmp	r2, r3
  11ba00:	9a000001 	bls	11ba0c <pbuf_copy_partial+0x12c>
        buf_copy_len = len;
  11ba04:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  11ba08:	e14b30bc 	strh	r3, [fp, #-12]
      }
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  11ba0c:	e15b30ba 	ldrh	r3, [fp, #-10]
  11ba10:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  11ba14:	e0820003 	add	r0, r2, r3
  11ba18:	e51b3008 	ldr	r3, [fp, #-8]
  11ba1c:	e5932004 	ldr	r2, [r3, #4]
  11ba20:	e15b32b0 	ldrh	r3, [fp, #-32]	; 0xffffffe0
  11ba24:	e0823003 	add	r3, r2, r3
  11ba28:	e15b20bc 	ldrh	r2, [fp, #-12]
  11ba2c:	e1a01003 	mov	r1, r3
  11ba30:	eb009557 	bl	140f94 <memcpy>
      copied_total += buf_copy_len;
  11ba34:	e15b20be 	ldrh	r2, [fp, #-14]
  11ba38:	e15b30bc 	ldrh	r3, [fp, #-12]
  11ba3c:	e0823003 	add	r3, r2, r3
  11ba40:	e14b30be 	strh	r3, [fp, #-14]
      left += buf_copy_len;
  11ba44:	e15b20ba 	ldrh	r2, [fp, #-10]
  11ba48:	e15b30bc 	ldrh	r3, [fp, #-12]
  11ba4c:	e0823003 	add	r3, r2, r3
  11ba50:	e14b30ba 	strh	r3, [fp, #-10]
      len -= buf_copy_len;
  11ba54:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
  11ba58:	e15b30bc 	ldrh	r3, [fp, #-12]
  11ba5c:	e0423003 	sub	r3, r2, r3
  11ba60:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
      offset = 0;
  11ba64:	e3a03000 	mov	r3, #0
  11ba68:	e14b32b0 	strh	r3, [fp, #-32]	; 0xffffffe0
  for (p = buf; len != 0 && p != NULL; p = p->next) {
  11ba6c:	e51b3008 	ldr	r3, [fp, #-8]
  11ba70:	e5933000 	ldr	r3, [r3]
  11ba74:	e50b3008 	str	r3, [fp, #-8]
  11ba78:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  11ba7c:	e3530000 	cmp	r3, #0
  11ba80:	0a000002 	beq	11ba90 <pbuf_copy_partial+0x1b0>
  11ba84:	e51b3008 	ldr	r3, [fp, #-8]
  11ba88:	e3530000 	cmp	r3, #0
  11ba8c:	1affffc5 	bne	11b9a8 <pbuf_copy_partial+0xc8>
    }
  }
  return copied_total;
  11ba90:	e15b30be 	ldrh	r3, [fp, #-14]
}
  11ba94:	e1a00003 	mov	r0, r3
  11ba98:	e24bd004 	sub	sp, fp, #4
  11ba9c:	e8bd8800 	pop	{fp, pc}

0011baa0 <pbuf_skip_const>:
#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

/* Actual implementation of pbuf_skip() but returning const pointer... */
static const struct pbuf*
pbuf_skip_const(const struct pbuf* in, u16_t in_offset, u16_t* out_offset)
{
  11baa0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11baa4:	e28db000 	add	fp, sp, #0
  11baa8:	e24dd01c 	sub	sp, sp, #28
  11baac:	e50b0010 	str	r0, [fp, #-16]
  11bab0:	e1a03001 	mov	r3, r1
  11bab4:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  11bab8:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  u16_t offset_left = in_offset;
  11babc:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11bac0:	e14b30b6 	strh	r3, [fp, #-6]
  const struct pbuf* q = in;
  11bac4:	e51b3010 	ldr	r3, [fp, #-16]
  11bac8:	e50b300c 	str	r3, [fp, #-12]

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
  11bacc:	ea000007 	b	11baf0 <pbuf_skip_const+0x50>
    offset_left -= q->len;
  11bad0:	e51b300c 	ldr	r3, [fp, #-12]
  11bad4:	e1d330ba 	ldrh	r3, [r3, #10]
  11bad8:	e15b20b6 	ldrh	r2, [fp, #-6]
  11badc:	e0423003 	sub	r3, r2, r3
  11bae0:	e14b30b6 	strh	r3, [fp, #-6]
    q = q->next;
  11bae4:	e51b300c 	ldr	r3, [fp, #-12]
  11bae8:	e5933000 	ldr	r3, [r3]
  11baec:	e50b300c 	str	r3, [fp, #-12]
  while ((q != NULL) && (q->len <= offset_left)) {
  11baf0:	e51b300c 	ldr	r3, [fp, #-12]
  11baf4:	e3530000 	cmp	r3, #0
  11baf8:	0a000004 	beq	11bb10 <pbuf_skip_const+0x70>
  11bafc:	e51b300c 	ldr	r3, [fp, #-12]
  11bb00:	e1d330ba 	ldrh	r3, [r3, #10]
  11bb04:	e15b20b6 	ldrh	r2, [fp, #-6]
  11bb08:	e1520003 	cmp	r2, r3
  11bb0c:	2affffef 	bcs	11bad0 <pbuf_skip_const+0x30>
  }
  if (out_offset != NULL) {
  11bb10:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11bb14:	e3530000 	cmp	r3, #0
  11bb18:	0a000002 	beq	11bb28 <pbuf_skip_const+0x88>
    *out_offset = offset_left;
  11bb1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11bb20:	e15b20b6 	ldrh	r2, [fp, #-6]
  11bb24:	e1c320b0 	strh	r2, [r3]
  }
  return q;
  11bb28:	e51b300c 	ldr	r3, [fp, #-12]
}
  11bb2c:	e1a00003 	mov	r0, r3
  11bb30:	e28bd000 	add	sp, fp, #0
  11bb34:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11bb38:	e12fff1e 	bx	lr

0011bb3c <pbuf_skip>:
 * @param out_offset resulting offset in the returned pbuf
 * @return the pbuf in the queue where the offset is
 */
struct pbuf*
pbuf_skip(struct pbuf* in, u16_t in_offset, u16_t* out_offset)
{
  11bb3c:	e92d4800 	push	{fp, lr}
  11bb40:	e28db004 	add	fp, sp, #4
  11bb44:	e24dd018 	sub	sp, sp, #24
  11bb48:	e50b0010 	str	r0, [fp, #-16]
  11bb4c:	e1a03001 	mov	r3, r1
  11bb50:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  11bb54:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  const struct pbuf* out = pbuf_skip_const(in, in_offset, out_offset);
  11bb58:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11bb5c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  11bb60:	e1a01003 	mov	r1, r3
  11bb64:	e51b0010 	ldr	r0, [fp, #-16]
  11bb68:	ebffffcc 	bl	11baa0 <pbuf_skip_const>
  11bb6c:	e50b0008 	str	r0, [fp, #-8]
  return LWIP_CONST_CAST(struct pbuf*, out);
  11bb70:	e51b3008 	ldr	r3, [fp, #-8]
}
  11bb74:	e1a00003 	mov	r0, r3
  11bb78:	e24bd004 	sub	sp, fp, #4
  11bb7c:	e8bd8800 	pop	{fp, pc}

0011bb80 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
  11bb80:	e92d4800 	push	{fp, lr}
  11bb84:	e28db004 	add	fp, sp, #4
  11bb88:	e24dd020 	sub	sp, sp, #32
  11bb8c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  11bb90:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  11bb94:	e1a03002 	mov	r3, r2
  11bb98:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  11bb9c:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  11bba0:	e14b30bc 	strh	r3, [fp, #-12]
  u16_t copied_total = 0;
  11bba4:	e3a03000 	mov	r3, #0
  11bba8:	e14b30be 	strh	r3, [fp, #-14]

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
  11bbac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11bbb0:	e3530000 	cmp	r3, #0
  11bbb4:	1a000008 	bne	11bbdc <pbuf_take+0x5c>
  11bbb8:	e3070c80 	movw	r0, #31872	; 0x7c80
  11bbbc:	e3400014 	movt	r0, #20
  11bbc0:	ebff9d53 	bl	103114 <rt_kprintf>
  11bbc4:	e3001485 	movw	r1, #1157	; 0x485
  11bbc8:	e3070854 	movw	r0, #30804	; 0x7854
  11bbcc:	e3400014 	movt	r0, #20
  11bbd0:	ebffbd29 	bl	10b07c <sys_arch_assert>
  11bbd4:	e3e0300f 	mvn	r3, #15
  11bbd8:	ea000062 	b	11bd68 <pbuf_take+0x1e8>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  11bbdc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11bbe0:	e3530000 	cmp	r3, #0
  11bbe4:	1a000008 	bne	11bc0c <pbuf_take+0x8c>
  11bbe8:	e3070c98 	movw	r0, #31896	; 0x7c98
  11bbec:	e3400014 	movt	r0, #20
  11bbf0:	ebff9d47 	bl	103114 <rt_kprintf>
  11bbf4:	e3001486 	movw	r1, #1158	; 0x486
  11bbf8:	e3070854 	movw	r0, #30804	; 0x7854
  11bbfc:	e3400014 	movt	r0, #20
  11bc00:	ebffbd1d 	bl	10b07c <sys_arch_assert>
  11bc04:	e3e0300f 	mvn	r3, #15
  11bc08:	ea000056 	b	11bd68 <pbuf_take+0x1e8>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
  11bc0c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11bc10:	e1d330b8 	ldrh	r3, [r3, #8]
  11bc14:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
  11bc18:	e1520003 	cmp	r2, r3
  11bc1c:	9a000008 	bls	11bc44 <pbuf_take+0xc4>
  11bc20:	e3070cb4 	movw	r0, #31924	; 0x7cb4
  11bc24:	e3400014 	movt	r0, #20
  11bc28:	ebff9d39 	bl	103114 <rt_kprintf>
  11bc2c:	e3001487 	movw	r1, #1159	; 0x487
  11bc30:	e3070854 	movw	r0, #30804	; 0x7854
  11bc34:	e3400014 	movt	r0, #20
  11bc38:	ebffbd0f 	bl	10b07c <sys_arch_assert>
  11bc3c:	e3e03000 	mvn	r3, #0
  11bc40:	ea000048 	b	11bd68 <pbuf_take+0x1e8>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
  11bc44:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11bc48:	e3530000 	cmp	r3, #0
  11bc4c:	0a000007 	beq	11bc70 <pbuf_take+0xf0>
  11bc50:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11bc54:	e3530000 	cmp	r3, #0
  11bc58:	0a000004 	beq	11bc70 <pbuf_take+0xf0>
  11bc5c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11bc60:	e1d330b8 	ldrh	r3, [r3, #8]
  11bc64:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
  11bc68:	e1520003 	cmp	r2, r3
  11bc6c:	9a000001 	bls	11bc78 <pbuf_take+0xf8>
    return ERR_ARG;
  11bc70:	e3e0300f 	mvn	r3, #15
  11bc74:	ea00003b 	b	11bd68 <pbuf_take+0x1e8>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
  11bc78:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11bc7c:	e50b3008 	str	r3, [fp, #-8]
  11bc80:	ea000026 	b	11bd20 <pbuf_take+0x1a0>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
  11bc84:	e51b3008 	ldr	r3, [fp, #-8]
  11bc88:	e3530000 	cmp	r3, #0
  11bc8c:	1a000006 	bne	11bcac <pbuf_take+0x12c>
  11bc90:	e3070cd4 	movw	r0, #31956	; 0x7cd4
  11bc94:	e3400014 	movt	r0, #20
  11bc98:	ebff9d1d 	bl	103114 <rt_kprintf>
  11bc9c:	e300148f 	movw	r1, #1167	; 0x48f
  11bca0:	e3070854 	movw	r0, #30804	; 0x7854
  11bca4:	e3400014 	movt	r0, #20
  11bca8:	ebffbcf3 	bl	10b07c <sys_arch_assert>
    buf_copy_len = total_copy_len;
  11bcac:	e15b30bc 	ldrh	r3, [fp, #-12]
  11bcb0:	e14b30ba 	strh	r3, [fp, #-10]
    if (buf_copy_len > p->len) {
  11bcb4:	e51b3008 	ldr	r3, [fp, #-8]
  11bcb8:	e1d330ba 	ldrh	r3, [r3, #10]
  11bcbc:	e15b20ba 	ldrh	r2, [fp, #-10]
  11bcc0:	e1520003 	cmp	r2, r3
  11bcc4:	9a000002 	bls	11bcd4 <pbuf_take+0x154>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
  11bcc8:	e51b3008 	ldr	r3, [fp, #-8]
  11bccc:	e1d330ba 	ldrh	r3, [r3, #10]
  11bcd0:	e14b30ba 	strh	r3, [fp, #-10]
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char*)dataptr)[copied_total], buf_copy_len);
  11bcd4:	e51b3008 	ldr	r3, [fp, #-8]
  11bcd8:	e5930004 	ldr	r0, [r3, #4]
  11bcdc:	e15b30be 	ldrh	r3, [fp, #-14]
  11bce0:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  11bce4:	e0823003 	add	r3, r2, r3
  11bce8:	e15b20ba 	ldrh	r2, [fp, #-10]
  11bcec:	e1a01003 	mov	r1, r3
  11bcf0:	eb0094a7 	bl	140f94 <memcpy>
    total_copy_len -= buf_copy_len;
  11bcf4:	e15b20bc 	ldrh	r2, [fp, #-12]
  11bcf8:	e15b30ba 	ldrh	r3, [fp, #-10]
  11bcfc:	e0423003 	sub	r3, r2, r3
  11bd00:	e14b30bc 	strh	r3, [fp, #-12]
    copied_total += buf_copy_len;
  11bd04:	e15b20be 	ldrh	r2, [fp, #-14]
  11bd08:	e15b30ba 	ldrh	r3, [fp, #-10]
  11bd0c:	e0823003 	add	r3, r2, r3
  11bd10:	e14b30be 	strh	r3, [fp, #-14]
  for (p = buf; total_copy_len != 0; p = p->next) {
  11bd14:	e51b3008 	ldr	r3, [fp, #-8]
  11bd18:	e5933000 	ldr	r3, [r3]
  11bd1c:	e50b3008 	str	r3, [fp, #-8]
  11bd20:	e15b30bc 	ldrh	r3, [fp, #-12]
  11bd24:	e3530000 	cmp	r3, #0
  11bd28:	1affffd5 	bne	11bc84 <pbuf_take+0x104>
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  11bd2c:	e15b30bc 	ldrh	r3, [fp, #-12]
  11bd30:	e3530000 	cmp	r3, #0
  11bd34:	1a000003 	bne	11bd48 <pbuf_take+0x1c8>
  11bd38:	e15b20be 	ldrh	r2, [fp, #-14]
  11bd3c:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  11bd40:	e1520003 	cmp	r2, r3
  11bd44:	0a000006 	beq	11bd64 <pbuf_take+0x1e4>
  11bd48:	e3070cec 	movw	r0, #31980	; 0x7cec
  11bd4c:	e3400014 	movt	r0, #20
  11bd50:	ebff9cef 	bl	103114 <rt_kprintf>
  11bd54:	e300149a 	movw	r1, #1178	; 0x49a
  11bd58:	e3070854 	movw	r0, #30804	; 0x7854
  11bd5c:	e3400014 	movt	r0, #20
  11bd60:	ebffbcc5 	bl	10b07c <sys_arch_assert>
  return ERR_OK;
  11bd64:	e3a03000 	mov	r3, #0
}
  11bd68:	e1a00003 	mov	r0, r3
  11bd6c:	e24bd004 	sub	sp, fp, #4
  11bd70:	e8bd8800 	pop	{fp, pc}

0011bd74 <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
  11bd74:	e92d4800 	push	{fp, lr}
  11bd78:	e28db004 	add	fp, sp, #4
  11bd7c:	e24dd020 	sub	sp, sp, #32
  11bd80:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  11bd84:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  11bd88:	e1a01002 	mov	r1, r2
  11bd8c:	e1a02003 	mov	r2, r3
  11bd90:	e1a03001 	mov	r3, r1
  11bd94:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
  11bd98:	e1a03002 	mov	r3, r2
  11bd9c:	e14b32b0 	strh	r3, [fp, #-32]	; 0xffffffe0
  u16_t target_offset;
  struct pbuf* q = pbuf_skip(buf, offset, &target_offset);
  11bda0:	e24b2014 	sub	r2, fp, #20
  11bda4:	e15b32b0 	ldrh	r3, [fp, #-32]	; 0xffffffe0
  11bda8:	e1a01003 	mov	r1, r3
  11bdac:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  11bdb0:	ebffff61 	bl	11bb3c <pbuf_skip>
  11bdb4:	e50b0008 	str	r0, [fp, #-8]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
  11bdb8:	e51b3008 	ldr	r3, [fp, #-8]
  11bdbc:	e3530000 	cmp	r3, #0
  11bdc0:	0a000033 	beq	11be94 <pbuf_take_at+0x120>
  11bdc4:	e51b3008 	ldr	r3, [fp, #-8]
  11bdc8:	e1d330b8 	ldrh	r3, [r3, #8]
  11bdcc:	e1a02003 	mov	r2, r3
  11bdd0:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
  11bdd4:	e1a01003 	mov	r1, r3
  11bdd8:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  11bddc:	e0813003 	add	r3, r1, r3
  11bde0:	e1520003 	cmp	r2, r3
  11bde4:	ba00002a 	blt	11be94 <pbuf_take_at+0x120>
    u16_t remaining_len = len;
  11bde8:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  11bdec:	e14b30ba 	strh	r3, [fp, #-10]
    const u8_t* src_ptr = (const u8_t*)dataptr;
  11bdf0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11bdf4:	e50b3010 	str	r3, [fp, #-16]
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len = LWIP_MIN(q->len - target_offset, len);
  11bdf8:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
  11bdfc:	e51b3008 	ldr	r3, [fp, #-8]
  11be00:	e1d330ba 	ldrh	r3, [r3, #10]
  11be04:	e1a01003 	mov	r1, r3
  11be08:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
  11be0c:	e0413003 	sub	r3, r1, r3
  11be10:	e1520003 	cmp	r2, r3
  11be14:	b1a03002 	movlt	r3, r2
  11be18:	a1a03003 	movge	r3, r3
  11be1c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    MEMCPY(((u8_t*)q->payload) + target_offset, dataptr, first_copy_len);
  11be20:	e51b3008 	ldr	r3, [fp, #-8]
  11be24:	e5933004 	ldr	r3, [r3, #4]
  11be28:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
  11be2c:	e0833002 	add	r3, r3, r2
  11be30:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
  11be34:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  11be38:	e1a00003 	mov	r0, r3
  11be3c:	eb009454 	bl	140f94 <memcpy>
    remaining_len -= first_copy_len;
  11be40:	e15b20ba 	ldrh	r2, [fp, #-10]
  11be44:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11be48:	e0423003 	sub	r3, r2, r3
  11be4c:	e14b30ba 	strh	r3, [fp, #-10]
    src_ptr += first_copy_len;
  11be50:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11be54:	e51b2010 	ldr	r2, [fp, #-16]
  11be58:	e0823003 	add	r3, r2, r3
  11be5c:	e50b3010 	str	r3, [fp, #-16]
    if (remaining_len > 0) {
  11be60:	e15b30ba 	ldrh	r3, [fp, #-10]
  11be64:	e3530000 	cmp	r3, #0
  11be68:	0a000007 	beq	11be8c <pbuf_take_at+0x118>
      return pbuf_take(q->next, src_ptr, remaining_len);
  11be6c:	e51b3008 	ldr	r3, [fp, #-8]
  11be70:	e5933000 	ldr	r3, [r3]
  11be74:	e15b20ba 	ldrh	r2, [fp, #-10]
  11be78:	e51b1010 	ldr	r1, [fp, #-16]
  11be7c:	e1a00003 	mov	r0, r3
  11be80:	ebffff3e 	bl	11bb80 <pbuf_take>
  11be84:	e1a03000 	mov	r3, r0
  11be88:	ea000002 	b	11be98 <pbuf_take_at+0x124>
    }
    return ERR_OK;
  11be8c:	e3a03000 	mov	r3, #0
  11be90:	ea000000 	b	11be98 <pbuf_take_at+0x124>
  }
  return ERR_MEM;
  11be94:	e3e03000 	mvn	r3, #0
}
  11be98:	e1a00003 	mov	r0, r3
  11be9c:	e24bd004 	sub	sp, fp, #4
  11bea0:	e8bd8800 	pop	{fp, pc}

0011bea4 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
  11bea4:	e92d4800 	push	{fp, lr}
  11bea8:	e28db004 	add	fp, sp, #4
  11beac:	e24dd010 	sub	sp, sp, #16
  11beb0:	e50b0010 	str	r0, [fp, #-16]
  11beb4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
  11beb8:	e51b3010 	ldr	r3, [fp, #-16]
  11bebc:	e5933000 	ldr	r3, [r3]
  11bec0:	e3530000 	cmp	r3, #0
  11bec4:	1a000001 	bne	11bed0 <pbuf_coalesce+0x2c>
    return p;
  11bec8:	e51b3010 	ldr	r3, [fp, #-16]
  11becc:	ea00001d 	b	11bf48 <pbuf_coalesce+0xa4>
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
  11bed0:	e51b3010 	ldr	r3, [fp, #-16]
  11bed4:	e1d330b8 	ldrh	r3, [r3, #8]
  11bed8:	e3a02000 	mov	r2, #0
  11bedc:	e1a01003 	mov	r1, r3
  11bee0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  11bee4:	ebfff96b 	bl	11a498 <pbuf_alloc>
  11bee8:	e50b0008 	str	r0, [fp, #-8]
  if (q == NULL) {
  11beec:	e51b3008 	ldr	r3, [fp, #-8]
  11bef0:	e3530000 	cmp	r3, #0
  11bef4:	1a000001 	bne	11bf00 <pbuf_coalesce+0x5c>
    /* @todo: what do we do now? */
    return p;
  11bef8:	e51b3010 	ldr	r3, [fp, #-16]
  11befc:	ea000011 	b	11bf48 <pbuf_coalesce+0xa4>
  }
  err = pbuf_copy(q, p);
  11bf00:	e51b1010 	ldr	r1, [fp, #-16]
  11bf04:	e51b0008 	ldr	r0, [fp, #-8]
  11bf08:	ebfffdbe 	bl	11b608 <pbuf_copy>
  11bf0c:	e1a03000 	mov	r3, r0
  11bf10:	e54b3009 	strb	r3, [fp, #-9]
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
  11bf14:	e15b30d9 	ldrsb	r3, [fp, #-9]
  11bf18:	e3530000 	cmp	r3, #0
  11bf1c:	0a000006 	beq	11bf3c <pbuf_coalesce+0x98>
  11bf20:	e3070d04 	movw	r0, #32004	; 0x7d04
  11bf24:	e3400014 	movt	r0, #20
  11bf28:	ebff9c79 	bl	103114 <rt_kprintf>
  11bf2c:	e30014dc 	movw	r1, #1244	; 0x4dc
  11bf30:	e3070854 	movw	r0, #30804	; 0x7854
  11bf34:	e3400014 	movt	r0, #20
  11bf38:	ebffbc4f 	bl	10b07c <sys_arch_assert>
  pbuf_free(p);
  11bf3c:	e51b0010 	ldr	r0, [fp, #-16]
  11bf40:	ebfffc5b 	bl	11b0b4 <pbuf_free>
  return q;
  11bf44:	e51b3008 	ldr	r3, [fp, #-8]
}
  11bf48:	e1a00003 	mov	r0, r3
  11bf4c:	e24bd004 	sub	sp, fp, #4
  11bf50:	e8bd8800 	pop	{fp, pc}

0011bf54 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(const struct pbuf* p, u16_t offset)
{
  11bf54:	e92d4800 	push	{fp, lr}
  11bf58:	e28db004 	add	fp, sp, #4
  11bf5c:	e24dd010 	sub	sp, sp, #16
  11bf60:	e50b0010 	str	r0, [fp, #-16]
  11bf64:	e1a03001 	mov	r3, r1
  11bf68:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  int ret = pbuf_try_get_at(p, offset);
  11bf6c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11bf70:	e1a01003 	mov	r1, r3
  11bf74:	e51b0010 	ldr	r0, [fp, #-16]
  11bf78:	eb00000a 	bl	11bfa8 <pbuf_try_get_at>
  11bf7c:	e50b0008 	str	r0, [fp, #-8]
  if (ret >= 0) {
  11bf80:	e51b3008 	ldr	r3, [fp, #-8]
  11bf84:	e3530000 	cmp	r3, #0
  11bf88:	ba000002 	blt	11bf98 <pbuf_get_at+0x44>
    return (u8_t)ret;
  11bf8c:	e51b3008 	ldr	r3, [fp, #-8]
  11bf90:	e6ef3073 	uxtb	r3, r3
  11bf94:	ea000000 	b	11bf9c <pbuf_get_at+0x48>
  }
  return 0;
  11bf98:	e3a03000 	mov	r3, #0
}
  11bf9c:	e1a00003 	mov	r0, r3
  11bfa0:	e24bd004 	sub	sp, fp, #4
  11bfa4:	e8bd8800 	pop	{fp, pc}

0011bfa8 <pbuf_try_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p [0..0xFF] OR negative if 'offset' >= p->tot_len
 */
int
pbuf_try_get_at(const struct pbuf* p, u16_t offset)
{
  11bfa8:	e92d4800 	push	{fp, lr}
  11bfac:	e28db004 	add	fp, sp, #4
  11bfb0:	e24dd010 	sub	sp, sp, #16
  11bfb4:	e50b0010 	str	r0, [fp, #-16]
  11bfb8:	e1a03001 	mov	r3, r1
  11bfbc:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  u16_t q_idx;
  const struct pbuf* q = pbuf_skip_const(p, offset, &q_idx);
  11bfc0:	e24b200a 	sub	r2, fp, #10
  11bfc4:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11bfc8:	e1a01003 	mov	r1, r3
  11bfcc:	e51b0010 	ldr	r0, [fp, #-16]
  11bfd0:	ebfffeb2 	bl	11baa0 <pbuf_skip_const>
  11bfd4:	e50b0008 	str	r0, [fp, #-8]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
  11bfd8:	e51b3008 	ldr	r3, [fp, #-8]
  11bfdc:	e3530000 	cmp	r3, #0
  11bfe0:	0a00000a 	beq	11c010 <pbuf_try_get_at+0x68>
  11bfe4:	e51b3008 	ldr	r3, [fp, #-8]
  11bfe8:	e1d320ba 	ldrh	r2, [r3, #10]
  11bfec:	e15b30ba 	ldrh	r3, [fp, #-10]
  11bff0:	e1520003 	cmp	r2, r3
  11bff4:	9a000005 	bls	11c010 <pbuf_try_get_at+0x68>
    return ((u8_t*)q->payload)[q_idx];
  11bff8:	e51b3008 	ldr	r3, [fp, #-8]
  11bffc:	e5933004 	ldr	r3, [r3, #4]
  11c000:	e15b20ba 	ldrh	r2, [fp, #-10]
  11c004:	e0833002 	add	r3, r3, r2
  11c008:	e5d33000 	ldrb	r3, [r3]
  11c00c:	ea000000 	b	11c014 <pbuf_try_get_at+0x6c>
  }
  return -1;
  11c010:	e3e03000 	mvn	r3, #0
}
  11c014:	e1a00003 	mov	r0, r3
  11c018:	e24bd004 	sub	sp, fp, #4
  11c01c:	e8bd8800 	pop	{fp, pc}

0011c020 <pbuf_put_at>:
 * @param offset offset into p of the byte to write
 * @param data byte to write at an offset into p
 */
void
pbuf_put_at(struct pbuf* p, u16_t offset, u8_t data)
{
  11c020:	e92d4800 	push	{fp, lr}
  11c024:	e28db004 	add	fp, sp, #4
  11c028:	e24dd010 	sub	sp, sp, #16
  11c02c:	e50b0010 	str	r0, [fp, #-16]
  11c030:	e1a03001 	mov	r3, r1
  11c034:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  11c038:	e1a03002 	mov	r3, r2
  11c03c:	e54b3013 	strb	r3, [fp, #-19]	; 0xffffffed
  u16_t q_idx;
  struct pbuf* q = pbuf_skip(p, offset, &q_idx);
  11c040:	e24b200a 	sub	r2, fp, #10
  11c044:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11c048:	e1a01003 	mov	r1, r3
  11c04c:	e51b0010 	ldr	r0, [fp, #-16]
  11c050:	ebfffeb9 	bl	11bb3c <pbuf_skip>
  11c054:	e50b0008 	str	r0, [fp, #-8]

  /* write requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
  11c058:	e51b3008 	ldr	r3, [fp, #-8]
  11c05c:	e3530000 	cmp	r3, #0
  11c060:	0a00000a 	beq	11c090 <pbuf_put_at+0x70>
  11c064:	e51b3008 	ldr	r3, [fp, #-8]
  11c068:	e1d320ba 	ldrh	r2, [r3, #10]
  11c06c:	e15b30ba 	ldrh	r3, [fp, #-10]
  11c070:	e1520003 	cmp	r2, r3
  11c074:	9a000005 	bls	11c090 <pbuf_put_at+0x70>
    ((u8_t*)q->payload)[q_idx] = data;
  11c078:	e51b3008 	ldr	r3, [fp, #-8]
  11c07c:	e5933004 	ldr	r3, [r3, #4]
  11c080:	e15b20ba 	ldrh	r2, [fp, #-10]
  11c084:	e0833002 	add	r3, r3, r2
  11c088:	e55b2013 	ldrb	r2, [fp, #-19]	; 0xffffffed
  11c08c:	e5c32000 	strb	r2, [r3]
  }
}
  11c090:	e320f000 	nop	{0}
  11c094:	e24bd004 	sub	sp, fp, #4
  11c098:	e8bd8800 	pop	{fp, pc}

0011c09c <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(const struct pbuf* p, u16_t offset, const void* s2, u16_t n)
{
  11c09c:	e92d4800 	push	{fp, lr}
  11c0a0:	e28db004 	add	fp, sp, #4
  11c0a4:	e24dd020 	sub	sp, sp, #32
  11c0a8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  11c0ac:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  11c0b0:	e1a02003 	mov	r2, r3
  11c0b4:	e1a03001 	mov	r3, r1
  11c0b8:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
  11c0bc:	e1a03002 	mov	r3, r2
  11c0c0:	e14b31bc 	strh	r3, [fp, #-28]	; 0xffffffe4
  u16_t start = offset;
  11c0c4:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  11c0c8:	e14b30b6 	strh	r3, [fp, #-6]
  const struct pbuf* q = p;
  11c0cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11c0d0:	e50b300c 	str	r3, [fp, #-12]
  u16_t i;
 
  /* pbuf long enough to perform check? */
  if(p->tot_len < (offset + n)) {
  11c0d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11c0d8:	e1d330b8 	ldrh	r3, [r3, #8]
  11c0dc:	e1a01003 	mov	r1, r3
  11c0e0:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
  11c0e4:	e15b31bc 	ldrh	r3, [fp, #-28]	; 0xffffffe4
  11c0e8:	e0823003 	add	r3, r2, r3
  11c0ec:	e1510003 	cmp	r1, r3
  11c0f0:	aa000009 	bge	11c11c <pbuf_memcmp+0x80>
    return 0xffff;
  11c0f4:	e30f3fff 	movw	r3, #65535	; 0xffff
  11c0f8:	ea000030 	b	11c1c0 <pbuf_memcmp+0x124>
  }
 
  /* get the correct pbuf from chain. We know it succeeds because of p->tot_len check above. */
  while ((q != NULL) && (q->len <= start)) {
    start -= q->len;
  11c0fc:	e51b300c 	ldr	r3, [fp, #-12]
  11c100:	e1d330ba 	ldrh	r3, [r3, #10]
  11c104:	e15b20b6 	ldrh	r2, [fp, #-6]
  11c108:	e0423003 	sub	r3, r2, r3
  11c10c:	e14b30b6 	strh	r3, [fp, #-6]
    q = q->next;
  11c110:	e51b300c 	ldr	r3, [fp, #-12]
  11c114:	e5933000 	ldr	r3, [r3]
  11c118:	e50b300c 	str	r3, [fp, #-12]
  while ((q != NULL) && (q->len <= start)) {
  11c11c:	e51b300c 	ldr	r3, [fp, #-12]
  11c120:	e3530000 	cmp	r3, #0
  11c124:	0a000004 	beq	11c13c <pbuf_memcmp+0xa0>
  11c128:	e51b300c 	ldr	r3, [fp, #-12]
  11c12c:	e1d330ba 	ldrh	r3, [r3, #10]
  11c130:	e15b20b6 	ldrh	r2, [fp, #-6]
  11c134:	e1520003 	cmp	r2, r3
  11c138:	2affffef 	bcs	11c0fc <pbuf_memcmp+0x60>
  }
 
  /* return requested data if pbuf is OK */
  for (i = 0; i < n; i++) {
  11c13c:	e3a03000 	mov	r3, #0
  11c140:	e14b30be 	strh	r3, [fp, #-14]
  11c144:	ea000018 	b	11c1ac <pbuf_memcmp+0x110>
    /* We know pbuf_get_at() succeeds because of p->tot_len check above. */
    u8_t a = pbuf_get_at(q, start + i);
  11c148:	e15b20b6 	ldrh	r2, [fp, #-6]
  11c14c:	e15b30be 	ldrh	r3, [fp, #-14]
  11c150:	e0823003 	add	r3, r2, r3
  11c154:	e6ff3073 	uxth	r3, r3
  11c158:	e1a01003 	mov	r1, r3
  11c15c:	e51b000c 	ldr	r0, [fp, #-12]
  11c160:	ebffff7b 	bl	11bf54 <pbuf_get_at>
  11c164:	e1a03000 	mov	r3, r0
  11c168:	e54b300f 	strb	r3, [fp, #-15]
    u8_t b = ((const u8_t*)s2)[i];
  11c16c:	e15b30be 	ldrh	r3, [fp, #-14]
  11c170:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  11c174:	e0823003 	add	r3, r2, r3
  11c178:	e5d33000 	ldrb	r3, [r3]
  11c17c:	e54b3010 	strb	r3, [fp, #-16]
    if (a != b) {
  11c180:	e55b200f 	ldrb	r2, [fp, #-15]
  11c184:	e55b3010 	ldrb	r3, [fp, #-16]
  11c188:	e1520003 	cmp	r2, r3
  11c18c:	0a000003 	beq	11c1a0 <pbuf_memcmp+0x104>
      return i+1;
  11c190:	e15b30be 	ldrh	r3, [fp, #-14]
  11c194:	e2833001 	add	r3, r3, #1
  11c198:	e6ff3073 	uxth	r3, r3
  11c19c:	ea000007 	b	11c1c0 <pbuf_memcmp+0x124>
  for (i = 0; i < n; i++) {
  11c1a0:	e15b30be 	ldrh	r3, [fp, #-14]
  11c1a4:	e2833001 	add	r3, r3, #1
  11c1a8:	e14b30be 	strh	r3, [fp, #-14]
  11c1ac:	e15b20be 	ldrh	r2, [fp, #-14]
  11c1b0:	e15b31bc 	ldrh	r3, [fp, #-28]	; 0xffffffe4
  11c1b4:	e1520003 	cmp	r2, r3
  11c1b8:	3affffe2 	bcc	11c148 <pbuf_memcmp+0xac>
    }
  }
  return 0;
  11c1bc:	e3a03000 	mov	r3, #0
}
  11c1c0:	e1a00003 	mov	r0, r3
  11c1c4:	e24bd004 	sub	sp, fp, #4
  11c1c8:	e8bd8800 	pop	{fp, pc}

0011c1cc <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(const struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  11c1cc:	e92d4800 	push	{fp, lr}
  11c1d0:	e28db004 	add	fp, sp, #4
  11c1d4:	e24dd018 	sub	sp, sp, #24
  11c1d8:	e50b0010 	str	r0, [fp, #-16]
  11c1dc:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  11c1e0:	e1a01002 	mov	r1, r2
  11c1e4:	e1a02003 	mov	r2, r3
  11c1e8:	e1a03001 	mov	r3, r1
  11c1ec:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  11c1f0:	e1a03002 	mov	r3, r2
  11c1f4:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  11c1f8:	e51b3010 	ldr	r3, [fp, #-16]
  11c1fc:	e1d320b8 	ldrh	r2, [r3, #8]
  11c200:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  11c204:	e0423003 	sub	r3, r2, r3
  11c208:	e14b30b8 	strh	r3, [fp, #-8]
  if (p->tot_len >= mem_len + start_offset) {
  11c20c:	e51b3010 	ldr	r3, [fp, #-16]
  11c210:	e1d330b8 	ldrh	r3, [r3, #8]
  11c214:	e1a01003 	mov	r1, r3
  11c218:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  11c21c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
  11c220:	e0823003 	add	r3, r2, r3
  11c224:	e1510003 	cmp	r1, r3
  11c228:	ba000015 	blt	11c284 <pbuf_memfind+0xb8>
    for (i = start_offset; i <= max; i++) {
  11c22c:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
  11c230:	e14b30b6 	strh	r3, [fp, #-6]
  11c234:	ea00000e 	b	11c274 <pbuf_memfind+0xa8>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
  11c238:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  11c23c:	e15b10b6 	ldrh	r1, [fp, #-6]
  11c240:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  11c244:	e51b0010 	ldr	r0, [fp, #-16]
  11c248:	ebffff93 	bl	11c09c <pbuf_memcmp>
  11c24c:	e1a03000 	mov	r3, r0
  11c250:	e14b30ba 	strh	r3, [fp, #-10]
      if (plus == 0) {
  11c254:	e15b30ba 	ldrh	r3, [fp, #-10]
  11c258:	e3530000 	cmp	r3, #0
  11c25c:	1a000001 	bne	11c268 <pbuf_memfind+0x9c>
        return i;
  11c260:	e15b30b6 	ldrh	r3, [fp, #-6]
  11c264:	ea000007 	b	11c288 <pbuf_memfind+0xbc>
    for (i = start_offset; i <= max; i++) {
  11c268:	e15b30b6 	ldrh	r3, [fp, #-6]
  11c26c:	e2833001 	add	r3, r3, #1
  11c270:	e14b30b6 	strh	r3, [fp, #-6]
  11c274:	e15b20b6 	ldrh	r2, [fp, #-6]
  11c278:	e15b30b8 	ldrh	r3, [fp, #-8]
  11c27c:	e1520003 	cmp	r2, r3
  11c280:	9affffec 	bls	11c238 <pbuf_memfind+0x6c>
      }
    }
  }
  return 0xFFFF;
  11c284:	e30f3fff 	movw	r3, #65535	; 0xffff
}
  11c288:	e1a00003 	mov	r0, r3
  11c28c:	e24bd004 	sub	sp, fp, #4
  11c290:	e8bd8800 	pop	{fp, pc}

0011c294 <pbuf_strstr>:
 * @param substr string to search for in p, maximum length is 0xFFFE
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_strstr(const struct pbuf* p, const char* substr)
{
  11c294:	e92d4800 	push	{fp, lr}
  11c298:	e28db004 	add	fp, sp, #4
  11c29c:	e24dd010 	sub	sp, sp, #16
  11c2a0:	e50b0010 	str	r0, [fp, #-16]
  11c2a4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
  11c2a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11c2ac:	e3530000 	cmp	r3, #0
  11c2b0:	0a000008 	beq	11c2d8 <pbuf_strstr+0x44>
  11c2b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11c2b8:	e5d33000 	ldrb	r3, [r3]
  11c2bc:	e3530000 	cmp	r3, #0
  11c2c0:	0a000004 	beq	11c2d8 <pbuf_strstr+0x44>
  11c2c4:	e51b3010 	ldr	r3, [fp, #-16]
  11c2c8:	e1d330b8 	ldrh	r3, [r3, #8]
  11c2cc:	e30f2fff 	movw	r2, #65535	; 0xffff
  11c2d0:	e1530002 	cmp	r3, r2
  11c2d4:	1a000001 	bne	11c2e0 <pbuf_strstr+0x4c>
    return 0xFFFF;
  11c2d8:	e30f3fff 	movw	r3, #65535	; 0xffff
  11c2dc:	ea00000f 	b	11c320 <pbuf_strstr+0x8c>
  }
  substr_len = strlen(substr);
  11c2e0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  11c2e4:	eb0094f3 	bl	1416b8 <strlen>
  11c2e8:	e50b0008 	str	r0, [fp, #-8]
  if (substr_len >= 0xFFFF) {
  11c2ec:	e51b3008 	ldr	r3, [fp, #-8]
  11c2f0:	e30f2ffe 	movw	r2, #65534	; 0xfffe
  11c2f4:	e1530002 	cmp	r3, r2
  11c2f8:	9a000001 	bls	11c304 <pbuf_strstr+0x70>
    return 0xFFFF;
  11c2fc:	e30f3fff 	movw	r3, #65535	; 0xffff
  11c300:	ea000006 	b	11c320 <pbuf_strstr+0x8c>
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
  11c304:	e51b3008 	ldr	r3, [fp, #-8]
  11c308:	e6ff2073 	uxth	r2, r3
  11c30c:	e3a03000 	mov	r3, #0
  11c310:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  11c314:	e51b0010 	ldr	r0, [fp, #-16]
  11c318:	ebffffab 	bl	11c1cc <pbuf_memfind>
  11c31c:	e1a03000 	mov	r3, r0
}
  11c320:	e1a00003 	mov	r0, r3
  11c324:	e24bd004 	sub	sp, fp, #4
  11c328:	e8bd8800 	pop	{fp, pc}

0011c32c <raw_input_match>:
/** The list of RAW PCBs */
static struct raw_pcb *raw_pcbs;

static u8_t
raw_input_match(struct raw_pcb *pcb, u8_t broadcast)
{
  11c32c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11c330:	e28db000 	add	fp, sp, #0
  11c334:	e24dd00c 	sub	sp, sp, #12
  11c338:	e50b0008 	str	r0, [fp, #-8]
  11c33c:	e1a03001 	mov	r3, r1
  11c340:	e54b3009 	strb	r3, [fp, #-9]
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: receive all broadcasts
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
  11c344:	e55b3009 	ldrb	r3, [fp, #-9]
  11c348:	e3530000 	cmp	r3, #0
  11c34c:	0a00000d 	beq	11c388 <raw_input_match+0x5c>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
  11c350:	e51b3008 	ldr	r3, [fp, #-8]
  11c354:	e5d33008 	ldrb	r3, [r3, #8]
  11c358:	e2033020 	and	r3, r3, #32
  11c35c:	e3530000 	cmp	r3, #0
  11c360:	0a000018 	beq	11c3c8 <raw_input_match+0x9c>
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip))) {
  11c364:	e51b3008 	ldr	r3, [fp, #-8]
  11c368:	e3530000 	cmp	r3, #0
  11c36c:	0a000003 	beq	11c380 <raw_input_match+0x54>
  11c370:	e51b3008 	ldr	r3, [fp, #-8]
  11c374:	e5933000 	ldr	r3, [r3]
  11c378:	e3530000 	cmp	r3, #0
  11c37c:	1a000011 	bne	11c3c8 <raw_input_match+0x9c>
          return 1;
  11c380:	e3a03001 	mov	r3, #1
  11c384:	ea000010 	b	11c3cc <raw_input_match+0xa0>
        }
      }
    } else
#endif /* LWIP_IPV4 */
    /* Handle IPv4 and IPv6: catch all or exact match */
    if (ip_addr_isany(&pcb->local_ip) ||
  11c388:	e51b3008 	ldr	r3, [fp, #-8]
  11c38c:	e3530000 	cmp	r3, #0
  11c390:	0a00000a 	beq	11c3c0 <raw_input_match+0x94>
  11c394:	e51b3008 	ldr	r3, [fp, #-8]
  11c398:	e5933000 	ldr	r3, [r3]
  11c39c:	e3530000 	cmp	r3, #0
  11c3a0:	0a000006 	beq	11c3c0 <raw_input_match+0x94>
       ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
  11c3a4:	e51b3008 	ldr	r3, [fp, #-8]
  11c3a8:	e5932000 	ldr	r2, [r3]
  11c3ac:	e30035e8 	movw	r3, #1512	; 0x5e8
  11c3b0:	e3403015 	movt	r3, #21
  11c3b4:	e5933014 	ldr	r3, [r3, #20]
    if (ip_addr_isany(&pcb->local_ip) ||
  11c3b8:	e1520003 	cmp	r2, r3
  11c3bc:	1a000001 	bne	11c3c8 <raw_input_match+0x9c>
      return 1;
  11c3c0:	e3a03001 	mov	r3, #1
  11c3c4:	ea000000 	b	11c3cc <raw_input_match+0xa0>
    }
  }

  return 0;
  11c3c8:	e3a03000 	mov	r3, #0
}
  11c3cc:	e1a00003 	mov	r0, r3
  11c3d0:	e28bd000 	add	sp, fp, #0
  11c3d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11c3d8:	e12fff1e 	bx	lr

0011c3dc <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  11c3dc:	e92d4810 	push	{r4, fp, lr}
  11c3e0:	e28db008 	add	fp, sp, #8
  11c3e4:	e24dd01c 	sub	sp, sp, #28
  11c3e8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  11c3ec:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  struct raw_pcb *pcb, *prev;
  s16_t proto;
  u8_t eaten = 0;
  11c3f0:	e3a03000 	mov	r3, #0
  11c3f4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
  u8_t broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
  11c3f8:	e30035e8 	movw	r3, #1512	; 0x5e8
  11c3fc:	e3403015 	movt	r3, #21
  11c400:	e5932014 	ldr	r2, [r3, #20]
  11c404:	e30035e8 	movw	r3, #1512	; 0x5e8
  11c408:	e3403015 	movt	r3, #21
  11c40c:	e5933000 	ldr	r3, [r3]
  11c410:	e1a01003 	mov	r1, r3
  11c414:	e1a00002 	mov	r0, r2
  11c418:	eb0058bb 	bl	13270c <ip4_addr_isbroadcast_u32>
  11c41c:	e1a03000 	mov	r3, r0
  11c420:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    proto = IPH_PROTO((struct ip_hdr *)p->payload);
  11c424:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c428:	e5933004 	ldr	r3, [r3, #4]
  11c42c:	e5d33009 	ldrb	r3, [r3, #9]
  11c430:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
  }
#endif /* LWIP_IPV4 */

  prev = NULL;
  11c434:	e3a03000 	mov	r3, #0
  11c438:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  pcb = raw_pcbs;
  11c43c:	e30f3218 	movw	r3, #61976	; 0xf218
  11c440:	e3403014 	movt	r3, #20
  11c444:	e5933000 	ldr	r3, [r3]
  11c448:	e50b3010 	str	r3, [fp, #-16]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  11c44c:	ea000046 	b	11c56c <raw_input+0x190>
    if ((pcb->protocol == proto) && raw_input_match(pcb, broadcast)) {
  11c450:	e51b3010 	ldr	r3, [fp, #-16]
  11c454:	e5d33010 	ldrb	r3, [r3, #16]
  11c458:	e1a02003 	mov	r2, r3
  11c45c:	e15b31f8 	ldrsh	r3, [fp, #-24]	; 0xffffffe8
  11c460:	e1520003 	cmp	r2, r3
  11c464:	1a00003b 	bne	11c558 <raw_input+0x17c>
  11c468:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
  11c46c:	e1a01003 	mov	r1, r3
  11c470:	e51b0010 	ldr	r0, [fp, #-16]
  11c474:	ebffffac 	bl	11c32c <raw_input_match>
  11c478:	e1a03000 	mov	r3, r0
  11c47c:	e3530000 	cmp	r3, #0
  11c480:	0a000034 	beq	11c558 <raw_input+0x17c>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  11c484:	e51b3010 	ldr	r3, [fp, #-16]
  11c488:	e5933014 	ldr	r3, [r3, #20]
  11c48c:	e3530000 	cmp	r3, #0
  11c490:	0a000030 	beq	11c558 <raw_input+0x17c>
#ifndef LWIP_NOASSERT
        void* old_payload = p->payload;
  11c494:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c498:	e5933004 	ldr	r3, [r3, #4]
  11c49c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
#endif
        /* the receive callback function did not eat the packet? */
        eaten = pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr());
  11c4a0:	e51b3010 	ldr	r3, [fp, #-16]
  11c4a4:	e5934014 	ldr	r4, [r3, #20]
  11c4a8:	e51b3010 	ldr	r3, [fp, #-16]
  11c4ac:	e5930018 	ldr	r0, [r3, #24]
  11c4b0:	e59f30dc 	ldr	r3, [pc, #220]	; 11c594 <raw_input+0x1b8>
  11c4b4:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  11c4b8:	e51b1010 	ldr	r1, [fp, #-16]
  11c4bc:	e12fff34 	blx	r4
  11c4c0:	e1a03000 	mov	r3, r0
  11c4c4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
        if (eaten != 0) {
  11c4c8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  11c4cc:	e3530000 	cmp	r3, #0
  11c4d0:	0a000014 	beq	11c528 <raw_input+0x14c>
          /* receive function ate the packet */
          p = NULL;
  11c4d4:	e3a03000 	mov	r3, #0
  11c4d8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
          eaten = 1;
  11c4dc:	e3a03001 	mov	r3, #1
  11c4e0:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
          if (prev != NULL) {
  11c4e4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11c4e8:	e3530000 	cmp	r3, #0
  11c4ec:	0a000019 	beq	11c558 <raw_input+0x17c>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  11c4f0:	e51b3010 	ldr	r3, [fp, #-16]
  11c4f4:	e593200c 	ldr	r2, [r3, #12]
  11c4f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11c4fc:	e583200c 	str	r2, [r3, #12]
            pcb->next = raw_pcbs;
  11c500:	e30f3218 	movw	r3, #61976	; 0xf218
  11c504:	e3403014 	movt	r3, #20
  11c508:	e5932000 	ldr	r2, [r3]
  11c50c:	e51b3010 	ldr	r3, [fp, #-16]
  11c510:	e583200c 	str	r2, [r3, #12]
            raw_pcbs = pcb;
  11c514:	e30f3218 	movw	r3, #61976	; 0xf218
  11c518:	e3403014 	movt	r3, #20
  11c51c:	e51b2010 	ldr	r2, [fp, #-16]
  11c520:	e5832000 	str	r2, [r3]
  11c524:	ea00000b 	b	11c558 <raw_input+0x17c>
          }
        } else {
          /* sanity-check that the receive callback did not alter the pbuf */
          LWIP_ASSERT("raw pcb recv callback altered pbuf payload pointer without eating packet",
  11c528:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c52c:	e5933004 	ldr	r3, [r3, #4]
  11c530:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  11c534:	e1520003 	cmp	r2, r3
  11c538:	0a000006 	beq	11c558 <raw_input+0x17c>
  11c53c:	e3070d18 	movw	r0, #32024	; 0x7d18
  11c540:	e3400014 	movt	r0, #20
  11c544:	ebff9af2 	bl	103114 <rt_kprintf>
  11c548:	e3a010b6 	mov	r1, #182	; 0xb6
  11c54c:	e3070d64 	movw	r0, #32100	; 0x7d64
  11c550:	e3400014 	movt	r0, #20
  11c554:	ebffbac8 	bl	10b07c <sys_arch_assert>
        }
      }
      /* no receive callback function was set for this raw PCB */
    }
    /* drop the packet */
    prev = pcb;
  11c558:	e51b3010 	ldr	r3, [fp, #-16]
  11c55c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    pcb = pcb->next;
  11c560:	e51b3010 	ldr	r3, [fp, #-16]
  11c564:	e593300c 	ldr	r3, [r3, #12]
  11c568:	e50b3010 	str	r3, [fp, #-16]
  while ((eaten == 0) && (pcb != NULL)) {
  11c56c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  11c570:	e3530000 	cmp	r3, #0
  11c574:	1a000002 	bne	11c584 <raw_input+0x1a8>
  11c578:	e51b3010 	ldr	r3, [fp, #-16]
  11c57c:	e3530000 	cmp	r3, #0
  11c580:	1affffb2 	bne	11c450 <raw_input+0x74>
  }
  return eaten;
  11c584:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
}
  11c588:	e1a00003 	mov	r0, r3
  11c58c:	e24bd008 	sub	sp, fp, #8
  11c590:	e8bd8810 	pop	{r4, fp, pc}
  11c594:	001505f8 	.word	0x001505f8

0011c598 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, const ip_addr_t *ipaddr)
{
  11c598:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11c59c:	e28db000 	add	fp, sp, #0
  11c5a0:	e24dd00c 	sub	sp, sp, #12
  11c5a4:	e50b0008 	str	r0, [fp, #-8]
  11c5a8:	e50b100c 	str	r1, [fp, #-12]
  if ((pcb == NULL) || (ipaddr == NULL)) {
  11c5ac:	e51b3008 	ldr	r3, [fp, #-8]
  11c5b0:	e3530000 	cmp	r3, #0
  11c5b4:	0a000002 	beq	11c5c4 <raw_bind+0x2c>
  11c5b8:	e51b300c 	ldr	r3, [fp, #-12]
  11c5bc:	e3530000 	cmp	r3, #0
  11c5c0:	1a000001 	bne	11c5cc <raw_bind+0x34>
    return ERR_VAL;
  11c5c4:	e3e03005 	mvn	r3, #5
  11c5c8:	ea000009 	b	11c5f4 <raw_bind+0x5c>
  }
  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
  11c5cc:	e51b300c 	ldr	r3, [fp, #-12]
  11c5d0:	e3530000 	cmp	r3, #0
  11c5d4:	0a000002 	beq	11c5e4 <raw_bind+0x4c>
  11c5d8:	e51b300c 	ldr	r3, [fp, #-12]
  11c5dc:	e5933000 	ldr	r3, [r3]
  11c5e0:	ea000000 	b	11c5e8 <raw_bind+0x50>
  11c5e4:	e3a03000 	mov	r3, #0
  11c5e8:	e51b2008 	ldr	r2, [fp, #-8]
  11c5ec:	e5823000 	str	r3, [r2]
  return ERR_OK;
  11c5f0:	e3a03000 	mov	r3, #0
}
  11c5f4:	e1a00003 	mov	r0, r3
  11c5f8:	e28bd000 	add	sp, fp, #0
  11c5fc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11c600:	e12fff1e 	bx	lr

0011c604 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, const ip_addr_t *ipaddr)
{
  11c604:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11c608:	e28db000 	add	fp, sp, #0
  11c60c:	e24dd00c 	sub	sp, sp, #12
  11c610:	e50b0008 	str	r0, [fp, #-8]
  11c614:	e50b100c 	str	r1, [fp, #-12]
  if ((pcb == NULL) || (ipaddr == NULL)) {
  11c618:	e51b3008 	ldr	r3, [fp, #-8]
  11c61c:	e3530000 	cmp	r3, #0
  11c620:	0a000002 	beq	11c630 <raw_connect+0x2c>
  11c624:	e51b300c 	ldr	r3, [fp, #-12]
  11c628:	e3530000 	cmp	r3, #0
  11c62c:	1a000001 	bne	11c638 <raw_connect+0x34>
    return ERR_VAL;
  11c630:	e3e03005 	mvn	r3, #5
  11c634:	ea000009 	b	11c660 <raw_connect+0x5c>
  }
  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
  11c638:	e51b300c 	ldr	r3, [fp, #-12]
  11c63c:	e3530000 	cmp	r3, #0
  11c640:	0a000002 	beq	11c650 <raw_connect+0x4c>
  11c644:	e51b300c 	ldr	r3, [fp, #-12]
  11c648:	e5933000 	ldr	r3, [r3]
  11c64c:	ea000000 	b	11c654 <raw_connect+0x50>
  11c650:	e3a03000 	mov	r3, #0
  11c654:	e51b2008 	ldr	r2, [fp, #-8]
  11c658:	e5823004 	str	r3, [r2, #4]
  return ERR_OK;
  11c65c:	e3a03000 	mov	r3, #0
}
  11c660:	e1a00003 	mov	r0, r3
  11c664:	e28bd000 	add	sp, fp, #0
  11c668:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11c66c:	e12fff1e 	bx	lr

0011c670 <raw_recv>:
 * - not free the packet, and return zero. The packet will be matched
 *   against further PCBs and/or forwarded to another protocol layers.
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
  11c670:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11c674:	e28db000 	add	fp, sp, #0
  11c678:	e24dd014 	sub	sp, sp, #20
  11c67c:	e50b0008 	str	r0, [fp, #-8]
  11c680:	e50b100c 	str	r1, [fp, #-12]
  11c684:	e50b2010 	str	r2, [fp, #-16]
  /* remember recv() callback and user data */
  pcb->recv = recv;
  11c688:	e51b3008 	ldr	r3, [fp, #-8]
  11c68c:	e51b200c 	ldr	r2, [fp, #-12]
  11c690:	e5832014 	str	r2, [r3, #20]
  pcb->recv_arg = recv_arg;
  11c694:	e51b3008 	ldr	r3, [fp, #-8]
  11c698:	e51b2010 	ldr	r2, [fp, #-16]
  11c69c:	e5832018 	str	r2, [r3, #24]
}
  11c6a0:	e320f000 	nop	{0}
  11c6a4:	e28bd000 	add	sp, fp, #0
  11c6a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11c6ac:	e12fff1e 	bx	lr

0011c6b0 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *ipaddr)
{
  11c6b0:	e92d4800 	push	{fp, lr}
  11c6b4:	e28db004 	add	fp, sp, #4
  11c6b8:	e24dd038 	sub	sp, sp, #56	; 0x38
  11c6bc:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  11c6c0:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  11c6c4:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  struct netif *netif;
  const ip_addr_t *src_ip;
  struct pbuf *q; /* q will be sent down the stack */
  s16_t header_size;

  if ((pcb == NULL) || (ipaddr == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr)) {
  11c6c8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c6cc:	e3530000 	cmp	r3, #0
  11c6d0:	0a000002 	beq	11c6e0 <raw_sendto+0x30>
  11c6d4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11c6d8:	e3530000 	cmp	r3, #0
  11c6dc:	1a000001 	bne	11c6e8 <raw_sendto+0x38>
    return ERR_VAL;
  11c6e0:	e3e03005 	mvn	r3, #5
  11c6e4:	ea00007c 	b	11c8dc <raw_sendto+0x22c>
  }

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));

  header_size = (
  11c6e8:	e3a03014 	mov	r3, #20
  11c6ec:	e14b30be 	strh	r3, [fp, #-14]
#else
    IP6_HLEN);
#endif

  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, header_size)) {
  11c6f0:	e15b30fe 	ldrsh	r3, [fp, #-14]
  11c6f4:	e1a01003 	mov	r1, r3
  11c6f8:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  11c6fc:	ebfffa4e 	bl	11b03c <pbuf_header>
  11c700:	e1a03000 	mov	r3, r0
  11c704:	e3530000 	cmp	r3, #0
  11c708:	0a000011 	beq	11c754 <raw_sendto+0xa4>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  11c70c:	e3a02000 	mov	r2, #0
  11c710:	e3a01000 	mov	r1, #0
  11c714:	e3a00001 	mov	r0, #1
  11c718:	ebfff75e 	bl	11a498 <pbuf_alloc>
  11c71c:	e50b000c 	str	r0, [fp, #-12]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  11c720:	e51b300c 	ldr	r3, [fp, #-12]
  11c724:	e3530000 	cmp	r3, #0
  11c728:	1a000001 	bne	11c734 <raw_sendto+0x84>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  11c72c:	e3e03000 	mvn	r3, #0
  11c730:	ea000069 	b	11c8dc <raw_sendto+0x22c>
    }
    if (p->tot_len != 0) {
  11c734:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11c738:	e1d330b8 	ldrh	r3, [r3, #8]
  11c73c:	e3530000 	cmp	r3, #0
  11c740:	0a000018 	beq	11c7a8 <raw_sendto+0xf8>
      /* chain header q in front of given pbuf p */
      pbuf_chain(q, p);
  11c744:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  11c748:	e51b000c 	ldr	r0, [fp, #-12]
  11c74c:	ebfffb59 	bl	11b4b8 <pbuf_chain>
  11c750:	ea000014 	b	11c7a8 <raw_sendto+0xf8>
    }
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* first pbuf q equals given pbuf */
    q = p;
  11c754:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11c758:	e50b300c 	str	r3, [fp, #-12]
    if (pbuf_header(q, -header_size)) {
  11c75c:	e15b30be 	ldrh	r3, [fp, #-14]
  11c760:	e2633000 	rsb	r3, r3, #0
  11c764:	e6ff3073 	uxth	r3, r3
  11c768:	e6bf3073 	sxth	r3, r3
  11c76c:	e1a01003 	mov	r1, r3
  11c770:	e51b000c 	ldr	r0, [fp, #-12]
  11c774:	ebfffa30 	bl	11b03c <pbuf_header>
  11c778:	e1a03000 	mov	r3, r0
  11c77c:	e3530000 	cmp	r3, #0
  11c780:	0a000008 	beq	11c7a8 <raw_sendto+0xf8>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  11c784:	e3070d90 	movw	r0, #32144	; 0x7d90
  11c788:	e3400014 	movt	r0, #20
  11c78c:	ebff9a60 	bl	103114 <rt_kprintf>
  11c790:	e300113e 	movw	r1, #318	; 0x13e
  11c794:	e3070d64 	movw	r0, #32100	; 0x7d64
  11c798:	e3400014 	movt	r0, #20
  11c79c:	ebffba36 	bl	10b07c <sys_arch_assert>
      return ERR_MEM;
  11c7a0:	e3e03000 	mvn	r3, #0
  11c7a4:	ea00004c 	b	11c8dc <raw_sendto+0x22c>

  if(IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
    /* Don't call ip_route() with IP_ANY_TYPE */
    netif = ip_route(IP46_ADDR_ANY(IP_GET_TYPE(ipaddr)), ipaddr);
  } else {
    netif = ip_route(&pcb->local_ip, ipaddr);
  11c7a8:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  11c7ac:	eb0052f7 	bl	131390 <ip4_route>
  11c7b0:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  }

  if (netif == NULL) {
  11c7b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11c7b8:	e3530000 	cmp	r3, #0
  11c7bc:	1a000007 	bne	11c7e0 <raw_sendto+0x130>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to "));
    ip_addr_debug_print(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ipaddr);
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  11c7c0:	e51b200c 	ldr	r2, [fp, #-12]
  11c7c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11c7c8:	e1520003 	cmp	r2, r3
  11c7cc:	0a000001 	beq	11c7d8 <raw_sendto+0x128>
      pbuf_free(q);
  11c7d0:	e51b000c 	ldr	r0, [fp, #-12]
  11c7d4:	ebfffa36 	bl	11b0b4 <pbuf_free>
    }
    return ERR_RTE;
  11c7d8:	e3e03003 	mvn	r3, #3
  11c7dc:	ea00003e 	b	11c8dc <raw_sendto+0x22c>

#if IP_SOF_BROADCAST
  if (IP_IS_V4(ipaddr))
  {
    /* broadcast filter? */
    if (!ip_get_option(pcb, SOF_BROADCAST) && ip_addr_isbroadcast(ipaddr, netif)) {
  11c7e0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c7e4:	e5d33008 	ldrb	r3, [r3, #8]
  11c7e8:	e2033020 	and	r3, r3, #32
  11c7ec:	e3530000 	cmp	r3, #0
  11c7f0:	1a00000f 	bne	11c834 <raw_sendto+0x184>
  11c7f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11c7f8:	e5933000 	ldr	r3, [r3]
  11c7fc:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  11c800:	e1a00003 	mov	r0, r3
  11c804:	eb0057c0 	bl	13270c <ip4_addr_isbroadcast_u32>
  11c808:	e1a03000 	mov	r3, r0
  11c80c:	e3530000 	cmp	r3, #0
  11c810:	0a000007 	beq	11c834 <raw_sendto+0x184>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
      /* free any temporary header pbuf allocated by pbuf_header() */
      if (q != p) {
  11c814:	e51b200c 	ldr	r2, [fp, #-12]
  11c818:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11c81c:	e1520003 	cmp	r2, r3
  11c820:	0a000001 	beq	11c82c <raw_sendto+0x17c>
        pbuf_free(q);
  11c824:	e51b000c 	ldr	r0, [fp, #-12]
  11c828:	ebfffa21 	bl	11b0b4 <pbuf_free>
      }
      return ERR_VAL;
  11c82c:	e3e03005 	mvn	r3, #5
  11c830:	ea000029 	b	11c8dc <raw_sendto+0x22c>
    }
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
  11c834:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c838:	e3530000 	cmp	r3, #0
  11c83c:	0a000003 	beq	11c850 <raw_sendto+0x1a0>
  11c840:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c844:	e5933000 	ldr	r3, [r3]
  11c848:	e3530000 	cmp	r3, #0
  11c84c:	1a000008 	bne	11c874 <raw_sendto+0x1c4>
    /* use outgoing network interface IP address as source address */
    src_ip = ip_netif_get_local_ip(netif, ipaddr);
  11c850:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11c854:	e3530000 	cmp	r3, #0
  11c858:	0a000002 	beq	11c868 <raw_sendto+0x1b8>
  11c85c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11c860:	e2833004 	add	r3, r3, #4
  11c864:	ea000000 	b	11c86c <raw_sendto+0x1bc>
  11c868:	e3a03000 	mov	r3, #0
  11c86c:	e50b3008 	str	r3, [fp, #-8]
  11c870:	ea000001 	b	11c87c <raw_sendto+0x1cc>
      return ERR_RTE;
    }
#endif /* LWIP_IPV6 */
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &pcb->local_ip;
  11c874:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c878:	e50b3008 	str	r3, [fp, #-8]
    SMEMCPY(((u8_t *)p->payload) + pcb->chksum_offset, &chksum, sizeof(u16_t));
  }
#endif

  NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
  err = ip_output_if(q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  11c87c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c880:	e5d3000a 	ldrb	r0, [r3, #10]
  11c884:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11c888:	e5d33009 	ldrb	r3, [r3, #9]
  11c88c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  11c890:	e5d22010 	ldrb	r2, [r2, #16]
  11c894:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  11c898:	e58d1008 	str	r1, [sp, #8]
  11c89c:	e58d2004 	str	r2, [sp, #4]
  11c8a0:	e58d3000 	str	r3, [sp]
  11c8a4:	e1a03000 	mov	r3, r0
  11c8a8:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  11c8ac:	e51b1008 	ldr	r1, [fp, #-8]
  11c8b0:	e51b000c 	ldr	r0, [fp, #-12]
  11c8b4:	eb00558e 	bl	131ef4 <ip4_output_if>
  11c8b8:	e1a03000 	mov	r3, r0
  11c8bc:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
  NETIF_SET_HWADDRHINT(netif, NULL);

  /* did we chain a header earlier? */
  if (q != p) {
  11c8c0:	e51b200c 	ldr	r2, [fp, #-12]
  11c8c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  11c8c8:	e1520003 	cmp	r2, r3
  11c8cc:	0a000001 	beq	11c8d8 <raw_sendto+0x228>
    /* free the header */
    pbuf_free(q);
  11c8d0:	e51b000c 	ldr	r0, [fp, #-12]
  11c8d4:	ebfff9f6 	bl	11b0b4 <pbuf_free>
  }
  return err;
  11c8d8:	e15b31d5 	ldrsb	r3, [fp, #-21]	; 0xffffffeb
}
  11c8dc:	e1a00003 	mov	r0, r3
  11c8e0:	e24bd004 	sub	sp, fp, #4
  11c8e4:	e8bd8800 	pop	{fp, pc}

0011c8e8 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  11c8e8:	e92d4800 	push	{fp, lr}
  11c8ec:	e28db004 	add	fp, sp, #4
  11c8f0:	e24dd008 	sub	sp, sp, #8
  11c8f4:	e50b0008 	str	r0, [fp, #-8]
  11c8f8:	e50b100c 	str	r1, [fp, #-12]
  return raw_sendto(pcb, p, &pcb->remote_ip);
  11c8fc:	e51b3008 	ldr	r3, [fp, #-8]
  11c900:	e2833004 	add	r3, r3, #4
  11c904:	e1a02003 	mov	r2, r3
  11c908:	e51b100c 	ldr	r1, [fp, #-12]
  11c90c:	e51b0008 	ldr	r0, [fp, #-8]
  11c910:	ebffff66 	bl	11c6b0 <raw_sendto>
  11c914:	e1a03000 	mov	r3, r0
}
  11c918:	e1a00003 	mov	r0, r3
  11c91c:	e24bd004 	sub	sp, fp, #4
  11c920:	e8bd8800 	pop	{fp, pc}

0011c924 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  11c924:	e92d4800 	push	{fp, lr}
  11c928:	e28db004 	add	fp, sp, #4
  11c92c:	e24dd010 	sub	sp, sp, #16
  11c930:	e50b0010 	str	r0, [fp, #-16]
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  11c934:	e30f3218 	movw	r3, #61976	; 0xf218
  11c938:	e3403014 	movt	r3, #20
  11c93c:	e5933000 	ldr	r3, [r3]
  11c940:	e51b2010 	ldr	r2, [fp, #-16]
  11c944:	e1520003 	cmp	r2, r3
  11c948:	1a000007 	bne	11c96c <raw_remove+0x48>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  11c94c:	e30f3218 	movw	r3, #61976	; 0xf218
  11c950:	e3403014 	movt	r3, #20
  11c954:	e5933000 	ldr	r3, [r3]
  11c958:	e593200c 	ldr	r2, [r3, #12]
  11c95c:	e30f3218 	movw	r3, #61976	; 0xf218
  11c960:	e3403014 	movt	r3, #20
  11c964:	e5832000 	str	r2, [r3]
  11c968:	ea000018 	b	11c9d0 <raw_remove+0xac>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  11c96c:	e30f3218 	movw	r3, #61976	; 0xf218
  11c970:	e3403014 	movt	r3, #20
  11c974:	e5933000 	ldr	r3, [r3]
  11c978:	e50b3008 	str	r3, [fp, #-8]
  11c97c:	ea000010 	b	11c9c4 <raw_remove+0xa0>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  11c980:	e51b3008 	ldr	r3, [fp, #-8]
  11c984:	e593300c 	ldr	r3, [r3, #12]
  11c988:	e3530000 	cmp	r3, #0
  11c98c:	0a000009 	beq	11c9b8 <raw_remove+0x94>
  11c990:	e51b3008 	ldr	r3, [fp, #-8]
  11c994:	e593300c 	ldr	r3, [r3, #12]
  11c998:	e51b2010 	ldr	r2, [fp, #-16]
  11c99c:	e1520003 	cmp	r2, r3
  11c9a0:	1a000004 	bne	11c9b8 <raw_remove+0x94>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  11c9a4:	e51b3010 	ldr	r3, [fp, #-16]
  11c9a8:	e593200c 	ldr	r2, [r3, #12]
  11c9ac:	e51b3008 	ldr	r3, [fp, #-8]
  11c9b0:	e583200c 	str	r2, [r3, #12]
        break;
  11c9b4:	ea000005 	b	11c9d0 <raw_remove+0xac>
    for (pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  11c9b8:	e51b3008 	ldr	r3, [fp, #-8]
  11c9bc:	e593300c 	ldr	r3, [r3, #12]
  11c9c0:	e50b3008 	str	r3, [fp, #-8]
  11c9c4:	e51b3008 	ldr	r3, [fp, #-8]
  11c9c8:	e3530000 	cmp	r3, #0
  11c9cc:	1affffeb 	bne	11c980 <raw_remove+0x5c>
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  11c9d0:	e51b1010 	ldr	r1, [fp, #-16]
  11c9d4:	e3a00000 	mov	r0, #0
  11c9d8:	ebfff2a7 	bl	11947c <memp_free>
}
  11c9dc:	e320f000 	nop	{0}
  11c9e0:	e24bd004 	sub	sp, fp, #4
  11c9e4:	e8bd8800 	pop	{fp, pc}

0011c9e8 <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
  11c9e8:	e92d4800 	push	{fp, lr}
  11c9ec:	e28db004 	add	fp, sp, #4
  11c9f0:	e24dd010 	sub	sp, sp, #16
  11c9f4:	e1a03000 	mov	r3, r0
  11c9f8:	e54b300d 	strb	r3, [fp, #-13]
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
  11c9fc:	e3a02f72 	mov	r2, #456	; 0x1c8
  11ca00:	e3071d64 	movw	r1, #32100	; 0x7d64
  11ca04:	e3401014 	movt	r1, #20
  11ca08:	e3a00000 	mov	r0, #0
  11ca0c:	ebfff232 	bl	1192dc <memp_malloc_fn>
  11ca10:	e50b0008 	str	r0, [fp, #-8]
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  11ca14:	e51b3008 	ldr	r3, [fp, #-8]
  11ca18:	e3530000 	cmp	r3, #0
  11ca1c:	0a000012 	beq	11ca6c <raw_new+0x84>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  11ca20:	e3a0201c 	mov	r2, #28
  11ca24:	e3a01000 	mov	r1, #0
  11ca28:	e51b0008 	ldr	r0, [fp, #-8]
  11ca2c:	eb009290 	bl	141474 <memset>
    pcb->protocol = proto;
  11ca30:	e51b3008 	ldr	r3, [fp, #-8]
  11ca34:	e55b200d 	ldrb	r2, [fp, #-13]
  11ca38:	e5c32010 	strb	r2, [r3, #16]
    pcb->ttl = RAW_TTL;
  11ca3c:	e51b3008 	ldr	r3, [fp, #-8]
  11ca40:	e3e02000 	mvn	r2, #0
  11ca44:	e5c3200a 	strb	r2, [r3, #10]
    pcb->next = raw_pcbs;
  11ca48:	e30f3218 	movw	r3, #61976	; 0xf218
  11ca4c:	e3403014 	movt	r3, #20
  11ca50:	e5932000 	ldr	r2, [r3]
  11ca54:	e51b3008 	ldr	r3, [fp, #-8]
  11ca58:	e583200c 	str	r2, [r3, #12]
    raw_pcbs = pcb;
  11ca5c:	e30f3218 	movw	r3, #61976	; 0xf218
  11ca60:	e3403014 	movt	r3, #20
  11ca64:	e51b2008 	ldr	r2, [fp, #-8]
  11ca68:	e5832000 	str	r2, [r3]
  }
  return pcb;
  11ca6c:	e51b3008 	ldr	r3, [fp, #-8]
}
  11ca70:	e1a00003 	mov	r0, r3
  11ca74:	e24bd004 	sub	sp, fp, #4
  11ca78:	e8bd8800 	pop	{fp, pc}

0011ca7c <raw_new_ip_type>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new_ip_type(u8_t type, u8_t proto)
{
  11ca7c:	e92d4800 	push	{fp, lr}
  11ca80:	e28db004 	add	fp, sp, #4
  11ca84:	e24dd010 	sub	sp, sp, #16
  11ca88:	e1a03000 	mov	r3, r0
  11ca8c:	e1a02001 	mov	r2, r1
  11ca90:	e54b300d 	strb	r3, [fp, #-13]
  11ca94:	e1a03002 	mov	r3, r2
  11ca98:	e54b300e 	strb	r3, [fp, #-14]
  struct raw_pcb *pcb;
  pcb = raw_new(proto);
  11ca9c:	e55b300e 	ldrb	r3, [fp, #-14]
  11caa0:	e1a00003 	mov	r0, r3
  11caa4:	ebffffcf 	bl	11c9e8 <raw_new>
  11caa8:	e50b0008 	str	r0, [fp, #-8]
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else /* LWIP_IPV4 && LWIP_IPV6 */
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
  11caac:	e51b3008 	ldr	r3, [fp, #-8]
}
  11cab0:	e1a00003 	mov	r0, r3
  11cab4:	e24bd004 	sub	sp, fp, #4
  11cab8:	e8bd8800 	pop	{fp, pc}

0011cabc <raw_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void raw_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
  11cabc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11cac0:	e28db000 	add	fp, sp, #0
  11cac4:	e24dd014 	sub	sp, sp, #20
  11cac8:	e50b0010 	str	r0, [fp, #-16]
  11cacc:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct raw_pcb* rpcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
  11cad0:	e51b3010 	ldr	r3, [fp, #-16]
  11cad4:	e3530000 	cmp	r3, #0
  11cad8:	0a00001f 	beq	11cb5c <raw_netif_ip_addr_changed+0xa0>
  11cadc:	e51b3010 	ldr	r3, [fp, #-16]
  11cae0:	e5933000 	ldr	r3, [r3]
  11cae4:	e3530000 	cmp	r3, #0
  11cae8:	0a00001b 	beq	11cb5c <raw_netif_ip_addr_changed+0xa0>
  11caec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11caf0:	e3530000 	cmp	r3, #0
  11caf4:	0a000018 	beq	11cb5c <raw_netif_ip_addr_changed+0xa0>
  11caf8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11cafc:	e5933000 	ldr	r3, [r3]
  11cb00:	e3530000 	cmp	r3, #0
  11cb04:	0a000014 	beq	11cb5c <raw_netif_ip_addr_changed+0xa0>
    for (rpcb = raw_pcbs; rpcb != NULL; rpcb = rpcb->next) {
  11cb08:	e30f3218 	movw	r3, #61976	; 0xf218
  11cb0c:	e3403014 	movt	r3, #20
  11cb10:	e5933000 	ldr	r3, [r3]
  11cb14:	e50b3008 	str	r3, [fp, #-8]
  11cb18:	ea00000c 	b	11cb50 <raw_netif_ip_addr_changed+0x94>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&rpcb->local_ip, old_addr)) {
  11cb1c:	e51b3008 	ldr	r3, [fp, #-8]
  11cb20:	e5932000 	ldr	r2, [r3]
  11cb24:	e51b3010 	ldr	r3, [fp, #-16]
  11cb28:	e5933000 	ldr	r3, [r3]
  11cb2c:	e1520003 	cmp	r2, r3
  11cb30:	1a000003 	bne	11cb44 <raw_netif_ip_addr_changed+0x88>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(rpcb->local_ip, *new_addr);
  11cb34:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11cb38:	e5932000 	ldr	r2, [r3]
  11cb3c:	e51b3008 	ldr	r3, [fp, #-8]
  11cb40:	e5832000 	str	r2, [r3]
    for (rpcb = raw_pcbs; rpcb != NULL; rpcb = rpcb->next) {
  11cb44:	e51b3008 	ldr	r3, [fp, #-8]
  11cb48:	e593300c 	ldr	r3, [r3, #12]
  11cb4c:	e50b3008 	str	r3, [fp, #-8]
  11cb50:	e51b3008 	ldr	r3, [fp, #-8]
  11cb54:	e3530000 	cmp	r3, #0
  11cb58:	1affffef 	bne	11cb1c <raw_netif_ip_addr_changed+0x60>
      }
    }
  }
}
  11cb5c:	e320f000 	nop	{0}
  11cb60:	e28bd000 	add	sp, fp, #0
  11cb64:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11cb68:	e12fff1e 	bx	lr

0011cb6c <stats_init>:

struct stats_ lwip_stats;

void
stats_init(void)
{
  11cb6c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11cb70:	e28db000 	add	fp, sp, #0
#ifdef LWIP_DEBUG
#if MEM_STATS
  lwip_stats.mem.name = "MEM";
#endif /* MEM_STATS */
#endif /* LWIP_DEBUG */
}
  11cb74:	e320f000 	nop	{0}
  11cb78:	e28bd000 	add	sp, fp, #0
  11cb7c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11cb80:	e12fff1e 	bx	lr

0011cb84 <stats_display_proto>:

#if LWIP_STATS_DISPLAY
void
stats_display_proto(struct stats_proto *proto, const char *name)
{
  11cb84:	e92d4800 	push	{fp, lr}
  11cb88:	e28db004 	add	fp, sp, #4
  11cb8c:	e24dd008 	sub	sp, sp, #8
  11cb90:	e50b0008 	str	r0, [fp, #-8]
  11cb94:	e50b100c 	str	r1, [fp, #-12]
  LWIP_PLATFORM_DIAG(("\n%s\n\t", name));
  11cb98:	e51b100c 	ldr	r1, [fp, #-12]
  11cb9c:	e3070db8 	movw	r0, #32184	; 0x7db8
  11cba0:	e3400014 	movt	r0, #20
  11cba4:	ebff995a 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("xmit: %"STAT_COUNTER_F"\n\t", proto->xmit));
  11cba8:	e51b3008 	ldr	r3, [fp, #-8]
  11cbac:	e1d330b0 	ldrh	r3, [r3]
  11cbb0:	e1a01003 	mov	r1, r3
  11cbb4:	e3070dc0 	movw	r0, #32192	; 0x7dc0
  11cbb8:	e3400014 	movt	r0, #20
  11cbbc:	ebff9954 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("recv: %"STAT_COUNTER_F"\n\t", proto->recv));
  11cbc0:	e51b3008 	ldr	r3, [fp, #-8]
  11cbc4:	e1d330b2 	ldrh	r3, [r3, #2]
  11cbc8:	e1a01003 	mov	r1, r3
  11cbcc:	e3070dcc 	movw	r0, #32204	; 0x7dcc
  11cbd0:	e3400014 	movt	r0, #20
  11cbd4:	ebff994e 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("fw: %"STAT_COUNTER_F"\n\t", proto->fw));
  11cbd8:	e51b3008 	ldr	r3, [fp, #-8]
  11cbdc:	e1d330b4 	ldrh	r3, [r3, #4]
  11cbe0:	e1a01003 	mov	r1, r3
  11cbe4:	e3070dd8 	movw	r0, #32216	; 0x7dd8
  11cbe8:	e3400014 	movt	r0, #20
  11cbec:	ebff9948 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("drop: %"STAT_COUNTER_F"\n\t", proto->drop));
  11cbf0:	e51b3008 	ldr	r3, [fp, #-8]
  11cbf4:	e1d330b6 	ldrh	r3, [r3, #6]
  11cbf8:	e1a01003 	mov	r1, r3
  11cbfc:	e3070de4 	movw	r0, #32228	; 0x7de4
  11cc00:	e3400014 	movt	r0, #20
  11cc04:	ebff9942 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("chkerr: %"STAT_COUNTER_F"\n\t", proto->chkerr));
  11cc08:	e51b3008 	ldr	r3, [fp, #-8]
  11cc0c:	e1d330b8 	ldrh	r3, [r3, #8]
  11cc10:	e1a01003 	mov	r1, r3
  11cc14:	e3070df0 	movw	r0, #32240	; 0x7df0
  11cc18:	e3400014 	movt	r0, #20
  11cc1c:	ebff993c 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("lenerr: %"STAT_COUNTER_F"\n\t", proto->lenerr));
  11cc20:	e51b3008 	ldr	r3, [fp, #-8]
  11cc24:	e1d330ba 	ldrh	r3, [r3, #10]
  11cc28:	e1a01003 	mov	r1, r3
  11cc2c:	e3070e00 	movw	r0, #32256	; 0x7e00
  11cc30:	e3400014 	movt	r0, #20
  11cc34:	ebff9936 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("memerr: %"STAT_COUNTER_F"\n\t", proto->memerr));
  11cc38:	e51b3008 	ldr	r3, [fp, #-8]
  11cc3c:	e1d330bc 	ldrh	r3, [r3, #12]
  11cc40:	e1a01003 	mov	r1, r3
  11cc44:	e3070e10 	movw	r0, #32272	; 0x7e10
  11cc48:	e3400014 	movt	r0, #20
  11cc4c:	ebff9930 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("rterr: %"STAT_COUNTER_F"\n\t", proto->rterr));
  11cc50:	e51b3008 	ldr	r3, [fp, #-8]
  11cc54:	e1d330be 	ldrh	r3, [r3, #14]
  11cc58:	e1a01003 	mov	r1, r3
  11cc5c:	e3070e20 	movw	r0, #32288	; 0x7e20
  11cc60:	e3400014 	movt	r0, #20
  11cc64:	ebff992a 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("proterr: %"STAT_COUNTER_F"\n\t", proto->proterr));
  11cc68:	e51b3008 	ldr	r3, [fp, #-8]
  11cc6c:	e1d331b0 	ldrh	r3, [r3, #16]
  11cc70:	e1a01003 	mov	r1, r3
  11cc74:	e3070e30 	movw	r0, #32304	; 0x7e30
  11cc78:	e3400014 	movt	r0, #20
  11cc7c:	ebff9924 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("opterr: %"STAT_COUNTER_F"\n\t", proto->opterr));
  11cc80:	e51b3008 	ldr	r3, [fp, #-8]
  11cc84:	e1d331b2 	ldrh	r3, [r3, #18]
  11cc88:	e1a01003 	mov	r1, r3
  11cc8c:	e3070e40 	movw	r0, #32320	; 0x7e40
  11cc90:	e3400014 	movt	r0, #20
  11cc94:	ebff991e 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("err: %"STAT_COUNTER_F"\n\t", proto->err));
  11cc98:	e51b3008 	ldr	r3, [fp, #-8]
  11cc9c:	e1d331b4 	ldrh	r3, [r3, #20]
  11cca0:	e1a01003 	mov	r1, r3
  11cca4:	e3070e50 	movw	r0, #32336	; 0x7e50
  11cca8:	e3400014 	movt	r0, #20
  11ccac:	ebff9918 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("cachehit: %"STAT_COUNTER_F"\n", proto->cachehit));
  11ccb0:	e51b3008 	ldr	r3, [fp, #-8]
  11ccb4:	e1d331b6 	ldrh	r3, [r3, #22]
  11ccb8:	e1a01003 	mov	r1, r3
  11ccbc:	e3070e5c 	movw	r0, #32348	; 0x7e5c
  11ccc0:	e3400014 	movt	r0, #20
  11ccc4:	ebff9912 	bl	103114 <rt_kprintf>
}
  11ccc8:	e320f000 	nop	{0}
  11cccc:	e24bd004 	sub	sp, fp, #4
  11ccd0:	e8bd8800 	pop	{fp, pc}

0011ccd4 <stats_display_igmp>:

#if IGMP_STATS || MLD6_STATS
void
stats_display_igmp(struct stats_igmp *igmp, const char *name)
{
  11ccd4:	e92d4800 	push	{fp, lr}
  11ccd8:	e28db004 	add	fp, sp, #4
  11ccdc:	e24dd008 	sub	sp, sp, #8
  11cce0:	e50b0008 	str	r0, [fp, #-8]
  11cce4:	e50b100c 	str	r1, [fp, #-12]
  LWIP_PLATFORM_DIAG(("\n%s\n\t", name));
  11cce8:	e51b100c 	ldr	r1, [fp, #-12]
  11ccec:	e3070db8 	movw	r0, #32184	; 0x7db8
  11ccf0:	e3400014 	movt	r0, #20
  11ccf4:	ebff9906 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("xmit: %"STAT_COUNTER_F"\n\t", igmp->xmit));
  11ccf8:	e51b3008 	ldr	r3, [fp, #-8]
  11ccfc:	e1d330b0 	ldrh	r3, [r3]
  11cd00:	e1a01003 	mov	r1, r3
  11cd04:	e3070dc0 	movw	r0, #32192	; 0x7dc0
  11cd08:	e3400014 	movt	r0, #20
  11cd0c:	ebff9900 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("recv: %"STAT_COUNTER_F"\n\t", igmp->recv));
  11cd10:	e51b3008 	ldr	r3, [fp, #-8]
  11cd14:	e1d330b2 	ldrh	r3, [r3, #2]
  11cd18:	e1a01003 	mov	r1, r3
  11cd1c:	e3070dcc 	movw	r0, #32204	; 0x7dcc
  11cd20:	e3400014 	movt	r0, #20
  11cd24:	ebff98fa 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("drop: %"STAT_COUNTER_F"\n\t", igmp->drop));
  11cd28:	e51b3008 	ldr	r3, [fp, #-8]
  11cd2c:	e1d330b4 	ldrh	r3, [r3, #4]
  11cd30:	e1a01003 	mov	r1, r3
  11cd34:	e3070de4 	movw	r0, #32228	; 0x7de4
  11cd38:	e3400014 	movt	r0, #20
  11cd3c:	ebff98f4 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("chkerr: %"STAT_COUNTER_F"\n\t", igmp->chkerr));
  11cd40:	e51b3008 	ldr	r3, [fp, #-8]
  11cd44:	e1d330b6 	ldrh	r3, [r3, #6]
  11cd48:	e1a01003 	mov	r1, r3
  11cd4c:	e3070df0 	movw	r0, #32240	; 0x7df0
  11cd50:	e3400014 	movt	r0, #20
  11cd54:	ebff98ee 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("lenerr: %"STAT_COUNTER_F"\n\t", igmp->lenerr));
  11cd58:	e51b3008 	ldr	r3, [fp, #-8]
  11cd5c:	e1d330b8 	ldrh	r3, [r3, #8]
  11cd60:	e1a01003 	mov	r1, r3
  11cd64:	e3070e00 	movw	r0, #32256	; 0x7e00
  11cd68:	e3400014 	movt	r0, #20
  11cd6c:	ebff98e8 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("memerr: %"STAT_COUNTER_F"\n\t", igmp->memerr));
  11cd70:	e51b3008 	ldr	r3, [fp, #-8]
  11cd74:	e1d330ba 	ldrh	r3, [r3, #10]
  11cd78:	e1a01003 	mov	r1, r3
  11cd7c:	e3070e10 	movw	r0, #32272	; 0x7e10
  11cd80:	e3400014 	movt	r0, #20
  11cd84:	ebff98e2 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("proterr: %"STAT_COUNTER_F"\n\t", igmp->proterr));
  11cd88:	e51b3008 	ldr	r3, [fp, #-8]
  11cd8c:	e1d330bc 	ldrh	r3, [r3, #12]
  11cd90:	e1a01003 	mov	r1, r3
  11cd94:	e3070e30 	movw	r0, #32304	; 0x7e30
  11cd98:	e3400014 	movt	r0, #20
  11cd9c:	ebff98dc 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("rx_v1: %"STAT_COUNTER_F"\n\t", igmp->rx_v1));
  11cda0:	e51b3008 	ldr	r3, [fp, #-8]
  11cda4:	e1d330be 	ldrh	r3, [r3, #14]
  11cda8:	e1a01003 	mov	r1, r3
  11cdac:	e3070e6c 	movw	r0, #32364	; 0x7e6c
  11cdb0:	e3400014 	movt	r0, #20
  11cdb4:	ebff98d6 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("rx_group: %"STAT_COUNTER_F"\n\t", igmp->rx_group));
  11cdb8:	e51b3008 	ldr	r3, [fp, #-8]
  11cdbc:	e1d331b0 	ldrh	r3, [r3, #16]
  11cdc0:	e1a01003 	mov	r1, r3
  11cdc4:	e3070e7c 	movw	r0, #32380	; 0x7e7c
  11cdc8:	e3400014 	movt	r0, #20
  11cdcc:	ebff98d0 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("rx_general: %"STAT_COUNTER_F"\n\t", igmp->rx_general));
  11cdd0:	e51b3008 	ldr	r3, [fp, #-8]
  11cdd4:	e1d331b2 	ldrh	r3, [r3, #18]
  11cdd8:	e1a01003 	mov	r1, r3
  11cddc:	e3070e8c 	movw	r0, #32396	; 0x7e8c
  11cde0:	e3400014 	movt	r0, #20
  11cde4:	ebff98ca 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("rx_report: %"STAT_COUNTER_F"\n\t", igmp->rx_report));
  11cde8:	e51b3008 	ldr	r3, [fp, #-8]
  11cdec:	e1d331b4 	ldrh	r3, [r3, #20]
  11cdf0:	e1a01003 	mov	r1, r3
  11cdf4:	e3070ea0 	movw	r0, #32416	; 0x7ea0
  11cdf8:	e3400014 	movt	r0, #20
  11cdfc:	ebff98c4 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("tx_join: %"STAT_COUNTER_F"\n\t", igmp->tx_join));
  11ce00:	e51b3008 	ldr	r3, [fp, #-8]
  11ce04:	e1d331b6 	ldrh	r3, [r3, #22]
  11ce08:	e1a01003 	mov	r1, r3
  11ce0c:	e3070eb4 	movw	r0, #32436	; 0x7eb4
  11ce10:	e3400014 	movt	r0, #20
  11ce14:	ebff98be 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("tx_leave: %"STAT_COUNTER_F"\n\t", igmp->tx_leave));
  11ce18:	e51b3008 	ldr	r3, [fp, #-8]
  11ce1c:	e1d331b8 	ldrh	r3, [r3, #24]
  11ce20:	e1a01003 	mov	r1, r3
  11ce24:	e3070ec4 	movw	r0, #32452	; 0x7ec4
  11ce28:	e3400014 	movt	r0, #20
  11ce2c:	ebff98b8 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("tx_report: %"STAT_COUNTER_F"\n", igmp->tx_report));
  11ce30:	e51b3008 	ldr	r3, [fp, #-8]
  11ce34:	e1d331ba 	ldrh	r3, [r3, #26]
  11ce38:	e1a01003 	mov	r1, r3
  11ce3c:	e3070ed4 	movw	r0, #32468	; 0x7ed4
  11ce40:	e3400014 	movt	r0, #20
  11ce44:	ebff98b2 	bl	103114 <rt_kprintf>
}
  11ce48:	e320f000 	nop	{0}
  11ce4c:	e24bd004 	sub	sp, fp, #4
  11ce50:	e8bd8800 	pop	{fp, pc}

0011ce54 <stats_display_mem>:
#endif /* IGMP_STATS || MLD6_STATS */

#if MEM_STATS || MEMP_STATS
void
stats_display_mem(struct stats_mem *mem, const char *name)
{
  11ce54:	e92d4800 	push	{fp, lr}
  11ce58:	e28db004 	add	fp, sp, #4
  11ce5c:	e24dd008 	sub	sp, sp, #8
  11ce60:	e50b0008 	str	r0, [fp, #-8]
  11ce64:	e50b100c 	str	r1, [fp, #-12]
  LWIP_PLATFORM_DIAG(("\nMEM %s\n\t", name));
  11ce68:	e51b100c 	ldr	r1, [fp, #-12]
  11ce6c:	e3070ee4 	movw	r0, #32484	; 0x7ee4
  11ce70:	e3400014 	movt	r0, #20
  11ce74:	ebff98a6 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("avail: %"U32_F"\n\t", (u32_t)mem->avail));
  11ce78:	e51b3008 	ldr	r3, [fp, #-8]
  11ce7c:	e1d330b6 	ldrh	r3, [r3, #6]
  11ce80:	e1a01003 	mov	r1, r3
  11ce84:	e3070ef0 	movw	r0, #32496	; 0x7ef0
  11ce88:	e3400014 	movt	r0, #20
  11ce8c:	ebff98a0 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("used: %"U32_F"\n\t", (u32_t)mem->used));
  11ce90:	e51b3008 	ldr	r3, [fp, #-8]
  11ce94:	e1d330b8 	ldrh	r3, [r3, #8]
  11ce98:	e1a01003 	mov	r1, r3
  11ce9c:	e3070f00 	movw	r0, #32512	; 0x7f00
  11cea0:	e3400014 	movt	r0, #20
  11cea4:	ebff989a 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("max: %"U32_F"\n\t", (u32_t)mem->max));
  11cea8:	e51b3008 	ldr	r3, [fp, #-8]
  11ceac:	e1d330ba 	ldrh	r3, [r3, #10]
  11ceb0:	e1a01003 	mov	r1, r3
  11ceb4:	e3070f0c 	movw	r0, #32524	; 0x7f0c
  11ceb8:	e3400014 	movt	r0, #20
  11cebc:	ebff9894 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("err: %"U32_F"\n", (u32_t)mem->err));
  11cec0:	e51b3008 	ldr	r3, [fp, #-8]
  11cec4:	e1d330b4 	ldrh	r3, [r3, #4]
  11cec8:	e1a01003 	mov	r1, r3
  11cecc:	e3070f18 	movw	r0, #32536	; 0x7f18
  11ced0:	e3400014 	movt	r0, #20
  11ced4:	ebff988e 	bl	103114 <rt_kprintf>
}
  11ced8:	e320f000 	nop	{0}
  11cedc:	e24bd004 	sub	sp, fp, #4
  11cee0:	e8bd8800 	pop	{fp, pc}

0011cee4 <stats_display_memp>:

#if MEMP_STATS
void
stats_display_memp(struct stats_mem *mem, int index)
{
  11cee4:	e92d4800 	push	{fp, lr}
  11cee8:	e28db004 	add	fp, sp, #4
  11ceec:	e24dd008 	sub	sp, sp, #8
  11cef0:	e50b0008 	str	r0, [fp, #-8]
  11cef4:	e50b100c 	str	r1, [fp, #-12]
  if (index < MEMP_MAX) {
  11cef8:	e51b300c 	ldr	r3, [fp, #-12]
  11cefc:	e3530010 	cmp	r3, #16
  11cf00:	ca000004 	bgt	11cf18 <stats_display_memp+0x34>
    stats_display_mem(mem, mem->name);
  11cf04:	e51b3008 	ldr	r3, [fp, #-8]
  11cf08:	e5933000 	ldr	r3, [r3]
  11cf0c:	e1a01003 	mov	r1, r3
  11cf10:	e51b0008 	ldr	r0, [fp, #-8]
  11cf14:	ebffffce 	bl	11ce54 <stats_display_mem>
  }
}
  11cf18:	e320f000 	nop	{0}
  11cf1c:	e24bd004 	sub	sp, fp, #4
  11cf20:	e8bd8800 	pop	{fp, pc}

0011cf24 <stats_display_sys>:
#endif /* MEM_STATS || MEMP_STATS */

#if SYS_STATS
void
stats_display_sys(struct stats_sys *sys)
{
  11cf24:	e92d4800 	push	{fp, lr}
  11cf28:	e28db004 	add	fp, sp, #4
  11cf2c:	e24dd008 	sub	sp, sp, #8
  11cf30:	e50b0008 	str	r0, [fp, #-8]
  LWIP_PLATFORM_DIAG(("\nSYS\n\t"));
  11cf34:	e3070f24 	movw	r0, #32548	; 0x7f24
  11cf38:	e3400014 	movt	r0, #20
  11cf3c:	ebff9874 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("sem.used:  %"U32_F"\n\t", (u32_t)sys->sem.used));
  11cf40:	e51b3008 	ldr	r3, [fp, #-8]
  11cf44:	e1d330b0 	ldrh	r3, [r3]
  11cf48:	e1a01003 	mov	r1, r3
  11cf4c:	e3070f2c 	movw	r0, #32556	; 0x7f2c
  11cf50:	e3400014 	movt	r0, #20
  11cf54:	ebff986e 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("sem.max:   %"U32_F"\n\t", (u32_t)sys->sem.max));
  11cf58:	e51b3008 	ldr	r3, [fp, #-8]
  11cf5c:	e1d330b2 	ldrh	r3, [r3, #2]
  11cf60:	e1a01003 	mov	r1, r3
  11cf64:	e3070f40 	movw	r0, #32576	; 0x7f40
  11cf68:	e3400014 	movt	r0, #20
  11cf6c:	ebff9868 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("sem.err:   %"U32_F"\n\t", (u32_t)sys->sem.err));
  11cf70:	e51b3008 	ldr	r3, [fp, #-8]
  11cf74:	e1d330b4 	ldrh	r3, [r3, #4]
  11cf78:	e1a01003 	mov	r1, r3
  11cf7c:	e3070f54 	movw	r0, #32596	; 0x7f54
  11cf80:	e3400014 	movt	r0, #20
  11cf84:	ebff9862 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("mutex.used: %"U32_F"\n\t", (u32_t)sys->mutex.used));
  11cf88:	e51b3008 	ldr	r3, [fp, #-8]
  11cf8c:	e1d330b6 	ldrh	r3, [r3, #6]
  11cf90:	e1a01003 	mov	r1, r3
  11cf94:	e3070f68 	movw	r0, #32616	; 0x7f68
  11cf98:	e3400014 	movt	r0, #20
  11cf9c:	ebff985c 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("mutex.max:  %"U32_F"\n\t", (u32_t)sys->mutex.max));
  11cfa0:	e51b3008 	ldr	r3, [fp, #-8]
  11cfa4:	e1d330b8 	ldrh	r3, [r3, #8]
  11cfa8:	e1a01003 	mov	r1, r3
  11cfac:	e3070f7c 	movw	r0, #32636	; 0x7f7c
  11cfb0:	e3400014 	movt	r0, #20
  11cfb4:	ebff9856 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("mutex.err:  %"U32_F"\n\t", (u32_t)sys->mutex.err));
  11cfb8:	e51b3008 	ldr	r3, [fp, #-8]
  11cfbc:	e1d330ba 	ldrh	r3, [r3, #10]
  11cfc0:	e1a01003 	mov	r1, r3
  11cfc4:	e3070f90 	movw	r0, #32656	; 0x7f90
  11cfc8:	e3400014 	movt	r0, #20
  11cfcc:	ebff9850 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("mbox.used:  %"U32_F"\n\t", (u32_t)sys->mbox.used));
  11cfd0:	e51b3008 	ldr	r3, [fp, #-8]
  11cfd4:	e1d330bc 	ldrh	r3, [r3, #12]
  11cfd8:	e1a01003 	mov	r1, r3
  11cfdc:	e3070fa4 	movw	r0, #32676	; 0x7fa4
  11cfe0:	e3400014 	movt	r0, #20
  11cfe4:	ebff984a 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("mbox.max:   %"U32_F"\n\t", (u32_t)sys->mbox.max));
  11cfe8:	e51b3008 	ldr	r3, [fp, #-8]
  11cfec:	e1d330be 	ldrh	r3, [r3, #14]
  11cff0:	e1a01003 	mov	r1, r3
  11cff4:	e3070fb8 	movw	r0, #32696	; 0x7fb8
  11cff8:	e3400014 	movt	r0, #20
  11cffc:	ebff9844 	bl	103114 <rt_kprintf>
  LWIP_PLATFORM_DIAG(("mbox.err:   %"U32_F"\n", (u32_t)sys->mbox.err));
  11d000:	e51b3008 	ldr	r3, [fp, #-8]
  11d004:	e1d331b0 	ldrh	r3, [r3, #16]
  11d008:	e1a01003 	mov	r1, r3
  11d00c:	e3070fcc 	movw	r0, #32716	; 0x7fcc
  11d010:	e3400014 	movt	r0, #20
  11d014:	ebff983e 	bl	103114 <rt_kprintf>
}
  11d018:	e320f000 	nop	{0}
  11d01c:	e24bd004 	sub	sp, fp, #4
  11d020:	e8bd8800 	pop	{fp, pc}

0011d024 <stats_display>:
#endif /* SYS_STATS */

void
stats_display(void)
{
  11d024:	e92d4800 	push	{fp, lr}
  11d028:	e28db004 	add	fp, sp, #4
  11d02c:	e24dd008 	sub	sp, sp, #8
  s16_t i;

  LINK_STATS_DISPLAY();
  11d030:	e3071fe0 	movw	r1, #32736	; 0x7fe0
  11d034:	e3401014 	movt	r1, #20
  11d038:	e3060840 	movw	r0, #26688	; 0x6840
  11d03c:	e3400057 	movt	r0, #87	; 0x57
  11d040:	ebfffecf 	bl	11cb84 <stats_display_proto>
  ETHARP_STATS_DISPLAY();
  11d044:	e3071fe8 	movw	r1, #32744	; 0x7fe8
  11d048:	e3401014 	movt	r1, #20
  11d04c:	e59f00dc 	ldr	r0, [pc, #220]	; 11d130 <stats_display+0x10c>
  11d050:	ebfffecb 	bl	11cb84 <stats_display_proto>
  IPFRAG_STATS_DISPLAY();
  11d054:	e3071ff0 	movw	r1, #32752	; 0x7ff0
  11d058:	e3401014 	movt	r1, #20
  11d05c:	e59f00d0 	ldr	r0, [pc, #208]	; 11d134 <stats_display+0x110>
  11d060:	ebfffec7 	bl	11cb84 <stats_display_proto>
  IP6_FRAG_STATS_DISPLAY();
  IP_STATS_DISPLAY();
  11d064:	e3071ff8 	movw	r1, #32760	; 0x7ff8
  11d068:	e3401014 	movt	r1, #20
  11d06c:	e59f00c4 	ldr	r0, [pc, #196]	; 11d138 <stats_display+0x114>
  11d070:	ebfffec3 	bl	11cb84 <stats_display_proto>
  ND6_STATS_DISPLAY();
  IP6_STATS_DISPLAY();
  IGMP_STATS_DISPLAY();
  11d074:	e3071ffc 	movw	r1, #32764	; 0x7ffc
  11d078:	e3401014 	movt	r1, #20
  11d07c:	e59f00b8 	ldr	r0, [pc, #184]	; 11d13c <stats_display+0x118>
  11d080:	ebffff13 	bl	11ccd4 <stats_display_igmp>
  MLD6_STATS_DISPLAY();
  ICMP_STATS_DISPLAY();
  11d084:	e3081004 	movw	r1, #32772	; 0x8004
  11d088:	e3401014 	movt	r1, #20
  11d08c:	e59f00ac 	ldr	r0, [pc, #172]	; 11d140 <stats_display+0x11c>
  11d090:	ebfffebb 	bl	11cb84 <stats_display_proto>
  ICMP6_STATS_DISPLAY();
  UDP_STATS_DISPLAY();
  11d094:	e308100c 	movw	r1, #32780	; 0x800c
  11d098:	e3401014 	movt	r1, #20
  11d09c:	e59f00a0 	ldr	r0, [pc, #160]	; 11d144 <stats_display+0x120>
  11d0a0:	ebfffeb7 	bl	11cb84 <stats_display_proto>
  TCP_STATS_DISPLAY();
  11d0a4:	e3081010 	movw	r1, #32784	; 0x8010
  11d0a8:	e3401014 	movt	r1, #20
  11d0ac:	e59f0094 	ldr	r0, [pc, #148]	; 11d148 <stats_display+0x124>
  11d0b0:	ebfffeb3 	bl	11cb84 <stats_display_proto>
  MEM_STATS_DISPLAY();
  11d0b4:	e3081014 	movw	r1, #32788	; 0x8014
  11d0b8:	e3401014 	movt	r1, #20
  11d0bc:	e59f0088 	ldr	r0, [pc, #136]	; 11d14c <stats_display+0x128>
  11d0c0:	ebffff63 	bl	11ce54 <stats_display_mem>
  for (i = 0; i < MEMP_MAX; i++) {
  11d0c4:	e3a03000 	mov	r3, #0
  11d0c8:	e14b30b6 	strh	r3, [fp, #-6]
  11d0cc:	ea00000f 	b	11d110 <stats_display+0xec>
    MEMP_STATS_DISPLAY(i);
  11d0d0:	e15b30f6 	ldrsh	r3, [fp, #-6]
  11d0d4:	e3062840 	movw	r2, #26688	; 0x6840
  11d0d8:	e3402057 	movt	r2, #87	; 0x57
  11d0dc:	e2833034 	add	r3, r3, #52	; 0x34
  11d0e0:	e1a03103 	lsl	r3, r3, #2
  11d0e4:	e0823003 	add	r3, r2, r3
  11d0e8:	e5933004 	ldr	r3, [r3, #4]
  11d0ec:	e15b20f6 	ldrsh	r2, [fp, #-6]
  11d0f0:	e1a01002 	mov	r1, r2
  11d0f4:	e1a00003 	mov	r0, r3
  11d0f8:	ebffff79 	bl	11cee4 <stats_display_memp>
  for (i = 0; i < MEMP_MAX; i++) {
  11d0fc:	e15b30f6 	ldrsh	r3, [fp, #-6]
  11d100:	e6ff3073 	uxth	r3, r3
  11d104:	e2833001 	add	r3, r3, #1
  11d108:	e6ff3073 	uxth	r3, r3
  11d10c:	e14b30b6 	strh	r3, [fp, #-6]
  11d110:	e15b30f6 	ldrsh	r3, [fp, #-6]
  11d114:	e3530010 	cmp	r3, #16
  11d118:	daffffec 	ble	11d0d0 <stats_display+0xac>
  }
  SYS_STATS_DISPLAY();
  11d11c:	e59f002c 	ldr	r0, [pc, #44]	; 11d150 <stats_display+0x12c>
  11d120:	ebffff7f 	bl	11cf24 <stats_display_sys>
}
  11d124:	e320f000 	nop	{0}
  11d128:	e24bd004 	sub	sp, fp, #4
  11d12c:	e8bd8800 	pop	{fp, pc}
  11d130:	00576858 	.word	0x00576858
  11d134:	00576870 	.word	0x00576870
  11d138:	00576888 	.word	0x00576888
  11d13c:	005768b8 	.word	0x005768b8
  11d140:	005768a0 	.word	0x005768a0
  11d144:	005768d4 	.word	0x005768d4
  11d148:	005768ec 	.word	0x005768ec
  11d14c:	00576904 	.word	0x00576904
  11d150:	00576958 	.word	0x00576958

0011d154 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  11d154:	e92d4800 	push	{fp, lr}
  11d158:	e28db004 	add	fp, sp, #4
  11d15c:	e24dd010 	sub	sp, sp, #16
  11d160:	e50b0010 	str	r0, [fp, #-16]
  if (ms > 0) {
  11d164:	e51b3010 	ldr	r3, [fp, #-16]
  11d168:	e3530000 	cmp	r3, #0
  11d16c:	0a00000f 	beq	11d1b0 <sys_msleep+0x5c>
    sys_sem_t delaysem;
    err_t err = sys_sem_new(&delaysem, 0);
  11d170:	e24b300c 	sub	r3, fp, #12
  11d174:	e3a01000 	mov	r1, #0
  11d178:	e1a00003 	mov	r0, r3
  11d17c:	ebffb52c 	bl	10a634 <sys_sem_new>
  11d180:	e1a03000 	mov	r3, r0
  11d184:	e54b3005 	strb	r3, [fp, #-5]
    if (err == ERR_OK) {
  11d188:	e15b30d5 	ldrsb	r3, [fp, #-5]
  11d18c:	e3530000 	cmp	r3, #0
  11d190:	1a000006 	bne	11d1b0 <sys_msleep+0x5c>
      sys_arch_sem_wait(&delaysem, ms);
  11d194:	e24b300c 	sub	r3, fp, #12
  11d198:	e51b1010 	ldr	r1, [fp, #-16]
  11d19c:	e1a00003 	mov	r0, r3
  11d1a0:	ebffb564 	bl	10a738 <sys_arch_sem_wait>
      sys_sem_free(&delaysem);
  11d1a4:	e24b300c 	sub	r3, fp, #12
  11d1a8:	e1a00003 	mov	r0, r3
  11d1ac:	ebffb54b 	bl	10a6e0 <sys_sem_free>
    }
  }
}
  11d1b0:	e320f000 	nop	{0}
  11d1b4:	e24bd004 	sub	sp, fp, #4
  11d1b8:	e8bd8800 	pop	{fp, pc}

0011d1bc <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
  11d1bc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11d1c0:	e28db000 	add	fp, sp, #0
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
  11d1c4:	e320f000 	nop	{0}
  11d1c8:	e28bd000 	add	sp, fp, #0
  11d1cc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11d1d0:	e12fff1e 	bx	lr

0011d1d4 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
  11d1d4:	e92d4800 	push	{fp, lr}
  11d1d8:	e28db004 	add	fp, sp, #4
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  11d1dc:	eb000847 	bl	11f300 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  11d1e0:	e30f321c 	movw	r3, #61980	; 0xf21c
  11d1e4:	e3403014 	movt	r3, #20
  11d1e8:	e5d33000 	ldrb	r3, [r3]
  11d1ec:	e2833001 	add	r3, r3, #1
  11d1f0:	e6ef2073 	uxtb	r2, r3
  11d1f4:	e30f321c 	movw	r3, #61980	; 0xf21c
  11d1f8:	e3403014 	movt	r3, #20
  11d1fc:	e5c32000 	strb	r2, [r3]
  11d200:	e30f321c 	movw	r3, #61980	; 0xf21c
  11d204:	e3403014 	movt	r3, #20
  11d208:	e5d33000 	ldrb	r3, [r3]
  11d20c:	e2033001 	and	r3, r3, #1
  11d210:	e3530000 	cmp	r3, #0
  11d214:	0a000000 	beq	11d21c <tcp_tmr+0x48>
    /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  11d218:	eb0005c8 	bl	11e940 <tcp_slowtmr>
  }
}
  11d21c:	e320f000 	nop	{0}
  11d220:	e8bd8800 	pop	{fp, pc}

0011d224 <tcp_remove_listener>:
/** Called when a listen pcb is closed. Iterates one pcb list and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
  11d224:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11d228:	e28db000 	add	fp, sp, #0
  11d22c:	e24dd014 	sub	sp, sp, #20
  11d230:	e50b0010 	str	r0, [fp, #-16]
  11d234:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
   struct tcp_pcb *pcb;
   for (pcb = list; pcb != NULL; pcb = pcb->next) {
  11d238:	e51b3010 	ldr	r3, [fp, #-16]
  11d23c:	e50b3008 	str	r3, [fp, #-8]
  11d240:	ea00000a 	b	11d270 <tcp_remove_listener+0x4c>
      if (pcb->listener == lpcb) {
  11d244:	e51b3008 	ldr	r3, [fp, #-8]
  11d248:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  11d24c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  11d250:	e1520003 	cmp	r2, r3
  11d254:	1a000002 	bne	11d264 <tcp_remove_listener+0x40>
         pcb->listener = NULL;
  11d258:	e51b3008 	ldr	r3, [fp, #-8]
  11d25c:	e3a02000 	mov	r2, #0
  11d260:	e583207c 	str	r2, [r3, #124]	; 0x7c
   for (pcb = list; pcb != NULL; pcb = pcb->next) {
  11d264:	e51b3008 	ldr	r3, [fp, #-8]
  11d268:	e593300c 	ldr	r3, [r3, #12]
  11d26c:	e50b3008 	str	r3, [fp, #-8]
  11d270:	e51b3008 	ldr	r3, [fp, #-8]
  11d274:	e3530000 	cmp	r3, #0
  11d278:	1afffff1 	bne	11d244 <tcp_remove_listener+0x20>
      }
   }
}
  11d27c:	e320f000 	nop	{0}
  11d280:	e28bd000 	add	sp, fp, #0
  11d284:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11d288:	e12fff1e 	bx	lr

0011d28c <tcp_listen_closed>:
/** Called when a listen pcb is closed. Iterates all pcb lists and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_listen_closed(struct tcp_pcb *pcb)
{
  11d28c:	e92d4800 	push	{fp, lr}
  11d290:	e28db004 	add	fp, sp, #4
  11d294:	e24dd010 	sub	sp, sp, #16
  11d298:	e50b0010 	str	r0, [fp, #-16]
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
  size_t i;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
  11d29c:	e51b3010 	ldr	r3, [fp, #-16]
  11d2a0:	e3530000 	cmp	r3, #0
  11d2a4:	1a000006 	bne	11d2c4 <tcp_listen_closed+0x38>
  11d2a8:	e30800e8 	movw	r0, #33000	; 0x80e8
  11d2ac:	e3400014 	movt	r0, #20
  11d2b0:	ebff9797 	bl	103114 <rt_kprintf>
  11d2b4:	e3a010c0 	mov	r1, #192	; 0xc0
  11d2b8:	e30800f4 	movw	r0, #33012	; 0x80f4
  11d2bc:	e3400014 	movt	r0, #20
  11d2c0:	ebffb76d 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
  11d2c4:	e51b3010 	ldr	r3, [fp, #-16]
  11d2c8:	e5933014 	ldr	r3, [r3, #20]
  11d2cc:	e3530001 	cmp	r3, #1
  11d2d0:	0a000006 	beq	11d2f0 <tcp_listen_closed+0x64>
  11d2d4:	e3080120 	movw	r0, #33056	; 0x8120
  11d2d8:	e3400014 	movt	r0, #20
  11d2dc:	ebff978c 	bl	103114 <rt_kprintf>
  11d2e0:	e3a010c1 	mov	r1, #193	; 0xc1
  11d2e4:	e30800f4 	movw	r0, #33012	; 0x80f4
  11d2e8:	e3400014 	movt	r0, #20
  11d2ec:	ebffb762 	bl	10b07c <sys_arch_assert>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
  11d2f0:	e3a03001 	mov	r3, #1
  11d2f4:	e50b3008 	str	r3, [fp, #-8]
  11d2f8:	ea00000a 	b	11d328 <tcp_listen_closed+0x9c>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen*)pcb);
  11d2fc:	e30830d8 	movw	r3, #32984	; 0x80d8
  11d300:	e3403014 	movt	r3, #20
  11d304:	e51b2008 	ldr	r2, [fp, #-8]
  11d308:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  11d30c:	e5933000 	ldr	r3, [r3]
  11d310:	e51b1010 	ldr	r1, [fp, #-16]
  11d314:	e1a00003 	mov	r0, r3
  11d318:	ebffffc1 	bl	11d224 <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
  11d31c:	e51b3008 	ldr	r3, [fp, #-8]
  11d320:	e2833001 	add	r3, r3, #1
  11d324:	e50b3008 	str	r3, [fp, #-8]
  11d328:	e51b3008 	ldr	r3, [fp, #-8]
  11d32c:	e3530003 	cmp	r3, #3
  11d330:	9afffff1 	bls	11d2fc <tcp_listen_closed+0x70>
  }
#endif
  LWIP_UNUSED_ARG(pcb);
}
  11d334:	e320f000 	nop	{0}
  11d338:	e24bd004 	sub	sp, fp, #4
  11d33c:	e8bd8800 	pop	{fp, pc}

0011d340 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  11d340:	e92d4800 	push	{fp, lr}
  11d344:	e28db004 	add	fp, sp, #4
  11d348:	e24dd018 	sub	sp, sp, #24
  11d34c:	e50b0010 	str	r0, [fp, #-16]
  11d350:	e1a03001 	mov	r3, r1
  11d354:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
  11d358:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  11d35c:	e3530000 	cmp	r3, #0
  11d360:	0a000077 	beq	11d544 <tcp_close_shutdown+0x204>
  11d364:	e51b3010 	ldr	r3, [fp, #-16]
  11d368:	e5933014 	ldr	r3, [r3, #20]
  11d36c:	e3530004 	cmp	r3, #4
  11d370:	0a000003 	beq	11d384 <tcp_close_shutdown+0x44>
  11d374:	e51b3010 	ldr	r3, [fp, #-16]
  11d378:	e5933014 	ldr	r3, [r3, #20]
  11d37c:	e3530007 	cmp	r3, #7
  11d380:	1a00006f 	bne	11d544 <tcp_close_shutdown+0x204>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
  11d384:	e51b3010 	ldr	r3, [fp, #-16]
  11d388:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  11d38c:	e3530000 	cmp	r3, #0
  11d390:	1a000004 	bne	11d3a8 <tcp_close_shutdown+0x68>
  11d394:	e51b3010 	ldr	r3, [fp, #-16]
  11d398:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  11d39c:	e30f2fff 	movw	r2, #65535	; 0xffff
  11d3a0:	e1530002 	cmp	r3, r2
  11d3a4:	0a000066 	beq	11d544 <tcp_close_shutdown+0x204>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
  11d3a8:	e51b3010 	ldr	r3, [fp, #-16]
  11d3ac:	e5d3301e 	ldrb	r3, [r3, #30]
  11d3b0:	e2033010 	and	r3, r3, #16
  11d3b4:	e3530000 	cmp	r3, #0
  11d3b8:	1a000006 	bne	11d3d8 <tcp_close_shutdown+0x98>
  11d3bc:	e3080138 	movw	r0, #33080	; 0x8138
  11d3c0:	e3400014 	movt	r0, #20
  11d3c4:	ebff9752 	bl	103114 <rt_kprintf>
  11d3c8:	e300110f 	movw	r1, #271	; 0x10f
  11d3cc:	e30800f4 	movw	r0, #33012	; 0x80f4
  11d3d0:	e3400014 	movt	r0, #20
  11d3d4:	ebffb728 	bl	10b07c <sys_arch_assert>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
  11d3d8:	e51b3010 	ldr	r3, [fp, #-16]
  11d3dc:	e5930050 	ldr	r0, [r3, #80]	; 0x50
  11d3e0:	e51b3010 	ldr	r3, [fp, #-16]
  11d3e4:	e5931028 	ldr	r1, [r3, #40]	; 0x28
  11d3e8:	e51bc010 	ldr	ip, [fp, #-16]
  11d3ec:	e51b3010 	ldr	r3, [fp, #-16]
  11d3f0:	e283e004 	add	lr, r3, #4
  11d3f4:	e51b3010 	ldr	r3, [fp, #-16]
  11d3f8:	e1d331ba 	ldrh	r3, [r3, #26]
  11d3fc:	e51b2010 	ldr	r2, [fp, #-16]
  11d400:	e1d221bc 	ldrh	r2, [r2, #28]
  11d404:	e58d2004 	str	r2, [sp, #4]
  11d408:	e58d3000 	str	r3, [sp]
  11d40c:	e1a0300e 	mov	r3, lr
  11d410:	e1a0200c 	mov	r2, ip
  11d414:	eb0025b6 	bl	126af4 <tcp_rst>
               pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
  11d418:	e51b0010 	ldr	r0, [fp, #-16]
  11d41c:	eb000adb 	bl	11ff90 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
  11d420:	e3063a30 	movw	r3, #27184	; 0x6a30
  11d424:	e3403057 	movt	r3, #87	; 0x57
  11d428:	e5933000 	ldr	r3, [r3]
  11d42c:	e51b2010 	ldr	r2, [fp, #-16]
  11d430:	e1520003 	cmp	r2, r3
  11d434:	1a000007 	bne	11d458 <tcp_close_shutdown+0x118>
  11d438:	e3063a30 	movw	r3, #27184	; 0x6a30
  11d43c:	e3403057 	movt	r3, #87	; 0x57
  11d440:	e5933000 	ldr	r3, [r3]
  11d444:	e593200c 	ldr	r2, [r3, #12]
  11d448:	e3063a30 	movw	r3, #27184	; 0x6a30
  11d44c:	e3403057 	movt	r3, #87	; 0x57
  11d450:	e5832000 	str	r2, [r3]
  11d454:	ea000014 	b	11d4ac <tcp_close_shutdown+0x16c>
  11d458:	e3063a30 	movw	r3, #27184	; 0x6a30
  11d45c:	e3403057 	movt	r3, #87	; 0x57
  11d460:	e5933000 	ldr	r3, [r3]
  11d464:	e50b3008 	str	r3, [fp, #-8]
  11d468:	ea00000c 	b	11d4a0 <tcp_close_shutdown+0x160>
  11d46c:	e51b3008 	ldr	r3, [fp, #-8]
  11d470:	e593300c 	ldr	r3, [r3, #12]
  11d474:	e51b2010 	ldr	r2, [fp, #-16]
  11d478:	e1520003 	cmp	r2, r3
  11d47c:	1a000004 	bne	11d494 <tcp_close_shutdown+0x154>
  11d480:	e51b3010 	ldr	r3, [fp, #-16]
  11d484:	e593200c 	ldr	r2, [r3, #12]
  11d488:	e51b3008 	ldr	r3, [fp, #-8]
  11d48c:	e583200c 	str	r2, [r3, #12]
  11d490:	ea000005 	b	11d4ac <tcp_close_shutdown+0x16c>
  11d494:	e51b3008 	ldr	r3, [fp, #-8]
  11d498:	e593300c 	ldr	r3, [r3, #12]
  11d49c:	e50b3008 	str	r3, [fp, #-8]
  11d4a0:	e51b3008 	ldr	r3, [fp, #-8]
  11d4a4:	e3530000 	cmp	r3, #0
  11d4a8:	1affffef 	bne	11d46c <tcp_close_shutdown+0x12c>
  11d4ac:	e51b3010 	ldr	r3, [fp, #-16]
  11d4b0:	e3a02000 	mov	r2, #0
  11d4b4:	e583200c 	str	r2, [r3, #12]
  11d4b8:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11d4bc:	e3403057 	movt	r3, #87	; 0x57
  11d4c0:	e3a02001 	mov	r2, #1
  11d4c4:	e5c32000 	strb	r2, [r3]
      if (pcb->state == ESTABLISHED) {
  11d4c8:	e51b3010 	ldr	r3, [fp, #-16]
  11d4cc:	e5933014 	ldr	r3, [r3, #20]
  11d4d0:	e3530004 	cmp	r3, #4
  11d4d4:	1a00000d 	bne	11d510 <tcp_close_shutdown+0x1d0>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
  11d4d8:	e51b3010 	ldr	r3, [fp, #-16]
  11d4dc:	e3a0200a 	mov	r2, #10
  11d4e0:	e5832014 	str	r2, [r3, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
  11d4e4:	e3063a40 	movw	r3, #27200	; 0x6a40
  11d4e8:	e3403057 	movt	r3, #87	; 0x57
  11d4ec:	e5932000 	ldr	r2, [r3]
  11d4f0:	e51b3010 	ldr	r3, [fp, #-16]
  11d4f4:	e583200c 	str	r2, [r3, #12]
  11d4f8:	e3063a40 	movw	r3, #27200	; 0x6a40
  11d4fc:	e3403057 	movt	r3, #87	; 0x57
  11d500:	e51b2010 	ldr	r2, [fp, #-16]
  11d504:	e5832000 	str	r2, [r3]
  11d508:	eb0027cc 	bl	127440 <tcp_timer_needed>
  11d50c:	ea00000a 	b	11d53c <tcp_close_shutdown+0x1fc>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        if (tcp_input_pcb == pcb) {
  11d510:	e3063a44 	movw	r3, #27204	; 0x6a44
  11d514:	e3403057 	movt	r3, #87	; 0x57
  11d518:	e5933000 	ldr	r3, [r3]
  11d51c:	e51b2010 	ldr	r2, [fp, #-16]
  11d520:	e1520003 	cmp	r2, r3
  11d524:	1a000001 	bne	11d530 <tcp_close_shutdown+0x1f0>
          /* prevent using a deallocated pcb: free it from tcp_input later */
          tcp_trigger_input_pcb_close();
  11d528:	eb001ce4 	bl	1248c0 <tcp_trigger_input_pcb_close>
  11d52c:	ea000002 	b	11d53c <tcp_close_shutdown+0x1fc>
        } else {
          memp_free(MEMP_TCP_PCB, pcb);
  11d530:	e51b1010 	ldr	r1, [fp, #-16]
  11d534:	e3a00002 	mov	r0, #2
  11d538:	ebffefcf 	bl	11947c <memp_free>
        }
      }
      return ERR_OK;
  11d53c:	e3a03000 	mov	r3, #0
  11d540:	ea000058 	b	11d6a8 <tcp_close_shutdown+0x368>
    }
  }

  /* - states which free the pcb are handled here,
     - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
  switch (pcb->state) {
  11d544:	e51b3010 	ldr	r3, [fp, #-16]
  11d548:	e5933014 	ldr	r3, [r3, #20]
  11d54c:	e3530001 	cmp	r3, #1
  11d550:	0a000032 	beq	11d620 <tcp_close_shutdown+0x2e0>
  11d554:	e3530001 	cmp	r3, #1
  11d558:	3a000002 	bcc	11d568 <tcp_close_shutdown+0x228>
  11d55c:	e3530002 	cmp	r3, #2
  11d560:	0a000038 	beq	11d648 <tcp_close_shutdown+0x308>
  11d564:	ea00004a 	b	11d694 <tcp_close_shutdown+0x354>
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    if (pcb->local_port != 0) {
  11d568:	e51b3010 	ldr	r3, [fp, #-16]
  11d56c:	e1d331ba 	ldrh	r3, [r3, #26]
  11d570:	e3530000 	cmp	r3, #0
  11d574:	0a000025 	beq	11d610 <tcp_close_shutdown+0x2d0>
      TCP_RMV(&tcp_bound_pcbs, pcb);
  11d578:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11d57c:	e3403057 	movt	r3, #87	; 0x57
  11d580:	e5933000 	ldr	r3, [r3]
  11d584:	e51b2010 	ldr	r2, [fp, #-16]
  11d588:	e1520003 	cmp	r2, r3
  11d58c:	1a000007 	bne	11d5b0 <tcp_close_shutdown+0x270>
  11d590:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11d594:	e3403057 	movt	r3, #87	; 0x57
  11d598:	e5933000 	ldr	r3, [r3]
  11d59c:	e593200c 	ldr	r2, [r3, #12]
  11d5a0:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11d5a4:	e3403057 	movt	r3, #87	; 0x57
  11d5a8:	e5832000 	str	r2, [r3]
  11d5ac:	ea000014 	b	11d604 <tcp_close_shutdown+0x2c4>
  11d5b0:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11d5b4:	e3403057 	movt	r3, #87	; 0x57
  11d5b8:	e5933000 	ldr	r3, [r3]
  11d5bc:	e50b300c 	str	r3, [fp, #-12]
  11d5c0:	ea00000c 	b	11d5f8 <tcp_close_shutdown+0x2b8>
  11d5c4:	e51b300c 	ldr	r3, [fp, #-12]
  11d5c8:	e593300c 	ldr	r3, [r3, #12]
  11d5cc:	e51b2010 	ldr	r2, [fp, #-16]
  11d5d0:	e1520003 	cmp	r2, r3
  11d5d4:	1a000004 	bne	11d5ec <tcp_close_shutdown+0x2ac>
  11d5d8:	e51b3010 	ldr	r3, [fp, #-16]
  11d5dc:	e593200c 	ldr	r2, [r3, #12]
  11d5e0:	e51b300c 	ldr	r3, [fp, #-12]
  11d5e4:	e583200c 	str	r2, [r3, #12]
  11d5e8:	ea000005 	b	11d604 <tcp_close_shutdown+0x2c4>
  11d5ec:	e51b300c 	ldr	r3, [fp, #-12]
  11d5f0:	e593300c 	ldr	r3, [r3, #12]
  11d5f4:	e50b300c 	str	r3, [fp, #-12]
  11d5f8:	e51b300c 	ldr	r3, [fp, #-12]
  11d5fc:	e3530000 	cmp	r3, #0
  11d600:	1affffef 	bne	11d5c4 <tcp_close_shutdown+0x284>
  11d604:	e51b3010 	ldr	r3, [fp, #-16]
  11d608:	e3a02000 	mov	r2, #0
  11d60c:	e583200c 	str	r2, [r3, #12]
    }
    memp_free(MEMP_TCP_PCB, pcb);
  11d610:	e51b1010 	ldr	r1, [fp, #-16]
  11d614:	e3a00002 	mov	r0, #2
  11d618:	ebffef97 	bl	11947c <memp_free>
    break;
  11d61c:	ea000020 	b	11d6a4 <tcp_close_shutdown+0x364>
  case LISTEN:
    tcp_listen_closed(pcb);
  11d620:	e51b0010 	ldr	r0, [fp, #-16]
  11d624:	ebffff18 	bl	11d28c <tcp_listen_closed>
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
  11d628:	e51b1010 	ldr	r1, [fp, #-16]
  11d62c:	e3060a38 	movw	r0, #27192	; 0x6a38
  11d630:	e3400057 	movt	r0, #87	; 0x57
  11d634:	eb000a8f 	bl	120078 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  11d638:	e51b1010 	ldr	r1, [fp, #-16]
  11d63c:	e3a00003 	mov	r0, #3
  11d640:	ebffef8d 	bl	11947c <memp_free>
    break;
  11d644:	ea000016 	b	11d6a4 <tcp_close_shutdown+0x364>
  case SYN_SENT:
    TCP_PCB_REMOVE_ACTIVE(pcb);
  11d648:	e51b1010 	ldr	r1, [fp, #-16]
  11d64c:	e3060a30 	movw	r0, #27184	; 0x6a30
  11d650:	e3400057 	movt	r0, #87	; 0x57
  11d654:	eb000a87 	bl	120078 <tcp_pcb_remove>
  11d658:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11d65c:	e3403057 	movt	r3, #87	; 0x57
  11d660:	e3a02001 	mov	r2, #1
  11d664:	e5c32000 	strb	r2, [r3]
    memp_free(MEMP_TCP_PCB, pcb);
  11d668:	e51b1010 	ldr	r1, [fp, #-16]
  11d66c:	e3a00002 	mov	r0, #2
  11d670:	ebffef81 	bl	11947c <memp_free>
    MIB2_STATS_INC(mib2.tcpattemptfails);
  11d674:	e3063840 	movw	r3, #26688	; 0x6840
  11d678:	e3403057 	movt	r3, #87	; 0x57
  11d67c:	e5933174 	ldr	r3, [r3, #372]	; 0x174
  11d680:	e2832001 	add	r2, r3, #1
  11d684:	e3063840 	movw	r3, #26688	; 0x6840
  11d688:	e3403057 	movt	r3, #87	; 0x57
  11d68c:	e5832174 	str	r2, [r3, #372]	; 0x174
    break;
  11d690:	ea000003 	b	11d6a4 <tcp_close_shutdown+0x364>
  default:
    return tcp_close_shutdown_fin(pcb);
  11d694:	e51b0010 	ldr	r0, [fp, #-16]
  11d698:	eb000005 	bl	11d6b4 <tcp_close_shutdown_fin>
  11d69c:	e1a03000 	mov	r3, r0
  11d6a0:	ea000000 	b	11d6a8 <tcp_close_shutdown+0x368>
  }
  return ERR_OK;
  11d6a4:	e3a03000 	mov	r3, #0
}
  11d6a8:	e1a00003 	mov	r0, r3
  11d6ac:	e24bd004 	sub	sp, fp, #4
  11d6b0:	e8bd8800 	pop	{fp, pc}

0011d6b4 <tcp_close_shutdown_fin>:

static err_t
tcp_close_shutdown_fin(struct tcp_pcb *pcb)
{
  11d6b4:	e92d4800 	push	{fp, lr}
  11d6b8:	e28db004 	add	fp, sp, #4
  11d6bc:	e24dd010 	sub	sp, sp, #16
  11d6c0:	e50b0010 	str	r0, [fp, #-16]
  err_t err;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
  11d6c4:	e51b3010 	ldr	r3, [fp, #-16]
  11d6c8:	e3530000 	cmp	r3, #0
  11d6cc:	1a000006 	bne	11d6ec <tcp_close_shutdown_fin+0x38>
  11d6d0:	e30800e8 	movw	r0, #33000	; 0x80e8
  11d6d4:	e3400014 	movt	r0, #20
  11d6d8:	ebff968d 	bl	103114 <rt_kprintf>
  11d6dc:	e300114d 	movw	r1, #333	; 0x14d
  11d6e0:	e30800f4 	movw	r0, #33012	; 0x80f4
  11d6e4:	e3400014 	movt	r0, #20
  11d6e8:	ebffb663 	bl	10b07c <sys_arch_assert>

  switch (pcb->state) {
  11d6ec:	e51b3010 	ldr	r3, [fp, #-16]
  11d6f0:	e5933014 	ldr	r3, [r3, #20]
  11d6f4:	e3530004 	cmp	r3, #4
  11d6f8:	0a000015 	beq	11d754 <tcp_close_shutdown_fin+0xa0>
  11d6fc:	e3530007 	cmp	r3, #7
  11d700:	0a000025 	beq	11d79c <tcp_close_shutdown_fin+0xe8>
  11d704:	e3530003 	cmp	r3, #3
  11d708:	1a000035 	bne	11d7e4 <tcp_close_shutdown_fin+0x130>
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
  11d70c:	e51b0010 	ldr	r0, [fp, #-16]
  11d710:	eb001ce6 	bl	124ab0 <tcp_send_fin>
  11d714:	e1a03000 	mov	r3, r0
  11d718:	e54b3005 	strb	r3, [fp, #-5]
    if (err == ERR_OK) {
  11d71c:	e15b30d5 	ldrsb	r3, [fp, #-5]
  11d720:	e3530000 	cmp	r3, #0
  11d724:	1a000030 	bne	11d7ec <tcp_close_shutdown_fin+0x138>
      tcp_backlog_accepted(pcb);
      MIB2_STATS_INC(mib2.tcpattemptfails);
  11d728:	e3063840 	movw	r3, #26688	; 0x6840
  11d72c:	e3403057 	movt	r3, #87	; 0x57
  11d730:	e5933174 	ldr	r3, [r3, #372]	; 0x174
  11d734:	e2832001 	add	r2, r3, #1
  11d738:	e3063840 	movw	r3, #26688	; 0x6840
  11d73c:	e3403057 	movt	r3, #87	; 0x57
  11d740:	e5832174 	str	r2, [r3, #372]	; 0x174
      pcb->state = FIN_WAIT_1;
  11d744:	e51b3010 	ldr	r3, [fp, #-16]
  11d748:	e3a02005 	mov	r2, #5
  11d74c:	e5832014 	str	r2, [r3, #20]
    }
    break;
  11d750:	ea000025 	b	11d7ec <tcp_close_shutdown_fin+0x138>
  case ESTABLISHED:
    err = tcp_send_fin(pcb);
  11d754:	e51b0010 	ldr	r0, [fp, #-16]
  11d758:	eb001cd4 	bl	124ab0 <tcp_send_fin>
  11d75c:	e1a03000 	mov	r3, r0
  11d760:	e54b3005 	strb	r3, [fp, #-5]
    if (err == ERR_OK) {
  11d764:	e15b30d5 	ldrsb	r3, [fp, #-5]
  11d768:	e3530000 	cmp	r3, #0
  11d76c:	1a000020 	bne	11d7f4 <tcp_close_shutdown_fin+0x140>
      MIB2_STATS_INC(mib2.tcpestabresets);
  11d770:	e3063840 	movw	r3, #26688	; 0x6840
  11d774:	e3403057 	movt	r3, #87	; 0x57
  11d778:	e5933178 	ldr	r3, [r3, #376]	; 0x178
  11d77c:	e2832001 	add	r2, r3, #1
  11d780:	e3063840 	movw	r3, #26688	; 0x6840
  11d784:	e3403057 	movt	r3, #87	; 0x57
  11d788:	e5832178 	str	r2, [r3, #376]	; 0x178
      pcb->state = FIN_WAIT_1;
  11d78c:	e51b3010 	ldr	r3, [fp, #-16]
  11d790:	e3a02005 	mov	r2, #5
  11d794:	e5832014 	str	r2, [r3, #20]
    }
    break;
  11d798:	ea000015 	b	11d7f4 <tcp_close_shutdown_fin+0x140>
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
  11d79c:	e51b0010 	ldr	r0, [fp, #-16]
  11d7a0:	eb001cc2 	bl	124ab0 <tcp_send_fin>
  11d7a4:	e1a03000 	mov	r3, r0
  11d7a8:	e54b3005 	strb	r3, [fp, #-5]
    if (err == ERR_OK) {
  11d7ac:	e15b30d5 	ldrsb	r3, [fp, #-5]
  11d7b0:	e3530000 	cmp	r3, #0
  11d7b4:	1a000010 	bne	11d7fc <tcp_close_shutdown_fin+0x148>
      MIB2_STATS_INC(mib2.tcpestabresets);
  11d7b8:	e3063840 	movw	r3, #26688	; 0x6840
  11d7bc:	e3403057 	movt	r3, #87	; 0x57
  11d7c0:	e5933178 	ldr	r3, [r3, #376]	; 0x178
  11d7c4:	e2832001 	add	r2, r3, #1
  11d7c8:	e3063840 	movw	r3, #26688	; 0x6840
  11d7cc:	e3403057 	movt	r3, #87	; 0x57
  11d7d0:	e5832178 	str	r2, [r3, #376]	; 0x178
      pcb->state = LAST_ACK;
  11d7d4:	e51b3010 	ldr	r3, [fp, #-16]
  11d7d8:	e3a02009 	mov	r2, #9
  11d7dc:	e5832014 	str	r2, [r3, #20]
    }
    break;
  11d7e0:	ea000005 	b	11d7fc <tcp_close_shutdown_fin+0x148>
  default:
    /* Has already been closed, do nothing. */
    return ERR_OK;
  11d7e4:	e3a03000 	mov	r3, #0
  11d7e8:	ea000014 	b	11d840 <tcp_close_shutdown_fin+0x18c>
    break;
  11d7ec:	e320f000 	nop	{0}
  11d7f0:	ea000002 	b	11d800 <tcp_close_shutdown_fin+0x14c>
    break;
  11d7f4:	e320f000 	nop	{0}
  11d7f8:	ea000000 	b	11d800 <tcp_close_shutdown_fin+0x14c>
    break;
  11d7fc:	e320f000 	nop	{0}
    break;
  }

  if (err == ERR_OK) {
  11d800:	e15b30d5 	ldrsb	r3, [fp, #-5]
  11d804:	e3530000 	cmp	r3, #0
  11d808:	1a000002 	bne	11d818 <tcp_close_shutdown_fin+0x164>
    /* To ensure all data has been sent when tcp_close returns, we have
       to make sure tcp_output doesn't fail.
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    tcp_output(pcb);
  11d80c:	e51b0010 	ldr	r0, [fp, #-16]
  11d810:	eb002251 	bl	12615c <tcp_output>
  11d814:	ea000008 	b	11d83c <tcp_close_shutdown_fin+0x188>
  } else if (err == ERR_MEM) {
  11d818:	e15b30d5 	ldrsb	r3, [fp, #-5]
  11d81c:	e3730001 	cmn	r3, #1
  11d820:	1a000005 	bne	11d83c <tcp_close_shutdown_fin+0x188>
    /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
    pcb->flags |= TF_CLOSEPEND;
  11d824:	e51b3010 	ldr	r3, [fp, #-16]
  11d828:	e5d3301e 	ldrb	r3, [r3, #30]
  11d82c:	e3833008 	orr	r3, r3, #8
  11d830:	e6ef2073 	uxtb	r2, r3
  11d834:	e51b3010 	ldr	r3, [fp, #-16]
  11d838:	e5c3201e 	strb	r2, [r3, #30]
  }
  return err;
  11d83c:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  11d840:	e1a00003 	mov	r0, r3
  11d844:	e24bd004 	sub	sp, fp, #4
  11d848:	e8bd8800 	pop	{fp, pc}

0011d84c <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  11d84c:	e92d4800 	push	{fp, lr}
  11d850:	e28db004 	add	fp, sp, #4
  11d854:	e24dd008 	sub	sp, sp, #8
  11d858:	e50b0008 	str	r0, [fp, #-8]
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);

  if (pcb->state != LISTEN) {
  11d85c:	e51b3008 	ldr	r3, [fp, #-8]
  11d860:	e5933014 	ldr	r3, [r3, #20]
  11d864:	e3530001 	cmp	r3, #1
  11d868:	0a000005 	beq	11d884 <tcp_close+0x38>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
  11d86c:	e51b3008 	ldr	r3, [fp, #-8]
  11d870:	e5d3301e 	ldrb	r3, [r3, #30]
  11d874:	e3833010 	orr	r3, r3, #16
  11d878:	e6ef2073 	uxtb	r2, r3
  11d87c:	e51b3008 	ldr	r3, [fp, #-8]
  11d880:	e5c3201e 	strb	r2, [r3, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
  11d884:	e3a01001 	mov	r1, #1
  11d888:	e51b0008 	ldr	r0, [fp, #-8]
  11d88c:	ebfffeab 	bl	11d340 <tcp_close_shutdown>
  11d890:	e1a03000 	mov	r3, r0
}
  11d894:	e1a00003 	mov	r0, r3
  11d898:	e24bd004 	sub	sp, fp, #4
  11d89c:	e8bd8800 	pop	{fp, pc}

0011d8a0 <tcp_shutdown>:
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
  11d8a0:	e92d4800 	push	{fp, lr}
  11d8a4:	e28db004 	add	fp, sp, #4
  11d8a8:	e24dd010 	sub	sp, sp, #16
  11d8ac:	e50b0008 	str	r0, [fp, #-8]
  11d8b0:	e50b100c 	str	r1, [fp, #-12]
  11d8b4:	e50b2010 	str	r2, [fp, #-16]
  if (pcb->state == LISTEN) {
  11d8b8:	e51b3008 	ldr	r3, [fp, #-8]
  11d8bc:	e5933014 	ldr	r3, [r3, #20]
  11d8c0:	e3530001 	cmp	r3, #1
  11d8c4:	1a000001 	bne	11d8d0 <tcp_shutdown+0x30>
    return ERR_CONN;
  11d8c8:	e3e0300a 	mvn	r3, #10
  11d8cc:	ea000030 	b	11d994 <tcp_shutdown+0xf4>
  }
  if (shut_rx) {
  11d8d0:	e51b300c 	ldr	r3, [fp, #-12]
  11d8d4:	e3530000 	cmp	r3, #0
  11d8d8:	0a000018 	beq	11d940 <tcp_shutdown+0xa0>
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
  11d8dc:	e51b3008 	ldr	r3, [fp, #-8]
  11d8e0:	e5d3301e 	ldrb	r3, [r3, #30]
  11d8e4:	e3833010 	orr	r3, r3, #16
  11d8e8:	e6ef2073 	uxtb	r2, r3
  11d8ec:	e51b3008 	ldr	r3, [fp, #-8]
  11d8f0:	e5c3201e 	strb	r2, [r3, #30]
    if (shut_tx) {
  11d8f4:	e51b3010 	ldr	r3, [fp, #-16]
  11d8f8:	e3530000 	cmp	r3, #0
  11d8fc:	0a000004 	beq	11d914 <tcp_shutdown+0x74>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
  11d900:	e3a01001 	mov	r1, #1
  11d904:	e51b0008 	ldr	r0, [fp, #-8]
  11d908:	ebfffe8c 	bl	11d340 <tcp_close_shutdown>
  11d90c:	e1a03000 	mov	r3, r0
  11d910:	ea00001f 	b	11d994 <tcp_shutdown+0xf4>
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
  11d914:	e51b3008 	ldr	r3, [fp, #-8]
  11d918:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  11d91c:	e3530000 	cmp	r3, #0
  11d920:	0a000006 	beq	11d940 <tcp_shutdown+0xa0>
      pbuf_free(pcb->refused_data);
  11d924:	e51b3008 	ldr	r3, [fp, #-8]
  11d928:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  11d92c:	e1a00003 	mov	r0, r3
  11d930:	ebfff5df 	bl	11b0b4 <pbuf_free>
      pcb->refused_data = NULL;
  11d934:	e51b3008 	ldr	r3, [fp, #-8]
  11d938:	e3a02000 	mov	r2, #0
  11d93c:	e5832078 	str	r2, [r3, #120]	; 0x78
    }
  }
  if (shut_tx) {
  11d940:	e51b3010 	ldr	r3, [fp, #-16]
  11d944:	e3530000 	cmp	r3, #0
  11d948:	0a000010 	beq	11d990 <tcp_shutdown+0xf0>
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
  11d94c:	e51b3008 	ldr	r3, [fp, #-8]
  11d950:	e5933014 	ldr	r3, [r3, #20]
  11d954:	e3530003 	cmp	r3, #3
  11d958:	3a00000a 	bcc	11d988 <tcp_shutdown+0xe8>
  11d95c:	e3530004 	cmp	r3, #4
  11d960:	9a000001 	bls	11d96c <tcp_shutdown+0xcc>
  11d964:	e3530007 	cmp	r3, #7
  11d968:	1a000006 	bne	11d988 <tcp_shutdown+0xe8>
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, (u8_t)shut_rx);
  11d96c:	e51b300c 	ldr	r3, [fp, #-12]
  11d970:	e6ef3073 	uxtb	r3, r3
  11d974:	e1a01003 	mov	r1, r3
  11d978:	e51b0008 	ldr	r0, [fp, #-8]
  11d97c:	ebfffe6f 	bl	11d340 <tcp_close_shutdown>
  11d980:	e1a03000 	mov	r3, r0
  11d984:	ea000002 	b	11d994 <tcp_shutdown+0xf4>
    default:
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
  11d988:	e3e0300a 	mvn	r3, #10
  11d98c:	ea000000 	b	11d994 <tcp_shutdown+0xf4>
    }
  }
  return ERR_OK;
  11d990:	e3a03000 	mov	r3, #0
}
  11d994:	e1a00003 	mov	r0, r3
  11d998:	e24bd004 	sub	sp, fp, #4
  11d99c:	e8bd8800 	pop	{fp, pc}

0011d9a0 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
  11d9a0:	e92d4800 	push	{fp, lr}
  11d9a4:	e28db004 	add	fp, sp, #4
  11d9a8:	e24dd030 	sub	sp, sp, #48	; 0x30
  11d9ac:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  11d9b0:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
  11d9b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11d9b8:	e5933014 	ldr	r3, [r3, #20]
  11d9bc:	e3530001 	cmp	r3, #1
  11d9c0:	1a000006 	bne	11d9e0 <tcp_abandon+0x40>
  11d9c4:	e3080154 	movw	r0, #33108	; 0x8154
  11d9c8:	e3400014 	movt	r0, #20
  11d9cc:	ebff95d0 	bl	103114 <rt_kprintf>
  11d9d0:	e30011db 	movw	r1, #475	; 0x1db
  11d9d4:	e30800f4 	movw	r0, #33012	; 0x80f4
  11d9d8:	e3400014 	movt	r0, #20
  11d9dc:	ebffb5a6 	bl	10b07c <sys_arch_assert>
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  11d9e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11d9e4:	e5933014 	ldr	r3, [r3, #20]
  11d9e8:	e353000a 	cmp	r3, #10
  11d9ec:	1a000007 	bne	11da10 <tcp_abandon+0x70>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  11d9f0:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
  11d9f4:	e3060a40 	movw	r0, #27200	; 0x6a40
  11d9f8:	e3400057 	movt	r0, #87	; 0x57
  11d9fc:	eb00099d 	bl	120078 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  11da00:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
  11da04:	e3a00002 	mov	r0, #2
  11da08:	ebffee9b 	bl	11947c <memp_free>
    }
    last_state = pcb->state;
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
  }
}
  11da0c:	ea00007f 	b	11dc10 <tcp_abandon+0x270>
    int send_rst = 0;
  11da10:	e3a03000 	mov	r3, #0
  11da14:	e50b3008 	str	r3, [fp, #-8]
    u16_t local_port = 0;
  11da18:	e3a03000 	mov	r3, #0
  11da1c:	e14b30ba 	strh	r3, [fp, #-10]
    seqno = pcb->snd_nxt;
  11da20:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11da24:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  11da28:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    ackno = pcb->rcv_nxt;
  11da2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11da30:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  11da34:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    errf = pcb->errf;
  11da38:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11da3c:	e5933090 	ldr	r3, [r3, #144]	; 0x90
  11da40:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    errf_arg = pcb->callback_arg;
  11da44:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11da48:	e5933010 	ldr	r3, [r3, #16]
  11da4c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    if (pcb->state == CLOSED) {
  11da50:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11da54:	e5933014 	ldr	r3, [r3, #20]
  11da58:	e3530000 	cmp	r3, #0
  11da5c:	1a00002a 	bne	11db0c <tcp_abandon+0x16c>
      if (pcb->local_port != 0) {
  11da60:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11da64:	e1d331ba 	ldrh	r3, [r3, #26]
  11da68:	e3530000 	cmp	r3, #0
  11da6c:	0a000033 	beq	11db40 <tcp_abandon+0x1a0>
        TCP_RMV(&tcp_bound_pcbs, pcb);
  11da70:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11da74:	e3403057 	movt	r3, #87	; 0x57
  11da78:	e5933000 	ldr	r3, [r3]
  11da7c:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  11da80:	e1520003 	cmp	r2, r3
  11da84:	1a000007 	bne	11daa8 <tcp_abandon+0x108>
  11da88:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11da8c:	e3403057 	movt	r3, #87	; 0x57
  11da90:	e5933000 	ldr	r3, [r3]
  11da94:	e593200c 	ldr	r2, [r3, #12]
  11da98:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11da9c:	e3403057 	movt	r3, #87	; 0x57
  11daa0:	e5832000 	str	r2, [r3]
  11daa4:	ea000014 	b	11dafc <tcp_abandon+0x15c>
  11daa8:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11daac:	e3403057 	movt	r3, #87	; 0x57
  11dab0:	e5933000 	ldr	r3, [r3]
  11dab4:	e50b3010 	str	r3, [fp, #-16]
  11dab8:	ea00000c 	b	11daf0 <tcp_abandon+0x150>
  11dabc:	e51b3010 	ldr	r3, [fp, #-16]
  11dac0:	e593300c 	ldr	r3, [r3, #12]
  11dac4:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  11dac8:	e1520003 	cmp	r2, r3
  11dacc:	1a000004 	bne	11dae4 <tcp_abandon+0x144>
  11dad0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11dad4:	e593200c 	ldr	r2, [r3, #12]
  11dad8:	e51b3010 	ldr	r3, [fp, #-16]
  11dadc:	e583200c 	str	r2, [r3, #12]
  11dae0:	ea000005 	b	11dafc <tcp_abandon+0x15c>
  11dae4:	e51b3010 	ldr	r3, [fp, #-16]
  11dae8:	e593300c 	ldr	r3, [r3, #12]
  11daec:	e50b3010 	str	r3, [fp, #-16]
  11daf0:	e51b3010 	ldr	r3, [fp, #-16]
  11daf4:	e3530000 	cmp	r3, #0
  11daf8:	1affffef 	bne	11dabc <tcp_abandon+0x11c>
  11dafc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11db00:	e3a02000 	mov	r2, #0
  11db04:	e583200c 	str	r2, [r3, #12]
  11db08:	ea00000c 	b	11db40 <tcp_abandon+0x1a0>
      send_rst = reset;
  11db0c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11db10:	e50b3008 	str	r3, [fp, #-8]
      local_port = pcb->local_port;
  11db14:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11db18:	e1d331ba 	ldrh	r3, [r3, #26]
  11db1c:	e14b30ba 	strh	r3, [fp, #-10]
      TCP_PCB_REMOVE_ACTIVE(pcb);
  11db20:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
  11db24:	e3060a30 	movw	r0, #27184	; 0x6a30
  11db28:	e3400057 	movt	r0, #87	; 0x57
  11db2c:	eb000951 	bl	120078 <tcp_pcb_remove>
  11db30:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11db34:	e3403057 	movt	r3, #87	; 0x57
  11db38:	e3a02001 	mov	r2, #1
  11db3c:	e5c32000 	strb	r2, [r3]
    if (pcb->unacked != NULL) {
  11db40:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11db44:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  11db48:	e3530000 	cmp	r3, #0
  11db4c:	0a000003 	beq	11db60 <tcp_abandon+0x1c0>
      tcp_segs_free(pcb->unacked);
  11db50:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11db54:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  11db58:	e1a00003 	mov	r0, r3
  11db5c:	eb0006b4 	bl	11f634 <tcp_segs_free>
    if (pcb->unsent != NULL) {
  11db60:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11db64:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  11db68:	e3530000 	cmp	r3, #0
  11db6c:	0a000003 	beq	11db80 <tcp_abandon+0x1e0>
      tcp_segs_free(pcb->unsent);
  11db70:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11db74:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  11db78:	e1a00003 	mov	r0, r3
  11db7c:	eb0006ac 	bl	11f634 <tcp_segs_free>
    if (pcb->ooseq != NULL) {
  11db80:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11db84:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  11db88:	e3530000 	cmp	r3, #0
  11db8c:	0a000003 	beq	11dba0 <tcp_abandon+0x200>
      tcp_segs_free(pcb->ooseq);
  11db90:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11db94:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  11db98:	e1a00003 	mov	r0, r3
  11db9c:	eb0006a4 	bl	11f634 <tcp_segs_free>
    if (send_rst) {
  11dba0:	e51b3008 	ldr	r3, [fp, #-8]
  11dba4:	e3530000 	cmp	r3, #0
  11dba8:	0a00000b 	beq	11dbdc <tcp_abandon+0x23c>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
  11dbac:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  11dbb0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11dbb4:	e2831004 	add	r1, r3, #4
  11dbb8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11dbbc:	e1d331bc 	ldrh	r3, [r3, #28]
  11dbc0:	e58d3004 	str	r3, [sp, #4]
  11dbc4:	e15b30ba 	ldrh	r3, [fp, #-10]
  11dbc8:	e58d3000 	str	r3, [sp]
  11dbcc:	e1a03001 	mov	r3, r1
  11dbd0:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  11dbd4:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  11dbd8:	eb0023c5 	bl	126af4 <tcp_rst>
    last_state = pcb->state;
  11dbdc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11dbe0:	e5933014 	ldr	r3, [r3, #20]
  11dbe4:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    memp_free(MEMP_TCP_PCB, pcb);
  11dbe8:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
  11dbec:	e3a00002 	mov	r0, #2
  11dbf0:	ebffee21 	bl	11947c <memp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
  11dbf4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11dbf8:	e3530000 	cmp	r3, #0
  11dbfc:	0a000003 	beq	11dc10 <tcp_abandon+0x270>
  11dc00:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11dc04:	e3e0100c 	mvn	r1, #12
  11dc08:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  11dc0c:	e12fff33 	blx	r3
}
  11dc10:	e320f000 	nop	{0}
  11dc14:	e24bd004 	sub	sp, fp, #4
  11dc18:	e8bd8800 	pop	{fp, pc}

0011dc1c <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  11dc1c:	e92d4800 	push	{fp, lr}
  11dc20:	e28db004 	add	fp, sp, #4
  11dc24:	e24dd008 	sub	sp, sp, #8
  11dc28:	e50b0008 	str	r0, [fp, #-8]
  tcp_abandon(pcb, 1);
  11dc2c:	e3a01001 	mov	r1, #1
  11dc30:	e51b0008 	ldr	r0, [fp, #-8]
  11dc34:	ebffff59 	bl	11d9a0 <tcp_abandon>
}
  11dc38:	e320f000 	nop	{0}
  11dc3c:	e24bd004 	sub	sp, fp, #4
  11dc40:	e8bd8800 	pop	{fp, pc}

0011dc44 <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
  11dc44:	e92d4800 	push	{fp, lr}
  11dc48:	e28db004 	add	fp, sp, #4
  11dc4c:	e24dd020 	sub	sp, sp, #32
  11dc50:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  11dc54:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  11dc58:	e1a03002 	mov	r3, r2
  11dc5c:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  11dc60:	e3a03004 	mov	r3, #4
  11dc64:	e50b300c 	str	r3, [fp, #-12]
  struct tcp_pcb *cpcb;

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
  11dc68:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11dc6c:	e3530000 	cmp	r3, #0
  11dc70:	1a000002 	bne	11dc80 <tcp_bind+0x3c>
    ipaddr = IP4_ADDR_ANY;
  11dc74:	e3093b24 	movw	r3, #39716	; 0x9b24
  11dc78:	e3403014 	movt	r3, #20
  11dc7c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  }
#endif /* LWIP_IPV4 */

  /* still need to check for ipaddr == NULL in IPv6 only case */
  if ((pcb == NULL) || (ipaddr == NULL)) {
  11dc80:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11dc84:	e3530000 	cmp	r3, #0
  11dc88:	0a000002 	beq	11dc98 <tcp_bind+0x54>
  11dc8c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11dc90:	e3530000 	cmp	r3, #0
  11dc94:	1a000001 	bne	11dca0 <tcp_bind+0x5c>
    return ERR_VAL;
  11dc98:	e3e03005 	mvn	r3, #5
  11dc9c:	ea000078 	b	11de84 <tcp_bind+0x240>
  }

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
  11dca0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11dca4:	e5933014 	ldr	r3, [r3, #20]
  11dca8:	e3530000 	cmp	r3, #0
  11dcac:	0a000008 	beq	11dcd4 <tcp_bind+0x90>
  11dcb0:	e3080188 	movw	r0, #33160	; 0x8188
  11dcb4:	e3400014 	movt	r0, #20
  11dcb8:	ebff9515 	bl	103114 <rt_kprintf>
  11dcbc:	e300123f 	movw	r1, #575	; 0x23f
  11dcc0:	e30800f4 	movw	r0, #33012	; 0x80f4
  11dcc4:	e3400014 	movt	r0, #20
  11dcc8:	ebffb4eb 	bl	10b07c <sys_arch_assert>
  11dccc:	e3e03005 	mvn	r3, #5
  11dcd0:	ea00006b 	b	11de84 <tcp_bind+0x240>
  /* Unless the REUSEADDR flag is set,
     we have to check the pcbs in TIME-WAIT state, also.
     We do not dump TIME_WAIT pcb's; they can still be matched by incoming
     packets using both local and remote IP addresses and ports to distinguish.
   */
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
  11dcd4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11dcd8:	e5d33008 	ldrb	r3, [r3, #8]
  11dcdc:	e2033004 	and	r3, r3, #4
  11dce0:	e3530000 	cmp	r3, #0
  11dce4:	0a000001 	beq	11dcf0 <tcp_bind+0xac>
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  11dce8:	e3a03003 	mov	r3, #3
  11dcec:	e50b300c 	str	r3, [fp, #-12]
  }
#endif /* SO_REUSE */

  if (port == 0) {
  11dcf0:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  11dcf4:	e3530000 	cmp	r3, #0
  11dcf8:	1a000007 	bne	11dd1c <tcp_bind+0xd8>
    port = tcp_new_port();
  11dcfc:	eb0001ba 	bl	11e3ec <tcp_new_port>
  11dd00:	e1a03000 	mov	r3, r0
  11dd04:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
    if (port == 0) {
  11dd08:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  11dd0c:	e3530000 	cmp	r3, #0
  11dd10:	1a00003d 	bne	11de0c <tcp_bind+0x1c8>
      return ERR_BUF;
  11dd14:	e3e03001 	mvn	r3, #1
  11dd18:	ea000059 	b	11de84 <tcp_bind+0x240>
    }
  } else {
    /* Check if the address already is in use (on all lists) */
    for (i = 0; i < max_pcb_list; i++) {
  11dd1c:	e3a03000 	mov	r3, #0
  11dd20:	e50b3008 	str	r3, [fp, #-8]
  11dd24:	ea000034 	b	11ddfc <tcp_bind+0x1b8>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
  11dd28:	e30830d8 	movw	r3, #32984	; 0x80d8
  11dd2c:	e3403014 	movt	r3, #20
  11dd30:	e51b2008 	ldr	r2, [fp, #-8]
  11dd34:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  11dd38:	e5933000 	ldr	r3, [r3]
  11dd3c:	e50b3010 	str	r3, [fp, #-16]
  11dd40:	ea000027 	b	11dde4 <tcp_bind+0x1a0>
        if (cpcb->local_port == port) {
  11dd44:	e51b3010 	ldr	r3, [fp, #-16]
  11dd48:	e1d331ba 	ldrh	r3, [r3, #26]
  11dd4c:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
  11dd50:	e1520003 	cmp	r2, r3
  11dd54:	1a00001f 	bne	11ddd8 <tcp_bind+0x194>
#if SO_REUSE
          /* Omit checking for the same port if both pcbs have REUSEADDR set.
             For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
             tcp_connect. */
          if (!ip_get_option(pcb, SOF_REUSEADDR) ||
  11dd58:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11dd5c:	e5d33008 	ldrb	r3, [r3, #8]
  11dd60:	e2033004 	and	r3, r3, #4
  11dd64:	e3530000 	cmp	r3, #0
  11dd68:	0a000004 	beq	11dd80 <tcp_bind+0x13c>
              !ip_get_option(cpcb, SOF_REUSEADDR))
  11dd6c:	e51b3010 	ldr	r3, [fp, #-16]
  11dd70:	e5d33008 	ldrb	r3, [r3, #8]
  11dd74:	e2033004 	and	r3, r3, #4
          if (!ip_get_option(pcb, SOF_REUSEADDR) ||
  11dd78:	e3530000 	cmp	r3, #0
  11dd7c:	1a000015 	bne	11ddd8 <tcp_bind+0x194>
#endif /* SO_REUSE */
          {
            /* @todo: check accept_any_ip_version */
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
                (ip_addr_isany(&cpcb->local_ip) ||
  11dd80:	e51b3010 	ldr	r3, [fp, #-16]
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
  11dd84:	e3530000 	cmp	r3, #0
  11dd88:	0a000010 	beq	11ddd0 <tcp_bind+0x18c>
                (ip_addr_isany(&cpcb->local_ip) ||
  11dd8c:	e51b3010 	ldr	r3, [fp, #-16]
  11dd90:	e5933000 	ldr	r3, [r3]
  11dd94:	e3530000 	cmp	r3, #0
  11dd98:	0a00000c 	beq	11ddd0 <tcp_bind+0x18c>
  11dd9c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11dda0:	e3530000 	cmp	r3, #0
  11dda4:	0a000009 	beq	11ddd0 <tcp_bind+0x18c>
                ip_addr_isany(ipaddr) ||
  11dda8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ddac:	e5933000 	ldr	r3, [r3]
  11ddb0:	e3530000 	cmp	r3, #0
  11ddb4:	0a000005 	beq	11ddd0 <tcp_bind+0x18c>
                ip_addr_cmp(&cpcb->local_ip, ipaddr))) {
  11ddb8:	e51b3010 	ldr	r3, [fp, #-16]
  11ddbc:	e5932000 	ldr	r2, [r3]
  11ddc0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11ddc4:	e5933000 	ldr	r3, [r3]
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
  11ddc8:	e1520003 	cmp	r2, r3
  11ddcc:	1a000001 	bne	11ddd8 <tcp_bind+0x194>
              return ERR_USE;
  11ddd0:	e3e03007 	mvn	r3, #7
  11ddd4:	ea00002a 	b	11de84 <tcp_bind+0x240>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
  11ddd8:	e51b3010 	ldr	r3, [fp, #-16]
  11dddc:	e593300c 	ldr	r3, [r3, #12]
  11dde0:	e50b3010 	str	r3, [fp, #-16]
  11dde4:	e51b3010 	ldr	r3, [fp, #-16]
  11dde8:	e3530000 	cmp	r3, #0
  11ddec:	1affffd4 	bne	11dd44 <tcp_bind+0x100>
    for (i = 0; i < max_pcb_list; i++) {
  11ddf0:	e51b3008 	ldr	r3, [fp, #-8]
  11ddf4:	e2833001 	add	r3, r3, #1
  11ddf8:	e50b3008 	str	r3, [fp, #-8]
  11ddfc:	e51b2008 	ldr	r2, [fp, #-8]
  11de00:	e51b300c 	ldr	r3, [fp, #-12]
  11de04:	e1520003 	cmp	r2, r3
  11de08:	baffffc6 	blt	11dd28 <tcp_bind+0xe4>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  11de0c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11de10:	e3530000 	cmp	r3, #0
  11de14:	0a00000c 	beq	11de4c <tcp_bind+0x208>
  11de18:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11de1c:	e5933000 	ldr	r3, [r3]
  11de20:	e3530000 	cmp	r3, #0
  11de24:	0a000008 	beq	11de4c <tcp_bind+0x208>
    ip_addr_set(&pcb->local_ip, ipaddr);
  11de28:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11de2c:	e3530000 	cmp	r3, #0
  11de30:	0a000002 	beq	11de40 <tcp_bind+0x1fc>
  11de34:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  11de38:	e5933000 	ldr	r3, [r3]
  11de3c:	ea000000 	b	11de44 <tcp_bind+0x200>
  11de40:	e3a03000 	mov	r3, #0
  11de44:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  11de48:	e5823000 	str	r3, [r2]
  }
  pcb->local_port = port;
  11de4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11de50:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
  11de54:	e1c321ba 	strh	r2, [r3, #26]
  TCP_REG(&tcp_bound_pcbs, pcb);
  11de58:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11de5c:	e3403057 	movt	r3, #87	; 0x57
  11de60:	e5932000 	ldr	r2, [r3]
  11de64:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11de68:	e583200c 	str	r2, [r3, #12]
  11de6c:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11de70:	e3403057 	movt	r3, #87	; 0x57
  11de74:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  11de78:	e5832000 	str	r2, [r3]
  11de7c:	eb00256f 	bl	127440 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  11de80:	e3a03000 	mov	r3, #0
}
  11de84:	e1a00003 	mov	r0, r3
  11de88:	e24bd004 	sub	sp, fp, #4
  11de8c:	e8bd8800 	pop	{fp, pc}

0011de90 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  11de90:	e92d4800 	push	{fp, lr}
  11de94:	e28db004 	add	fp, sp, #4
  11de98:	e24dd010 	sub	sp, sp, #16
  11de9c:	e50b0008 	str	r0, [fp, #-8]
  11dea0:	e50b100c 	str	r1, [fp, #-12]
  11dea4:	e1a03002 	mov	r3, r2
  11dea8:	e54b300d 	strb	r3, [fp, #-13]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(err);

  tcp_abort(pcb);
  11deac:	e51b000c 	ldr	r0, [fp, #-12]
  11deb0:	ebffff59 	bl	11dc1c <tcp_abort>

  return ERR_ABRT;
  11deb4:	e3e0300c 	mvn	r3, #12
}
  11deb8:	e1a00003 	mov	r0, r3
  11debc:	e24bd004 	sub	sp, fp, #4
  11dec0:	e8bd8800 	pop	{fp, pc}

0011dec4 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen_with_backlog(tpcb, backlog);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  11dec4:	e92d4800 	push	{fp, lr}
  11dec8:	e28db004 	add	fp, sp, #4
  11decc:	e24dd008 	sub	sp, sp, #8
  11ded0:	e50b0008 	str	r0, [fp, #-8]
  11ded4:	e1a03001 	mov	r3, r1
  11ded8:	e54b3009 	strb	r3, [fp, #-9]
  return tcp_listen_with_backlog_and_err(pcb, backlog, NULL);
  11dedc:	e55b3009 	ldrb	r3, [fp, #-9]
  11dee0:	e3a02000 	mov	r2, #0
  11dee4:	e1a01003 	mov	r1, r3
  11dee8:	e51b0008 	ldr	r0, [fp, #-8]
  11deec:	eb000003 	bl	11df00 <tcp_listen_with_backlog_and_err>
  11def0:	e1a03000 	mov	r3, r0
}
  11def4:	e1a00003 	mov	r0, r3
  11def8:	e24bd004 	sub	sp, fp, #4
  11defc:	e8bd8800 	pop	{fp, pc}

0011df00 <tcp_listen_with_backlog_and_err>:
 *       called like this:
 *             tpcb = tcp_listen_with_backlog_and_err(tpcb, backlog, &err);
 */
struct tcp_pcb *
tcp_listen_with_backlog_and_err(struct tcp_pcb *pcb, u8_t backlog, err_t *err)
{
  11df00:	e92d4800 	push	{fp, lr}
  11df04:	e28db004 	add	fp, sp, #4
  11df08:	e24dd020 	sub	sp, sp, #32
  11df0c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  11df10:	e1a03001 	mov	r3, r1
  11df14:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  11df18:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
  struct tcp_pcb_listen *lpcb = NULL;
  11df1c:	e3a03000 	mov	r3, #0
  11df20:	e50b3008 	str	r3, [fp, #-8]
  err_t res;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
  11df24:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11df28:	e5933014 	ldr	r3, [r3, #20]
  11df2c:	e3530000 	cmp	r3, #0
  11df30:	0a000009 	beq	11df5c <tcp_listen_with_backlog_and_err+0x5c>
  11df34:	e30801b0 	movw	r0, #33200	; 0x81b0
  11df38:	e3400014 	movt	r0, #20
  11df3c:	ebff9474 	bl	103114 <rt_kprintf>
  11df40:	e30012af 	movw	r1, #687	; 0x2af
  11df44:	e30800f4 	movw	r0, #33012	; 0x80f4
  11df48:	e3400014 	movt	r0, #20
  11df4c:	ebffb44a 	bl	10b07c <sys_arch_assert>
  11df50:	e3e0300e 	mvn	r3, #14
  11df54:	e54b3009 	strb	r3, [fp, #-9]
  11df58:	ea000091 	b	11e1a4 <tcp_listen_with_backlog_and_err+0x2a4>

  /* already listening? */
  if (pcb->state == LISTEN) {
  11df5c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11df60:	e5933014 	ldr	r3, [r3, #20]
  11df64:	e3530001 	cmp	r3, #1
  11df68:	1a000004 	bne	11df80 <tcp_listen_with_backlog_and_err+0x80>
    lpcb = (struct tcp_pcb_listen*)pcb;
  11df6c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11df70:	e50b3008 	str	r3, [fp, #-8]
    res = ERR_ALREADY;
  11df74:	e3e03008 	mvn	r3, #8
  11df78:	e54b3009 	strb	r3, [fp, #-9]
    goto done;
  11df7c:	ea000088 	b	11e1a4 <tcp_listen_with_backlog_and_err+0x2a4>
  }
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
  11df80:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11df84:	e5d33008 	ldrb	r3, [r3, #8]
  11df88:	e2033004 	and	r3, r3, #4
  11df8c:	e3530000 	cmp	r3, #0
  11df90:	0a00001b 	beq	11e004 <tcp_listen_with_backlog_and_err+0x104>
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  11df94:	e3063a38 	movw	r3, #27192	; 0x6a38
  11df98:	e3403057 	movt	r3, #87	; 0x57
  11df9c:	e5933000 	ldr	r3, [r3]
  11dfa0:	e50b3008 	str	r3, [fp, #-8]
  11dfa4:	ea000013 	b	11dff8 <tcp_listen_with_backlog_and_err+0xf8>
      if ((lpcb->local_port == pcb->local_port) &&
  11dfa8:	e51b3008 	ldr	r3, [fp, #-8]
  11dfac:	e1d321ba 	ldrh	r2, [r3, #26]
  11dfb0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11dfb4:	e1d331ba 	ldrh	r3, [r3, #26]
  11dfb8:	e1520003 	cmp	r2, r3
  11dfbc:	1a00000a 	bne	11dfec <tcp_listen_with_backlog_and_err+0xec>
          ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
  11dfc0:	e51b3008 	ldr	r3, [fp, #-8]
  11dfc4:	e5932000 	ldr	r2, [r3]
  11dfc8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11dfcc:	e5933000 	ldr	r3, [r3]
      if ((lpcb->local_port == pcb->local_port) &&
  11dfd0:	e1520003 	cmp	r2, r3
  11dfd4:	1a000004 	bne	11dfec <tcp_listen_with_backlog_and_err+0xec>
        /* this address/port is already used */
        lpcb = NULL;
  11dfd8:	e3a03000 	mov	r3, #0
  11dfdc:	e50b3008 	str	r3, [fp, #-8]
        res = ERR_USE;
  11dfe0:	e3e03007 	mvn	r3, #7
  11dfe4:	e54b3009 	strb	r3, [fp, #-9]
        goto done;
  11dfe8:	ea00006d 	b	11e1a4 <tcp_listen_with_backlog_and_err+0x2a4>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  11dfec:	e51b3008 	ldr	r3, [fp, #-8]
  11dff0:	e593300c 	ldr	r3, [r3, #12]
  11dff4:	e50b3008 	str	r3, [fp, #-8]
  11dff8:	e51b3008 	ldr	r3, [fp, #-8]
  11dffc:	e3530000 	cmp	r3, #0
  11e000:	1affffe8 	bne	11dfa8 <tcp_listen_with_backlog_and_err+0xa8>
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  11e004:	e30022c7 	movw	r2, #711	; 0x2c7
  11e008:	e30810f4 	movw	r1, #33012	; 0x80f4
  11e00c:	e3401014 	movt	r1, #20
  11e010:	e3a00003 	mov	r0, #3
  11e014:	ebffecb0 	bl	1192dc <memp_malloc_fn>
  11e018:	e50b0008 	str	r0, [fp, #-8]
  if (lpcb == NULL) {
  11e01c:	e51b3008 	ldr	r3, [fp, #-8]
  11e020:	e3530000 	cmp	r3, #0
  11e024:	1a000002 	bne	11e034 <tcp_listen_with_backlog_and_err+0x134>
    res = ERR_MEM;
  11e028:	e3e03000 	mvn	r3, #0
  11e02c:	e54b3009 	strb	r3, [fp, #-9]
    goto done;
  11e030:	ea00005b 	b	11e1a4 <tcp_listen_with_backlog_and_err+0x2a4>
  }
  lpcb->callback_arg = pcb->callback_arg;
  11e034:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e038:	e5932010 	ldr	r2, [r3, #16]
  11e03c:	e51b3008 	ldr	r3, [fp, #-8]
  11e040:	e5832010 	str	r2, [r3, #16]
  lpcb->local_port = pcb->local_port;
  11e044:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e048:	e1d321ba 	ldrh	r2, [r3, #26]
  11e04c:	e51b3008 	ldr	r3, [fp, #-8]
  11e050:	e1c321ba 	strh	r2, [r3, #26]
  lpcb->state = LISTEN;
  11e054:	e51b3008 	ldr	r3, [fp, #-8]
  11e058:	e3a02001 	mov	r2, #1
  11e05c:	e5832014 	str	r2, [r3, #20]
  lpcb->prio = pcb->prio;
  11e060:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e064:	e5d32018 	ldrb	r2, [r3, #24]
  11e068:	e51b3008 	ldr	r3, [fp, #-8]
  11e06c:	e5c32018 	strb	r2, [r3, #24]
  lpcb->so_options = pcb->so_options;
  11e070:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e074:	e5d32008 	ldrb	r2, [r3, #8]
  11e078:	e51b3008 	ldr	r3, [fp, #-8]
  11e07c:	e5c32008 	strb	r2, [r3, #8]
  lpcb->ttl = pcb->ttl;
  11e080:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e084:	e5d3200a 	ldrb	r2, [r3, #10]
  11e088:	e51b3008 	ldr	r3, [fp, #-8]
  11e08c:	e5c3200a 	strb	r2, [r3, #10]
  lpcb->tos = pcb->tos;
  11e090:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e094:	e5d32009 	ldrb	r2, [r3, #9]
  11e098:	e51b3008 	ldr	r3, [fp, #-8]
  11e09c:	e5c32009 	strb	r2, [r3, #9]
#if LWIP_IPV4 && LWIP_IPV6
  IP_SET_TYPE_VAL(lpcb->remote_ip, pcb->local_ip.type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
  11e0a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e0a4:	e5932000 	ldr	r2, [r3]
  11e0a8:	e51b3008 	ldr	r3, [fp, #-8]
  11e0ac:	e5832000 	str	r2, [r3]
  if (pcb->local_port != 0) {
  11e0b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e0b4:	e1d331ba 	ldrh	r3, [r3, #26]
  11e0b8:	e3530000 	cmp	r3, #0
  11e0bc:	0a000025 	beq	11e158 <tcp_listen_with_backlog_and_err+0x258>
    TCP_RMV(&tcp_bound_pcbs, pcb);
  11e0c0:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11e0c4:	e3403057 	movt	r3, #87	; 0x57
  11e0c8:	e5933000 	ldr	r3, [r3]
  11e0cc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  11e0d0:	e1520003 	cmp	r2, r3
  11e0d4:	1a000007 	bne	11e0f8 <tcp_listen_with_backlog_and_err+0x1f8>
  11e0d8:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11e0dc:	e3403057 	movt	r3, #87	; 0x57
  11e0e0:	e5933000 	ldr	r3, [r3]
  11e0e4:	e593200c 	ldr	r2, [r3, #12]
  11e0e8:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11e0ec:	e3403057 	movt	r3, #87	; 0x57
  11e0f0:	e5832000 	str	r2, [r3]
  11e0f4:	ea000014 	b	11e14c <tcp_listen_with_backlog_and_err+0x24c>
  11e0f8:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11e0fc:	e3403057 	movt	r3, #87	; 0x57
  11e100:	e5933000 	ldr	r3, [r3]
  11e104:	e50b3010 	str	r3, [fp, #-16]
  11e108:	ea00000c 	b	11e140 <tcp_listen_with_backlog_and_err+0x240>
  11e10c:	e51b3010 	ldr	r3, [fp, #-16]
  11e110:	e593300c 	ldr	r3, [r3, #12]
  11e114:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  11e118:	e1520003 	cmp	r2, r3
  11e11c:	1a000004 	bne	11e134 <tcp_listen_with_backlog_and_err+0x234>
  11e120:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e124:	e593200c 	ldr	r2, [r3, #12]
  11e128:	e51b3010 	ldr	r3, [fp, #-16]
  11e12c:	e583200c 	str	r2, [r3, #12]
  11e130:	ea000005 	b	11e14c <tcp_listen_with_backlog_and_err+0x24c>
  11e134:	e51b3010 	ldr	r3, [fp, #-16]
  11e138:	e593300c 	ldr	r3, [r3, #12]
  11e13c:	e50b3010 	str	r3, [fp, #-16]
  11e140:	e51b3010 	ldr	r3, [fp, #-16]
  11e144:	e3530000 	cmp	r3, #0
  11e148:	1affffef 	bne	11e10c <tcp_listen_with_backlog_and_err+0x20c>
  11e14c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e150:	e3a02000 	mov	r2, #0
  11e154:	e583200c 	str	r2, [r3, #12]
  }
  memp_free(MEMP_TCP_PCB, pcb);
  11e158:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  11e15c:	e3a00002 	mov	r0, #2
  11e160:	ebffecc5 	bl	11947c <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  11e164:	e51b2008 	ldr	r2, [fp, #-8]
  11e168:	e30d3e90 	movw	r3, #56976	; 0xde90
  11e16c:	e3403011 	movt	r3, #17
  11e170:	e582301c 	str	r3, [r2, #28]
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  tcp_backlog_set(lpcb, backlog);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
  11e174:	e3063a38 	movw	r3, #27192	; 0x6a38
  11e178:	e3403057 	movt	r3, #87	; 0x57
  11e17c:	e5932000 	ldr	r2, [r3]
  11e180:	e51b3008 	ldr	r3, [fp, #-8]
  11e184:	e583200c 	str	r2, [r3, #12]
  11e188:	e3063a38 	movw	r3, #27192	; 0x6a38
  11e18c:	e3403057 	movt	r3, #87	; 0x57
  11e190:	e51b2008 	ldr	r2, [fp, #-8]
  11e194:	e5832000 	str	r2, [r3]
  11e198:	eb0024a8 	bl	127440 <tcp_timer_needed>
  res = ERR_OK;
  11e19c:	e3a03000 	mov	r3, #0
  11e1a0:	e54b3009 	strb	r3, [fp, #-9]
done:
  if (err != NULL) {
  11e1a4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11e1a8:	e3530000 	cmp	r3, #0
  11e1ac:	0a000002 	beq	11e1bc <tcp_listen_with_backlog_and_err+0x2bc>
    *err = res;
  11e1b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11e1b4:	e55b2009 	ldrb	r2, [fp, #-9]
  11e1b8:	e5c32000 	strb	r2, [r3]
  }
  return (struct tcp_pcb *)lpcb;
  11e1bc:	e51b3008 	ldr	r3, [fp, #-8]
}
  11e1c0:	e1a00003 	mov	r0, r3
  11e1c4:	e24bd004 	sub	sp, fp, #4
  11e1c8:	e8bd8800 	pop	{fp, pc}

0011e1cc <tcp_update_rcv_ann_wnd>:
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t
tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  11e1cc:	e92d4800 	push	{fp, lr}
  11e1d0:	e28db004 	add	fp, sp, #4
  11e1d4:	e24dd010 	sub	sp, sp, #16
  11e1d8:	e50b0010 	str	r0, [fp, #-16]
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
  11e1dc:	e51b3010 	ldr	r3, [fp, #-16]
  11e1e0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  11e1e4:	e51b2010 	ldr	r2, [fp, #-16]
  11e1e8:	e1d222bc 	ldrh	r2, [r2, #44]	; 0x2c
  11e1ec:	e0833002 	add	r3, r3, r2
  11e1f0:	e50b3008 	str	r3, [fp, #-8]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
  11e1f4:	e51b3010 	ldr	r3, [fp, #-16]
  11e1f8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  11e1fc:	e51b2010 	ldr	r2, [fp, #-16]
  11e200:	e1d223b6 	ldrh	r2, [r2, #54]	; 0x36
  11e204:	e6bf2072 	sxth	r2, r2
  11e208:	e3520000 	cmp	r2, #0
  11e20c:	ba000002 	blt	11e21c <tcp_update_rcv_ann_wnd+0x50>
  11e210:	e51b2010 	ldr	r2, [fp, #-16]
  11e214:	e1d223b6 	ldrh	r2, [r2, #54]	; 0x36
  11e218:	ea000000 	b	11e220 <tcp_update_rcv_ann_wnd+0x54>
  11e21c:	e3072fff 	movw	r2, #32767	; 0x7fff
  11e220:	e0823003 	add	r3, r2, r3
  11e224:	e51b2008 	ldr	r2, [fp, #-8]
  11e228:	e0423003 	sub	r3, r2, r3
  11e22c:	e3530000 	cmp	r3, #0
  11e230:	ba000008 	blt	11e258 <tcp_update_rcv_ann_wnd+0x8c>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
  11e234:	e51b3010 	ldr	r3, [fp, #-16]
  11e238:	e1d322bc 	ldrh	r2, [r3, #44]	; 0x2c
  11e23c:	e51b3010 	ldr	r3, [fp, #-16]
  11e240:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
    return new_right_edge - pcb->rcv_ann_right_edge;
  11e244:	e51b3010 	ldr	r3, [fp, #-16]
  11e248:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  11e24c:	e51b2008 	ldr	r2, [fp, #-8]
  11e250:	e0423003 	sub	r3, r2, r3
  11e254:	ea00001f 	b	11e2d8 <tcp_update_rcv_ann_wnd+0x10c>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
  11e258:	e51b3010 	ldr	r3, [fp, #-16]
  11e25c:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  11e260:	e51b3010 	ldr	r3, [fp, #-16]
  11e264:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  11e268:	e0423003 	sub	r3, r2, r3
  11e26c:	e3530000 	cmp	r3, #0
  11e270:	da000003 	ble	11e284 <tcp_update_rcv_ann_wnd+0xb8>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
  11e274:	e51b3010 	ldr	r3, [fp, #-16]
  11e278:	e3a02000 	mov	r2, #0
  11e27c:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
  11e280:	ea000013 	b	11e2d4 <tcp_update_rcv_ann_wnd+0x108>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
  11e284:	e51b3010 	ldr	r3, [fp, #-16]
  11e288:	e5932030 	ldr	r2, [r3, #48]	; 0x30
  11e28c:	e51b3010 	ldr	r3, [fp, #-16]
  11e290:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  11e294:	e0423003 	sub	r3, r2, r3
  11e298:	e50b300c 	str	r3, [fp, #-12]
#if !LWIP_WND_SCALE
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
  11e29c:	e51b300c 	ldr	r3, [fp, #-12]
  11e2a0:	e3530801 	cmp	r3, #65536	; 0x10000
  11e2a4:	3a000006 	bcc	11e2c4 <tcp_update_rcv_ann_wnd+0xf8>
  11e2a8:	e30801d4 	movw	r0, #33236	; 0x81d4
  11e2ac:	e3400014 	movt	r0, #20
  11e2b0:	ebff9397 	bl	103114 <rt_kprintf>
  11e2b4:	e3001303 	movw	r1, #771	; 0x303
  11e2b8:	e30800f4 	movw	r0, #33012	; 0x80f4
  11e2bc:	e3400014 	movt	r0, #20
  11e2c0:	ebffb36d 	bl	10b07c <sys_arch_assert>
#endif
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
  11e2c4:	e51b300c 	ldr	r3, [fp, #-12]
  11e2c8:	e6ff2073 	uxth	r2, r3
  11e2cc:	e51b3010 	ldr	r3, [fp, #-16]
  11e2d0:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
    }
    return 0;
  11e2d4:	e3a03000 	mov	r3, #0
  }
}
  11e2d8:	e1a00003 	mov	r0, r3
  11e2dc:	e24bd004 	sub	sp, fp, #4
  11e2e0:	e8bd8800 	pop	{fp, pc}

0011e2e4 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  11e2e4:	e92d4800 	push	{fp, lr}
  11e2e8:	e28db004 	add	fp, sp, #4
  11e2ec:	e24dd010 	sub	sp, sp, #16
  11e2f0:	e50b0010 	str	r0, [fp, #-16]
  11e2f4:	e1a03001 	mov	r3, r1
  11e2f8:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
  11e2fc:	e51b3010 	ldr	r3, [fp, #-16]
  11e300:	e5933014 	ldr	r3, [r3, #20]
  11e304:	e3530001 	cmp	r3, #1
  11e308:	1a000006 	bne	11e328 <tcp_recved+0x44>
  11e30c:	e30801f0 	movw	r0, #33264	; 0x81f0
  11e310:	e3400014 	movt	r0, #20
  11e314:	ebff937e 	bl	103114 <rt_kprintf>
  11e318:	e300131b 	movw	r1, #795	; 0x31b
  11e31c:	e30800f4 	movw	r0, #33012	; 0x80f4
  11e320:	e3400014 	movt	r0, #20
  11e324:	ebffb354 	bl	10b07c <sys_arch_assert>
    pcb->state != LISTEN);

  pcb->rcv_wnd += len;
  11e328:	e51b3010 	ldr	r3, [fp, #-16]
  11e32c:	e1d322bc 	ldrh	r2, [r3, #44]	; 0x2c
  11e330:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  11e334:	e0823003 	add	r3, r2, r3
  11e338:	e6ff2073 	uxth	r2, r3
  11e33c:	e51b3010 	ldr	r3, [fp, #-16]
  11e340:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
  if (pcb->rcv_wnd > TCP_WND_MAX(pcb)) {
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
  } else if (pcb->rcv_wnd == 0) {
  11e344:	e51b3010 	ldr	r3, [fp, #-16]
  11e348:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  11e34c:	e3530000 	cmp	r3, #0
  11e350:	1a000012 	bne	11e3a0 <tcp_recved+0xbc>
    /* rcv_wnd overflowed */
    if ((pcb->state == CLOSE_WAIT) || (pcb->state == LAST_ACK)) {
  11e354:	e51b3010 	ldr	r3, [fp, #-16]
  11e358:	e5933014 	ldr	r3, [r3, #20]
  11e35c:	e3530007 	cmp	r3, #7
  11e360:	0a000003 	beq	11e374 <tcp_recved+0x90>
  11e364:	e51b3010 	ldr	r3, [fp, #-16]
  11e368:	e5933014 	ldr	r3, [r3, #20]
  11e36c:	e3530009 	cmp	r3, #9
  11e370:	1a000003 	bne	11e384 <tcp_recved+0xa0>
      /* In passive close, we allow this, since the FIN bit is added to rcv_wnd
         by the stack itself, since it is not mandatory for an application
         to call tcp_recved() for the FIN bit, but e.g. the netconn API does so. */
      pcb->rcv_wnd = TCP_WND_MAX(pcb);
  11e374:	e51b3010 	ldr	r3, [fp, #-16]
  11e378:	e3e02000 	mvn	r2, #0
  11e37c:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
  11e380:	ea000006 	b	11e3a0 <tcp_recved+0xbc>
    } else {
      LWIP_ASSERT("tcp_recved: len wrapped rcv_wnd\n", 0);
  11e384:	e3080218 	movw	r0, #33304	; 0x8218
  11e388:	e3400014 	movt	r0, #20
  11e38c:	ebff9360 	bl	103114 <rt_kprintf>
  11e390:	e3a01fca 	mov	r1, #808	; 0x328
  11e394:	e30800f4 	movw	r0, #33012	; 0x80f4
  11e398:	e3400014 	movt	r0, #20
  11e39c:	ebffb336 	bl	10b07c <sys_arch_assert>
    }
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
  11e3a0:	e51b0010 	ldr	r0, [fp, #-16]
  11e3a4:	ebffff88 	bl	11e1cc <tcp_update_rcv_ann_wnd>
  11e3a8:	e1a03000 	mov	r3, r0
  11e3ac:	e50b3008 	str	r3, [fp, #-8]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
  11e3b0:	e51b3008 	ldr	r3, [fp, #-8]
  11e3b4:	e30126cf 	movw	r2, #5839	; 0x16cf
  11e3b8:	e1530002 	cmp	r3, r2
  11e3bc:	da000007 	ble	11e3e0 <tcp_recved+0xfc>
    tcp_ack_now(pcb);
  11e3c0:	e51b3010 	ldr	r3, [fp, #-16]
  11e3c4:	e5d3301e 	ldrb	r3, [r3, #30]
  11e3c8:	e3833002 	orr	r3, r3, #2
  11e3cc:	e6ef2073 	uxtb	r2, r3
  11e3d0:	e51b3010 	ldr	r3, [fp, #-16]
  11e3d4:	e5c3201e 	strb	r2, [r3, #30]
    tcp_output(pcb);
  11e3d8:	e51b0010 	ldr	r0, [fp, #-16]
  11e3dc:	eb001f5e 	bl	12615c <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
         len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
}
  11e3e0:	e320f000 	nop	{0}
  11e3e4:	e24bd004 	sub	sp, fp, #4
  11e3e8:	e8bd8800 	pop	{fp, pc}

0011e3ec <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  11e3ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11e3f0:	e28db000 	add	fp, sp, #0
  11e3f4:	e24dd00c 	sub	sp, sp, #12
  u8_t i;
  u16_t n = 0;
  11e3f8:	e3a03000 	mov	r3, #0
  11e3fc:	e14b30b8 	strh	r3, [fp, #-8]
  struct tcp_pcb *pcb;

again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
  11e400:	e30e3030 	movw	r3, #57392	; 0xe030
  11e404:	e3403014 	movt	r3, #20
  11e408:	e1d320b0 	ldrh	r2, [r3]
  11e40c:	e2823001 	add	r3, r2, #1
  11e410:	e6ff1073 	uxth	r1, r3
  11e414:	e30e3030 	movw	r3, #57392	; 0xe030
  11e418:	e3403014 	movt	r3, #20
  11e41c:	e1c310b0 	strh	r1, [r3]
  11e420:	e30f3fff 	movw	r3, #65535	; 0xffff
  11e424:	e1520003 	cmp	r2, r3
  11e428:	1a000003 	bne	11e43c <tcp_new_port+0x50>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  11e42c:	e30e3030 	movw	r3, #57392	; 0xe030
  11e430:	e3403014 	movt	r3, #20
  11e434:	e3a02903 	mov	r2, #49152	; 0xc000
  11e438:	e1c320b0 	strh	r2, [r3]
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
  11e43c:	e3a03000 	mov	r3, #0
  11e440:	e54b3005 	strb	r3, [fp, #-5]
  11e444:	ea00001e 	b	11e4c4 <tcp_new_port+0xd8>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
  11e448:	e55b2005 	ldrb	r2, [fp, #-5]
  11e44c:	e30830d8 	movw	r3, #32984	; 0x80d8
  11e450:	e3403014 	movt	r3, #20
  11e454:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  11e458:	e5933000 	ldr	r3, [r3]
  11e45c:	e50b300c 	str	r3, [fp, #-12]
  11e460:	ea000011 	b	11e4ac <tcp_new_port+0xc0>
      if (pcb->local_port == tcp_port) {
  11e464:	e51b300c 	ldr	r3, [fp, #-12]
  11e468:	e1d321ba 	ldrh	r2, [r3, #26]
  11e46c:	e30e3030 	movw	r3, #57392	; 0xe030
  11e470:	e3403014 	movt	r3, #20
  11e474:	e1d330b0 	ldrh	r3, [r3]
  11e478:	e1520003 	cmp	r2, r3
  11e47c:	1a000007 	bne	11e4a0 <tcp_new_port+0xb4>
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
  11e480:	e15b30b8 	ldrh	r3, [fp, #-8]
  11e484:	e2833001 	add	r3, r3, #1
  11e488:	e14b30b8 	strh	r3, [fp, #-8]
  11e48c:	e15b30b8 	ldrh	r3, [fp, #-8]
  11e490:	e3530901 	cmp	r3, #16384	; 0x4000
  11e494:	3affffd9 	bcc	11e400 <tcp_new_port+0x14>
          return 0;
  11e498:	e3a03000 	mov	r3, #0
  11e49c:	ea00000e 	b	11e4dc <tcp_new_port+0xf0>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
  11e4a0:	e51b300c 	ldr	r3, [fp, #-12]
  11e4a4:	e593300c 	ldr	r3, [r3, #12]
  11e4a8:	e50b300c 	str	r3, [fp, #-12]
  11e4ac:	e51b300c 	ldr	r3, [fp, #-12]
  11e4b0:	e3530000 	cmp	r3, #0
  11e4b4:	1affffea 	bne	11e464 <tcp_new_port+0x78>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
  11e4b8:	e55b3005 	ldrb	r3, [fp, #-5]
  11e4bc:	e2833001 	add	r3, r3, #1
  11e4c0:	e54b3005 	strb	r3, [fp, #-5]
  11e4c4:	e55b3005 	ldrb	r3, [fp, #-5]
  11e4c8:	e3530003 	cmp	r3, #3
  11e4cc:	9affffdd 	bls	11e448 <tcp_new_port+0x5c>
        }
        goto again;
      }
    }
  }
  return tcp_port;
  11e4d0:	e30e3030 	movw	r3, #57392	; 0xe030
  11e4d4:	e3403014 	movt	r3, #20
  11e4d8:	e1d330b0 	ldrh	r3, [r3]
}
  11e4dc:	e1a00003 	mov	r0, r3
  11e4e0:	e28bd000 	add	sp, fp, #0
  11e4e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11e4e8:	e12fff1e 	bx	lr

0011e4ec <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
      tcp_connected_fn connected)
{
  11e4ec:	e92d4800 	push	{fp, lr}
  11e4f0:	e28db004 	add	fp, sp, #4
  11e4f4:	e24dd030 	sub	sp, sp, #48	; 0x30
  11e4f8:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  11e4fc:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  11e500:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
  11e504:	e1a03002 	mov	r3, r2
  11e508:	e14b32be 	strh	r3, [fp, #-46]	; 0xffffffd2
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  if ((pcb == NULL) || (ipaddr == NULL)) {
  11e50c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e510:	e3530000 	cmp	r3, #0
  11e514:	0a000002 	beq	11e524 <tcp_connect+0x38>
  11e518:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11e51c:	e3530000 	cmp	r3, #0
  11e520:	1a000001 	bne	11e52c <tcp_connect+0x40>
    return ERR_VAL;
  11e524:	e3e03005 	mvn	r3, #5
  11e528:	ea000101 	b	11e934 <tcp_connect+0x448>
  }

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  11e52c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e530:	e5933014 	ldr	r3, [r3, #20]
  11e534:	e3530000 	cmp	r3, #0
  11e538:	0a000008 	beq	11e560 <tcp_connect+0x74>
  11e53c:	e308023c 	movw	r0, #33340	; 0x823c
  11e540:	e3400014 	movt	r0, #20
  11e544:	ebff92f2 	bl	103114 <rt_kprintf>
  11e548:	e3001373 	movw	r1, #883	; 0x373
  11e54c:	e30800f4 	movw	r0, #33012	; 0x80f4
  11e550:	e3400014 	movt	r0, #20
  11e554:	ebffb2c8 	bl	10b07c <sys_arch_assert>
  11e558:	e3e03009 	mvn	r3, #9
  11e55c:	ea0000f4 	b	11e934 <tcp_connect+0x448>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  ip_addr_set(&pcb->remote_ip, ipaddr);
  11e560:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11e564:	e3530000 	cmp	r3, #0
  11e568:	0a000002 	beq	11e578 <tcp_connect+0x8c>
  11e56c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11e570:	e5933000 	ldr	r3, [r3]
  11e574:	ea000000 	b	11e57c <tcp_connect+0x90>
  11e578:	e3a03000 	mov	r3, #0
  11e57c:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  11e580:	e5823004 	str	r3, [r2, #4]
  pcb->remote_port = port;
  11e584:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e588:	e15b22be 	ldrh	r2, [fp, #-46]	; 0xffffffd2
  11e58c:	e1c321bc 	strh	r2, [r3, #28]

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&pcb->local_ip)) {
  11e590:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e594:	e3530000 	cmp	r3, #0
  11e598:	0a000003 	beq	11e5ac <tcp_connect+0xc0>
  11e59c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e5a0:	e5933000 	ldr	r3, [r3]
  11e5a4:	e3530000 	cmp	r3, #0
  11e5a8:	1a000018 	bne	11e610 <tcp_connect+0x124>
    /* no local IP address set, yet. */
    struct netif *netif;
    const ip_addr_t *local_ip;
    ip_route_get_local_ip(&pcb->local_ip, &pcb->remote_ip, netif, local_ip);
  11e5ac:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e5b0:	e2833004 	add	r3, r3, #4
  11e5b4:	e1a00003 	mov	r0, r3
  11e5b8:	eb004b74 	bl	131390 <ip4_route>
  11e5bc:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  11e5c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11e5c4:	e3530000 	cmp	r3, #0
  11e5c8:	0a000002 	beq	11e5d8 <tcp_connect+0xec>
  11e5cc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11e5d0:	e2833004 	add	r3, r3, #4
  11e5d4:	ea000000 	b	11e5dc <tcp_connect+0xf0>
  11e5d8:	e3a03000 	mov	r3, #0
  11e5dc:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    if ((netif == NULL) || (local_ip == NULL)) {
  11e5e0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  11e5e4:	e3530000 	cmp	r3, #0
  11e5e8:	0a000002 	beq	11e5f8 <tcp_connect+0x10c>
  11e5ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e5f0:	e3530000 	cmp	r3, #0
  11e5f4:	1a000001 	bne	11e600 <tcp_connect+0x114>
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
  11e5f8:	e3e03003 	mvn	r3, #3
  11e5fc:	ea0000cc 	b	11e934 <tcp_connect+0x448>
    }
    /* Use the address as local address of the pcb. */
    ip_addr_copy(pcb->local_ip, *local_ip);
  11e600:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11e604:	e5932000 	ldr	r2, [r3]
  11e608:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e60c:	e5832000 	str	r2, [r3]
  }

  old_local_port = pcb->local_port;
  11e610:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e614:	e1d331ba 	ldrh	r3, [r3, #26]
  11e618:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
  if (pcb->local_port == 0) {
  11e61c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e620:	e1d331ba 	ldrh	r3, [r3, #26]
  11e624:	e3530000 	cmp	r3, #0
  11e628:	1a00000a 	bne	11e658 <tcp_connect+0x16c>
    pcb->local_port = tcp_new_port();
  11e62c:	ebffff6e 	bl	11e3ec <tcp_new_port>
  11e630:	e1a03000 	mov	r3, r0
  11e634:	e1a02003 	mov	r2, r3
  11e638:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e63c:	e1c321ba 	strh	r2, [r3, #26]
    if (pcb->local_port == 0) {
  11e640:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e644:	e1d331ba 	ldrh	r3, [r3, #26]
  11e648:	e3530000 	cmp	r3, #0
  11e64c:	1a000035 	bne	11e728 <tcp_connect+0x23c>
      return ERR_BUF;
  11e650:	e3e03001 	mvn	r3, #1
  11e654:	ea0000b6 	b	11e934 <tcp_connect+0x448>
    }
  } else {
#if SO_REUSE
    if (ip_get_option(pcb, SOF_REUSEADDR)) {
  11e658:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e65c:	e5d33008 	ldrb	r3, [r3, #8]
  11e660:	e2033004 	and	r3, r3, #4
  11e664:	e3530000 	cmp	r3, #0
  11e668:	0a00002e 	beq	11e728 <tcp_connect+0x23c>
      /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
         now that the 5-tuple is unique. */
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
  11e66c:	e3a03002 	mov	r3, #2
  11e670:	e50b300c 	str	r3, [fp, #-12]
  11e674:	ea000028 	b	11e71c <tcp_connect+0x230>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
  11e678:	e30830d8 	movw	r3, #32984	; 0x80d8
  11e67c:	e3403014 	movt	r3, #20
  11e680:	e51b200c 	ldr	r2, [fp, #-12]
  11e684:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  11e688:	e5933000 	ldr	r3, [r3]
  11e68c:	e50b3008 	str	r3, [fp, #-8]
  11e690:	ea00001b 	b	11e704 <tcp_connect+0x218>
          if ((cpcb->local_port == pcb->local_port) &&
  11e694:	e51b3008 	ldr	r3, [fp, #-8]
  11e698:	e1d321ba 	ldrh	r2, [r3, #26]
  11e69c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e6a0:	e1d331ba 	ldrh	r3, [r3, #26]
  11e6a4:	e1520003 	cmp	r2, r3
  11e6a8:	1a000012 	bne	11e6f8 <tcp_connect+0x20c>
              (cpcb->remote_port == port) &&
  11e6ac:	e51b3008 	ldr	r3, [fp, #-8]
  11e6b0:	e1d331bc 	ldrh	r3, [r3, #28]
          if ((cpcb->local_port == pcb->local_port) &&
  11e6b4:	e15b22be 	ldrh	r2, [fp, #-46]	; 0xffffffd2
  11e6b8:	e1520003 	cmp	r2, r3
  11e6bc:	1a00000d 	bne	11e6f8 <tcp_connect+0x20c>
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
  11e6c0:	e51b3008 	ldr	r3, [fp, #-8]
  11e6c4:	e5932000 	ldr	r2, [r3]
  11e6c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e6cc:	e5933000 	ldr	r3, [r3]
              (cpcb->remote_port == port) &&
  11e6d0:	e1520003 	cmp	r2, r3
  11e6d4:	1a000007 	bne	11e6f8 <tcp_connect+0x20c>
              ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
  11e6d8:	e51b3008 	ldr	r3, [fp, #-8]
  11e6dc:	e5932004 	ldr	r2, [r3, #4]
  11e6e0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  11e6e4:	e5933000 	ldr	r3, [r3]
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
  11e6e8:	e1520003 	cmp	r2, r3
  11e6ec:	1a000001 	bne	11e6f8 <tcp_connect+0x20c>
            /* linux returns EISCONN here, but ERR_USE should be OK for us */
            return ERR_USE;
  11e6f0:	e3e03007 	mvn	r3, #7
  11e6f4:	ea00008e 	b	11e934 <tcp_connect+0x448>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
  11e6f8:	e51b3008 	ldr	r3, [fp, #-8]
  11e6fc:	e593300c 	ldr	r3, [r3, #12]
  11e700:	e50b3008 	str	r3, [fp, #-8]
  11e704:	e51b3008 	ldr	r3, [fp, #-8]
  11e708:	e3530000 	cmp	r3, #0
  11e70c:	1affffe0 	bne	11e694 <tcp_connect+0x1a8>
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
  11e710:	e51b300c 	ldr	r3, [fp, #-12]
  11e714:	e2833001 	add	r3, r3, #1
  11e718:	e50b300c 	str	r3, [fp, #-12]
  11e71c:	e51b300c 	ldr	r3, [fp, #-12]
  11e720:	e3530003 	cmp	r3, #3
  11e724:	daffffd3 	ble	11e678 <tcp_connect+0x18c>
      }
    }
#endif /* SO_REUSE */
  }

  iss = tcp_next_iss(pcb);
  11e728:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  11e72c:	eb0006bd 	bl	120228 <tcp_next_iss>
  11e730:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  pcb->rcv_nxt = 0;
  11e734:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e738:	e3a02000 	mov	r2, #0
  11e73c:	e5832028 	str	r2, [r3, #40]	; 0x28
  pcb->snd_nxt = iss;
  11e740:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e744:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  11e748:	e5832050 	str	r2, [r3, #80]	; 0x50
  pcb->lastack = iss - 1;
  11e74c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11e750:	e2432001 	sub	r2, r3, #1
  11e754:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e758:	e5832048 	str	r2, [r3, #72]	; 0x48
  pcb->snd_wl2 = iss - 1;
  11e75c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11e760:	e2432001 	sub	r2, r3, #1
  11e764:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e768:	e5832058 	str	r2, [r3, #88]	; 0x58
  pcb->snd_lbb = iss - 1;
  11e76c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11e770:	e2432001 	sub	r2, r3, #1
  11e774:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e778:	e583205c 	str	r2, [r3, #92]	; 0x5c
  /* Start with a window that does not need scaling. When window scaling is
     enabled and used, the window is enlarged when both sides agree on scaling. */
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
  11e77c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e780:	e3e02000 	mvn	r2, #0
  11e784:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
  11e788:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e78c:	e1d322be 	ldrh	r2, [r3, #46]	; 0x2e
  11e790:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e794:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
  11e798:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e79c:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  11e7a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e7a4:	e5832030 	str	r2, [r3, #48]	; 0x30
  pcb->snd_wnd = TCP_WND;
  11e7a8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e7ac:	e3e02000 	mvn	r2, #0
  11e7b0:	e1c326b0 	strh	r2, [r3, #96]	; 0x60
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = INITIAL_MSS;
  11e7b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e7b8:	e3a02f86 	mov	r2, #536	; 0x218
  11e7bc:	e1c323b6 	strh	r2, [r3, #54]	; 0x36
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
  11e7c0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e7c4:	e1d323b6 	ldrh	r2, [r3, #54]	; 0x36
  11e7c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e7cc:	e2833004 	add	r3, r3, #4
  11e7d0:	e1a01003 	mov	r1, r3
  11e7d4:	e1a00002 	mov	r0, r2
  11e7d8:	eb0006a7 	bl	12027c <tcp_eff_send_mss_impl>
  11e7dc:	e1a03000 	mov	r3, r0
  11e7e0:	e1a02003 	mov	r2, r3
  11e7e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e7e8:	e1c323b6 	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  11e7ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e7f0:	e3a02001 	mov	r2, #1
  11e7f4:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
#if LWIP_CALLBACK_API
  pcb->connected = connected;
  11e7f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e7fc:	e51b2034 	ldr	r2, [fp, #-52]	; 0xffffffcc
  11e800:	e5832088 	str	r2, [r3, #136]	; 0x88
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
  11e804:	e3a01002 	mov	r1, #2
  11e808:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  11e80c:	eb001d03 	bl	125c20 <tcp_enqueue_flags>
  11e810:	e1a03000 	mov	r3, r0
  11e814:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
  if (ret == ERR_OK) {
  11e818:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
  11e81c:	e3530000 	cmp	r3, #0
  11e820:	1a000042 	bne	11e930 <tcp_connect+0x444>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
  11e824:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e828:	e3a02002 	mov	r2, #2
  11e82c:	e5832014 	str	r2, [r3, #20]
    if (old_local_port != 0) {
  11e830:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  11e834:	e3530000 	cmp	r3, #0
  11e838:	0a000025 	beq	11e8d4 <tcp_connect+0x3e8>
      TCP_RMV(&tcp_bound_pcbs, pcb);
  11e83c:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11e840:	e3403057 	movt	r3, #87	; 0x57
  11e844:	e5933000 	ldr	r3, [r3]
  11e848:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  11e84c:	e1520003 	cmp	r2, r3
  11e850:	1a000007 	bne	11e874 <tcp_connect+0x388>
  11e854:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11e858:	e3403057 	movt	r3, #87	; 0x57
  11e85c:	e5933000 	ldr	r3, [r3]
  11e860:	e593200c 	ldr	r2, [r3, #12]
  11e864:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11e868:	e3403057 	movt	r3, #87	; 0x57
  11e86c:	e5832000 	str	r2, [r3]
  11e870:	ea000014 	b	11e8c8 <tcp_connect+0x3dc>
  11e874:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  11e878:	e3403057 	movt	r3, #87	; 0x57
  11e87c:	e5933000 	ldr	r3, [r3]
  11e880:	e50b3010 	str	r3, [fp, #-16]
  11e884:	ea00000c 	b	11e8bc <tcp_connect+0x3d0>
  11e888:	e51b3010 	ldr	r3, [fp, #-16]
  11e88c:	e593300c 	ldr	r3, [r3, #12]
  11e890:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  11e894:	e1520003 	cmp	r2, r3
  11e898:	1a000004 	bne	11e8b0 <tcp_connect+0x3c4>
  11e89c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e8a0:	e593200c 	ldr	r2, [r3, #12]
  11e8a4:	e51b3010 	ldr	r3, [fp, #-16]
  11e8a8:	e583200c 	str	r2, [r3, #12]
  11e8ac:	ea000005 	b	11e8c8 <tcp_connect+0x3dc>
  11e8b0:	e51b3010 	ldr	r3, [fp, #-16]
  11e8b4:	e593300c 	ldr	r3, [r3, #12]
  11e8b8:	e50b3010 	str	r3, [fp, #-16]
  11e8bc:	e51b3010 	ldr	r3, [fp, #-16]
  11e8c0:	e3530000 	cmp	r3, #0
  11e8c4:	1affffef 	bne	11e888 <tcp_connect+0x39c>
  11e8c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e8cc:	e3a02000 	mov	r2, #0
  11e8d0:	e583200c 	str	r2, [r3, #12]
    }
    TCP_REG_ACTIVE(pcb);
  11e8d4:	e3063a30 	movw	r3, #27184	; 0x6a30
  11e8d8:	e3403057 	movt	r3, #87	; 0x57
  11e8dc:	e5932000 	ldr	r2, [r3]
  11e8e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  11e8e4:	e583200c 	str	r2, [r3, #12]
  11e8e8:	e3063a30 	movw	r3, #27184	; 0x6a30
  11e8ec:	e3403057 	movt	r3, #87	; 0x57
  11e8f0:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  11e8f4:	e5832000 	str	r2, [r3]
  11e8f8:	eb0022d0 	bl	127440 <tcp_timer_needed>
  11e8fc:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11e900:	e3403057 	movt	r3, #87	; 0x57
  11e904:	e3a02001 	mov	r2, #1
  11e908:	e5c32000 	strb	r2, [r3]
    MIB2_STATS_INC(mib2.tcpactiveopens);
  11e90c:	e3063840 	movw	r3, #26688	; 0x6840
  11e910:	e3403057 	movt	r3, #87	; 0x57
  11e914:	e593316c 	ldr	r3, [r3, #364]	; 0x16c
  11e918:	e2832001 	add	r2, r3, #1
  11e91c:	e3063840 	movw	r3, #26688	; 0x6840
  11e920:	e3403057 	movt	r3, #87	; 0x57
  11e924:	e583216c 	str	r2, [r3, #364]	; 0x16c

    tcp_output(pcb);
  11e928:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  11e92c:	eb001e0a 	bl	12615c <tcp_output>
  }
  return ret;
  11e930:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
}
  11e934:	e1a00003 	mov	r0, r3
  11e938:	e24bd004 	sub	sp, fp, #4
  11e93c:	e8bd8800 	pop	{fp, pc}

0011e940 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  11e940:	e92d4800 	push	{fp, lr}
  11e944:	e28db004 	add	fp, sp, #4
  11e948:	e24dd030 	sub	sp, sp, #48	; 0x30
  tcpwnd_size_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
  11e94c:	e3a03000 	mov	r3, #0
  11e950:	e54b300f 	strb	r3, [fp, #-15]

  ++tcp_ticks;
  11e954:	e3063a34 	movw	r3, #27188	; 0x6a34
  11e958:	e3403057 	movt	r3, #87	; 0x57
  11e95c:	e5933000 	ldr	r3, [r3]
  11e960:	e2832001 	add	r2, r3, #1
  11e964:	e3063a34 	movw	r3, #27188	; 0x6a34
  11e968:	e3403057 	movt	r3, #87	; 0x57
  11e96c:	e5832000 	str	r2, [r3]
  ++tcp_timer_ctr;
  11e970:	e30f321d 	movw	r3, #61981	; 0xf21d
  11e974:	e3403014 	movt	r3, #20
  11e978:	e5d33000 	ldrb	r3, [r3]
  11e97c:	e2833001 	add	r3, r3, #1
  11e980:	e6ef2073 	uxtb	r2, r3
  11e984:	e30f321d 	movw	r3, #61981	; 0xf21d
  11e988:	e3403014 	movt	r3, #20
  11e98c:	e5c32000 	strb	r2, [r3]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
  11e990:	e3a03000 	mov	r3, #0
  11e994:	e50b300c 	str	r3, [fp, #-12]
  pcb = tcp_active_pcbs;
  11e998:	e3063a30 	movw	r3, #27184	; 0x6a30
  11e99c:	e3403057 	movt	r3, #87	; 0x57
  11e9a0:	e5933000 	ldr	r3, [r3]
  11e9a4:	e50b3008 	str	r3, [fp, #-8]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  11e9a8:	ea0001f2 	b	11f178 <tcp_slowtmr+0x838>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  11e9ac:	e51b3008 	ldr	r3, [fp, #-8]
  11e9b0:	e5933014 	ldr	r3, [r3, #20]
  11e9b4:	e3530000 	cmp	r3, #0
  11e9b8:	1a000006 	bne	11e9d8 <tcp_slowtmr+0x98>
  11e9bc:	e308026c 	movw	r0, #33388	; 0x826c
  11e9c0:	e3400014 	movt	r0, #20
  11e9c4:	ebff91d2 	bl	103114 <rt_kprintf>
  11e9c8:	e30013eb 	movw	r1, #1003	; 0x3eb
  11e9cc:	e30800f4 	movw	r0, #33012	; 0x80f4
  11e9d0:	e3400014 	movt	r0, #20
  11e9d4:	ebffb1a8 	bl	10b07c <sys_arch_assert>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  11e9d8:	e51b3008 	ldr	r3, [fp, #-8]
  11e9dc:	e5933014 	ldr	r3, [r3, #20]
  11e9e0:	e3530001 	cmp	r3, #1
  11e9e4:	1a000006 	bne	11ea04 <tcp_slowtmr+0xc4>
  11e9e8:	e3080298 	movw	r0, #33432	; 0x8298
  11e9ec:	e3400014 	movt	r0, #20
  11e9f0:	ebff91c7 	bl	103114 <rt_kprintf>
  11e9f4:	e3a01ffb 	mov	r1, #1004	; 0x3ec
  11e9f8:	e30800f4 	movw	r0, #33012	; 0x80f4
  11e9fc:	e3400014 	movt	r0, #20
  11ea00:	ebffb19d 	bl	10b07c <sys_arch_assert>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  11ea04:	e51b3008 	ldr	r3, [fp, #-8]
  11ea08:	e5933014 	ldr	r3, [r3, #20]
  11ea0c:	e353000a 	cmp	r3, #10
  11ea10:	1a000006 	bne	11ea30 <tcp_slowtmr+0xf0>
  11ea14:	e30802c4 	movw	r0, #33476	; 0x82c4
  11ea18:	e3400014 	movt	r0, #20
  11ea1c:	ebff91bc 	bl	103114 <rt_kprintf>
  11ea20:	e30013ed 	movw	r1, #1005	; 0x3ed
  11ea24:	e30800f4 	movw	r0, #33012	; 0x80f4
  11ea28:	e3400014 	movt	r0, #20
  11ea2c:	ebffb192 	bl	10b07c <sys_arch_assert>
    if (pcb->last_timer == tcp_timer_ctr) {
  11ea30:	e51b3008 	ldr	r3, [fp, #-8]
  11ea34:	e5d32021 	ldrb	r2, [r3, #33]	; 0x21
  11ea38:	e30f321d 	movw	r3, #61981	; 0xf21d
  11ea3c:	e3403014 	movt	r3, #20
  11ea40:	e5d33000 	ldrb	r3, [r3]
  11ea44:	e1520003 	cmp	r2, r3
  11ea48:	1a000003 	bne	11ea5c <tcp_slowtmr+0x11c>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
  11ea4c:	e51b3008 	ldr	r3, [fp, #-8]
  11ea50:	e593300c 	ldr	r3, [r3, #12]
  11ea54:	e50b3008 	str	r3, [fp, #-8]
      continue;
  11ea58:	ea0001c6 	b	11f178 <tcp_slowtmr+0x838>
    }
    pcb->last_timer = tcp_timer_ctr;
  11ea5c:	e30f321d 	movw	r3, #61981	; 0xf21d
  11ea60:	e3403014 	movt	r3, #20
  11ea64:	e5d32000 	ldrb	r2, [r3]
  11ea68:	e51b3008 	ldr	r3, [fp, #-8]
  11ea6c:	e5c32021 	strb	r2, [r3, #33]	; 0x21

    pcb_remove = 0;
  11ea70:	e3a03000 	mov	r3, #0
  11ea74:	e54b300d 	strb	r3, [fp, #-13]
    pcb_reset = 0;
  11ea78:	e3a03000 	mov	r3, #0
  11ea7c:	e54b300e 	strb	r3, [fp, #-14]

    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
  11ea80:	e51b3008 	ldr	r3, [fp, #-8]
  11ea84:	e5933014 	ldr	r3, [r3, #20]
  11ea88:	e3530002 	cmp	r3, #2
  11ea8c:	1a000007 	bne	11eab0 <tcp_slowtmr+0x170>
  11ea90:	e51b3008 	ldr	r3, [fp, #-8]
  11ea94:	e5d33046 	ldrb	r3, [r3, #70]	; 0x46
  11ea98:	e3530003 	cmp	r3, #3
  11ea9c:	9a000003 	bls	11eab0 <tcp_slowtmr+0x170>
      ++pcb_remove;
  11eaa0:	e55b300d 	ldrb	r3, [fp, #-13]
  11eaa4:	e2833001 	add	r3, r3, #1
  11eaa8:	e54b300d 	strb	r3, [fp, #-13]
  11eaac:	ea000089 	b	11ecd8 <tcp_slowtmr+0x398>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx >= TCP_MAXRTX) {
  11eab0:	e51b3008 	ldr	r3, [fp, #-8]
  11eab4:	e5d33046 	ldrb	r3, [r3, #70]	; 0x46
  11eab8:	e353000b 	cmp	r3, #11
  11eabc:	9a000003 	bls	11ead0 <tcp_slowtmr+0x190>
      ++pcb_remove;
  11eac0:	e55b300d 	ldrb	r3, [fp, #-13]
  11eac4:	e2833001 	add	r3, r3, #1
  11eac8:	e54b300d 	strb	r3, [fp, #-13]
  11eacc:	ea000081 	b	11ecd8 <tcp_slowtmr+0x398>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  11ead0:	e51b3008 	ldr	r3, [fp, #-8]
  11ead4:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
  11ead8:	e3530000 	cmp	r3, #0
  11eadc:	0a000029 	beq	11eb88 <tcp_slowtmr+0x248>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff-1];
  11eae0:	e51b3008 	ldr	r3, [fp, #-8]
  11eae4:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
  11eae8:	e2432001 	sub	r2, r3, #1
  11eaec:	e30830d0 	movw	r3, #32976	; 0x80d0
  11eaf0:	e3403014 	movt	r3, #20
  11eaf4:	e7d33002 	ldrb	r3, [r3, r2]
  11eaf8:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
        if (pcb->persist_cnt < backoff_cnt) {
  11eafc:	e51b3008 	ldr	r3, [fp, #-8]
  11eb00:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
  11eb04:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
  11eb08:	e1520003 	cmp	r2, r3
  11eb0c:	9a000005 	bls	11eb28 <tcp_slowtmr+0x1e8>
          pcb->persist_cnt++;
  11eb10:	e51b3008 	ldr	r3, [fp, #-8]
  11eb14:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
  11eb18:	e2833001 	add	r3, r3, #1
  11eb1c:	e6ef2073 	uxtb	r2, r3
  11eb20:	e51b3008 	ldr	r3, [fp, #-8]
  11eb24:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
        }
        if (pcb->persist_cnt >= backoff_cnt) {
  11eb28:	e51b3008 	ldr	r3, [fp, #-8]
  11eb2c:	e5d330a0 	ldrb	r3, [r3, #160]	; 0xa0
  11eb30:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
  11eb34:	e1520003 	cmp	r2, r3
  11eb38:	8a000066 	bhi	11ecd8 <tcp_slowtmr+0x398>
          if (tcp_zero_window_probe(pcb) == ERR_OK) {
  11eb3c:	e51b0008 	ldr	r0, [fp, #-8]
  11eb40:	eb002180 	bl	127148 <tcp_zero_window_probe>
  11eb44:	e1a03000 	mov	r3, r0
  11eb48:	e3530000 	cmp	r3, #0
  11eb4c:	1a000061 	bne	11ecd8 <tcp_slowtmr+0x398>
            pcb->persist_cnt = 0;
  11eb50:	e51b3008 	ldr	r3, [fp, #-8]
  11eb54:	e3a02000 	mov	r2, #0
  11eb58:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
            if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  11eb5c:	e51b3008 	ldr	r3, [fp, #-8]
  11eb60:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
  11eb64:	e3530006 	cmp	r3, #6
  11eb68:	8a00005a 	bhi	11ecd8 <tcp_slowtmr+0x398>
              pcb->persist_backoff++;
  11eb6c:	e51b3008 	ldr	r3, [fp, #-8]
  11eb70:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
  11eb74:	e2833001 	add	r3, r3, #1
  11eb78:	e6ef2073 	uxtb	r2, r3
  11eb7c:	e51b3008 	ldr	r3, [fp, #-8]
  11eb80:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1
  11eb84:	ea000053 	b	11ecd8 <tcp_slowtmr+0x398>
            }
          }
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if (pcb->rtime >= 0) {
  11eb88:	e51b3008 	ldr	r3, [fp, #-8]
  11eb8c:	e1d333f4 	ldrsh	r3, [r3, #52]	; 0x34
  11eb90:	e3530000 	cmp	r3, #0
  11eb94:	ba000007 	blt	11ebb8 <tcp_slowtmr+0x278>
          ++pcb->rtime;
  11eb98:	e51b3008 	ldr	r3, [fp, #-8]
  11eb9c:	e1d333f4 	ldrsh	r3, [r3, #52]	; 0x34
  11eba0:	e6ff3073 	uxth	r3, r3
  11eba4:	e2833001 	add	r3, r3, #1
  11eba8:	e6ff3073 	uxth	r3, r3
  11ebac:	e6bf2073 	sxth	r2, r3
  11ebb0:	e51b3008 	ldr	r3, [fp, #-8]
  11ebb4:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  11ebb8:	e51b3008 	ldr	r3, [fp, #-8]
  11ebbc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  11ebc0:	e3530000 	cmp	r3, #0
  11ebc4:	0a000043 	beq	11ecd8 <tcp_slowtmr+0x398>
  11ebc8:	e51b3008 	ldr	r3, [fp, #-8]
  11ebcc:	e1d323f4 	ldrsh	r2, [r3, #52]	; 0x34
  11ebd0:	e51b3008 	ldr	r3, [fp, #-8]
  11ebd4:	e1d334f4 	ldrsh	r3, [r3, #68]	; 0x44
  11ebd8:	e1520003 	cmp	r2, r3
  11ebdc:	ba00003d 	blt	11ecd8 <tcp_slowtmr+0x398>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  11ebe0:	e51b3008 	ldr	r3, [fp, #-8]
  11ebe4:	e5933014 	ldr	r3, [r3, #20]
  11ebe8:	e3530002 	cmp	r3, #2
  11ebec:	0a000015 	beq	11ec48 <tcp_slowtmr+0x308>
            u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff)-1);
  11ebf0:	e51b3008 	ldr	r3, [fp, #-8]
  11ebf4:	e5d33046 	ldrb	r3, [r3, #70]	; 0x46
  11ebf8:	e353000c 	cmp	r3, #12
  11ebfc:	31a03003 	movcc	r3, r3
  11ec00:	23a0300c 	movcs	r3, #12
  11ec04:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
  11ec08:	e51b3008 	ldr	r3, [fp, #-8]
  11ec0c:	e1d334f0 	ldrsh	r3, [r3, #64]	; 0x40
  11ec10:	e1a031c3 	asr	r3, r3, #3
  11ec14:	e6bf3073 	sxth	r3, r3
  11ec18:	e1a02003 	mov	r2, r3
  11ec1c:	e51b3008 	ldr	r3, [fp, #-8]
  11ec20:	e1d334f2 	ldrsh	r3, [r3, #66]	; 0x42
  11ec24:	e0822003 	add	r2, r2, r3
  11ec28:	e55b1015 	ldrb	r1, [fp, #-21]	; 0xffffffeb
  11ec2c:	e30830c0 	movw	r3, #32960	; 0x80c0
  11ec30:	e3403014 	movt	r3, #20
  11ec34:	e7d33001 	ldrb	r3, [r3, r1]
  11ec38:	e1a03312 	lsl	r3, r2, r3
  11ec3c:	e6bf2073 	sxth	r2, r3
  11ec40:	e51b3008 	ldr	r3, [fp, #-8]
  11ec44:	e1c324b4 	strh	r2, [r3, #68]	; 0x44
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  11ec48:	e51b3008 	ldr	r3, [fp, #-8]
  11ec4c:	e3a02000 	mov	r2, #0
  11ec50:	e1c323b4 	strh	r2, [r3, #52]	; 0x34

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  11ec54:	e51b3008 	ldr	r3, [fp, #-8]
  11ec58:	e1d326b0 	ldrh	r2, [r3, #96]	; 0x60
  11ec5c:	e51b3008 	ldr	r3, [fp, #-8]
  11ec60:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
  11ec64:	e1520003 	cmp	r2, r3
  11ec68:	31a03002 	movcc	r3, r2
  11ec6c:	21a03003 	movcs	r3, r3
  11ec70:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8
          pcb->ssthresh = eff_wnd >> 1;
  11ec74:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
  11ec78:	e1a030a3 	lsr	r3, r3, #1
  11ec7c:	e6ff2073 	uxth	r2, r3
  11ec80:	e51b3008 	ldr	r3, [fp, #-8]
  11ec84:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
  11ec88:	e51b3008 	ldr	r3, [fp, #-8]
  11ec8c:	e1d324be 	ldrh	r2, [r3, #78]	; 0x4e
  11ec90:	e51b3008 	ldr	r3, [fp, #-8]
  11ec94:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  11ec98:	e1a03083 	lsl	r3, r3, #1
  11ec9c:	e6ff3073 	uxth	r3, r3
  11eca0:	e1520003 	cmp	r2, r3
  11eca4:	2a000005 	bcs	11ecc0 <tcp_slowtmr+0x380>
            pcb->ssthresh = (pcb->mss << 1);
  11eca8:	e51b3008 	ldr	r3, [fp, #-8]
  11ecac:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  11ecb0:	e1a03083 	lsl	r3, r3, #1
  11ecb4:	e6ff2073 	uxth	r2, r3
  11ecb8:	e51b3008 	ldr	r3, [fp, #-8]
  11ecbc:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
          }
          pcb->cwnd = pcb->mss;
  11ecc0:	e51b3008 	ldr	r3, [fp, #-8]
  11ecc4:	e1d323b6 	ldrh	r2, [r3, #54]	; 0x36
  11ecc8:	e51b3008 	ldr	r3, [fp, #-8]
  11eccc:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  11ecd0:	e51b0008 	ldr	r0, [fp, #-8]
  11ecd4:	eb002002 	bl	126ce4 <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  11ecd8:	e51b3008 	ldr	r3, [fp, #-8]
  11ecdc:	e5933014 	ldr	r3, [r3, #20]
  11ece0:	e3530006 	cmp	r3, #6
  11ece4:	1a00000f 	bne	11ed28 <tcp_slowtmr+0x3e8>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
  11ece8:	e51b3008 	ldr	r3, [fp, #-8]
  11ecec:	e5d3301e 	ldrb	r3, [r3, #30]
  11ecf0:	e2033010 	and	r3, r3, #16
  11ecf4:	e3530000 	cmp	r3, #0
  11ecf8:	0a00000a 	beq	11ed28 <tcp_slowtmr+0x3e8>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
  11ecfc:	e3063a34 	movw	r3, #27188	; 0x6a34
  11ed00:	e3403057 	movt	r3, #87	; 0x57
  11ed04:	e5932000 	ldr	r2, [r3]
  11ed08:	e51b3008 	ldr	r3, [fp, #-8]
  11ed0c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11ed10:	e0423003 	sub	r3, r2, r3
  11ed14:	e3530028 	cmp	r3, #40	; 0x28
  11ed18:	9a000002 	bls	11ed28 <tcp_slowtmr+0x3e8>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
  11ed1c:	e55b300d 	ldrb	r3, [fp, #-13]
  11ed20:	e2833001 	add	r3, r3, #1
  11ed24:	e54b300d 	strb	r3, [fp, #-13]
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
  11ed28:	e51b3008 	ldr	r3, [fp, #-8]
  11ed2c:	e5d33008 	ldrb	r3, [r3, #8]
  11ed30:	e2033008 	and	r3, r3, #8
  11ed34:	e3530000 	cmp	r3, #0
  11ed38:	0a000044 	beq	11ee50 <tcp_slowtmr+0x510>
       ((pcb->state == ESTABLISHED) ||
  11ed3c:	e51b3008 	ldr	r3, [fp, #-8]
  11ed40:	e5933014 	ldr	r3, [r3, #20]
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
  11ed44:	e3530004 	cmp	r3, #4
  11ed48:	0a000003 	beq	11ed5c <tcp_slowtmr+0x41c>
        (pcb->state == CLOSE_WAIT))) {
  11ed4c:	e51b3008 	ldr	r3, [fp, #-8]
  11ed50:	e5933014 	ldr	r3, [r3, #20]
       ((pcb->state == ESTABLISHED) ||
  11ed54:	e3530007 	cmp	r3, #7
  11ed58:	1a00003c 	bne	11ee50 <tcp_slowtmr+0x510>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  11ed5c:	e3063a34 	movw	r3, #27188	; 0x6a34
  11ed60:	e3403057 	movt	r3, #87	; 0x57
  11ed64:	e5932000 	ldr	r2, [r3]
  11ed68:	e51b3008 	ldr	r3, [fp, #-8]
  11ed6c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11ed70:	e0421003 	sub	r1, r2, r3
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
  11ed74:	e51b3008 	ldr	r3, [fp, #-8]
  11ed78:	e5932094 	ldr	r2, [r3, #148]	; 0x94
  11ed7c:	e51b3008 	ldr	r3, [fp, #-8]
  11ed80:	e593309c 	ldr	r3, [r3, #156]	; 0x9c
  11ed84:	e51b0008 	ldr	r0, [fp, #-8]
  11ed88:	e5900098 	ldr	r0, [r0, #152]	; 0x98
  11ed8c:	e0030390 	mul	r3, r0, r3
  11ed90:	e0822003 	add	r2, r2, r3
  11ed94:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  11ed98:	e3413062 	movt	r3, #4194	; 0x1062
  11ed9c:	e0832392 	umull	r2, r3, r2, r3
  11eda0:	e1a032a3 	lsr	r3, r3, #5
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  11eda4:	e1510003 	cmp	r1, r3
  11eda8:	9a000006 	bls	11edc8 <tcp_slowtmr+0x488>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
        ip_addr_debug_print(TCP_DEBUG, &pcb->remote_ip);
        LWIP_DEBUGF(TCP_DEBUG, ("\n"));

        ++pcb_remove;
  11edac:	e55b300d 	ldrb	r3, [fp, #-13]
  11edb0:	e2833001 	add	r3, r3, #1
  11edb4:	e54b300d 	strb	r3, [fp, #-13]
        ++pcb_reset;
  11edb8:	e55b300e 	ldrb	r3, [fp, #-14]
  11edbc:	e2833001 	add	r3, r3, #1
  11edc0:	e54b300e 	strb	r3, [fp, #-14]
  11edc4:	ea000021 	b	11ee50 <tcp_slowtmr+0x510>
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
  11edc8:	e3063a34 	movw	r3, #27188	; 0x6a34
  11edcc:	e3403057 	movt	r3, #87	; 0x57
  11edd0:	e5932000 	ldr	r2, [r3]
  11edd4:	e51b3008 	ldr	r3, [fp, #-8]
  11edd8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11eddc:	e0421003 	sub	r1, r2, r3
                (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
  11ede0:	e51b3008 	ldr	r3, [fp, #-8]
  11ede4:	e5932094 	ldr	r2, [r3, #148]	; 0x94
  11ede8:	e51b3008 	ldr	r3, [fp, #-8]
  11edec:	e5d330a2 	ldrb	r3, [r3, #162]	; 0xa2
  11edf0:	e1a00003 	mov	r0, r3
  11edf4:	e51b3008 	ldr	r3, [fp, #-8]
  11edf8:	e5933098 	ldr	r3, [r3, #152]	; 0x98
  11edfc:	e0030093 	mul	r3, r3, r0
  11ee00:	e0822003 	add	r2, r2, r3
                / TCP_SLOW_INTERVAL)
  11ee04:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  11ee08:	e3413062 	movt	r3, #4194	; 0x1062
  11ee0c:	e0832392 	umull	r2, r3, r2, r3
  11ee10:	e1a032a3 	lsr	r3, r3, #5
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
  11ee14:	e1510003 	cmp	r1, r3
  11ee18:	9a00000c 	bls	11ee50 <tcp_slowtmr+0x510>
      {
        err = tcp_keepalive(pcb);
  11ee1c:	e51b0008 	ldr	r0, [fp, #-8]
  11ee20:	eb00207a 	bl	127010 <tcp_keepalive>
  11ee24:	e1a03000 	mov	r3, r0
  11ee28:	e54b300f 	strb	r3, [fp, #-15]
        if (err == ERR_OK) {
  11ee2c:	e15b30df 	ldrsb	r3, [fp, #-15]
  11ee30:	e3530000 	cmp	r3, #0
  11ee34:	1a000005 	bne	11ee50 <tcp_slowtmr+0x510>
          pcb->keep_cnt_sent++;
  11ee38:	e51b3008 	ldr	r3, [fp, #-8]
  11ee3c:	e5d330a2 	ldrb	r3, [r3, #162]	; 0xa2
  11ee40:	e2833001 	add	r3, r3, #1
  11ee44:	e6ef2073 	uxtb	r2, r3
  11ee48:	e51b3008 	ldr	r3, [fp, #-8]
  11ee4c:	e5c320a2 	strb	r2, [r3, #162]	; 0xa2

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
  11ee50:	e51b3008 	ldr	r3, [fp, #-8]
  11ee54:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  11ee58:	e3530000 	cmp	r3, #0
  11ee5c:	0a000013 	beq	11eeb0 <tcp_slowtmr+0x570>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  11ee60:	e3063a34 	movw	r3, #27188	; 0x6a34
  11ee64:	e3403057 	movt	r3, #87	; 0x57
  11ee68:	e5932000 	ldr	r2, [r3]
  11ee6c:	e51b3008 	ldr	r3, [fp, #-8]
  11ee70:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11ee74:	e0422003 	sub	r2, r2, r3
  11ee78:	e51b3008 	ldr	r3, [fp, #-8]
  11ee7c:	e1d334f4 	ldrsh	r3, [r3, #68]	; 0x44
  11ee80:	e1a01003 	mov	r1, r3
  11ee84:	e3a03006 	mov	r3, #6
  11ee88:	e0030193 	mul	r3, r3, r1
    if (pcb->ooseq != NULL &&
  11ee8c:	e1520003 	cmp	r2, r3
  11ee90:	3a000006 	bcc	11eeb0 <tcp_slowtmr+0x570>
      tcp_segs_free(pcb->ooseq);
  11ee94:	e51b3008 	ldr	r3, [fp, #-8]
  11ee98:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  11ee9c:	e1a00003 	mov	r0, r3
  11eea0:	eb0001e3 	bl	11f634 <tcp_segs_free>
      pcb->ooseq = NULL;
  11eea4:	e51b3008 	ldr	r3, [fp, #-8]
  11eea8:	e3a02000 	mov	r2, #0
  11eeac:	e5832074 	str	r2, [r3, #116]	; 0x74
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  11eeb0:	e51b3008 	ldr	r3, [fp, #-8]
  11eeb4:	e5933014 	ldr	r3, [r3, #20]
  11eeb8:	e3530003 	cmp	r3, #3
  11eebc:	1a00000a 	bne	11eeec <tcp_slowtmr+0x5ac>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  11eec0:	e3063a34 	movw	r3, #27188	; 0x6a34
  11eec4:	e3403057 	movt	r3, #87	; 0x57
  11eec8:	e5932000 	ldr	r2, [r3]
  11eecc:	e51b3008 	ldr	r3, [fp, #-8]
  11eed0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11eed4:	e0423003 	sub	r3, r2, r3
  11eed8:	e3530028 	cmp	r3, #40	; 0x28
  11eedc:	9a000002 	bls	11eeec <tcp_slowtmr+0x5ac>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  11eee0:	e55b300d 	ldrb	r3, [fp, #-13]
  11eee4:	e2833001 	add	r3, r3, #1
  11eee8:	e54b300d 	strb	r3, [fp, #-13]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  11eeec:	e51b3008 	ldr	r3, [fp, #-8]
  11eef0:	e5933014 	ldr	r3, [r3, #20]
  11eef4:	e3530009 	cmp	r3, #9
  11eef8:	1a00000a 	bne	11ef28 <tcp_slowtmr+0x5e8>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  11eefc:	e3063a34 	movw	r3, #27188	; 0x6a34
  11ef00:	e3403057 	movt	r3, #87	; 0x57
  11ef04:	e5932000 	ldr	r2, [r3]
  11ef08:	e51b3008 	ldr	r3, [fp, #-8]
  11ef0c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11ef10:	e0423003 	sub	r3, r2, r3
  11ef14:	e35300f0 	cmp	r3, #240	; 0xf0
  11ef18:	9a000002 	bls	11ef28 <tcp_slowtmr+0x5e8>
        ++pcb_remove;
  11ef1c:	e55b300d 	ldrb	r3, [fp, #-13]
  11ef20:	e2833001 	add	r3, r3, #1
  11ef24:	e54b300d 	strb	r3, [fp, #-13]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  11ef28:	e55b300d 	ldrb	r3, [fp, #-13]
  11ef2c:	e3530000 	cmp	r3, #0
  11ef30:	0a00005d 	beq	11f0ac <tcp_slowtmr+0x76c>
      struct tcp_pcb *pcb2;
#if LWIP_CALLBACK_API
      tcp_err_fn err_fn = pcb->errf;
  11ef34:	e51b3008 	ldr	r3, [fp, #-8]
  11ef38:	e5933090 	ldr	r3, [r3, #144]	; 0x90
  11ef3c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
#endif /* LWIP_CALLBACK_API */
      void *err_arg;
      enum tcp_state last_state;
      tcp_pcb_purge(pcb);
  11ef40:	e51b0008 	ldr	r0, [fp, #-8]
  11ef44:	eb000411 	bl	11ff90 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  11ef48:	e51b300c 	ldr	r3, [fp, #-12]
  11ef4c:	e3530000 	cmp	r3, #0
  11ef50:	0a000011 	beq	11ef9c <tcp_slowtmr+0x65c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  11ef54:	e3063a30 	movw	r3, #27184	; 0x6a30
  11ef58:	e3403057 	movt	r3, #87	; 0x57
  11ef5c:	e5933000 	ldr	r3, [r3]
  11ef60:	e51b2008 	ldr	r2, [fp, #-8]
  11ef64:	e1520003 	cmp	r2, r3
  11ef68:	1a000006 	bne	11ef88 <tcp_slowtmr+0x648>
  11ef6c:	e30802f4 	movw	r0, #33524	; 0x82f4
  11ef70:	e3400014 	movt	r0, #20
  11ef74:	ebff9066 	bl	103114 <rt_kprintf>
  11ef78:	e3001484 	movw	r1, #1156	; 0x484
  11ef7c:	e30800f4 	movw	r0, #33012	; 0x80f4
  11ef80:	e3400014 	movt	r0, #20
  11ef84:	ebffb03c 	bl	10b07c <sys_arch_assert>
        prev->next = pcb->next;
  11ef88:	e51b3008 	ldr	r3, [fp, #-8]
  11ef8c:	e593200c 	ldr	r2, [r3, #12]
  11ef90:	e51b300c 	ldr	r3, [fp, #-12]
  11ef94:	e583200c 	str	r2, [r3, #12]
  11ef98:	ea000011 	b	11efe4 <tcp_slowtmr+0x6a4>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  11ef9c:	e3063a30 	movw	r3, #27184	; 0x6a30
  11efa0:	e3403057 	movt	r3, #87	; 0x57
  11efa4:	e5933000 	ldr	r3, [r3]
  11efa8:	e51b2008 	ldr	r2, [fp, #-8]
  11efac:	e1520003 	cmp	r2, r3
  11efb0:	0a000006 	beq	11efd0 <tcp_slowtmr+0x690>
  11efb4:	e3080320 	movw	r0, #33568	; 0x8320
  11efb8:	e3400014 	movt	r0, #20
  11efbc:	ebff9054 	bl	103114 <rt_kprintf>
  11efc0:	e3001488 	movw	r1, #1160	; 0x488
  11efc4:	e30800f4 	movw	r0, #33012	; 0x80f4
  11efc8:	e3400014 	movt	r0, #20
  11efcc:	ebffb02a 	bl	10b07c <sys_arch_assert>
        tcp_active_pcbs = pcb->next;
  11efd0:	e51b3008 	ldr	r3, [fp, #-8]
  11efd4:	e593200c 	ldr	r2, [r3, #12]
  11efd8:	e3063a30 	movw	r3, #27184	; 0x6a30
  11efdc:	e3403057 	movt	r3, #87	; 0x57
  11efe0:	e5832000 	str	r2, [r3]
      }

      if (pcb_reset) {
  11efe4:	e55b300e 	ldrb	r3, [fp, #-14]
  11efe8:	e3530000 	cmp	r3, #0
  11efec:	0a00000f 	beq	11f030 <tcp_slowtmr+0x6f0>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
  11eff0:	e51b3008 	ldr	r3, [fp, #-8]
  11eff4:	e5930050 	ldr	r0, [r3, #80]	; 0x50
  11eff8:	e51b3008 	ldr	r3, [fp, #-8]
  11effc:	e5931028 	ldr	r1, [r3, #40]	; 0x28
  11f000:	e51bc008 	ldr	ip, [fp, #-8]
  11f004:	e51b3008 	ldr	r3, [fp, #-8]
  11f008:	e283e004 	add	lr, r3, #4
  11f00c:	e51b3008 	ldr	r3, [fp, #-8]
  11f010:	e1d331ba 	ldrh	r3, [r3, #26]
  11f014:	e51b2008 	ldr	r2, [fp, #-8]
  11f018:	e1d221bc 	ldrh	r2, [r2, #28]
  11f01c:	e58d2004 	str	r2, [sp, #4]
  11f020:	e58d3000 	str	r3, [sp]
  11f024:	e1a0300e 	mov	r3, lr
  11f028:	e1a0200c 	mov	r2, ip
  11f02c:	eb001eb0 	bl	126af4 <tcp_rst>
                 pcb->local_port, pcb->remote_port);
      }

      err_arg = pcb->callback_arg;
  11f030:	e51b3008 	ldr	r3, [fp, #-8]
  11f034:	e5933010 	ldr	r3, [r3, #16]
  11f038:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
      last_state = pcb->state;
  11f03c:	e51b3008 	ldr	r3, [fp, #-8]
  11f040:	e5933014 	ldr	r3, [r3, #20]
  11f044:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
      pcb2 = pcb;
  11f048:	e51b3008 	ldr	r3, [fp, #-8]
  11f04c:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
      pcb = pcb->next;
  11f050:	e51b3008 	ldr	r3, [fp, #-8]
  11f054:	e593300c 	ldr	r3, [r3, #12]
  11f058:	e50b3008 	str	r3, [fp, #-8]
      memp_free(MEMP_TCP_PCB, pcb2);
  11f05c:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  11f060:	e3a00002 	mov	r0, #2
  11f064:	ebffe904 	bl	11947c <memp_free>

      tcp_active_pcbs_changed = 0;
  11f068:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11f06c:	e3403057 	movt	r3, #87	; 0x57
  11f070:	e3a02000 	mov	r2, #0
  11f074:	e5c32000 	strb	r2, [r3]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
  11f078:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11f07c:	e3530000 	cmp	r3, #0
  11f080:	0a000003 	beq	11f094 <tcp_slowtmr+0x754>
  11f084:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  11f088:	e3e0100c 	mvn	r1, #12
  11f08c:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  11f090:	e12fff33 	blx	r3
      if (tcp_active_pcbs_changed) {
  11f094:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11f098:	e3403057 	movt	r3, #87	; 0x57
  11f09c:	e5d33000 	ldrb	r3, [r3]
  11f0a0:	e3530000 	cmp	r3, #0
  11f0a4:	0a000033 	beq	11f178 <tcp_slowtmr+0x838>
        goto tcp_slowtmr_start;
  11f0a8:	eafffe38 	b	11e990 <tcp_slowtmr+0x50>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
  11f0ac:	e51b3008 	ldr	r3, [fp, #-8]
  11f0b0:	e50b300c 	str	r3, [fp, #-12]
      pcb = pcb->next;
  11f0b4:	e51b3008 	ldr	r3, [fp, #-8]
  11f0b8:	e593300c 	ldr	r3, [r3, #12]
  11f0bc:	e50b3008 	str	r3, [fp, #-8]

      /* We check if we should poll the connection. */
      ++prev->polltmr;
  11f0c0:	e51b300c 	ldr	r3, [fp, #-12]
  11f0c4:	e5d3301f 	ldrb	r3, [r3, #31]
  11f0c8:	e2833001 	add	r3, r3, #1
  11f0cc:	e6ef2073 	uxtb	r2, r3
  11f0d0:	e51b300c 	ldr	r3, [fp, #-12]
  11f0d4:	e5c3201f 	strb	r2, [r3, #31]
      if (prev->polltmr >= prev->pollinterval) {
  11f0d8:	e51b300c 	ldr	r3, [fp, #-12]
  11f0dc:	e5d3201f 	ldrb	r2, [r3, #31]
  11f0e0:	e51b300c 	ldr	r3, [fp, #-12]
  11f0e4:	e5d33020 	ldrb	r3, [r3, #32]
  11f0e8:	e1520003 	cmp	r2, r3
  11f0ec:	3a000021 	bcc	11f178 <tcp_slowtmr+0x838>
        prev->polltmr = 0;
  11f0f0:	e51b300c 	ldr	r3, [fp, #-12]
  11f0f4:	e3a02000 	mov	r2, #0
  11f0f8:	e5c3201f 	strb	r2, [r3, #31]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
  11f0fc:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11f100:	e3403057 	movt	r3, #87	; 0x57
  11f104:	e3a02000 	mov	r2, #0
  11f108:	e5c32000 	strb	r2, [r3]
        TCP_EVENT_POLL(prev, err);
  11f10c:	e51b300c 	ldr	r3, [fp, #-12]
  11f110:	e593308c 	ldr	r3, [r3, #140]	; 0x8c
  11f114:	e3530000 	cmp	r3, #0
  11f118:	0a000009 	beq	11f144 <tcp_slowtmr+0x804>
  11f11c:	e51b300c 	ldr	r3, [fp, #-12]
  11f120:	e593308c 	ldr	r3, [r3, #140]	; 0x8c
  11f124:	e51b200c 	ldr	r2, [fp, #-12]
  11f128:	e5922010 	ldr	r2, [r2, #16]
  11f12c:	e51b100c 	ldr	r1, [fp, #-12]
  11f130:	e1a00002 	mov	r0, r2
  11f134:	e12fff33 	blx	r3
  11f138:	e1a03000 	mov	r3, r0
  11f13c:	e54b300f 	strb	r3, [fp, #-15]
  11f140:	ea000001 	b	11f14c <tcp_slowtmr+0x80c>
  11f144:	e3a03000 	mov	r3, #0
  11f148:	e54b300f 	strb	r3, [fp, #-15]
        if (tcp_active_pcbs_changed) {
  11f14c:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11f150:	e3403057 	movt	r3, #87	; 0x57
  11f154:	e5d33000 	ldrb	r3, [r3]
  11f158:	e3530000 	cmp	r3, #0
  11f15c:	0a000000 	beq	11f164 <tcp_slowtmr+0x824>
          goto tcp_slowtmr_start;
  11f160:	eafffe0a 	b	11e990 <tcp_slowtmr+0x50>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
  11f164:	e15b30df 	ldrsb	r3, [fp, #-15]
  11f168:	e3530000 	cmp	r3, #0
  11f16c:	1a000001 	bne	11f178 <tcp_slowtmr+0x838>
          tcp_output(prev);
  11f170:	e51b000c 	ldr	r0, [fp, #-12]
  11f174:	eb001bf8 	bl	12615c <tcp_output>
  while (pcb != NULL) {
  11f178:	e51b3008 	ldr	r3, [fp, #-8]
  11f17c:	e3530000 	cmp	r3, #0
  11f180:	1afffe09 	bne	11e9ac <tcp_slowtmr+0x6c>
    }
  }


  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  11f184:	e3a03000 	mov	r3, #0
  11f188:	e50b300c 	str	r3, [fp, #-12]
  pcb = tcp_tw_pcbs;
  11f18c:	e3063a40 	movw	r3, #27200	; 0x6a40
  11f190:	e3403057 	movt	r3, #87	; 0x57
  11f194:	e5933000 	ldr	r3, [r3]
  11f198:	e50b3008 	str	r3, [fp, #-8]
  while (pcb != NULL) {
  11f19c:	ea000051 	b	11f2e8 <tcp_slowtmr+0x9a8>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  11f1a0:	e51b3008 	ldr	r3, [fp, #-8]
  11f1a4:	e5933014 	ldr	r3, [r3, #20]
  11f1a8:	e353000a 	cmp	r3, #10
  11f1ac:	0a000006 	beq	11f1cc <tcp_slowtmr+0x88c>
  11f1b0:	e308034c 	movw	r0, #33612	; 0x834c
  11f1b4:	e3400014 	movt	r0, #20
  11f1b8:	ebff8fd5 	bl	103114 <rt_kprintf>
  11f1bc:	e30014b8 	movw	r1, #1208	; 0x4b8
  11f1c0:	e30800f4 	movw	r0, #33012	; 0x80f4
  11f1c4:	e3400014 	movt	r0, #20
  11f1c8:	ebffafab 	bl	10b07c <sys_arch_assert>
    pcb_remove = 0;
  11f1cc:	e3a03000 	mov	r3, #0
  11f1d0:	e54b300d 	strb	r3, [fp, #-13]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  11f1d4:	e3063a34 	movw	r3, #27188	; 0x6a34
  11f1d8:	e3403057 	movt	r3, #87	; 0x57
  11f1dc:	e5932000 	ldr	r2, [r3]
  11f1e0:	e51b3008 	ldr	r3, [fp, #-8]
  11f1e4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11f1e8:	e0423003 	sub	r3, r2, r3
  11f1ec:	e35300f0 	cmp	r3, #240	; 0xf0
  11f1f0:	9a000002 	bls	11f200 <tcp_slowtmr+0x8c0>
      ++pcb_remove;
  11f1f4:	e55b300d 	ldrb	r3, [fp, #-13]
  11f1f8:	e2833001 	add	r3, r3, #1
  11f1fc:	e54b300d 	strb	r3, [fp, #-13]
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  11f200:	e55b300d 	ldrb	r3, [fp, #-13]
  11f204:	e3530000 	cmp	r3, #0
  11f208:	0a000031 	beq	11f2d4 <tcp_slowtmr+0x994>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
  11f20c:	e51b0008 	ldr	r0, [fp, #-8]
  11f210:	eb00035e 	bl	11ff90 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  11f214:	e51b300c 	ldr	r3, [fp, #-12]
  11f218:	e3530000 	cmp	r3, #0
  11f21c:	0a000011 	beq	11f268 <tcp_slowtmr+0x928>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  11f220:	e3063a40 	movw	r3, #27200	; 0x6a40
  11f224:	e3403057 	movt	r3, #87	; 0x57
  11f228:	e5933000 	ldr	r3, [r3]
  11f22c:	e51b2008 	ldr	r2, [fp, #-8]
  11f230:	e1520003 	cmp	r2, r3
  11f234:	1a000006 	bne	11f254 <tcp_slowtmr+0x914>
  11f238:	e308037c 	movw	r0, #33660	; 0x837c
  11f23c:	e3400014 	movt	r0, #20
  11f240:	ebff8fb3 	bl	103114 <rt_kprintf>
  11f244:	e30014c6 	movw	r1, #1222	; 0x4c6
  11f248:	e30800f4 	movw	r0, #33012	; 0x80f4
  11f24c:	e3400014 	movt	r0, #20
  11f250:	ebffaf89 	bl	10b07c <sys_arch_assert>
        prev->next = pcb->next;
  11f254:	e51b3008 	ldr	r3, [fp, #-8]
  11f258:	e593200c 	ldr	r2, [r3, #12]
  11f25c:	e51b300c 	ldr	r3, [fp, #-12]
  11f260:	e583200c 	str	r2, [r3, #12]
  11f264:	ea000011 	b	11f2b0 <tcp_slowtmr+0x970>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  11f268:	e3063a40 	movw	r3, #27200	; 0x6a40
  11f26c:	e3403057 	movt	r3, #87	; 0x57
  11f270:	e5933000 	ldr	r3, [r3]
  11f274:	e51b2008 	ldr	r2, [fp, #-8]
  11f278:	e1520003 	cmp	r2, r3
  11f27c:	0a000006 	beq	11f29c <tcp_slowtmr+0x95c>
  11f280:	e30803a4 	movw	r0, #33700	; 0x83a4
  11f284:	e3400014 	movt	r0, #20
  11f288:	ebff8fa1 	bl	103114 <rt_kprintf>
  11f28c:	e30014ca 	movw	r1, #1226	; 0x4ca
  11f290:	e30800f4 	movw	r0, #33012	; 0x80f4
  11f294:	e3400014 	movt	r0, #20
  11f298:	ebffaf77 	bl	10b07c <sys_arch_assert>
        tcp_tw_pcbs = pcb->next;
  11f29c:	e51b3008 	ldr	r3, [fp, #-8]
  11f2a0:	e593200c 	ldr	r2, [r3, #12]
  11f2a4:	e3063a40 	movw	r3, #27200	; 0x6a40
  11f2a8:	e3403057 	movt	r3, #87	; 0x57
  11f2ac:	e5832000 	str	r2, [r3]
      }
      pcb2 = pcb;
  11f2b0:	e51b3008 	ldr	r3, [fp, #-8]
  11f2b4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      pcb = pcb->next;
  11f2b8:	e51b3008 	ldr	r3, [fp, #-8]
  11f2bc:	e593300c 	ldr	r3, [r3, #12]
  11f2c0:	e50b3008 	str	r3, [fp, #-8]
      memp_free(MEMP_TCP_PCB, pcb2);
  11f2c4:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  11f2c8:	e3a00002 	mov	r0, #2
  11f2cc:	ebffe86a 	bl	11947c <memp_free>
  11f2d0:	ea000004 	b	11f2e8 <tcp_slowtmr+0x9a8>
    } else {
      prev = pcb;
  11f2d4:	e51b3008 	ldr	r3, [fp, #-8]
  11f2d8:	e50b300c 	str	r3, [fp, #-12]
      pcb = pcb->next;
  11f2dc:	e51b3008 	ldr	r3, [fp, #-8]
  11f2e0:	e593300c 	ldr	r3, [r3, #12]
  11f2e4:	e50b3008 	str	r3, [fp, #-8]
  while (pcb != NULL) {
  11f2e8:	e51b3008 	ldr	r3, [fp, #-8]
  11f2ec:	e3530000 	cmp	r3, #0
  11f2f0:	1affffaa 	bne	11f1a0 <tcp_slowtmr+0x860>
    }
  }
}
  11f2f4:	e320f000 	nop	{0}
  11f2f8:	e24bd004 	sub	sp, fp, #4
  11f2fc:	e8bd8800 	pop	{fp, pc}

0011f300 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  11f300:	e92d4800 	push	{fp, lr}
  11f304:	e28db004 	add	fp, sp, #4
  11f308:	e24dd008 	sub	sp, sp, #8
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
  11f30c:	e30f321d 	movw	r3, #61981	; 0xf21d
  11f310:	e3403014 	movt	r3, #20
  11f314:	e5d33000 	ldrb	r3, [r3]
  11f318:	e2833001 	add	r3, r3, #1
  11f31c:	e6ef2073 	uxtb	r2, r3
  11f320:	e30f321d 	movw	r3, #61981	; 0xf21d
  11f324:	e3403014 	movt	r3, #20
  11f328:	e5c32000 	strb	r2, [r3]

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
  11f32c:	e3063a30 	movw	r3, #27184	; 0x6a30
  11f330:	e3403057 	movt	r3, #87	; 0x57
  11f334:	e5933000 	ldr	r3, [r3]
  11f338:	e50b3008 	str	r3, [fp, #-8]

  while (pcb != NULL) {
  11f33c:	ea000044 	b	11f454 <tcp_fasttmr+0x154>
    if (pcb->last_timer != tcp_timer_ctr) {
  11f340:	e51b3008 	ldr	r3, [fp, #-8]
  11f344:	e5d32021 	ldrb	r2, [r3, #33]	; 0x21
  11f348:	e30f321d 	movw	r3, #61981	; 0xf21d
  11f34c:	e3403014 	movt	r3, #20
  11f350:	e5d33000 	ldrb	r3, [r3]
  11f354:	e1520003 	cmp	r2, r3
  11f358:	0a00003a 	beq	11f448 <tcp_fasttmr+0x148>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
  11f35c:	e30f321d 	movw	r3, #61981	; 0xf21d
  11f360:	e3403014 	movt	r3, #20
  11f364:	e5d32000 	ldrb	r2, [r3]
  11f368:	e51b3008 	ldr	r3, [fp, #-8]
  11f36c:	e5c32021 	strb	r2, [r3, #33]	; 0x21
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
  11f370:	e51b3008 	ldr	r3, [fp, #-8]
  11f374:	e5d3301e 	ldrb	r3, [r3, #30]
  11f378:	e2033001 	and	r3, r3, #1
  11f37c:	e3530000 	cmp	r3, #0
  11f380:	0a00000d 	beq	11f3bc <tcp_fasttmr+0xbc>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
  11f384:	e51b3008 	ldr	r3, [fp, #-8]
  11f388:	e5d3301e 	ldrb	r3, [r3, #30]
  11f38c:	e3833002 	orr	r3, r3, #2
  11f390:	e6ef2073 	uxtb	r2, r3
  11f394:	e51b3008 	ldr	r3, [fp, #-8]
  11f398:	e5c3201e 	strb	r2, [r3, #30]
        tcp_output(pcb);
  11f39c:	e51b0008 	ldr	r0, [fp, #-8]
  11f3a0:	eb001b6d 	bl	12615c <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  11f3a4:	e51b3008 	ldr	r3, [fp, #-8]
  11f3a8:	e5d3301e 	ldrb	r3, [r3, #30]
  11f3ac:	e3c33003 	bic	r3, r3, #3
  11f3b0:	e6ef2073 	uxtb	r2, r3
  11f3b4:	e51b3008 	ldr	r3, [fp, #-8]
  11f3b8:	e5c3201e 	strb	r2, [r3, #30]
      }
      /* send pending FIN */
      if (pcb->flags & TF_CLOSEPEND) {
  11f3bc:	e51b3008 	ldr	r3, [fp, #-8]
  11f3c0:	e5d3301e 	ldrb	r3, [r3, #30]
  11f3c4:	e2033008 	and	r3, r3, #8
  11f3c8:	e3530000 	cmp	r3, #0
  11f3cc:	0a000007 	beq	11f3f0 <tcp_fasttmr+0xf0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
        pcb->flags &= ~(TF_CLOSEPEND);
  11f3d0:	e51b3008 	ldr	r3, [fp, #-8]
  11f3d4:	e5d3301e 	ldrb	r3, [r3, #30]
  11f3d8:	e3c33008 	bic	r3, r3, #8
  11f3dc:	e6ef2073 	uxtb	r2, r3
  11f3e0:	e51b3008 	ldr	r3, [fp, #-8]
  11f3e4:	e5c3201e 	strb	r2, [r3, #30]
        tcp_close_shutdown_fin(pcb);
  11f3e8:	e51b0008 	ldr	r0, [fp, #-8]
  11f3ec:	ebfff8b0 	bl	11d6b4 <tcp_close_shutdown_fin>
      }

      next = pcb->next;
  11f3f0:	e51b3008 	ldr	r3, [fp, #-8]
  11f3f4:	e593300c 	ldr	r3, [r3, #12]
  11f3f8:	e50b300c 	str	r3, [fp, #-12]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
  11f3fc:	e51b3008 	ldr	r3, [fp, #-8]
  11f400:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  11f404:	e3530000 	cmp	r3, #0
  11f408:	0a00000b 	beq	11f43c <tcp_fasttmr+0x13c>
        tcp_active_pcbs_changed = 0;
  11f40c:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11f410:	e3403057 	movt	r3, #87	; 0x57
  11f414:	e3a02000 	mov	r2, #0
  11f418:	e5c32000 	strb	r2, [r3]
        tcp_process_refused_data(pcb);
  11f41c:	e51b0008 	ldr	r0, [fp, #-8]
  11f420:	eb000029 	bl	11f4cc <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
  11f424:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  11f428:	e3403057 	movt	r3, #87	; 0x57
  11f42c:	e5d33000 	ldrb	r3, [r3]
  11f430:	e3530000 	cmp	r3, #0
  11f434:	0a000000 	beq	11f43c <tcp_fasttmr+0x13c>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
  11f438:	eaffffbb 	b	11f32c <tcp_fasttmr+0x2c>
        }
      }
      pcb = next;
  11f43c:	e51b300c 	ldr	r3, [fp, #-12]
  11f440:	e50b3008 	str	r3, [fp, #-8]
  11f444:	ea000002 	b	11f454 <tcp_fasttmr+0x154>
    } else {
      pcb = pcb->next;
  11f448:	e51b3008 	ldr	r3, [fp, #-8]
  11f44c:	e593300c 	ldr	r3, [r3, #12]
  11f450:	e50b3008 	str	r3, [fp, #-8]
  while (pcb != NULL) {
  11f454:	e51b3008 	ldr	r3, [fp, #-8]
  11f458:	e3530000 	cmp	r3, #0
  11f45c:	1affffb7 	bne	11f340 <tcp_fasttmr+0x40>
    }
  }
}
  11f460:	e320f000 	nop	{0}
  11f464:	e24bd004 	sub	sp, fp, #4
  11f468:	e8bd8800 	pop	{fp, pc}

0011f46c <tcp_txnow>:

/** Call tcp_output for all active pcbs that have TF_NAGLEMEMERR set */
void
tcp_txnow(void)
{
  11f46c:	e92d4800 	push	{fp, lr}
  11f470:	e28db004 	add	fp, sp, #4
  11f474:	e24dd008 	sub	sp, sp, #8
  struct tcp_pcb *pcb;

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  11f478:	e3063a30 	movw	r3, #27184	; 0x6a30
  11f47c:	e3403057 	movt	r3, #87	; 0x57
  11f480:	e5933000 	ldr	r3, [r3]
  11f484:	e50b3008 	str	r3, [fp, #-8]
  11f488:	ea000009 	b	11f4b4 <tcp_txnow+0x48>
    if (pcb->flags & TF_NAGLEMEMERR) {
  11f48c:	e51b3008 	ldr	r3, [fp, #-8]
  11f490:	e5d3301e 	ldrb	r3, [r3, #30]
  11f494:	e6af3073 	sxtb	r3, r3
  11f498:	e3530000 	cmp	r3, #0
  11f49c:	aa000001 	bge	11f4a8 <tcp_txnow+0x3c>
      tcp_output(pcb);
  11f4a0:	e51b0008 	ldr	r0, [fp, #-8]
  11f4a4:	eb001b2c 	bl	12615c <tcp_output>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  11f4a8:	e51b3008 	ldr	r3, [fp, #-8]
  11f4ac:	e593300c 	ldr	r3, [r3, #12]
  11f4b0:	e50b3008 	str	r3, [fp, #-8]
  11f4b4:	e51b3008 	ldr	r3, [fp, #-8]
  11f4b8:	e3530000 	cmp	r3, #0
  11f4bc:	1afffff2 	bne	11f48c <tcp_txnow+0x20>
    }
  }
}
  11f4c0:	e320f000 	nop	{0}
  11f4c4:	e24bd004 	sub	sp, fp, #4
  11f4c8:	e8bd8800 	pop	{fp, pc}

0011f4cc <tcp_process_refused_data>:

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
  11f4cc:	e92d4810 	push	{r4, fp, lr}
  11f4d0:	e28db008 	add	fp, sp, #8
  11f4d4:	e24dd014 	sub	sp, sp, #20
  11f4d8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct pbuf *rest;
  while (pcb->refused_data != NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
  {
    err_t err;
    u8_t refused_flags = pcb->refused_data->flags;
  11f4dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f4e0:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  11f4e4:	e5d3300d 	ldrb	r3, [r3, #13]
  11f4e8:	e54b300e 	strb	r3, [fp, #-14]
    /* set pcb->refused_data to NULL in case the callback frees it and then
       closes the pcb */
    struct pbuf *refused_data = pcb->refused_data;
  11f4ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f4f0:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  11f4f4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
    pbuf_split_64k(refused_data, &rest);
    pcb->refused_data = rest;
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    pcb->refused_data = NULL;
  11f4f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f4fc:	e3a02000 	mov	r2, #0
  11f500:	e5832078 	str	r2, [r3, #120]	; 0x78
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    /* Notify again application with data previously received. */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
  11f504:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f508:	e5933084 	ldr	r3, [r3, #132]	; 0x84
  11f50c:	e3530000 	cmp	r3, #0
  11f510:	0a00000a 	beq	11f540 <tcp_process_refused_data+0x74>
  11f514:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f518:	e5934084 	ldr	r4, [r3, #132]	; 0x84
  11f51c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f520:	e5930010 	ldr	r0, [r3, #16]
  11f524:	e3a03000 	mov	r3, #0
  11f528:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  11f52c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  11f530:	e12fff34 	blx	r4
  11f534:	e1a03000 	mov	r3, r0
  11f538:	e54b300d 	strb	r3, [fp, #-13]
  11f53c:	ea000006 	b	11f55c <tcp_process_refused_data+0x90>
  11f540:	e3a03000 	mov	r3, #0
  11f544:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  11f548:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  11f54c:	e3a00000 	mov	r0, #0
  11f550:	eb000086 	bl	11f770 <tcp_recv_null>
  11f554:	e1a03000 	mov	r3, r0
  11f558:	e54b300d 	strb	r3, [fp, #-13]
    if (err == ERR_OK) {
  11f55c:	e15b30dd 	ldrsb	r3, [fp, #-13]
  11f560:	e3530000 	cmp	r3, #0
  11f564:	1a000024 	bne	11f5fc <tcp_process_refused_data+0x130>
      /* did refused_data include a FIN? */
      if (refused_flags & PBUF_FLAG_TCP_FIN
  11f568:	e55b300e 	ldrb	r3, [fp, #-14]
  11f56c:	e2033020 	and	r3, r3, #32
  11f570:	e3530000 	cmp	r3, #0
  11f574:	0a00002a 	beq	11f624 <tcp_process_refused_data+0x158>
          && (rest == NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
         ) {
        /* correct rcv_wnd as the application won't call tcp_recved()
           for the FIN's seqno */
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
  11f578:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f57c:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  11f580:	e30f2fff 	movw	r2, #65535	; 0xffff
  11f584:	e1530002 	cmp	r3, r2
  11f588:	0a000005 	beq	11f5a4 <tcp_process_refused_data+0xd8>
          pcb->rcv_wnd++;
  11f58c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f590:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  11f594:	e2833001 	add	r3, r3, #1
  11f598:	e6ff2073 	uxth	r2, r3
  11f59c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f5a0:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
        }
        TCP_EVENT_CLOSED(pcb, err);
  11f5a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f5a8:	e5933084 	ldr	r3, [r3, #132]	; 0x84
  11f5ac:	e3530000 	cmp	r3, #0
  11f5b0:	0a00000a 	beq	11f5e0 <tcp_process_refused_data+0x114>
  11f5b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f5b8:	e5934084 	ldr	r4, [r3, #132]	; 0x84
  11f5bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f5c0:	e5930010 	ldr	r0, [r3, #16]
  11f5c4:	e3a03000 	mov	r3, #0
  11f5c8:	e3a02000 	mov	r2, #0
  11f5cc:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  11f5d0:	e12fff34 	blx	r4
  11f5d4:	e1a03000 	mov	r3, r0
  11f5d8:	e54b300d 	strb	r3, [fp, #-13]
  11f5dc:	ea000001 	b	11f5e8 <tcp_process_refused_data+0x11c>
  11f5e0:	e3a03000 	mov	r3, #0
  11f5e4:	e54b300d 	strb	r3, [fp, #-13]
        if (err == ERR_ABRT) {
  11f5e8:	e15b30dd 	ldrsb	r3, [fp, #-13]
  11f5ec:	e373000d 	cmn	r3, #13
  11f5f0:	1a00000b 	bne	11f624 <tcp_process_refused_data+0x158>
          return ERR_ABRT;
  11f5f4:	e3e0300c 	mvn	r3, #12
  11f5f8:	ea00000a 	b	11f628 <tcp_process_refused_data+0x15c>
        }
      }
    } else if (err == ERR_ABRT) {
  11f5fc:	e15b30dd 	ldrsb	r3, [fp, #-13]
  11f600:	e373000d 	cmn	r3, #13
  11f604:	1a000001 	bne	11f610 <tcp_process_refused_data+0x144>
      /* if err == ERR_ABRT, 'pcb' is already deallocated */
      /* Drop incoming packets because pcb is "full" (only if the incoming
         segment contains data). */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
      return ERR_ABRT;
  11f608:	e3e0300c 	mvn	r3, #12
  11f60c:	ea000005 	b	11f628 <tcp_process_refused_data+0x15c>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
      if (rest != NULL) {
        pbuf_cat(refused_data, rest);
      }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
      pcb->refused_data = refused_data;
  11f610:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f614:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  11f618:	e5832078 	str	r2, [r3, #120]	; 0x78
      return ERR_INPROGRESS;
  11f61c:	e3e03004 	mvn	r3, #4
  11f620:	ea000000 	b	11f628 <tcp_process_refused_data+0x15c>
    }
  }
  return ERR_OK;
  11f624:	e3a03000 	mov	r3, #0
}
  11f628:	e1a00003 	mov	r0, r3
  11f62c:	e24bd008 	sub	sp, fp, #8
  11f630:	e8bd8810 	pop	{r4, fp, pc}

0011f634 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  11f634:	e92d4800 	push	{fp, lr}
  11f638:	e28db004 	add	fp, sp, #4
  11f63c:	e24dd010 	sub	sp, sp, #16
  11f640:	e50b0010 	str	r0, [fp, #-16]
  while (seg != NULL) {
  11f644:	ea000006 	b	11f664 <tcp_segs_free+0x30>
    struct tcp_seg *next = seg->next;
  11f648:	e51b3010 	ldr	r3, [fp, #-16]
  11f64c:	e5933000 	ldr	r3, [r3]
  11f650:	e50b3008 	str	r3, [fp, #-8]
    tcp_seg_free(seg);
  11f654:	e51b0010 	ldr	r0, [fp, #-16]
  11f658:	eb000007 	bl	11f67c <tcp_seg_free>
    seg = next;
  11f65c:	e51b3008 	ldr	r3, [fp, #-8]
  11f660:	e50b3010 	str	r3, [fp, #-16]
  while (seg != NULL) {
  11f664:	e51b3010 	ldr	r3, [fp, #-16]
  11f668:	e3530000 	cmp	r3, #0
  11f66c:	1afffff5 	bne	11f648 <tcp_segs_free+0x14>
  }
}
  11f670:	e320f000 	nop	{0}
  11f674:	e24bd004 	sub	sp, fp, #4
  11f678:	e8bd8800 	pop	{fp, pc}

0011f67c <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  11f67c:	e92d4800 	push	{fp, lr}
  11f680:	e28db004 	add	fp, sp, #4
  11f684:	e24dd008 	sub	sp, sp, #8
  11f688:	e50b0008 	str	r0, [fp, #-8]
  if (seg != NULL) {
  11f68c:	e51b3008 	ldr	r3, [fp, #-8]
  11f690:	e3530000 	cmp	r3, #0
  11f694:	0a00000a 	beq	11f6c4 <tcp_seg_free+0x48>
    if (seg->p != NULL) {
  11f698:	e51b3008 	ldr	r3, [fp, #-8]
  11f69c:	e5933004 	ldr	r3, [r3, #4]
  11f6a0:	e3530000 	cmp	r3, #0
  11f6a4:	0a000003 	beq	11f6b8 <tcp_seg_free+0x3c>
      pbuf_free(seg->p);
  11f6a8:	e51b3008 	ldr	r3, [fp, #-8]
  11f6ac:	e5933004 	ldr	r3, [r3, #4]
  11f6b0:	e1a00003 	mov	r0, r3
  11f6b4:	ebffee7e 	bl	11b0b4 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  11f6b8:	e51b1008 	ldr	r1, [fp, #-8]
  11f6bc:	e3a00004 	mov	r0, #4
  11f6c0:	ebffe76d 	bl	11947c <memp_free>
  }
}
  11f6c4:	e320f000 	nop	{0}
  11f6c8:	e24bd004 	sub	sp, fp, #4
  11f6cc:	e8bd8800 	pop	{fp, pc}

0011f6d0 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  11f6d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11f6d4:	e28db000 	add	fp, sp, #0
  11f6d8:	e24dd00c 	sub	sp, sp, #12
  11f6dc:	e50b0008 	str	r0, [fp, #-8]
  11f6e0:	e1a03001 	mov	r3, r1
  11f6e4:	e54b3009 	strb	r3, [fp, #-9]
  pcb->prio = prio;
  11f6e8:	e51b3008 	ldr	r3, [fp, #-8]
  11f6ec:	e55b2009 	ldrb	r2, [fp, #-9]
  11f6f0:	e5c32018 	strb	r2, [r3, #24]
}
  11f6f4:	e320f000 	nop	{0}
  11f6f8:	e28bd000 	add	sp, fp, #0
  11f6fc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11f700:	e12fff1e 	bx	lr

0011f704 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  11f704:	e92d4800 	push	{fp, lr}
  11f708:	e28db004 	add	fp, sp, #4
  11f70c:	e24dd010 	sub	sp, sp, #16
  11f710:	e50b0010 	str	r0, [fp, #-16]
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
  11f714:	e300258f 	movw	r2, #1423	; 0x58f
  11f718:	e30810f4 	movw	r1, #33012	; 0x80f4
  11f71c:	e3401014 	movt	r1, #20
  11f720:	e3a00004 	mov	r0, #4
  11f724:	ebffe6ec 	bl	1192dc <memp_malloc_fn>
  11f728:	e50b0008 	str	r0, [fp, #-8]
  if (cseg == NULL) {
  11f72c:	e51b3008 	ldr	r3, [fp, #-8]
  11f730:	e3530000 	cmp	r3, #0
  11f734:	1a000001 	bne	11f740 <tcp_seg_copy+0x3c>
    return NULL;
  11f738:	e3a03000 	mov	r3, #0
  11f73c:	ea000008 	b	11f764 <tcp_seg_copy+0x60>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
  11f740:	e3a02010 	mov	r2, #16
  11f744:	e51b1010 	ldr	r1, [fp, #-16]
  11f748:	e51b0008 	ldr	r0, [fp, #-8]
  11f74c:	eb008610 	bl	140f94 <memcpy>
  pbuf_ref(cseg->p);
  11f750:	e51b3008 	ldr	r3, [fp, #-8]
  11f754:	e5933004 	ldr	r3, [r3, #4]
  11f758:	e1a00003 	mov	r0, r3
  11f75c:	ebffeeee 	bl	11b31c <pbuf_ref>
  return cseg;
  11f760:	e51b3008 	ldr	r3, [fp, #-8]
}
  11f764:	e1a00003 	mov	r0, r3
  11f768:	e24bd004 	sub	sp, fp, #4
  11f76c:	e8bd8800 	pop	{fp, pc}

0011f770 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  11f770:	e92d4800 	push	{fp, lr}
  11f774:	e28db004 	add	fp, sp, #4
  11f778:	e24dd010 	sub	sp, sp, #16
  11f77c:	e50b0008 	str	r0, [fp, #-8]
  11f780:	e50b100c 	str	r1, [fp, #-12]
  11f784:	e50b2010 	str	r2, [fp, #-16]
  11f788:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
  11f78c:	e51b3010 	ldr	r3, [fp, #-16]
  11f790:	e3530000 	cmp	r3, #0
  11f794:	0a000007 	beq	11f7b8 <tcp_recv_null+0x48>
    tcp_recved(pcb, p->tot_len);
  11f798:	e51b3010 	ldr	r3, [fp, #-16]
  11f79c:	e1d330b8 	ldrh	r3, [r3, #8]
  11f7a0:	e1a01003 	mov	r1, r3
  11f7a4:	e51b000c 	ldr	r0, [fp, #-12]
  11f7a8:	ebfffacd 	bl	11e2e4 <tcp_recved>
    pbuf_free(p);
  11f7ac:	e51b0010 	ldr	r0, [fp, #-16]
  11f7b0:	ebffee3f 	bl	11b0b4 <pbuf_free>
  11f7b4:	ea000006 	b	11f7d4 <tcp_recv_null+0x64>
  } else if (err == ERR_OK) {
  11f7b8:	e15b31d1 	ldrsb	r3, [fp, #-17]	; 0xffffffef
  11f7bc:	e3530000 	cmp	r3, #0
  11f7c0:	1a000003 	bne	11f7d4 <tcp_recv_null+0x64>
    return tcp_close(pcb);
  11f7c4:	e51b000c 	ldr	r0, [fp, #-12]
  11f7c8:	ebfff81f 	bl	11d84c <tcp_close>
  11f7cc:	e1a03000 	mov	r3, r0
  11f7d0:	ea000000 	b	11f7d8 <tcp_recv_null+0x68>
  }
  return ERR_OK;
  11f7d4:	e3a03000 	mov	r3, #0
}
  11f7d8:	e1a00003 	mov	r0, r3
  11f7dc:	e24bd004 	sub	sp, fp, #4
  11f7e0:	e8bd8800 	pop	{fp, pc}

0011f7e4 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  11f7e4:	e92d4800 	push	{fp, lr}
  11f7e8:	e28db004 	add	fp, sp, #4
  11f7ec:	e24dd018 	sub	sp, sp, #24
  11f7f0:	e1a03000 	mov	r3, r0
  11f7f4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;

  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
  11f7f8:	e15b31d5 	ldrsb	r3, [fp, #-21]	; 0xffffffeb
  11f7fc:	e3530000 	cmp	r3, #0
  11f800:	ba000001 	blt	11f80c <tcp_kill_prio+0x28>
  11f804:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  11f808:	ea000000 	b	11f810 <tcp_kill_prio+0x2c>
  11f80c:	e3a0307f 	mov	r3, #127	; 0x7f
  11f810:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef

  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  11f814:	e3a03000 	mov	r3, #0
  11f818:	e50b3010 	str	r3, [fp, #-16]
  inactive = NULL;
  11f81c:	e3a03000 	mov	r3, #0
  11f820:	e50b300c 	str	r3, [fp, #-12]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  11f824:	e3063a30 	movw	r3, #27184	; 0x6a30
  11f828:	e3403057 	movt	r3, #87	; 0x57
  11f82c:	e5933000 	ldr	r3, [r3]
  11f830:	e50b3008 	str	r3, [fp, #-8]
  11f834:	ea00001c 	b	11f8ac <tcp_kill_prio+0xc8>
    if (pcb->prio <= mprio &&
  11f838:	e51b3008 	ldr	r3, [fp, #-8]
  11f83c:	e5d33018 	ldrb	r3, [r3, #24]
  11f840:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  11f844:	e1520003 	cmp	r2, r3
  11f848:	3a000014 	bcc	11f8a0 <tcp_kill_prio+0xbc>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  11f84c:	e3063a34 	movw	r3, #27188	; 0x6a34
  11f850:	e3403057 	movt	r3, #87	; 0x57
  11f854:	e5932000 	ldr	r2, [r3]
  11f858:	e51b3008 	ldr	r3, [fp, #-8]
  11f85c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11f860:	e0423003 	sub	r3, r2, r3
    if (pcb->prio <= mprio &&
  11f864:	e51b2010 	ldr	r2, [fp, #-16]
  11f868:	e1520003 	cmp	r2, r3
  11f86c:	8a00000b 	bhi	11f8a0 <tcp_kill_prio+0xbc>
      inactivity = tcp_ticks - pcb->tmr;
  11f870:	e3063a34 	movw	r3, #27188	; 0x6a34
  11f874:	e3403057 	movt	r3, #87	; 0x57
  11f878:	e5932000 	ldr	r2, [r3]
  11f87c:	e51b3008 	ldr	r3, [fp, #-8]
  11f880:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11f884:	e0423003 	sub	r3, r2, r3
  11f888:	e50b3010 	str	r3, [fp, #-16]
      inactive = pcb;
  11f88c:	e51b3008 	ldr	r3, [fp, #-8]
  11f890:	e50b300c 	str	r3, [fp, #-12]
      mprio = pcb->prio;
  11f894:	e51b3008 	ldr	r3, [fp, #-8]
  11f898:	e5d33018 	ldrb	r3, [r3, #24]
  11f89c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  11f8a0:	e51b3008 	ldr	r3, [fp, #-8]
  11f8a4:	e593300c 	ldr	r3, [r3, #12]
  11f8a8:	e50b3008 	str	r3, [fp, #-8]
  11f8ac:	e51b3008 	ldr	r3, [fp, #-8]
  11f8b0:	e3530000 	cmp	r3, #0
  11f8b4:	1affffdf 	bne	11f838 <tcp_kill_prio+0x54>
    }
  }
  if (inactive != NULL) {
  11f8b8:	e51b300c 	ldr	r3, [fp, #-12]
  11f8bc:	e3530000 	cmp	r3, #0
  11f8c0:	0a000001 	beq	11f8cc <tcp_kill_prio+0xe8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  11f8c4:	e51b000c 	ldr	r0, [fp, #-12]
  11f8c8:	ebfff8d3 	bl	11dc1c <tcp_abort>
  }
}
  11f8cc:	e320f000 	nop	{0}
  11f8d0:	e24bd004 	sub	sp, fp, #4
  11f8d4:	e8bd8800 	pop	{fp, pc}

0011f8d8 <tcp_kill_state>:
 * Kills the oldest connection that is in specific state.
 * Called from tcp_alloc() for LAST_ACK and CLOSING if no more connections are available.
 */
static void
tcp_kill_state(enum tcp_state state)
{
  11f8d8:	e92d4800 	push	{fp, lr}
  11f8dc:	e28db004 	add	fp, sp, #4
  11f8e0:	e24dd018 	sub	sp, sp, #24
  11f8e4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
  11f8e8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f8ec:	e3530008 	cmp	r3, #8
  11f8f0:	0a000009 	beq	11f91c <tcp_kill_state+0x44>
  11f8f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  11f8f8:	e3530009 	cmp	r3, #9
  11f8fc:	0a000006 	beq	11f91c <tcp_kill_state+0x44>
  11f900:	e30803cc 	movw	r0, #33740	; 0x83cc
  11f904:	e3400014 	movt	r0, #20
  11f908:	ebff8e01 	bl	103114 <rt_kprintf>
  11f90c:	e30015d7 	movw	r1, #1495	; 0x5d7
  11f910:	e30800f4 	movw	r0, #33012	; 0x80f4
  11f914:	e3400014 	movt	r0, #20
  11f918:	ebffadd7 	bl	10b07c <sys_arch_assert>

  inactivity = 0;
  11f91c:	e3a03000 	mov	r3, #0
  11f920:	e50b3010 	str	r3, [fp, #-16]
  inactive = NULL;
  11f924:	e3a03000 	mov	r3, #0
  11f928:	e50b300c 	str	r3, [fp, #-12]
  /* Go through the list of active pcbs and get the oldest pcb that is in state
     CLOSING/LAST_ACK. */
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  11f92c:	e3063a30 	movw	r3, #27184	; 0x6a30
  11f930:	e3403057 	movt	r3, #87	; 0x57
  11f934:	e5933000 	ldr	r3, [r3]
  11f938:	e50b3008 	str	r3, [fp, #-8]
  11f93c:	ea000019 	b	11f9a8 <tcp_kill_state+0xd0>
    if (pcb->state == state) {
  11f940:	e51b3008 	ldr	r3, [fp, #-8]
  11f944:	e5933014 	ldr	r3, [r3, #20]
  11f948:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  11f94c:	e1520003 	cmp	r2, r3
  11f950:	1a000011 	bne	11f99c <tcp_kill_state+0xc4>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  11f954:	e3063a34 	movw	r3, #27188	; 0x6a34
  11f958:	e3403057 	movt	r3, #87	; 0x57
  11f95c:	e5932000 	ldr	r2, [r3]
  11f960:	e51b3008 	ldr	r3, [fp, #-8]
  11f964:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11f968:	e0423003 	sub	r3, r2, r3
  11f96c:	e51b2010 	ldr	r2, [fp, #-16]
  11f970:	e1520003 	cmp	r2, r3
  11f974:	8a000008 	bhi	11f99c <tcp_kill_state+0xc4>
        inactivity = tcp_ticks - pcb->tmr;
  11f978:	e3063a34 	movw	r3, #27188	; 0x6a34
  11f97c:	e3403057 	movt	r3, #87	; 0x57
  11f980:	e5932000 	ldr	r2, [r3]
  11f984:	e51b3008 	ldr	r3, [fp, #-8]
  11f988:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11f98c:	e0423003 	sub	r3, r2, r3
  11f990:	e50b3010 	str	r3, [fp, #-16]
        inactive = pcb;
  11f994:	e51b3008 	ldr	r3, [fp, #-8]
  11f998:	e50b300c 	str	r3, [fp, #-12]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  11f99c:	e51b3008 	ldr	r3, [fp, #-8]
  11f9a0:	e593300c 	ldr	r3, [r3, #12]
  11f9a4:	e50b3008 	str	r3, [fp, #-8]
  11f9a8:	e51b3008 	ldr	r3, [fp, #-8]
  11f9ac:	e3530000 	cmp	r3, #0
  11f9b0:	1affffe2 	bne	11f940 <tcp_kill_state+0x68>
      }
    }
  }
  if (inactive != NULL) {
  11f9b4:	e51b300c 	ldr	r3, [fp, #-12]
  11f9b8:	e3530000 	cmp	r3, #0
  11f9bc:	0a000002 	beq	11f9cc <tcp_kill_state+0xf4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
           tcp_state_str[state], (void *)inactive, inactivity));
    /* Don't send a RST, since no data is lost. */
    tcp_abandon(inactive, 0);
  11f9c0:	e3a01000 	mov	r1, #0
  11f9c4:	e51b000c 	ldr	r0, [fp, #-12]
  11f9c8:	ebfff7f4 	bl	11d9a0 <tcp_abandon>
  }
}
  11f9cc:	e320f000 	nop	{0}
  11f9d0:	e24bd004 	sub	sp, fp, #4
  11f9d4:	e8bd8800 	pop	{fp, pc}

0011f9d8 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  11f9d8:	e92d4800 	push	{fp, lr}
  11f9dc:	e28db004 	add	fp, sp, #4
  11f9e0:	e24dd010 	sub	sp, sp, #16
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  11f9e4:	e3a03000 	mov	r3, #0
  11f9e8:	e50b3010 	str	r3, [fp, #-16]
  inactive = NULL;
  11f9ec:	e3a03000 	mov	r3, #0
  11f9f0:	e50b300c 	str	r3, [fp, #-12]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  11f9f4:	e3063a40 	movw	r3, #27200	; 0x6a40
  11f9f8:	e3403057 	movt	r3, #87	; 0x57
  11f9fc:	e5933000 	ldr	r3, [r3]
  11fa00:	e50b3008 	str	r3, [fp, #-8]
  11fa04:	ea000014 	b	11fa5c <tcp_kill_timewait+0x84>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  11fa08:	e3063a34 	movw	r3, #27188	; 0x6a34
  11fa0c:	e3403057 	movt	r3, #87	; 0x57
  11fa10:	e5932000 	ldr	r2, [r3]
  11fa14:	e51b3008 	ldr	r3, [fp, #-8]
  11fa18:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11fa1c:	e0423003 	sub	r3, r2, r3
  11fa20:	e51b2010 	ldr	r2, [fp, #-16]
  11fa24:	e1520003 	cmp	r2, r3
  11fa28:	8a000008 	bhi	11fa50 <tcp_kill_timewait+0x78>
      inactivity = tcp_ticks - pcb->tmr;
  11fa2c:	e3063a34 	movw	r3, #27188	; 0x6a34
  11fa30:	e3403057 	movt	r3, #87	; 0x57
  11fa34:	e5932000 	ldr	r2, [r3]
  11fa38:	e51b3008 	ldr	r3, [fp, #-8]
  11fa3c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  11fa40:	e0423003 	sub	r3, r2, r3
  11fa44:	e50b3010 	str	r3, [fp, #-16]
      inactive = pcb;
  11fa48:	e51b3008 	ldr	r3, [fp, #-8]
  11fa4c:	e50b300c 	str	r3, [fp, #-12]
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  11fa50:	e51b3008 	ldr	r3, [fp, #-8]
  11fa54:	e593300c 	ldr	r3, [r3, #12]
  11fa58:	e50b3008 	str	r3, [fp, #-8]
  11fa5c:	e51b3008 	ldr	r3, [fp, #-8]
  11fa60:	e3530000 	cmp	r3, #0
  11fa64:	1affffe7 	bne	11fa08 <tcp_kill_timewait+0x30>
    }
  }
  if (inactive != NULL) {
  11fa68:	e51b300c 	ldr	r3, [fp, #-12]
  11fa6c:	e3530000 	cmp	r3, #0
  11fa70:	0a000001 	beq	11fa7c <tcp_kill_timewait+0xa4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  11fa74:	e51b000c 	ldr	r0, [fp, #-12]
  11fa78:	ebfff867 	bl	11dc1c <tcp_abort>
  }
}
  11fa7c:	e320f000 	nop	{0}
  11fa80:	e24bd004 	sub	sp, fp, #4
  11fa84:	e8bd8800 	pop	{fp, pc}

0011fa88 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  11fa88:	e92d4800 	push	{fp, lr}
  11fa8c:	e28db004 	add	fp, sp, #4
  11fa90:	e24dd010 	sub	sp, sp, #16
  11fa94:	e1a03000 	mov	r3, r0
  11fa98:	e54b300d 	strb	r3, [fp, #-13]
  struct tcp_pcb *pcb;

  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  11fa9c:	e3002612 	movw	r2, #1554	; 0x612
  11faa0:	e30810f4 	movw	r1, #33012	; 0x80f4
  11faa4:	e3401014 	movt	r1, #20
  11faa8:	e3a00002 	mov	r0, #2
  11faac:	ebffe60a 	bl	1192dc <memp_malloc_fn>
  11fab0:	e50b0008 	str	r0, [fp, #-8]
  if (pcb == NULL) {
  11fab4:	e51b3008 	ldr	r3, [fp, #-8]
  11fab8:	e3530000 	cmp	r3, #0
  11fabc:	1a000050 	bne	11fc04 <tcp_alloc+0x17c>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  11fac0:	ebffffc4 	bl	11f9d8 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  11fac4:	e3002618 	movw	r2, #1560	; 0x618
  11fac8:	e30810f4 	movw	r1, #33012	; 0x80f4
  11facc:	e3401014 	movt	r1, #20
  11fad0:	e3a00002 	mov	r0, #2
  11fad4:	ebffe600 	bl	1192dc <memp_malloc_fn>
  11fad8:	e50b0008 	str	r0, [fp, #-8]
    if (pcb == NULL) {
  11fadc:	e51b3008 	ldr	r3, [fp, #-8]
  11fae0:	e3530000 	cmp	r3, #0
  11fae4:	1a00003c 	bne	11fbdc <tcp_alloc+0x154>
      /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
      tcp_kill_state(LAST_ACK);
  11fae8:	e3a00009 	mov	r0, #9
  11faec:	ebffff79 	bl	11f8d8 <tcp_kill_state>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  11faf0:	e300261e 	movw	r2, #1566	; 0x61e
  11faf4:	e30810f4 	movw	r1, #33012	; 0x80f4
  11faf8:	e3401014 	movt	r1, #20
  11fafc:	e3a00002 	mov	r0, #2
  11fb00:	ebffe5f5 	bl	1192dc <memp_malloc_fn>
  11fb04:	e50b0008 	str	r0, [fp, #-8]
      if (pcb == NULL) {
  11fb08:	e51b3008 	ldr	r3, [fp, #-8]
  11fb0c:	e3530000 	cmp	r3, #0
  11fb10:	1a000027 	bne	11fbb4 <tcp_alloc+0x12c>
        /* Try killing oldest connection in CLOSING. */
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
        tcp_kill_state(CLOSING);
  11fb14:	e3a00008 	mov	r0, #8
  11fb18:	ebffff6e 	bl	11f8d8 <tcp_kill_state>
        /* Try to allocate a tcp_pcb again. */
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  11fb1c:	e3002624 	movw	r2, #1572	; 0x624
  11fb20:	e30810f4 	movw	r1, #33012	; 0x80f4
  11fb24:	e3401014 	movt	r1, #20
  11fb28:	e3a00002 	mov	r0, #2
  11fb2c:	ebffe5ea 	bl	1192dc <memp_malloc_fn>
  11fb30:	e50b0008 	str	r0, [fp, #-8]
        if (pcb == NULL) {
  11fb34:	e51b3008 	ldr	r3, [fp, #-8]
  11fb38:	e3530000 	cmp	r3, #0
  11fb3c:	1a000012 	bne	11fb8c <tcp_alloc+0x104>
          /* Try killing active connections with lower priority than the new one. */
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
          tcp_kill_prio(prio);
  11fb40:	e55b300d 	ldrb	r3, [fp, #-13]
  11fb44:	e1a00003 	mov	r0, r3
  11fb48:	ebffff25 	bl	11f7e4 <tcp_kill_prio>
          /* Try to allocate a tcp_pcb again. */
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  11fb4c:	e300262a 	movw	r2, #1578	; 0x62a
  11fb50:	e30810f4 	movw	r1, #33012	; 0x80f4
  11fb54:	e3401014 	movt	r1, #20
  11fb58:	e3a00002 	mov	r0, #2
  11fb5c:	ebffe5de 	bl	1192dc <memp_malloc_fn>
  11fb60:	e50b0008 	str	r0, [fp, #-8]
          if (pcb != NULL) {
  11fb64:	e51b3008 	ldr	r3, [fp, #-8]
  11fb68:	e3530000 	cmp	r3, #0
  11fb6c:	0a000006 	beq	11fb8c <tcp_alloc+0x104>
            /* adjust err stats: memp_malloc failed multiple times before */
            MEMP_STATS_DEC(err, MEMP_TCP_PCB);
  11fb70:	e3063840 	movw	r3, #26688	; 0x6840
  11fb74:	e3403057 	movt	r3, #87	; 0x57
  11fb78:	e59330dc 	ldr	r3, [r3, #220]	; 0xdc
  11fb7c:	e1d320b4 	ldrh	r2, [r3, #4]
  11fb80:	e2422001 	sub	r2, r2, #1
  11fb84:	e6ff2072 	uxth	r2, r2
  11fb88:	e1c320b4 	strh	r2, [r3, #4]
          }
        }
        if (pcb != NULL) {
  11fb8c:	e51b3008 	ldr	r3, [fp, #-8]
  11fb90:	e3530000 	cmp	r3, #0
  11fb94:	0a000006 	beq	11fbb4 <tcp_alloc+0x12c>
          /* adjust err stats: memp_malloc failed multiple times before */
          MEMP_STATS_DEC(err, MEMP_TCP_PCB);
  11fb98:	e3063840 	movw	r3, #26688	; 0x6840
  11fb9c:	e3403057 	movt	r3, #87	; 0x57
  11fba0:	e59330dc 	ldr	r3, [r3, #220]	; 0xdc
  11fba4:	e1d320b4 	ldrh	r2, [r3, #4]
  11fba8:	e2422001 	sub	r2, r2, #1
  11fbac:	e6ff2072 	uxth	r2, r2
  11fbb0:	e1c320b4 	strh	r2, [r3, #4]
        }
      }
      if (pcb != NULL) {
  11fbb4:	e51b3008 	ldr	r3, [fp, #-8]
  11fbb8:	e3530000 	cmp	r3, #0
  11fbbc:	0a000006 	beq	11fbdc <tcp_alloc+0x154>
        /* adjust err stats: memp_malloc failed multiple times before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
  11fbc0:	e3063840 	movw	r3, #26688	; 0x6840
  11fbc4:	e3403057 	movt	r3, #87	; 0x57
  11fbc8:	e59330dc 	ldr	r3, [r3, #220]	; 0xdc
  11fbcc:	e1d320b4 	ldrh	r2, [r3, #4]
  11fbd0:	e2422001 	sub	r2, r2, #1
  11fbd4:	e6ff2072 	uxth	r2, r2
  11fbd8:	e1c320b4 	strh	r2, [r3, #4]
      }
    }
    if (pcb != NULL) {
  11fbdc:	e51b3008 	ldr	r3, [fp, #-8]
  11fbe0:	e3530000 	cmp	r3, #0
  11fbe4:	0a000006 	beq	11fc04 <tcp_alloc+0x17c>
      /* adjust err stats: memp_malloc failed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
  11fbe8:	e3063840 	movw	r3, #26688	; 0x6840
  11fbec:	e3403057 	movt	r3, #87	; 0x57
  11fbf0:	e59330dc 	ldr	r3, [r3, #220]	; 0xdc
  11fbf4:	e1d320b4 	ldrh	r2, [r3, #4]
  11fbf8:	e2422001 	sub	r2, r2, #1
  11fbfc:	e6ff2072 	uxth	r2, r2
  11fc00:	e1c320b4 	strh	r2, [r3, #4]
    }
  }
  if (pcb != NULL) {
  11fc04:	e51b3008 	ldr	r3, [fp, #-8]
  11fc08:	e3530000 	cmp	r3, #0
  11fc0c:	0a00003e 	beq	11fd0c <tcp_alloc+0x284>
    /* zero out the whole pcb, so there is no need to initialize members to zero */
    memset(pcb, 0, sizeof(struct tcp_pcb));
  11fc10:	e3a020a4 	mov	r2, #164	; 0xa4
  11fc14:	e3a01000 	mov	r1, #0
  11fc18:	e51b0008 	ldr	r0, [fp, #-8]
  11fc1c:	eb008614 	bl	141474 <memset>
    pcb->prio = prio;
  11fc20:	e51b3008 	ldr	r3, [fp, #-8]
  11fc24:	e55b200d 	ldrb	r2, [fp, #-13]
  11fc28:	e5c32018 	strb	r2, [r3, #24]
    pcb->snd_buf = TCP_SND_BUF;
  11fc2c:	e51b3008 	ldr	r3, [fp, #-8]
  11fc30:	e3a02a02 	mov	r2, #8192	; 0x2000
  11fc34:	e1c326b4 	strh	r2, [r3, #100]	; 0x64
    /* Start with a window that does not need scaling. When window scaling is
       enabled and used, the window is enlarged when both sides agree on scaling. */
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
  11fc38:	e51b3008 	ldr	r3, [fp, #-8]
  11fc3c:	e3e02000 	mvn	r2, #0
  11fc40:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
  11fc44:	e51b3008 	ldr	r3, [fp, #-8]
  11fc48:	e1d322be 	ldrh	r2, [r3, #46]	; 0x2e
  11fc4c:	e51b3008 	ldr	r3, [fp, #-8]
  11fc50:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
    pcb->ttl = TCP_TTL;
  11fc54:	e51b3008 	ldr	r3, [fp, #-8]
  11fc58:	e3e02000 	mvn	r2, #0
  11fc5c:	e5c3200a 	strb	r2, [r3, #10]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = INITIAL_MSS;
  11fc60:	e51b3008 	ldr	r3, [fp, #-8]
  11fc64:	e3a02f86 	mov	r2, #536	; 0x218
  11fc68:	e1c323b6 	strh	r2, [r3, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  11fc6c:	e51b3008 	ldr	r3, [fp, #-8]
  11fc70:	e3a02006 	mov	r2, #6
  11fc74:	e1c324b4 	strh	r2, [r3, #68]	; 0x44
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  11fc78:	e51b3008 	ldr	r3, [fp, #-8]
  11fc7c:	e3a02006 	mov	r2, #6
  11fc80:	e1c324b2 	strh	r2, [r3, #66]	; 0x42
    pcb->rtime = -1;
  11fc84:	e51b3008 	ldr	r3, [fp, #-8]
  11fc88:	e3e02000 	mvn	r2, #0
  11fc8c:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
    pcb->cwnd = 1;
  11fc90:	e51b3008 	ldr	r3, [fp, #-8]
  11fc94:	e3a02001 	mov	r2, #1
  11fc98:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
    pcb->tmr = tcp_ticks;
  11fc9c:	e3063a34 	movw	r3, #27188	; 0x6a34
  11fca0:	e3403057 	movt	r3, #87	; 0x57
  11fca4:	e5932000 	ldr	r2, [r3]
  11fca8:	e51b3008 	ldr	r3, [fp, #-8]
  11fcac:	e5832024 	str	r2, [r3, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
  11fcb0:	e30f321d 	movw	r3, #61981	; 0xf21d
  11fcb4:	e3403014 	movt	r3, #20
  11fcb8:	e5d32000 	ldrb	r2, [r3]
  11fcbc:	e51b3008 	ldr	r3, [fp, #-8]
  11fcc0:	e5c32021 	strb	r2, [r3, #33]	; 0x21
    of using the largest advertised receive window.  We've seen complications with
    receiving TCPs that use window scaling and/or window auto-tuning where the
    initial advertised window is very small and then grows rapidly once the
    connection is established. To avoid these complications, we set ssthresh to the
    largest effective cwnd (amount of in-flight data) that the sender can have. */
    pcb->ssthresh = TCP_SND_BUF;
  11fcc4:	e51b3008 	ldr	r3, [fp, #-8]
  11fcc8:	e3a02a02 	mov	r2, #8192	; 0x2000
  11fccc:	e1c324be 	strh	r2, [r3, #78]	; 0x4e

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  11fcd0:	e51b2008 	ldr	r2, [fp, #-8]
  11fcd4:	e30f3770 	movw	r3, #63344	; 0xf770
  11fcd8:	e3403011 	movt	r3, #17
  11fcdc:	e5823084 	str	r3, [r2, #132]	; 0x84
#endif /* LWIP_CALLBACK_API */

    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  11fce0:	e51b2008 	ldr	r2, [fp, #-8]
  11fce4:	e3a03cdd 	mov	r3, #56576	; 0xdd00
  11fce8:	e340306d 	movt	r3, #109	; 0x6d
  11fcec:	e5823094 	str	r3, [r2, #148]	; 0x94

#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
  11fcf0:	e51b2008 	ldr	r2, [fp, #-8]
  11fcf4:	e30234f8 	movw	r3, #9464	; 0x24f8
  11fcf8:	e3403001 	movt	r3, #1
  11fcfc:	e5823098 	str	r3, [r2, #152]	; 0x98
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
  11fd00:	e51b3008 	ldr	r3, [fp, #-8]
  11fd04:	e3a02009 	mov	r2, #9
  11fd08:	e583209c 	str	r2, [r3, #156]	; 0x9c
#endif /* LWIP_TCP_KEEPALIVE */
  }
  return pcb;
  11fd0c:	e51b3008 	ldr	r3, [fp, #-8]
}
  11fd10:	e1a00003 	mov	r0, r3
  11fd14:	e24bd004 	sub	sp, fp, #4
  11fd18:	e8bd8800 	pop	{fp, pc}

0011fd1c <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  11fd1c:	e92d4800 	push	{fp, lr}
  11fd20:	e28db004 	add	fp, sp, #4
  return tcp_alloc(TCP_PRIO_NORMAL);
  11fd24:	e3a00040 	mov	r0, #64	; 0x40
  11fd28:	ebffff56 	bl	11fa88 <tcp_alloc>
  11fd2c:	e1a03000 	mov	r3, r0
}
  11fd30:	e1a00003 	mov	r0, r3
  11fd34:	e8bd8800 	pop	{fp, pc}

0011fd38 <tcp_new_ip_type>:
 * supply @ref IPADDR_TYPE_ANY as argument and bind to @ref IP_ANY_TYPE.
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new_ip_type(u8_t type)
{
  11fd38:	e92d4800 	push	{fp, lr}
  11fd3c:	e28db004 	add	fp, sp, #4
  11fd40:	e24dd010 	sub	sp, sp, #16
  11fd44:	e1a03000 	mov	r3, r0
  11fd48:	e54b300d 	strb	r3, [fp, #-13]
  struct tcp_pcb * pcb;
  pcb = tcp_alloc(TCP_PRIO_NORMAL);
  11fd4c:	e3a00040 	mov	r0, #64	; 0x40
  11fd50:	ebffff4c 	bl	11fa88 <tcp_alloc>
  11fd54:	e50b0008 	str	r0, [fp, #-8]
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
  11fd58:	e51b3008 	ldr	r3, [fp, #-8]
}
  11fd5c:	e1a00003 	mov	r0, r3
  11fd60:	e24bd004 	sub	sp, fp, #4
  11fd64:	e8bd8800 	pop	{fp, pc}

0011fd68 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  11fd68:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11fd6c:	e28db000 	add	fp, sp, #0
  11fd70:	e24dd00c 	sub	sp, sp, #12
  11fd74:	e50b0008 	str	r0, [fp, #-8]
  11fd78:	e50b100c 	str	r1, [fp, #-12]
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
  11fd7c:	e51b3008 	ldr	r3, [fp, #-8]
  11fd80:	e3530000 	cmp	r3, #0
  11fd84:	0a000002 	beq	11fd94 <tcp_arg+0x2c>
    pcb->callback_arg = arg;
  11fd88:	e51b3008 	ldr	r3, [fp, #-8]
  11fd8c:	e51b200c 	ldr	r2, [fp, #-12]
  11fd90:	e5832010 	str	r2, [r3, #16]
  }
}
  11fd94:	e320f000 	nop	{0}
  11fd98:	e28bd000 	add	sp, fp, #0
  11fd9c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11fda0:	e12fff1e 	bx	lr

0011fda4 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  11fda4:	e92d4800 	push	{fp, lr}
  11fda8:	e28db004 	add	fp, sp, #4
  11fdac:	e24dd008 	sub	sp, sp, #8
  11fdb0:	e50b0008 	str	r0, [fp, #-8]
  11fdb4:	e50b100c 	str	r1, [fp, #-12]
  if (pcb != NULL) {
  11fdb8:	e51b3008 	ldr	r3, [fp, #-8]
  11fdbc:	e3530000 	cmp	r3, #0
  11fdc0:	0a00000d 	beq	11fdfc <tcp_recv+0x58>
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
  11fdc4:	e51b3008 	ldr	r3, [fp, #-8]
  11fdc8:	e5933014 	ldr	r3, [r3, #20]
  11fdcc:	e3530001 	cmp	r3, #1
  11fdd0:	1a000006 	bne	11fdf0 <tcp_recv+0x4c>
  11fdd4:	e30803dc 	movw	r0, #33756	; 0x83dc
  11fdd8:	e3400014 	movt	r0, #20
  11fddc:	ebff8ccc 	bl	103114 <rt_kprintf>
  11fde0:	e30016b6 	movw	r1, #1718	; 0x6b6
  11fde4:	e30800f4 	movw	r0, #33012	; 0x80f4
  11fde8:	e3400014 	movt	r0, #20
  11fdec:	ebffaca2 	bl	10b07c <sys_arch_assert>
    pcb->recv = recv;
  11fdf0:	e51b3008 	ldr	r3, [fp, #-8]
  11fdf4:	e51b200c 	ldr	r2, [fp, #-12]
  11fdf8:	e5832084 	str	r2, [r3, #132]	; 0x84
  }
}
  11fdfc:	e320f000 	nop	{0}
  11fe00:	e24bd004 	sub	sp, fp, #4
  11fe04:	e8bd8800 	pop	{fp, pc}

0011fe08 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  11fe08:	e92d4800 	push	{fp, lr}
  11fe0c:	e28db004 	add	fp, sp, #4
  11fe10:	e24dd008 	sub	sp, sp, #8
  11fe14:	e50b0008 	str	r0, [fp, #-8]
  11fe18:	e50b100c 	str	r1, [fp, #-12]
  if (pcb != NULL) {
  11fe1c:	e51b3008 	ldr	r3, [fp, #-8]
  11fe20:	e3530000 	cmp	r3, #0
  11fe24:	0a00000d 	beq	11fe60 <tcp_sent+0x58>
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
  11fe28:	e51b3008 	ldr	r3, [fp, #-8]
  11fe2c:	e5933014 	ldr	r3, [r3, #20]
  11fe30:	e3530001 	cmp	r3, #1
  11fe34:	1a000006 	bne	11fe54 <tcp_sent+0x4c>
  11fe38:	e3080404 	movw	r0, #33796	; 0x8404
  11fe3c:	e3400014 	movt	r0, #20
  11fe40:	ebff8cb3 	bl	103114 <rt_kprintf>
  11fe44:	e30016c7 	movw	r1, #1735	; 0x6c7
  11fe48:	e30800f4 	movw	r0, #33012	; 0x80f4
  11fe4c:	e3400014 	movt	r0, #20
  11fe50:	ebffac89 	bl	10b07c <sys_arch_assert>
    pcb->sent = sent;
  11fe54:	e51b3008 	ldr	r3, [fp, #-8]
  11fe58:	e51b200c 	ldr	r2, [fp, #-12]
  11fe5c:	e5832080 	str	r2, [r3, #128]	; 0x80
  }
}
  11fe60:	e320f000 	nop	{0}
  11fe64:	e24bd004 	sub	sp, fp, #4
  11fe68:	e8bd8800 	pop	{fp, pc}

0011fe6c <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  11fe6c:	e92d4800 	push	{fp, lr}
  11fe70:	e28db004 	add	fp, sp, #4
  11fe74:	e24dd008 	sub	sp, sp, #8
  11fe78:	e50b0008 	str	r0, [fp, #-8]
  11fe7c:	e50b100c 	str	r1, [fp, #-12]
  if (pcb != NULL) {
  11fe80:	e51b3008 	ldr	r3, [fp, #-8]
  11fe84:	e3530000 	cmp	r3, #0
  11fe88:	0a00000d 	beq	11fec4 <tcp_err+0x58>
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
  11fe8c:	e51b3008 	ldr	r3, [fp, #-8]
  11fe90:	e5933014 	ldr	r3, [r3, #20]
  11fe94:	e3530001 	cmp	r3, #1
  11fe98:	1a000006 	bne	11feb8 <tcp_err+0x4c>
  11fe9c:	e308042c 	movw	r0, #33836	; 0x842c
  11fea0:	e3400014 	movt	r0, #20
  11fea4:	ebff8c9a 	bl	103114 <rt_kprintf>
  11fea8:	e30016db 	movw	r1, #1755	; 0x6db
  11feac:	e30800f4 	movw	r0, #33012	; 0x80f4
  11feb0:	e3400014 	movt	r0, #20
  11feb4:	ebffac70 	bl	10b07c <sys_arch_assert>
    pcb->errf = err;
  11feb8:	e51b3008 	ldr	r3, [fp, #-8]
  11febc:	e51b200c 	ldr	r2, [fp, #-12]
  11fec0:	e5832090 	str	r2, [r3, #144]	; 0x90
  }
}
  11fec4:	e320f000 	nop	{0}
  11fec8:	e24bd004 	sub	sp, fp, #4
  11fecc:	e8bd8800 	pop	{fp, pc}

0011fed0 <tcp_accept>:
 * @param accept callback function to call for this pcb when LISTENing
 *        connection has been connected to another host
 */
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
  11fed0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  11fed4:	e28db000 	add	fp, sp, #0
  11fed8:	e24dd014 	sub	sp, sp, #20
  11fedc:	e50b0010 	str	r0, [fp, #-16]
  11fee0:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  if ((pcb != NULL) && (pcb->state == LISTEN)) {
  11fee4:	e51b3010 	ldr	r3, [fp, #-16]
  11fee8:	e3530000 	cmp	r3, #0
  11feec:	0a000008 	beq	11ff14 <tcp_accept+0x44>
  11fef0:	e51b3010 	ldr	r3, [fp, #-16]
  11fef4:	e5933014 	ldr	r3, [r3, #20]
  11fef8:	e3530001 	cmp	r3, #1
  11fefc:	1a000004 	bne	11ff14 <tcp_accept+0x44>
    struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)pcb;
  11ff00:	e51b3010 	ldr	r3, [fp, #-16]
  11ff04:	e50b3008 	str	r3, [fp, #-8]
    lpcb->accept = accept;
  11ff08:	e51b3008 	ldr	r3, [fp, #-8]
  11ff0c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  11ff10:	e583201c 	str	r2, [r3, #28]
  }
}
  11ff14:	e320f000 	nop	{0}
  11ff18:	e28bd000 	add	sp, fp, #0
  11ff1c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  11ff20:	e12fff1e 	bx	lr

0011ff24 <tcp_poll>:
 * timer interval, which is called twice a second.
 *
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  11ff24:	e92d4800 	push	{fp, lr}
  11ff28:	e28db004 	add	fp, sp, #4
  11ff2c:	e24dd010 	sub	sp, sp, #16
  11ff30:	e50b0008 	str	r0, [fp, #-8]
  11ff34:	e50b100c 	str	r1, [fp, #-12]
  11ff38:	e1a03002 	mov	r3, r2
  11ff3c:	e54b300d 	strb	r3, [fp, #-13]
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
  11ff40:	e51b3008 	ldr	r3, [fp, #-8]
  11ff44:	e5933014 	ldr	r3, [r3, #20]
  11ff48:	e3530001 	cmp	r3, #1
  11ff4c:	1a000006 	bne	11ff6c <tcp_poll+0x48>
  11ff50:	e3080454 	movw	r0, #33876	; 0x8454
  11ff54:	e3400014 	movt	r0, #20
  11ff58:	ebff8c6d 	bl	103114 <rt_kprintf>
  11ff5c:	e30016fe 	movw	r1, #1790	; 0x6fe
  11ff60:	e30800f4 	movw	r0, #33012	; 0x80f4
  11ff64:	e3400014 	movt	r0, #20
  11ff68:	ebffac43 	bl	10b07c <sys_arch_assert>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  11ff6c:	e51b3008 	ldr	r3, [fp, #-8]
  11ff70:	e51b200c 	ldr	r2, [fp, #-12]
  11ff74:	e583208c 	str	r2, [r3, #140]	; 0x8c
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
  11ff78:	e51b3008 	ldr	r3, [fp, #-8]
  11ff7c:	e55b200d 	ldrb	r2, [fp, #-13]
  11ff80:	e5c32020 	strb	r2, [r3, #32]
}
  11ff84:	e320f000 	nop	{0}
  11ff88:	e24bd004 	sub	sp, fp, #4
  11ff8c:	e8bd8800 	pop	{fp, pc}

0011ff90 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  11ff90:	e92d4800 	push	{fp, lr}
  11ff94:	e28db004 	add	fp, sp, #4
  11ff98:	e24dd008 	sub	sp, sp, #8
  11ff9c:	e50b0008 	str	r0, [fp, #-8]
  if (pcb->state != CLOSED &&
  11ffa0:	e51b3008 	ldr	r3, [fp, #-8]
  11ffa4:	e5933014 	ldr	r3, [r3, #20]
  11ffa8:	e3530000 	cmp	r3, #0
  11ffac:	0a00002e 	beq	12006c <tcp_pcb_purge+0xdc>
     pcb->state != TIME_WAIT &&
  11ffb0:	e51b3008 	ldr	r3, [fp, #-8]
  11ffb4:	e5933014 	ldr	r3, [r3, #20]
  if (pcb->state != CLOSED &&
  11ffb8:	e353000a 	cmp	r3, #10
  11ffbc:	0a00002a 	beq	12006c <tcp_pcb_purge+0xdc>
     pcb->state != LISTEN) {
  11ffc0:	e51b3008 	ldr	r3, [fp, #-8]
  11ffc4:	e5933014 	ldr	r3, [r3, #20]
     pcb->state != TIME_WAIT &&
  11ffc8:	e3530001 	cmp	r3, #1
  11ffcc:	0a000026 	beq	12006c <tcp_pcb_purge+0xdc>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
  11ffd0:	e51b3008 	ldr	r3, [fp, #-8]
  11ffd4:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  11ffd8:	e3530000 	cmp	r3, #0
  11ffdc:	0a000006 	beq	11fffc <tcp_pcb_purge+0x6c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  11ffe0:	e51b3008 	ldr	r3, [fp, #-8]
  11ffe4:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  11ffe8:	e1a00003 	mov	r0, r3
  11ffec:	ebffec30 	bl	11b0b4 <pbuf_free>
      pcb->refused_data = NULL;
  11fff0:	e51b3008 	ldr	r3, [fp, #-8]
  11fff4:	e3a02000 	mov	r2, #0
  11fff8:	e5832078 	str	r2, [r3, #120]	; 0x78
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
  11fffc:	e51b3008 	ldr	r3, [fp, #-8]
  120000:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  120004:	e1a00003 	mov	r0, r3
  120008:	ebfffd89 	bl	11f634 <tcp_segs_free>
    pcb->ooseq = NULL;
  12000c:	e51b3008 	ldr	r3, [fp, #-8]
  120010:	e3a02000 	mov	r2, #0
  120014:	e5832074 	str	r2, [r3, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  120018:	e51b3008 	ldr	r3, [fp, #-8]
  12001c:	e3e02000 	mvn	r2, #0
  120020:	e1c323b4 	strh	r2, [r3, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
  120024:	e51b3008 	ldr	r3, [fp, #-8]
  120028:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  12002c:	e1a00003 	mov	r0, r3
  120030:	ebfffd7f 	bl	11f634 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  120034:	e51b3008 	ldr	r3, [fp, #-8]
  120038:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  12003c:	e1a00003 	mov	r0, r3
  120040:	ebfffd7b 	bl	11f634 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  120044:	e51b3008 	ldr	r3, [fp, #-8]
  120048:	e3a02000 	mov	r2, #0
  12004c:	e583206c 	str	r2, [r3, #108]	; 0x6c
  120050:	e51b3008 	ldr	r3, [fp, #-8]
  120054:	e593206c 	ldr	r2, [r3, #108]	; 0x6c
  120058:	e51b3008 	ldr	r3, [fp, #-8]
  12005c:	e5832070 	str	r2, [r3, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
  120060:	e51b3008 	ldr	r3, [fp, #-8]
  120064:	e3a02000 	mov	r2, #0
  120068:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
#endif /* TCP_OVERSIZE */
  }
}
  12006c:	e320f000 	nop	{0}
  120070:	e24bd004 	sub	sp, fp, #4
  120074:	e8bd8800 	pop	{fp, pc}

00120078 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  120078:	e92d4800 	push	{fp, lr}
  12007c:	e28db004 	add	fp, sp, #4
  120080:	e24dd010 	sub	sp, sp, #16
  120084:	e50b0010 	str	r0, [fp, #-16]
  120088:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  TCP_RMV(pcblist, pcb);
  12008c:	e51b3010 	ldr	r3, [fp, #-16]
  120090:	e5933000 	ldr	r3, [r3]
  120094:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  120098:	e1520003 	cmp	r2, r3
  12009c:	1a000005 	bne	1200b8 <tcp_pcb_remove+0x40>
  1200a0:	e51b3010 	ldr	r3, [fp, #-16]
  1200a4:	e5933000 	ldr	r3, [r3]
  1200a8:	e593200c 	ldr	r2, [r3, #12]
  1200ac:	e51b3010 	ldr	r3, [fp, #-16]
  1200b0:	e5832000 	str	r2, [r3]
  1200b4:	ea000013 	b	120108 <tcp_pcb_remove+0x90>
  1200b8:	e51b3010 	ldr	r3, [fp, #-16]
  1200bc:	e5933000 	ldr	r3, [r3]
  1200c0:	e50b3008 	str	r3, [fp, #-8]
  1200c4:	ea00000c 	b	1200fc <tcp_pcb_remove+0x84>
  1200c8:	e51b3008 	ldr	r3, [fp, #-8]
  1200cc:	e593300c 	ldr	r3, [r3, #12]
  1200d0:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  1200d4:	e1520003 	cmp	r2, r3
  1200d8:	1a000004 	bne	1200f0 <tcp_pcb_remove+0x78>
  1200dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1200e0:	e593200c 	ldr	r2, [r3, #12]
  1200e4:	e51b3008 	ldr	r3, [fp, #-8]
  1200e8:	e583200c 	str	r2, [r3, #12]
  1200ec:	ea000005 	b	120108 <tcp_pcb_remove+0x90>
  1200f0:	e51b3008 	ldr	r3, [fp, #-8]
  1200f4:	e593300c 	ldr	r3, [r3, #12]
  1200f8:	e50b3008 	str	r3, [fp, #-8]
  1200fc:	e51b3008 	ldr	r3, [fp, #-8]
  120100:	e3530000 	cmp	r3, #0
  120104:	1affffef 	bne	1200c8 <tcp_pcb_remove+0x50>
  120108:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12010c:	e3a02000 	mov	r2, #0
  120110:	e583200c 	str	r2, [r3, #12]

  tcp_pcb_purge(pcb);
  120114:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  120118:	ebffff9c 	bl	11ff90 <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  12011c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120120:	e5933014 	ldr	r3, [r3, #20]
  120124:	e353000a 	cmp	r3, #10
  120128:	0a000010 	beq	120170 <tcp_pcb_remove+0xf8>
     pcb->state != LISTEN &&
  12012c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120130:	e5933014 	ldr	r3, [r3, #20]
  if (pcb->state != TIME_WAIT &&
  120134:	e3530001 	cmp	r3, #1
  120138:	0a00000c 	beq	120170 <tcp_pcb_remove+0xf8>
     pcb->flags & TF_ACK_DELAY) {
  12013c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120140:	e5d3301e 	ldrb	r3, [r3, #30]
  120144:	e2033001 	and	r3, r3, #1
     pcb->state != LISTEN &&
  120148:	e3530000 	cmp	r3, #0
  12014c:	0a000007 	beq	120170 <tcp_pcb_remove+0xf8>
    pcb->flags |= TF_ACK_NOW;
  120150:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120154:	e5d3301e 	ldrb	r3, [r3, #30]
  120158:	e3833002 	orr	r3, r3, #2
  12015c:	e6ef2073 	uxtb	r2, r3
  120160:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120164:	e5c3201e 	strb	r2, [r3, #30]
    tcp_output(pcb);
  120168:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  12016c:	eb0017fa 	bl	12615c <tcp_output>
  }

  if (pcb->state != LISTEN) {
  120170:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120174:	e5933014 	ldr	r3, [r3, #20]
  120178:	e3530001 	cmp	r3, #1
  12017c:	0a000020 	beq	120204 <tcp_pcb_remove+0x18c>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  120180:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120184:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  120188:	e3530000 	cmp	r3, #0
  12018c:	0a000006 	beq	1201ac <tcp_pcb_remove+0x134>
  120190:	e3080474 	movw	r0, #33908	; 0x8474
  120194:	e3400014 	movt	r0, #20
  120198:	ebff8bdd 	bl	103114 <rt_kprintf>
  12019c:	e300174e 	movw	r1, #1870	; 0x74e
  1201a0:	e30800f4 	movw	r0, #33012	; 0x80f4
  1201a4:	e3400014 	movt	r0, #20
  1201a8:	ebffabb3 	bl	10b07c <sys_arch_assert>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  1201ac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1201b0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  1201b4:	e3530000 	cmp	r3, #0
  1201b8:	0a000006 	beq	1201d8 <tcp_pcb_remove+0x160>
  1201bc:	e308048c 	movw	r0, #33932	; 0x848c
  1201c0:	e3400014 	movt	r0, #20
  1201c4:	ebff8bd2 	bl	103114 <rt_kprintf>
  1201c8:	e300174f 	movw	r1, #1871	; 0x74f
  1201cc:	e30800f4 	movw	r0, #33012	; 0x80f4
  1201d0:	e3400014 	movt	r0, #20
  1201d4:	ebffaba8 	bl	10b07c <sys_arch_assert>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  1201d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1201dc:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  1201e0:	e3530000 	cmp	r3, #0
  1201e4:	0a000006 	beq	120204 <tcp_pcb_remove+0x18c>
  1201e8:	e30804a8 	movw	r0, #33960	; 0x84a8
  1201ec:	e3400014 	movt	r0, #20
  1201f0:	ebff8bc7 	bl	103114 <rt_kprintf>
  1201f4:	e3001751 	movw	r1, #1873	; 0x751
  1201f8:	e30800f4 	movw	r0, #33012	; 0x80f4
  1201fc:	e3400014 	movt	r0, #20
  120200:	ebffab9d 	bl	10b07c <sys_arch_assert>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  120204:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120208:	e3a02000 	mov	r2, #0
  12020c:	e5832014 	str	r2, [r3, #20]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
  120210:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120214:	e3a02000 	mov	r2, #0
  120218:	e1c321ba 	strh	r2, [r3, #26]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  12021c:	e320f000 	nop	{0}
  120220:	e24bd004 	sub	sp, fp, #4
  120224:	e8bd8800 	pop	{fp, pc}

00120228 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
  120228:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  12022c:	e28db000 	add	fp, sp, #0
  120230:	e24dd00c 	sub	sp, sp, #12
  120234:	e50b0008 	str	r0, [fp, #-8]
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
  120238:	e30e3034 	movw	r3, #57396	; 0xe034
  12023c:	e3403014 	movt	r3, #20
  120240:	e5932000 	ldr	r2, [r3]
  120244:	e3063a34 	movw	r3, #27188	; 0x6a34
  120248:	e3403057 	movt	r3, #87	; 0x57
  12024c:	e5933000 	ldr	r3, [r3]
  120250:	e0822003 	add	r2, r2, r3
  120254:	e30e3034 	movw	r3, #57396	; 0xe034
  120258:	e3403014 	movt	r3, #20
  12025c:	e5832000 	str	r2, [r3]
  return iss;
  120260:	e30e3034 	movw	r3, #57396	; 0xe034
  120264:	e3403014 	movt	r3, #20
  120268:	e5933000 	ldr	r3, [r3]
#endif /* LWIP_HOOK_TCP_ISN */
}
  12026c:	e1a00003 	mov	r0, r3
  120270:	e28bd000 	add	sp, fp, #0
  120274:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  120278:	e12fff1e 	bx	lr

0012027c <tcp_eff_send_mss_impl>:
tcp_eff_send_mss_impl(u16_t sendmss, const ip_addr_t *dest
#if LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING
                     , const ip_addr_t *src
#endif /* LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING */
                     )
{
  12027c:	e92d4800 	push	{fp, lr}
  120280:	e28db004 	add	fp, sp, #4
  120284:	e24dd010 	sub	sp, sp, #16
  120288:	e1a03000 	mov	r3, r0
  12028c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  120290:	e14b30be 	strh	r3, [fp, #-14]
  u16_t mss_s;
  struct netif *outif;
  s16_t mtu;

  outif = ip_route(src, dest);
  120294:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  120298:	eb00443c 	bl	131390 <ip4_route>
  12029c:	e50b0008 	str	r0, [fp, #-8]
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
  1202a0:	e51b3008 	ldr	r3, [fp, #-8]
  1202a4:	e3530000 	cmp	r3, #0
  1202a8:	1a000001 	bne	1202b4 <tcp_eff_send_mss_impl+0x38>
      return sendmss;
  1202ac:	e15b30be 	ldrh	r3, [fp, #-14]
  1202b0:	ea00000f 	b	1202f4 <tcp_eff_send_mss_impl+0x78>
    }
    mtu = outif->mtu;
  1202b4:	e51b3008 	ldr	r3, [fp, #-8]
  1202b8:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  1202bc:	e14b30ba 	strh	r3, [fp, #-10]
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
  1202c0:	e15b30fa 	ldrsh	r3, [fp, #-10]
  1202c4:	e3530000 	cmp	r3, #0
  1202c8:	0a000008 	beq	1202f0 <tcp_eff_send_mss_impl+0x74>
    else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    {
      mss_s = mtu - IP_HLEN - TCP_HLEN;
  1202cc:	e15b30ba 	ldrh	r3, [fp, #-10]
  1202d0:	e2433028 	sub	r3, r3, #40	; 0x28
  1202d4:	e14b30bc 	strh	r3, [fp, #-12]
#endif /* LWIP_IPV4 */
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
  1202d8:	e15b20bc 	ldrh	r2, [fp, #-12]
  1202dc:	e15b30be 	ldrh	r3, [fp, #-14]
  1202e0:	e1520003 	cmp	r2, r3
  1202e4:	31a03002 	movcc	r3, r2
  1202e8:	21a03003 	movcs	r3, r3
  1202ec:	e14b30be 	strh	r3, [fp, #-14]
  }
  return sendmss;
  1202f0:	e15b30be 	ldrh	r3, [fp, #-14]
}
  1202f4:	e1a00003 	mov	r0, r3
  1202f8:	e24bd004 	sub	sp, fp, #4
  1202fc:	e8bd8800 	pop	{fp, pc}

00120300 <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t* old_addr, struct tcp_pcb* pcb_list)
{
  120300:	e92d4800 	push	{fp, lr}
  120304:	e28db004 	add	fp, sp, #4
  120308:	e24dd010 	sub	sp, sp, #16
  12030c:	e50b0010 	str	r0, [fp, #-16]
  120310:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct tcp_pcb *pcb;
  pcb = pcb_list;
  120314:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120318:	e50b3008 	str	r3, [fp, #-8]
  while (pcb != NULL) {
  12031c:	ea000010 	b	120364 <tcp_netif_ip_addr_changed_pcblist+0x64>
    /* PCB bound to current local interface address? */
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
  120320:	e51b3008 	ldr	r3, [fp, #-8]
  120324:	e5932000 	ldr	r2, [r3]
  120328:	e51b3010 	ldr	r3, [fp, #-16]
  12032c:	e5933000 	ldr	r3, [r3]
  120330:	e1520003 	cmp	r2, r3
  120334:	1a000007 	bne	120358 <tcp_netif_ip_addr_changed_pcblist+0x58>
      /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
      && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
      ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
  120338:	e51b3008 	ldr	r3, [fp, #-8]
  12033c:	e593300c 	ldr	r3, [r3, #12]
  120340:	e50b300c 	str	r3, [fp, #-12]
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
      tcp_abort(pcb);
  120344:	e51b0008 	ldr	r0, [fp, #-8]
  120348:	ebfff633 	bl	11dc1c <tcp_abort>
      pcb = next;
  12034c:	e51b300c 	ldr	r3, [fp, #-12]
  120350:	e50b3008 	str	r3, [fp, #-8]
  120354:	ea000002 	b	120364 <tcp_netif_ip_addr_changed_pcblist+0x64>
    } else {
      pcb = pcb->next;
  120358:	e51b3008 	ldr	r3, [fp, #-8]
  12035c:	e593300c 	ldr	r3, [r3, #12]
  120360:	e50b3008 	str	r3, [fp, #-8]
  while (pcb != NULL) {
  120364:	e51b3008 	ldr	r3, [fp, #-8]
  120368:	e3530000 	cmp	r3, #0
  12036c:	1affffeb 	bne	120320 <tcp_netif_ip_addr_changed_pcblist+0x20>
    }
  }
}
  120370:	e320f000 	nop	{0}
  120374:	e24bd004 	sub	sp, fp, #4
  120378:	e8bd8800 	pop	{fp, pc}

0012037c <tcp_netif_ip_addr_changed>:
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change or NULL if netif has been removed
 */
void
tcp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
  12037c:	e92d4800 	push	{fp, lr}
  120380:	e28db004 	add	fp, sp, #4
  120384:	e24dd010 	sub	sp, sp, #16
  120388:	e50b0010 	str	r0, [fp, #-16]
  12038c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct tcp_pcb_listen *lpcb, *next;

  if (!ip_addr_isany(old_addr)) {
  120390:	e51b3010 	ldr	r3, [fp, #-16]
  120394:	e3530000 	cmp	r3, #0
  120398:	0a00002d 	beq	120454 <tcp_netif_ip_addr_changed+0xd8>
  12039c:	e51b3010 	ldr	r3, [fp, #-16]
  1203a0:	e5933000 	ldr	r3, [r3]
  1203a4:	e3530000 	cmp	r3, #0
  1203a8:	0a000029 	beq	120454 <tcp_netif_ip_addr_changed+0xd8>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
  1203ac:	e3063a30 	movw	r3, #27184	; 0x6a30
  1203b0:	e3403057 	movt	r3, #87	; 0x57
  1203b4:	e5933000 	ldr	r3, [r3]
  1203b8:	e1a01003 	mov	r1, r3
  1203bc:	e51b0010 	ldr	r0, [fp, #-16]
  1203c0:	ebffffce 	bl	120300 <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
  1203c4:	e3063a3c 	movw	r3, #27196	; 0x6a3c
  1203c8:	e3403057 	movt	r3, #87	; 0x57
  1203cc:	e5933000 	ldr	r3, [r3]
  1203d0:	e1a01003 	mov	r1, r3
  1203d4:	e51b0010 	ldr	r0, [fp, #-16]
  1203d8:	ebffffc8 	bl	120300 <tcp_netif_ip_addr_changed_pcblist>

    if (!ip_addr_isany(new_addr)) {
  1203dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1203e0:	e3530000 	cmp	r3, #0
  1203e4:	0a00001a 	beq	120454 <tcp_netif_ip_addr_changed+0xd8>
  1203e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1203ec:	e5933000 	ldr	r3, [r3]
  1203f0:	e3530000 	cmp	r3, #0
  1203f4:	0a000016 	beq	120454 <tcp_netif_ip_addr_changed+0xd8>
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
  1203f8:	e3063a38 	movw	r3, #27192	; 0x6a38
  1203fc:	e3403057 	movt	r3, #87	; 0x57
  120400:	e5933000 	ldr	r3, [r3]
  120404:	e50b3008 	str	r3, [fp, #-8]
  120408:	ea00000e 	b	120448 <tcp_netif_ip_addr_changed+0xcc>
        next = lpcb->next;
  12040c:	e51b3008 	ldr	r3, [fp, #-8]
  120410:	e593300c 	ldr	r3, [r3, #12]
  120414:	e50b300c 	str	r3, [fp, #-12]
        /* PCB bound to current local interface address? */
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
  120418:	e51b3008 	ldr	r3, [fp, #-8]
  12041c:	e5932000 	ldr	r2, [r3]
  120420:	e51b3010 	ldr	r3, [fp, #-16]
  120424:	e5933000 	ldr	r3, [r3]
  120428:	e1520003 	cmp	r2, r3
  12042c:	1a000003 	bne	120440 <tcp_netif_ip_addr_changed+0xc4>
          /* The PCB is listening to the old ipaddr and
            * is set to listen to the new one instead */
          ip_addr_copy(lpcb->local_ip, *new_addr);
  120430:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120434:	e5932000 	ldr	r2, [r3]
  120438:	e51b3008 	ldr	r3, [fp, #-8]
  12043c:	e5832000 	str	r2, [r3]
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
  120440:	e51b300c 	ldr	r3, [fp, #-12]
  120444:	e50b3008 	str	r3, [fp, #-8]
  120448:	e51b3008 	ldr	r3, [fp, #-8]
  12044c:	e3530000 	cmp	r3, #0
  120450:	1affffed 	bne	12040c <tcp_netif_ip_addr_changed+0x90>
        }
      }
    }
  }
}
  120454:	e320f000 	nop	{0}
  120458:	e24bd004 	sub	sp, fp, #4
  12045c:	e8bd8800 	pop	{fp, pc}

00120460 <tcp_debug_state_str>:

const char*
tcp_debug_state_str(enum tcp_state s)
{
  120460:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  120464:	e28db000 	add	fp, sp, #0
  120468:	e24dd00c 	sub	sp, sp, #12
  12046c:	e50b0008 	str	r0, [fp, #-8]
  return tcp_state_str[s];
  120470:	e3083094 	movw	r3, #32916	; 0x8094
  120474:	e3403014 	movt	r3, #20
  120478:	e51b2008 	ldr	r2, [fp, #-8]
  12047c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
}
  120480:	e1a00003 	mov	r0, r3
  120484:	e28bd000 	add	sp, fp, #0
  120488:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  12048c:	e12fff1e 	bx	lr

00120490 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the TCP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  120490:	e92d4810 	push	{r4, fp, lr}
  120494:	e28db008 	add	fp, sp, #8
  120498:	e24dd034 	sub	sp, sp, #52	; 0x34
  12049c:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  1204a0:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
#if SO_REUSE
  struct tcp_pcb *lpcb_prev = NULL;
  1204a4:	e3a03000 	mov	r3, #0
  1204a8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  struct tcp_pcb_listen *lpcb_any = NULL;
  1204ac:	e3a03000 	mov	r3, #0
  1204b0:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

  LWIP_UNUSED_ARG(inp);

  PERF_START;

  TCP_STATS_INC(tcp.recv);
  1204b4:	e3063840 	movw	r3, #26688	; 0x6840
  1204b8:	e3403057 	movt	r3, #87	; 0x57
  1204bc:	e1d33abe 	ldrh	r3, [r3, #174]	; 0xae
  1204c0:	e2833001 	add	r3, r3, #1
  1204c4:	e6ff2073 	uxth	r2, r3
  1204c8:	e3063840 	movw	r3, #26688	; 0x6840
  1204cc:	e3403057 	movt	r3, #87	; 0x57
  1204d0:	e1c32abe 	strh	r2, [r3, #174]	; 0xae
  MIB2_STATS_INC(mib2.tcpinsegs);
  1204d4:	e3063840 	movw	r3, #26688	; 0x6840
  1204d8:	e3403057 	movt	r3, #87	; 0x57
  1204dc:	e5933184 	ldr	r3, [r3, #388]	; 0x184
  1204e0:	e2832001 	add	r2, r3, #1
  1204e4:	e3063840 	movw	r3, #26688	; 0x6840
  1204e8:	e3403057 	movt	r3, #87	; 0x57
  1204ec:	e5832184 	str	r2, [r3, #388]	; 0x184

  tcphdr = (struct tcp_hdr *)p->payload;
  1204f0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1204f4:	e5932004 	ldr	r2, [r3, #4]
  1204f8:	e30f3230 	movw	r3, #62000	; 0xf230
  1204fc:	e3403014 	movt	r3, #20
  120500:	e5832000 	str	r2, [r3]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* Check that TCP header fits in payload */
  if (p->len < TCP_HLEN) {
  120504:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120508:	e1d330ba 	ldrh	r3, [r3, #10]
  12050c:	e3530013 	cmp	r3, #19
  120510:	8a000008 	bhi	120538 <tcp_input+0xa8>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
  120514:	e3063840 	movw	r3, #26688	; 0x6840
  120518:	e3403057 	movt	r3, #87	; 0x57
  12051c:	e1d33bb6 	ldrh	r3, [r3, #182]	; 0xb6
  120520:	e2833001 	add	r3, r3, #1
  120524:	e6ff2073 	uxth	r2, r3
  120528:	e3063840 	movw	r3, #26688	; 0x6840
  12052c:	e3403057 	movt	r3, #87	; 0x57
  120530:	e1c32bb6 	strh	r2, [r3, #182]	; 0xb6
    goto dropped;
  120534:	ea0003d2 	b	121484 <tcp_input+0xff4>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
  120538:	e30035e8 	movw	r3, #1512	; 0x5e8
  12053c:	e3403015 	movt	r3, #21
  120540:	e5932014 	ldr	r2, [r3, #20]
  120544:	e30035e8 	movw	r3, #1512	; 0x5e8
  120548:	e3403015 	movt	r3, #21
  12054c:	e5933000 	ldr	r3, [r3]
  120550:	e1a01003 	mov	r1, r3
  120554:	e1a00002 	mov	r0, r2
  120558:	eb00486b 	bl	13270c <ip4_addr_isbroadcast_u32>
  12055c:	e1a03000 	mov	r3, r0
  120560:	e3530000 	cmp	r3, #0
  120564:	1a000005 	bne	120580 <tcp_input+0xf0>
      ip_addr_ismulticast(ip_current_dest_addr())) {
  120568:	e30035e8 	movw	r3, #1512	; 0x5e8
  12056c:	e3403015 	movt	r3, #21
  120570:	e5933014 	ldr	r3, [r3, #20]
  120574:	e20330f0 	and	r3, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
  120578:	e35300e0 	cmp	r3, #224	; 0xe0
  12057c:	1a000008 	bne	1205a4 <tcp_input+0x114>
    TCP_STATS_INC(tcp.proterr);
  120580:	e3063840 	movw	r3, #26688	; 0x6840
  120584:	e3403057 	movt	r3, #87	; 0x57
  120588:	e1d33bbc 	ldrh	r3, [r3, #188]	; 0xbc
  12058c:	e2833001 	add	r3, r3, #1
  120590:	e6ff2073 	uxth	r2, r3
  120594:	e3063840 	movw	r3, #26688	; 0x6840
  120598:	e3403057 	movt	r3, #87	; 0x57
  12059c:	e1c32bbc 	strh	r2, [r3, #188]	; 0xbc
    goto dropped;
  1205a0:	ea0003b7 	b	121484 <tcp_input+0xff4>
  }

#if CHECKSUM_CHECK_TCP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
    /* Verify TCP checksum. */
    u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
  1205a4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1205a8:	e1d320b8 	ldrh	r2, [r3, #8]
  1205ac:	e59f3f24 	ldr	r3, [pc, #3876]	; 1214d8 <tcp_input+0x1048>
  1205b0:	e58d3000 	str	r3, [sp]
  1205b4:	e59f3f20 	ldr	r3, [pc, #3872]	; 1214dc <tcp_input+0x104c>
  1205b8:	e3a01006 	mov	r1, #6
  1205bc:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  1205c0:	ebffe0a3 	bl	118854 <ip_chksum_pseudo>
  1205c4:	e1a03000 	mov	r3, r0
  1205c8:	e14b32b4 	strh	r3, [fp, #-36]	; 0xffffffdc
                               ip_current_src_addr(), ip_current_dest_addr());
    if (chksum != 0) {
  1205cc:	e15b32b4 	ldrh	r3, [fp, #-36]	; 0xffffffdc
  1205d0:	e3530000 	cmp	r3, #0
  1205d4:	0a000008 	beq	1205fc <tcp_input+0x16c>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
          chksum));
      tcp_debug_print(tcphdr);
      TCP_STATS_INC(tcp.chkerr);
  1205d8:	e3063840 	movw	r3, #26688	; 0x6840
  1205dc:	e3403057 	movt	r3, #87	; 0x57
  1205e0:	e1d33bb4 	ldrh	r3, [r3, #180]	; 0xb4
  1205e4:	e2833001 	add	r3, r3, #1
  1205e8:	e6ff2073 	uxth	r2, r3
  1205ec:	e3063840 	movw	r3, #26688	; 0x6840
  1205f0:	e3403057 	movt	r3, #87	; 0x57
  1205f4:	e1c32bb4 	strh	r2, [r3, #180]	; 0xb4
      goto dropped;
  1205f8:	ea0003a1 	b	121484 <tcp_input+0xff4>
    }
  }
#endif /* CHECKSUM_CHECK_TCP */

  /* sanity-check header length */
  hdrlen_bytes = TCPH_HDRLEN(tcphdr) * 4;
  1205fc:	e30f3230 	movw	r3, #62000	; 0xf230
  120600:	e3403014 	movt	r3, #20
  120604:	e5933000 	ldr	r3, [r3]
  120608:	e1d330bc 	ldrh	r3, [r3, #12]
  12060c:	e6ff3073 	uxth	r3, r3
  120610:	e1a00003 	mov	r0, r3
  120614:	ebffd86f 	bl	1167d8 <lwip_htons>
  120618:	e1a03000 	mov	r3, r0
  12061c:	e1a03623 	lsr	r3, r3, #12
  120620:	e6ff3073 	uxth	r3, r3
  120624:	e6ef3073 	uxtb	r3, r3
  120628:	e1a03103 	lsl	r3, r3, #2
  12062c:	e54b3025 	strb	r3, [fp, #-37]	; 0xffffffdb
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
  120630:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
  120634:	e3530013 	cmp	r3, #19
  120638:	9a000005 	bls	120654 <tcp_input+0x1c4>
  12063c:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
  120640:	e6ff2073 	uxth	r2, r3
  120644:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120648:	e1d330b8 	ldrh	r3, [r3, #8]
  12064c:	e1520003 	cmp	r2, r3
  120650:	9a000008 	bls	120678 <tcp_input+0x1e8>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_bytes));
    TCP_STATS_INC(tcp.lenerr);
  120654:	e3063840 	movw	r3, #26688	; 0x6840
  120658:	e3403057 	movt	r3, #87	; 0x57
  12065c:	e1d33bb6 	ldrh	r3, [r3, #182]	; 0xb6
  120660:	e2833001 	add	r3, r3, #1
  120664:	e6ff2073 	uxth	r2, r3
  120668:	e3063840 	movw	r3, #26688	; 0x6840
  12066c:	e3403057 	movt	r3, #87	; 0x57
  120670:	e1c32bb6 	strh	r2, [r3, #182]	; 0xb6
    goto dropped;
  120674:	ea000382 	b	121484 <tcp_input+0xff4>
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;
  120678:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
  12067c:	e6ff3073 	uxth	r3, r3
  120680:	e2433014 	sub	r3, r3, #20
  120684:	e6ff2073 	uxth	r2, r3
  120688:	e30f3234 	movw	r3, #62004	; 0xf234
  12068c:	e3403014 	movt	r3, #20
  120690:	e1c320b0 	strh	r2, [r3]
  tcphdr_opt2 = NULL;
  120694:	e30f3238 	movw	r3, #62008	; 0xf238
  120698:	e3403014 	movt	r3, #20
  12069c:	e3a02000 	mov	r2, #0
  1206a0:	e5832000 	str	r2, [r3]
  if (p->len >= hdrlen_bytes) {
  1206a4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1206a8:	e1d320ba 	ldrh	r2, [r3, #10]
  1206ac:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
  1206b0:	e6ff3073 	uxth	r3, r3
  1206b4:	e1520003 	cmp	r2, r3
  1206b8:	3a00000e 	bcc	1206f8 <tcp_input+0x268>
    /* all options are in the first pbuf */
    tcphdr_opt1len = tcphdr_optlen;
  1206bc:	e30f3234 	movw	r3, #62004	; 0xf234
  1206c0:	e3403014 	movt	r3, #20
  1206c4:	e1d320b0 	ldrh	r2, [r3]
  1206c8:	e30f3236 	movw	r3, #62006	; 0xf236
  1206cc:	e3403014 	movt	r3, #20
  1206d0:	e1c320b0 	strh	r2, [r3]
    pbuf_header(p, -(s16_t)hdrlen_bytes); /* cannot fail */
  1206d4:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
  1206d8:	e6ff3073 	uxth	r3, r3
  1206dc:	e2633000 	rsb	r3, r3, #0
  1206e0:	e6ff3073 	uxth	r3, r3
  1206e4:	e6bf3073 	sxth	r3, r3
  1206e8:	e1a01003 	mov	r1, r3
  1206ec:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  1206f0:	ebffea51 	bl	11b03c <pbuf_header>
  1206f4:	ea000061 	b	120880 <tcp_input+0x3f0>
  } else {
    u16_t opt2len;
    /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
    /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
  1206f8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1206fc:	e5933000 	ldr	r3, [r3]
  120700:	e3530000 	cmp	r3, #0
  120704:	1a000006 	bne	120724 <tcp_input+0x294>
  120708:	e30804c0 	movw	r0, #33984	; 0x84c0
  12070c:	e3400014 	movt	r0, #20
  120710:	ebff8a7f 	bl	103114 <rt_kprintf>
  120714:	e3a010b0 	mov	r1, #176	; 0xb0
  120718:	e30804d0 	movw	r0, #34000	; 0x84d0
  12071c:	e3400014 	movt	r0, #20
  120720:	ebffaa55 	bl	10b07c <sys_arch_assert>

    /* advance over the TCP header (cannot fail) */
    pbuf_header(p, -TCP_HLEN);
  120724:	e3e01013 	mvn	r1, #19
  120728:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  12072c:	ebffea42 	bl	11b03c <pbuf_header>

    /* determine how long the first and second parts of the options are */
    tcphdr_opt1len = p->len;
  120730:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120734:	e1d320ba 	ldrh	r2, [r3, #10]
  120738:	e30f3236 	movw	r3, #62006	; 0xf236
  12073c:	e3403014 	movt	r3, #20
  120740:	e1c320b0 	strh	r2, [r3]
    opt2len = tcphdr_optlen - tcphdr_opt1len;
  120744:	e30f3234 	movw	r3, #62004	; 0xf234
  120748:	e3403014 	movt	r3, #20
  12074c:	e1d320b0 	ldrh	r2, [r3]
  120750:	e30f3236 	movw	r3, #62006	; 0xf236
  120754:	e3403014 	movt	r3, #20
  120758:	e1d330b0 	ldrh	r3, [r3]
  12075c:	e0423003 	sub	r3, r2, r3
  120760:	e14b32b8 	strh	r3, [fp, #-40]	; 0xffffffd8

    /* options continue in the next pbuf: set p to zero length and hide the
        options in the next pbuf (adjusting p->tot_len) */
    pbuf_header(p, -(s16_t)tcphdr_opt1len);
  120764:	e30f3236 	movw	r3, #62006	; 0xf236
  120768:	e3403014 	movt	r3, #20
  12076c:	e1d330b0 	ldrh	r3, [r3]
  120770:	e2633000 	rsb	r3, r3, #0
  120774:	e6ff3073 	uxth	r3, r3
  120778:	e6bf3073 	sxth	r3, r3
  12077c:	e1a01003 	mov	r1, r3
  120780:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  120784:	ebffea2c 	bl	11b03c <pbuf_header>

    /* check that the options fit in the second pbuf */
    if (opt2len > p->next->len) {
  120788:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12078c:	e5933000 	ldr	r3, [r3]
  120790:	e1d330ba 	ldrh	r3, [r3, #10]
  120794:	e15b22b8 	ldrh	r2, [fp, #-40]	; 0xffffffd8
  120798:	e1520003 	cmp	r2, r3
  12079c:	9a000008 	bls	1207c4 <tcp_input+0x334>
      /* drop short packets */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: options overflow second pbuf (%"U16_F" bytes)\n", p->next->len));
      TCP_STATS_INC(tcp.lenerr);
  1207a0:	e3063840 	movw	r3, #26688	; 0x6840
  1207a4:	e3403057 	movt	r3, #87	; 0x57
  1207a8:	e1d33bb6 	ldrh	r3, [r3, #182]	; 0xb6
  1207ac:	e2833001 	add	r3, r3, #1
  1207b0:	e6ff2073 	uxth	r2, r3
  1207b4:	e3063840 	movw	r3, #26688	; 0x6840
  1207b8:	e3403057 	movt	r3, #87	; 0x57
  1207bc:	e1c32bb6 	strh	r2, [r3, #182]	; 0xb6
      goto dropped;
  1207c0:	ea00032f 	b	121484 <tcp_input+0xff4>
    }

    /* remember the pointer to the second part of the options */
    tcphdr_opt2 = (u8_t*)p->next->payload;
  1207c4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1207c8:	e5933000 	ldr	r3, [r3]
  1207cc:	e5932004 	ldr	r2, [r3, #4]
  1207d0:	e30f3238 	movw	r3, #62008	; 0xf238
  1207d4:	e3403014 	movt	r3, #20
  1207d8:	e5832000 	str	r2, [r3]

    /* advance p->next to point after the options, and manually
        adjust p->tot_len to keep it consistent with the changed p->next */
    pbuf_header(p->next, -(s16_t)opt2len);
  1207dc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1207e0:	e5932000 	ldr	r2, [r3]
  1207e4:	e15b32b8 	ldrh	r3, [fp, #-40]	; 0xffffffd8
  1207e8:	e2633000 	rsb	r3, r3, #0
  1207ec:	e6ff3073 	uxth	r3, r3
  1207f0:	e6bf3073 	sxth	r3, r3
  1207f4:	e1a01003 	mov	r1, r3
  1207f8:	e1a00002 	mov	r0, r2
  1207fc:	ebffea0e 	bl	11b03c <pbuf_header>
    p->tot_len -= opt2len;
  120800:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120804:	e1d320b8 	ldrh	r2, [r3, #8]
  120808:	e15b32b8 	ldrh	r3, [fp, #-40]	; 0xffffffd8
  12080c:	e0423003 	sub	r3, r2, r3
  120810:	e6ff2073 	uxth	r2, r3
  120814:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120818:	e1c320b8 	strh	r2, [r3, #8]

    LWIP_ASSERT("p->len == 0", p->len == 0);
  12081c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120820:	e1d330ba 	ldrh	r3, [r3, #10]
  120824:	e3530000 	cmp	r3, #0
  120828:	0a000006 	beq	120848 <tcp_input+0x3b8>
  12082c:	e3080500 	movw	r0, #34048	; 0x8500
  120830:	e3400014 	movt	r0, #20
  120834:	ebff8a36 	bl	103114 <rt_kprintf>
  120838:	e3a010cd 	mov	r1, #205	; 0xcd
  12083c:	e30804d0 	movw	r0, #34000	; 0x84d0
  120840:	e3400014 	movt	r0, #20
  120844:	ebffaa0c 	bl	10b07c <sys_arch_assert>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
  120848:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12084c:	e1d320b8 	ldrh	r2, [r3, #8]
  120850:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120854:	e5933000 	ldr	r3, [r3]
  120858:	e1d330b8 	ldrh	r3, [r3, #8]
  12085c:	e1520003 	cmp	r2, r3
  120860:	0a000006 	beq	120880 <tcp_input+0x3f0>
  120864:	e308050c 	movw	r0, #34060	; 0x850c
  120868:	e3400014 	movt	r0, #20
  12086c:	ebff8a28 	bl	103114 <rt_kprintf>
  120870:	e3a010ce 	mov	r1, #206	; 0xce
  120874:	e30804d0 	movw	r0, #34000	; 0x84d0
  120878:	e3400014 	movt	r0, #20
  12087c:	ebffa9fe 	bl	10b07c <sys_arch_assert>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = lwip_ntohs(tcphdr->src);
  120880:	e30f3230 	movw	r3, #62000	; 0xf230
  120884:	e3403014 	movt	r3, #20
  120888:	e5933000 	ldr	r3, [r3]
  12088c:	e1d330b0 	ldrh	r3, [r3]
  120890:	e6ff2073 	uxth	r2, r3
  120894:	e30f3230 	movw	r3, #62000	; 0xf230
  120898:	e3403014 	movt	r3, #20
  12089c:	e5934000 	ldr	r4, [r3]
  1208a0:	e1a00002 	mov	r0, r2
  1208a4:	ebffd7cb 	bl	1167d8 <lwip_htons>
  1208a8:	e1a03000 	mov	r3, r0
  1208ac:	e1c430b0 	strh	r3, [r4]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
  1208b0:	e30f3230 	movw	r3, #62000	; 0xf230
  1208b4:	e3403014 	movt	r3, #20
  1208b8:	e5933000 	ldr	r3, [r3]
  1208bc:	e1d330b2 	ldrh	r3, [r3, #2]
  1208c0:	e6ff2073 	uxth	r2, r3
  1208c4:	e30f3230 	movw	r3, #62000	; 0xf230
  1208c8:	e3403014 	movt	r3, #20
  1208cc:	e5934000 	ldr	r4, [r3]
  1208d0:	e1a00002 	mov	r0, r2
  1208d4:	ebffd7bf 	bl	1167d8 <lwip_htons>
  1208d8:	e1a03000 	mov	r3, r0
  1208dc:	e1c430b2 	strh	r3, [r4, #2]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
  1208e0:	e30f3230 	movw	r3, #62000	; 0xf230
  1208e4:	e3403014 	movt	r3, #20
  1208e8:	e5933000 	ldr	r3, [r3]
  1208ec:	e5932004 	ldr	r2, [r3, #4]
  1208f0:	e30f3230 	movw	r3, #62000	; 0xf230
  1208f4:	e3403014 	movt	r3, #20
  1208f8:	e5934000 	ldr	r4, [r3]
  1208fc:	e1a00002 	mov	r0, r2
  120900:	ebffd7c0 	bl	116808 <lwip_htonl>
  120904:	e1a03000 	mov	r3, r0
  120908:	e5843004 	str	r3, [r4, #4]
  12090c:	e5942004 	ldr	r2, [r4, #4]
  120910:	e30f3240 	movw	r3, #62016	; 0xf240
  120914:	e3403014 	movt	r3, #20
  120918:	e5832000 	str	r2, [r3]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
  12091c:	e30f3230 	movw	r3, #62000	; 0xf230
  120920:	e3403014 	movt	r3, #20
  120924:	e5933000 	ldr	r3, [r3]
  120928:	e5932008 	ldr	r2, [r3, #8]
  12092c:	e30f3230 	movw	r3, #62000	; 0xf230
  120930:	e3403014 	movt	r3, #20
  120934:	e5934000 	ldr	r4, [r3]
  120938:	e1a00002 	mov	r0, r2
  12093c:	ebffd7b1 	bl	116808 <lwip_htonl>
  120940:	e1a03000 	mov	r3, r0
  120944:	e5843008 	str	r3, [r4, #8]
  120948:	e5942008 	ldr	r2, [r4, #8]
  12094c:	e30f3244 	movw	r3, #62020	; 0xf244
  120950:	e3403014 	movt	r3, #20
  120954:	e5832000 	str	r2, [r3]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
  120958:	e30f3230 	movw	r3, #62000	; 0xf230
  12095c:	e3403014 	movt	r3, #20
  120960:	e5933000 	ldr	r3, [r3]
  120964:	e1d330be 	ldrh	r3, [r3, #14]
  120968:	e6ff2073 	uxth	r2, r3
  12096c:	e30f3230 	movw	r3, #62000	; 0xf230
  120970:	e3403014 	movt	r3, #20
  120974:	e5934000 	ldr	r4, [r3]
  120978:	e1a00002 	mov	r0, r2
  12097c:	ebffd795 	bl	1167d8 <lwip_htons>
  120980:	e1a03000 	mov	r3, r0
  120984:	e1c430be 	strh	r3, [r4, #14]

  flags = TCPH_FLAGS(tcphdr);
  120988:	e30f3230 	movw	r3, #62000	; 0xf230
  12098c:	e3403014 	movt	r3, #20
  120990:	e5933000 	ldr	r3, [r3]
  120994:	e1d330bc 	ldrh	r3, [r3, #12]
  120998:	e6ff3073 	uxth	r3, r3
  12099c:	e1a00003 	mov	r0, r3
  1209a0:	ebffd78c 	bl	1167d8 <lwip_htons>
  1209a4:	e1a03000 	mov	r3, r0
  1209a8:	e6ef3073 	uxtb	r3, r3
  1209ac:	e203303f 	and	r3, r3, #63	; 0x3f
  1209b0:	e6ef2073 	uxtb	r2, r3
  1209b4:	e30f324c 	movw	r3, #62028	; 0xf24c
  1209b8:	e3403014 	movt	r3, #20
  1209bc:	e5c32000 	strb	r2, [r3]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
  1209c0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1209c4:	e1d320b8 	ldrh	r2, [r3, #8]
  1209c8:	e30f324c 	movw	r3, #62028	; 0xf24c
  1209cc:	e3403014 	movt	r3, #20
  1209d0:	e5d33000 	ldrb	r3, [r3]
  1209d4:	e2033003 	and	r3, r3, #3
  1209d8:	e3530000 	cmp	r3, #0
  1209dc:	13a03001 	movne	r3, #1
  1209e0:	03a03000 	moveq	r3, #0
  1209e4:	e6ef3073 	uxtb	r3, r3
  1209e8:	e6ff3073 	uxth	r3, r3
  1209ec:	e0823003 	add	r3, r2, r3
  1209f0:	e6ff2073 	uxth	r2, r3
  1209f4:	e30f324a 	movw	r3, #62026	; 0xf24a
  1209f8:	e3403014 	movt	r3, #20
  1209fc:	e1c320b0 	strh	r2, [r3]

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  120a00:	e3a03000 	mov	r3, #0
  120a04:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  120a08:	e3063a30 	movw	r3, #27184	; 0x6a30
  120a0c:	e3403057 	movt	r3, #87	; 0x57
  120a10:	e5933000 	ldr	r3, [r3]
  120a14:	e50b3010 	str	r3, [fp, #-16]
  120a18:	ea000077 	b	120bfc <tcp_input+0x76c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  120a1c:	e51b3010 	ldr	r3, [fp, #-16]
  120a20:	e5933014 	ldr	r3, [r3, #20]
  120a24:	e3530000 	cmp	r3, #0
  120a28:	1a000006 	bne	120a48 <tcp_input+0x5b8>
  120a2c:	e308052c 	movw	r0, #34092	; 0x852c
  120a30:	e3400014 	movt	r0, #20
  120a34:	ebff89b6 	bl	103114 <rt_kprintf>
  120a38:	e3a010e0 	mov	r1, #224	; 0xe0
  120a3c:	e30804d0 	movw	r0, #34000	; 0x84d0
  120a40:	e3400014 	movt	r0, #20
  120a44:	ebffa98c 	bl	10b07c <sys_arch_assert>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  120a48:	e51b3010 	ldr	r3, [fp, #-16]
  120a4c:	e5933014 	ldr	r3, [r3, #20]
  120a50:	e353000a 	cmp	r3, #10
  120a54:	1a000006 	bne	120a74 <tcp_input+0x5e4>
  120a58:	e3080554 	movw	r0, #34132	; 0x8554
  120a5c:	e3400014 	movt	r0, #20
  120a60:	ebff89ab 	bl	103114 <rt_kprintf>
  120a64:	e3a010e1 	mov	r1, #225	; 0xe1
  120a68:	e30804d0 	movw	r0, #34000	; 0x84d0
  120a6c:	e3400014 	movt	r0, #20
  120a70:	ebffa981 	bl	10b07c <sys_arch_assert>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  120a74:	e51b3010 	ldr	r3, [fp, #-16]
  120a78:	e5933014 	ldr	r3, [r3, #20]
  120a7c:	e3530001 	cmp	r3, #1
  120a80:	1a000006 	bne	120aa0 <tcp_input+0x610>
  120a84:	e3080580 	movw	r0, #34176	; 0x8580
  120a88:	e3400014 	movt	r0, #20
  120a8c:	ebff89a0 	bl	103114 <rt_kprintf>
  120a90:	e3a010e2 	mov	r1, #226	; 0xe2
  120a94:	e30804d0 	movw	r0, #34000	; 0x84d0
  120a98:	e3400014 	movt	r0, #20
  120a9c:	ebffa976 	bl	10b07c <sys_arch_assert>
    if (pcb->remote_port == tcphdr->src &&
  120aa0:	e51b3010 	ldr	r3, [fp, #-16]
  120aa4:	e1d321bc 	ldrh	r2, [r3, #28]
  120aa8:	e30f3230 	movw	r3, #62000	; 0xf230
  120aac:	e3403014 	movt	r3, #20
  120ab0:	e5933000 	ldr	r3, [r3]
  120ab4:	e1d330b0 	ldrh	r3, [r3]
  120ab8:	e6ff3073 	uxth	r3, r3
  120abc:	e1520003 	cmp	r2, r3
  120ac0:	1a000048 	bne	120be8 <tcp_input+0x758>
        pcb->local_port == tcphdr->dest &&
  120ac4:	e51b3010 	ldr	r3, [fp, #-16]
  120ac8:	e1d321ba 	ldrh	r2, [r3, #26]
  120acc:	e30f3230 	movw	r3, #62000	; 0xf230
  120ad0:	e3403014 	movt	r3, #20
  120ad4:	e5933000 	ldr	r3, [r3]
  120ad8:	e1d330b2 	ldrh	r3, [r3, #2]
  120adc:	e6ff3073 	uxth	r3, r3
    if (pcb->remote_port == tcphdr->src &&
  120ae0:	e1520003 	cmp	r2, r3
  120ae4:	1a00003f 	bne	120be8 <tcp_input+0x758>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
  120ae8:	e51b3010 	ldr	r3, [fp, #-16]
  120aec:	e5932004 	ldr	r2, [r3, #4]
  120af0:	e30035e8 	movw	r3, #1512	; 0x5e8
  120af4:	e3403015 	movt	r3, #21
  120af8:	e5933010 	ldr	r3, [r3, #16]
        pcb->local_port == tcphdr->dest &&
  120afc:	e1520003 	cmp	r2, r3
  120b00:	1a000038 	bne	120be8 <tcp_input+0x758>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
  120b04:	e51b3010 	ldr	r3, [fp, #-16]
  120b08:	e5932000 	ldr	r2, [r3]
  120b0c:	e30035e8 	movw	r3, #1512	; 0x5e8
  120b10:	e3403015 	movt	r3, #21
  120b14:	e5933014 	ldr	r3, [r3, #20]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
  120b18:	e1520003 	cmp	r2, r3
  120b1c:	1a000031 	bne	120be8 <tcp_input+0x758>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  120b20:	e51b3010 	ldr	r3, [fp, #-16]
  120b24:	e593300c 	ldr	r3, [r3, #12]
  120b28:	e51b2010 	ldr	r2, [fp, #-16]
  120b2c:	e1520003 	cmp	r2, r3
  120b30:	1a000006 	bne	120b50 <tcp_input+0x6c0>
  120b34:	e30805a8 	movw	r0, #34216	; 0x85a8
  120b38:	e3400014 	movt	r0, #20
  120b3c:	ebff8974 	bl	103114 <rt_kprintf>
  120b40:	e3a010ea 	mov	r1, #234	; 0xea
  120b44:	e30804d0 	movw	r0, #34000	; 0x84d0
  120b48:	e3400014 	movt	r0, #20
  120b4c:	ebffa94a 	bl	10b07c <sys_arch_assert>
      if (prev != NULL) {
  120b50:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120b54:	e3530000 	cmp	r3, #0
  120b58:	0a00000d 	beq	120b94 <tcp_input+0x704>
        prev->next = pcb->next;
  120b5c:	e51b3010 	ldr	r3, [fp, #-16]
  120b60:	e593200c 	ldr	r2, [r3, #12]
  120b64:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120b68:	e583200c 	str	r2, [r3, #12]
        pcb->next = tcp_active_pcbs;
  120b6c:	e3063a30 	movw	r3, #27184	; 0x6a30
  120b70:	e3403057 	movt	r3, #87	; 0x57
  120b74:	e5932000 	ldr	r2, [r3]
  120b78:	e51b3010 	ldr	r3, [fp, #-16]
  120b7c:	e583200c 	str	r2, [r3, #12]
        tcp_active_pcbs = pcb;
  120b80:	e3063a30 	movw	r3, #27184	; 0x6a30
  120b84:	e3403057 	movt	r3, #87	; 0x57
  120b88:	e51b2010 	ldr	r2, [fp, #-16]
  120b8c:	e5832000 	str	r2, [r3]
  120b90:	ea000007 	b	120bb4 <tcp_input+0x724>
      } else {
        TCP_STATS_INC(tcp.cachehit);
  120b94:	e3063840 	movw	r3, #26688	; 0x6840
  120b98:	e3403057 	movt	r3, #87	; 0x57
  120b9c:	e1d33cb2 	ldrh	r3, [r3, #194]	; 0xc2
  120ba0:	e2833001 	add	r3, r3, #1
  120ba4:	e6ff2073 	uxth	r2, r3
  120ba8:	e3063840 	movw	r3, #26688	; 0x6840
  120bac:	e3403057 	movt	r3, #87	; 0x57
  120bb0:	e1c32cb2 	strh	r2, [r3, #194]	; 0xc2
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  120bb4:	e51b3010 	ldr	r3, [fp, #-16]
  120bb8:	e593300c 	ldr	r3, [r3, #12]
  120bbc:	e51b2010 	ldr	r2, [fp, #-16]
  120bc0:	e1520003 	cmp	r2, r3
  120bc4:	1a000010 	bne	120c0c <tcp_input+0x77c>
  120bc8:	e30805d4 	movw	r0, #34260	; 0x85d4
  120bcc:	e3400014 	movt	r0, #20
  120bd0:	ebff894f 	bl	103114 <rt_kprintf>
  120bd4:	e3a010f2 	mov	r1, #242	; 0xf2
  120bd8:	e30804d0 	movw	r0, #34000	; 0x84d0
  120bdc:	e3400014 	movt	r0, #20
  120be0:	ebffa925 	bl	10b07c <sys_arch_assert>
      break;
  120be4:	ea000008 	b	120c0c <tcp_input+0x77c>
    }
    prev = pcb;
  120be8:	e51b3010 	ldr	r3, [fp, #-16]
  120bec:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  120bf0:	e51b3010 	ldr	r3, [fp, #-16]
  120bf4:	e593300c 	ldr	r3, [r3, #12]
  120bf8:	e50b3010 	str	r3, [fp, #-16]
  120bfc:	e51b3010 	ldr	r3, [fp, #-16]
  120c00:	e3530000 	cmp	r3, #0
  120c04:	1affff84 	bne	120a1c <tcp_input+0x58c>
  120c08:	ea000000 	b	120c10 <tcp_input+0x780>
      break;
  120c0c:	e320f000 	nop	{0}
  }

  if (pcb == NULL) {
  120c10:	e51b3010 	ldr	r3, [fp, #-16]
  120c14:	e3530000 	cmp	r3, #0
  120c18:	1a00008e 	bne	120e58 <tcp_input+0x9c8>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  120c1c:	e3063a40 	movw	r3, #27200	; 0x6a40
  120c20:	e3403057 	movt	r3, #87	; 0x57
  120c24:	e5933000 	ldr	r3, [r3]
  120c28:	e50b3010 	str	r3, [fp, #-16]
  120c2c:	ea000032 	b	120cfc <tcp_input+0x86c>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  120c30:	e51b3010 	ldr	r3, [fp, #-16]
  120c34:	e5933014 	ldr	r3, [r3, #20]
  120c38:	e353000a 	cmp	r3, #10
  120c3c:	0a000006 	beq	120c5c <tcp_input+0x7cc>
  120c40:	e3080600 	movw	r0, #34304	; 0x8600
  120c44:	e3400014 	movt	r0, #20
  120c48:	ebff8931 	bl	103114 <rt_kprintf>
  120c4c:	e3a010fc 	mov	r1, #252	; 0xfc
  120c50:	e30804d0 	movw	r0, #34000	; 0x84d0
  120c54:	e3400014 	movt	r0, #20
  120c58:	ebffa907 	bl	10b07c <sys_arch_assert>
      if (pcb->remote_port == tcphdr->src &&
  120c5c:	e51b3010 	ldr	r3, [fp, #-16]
  120c60:	e1d321bc 	ldrh	r2, [r3, #28]
  120c64:	e30f3230 	movw	r3, #62000	; 0xf230
  120c68:	e3403014 	movt	r3, #20
  120c6c:	e5933000 	ldr	r3, [r3]
  120c70:	e1d330b0 	ldrh	r3, [r3]
  120c74:	e6ff3073 	uxth	r3, r3
  120c78:	e1520003 	cmp	r2, r3
  120c7c:	1a00001b 	bne	120cf0 <tcp_input+0x860>
          pcb->local_port == tcphdr->dest &&
  120c80:	e51b3010 	ldr	r3, [fp, #-16]
  120c84:	e1d321ba 	ldrh	r2, [r3, #26]
  120c88:	e30f3230 	movw	r3, #62000	; 0xf230
  120c8c:	e3403014 	movt	r3, #20
  120c90:	e5933000 	ldr	r3, [r3]
  120c94:	e1d330b2 	ldrh	r3, [r3, #2]
  120c98:	e6ff3073 	uxth	r3, r3
      if (pcb->remote_port == tcphdr->src &&
  120c9c:	e1520003 	cmp	r2, r3
  120ca0:	1a000012 	bne	120cf0 <tcp_input+0x860>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
  120ca4:	e51b3010 	ldr	r3, [fp, #-16]
  120ca8:	e5932004 	ldr	r2, [r3, #4]
  120cac:	e30035e8 	movw	r3, #1512	; 0x5e8
  120cb0:	e3403015 	movt	r3, #21
  120cb4:	e5933010 	ldr	r3, [r3, #16]
          pcb->local_port == tcphdr->dest &&
  120cb8:	e1520003 	cmp	r2, r3
  120cbc:	1a00000b 	bne	120cf0 <tcp_input+0x860>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
  120cc0:	e51b3010 	ldr	r3, [fp, #-16]
  120cc4:	e5932000 	ldr	r2, [r3]
  120cc8:	e30035e8 	movw	r3, #1512	; 0x5e8
  120ccc:	e3403015 	movt	r3, #21
  120cd0:	e5933014 	ldr	r3, [r3, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
  120cd4:	e1520003 	cmp	r2, r3
  120cd8:	1a000004 	bne	120cf0 <tcp_input+0x860>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  120cdc:	e51b0010 	ldr	r0, [fp, #-16]
  120ce0:	eb0002d8 	bl	121848 <tcp_timewait_input>
        pbuf_free(p);
  120ce4:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  120ce8:	ebffe8f1 	bl	11b0b4 <pbuf_free>
        return;
  120cec:	ea0001f7 	b	1214d0 <tcp_input+0x1040>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  120cf0:	e51b3010 	ldr	r3, [fp, #-16]
  120cf4:	e593300c 	ldr	r3, [r3, #12]
  120cf8:	e50b3010 	str	r3, [fp, #-16]
  120cfc:	e51b3010 	ldr	r3, [fp, #-16]
  120d00:	e3530000 	cmp	r3, #0
  120d04:	1affffc9 	bne	120c30 <tcp_input+0x7a0>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
  120d08:	e3a03000 	mov	r3, #0
  120d0c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  120d10:	e3063a38 	movw	r3, #27192	; 0x6a38
  120d14:	e3403057 	movt	r3, #87	; 0x57
  120d18:	e5933000 	ldr	r3, [r3]
  120d1c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  120d20:	ea00001f 	b	120da4 <tcp_input+0x914>
      if (lpcb->local_port == tcphdr->dest) {
  120d24:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120d28:	e1d321ba 	ldrh	r2, [r3, #26]
  120d2c:	e30f3230 	movw	r3, #62000	; 0xf230
  120d30:	e3403014 	movt	r3, #20
  120d34:	e5933000 	ldr	r3, [r3]
  120d38:	e1d330b2 	ldrh	r3, [r3, #2]
  120d3c:	e6ff3073 	uxth	r3, r3
  120d40:	e1520003 	cmp	r2, r3
  120d44:	1a000011 	bne	120d90 <tcp_input+0x900>
          lpcb_prev = prev;
#else /* SO_REUSE */
          break;
#endif /* SO_REUSE */
        } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
  120d48:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120d4c:	e5932000 	ldr	r2, [r3]
  120d50:	e30035e8 	movw	r3, #1512	; 0x5e8
  120d54:	e3403015 	movt	r3, #21
  120d58:	e5933014 	ldr	r3, [r3, #20]
  120d5c:	e1520003 	cmp	r2, r3
  120d60:	0a000013 	beq	120db4 <tcp_input+0x924>
            /* found an exact match */
            break;
          } else if (ip_addr_isany(&lpcb->local_ip)) {
  120d64:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120d68:	e3530000 	cmp	r3, #0
  120d6c:	0a000003 	beq	120d80 <tcp_input+0x8f0>
  120d70:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120d74:	e5933000 	ldr	r3, [r3]
  120d78:	e3530000 	cmp	r3, #0
  120d7c:	1a000003 	bne	120d90 <tcp_input+0x900>
            /* found an ANY-match */
#if SO_REUSE
            lpcb_any = lpcb;
  120d80:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120d84:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
            lpcb_prev = prev;
  120d88:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120d8c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
            break;
 #endif /* SO_REUSE */
          }
        }
      }
      prev = (struct tcp_pcb *)lpcb;
  120d90:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120d94:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  120d98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120d9c:	e593300c 	ldr	r3, [r3, #12]
  120da0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  120da4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120da8:	e3530000 	cmp	r3, #0
  120dac:	1affffdc 	bne	120d24 <tcp_input+0x894>
  120db0:	ea000000 	b	120db8 <tcp_input+0x928>
            break;
  120db4:	e320f000 	nop	{0}
    }
#if SO_REUSE
    /* first try specific local IP */
    if (lpcb == NULL) {
  120db8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120dbc:	e3530000 	cmp	r3, #0
  120dc0:	1a000003 	bne	120dd4 <tcp_input+0x944>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
  120dc4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  120dc8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
      prev = lpcb_prev;
  120dcc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  120dd0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
  120dd4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120dd8:	e3530000 	cmp	r3, #0
  120ddc:	0a00001d 	beq	120e58 <tcp_input+0x9c8>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
  120de0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120de4:	e3530000 	cmp	r3, #0
  120de8:	0a00000d 	beq	120e24 <tcp_input+0x994>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  120dec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120df0:	e593200c 	ldr	r2, [r3, #12]
  120df4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  120df8:	e583200c 	str	r2, [r3, #12]
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
  120dfc:	e3063a38 	movw	r3, #27192	; 0x6a38
  120e00:	e3403057 	movt	r3, #87	; 0x57
  120e04:	e5932000 	ldr	r2, [r3]
  120e08:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  120e0c:	e583200c 	str	r2, [r3, #12]
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
  120e10:	e3063a38 	movw	r3, #27192	; 0x6a38
  120e14:	e3403057 	movt	r3, #87	; 0x57
  120e18:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  120e1c:	e5832000 	str	r2, [r3]
  120e20:	ea000007 	b	120e44 <tcp_input+0x9b4>
      } else {
        TCP_STATS_INC(tcp.cachehit);
  120e24:	e3063840 	movw	r3, #26688	; 0x6840
  120e28:	e3403057 	movt	r3, #87	; 0x57
  120e2c:	e1d33cb2 	ldrh	r3, [r3, #194]	; 0xc2
  120e30:	e2833001 	add	r3, r3, #1
  120e34:	e6ff2073 	uxth	r2, r3
  120e38:	e3063840 	movw	r3, #26688	; 0x6840
  120e3c:	e3403057 	movt	r3, #87	; 0x57
  120e40:	e1c32cb2 	strh	r2, [r3, #194]	; 0xc2
      }

      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
      tcp_listen_input(lpcb);
  120e44:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  120e48:	eb0001a4 	bl	1214e0 <tcp_listen_input>
      pbuf_free(p);
  120e4c:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  120e50:	ebffe897 	bl	11b0b4 <pbuf_free>
      return;
  120e54:	ea00019d 	b	1214d0 <tcp_input+0x1040>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  120e58:	e51b3010 	ldr	r3, [fp, #-16]
  120e5c:	e3530000 	cmp	r3, #0
  120e60:	0a00014f 	beq	1213a4 <tcp_input+0xf14>
#if TCP_INPUT_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  120e64:	e30f3220 	movw	r3, #61984	; 0xf220
  120e68:	e3403014 	movt	r3, #20
  120e6c:	e3a02000 	mov	r2, #0
  120e70:	e5832000 	str	r2, [r3]
    inseg.len = p->tot_len;
  120e74:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120e78:	e1d320b8 	ldrh	r2, [r3, #8]
  120e7c:	e30f3220 	movw	r3, #61984	; 0xf220
  120e80:	e3403014 	movt	r3, #20
  120e84:	e1c320b8 	strh	r2, [r3, #8]
    inseg.p = p;
  120e88:	e30f3220 	movw	r3, #61984	; 0xf220
  120e8c:	e3403014 	movt	r3, #20
  120e90:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  120e94:	e5832004 	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
  120e98:	e30f3230 	movw	r3, #62000	; 0xf230
  120e9c:	e3403014 	movt	r3, #20
  120ea0:	e5932000 	ldr	r2, [r3]
  120ea4:	e30f3220 	movw	r3, #61984	; 0xf220
  120ea8:	e3403014 	movt	r3, #20
  120eac:	e583200c 	str	r2, [r3, #12]

    recv_data = NULL;
  120eb0:	e30f3250 	movw	r3, #62032	; 0xf250
  120eb4:	e3403014 	movt	r3, #20
  120eb8:	e3a02000 	mov	r2, #0
  120ebc:	e5832000 	str	r2, [r3]
    recv_flags = 0;
  120ec0:	e30f324d 	movw	r3, #62029	; 0xf24d
  120ec4:	e3403014 	movt	r3, #20
  120ec8:	e3a02000 	mov	r2, #0
  120ecc:	e5c32000 	strb	r2, [r3]
    recv_acked = 0;
  120ed0:	e30f3248 	movw	r3, #62024	; 0xf248
  120ed4:	e3403014 	movt	r3, #20
  120ed8:	e3a02000 	mov	r2, #0
  120edc:	e1c320b0 	strh	r2, [r3]

    if (flags & TCP_PSH) {
  120ee0:	e30f324c 	movw	r3, #62028	; 0xf24c
  120ee4:	e3403014 	movt	r3, #20
  120ee8:	e5d33000 	ldrb	r3, [r3]
  120eec:	e2033008 	and	r3, r3, #8
  120ef0:	e3530000 	cmp	r3, #0
  120ef4:	0a000005 	beq	120f10 <tcp_input+0xa80>
      p->flags |= PBUF_FLAG_PUSH;
  120ef8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120efc:	e5d3300d 	ldrb	r3, [r3, #13]
  120f00:	e3833001 	orr	r3, r3, #1
  120f04:	e6ef2073 	uxtb	r2, r3
  120f08:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  120f0c:	e5c3200d 	strb	r2, [r3, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  120f10:	e51b3010 	ldr	r3, [fp, #-16]
  120f14:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  120f18:	e3530000 	cmp	r3, #0
  120f1c:	0a000023 	beq	120fb0 <tcp_input+0xb20>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
  120f20:	e51b0010 	ldr	r0, [fp, #-16]
  120f24:	ebfff968 	bl	11f4cc <tcp_process_refused_data>
  120f28:	e1a03000 	mov	r3, r0
  120f2c:	e373000d 	cmn	r3, #13
  120f30:	0a000008 	beq	120f58 <tcp_input+0xac8>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
  120f34:	e51b3010 	ldr	r3, [fp, #-16]
  120f38:	e5933078 	ldr	r3, [r3, #120]	; 0x78
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
  120f3c:	e3530000 	cmp	r3, #0
  120f40:	0a00001a 	beq	120fb0 <tcp_input+0xb20>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
  120f44:	e30f324a 	movw	r3, #62026	; 0xf24a
  120f48:	e3403014 	movt	r3, #20
  120f4c:	e1d330b0 	ldrh	r3, [r3]
  120f50:	e3530000 	cmp	r3, #0
  120f54:	0a000015 	beq	120fb0 <tcp_input+0xb20>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        if (pcb->rcv_ann_wnd == 0) {
  120f58:	e51b3010 	ldr	r3, [fp, #-16]
  120f5c:	e1d332be 	ldrh	r3, [r3, #46]	; 0x2e
  120f60:	e3530000 	cmp	r3, #0
  120f64:	1a000001 	bne	120f70 <tcp_input+0xae0>
          /* this is a zero-window probe, we respond to it with current RCV.NXT
          and drop the data segment */
          tcp_send_empty_ack(pcb);
  120f68:	e51b0010 	ldr	r0, [fp, #-16]
  120f6c:	eb001419 	bl	125fd8 <tcp_send_empty_ack>
        }
        TCP_STATS_INC(tcp.drop);
  120f70:	e3063840 	movw	r3, #26688	; 0x6840
  120f74:	e3403057 	movt	r3, #87	; 0x57
  120f78:	e1d33bb2 	ldrh	r3, [r3, #178]	; 0xb2
  120f7c:	e2833001 	add	r3, r3, #1
  120f80:	e6ff2073 	uxth	r2, r3
  120f84:	e3063840 	movw	r3, #26688	; 0x6840
  120f88:	e3403057 	movt	r3, #87	; 0x57
  120f8c:	e1c32bb2 	strh	r2, [r3, #178]	; 0xb2
        MIB2_STATS_INC(mib2.tcpinerrs);
  120f90:	e3063840 	movw	r3, #26688	; 0x6840
  120f94:	e3403057 	movt	r3, #87	; 0x57
  120f98:	e5933188 	ldr	r3, [r3, #392]	; 0x188
  120f9c:	e2832001 	add	r2, r3, #1
  120fa0:	e3063840 	movw	r3, #26688	; 0x6840
  120fa4:	e3403057 	movt	r3, #87	; 0x57
  120fa8:	e5832188 	str	r2, [r3, #392]	; 0x188
        goto aborted;
  120fac:	ea0000e5 	b	121348 <tcp_input+0xeb8>
      }
    }
    tcp_input_pcb = pcb;
  120fb0:	e3063a44 	movw	r3, #27204	; 0x6a44
  120fb4:	e3403057 	movt	r3, #87	; 0x57
  120fb8:	e51b2010 	ldr	r2, [fp, #-16]
  120fbc:	e5832000 	str	r2, [r3]
    err = tcp_process(pcb);
  120fc0:	e51b0010 	ldr	r0, [fp, #-16]
  120fc4:	eb00027e 	bl	1219c4 <tcp_process>
  120fc8:	e1a03000 	mov	r3, r0
  120fcc:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  120fd0:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
  120fd4:	e373000d 	cmn	r3, #13
  120fd8:	0a0000d3 	beq	12132c <tcp_input+0xe9c>
      if (recv_flags & TF_RESET) {
  120fdc:	e30f324d 	movw	r3, #62029	; 0xf24d
  120fe0:	e3403014 	movt	r3, #20
  120fe4:	e5d33000 	ldrb	r3, [r3]
  120fe8:	e2033008 	and	r3, r3, #8
  120fec:	e3530000 	cmp	r3, #0
  120ff0:	0a000012 	beq	121040 <tcp_input+0xbb0>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
  120ff4:	e51b3010 	ldr	r3, [fp, #-16]
  120ff8:	e5933090 	ldr	r3, [r3, #144]	; 0x90
  120ffc:	e3530000 	cmp	r3, #0
  121000:	0a000006 	beq	121020 <tcp_input+0xb90>
  121004:	e51b3010 	ldr	r3, [fp, #-16]
  121008:	e5933090 	ldr	r3, [r3, #144]	; 0x90
  12100c:	e51b2010 	ldr	r2, [fp, #-16]
  121010:	e5922010 	ldr	r2, [r2, #16]
  121014:	e3e0100d 	mvn	r1, #13
  121018:	e1a00002 	mov	r0, r2
  12101c:	e12fff33 	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  121020:	e51b1010 	ldr	r1, [fp, #-16]
  121024:	e3060a30 	movw	r0, #27184	; 0x6a30
  121028:	e3400057 	movt	r0, #87	; 0x57
  12102c:	ebfffc11 	bl	120078 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  121030:	e51b1010 	ldr	r1, [fp, #-16]
  121034:	e3a00002 	mov	r0, #2
  121038:	ebffe10f 	bl	11947c <memp_free>
  12103c:	ea0000c1 	b	121348 <tcp_input+0xeb8>
      } else {
        err = ERR_OK;
  121040:	e3a03000 	mov	r3, #0
  121044:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (recv_acked > 0) {
  121048:	e30f3248 	movw	r3, #62024	; 0xf248
  12104c:	e3403014 	movt	r3, #20
  121050:	e1d330b0 	ldrh	r3, [r3]
  121054:	e3530000 	cmp	r3, #0
  121058:	0a00001a 	beq	1210c8 <tcp_input+0xc38>
          while (acked > 0) {
            acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
            acked -= acked16;
#else
          {
            acked16 = recv_acked;
  12105c:	e30f3248 	movw	r3, #62024	; 0xf248
  121060:	e3403014 	movt	r3, #20
  121064:	e1d330b0 	ldrh	r3, [r3]
  121068:	e14b32ba 	strh	r3, [fp, #-42]	; 0xffffffd6
#endif
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
  12106c:	e51b3010 	ldr	r3, [fp, #-16]
  121070:	e5933080 	ldr	r3, [r3, #128]	; 0x80
  121074:	e3530000 	cmp	r3, #0
  121078:	0a000009 	beq	1210a4 <tcp_input+0xc14>
  12107c:	e51b3010 	ldr	r3, [fp, #-16]
  121080:	e5933080 	ldr	r3, [r3, #128]	; 0x80
  121084:	e51b2010 	ldr	r2, [fp, #-16]
  121088:	e5920010 	ldr	r0, [r2, #16]
  12108c:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
  121090:	e51b1010 	ldr	r1, [fp, #-16]
  121094:	e12fff33 	blx	r3
  121098:	e1a03000 	mov	r3, r0
  12109c:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
  1210a0:	ea000001 	b	1210ac <tcp_input+0xc1c>
  1210a4:	e3a03000 	mov	r3, #0
  1210a8:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
            if (err == ERR_ABRT) {
  1210ac:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
  1210b0:	e373000d 	cmn	r3, #13
  1210b4:	0a00009e 	beq	121334 <tcp_input+0xea4>
              goto aborted;
            }
          }
          recv_acked = 0;
  1210b8:	e30f3248 	movw	r3, #62024	; 0xf248
  1210bc:	e3403014 	movt	r3, #20
  1210c0:	e3a02000 	mov	r2, #0
  1210c4:	e1c320b0 	strh	r2, [r3]
        }
        if (recv_flags & TF_CLOSED) {
  1210c8:	e30f324d 	movw	r3, #62029	; 0xf24d
  1210cc:	e3403014 	movt	r3, #20
  1210d0:	e5d33000 	ldrb	r3, [r3]
  1210d4:	e2033010 	and	r3, r3, #16
  1210d8:	e3530000 	cmp	r3, #0
  1210dc:	0a000017 	beq	121140 <tcp_input+0xcb0>
          /* The connection has been closed and we will deallocate the
             PCB. */
          if (!(pcb->flags & TF_RXCLOSED)) {
  1210e0:	e51b3010 	ldr	r3, [fp, #-16]
  1210e4:	e5d3301e 	ldrb	r3, [r3, #30]
  1210e8:	e2033010 	and	r3, r3, #16
  1210ec:	e3530000 	cmp	r3, #0
  1210f0:	1a00000a 	bne	121120 <tcp_input+0xc90>
            /* Connection closed although the application has only shut down the
               tx side: call the PCB's err callback and indicate the closure to
               ensure the application doesn't continue using the PCB. */
            TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
  1210f4:	e51b3010 	ldr	r3, [fp, #-16]
  1210f8:	e5933090 	ldr	r3, [r3, #144]	; 0x90
  1210fc:	e3530000 	cmp	r3, #0
  121100:	0a000006 	beq	121120 <tcp_input+0xc90>
  121104:	e51b3010 	ldr	r3, [fp, #-16]
  121108:	e5933090 	ldr	r3, [r3, #144]	; 0x90
  12110c:	e51b2010 	ldr	r2, [fp, #-16]
  121110:	e5922010 	ldr	r2, [r2, #16]
  121114:	e3e0100e 	mvn	r1, #14
  121118:	e1a00002 	mov	r0, r2
  12111c:	e12fff33 	blx	r3
          }
          tcp_pcb_remove(&tcp_active_pcbs, pcb);
  121120:	e51b1010 	ldr	r1, [fp, #-16]
  121124:	e3060a30 	movw	r0, #27184	; 0x6a30
  121128:	e3400057 	movt	r0, #87	; 0x57
  12112c:	ebfffbd1 	bl	120078 <tcp_pcb_remove>
          memp_free(MEMP_TCP_PCB, pcb);
  121130:	e51b1010 	ldr	r1, [fp, #-16]
  121134:	e3a00002 	mov	r0, #2
  121138:	ebffe0cf 	bl	11947c <memp_free>
          goto aborted;
  12113c:	ea000081 	b	121348 <tcp_input+0xeb8>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
        while (recv_data != NULL) {
          struct pbuf *rest = NULL;
          pbuf_split_64k(recv_data, &rest);
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
        if (recv_data != NULL) {
  121140:	e30f3250 	movw	r3, #62032	; 0xf250
  121144:	e3403014 	movt	r3, #20
  121148:	e5933000 	ldr	r3, [r3]
  12114c:	e3530000 	cmp	r3, #0
  121150:	0a00003c 	beq	121248 <tcp_input+0xdb8>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
  121154:	e51b3010 	ldr	r3, [fp, #-16]
  121158:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  12115c:	e3530000 	cmp	r3, #0
  121160:	0a000006 	beq	121180 <tcp_input+0xcf0>
  121164:	e3080630 	movw	r0, #34352	; 0x8630
  121168:	e3400014 	movt	r0, #20
  12116c:	ebff87e8 	bl	103114 <rt_kprintf>
  121170:	e3a01f6b 	mov	r1, #428	; 0x1ac
  121174:	e30804d0 	movw	r0, #34000	; 0x84d0
  121178:	e3400014 	movt	r0, #20
  12117c:	ebffa7be 	bl	10b07c <sys_arch_assert>
          if (pcb->flags & TF_RXCLOSED) {
  121180:	e51b3010 	ldr	r3, [fp, #-16]
  121184:	e5d3301e 	ldrb	r3, [r3, #30]
  121188:	e2033010 	and	r3, r3, #16
  12118c:	e3530000 	cmp	r3, #0
  121190:	0a000007 	beq	1211b4 <tcp_input+0xd24>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
  121194:	e30f3250 	movw	r3, #62032	; 0xf250
  121198:	e3403014 	movt	r3, #20
  12119c:	e5933000 	ldr	r3, [r3]
  1211a0:	e1a00003 	mov	r0, r3
  1211a4:	ebffe7c2 	bl	11b0b4 <pbuf_free>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_free(rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            tcp_abort(pcb);
  1211a8:	e51b0010 	ldr	r0, [fp, #-16]
  1211ac:	ebfff29a 	bl	11dc1c <tcp_abort>
            goto aborted;
  1211b0:	ea000064 	b	121348 <tcp_input+0xeb8>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  1211b4:	e51b3010 	ldr	r3, [fp, #-16]
  1211b8:	e5933084 	ldr	r3, [r3, #132]	; 0x84
  1211bc:	e3530000 	cmp	r3, #0
  1211c0:	0a00000c 	beq	1211f8 <tcp_input+0xd68>
  1211c4:	e51b3010 	ldr	r3, [fp, #-16]
  1211c8:	e5934084 	ldr	r4, [r3, #132]	; 0x84
  1211cc:	e51b3010 	ldr	r3, [fp, #-16]
  1211d0:	e5930010 	ldr	r0, [r3, #16]
  1211d4:	e30f3250 	movw	r3, #62032	; 0xf250
  1211d8:	e3403014 	movt	r3, #20
  1211dc:	e5932000 	ldr	r2, [r3]
  1211e0:	e3a03000 	mov	r3, #0
  1211e4:	e51b1010 	ldr	r1, [fp, #-16]
  1211e8:	e12fff34 	blx	r4
  1211ec:	e1a03000 	mov	r3, r0
  1211f0:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
  1211f4:	ea000008 	b	12121c <tcp_input+0xd8c>
  1211f8:	e30f3250 	movw	r3, #62032	; 0xf250
  1211fc:	e3403014 	movt	r3, #20
  121200:	e5932000 	ldr	r2, [r3]
  121204:	e3a03000 	mov	r3, #0
  121208:	e51b1010 	ldr	r1, [fp, #-16]
  12120c:	e3a00000 	mov	r0, #0
  121210:	ebfff956 	bl	11f770 <tcp_recv_null>
  121214:	e1a03000 	mov	r3, r0
  121218:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
          if (err == ERR_ABRT) {
  12121c:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
  121220:	e373000d 	cmn	r3, #13
  121224:	0a000044 	beq	12133c <tcp_input+0xeac>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  121228:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
  12122c:	e3530000 	cmp	r3, #0
  121230:	0a000004 	beq	121248 <tcp_input+0xdb8>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_cat(recv_data, rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            pcb->refused_data = recv_data;
  121234:	e30f3250 	movw	r3, #62032	; 0xf250
  121238:	e3403014 	movt	r3, #20
  12123c:	e5932000 	ldr	r2, [r3]
  121240:	e51b3010 	ldr	r3, [fp, #-16]
  121244:	e5832078 	str	r2, [r3, #120]	; 0x78
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  121248:	e30f324d 	movw	r3, #62029	; 0xf24d
  12124c:	e3403014 	movt	r3, #20
  121250:	e5d33000 	ldrb	r3, [r3]
  121254:	e2033020 	and	r3, r3, #32
  121258:	e3530000 	cmp	r3, #0
  12125c:	0a00002b 	beq	121310 <tcp_input+0xe80>
          if (pcb->refused_data != NULL) {
  121260:	e51b3010 	ldr	r3, [fp, #-16]
  121264:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  121268:	e3530000 	cmp	r3, #0
  12126c:	0a000008 	beq	121294 <tcp_input+0xe04>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
  121270:	e51b3010 	ldr	r3, [fp, #-16]
  121274:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  121278:	e5d3200d 	ldrb	r2, [r3, #13]
  12127c:	e51b3010 	ldr	r3, [fp, #-16]
  121280:	e5933078 	ldr	r3, [r3, #120]	; 0x78
  121284:	e3822020 	orr	r2, r2, #32
  121288:	e6ef2072 	uxtb	r2, r2
  12128c:	e5c3200d 	strb	r2, [r3, #13]
  121290:	ea00001e 	b	121310 <tcp_input+0xe80>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
  121294:	e51b3010 	ldr	r3, [fp, #-16]
  121298:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  12129c:	e30f2fff 	movw	r2, #65535	; 0xffff
  1212a0:	e1530002 	cmp	r3, r2
  1212a4:	0a000005 	beq	1212c0 <tcp_input+0xe30>
              pcb->rcv_wnd++;
  1212a8:	e51b3010 	ldr	r3, [fp, #-16]
  1212ac:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  1212b0:	e2833001 	add	r3, r3, #1
  1212b4:	e6ff2073 	uxth	r2, r3
  1212b8:	e51b3010 	ldr	r3, [fp, #-16]
  1212bc:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
  1212c0:	e51b3010 	ldr	r3, [fp, #-16]
  1212c4:	e5933084 	ldr	r3, [r3, #132]	; 0x84
  1212c8:	e3530000 	cmp	r3, #0
  1212cc:	0a00000a 	beq	1212fc <tcp_input+0xe6c>
  1212d0:	e51b3010 	ldr	r3, [fp, #-16]
  1212d4:	e5934084 	ldr	r4, [r3, #132]	; 0x84
  1212d8:	e51b3010 	ldr	r3, [fp, #-16]
  1212dc:	e5930010 	ldr	r0, [r3, #16]
  1212e0:	e3a03000 	mov	r3, #0
  1212e4:	e3a02000 	mov	r2, #0
  1212e8:	e51b1010 	ldr	r1, [fp, #-16]
  1212ec:	e12fff34 	blx	r4
  1212f0:	e1a03000 	mov	r3, r0
  1212f4:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
  1212f8:	ea000001 	b	121304 <tcp_input+0xe74>
  1212fc:	e3a03000 	mov	r3, #0
  121300:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
            if (err == ERR_ABRT) {
  121304:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
  121308:	e373000d 	cmn	r3, #13
  12130c:	0a00000c 	beq	121344 <tcp_input+0xeb4>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
  121310:	e3063a44 	movw	r3, #27204	; 0x6a44
  121314:	e3403057 	movt	r3, #87	; 0x57
  121318:	e3a02000 	mov	r2, #0
  12131c:	e5832000 	str	r2, [r3]
        /* Try to send something out. */
        tcp_output(pcb);
  121320:	e51b0010 	ldr	r0, [fp, #-16]
  121324:	eb00138c 	bl	12615c <tcp_output>
  121328:	ea000006 	b	121348 <tcp_input+0xeb8>
#endif /* TCP_INPUT_DEBUG */
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
  12132c:	e320f000 	nop	{0}
  121330:	ea000004 	b	121348 <tcp_input+0xeb8>
              goto aborted;
  121334:	e320f000 	nop	{0}
  121338:	ea000002 	b	121348 <tcp_input+0xeb8>
            goto aborted;
  12133c:	e320f000 	nop	{0}
  121340:	ea000000 	b	121348 <tcp_input+0xeb8>
              goto aborted;
  121344:	e320f000 	nop	{0}
    tcp_input_pcb = NULL;
  121348:	e3063a44 	movw	r3, #27204	; 0x6a44
  12134c:	e3403057 	movt	r3, #87	; 0x57
  121350:	e3a02000 	mov	r2, #0
  121354:	e5832000 	str	r2, [r3]
    recv_data = NULL;
  121358:	e30f3250 	movw	r3, #62032	; 0xf250
  12135c:	e3403014 	movt	r3, #20
  121360:	e3a02000 	mov	r2, #0
  121364:	e5832000 	str	r2, [r3]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  121368:	e30f3220 	movw	r3, #61984	; 0xf220
  12136c:	e3403014 	movt	r3, #20
  121370:	e5933004 	ldr	r3, [r3, #4]
  121374:	e3530000 	cmp	r3, #0
  121378:	0a000053 	beq	1214cc <tcp_input+0x103c>
    {
      pbuf_free(inseg.p);
  12137c:	e30f3220 	movw	r3, #61984	; 0xf220
  121380:	e3403014 	movt	r3, #20
  121384:	e5933004 	ldr	r3, [r3, #4]
  121388:	e1a00003 	mov	r0, r3
  12138c:	ebffe748 	bl	11b0b4 <pbuf_free>
      inseg.p = NULL;
  121390:	e30f3220 	movw	r3, #61984	; 0xf220
  121394:	e3403014 	movt	r3, #20
  121398:	e3a02000 	mov	r2, #0
  12139c:	e5832004 	str	r2, [r3, #4]
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
  1213a0:	ea000049 	b	1214cc <tcp_input+0x103c>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  1213a4:	e30f3230 	movw	r3, #62000	; 0xf230
  1213a8:	e3403014 	movt	r3, #20
  1213ac:	e5933000 	ldr	r3, [r3]
  1213b0:	e1d330bc 	ldrh	r3, [r3, #12]
  1213b4:	e6ff3073 	uxth	r3, r3
  1213b8:	e1a00003 	mov	r0, r3
  1213bc:	ebffd505 	bl	1167d8 <lwip_htons>
  1213c0:	e1a03000 	mov	r3, r0
  1213c4:	e2033004 	and	r3, r3, #4
  1213c8:	e3530000 	cmp	r3, #0
  1213cc:	1a000029 	bne	121478 <tcp_input+0xfe8>
      TCP_STATS_INC(tcp.proterr);
  1213d0:	e3063840 	movw	r3, #26688	; 0x6840
  1213d4:	e3403057 	movt	r3, #87	; 0x57
  1213d8:	e1d33bbc 	ldrh	r3, [r3, #188]	; 0xbc
  1213dc:	e2833001 	add	r3, r3, #1
  1213e0:	e6ff2073 	uxth	r2, r3
  1213e4:	e3063840 	movw	r3, #26688	; 0x6840
  1213e8:	e3403057 	movt	r3, #87	; 0x57
  1213ec:	e1c32bbc 	strh	r2, [r3, #188]	; 0xbc
      TCP_STATS_INC(tcp.drop);
  1213f0:	e3063840 	movw	r3, #26688	; 0x6840
  1213f4:	e3403057 	movt	r3, #87	; 0x57
  1213f8:	e1d33bb2 	ldrh	r3, [r3, #178]	; 0xb2
  1213fc:	e2833001 	add	r3, r3, #1
  121400:	e6ff2073 	uxth	r2, r3
  121404:	e3063840 	movw	r3, #26688	; 0x6840
  121408:	e3403057 	movt	r3, #87	; 0x57
  12140c:	e1c32bb2 	strh	r2, [r3, #178]	; 0xb2
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  121410:	e30f3244 	movw	r3, #62020	; 0xf244
  121414:	e3403014 	movt	r3, #20
  121418:	e5930000 	ldr	r0, [r3]
  12141c:	e30f324a 	movw	r3, #62026	; 0xf24a
  121420:	e3403014 	movt	r3, #20
  121424:	e1d330b0 	ldrh	r3, [r3]
  121428:	e1a02003 	mov	r2, r3
  12142c:	e30f3240 	movw	r3, #62016	; 0xf240
  121430:	e3403014 	movt	r3, #20
  121434:	e5933000 	ldr	r3, [r3]
  121438:	e0821003 	add	r1, r2, r3
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  12143c:	e30f3230 	movw	r3, #62000	; 0xf230
  121440:	e3403014 	movt	r3, #20
  121444:	e5933000 	ldr	r3, [r3]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  121448:	e1d330b2 	ldrh	r3, [r3, #2]
  12144c:	e6ff2073 	uxth	r2, r3
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  121450:	e30f3230 	movw	r3, #62000	; 0xf230
  121454:	e3403014 	movt	r3, #20
  121458:	e5933000 	ldr	r3, [r3]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  12145c:	e1d330b0 	ldrh	r3, [r3]
  121460:	e6ff3073 	uxth	r3, r3
  121464:	e58d3004 	str	r3, [sp, #4]
  121468:	e58d2000 	str	r2, [sp]
  12146c:	e59f3068 	ldr	r3, [pc, #104]	; 1214dc <tcp_input+0x104c>
  121470:	e59f2060 	ldr	r2, [pc, #96]	; 1214d8 <tcp_input+0x1048>
  121474:	eb00159e 	bl	126af4 <tcp_rst>
    pbuf_free(p);
  121478:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  12147c:	ebffe70c 	bl	11b0b4 <pbuf_free>
  return;
  121480:	ea000011 	b	1214cc <tcp_input+0x103c>
dropped:
  TCP_STATS_INC(tcp.drop);
  121484:	e3063840 	movw	r3, #26688	; 0x6840
  121488:	e3403057 	movt	r3, #87	; 0x57
  12148c:	e1d33bb2 	ldrh	r3, [r3, #178]	; 0xb2
  121490:	e2833001 	add	r3, r3, #1
  121494:	e6ff2073 	uxth	r2, r3
  121498:	e3063840 	movw	r3, #26688	; 0x6840
  12149c:	e3403057 	movt	r3, #87	; 0x57
  1214a0:	e1c32bb2 	strh	r2, [r3, #178]	; 0xb2
  MIB2_STATS_INC(mib2.tcpinerrs);
  1214a4:	e3063840 	movw	r3, #26688	; 0x6840
  1214a8:	e3403057 	movt	r3, #87	; 0x57
  1214ac:	e5933188 	ldr	r3, [r3, #392]	; 0x188
  1214b0:	e2832001 	add	r2, r3, #1
  1214b4:	e3063840 	movw	r3, #26688	; 0x6840
  1214b8:	e3403057 	movt	r3, #87	; 0x57
  1214bc:	e5832188 	str	r2, [r3, #392]	; 0x188
  pbuf_free(p);
  1214c0:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  1214c4:	ebffe6fa 	bl	11b0b4 <pbuf_free>
  1214c8:	ea000000 	b	1214d0 <tcp_input+0x1040>
  return;
  1214cc:	e320f000 	nop	{0}
}
  1214d0:	e24bd008 	sub	sp, fp, #8
  1214d4:	e8bd8810 	pop	{r4, fp, pc}
  1214d8:	001505fc 	.word	0x001505fc
  1214dc:	001505f8 	.word	0x001505f8

001214e0 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  1214e0:	e92d4800 	push	{fp, lr}
  1214e4:	e28db004 	add	fp, sp, #4
  1214e8:	e24dd020 	sub	sp, sp, #32
  1214ec:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct tcp_pcb *npcb;
  u32_t iss;
  err_t rc;

  if (flags & TCP_RST) {
  1214f0:	e30f324c 	movw	r3, #62028	; 0xf24c
  1214f4:	e3403014 	movt	r3, #20
  1214f8:	e5d33000 	ldrb	r3, [r3]
  1214fc:	e2033004 	and	r3, r3, #4
  121500:	e3530000 	cmp	r3, #0
  121504:	1a0000c8 	bne	12182c <tcp_listen_input+0x34c>
    return;
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  121508:	e30f324c 	movw	r3, #62028	; 0xf24c
  12150c:	e3403014 	movt	r3, #20
  121510:	e5d33000 	ldrb	r3, [r3]
  121514:	e2033010 	and	r3, r3, #16
  121518:	e3530000 	cmp	r3, #0
  12151c:	0a00001a 	beq	12158c <tcp_listen_input+0xac>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  121520:	e30f3244 	movw	r3, #62020	; 0xf244
  121524:	e3403014 	movt	r3, #20
  121528:	e5930000 	ldr	r0, [r3]
  12152c:	e30f324a 	movw	r3, #62026	; 0xf24a
  121530:	e3403014 	movt	r3, #20
  121534:	e1d330b0 	ldrh	r3, [r3]
  121538:	e1a02003 	mov	r2, r3
  12153c:	e30f3240 	movw	r3, #62016	; 0xf240
  121540:	e3403014 	movt	r3, #20
  121544:	e5933000 	ldr	r3, [r3]
  121548:	e0821003 	add	r1, r2, r3
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  12154c:	e30f3230 	movw	r3, #62000	; 0xf230
  121550:	e3403014 	movt	r3, #20
  121554:	e5933000 	ldr	r3, [r3]
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  121558:	e1d330b2 	ldrh	r3, [r3, #2]
  12155c:	e6ff2073 	uxth	r2, r3
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  121560:	e30f3230 	movw	r3, #62000	; 0xf230
  121564:	e3403014 	movt	r3, #20
  121568:	e5933000 	ldr	r3, [r3]
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  12156c:	e1d330b0 	ldrh	r3, [r3]
  121570:	e6ff3073 	uxth	r3, r3
  121574:	e58d3004 	str	r3, [sp, #4]
  121578:	e58d2000 	str	r2, [sp]
  12157c:	e59f32bc 	ldr	r3, [pc, #700]	; 121840 <tcp_listen_input+0x360>
  121580:	e59f22bc 	ldr	r2, [pc, #700]	; 121844 <tcp_listen_input+0x364>
  121584:	eb00155a 	bl	126af4 <tcp_rst>
      tcp_abandon(npcb, 0);
      return;
    }
    tcp_output(npcb);
  }
  return;
  121588:	ea0000a9 	b	121834 <tcp_listen_input+0x354>
  } else if (flags & TCP_SYN) {
  12158c:	e30f324c 	movw	r3, #62028	; 0xf24c
  121590:	e3403014 	movt	r3, #20
  121594:	e5d33000 	ldrb	r3, [r3]
  121598:	e2033002 	and	r3, r3, #2
  12159c:	e3530000 	cmp	r3, #0
  1215a0:	0a0000a3 	beq	121834 <tcp_listen_input+0x354>
    npcb = tcp_alloc(pcb->prio);
  1215a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1215a8:	e5d33018 	ldrb	r3, [r3, #24]
  1215ac:	e1a00003 	mov	r0, r3
  1215b0:	ebfff934 	bl	11fa88 <tcp_alloc>
  1215b4:	e50b0008 	str	r0, [fp, #-8]
    if (npcb == NULL) {
  1215b8:	e51b3008 	ldr	r3, [fp, #-8]
  1215bc:	e3530000 	cmp	r3, #0
  1215c0:	1a000018 	bne	121628 <tcp_listen_input+0x148>
      TCP_STATS_INC(tcp.memerr);
  1215c4:	e3063840 	movw	r3, #26688	; 0x6840
  1215c8:	e3403057 	movt	r3, #87	; 0x57
  1215cc:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
  1215d0:	e2833001 	add	r3, r3, #1
  1215d4:	e6ff2073 	uxth	r2, r3
  1215d8:	e3063840 	movw	r3, #26688	; 0x6840
  1215dc:	e3403057 	movt	r3, #87	; 0x57
  1215e0:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
  1215e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1215e8:	e593301c 	ldr	r3, [r3, #28]
  1215ec:	e3530000 	cmp	r3, #0
  1215f0:	0a000009 	beq	12161c <tcp_listen_input+0x13c>
  1215f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1215f8:	e593301c 	ldr	r3, [r3, #28]
  1215fc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  121600:	e5920010 	ldr	r0, [r2, #16]
  121604:	e3e02000 	mvn	r2, #0
  121608:	e3a01000 	mov	r1, #0
  12160c:	e12fff33 	blx	r3
  121610:	e1a03000 	mov	r3, r0
  121614:	e54b300e 	strb	r3, [fp, #-14]
      return;
  121618:	ea000086 	b	121838 <tcp_listen_input+0x358>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
  12161c:	e3e0300f 	mvn	r3, #15
  121620:	e54b300e 	strb	r3, [fp, #-14]
      return;
  121624:	ea000083 	b	121838 <tcp_listen_input+0x358>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
  121628:	e30035e8 	movw	r3, #1512	; 0x5e8
  12162c:	e3403015 	movt	r3, #21
  121630:	e5932014 	ldr	r2, [r3, #20]
  121634:	e51b3008 	ldr	r3, [fp, #-8]
  121638:	e5832000 	str	r2, [r3]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
  12163c:	e30035e8 	movw	r3, #1512	; 0x5e8
  121640:	e3403015 	movt	r3, #21
  121644:	e5932010 	ldr	r2, [r3, #16]
  121648:	e51b3008 	ldr	r3, [fp, #-8]
  12164c:	e5832004 	str	r2, [r3, #4]
    npcb->local_port = pcb->local_port;
  121650:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  121654:	e1d321ba 	ldrh	r2, [r3, #26]
  121658:	e51b3008 	ldr	r3, [fp, #-8]
  12165c:	e1c321ba 	strh	r2, [r3, #26]
    npcb->remote_port = tcphdr->src;
  121660:	e30f3230 	movw	r3, #62000	; 0xf230
  121664:	e3403014 	movt	r3, #20
  121668:	e5933000 	ldr	r3, [r3]
  12166c:	e1d330b0 	ldrh	r3, [r3]
  121670:	e6ff2073 	uxth	r2, r3
  121674:	e51b3008 	ldr	r3, [fp, #-8]
  121678:	e1c321bc 	strh	r2, [r3, #28]
    npcb->state = SYN_RCVD;
  12167c:	e51b3008 	ldr	r3, [fp, #-8]
  121680:	e3a02003 	mov	r2, #3
  121684:	e5832014 	str	r2, [r3, #20]
    npcb->rcv_nxt = seqno + 1;
  121688:	e30f3240 	movw	r3, #62016	; 0xf240
  12168c:	e3403014 	movt	r3, #20
  121690:	e5933000 	ldr	r3, [r3]
  121694:	e2832001 	add	r2, r3, #1
  121698:	e51b3008 	ldr	r3, [fp, #-8]
  12169c:	e5832028 	str	r2, [r3, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
  1216a0:	e51b3008 	ldr	r3, [fp, #-8]
  1216a4:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  1216a8:	e51b3008 	ldr	r3, [fp, #-8]
  1216ac:	e5832030 	str	r2, [r3, #48]	; 0x30
    iss = tcp_next_iss(npcb);
  1216b0:	e51b0008 	ldr	r0, [fp, #-8]
  1216b4:	ebfffadb 	bl	120228 <tcp_next_iss>
  1216b8:	e50b000c 	str	r0, [fp, #-12]
    npcb->snd_wl2 = iss;
  1216bc:	e51b3008 	ldr	r3, [fp, #-8]
  1216c0:	e51b200c 	ldr	r2, [fp, #-12]
  1216c4:	e5832058 	str	r2, [r3, #88]	; 0x58
    npcb->snd_nxt = iss;
  1216c8:	e51b3008 	ldr	r3, [fp, #-8]
  1216cc:	e51b200c 	ldr	r2, [fp, #-12]
  1216d0:	e5832050 	str	r2, [r3, #80]	; 0x50
    npcb->lastack = iss;
  1216d4:	e51b3008 	ldr	r3, [fp, #-8]
  1216d8:	e51b200c 	ldr	r2, [fp, #-12]
  1216dc:	e5832048 	str	r2, [r3, #72]	; 0x48
    npcb->snd_lbb = iss;
  1216e0:	e51b3008 	ldr	r3, [fp, #-8]
  1216e4:	e51b200c 	ldr	r2, [fp, #-12]
  1216e8:	e583205c 	str	r2, [r3, #92]	; 0x5c
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  1216ec:	e30f3240 	movw	r3, #62016	; 0xf240
  1216f0:	e3403014 	movt	r3, #20
  1216f4:	e5933000 	ldr	r3, [r3]
  1216f8:	e2432001 	sub	r2, r3, #1
  1216fc:	e51b3008 	ldr	r3, [fp, #-8]
  121700:	e5832054 	str	r2, [r3, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
  121704:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  121708:	e5932010 	ldr	r2, [r3, #16]
  12170c:	e51b3008 	ldr	r3, [fp, #-8]
  121710:	e5832010 	str	r2, [r3, #16]
    npcb->listener = pcb;
  121714:	e51b3008 	ldr	r3, [fp, #-8]
  121718:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  12171c:	e583207c 	str	r2, [r3, #124]	; 0x7c
    npcb->so_options = pcb->so_options & SOF_INHERITED;
  121720:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  121724:	e5d33008 	ldrb	r3, [r3, #8]
  121728:	e203300c 	and	r3, r3, #12
  12172c:	e6ef2073 	uxtb	r2, r3
  121730:	e51b3008 	ldr	r3, [fp, #-8]
  121734:	e5c32008 	strb	r2, [r3, #8]
    TCP_REG_ACTIVE(npcb);
  121738:	e3063a30 	movw	r3, #27184	; 0x6a30
  12173c:	e3403057 	movt	r3, #87	; 0x57
  121740:	e5932000 	ldr	r2, [r3]
  121744:	e51b3008 	ldr	r3, [fp, #-8]
  121748:	e583200c 	str	r2, [r3, #12]
  12174c:	e3063a30 	movw	r3, #27184	; 0x6a30
  121750:	e3403057 	movt	r3, #87	; 0x57
  121754:	e51b2008 	ldr	r2, [fp, #-8]
  121758:	e5832000 	str	r2, [r3]
  12175c:	eb001737 	bl	127440 <tcp_timer_needed>
  121760:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  121764:	e3403057 	movt	r3, #87	; 0x57
  121768:	e3a02001 	mov	r2, #1
  12176c:	e5c32000 	strb	r2, [r3]
    tcp_parseopt(npcb);
  121770:	e51b0008 	ldr	r0, [fp, #-8]
  121774:	eb000bf1 	bl	124740 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
  121778:	e30f3230 	movw	r3, #62000	; 0xf230
  12177c:	e3403014 	movt	r3, #20
  121780:	e5933000 	ldr	r3, [r3]
  121784:	e1d330be 	ldrh	r3, [r3, #14]
  121788:	e6ff2073 	uxth	r2, r3
  12178c:	e51b3008 	ldr	r3, [fp, #-8]
  121790:	e1c326b0 	strh	r2, [r3, #96]	; 0x60
    npcb->snd_wnd_max = npcb->snd_wnd;
  121794:	e51b3008 	ldr	r3, [fp, #-8]
  121798:	e1d326b0 	ldrh	r2, [r3, #96]	; 0x60
  12179c:	e51b3008 	ldr	r3, [fp, #-8]
  1217a0:	e1c326b2 	strh	r2, [r3, #98]	; 0x62
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
  1217a4:	e51b3008 	ldr	r3, [fp, #-8]
  1217a8:	e1d323b6 	ldrh	r2, [r3, #54]	; 0x36
  1217ac:	e51b3008 	ldr	r3, [fp, #-8]
  1217b0:	e2833004 	add	r3, r3, #4
  1217b4:	e1a01003 	mov	r1, r3
  1217b8:	e1a00002 	mov	r0, r2
  1217bc:	ebfffaae 	bl	12027c <tcp_eff_send_mss_impl>
  1217c0:	e1a03000 	mov	r3, r0
  1217c4:	e1a02003 	mov	r2, r3
  1217c8:	e51b3008 	ldr	r3, [fp, #-8]
  1217cc:	e1c323b6 	strh	r2, [r3, #54]	; 0x36
    MIB2_STATS_INC(mib2.tcppassiveopens);
  1217d0:	e3063840 	movw	r3, #26688	; 0x6840
  1217d4:	e3403057 	movt	r3, #87	; 0x57
  1217d8:	e5933170 	ldr	r3, [r3, #368]	; 0x170
  1217dc:	e2832001 	add	r2, r3, #1
  1217e0:	e3063840 	movw	r3, #26688	; 0x6840
  1217e4:	e3403057 	movt	r3, #87	; 0x57
  1217e8:	e5832170 	str	r2, [r3, #368]	; 0x170
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
  1217ec:	e3a01012 	mov	r1, #18
  1217f0:	e51b0008 	ldr	r0, [fp, #-8]
  1217f4:	eb001109 	bl	125c20 <tcp_enqueue_flags>
  1217f8:	e1a03000 	mov	r3, r0
  1217fc:	e54b300d 	strb	r3, [fp, #-13]
    if (rc != ERR_OK) {
  121800:	e15b30dd 	ldrsb	r3, [fp, #-13]
  121804:	e3530000 	cmp	r3, #0
  121808:	0a000003 	beq	12181c <tcp_listen_input+0x33c>
      tcp_abandon(npcb, 0);
  12180c:	e3a01000 	mov	r1, #0
  121810:	e51b0008 	ldr	r0, [fp, #-8]
  121814:	ebfff061 	bl	11d9a0 <tcp_abandon>
      return;
  121818:	ea000006 	b	121838 <tcp_listen_input+0x358>
    tcp_output(npcb);
  12181c:	e51b0008 	ldr	r0, [fp, #-8]
  121820:	eb00124d 	bl	12615c <tcp_output>
  return;
  121824:	e320f000 	nop	{0}
  121828:	ea000001 	b	121834 <tcp_listen_input+0x354>
    return;
  12182c:	e320f000 	nop	{0}
  121830:	ea000000 	b	121838 <tcp_listen_input+0x358>
  return;
  121834:	e320f000 	nop	{0}
}
  121838:	e24bd004 	sub	sp, fp, #4
  12183c:	e8bd8800 	pop	{fp, pc}
  121840:	001505f8 	.word	0x001505f8
  121844:	001505fc 	.word	0x001505fc

00121848 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_timewait_input(struct tcp_pcb *pcb)
{
  121848:	e92d4800 	push	{fp, lr}
  12184c:	e28db004 	add	fp, sp, #4
  121850:	e24dd010 	sub	sp, sp, #16
  121854:	e50b0008 	str	r0, [fp, #-8]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST) {
  121858:	e30f324c 	movw	r3, #62028	; 0xf24c
  12185c:	e3403014 	movt	r3, #20
  121860:	e5d33000 	ldrb	r3, [r3]
  121864:	e2033004 	and	r3, r3, #4
  121868:	e3530000 	cmp	r3, #0
  12186c:	1a00004d 	bne	1219a8 <tcp_timewait_input+0x160>
    return;
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
  121870:	e30f324c 	movw	r3, #62028	; 0xf24c
  121874:	e3403014 	movt	r3, #20
  121878:	e5d33000 	ldrb	r3, [r3]
  12187c:	e2033002 	and	r3, r3, #2
  121880:	e3530000 	cmp	r3, #0
  121884:	0a00002d 	beq	121940 <tcp_timewait_input+0xf8>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
  121888:	e30f3240 	movw	r3, #62016	; 0xf240
  12188c:	e3403014 	movt	r3, #20
  121890:	e5932000 	ldr	r2, [r3]
  121894:	e51b3008 	ldr	r3, [fp, #-8]
  121898:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12189c:	e0423003 	sub	r3, r2, r3
  1218a0:	e3530000 	cmp	r3, #0
  1218a4:	ba000030 	blt	12196c <tcp_timewait_input+0x124>
  1218a8:	e30f3240 	movw	r3, #62016	; 0xf240
  1218ac:	e3403014 	movt	r3, #20
  1218b0:	e5932000 	ldr	r2, [r3]
  1218b4:	e51b3008 	ldr	r3, [fp, #-8]
  1218b8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  1218bc:	e51b1008 	ldr	r1, [fp, #-8]
  1218c0:	e1d112bc 	ldrh	r1, [r1, #44]	; 0x2c
  1218c4:	e0833001 	add	r3, r3, r1
  1218c8:	e0423003 	sub	r3, r2, r3
  1218cc:	e3530000 	cmp	r3, #0
  1218d0:	ca000025 	bgt	12196c <tcp_timewait_input+0x124>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  1218d4:	e30f3244 	movw	r3, #62020	; 0xf244
  1218d8:	e3403014 	movt	r3, #20
  1218dc:	e5930000 	ldr	r0, [r3]
  1218e0:	e30f324a 	movw	r3, #62026	; 0xf24a
  1218e4:	e3403014 	movt	r3, #20
  1218e8:	e1d330b0 	ldrh	r3, [r3]
  1218ec:	e1a02003 	mov	r2, r3
  1218f0:	e30f3240 	movw	r3, #62016	; 0xf240
  1218f4:	e3403014 	movt	r3, #20
  1218f8:	e5933000 	ldr	r3, [r3]
  1218fc:	e0821003 	add	r1, r2, r3
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  121900:	e30f3230 	movw	r3, #62000	; 0xf230
  121904:	e3403014 	movt	r3, #20
  121908:	e5933000 	ldr	r3, [r3]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  12190c:	e1d330b2 	ldrh	r3, [r3, #2]
  121910:	e6ff2073 	uxth	r2, r3
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  121914:	e30f3230 	movw	r3, #62000	; 0xf230
  121918:	e3403014 	movt	r3, #20
  12191c:	e5933000 	ldr	r3, [r3]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  121920:	e1d330b0 	ldrh	r3, [r3]
  121924:	e6ff3073 	uxth	r3, r3
  121928:	e58d3004 	str	r3, [sp, #4]
  12192c:	e58d2000 	str	r2, [sp]
  121930:	e59f3084 	ldr	r3, [pc, #132]	; 1219bc <tcp_timewait_input+0x174>
  121934:	e59f2084 	ldr	r2, [pc, #132]	; 1219c0 <tcp_timewait_input+0x178>
  121938:	eb00146d 	bl	126af4 <tcp_rst>
      return;
  12193c:	ea00001c 	b	1219b4 <tcp_timewait_input+0x16c>
    }
  } else if (flags & TCP_FIN) {
  121940:	e30f324c 	movw	r3, #62028	; 0xf24c
  121944:	e3403014 	movt	r3, #20
  121948:	e5d33000 	ldrb	r3, [r3]
  12194c:	e2033001 	and	r3, r3, #1
  121950:	e3530000 	cmp	r3, #0
  121954:	0a000004 	beq	12196c <tcp_timewait_input+0x124>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
  121958:	e3063a34 	movw	r3, #27188	; 0x6a34
  12195c:	e3403057 	movt	r3, #87	; 0x57
  121960:	e5932000 	ldr	r2, [r3]
  121964:	e51b3008 	ldr	r3, [fp, #-8]
  121968:	e5832024 	str	r2, [r3, #36]	; 0x24
  }

  if ((tcplen > 0)) {
  12196c:	e30f324a 	movw	r3, #62026	; 0xf24a
  121970:	e3403014 	movt	r3, #20
  121974:	e1d330b0 	ldrh	r3, [r3]
  121978:	e3530000 	cmp	r3, #0
  12197c:	0a00000b 	beq	1219b0 <tcp_timewait_input+0x168>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
  121980:	e51b3008 	ldr	r3, [fp, #-8]
  121984:	e5d3301e 	ldrb	r3, [r3, #30]
  121988:	e3833002 	orr	r3, r3, #2
  12198c:	e6ef2073 	uxtb	r2, r3
  121990:	e51b3008 	ldr	r3, [fp, #-8]
  121994:	e5c3201e 	strb	r2, [r3, #30]
    tcp_output(pcb);
  121998:	e51b0008 	ldr	r0, [fp, #-8]
  12199c:	eb0011ee 	bl	12615c <tcp_output>
  }
  return;
  1219a0:	e320f000 	nop	{0}
  1219a4:	ea000001 	b	1219b0 <tcp_timewait_input+0x168>
    return;
  1219a8:	e320f000 	nop	{0}
  1219ac:	ea000000 	b	1219b4 <tcp_timewait_input+0x16c>
  return;
  1219b0:	e320f000 	nop	{0}
}
  1219b4:	e24bd004 	sub	sp, fp, #4
  1219b8:	e8bd8800 	pop	{fp, pc}
  1219bc:	001505f8 	.word	0x001505f8
  1219c0:	001505fc 	.word	0x001505fc

001219c4 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  1219c4:	e92d4800 	push	{fp, lr}
  1219c8:	e28db004 	add	fp, sp, #4
  1219cc:	e24dd028 	sub	sp, sp, #40	; 0x28
  1219d0:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  1219d4:	e3a03000 	mov	r3, #0
  1219d8:	e54b3009 	strb	r3, [fp, #-9]
  err_t err;

  err = ERR_OK;
  1219dc:	e3a03000 	mov	r3, #0
  1219e0:	e54b300a 	strb	r3, [fp, #-10]

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  1219e4:	e30f324c 	movw	r3, #62028	; 0xf24c
  1219e8:	e3403014 	movt	r3, #20
  1219ec:	e5d33000 	ldrb	r3, [r3]
  1219f0:	e2033004 	and	r3, r3, #4
  1219f4:	e3530000 	cmp	r3, #0
  1219f8:	0a000050 	beq	121b40 <tcp_process+0x17c>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  1219fc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121a00:	e5933014 	ldr	r3, [r3, #20]
  121a04:	e3530002 	cmp	r3, #2
  121a08:	1a000009 	bne	121a34 <tcp_process+0x70>
      /* "In the SYN-SENT state (a RST received in response to an initial SYN),
          the RST is acceptable if the ACK field acknowledges the SYN." */
      if (ackno == pcb->snd_nxt) {
  121a0c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121a10:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  121a14:	e30f3244 	movw	r3, #62020	; 0xf244
  121a18:	e3403014 	movt	r3, #20
  121a1c:	e5933000 	ldr	r3, [r3]
  121a20:	e1520003 	cmp	r2, r3
  121a24:	1a000025 	bne	121ac0 <tcp_process+0xfc>
        acceptable = 1;
  121a28:	e3a03001 	mov	r3, #1
  121a2c:	e54b3009 	strb	r3, [fp, #-9]
  121a30:	ea000022 	b	121ac0 <tcp_process+0xfc>
      }
    } else {
      /* "In all states except SYN-SENT, all reset (RST) segments are validated
          by checking their SEQ-fields." */
      if (seqno == pcb->rcv_nxt) {
  121a34:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121a38:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  121a3c:	e30f3240 	movw	r3, #62016	; 0xf240
  121a40:	e3403014 	movt	r3, #20
  121a44:	e5933000 	ldr	r3, [r3]
  121a48:	e1520003 	cmp	r2, r3
  121a4c:	1a000002 	bne	121a5c <tcp_process+0x98>
        acceptable = 1;
  121a50:	e3a03001 	mov	r3, #1
  121a54:	e54b3009 	strb	r3, [fp, #-9]
  121a58:	ea000018 	b	121ac0 <tcp_process+0xfc>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
  121a5c:	e30f3240 	movw	r3, #62016	; 0xf240
  121a60:	e3403014 	movt	r3, #20
  121a64:	e5932000 	ldr	r2, [r3]
  121a68:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121a6c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  121a70:	e0423003 	sub	r3, r2, r3
  121a74:	e3530000 	cmp	r3, #0
  121a78:	ba000010 	blt	121ac0 <tcp_process+0xfc>
  121a7c:	e30f3240 	movw	r3, #62016	; 0xf240
  121a80:	e3403014 	movt	r3, #20
  121a84:	e5932000 	ldr	r2, [r3]
  121a88:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121a8c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  121a90:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  121a94:	e1d112bc 	ldrh	r1, [r1, #44]	; 0x2c
  121a98:	e0833001 	add	r3, r3, r1
  121a9c:	e0423003 	sub	r3, r2, r3
  121aa0:	e3530000 	cmp	r3, #0
  121aa4:	ca000005 	bgt	121ac0 <tcp_process+0xfc>
                                  pcb->rcv_nxt + pcb->rcv_wnd)) {
        /* If the sequence number is inside the window, we only send an ACK
           and wait for a re-send with matching sequence number.
           This violates RFC 793, but is required to protection against
           CVE-2004-0230 (RST spoofing attack). */
        tcp_ack_now(pcb);
  121aa8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121aac:	e5d3301e 	ldrb	r3, [r3, #30]
  121ab0:	e3833002 	orr	r3, r3, #2
  121ab4:	e6ef2073 	uxtb	r2, r3
  121ab8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121abc:	e5c3201e 	strb	r2, [r3, #30]
      }
    }

    if (acceptable) {
  121ac0:	e55b3009 	ldrb	r3, [fp, #-9]
  121ac4:	e3530000 	cmp	r3, #0
  121ac8:	0a00001a 	beq	121b38 <tcp_process+0x174>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  121acc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121ad0:	e5933014 	ldr	r3, [r3, #20]
  121ad4:	e3530000 	cmp	r3, #0
  121ad8:	1a000006 	bne	121af8 <tcp_process+0x134>
  121adc:	e308064c 	movw	r0, #34380	; 0x864c
  121ae0:	e3400014 	movt	r0, #20
  121ae4:	ebff858a 	bl	103114 <rt_kprintf>
  121ae8:	e3a01fb5 	mov	r1, #724	; 0x2d4
  121aec:	e30804d0 	movw	r0, #34000	; 0x84d0
  121af0:	e3400014 	movt	r0, #20
  121af4:	ebffa560 	bl	10b07c <sys_arch_assert>
      recv_flags |= TF_RESET;
  121af8:	e30f324d 	movw	r3, #62029	; 0xf24d
  121afc:	e3403014 	movt	r3, #20
  121b00:	e5d33000 	ldrb	r3, [r3]
  121b04:	e3833008 	orr	r3, r3, #8
  121b08:	e6ef2073 	uxtb	r2, r3
  121b0c:	e30f324d 	movw	r3, #62029	; 0xf24d
  121b10:	e3403014 	movt	r3, #20
  121b14:	e5c32000 	strb	r2, [r3]
      pcb->flags &= ~TF_ACK_DELAY;
  121b18:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121b1c:	e5d3301e 	ldrb	r3, [r3, #30]
  121b20:	e3c33001 	bic	r3, r3, #1
  121b24:	e6ef2073 	uxtb	r2, r3
  121b28:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121b2c:	e5c3201e 	strb	r2, [r3, #30]
      return ERR_RST;
  121b30:	e3e0300d 	mvn	r3, #13
  121b34:	ea0002fd 	b	122730 <tcp_process+0xd6c>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  121b38:	e3a03000 	mov	r3, #0
  121b3c:	ea0002fb 	b	122730 <tcp_process+0xd6c>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
  121b40:	e30f324c 	movw	r3, #62028	; 0xf24c
  121b44:	e3403014 	movt	r3, #20
  121b48:	e5d33000 	ldrb	r3, [r3]
  121b4c:	e2033002 	and	r3, r3, #2
  121b50:	e3530000 	cmp	r3, #0
  121b54:	0a00000f 	beq	121b98 <tcp_process+0x1d4>
  121b58:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121b5c:	e5933014 	ldr	r3, [r3, #20]
  121b60:	e3530002 	cmp	r3, #2
  121b64:	0a00000b 	beq	121b98 <tcp_process+0x1d4>
  121b68:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121b6c:	e5933014 	ldr	r3, [r3, #20]
  121b70:	e3530003 	cmp	r3, #3
  121b74:	0a000007 	beq	121b98 <tcp_process+0x1d4>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
  121b78:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121b7c:	e5d3301e 	ldrb	r3, [r3, #30]
  121b80:	e3833002 	orr	r3, r3, #2
  121b84:	e6ef2073 	uxtb	r2, r3
  121b88:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121b8c:	e5c3201e 	strb	r2, [r3, #30]
    return ERR_OK;
  121b90:	e3a03000 	mov	r3, #0
  121b94:	ea0002e5 	b	122730 <tcp_process+0xd6c>
  }

  if ((pcb->flags & TF_RXCLOSED) == 0) {
  121b98:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121b9c:	e5d3301e 	ldrb	r3, [r3, #30]
  121ba0:	e2033010 	and	r3, r3, #16
  121ba4:	e3530000 	cmp	r3, #0
  121ba8:	1a000004 	bne	121bc0 <tcp_process+0x1fc>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
  121bac:	e3063a34 	movw	r3, #27188	; 0x6a34
  121bb0:	e3403057 	movt	r3, #87	; 0x57
  121bb4:	e5932000 	ldr	r2, [r3]
  121bb8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121bbc:	e5832024 	str	r2, [r3, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
  121bc0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121bc4:	e3a02000 	mov	r2, #0
  121bc8:	e5c320a2 	strb	r2, [r3, #162]	; 0xa2

  tcp_parseopt(pcb);
  121bcc:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  121bd0:	eb000ada 	bl	124740 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  121bd4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121bd8:	e5933014 	ldr	r3, [r3, #20]
  121bdc:	e2433002 	sub	r3, r3, #2
  121be0:	e3530007 	cmp	r3, #7
  121be4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  121be8:	ea0002c0 	b	1226f0 <tcp_process+0xd2c>
  121bec:	00121c0c 	.word	0x00121c0c
  121bf0:	00121f60 	.word	0x00121f60
  121bf4:	00122204 	.word	0x00122204
  121bf8:	0012224c 	.word	0x0012224c
  121bfc:	0012242c 	.word	0x0012242c
  121c00:	00122204 	.word	0x00122204
  121c04:	0012254c 	.word	0x0012254c
  121c08:	00122680 	.word	0x00122680
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  121c0c:	e30f324c 	movw	r3, #62028	; 0xf24c
  121c10:	e3403014 	movt	r3, #20
  121c14:	e5d33000 	ldrb	r3, [r3]
  121c18:	e2033010 	and	r3, r3, #16
  121c1c:	e3530000 	cmp	r3, #0
  121c20:	0a0000a4 	beq	121eb8 <tcp_process+0x4f4>
  121c24:	e30f324c 	movw	r3, #62028	; 0xf24c
  121c28:	e3403014 	movt	r3, #20
  121c2c:	e5d33000 	ldrb	r3, [r3]
  121c30:	e2033002 	and	r3, r3, #2
  121c34:	e3530000 	cmp	r3, #0
  121c38:	0a00009e 	beq	121eb8 <tcp_process+0x4f4>
        && (ackno == pcb->lastack + 1)) {
  121c3c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121c40:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  121c44:	e2832001 	add	r2, r3, #1
  121c48:	e30f3244 	movw	r3, #62020	; 0xf244
  121c4c:	e3403014 	movt	r3, #20
  121c50:	e5933000 	ldr	r3, [r3]
  121c54:	e1520003 	cmp	r2, r3
  121c58:	1a000096 	bne	121eb8 <tcp_process+0x4f4>
      pcb->rcv_nxt = seqno + 1;
  121c5c:	e30f3240 	movw	r3, #62016	; 0xf240
  121c60:	e3403014 	movt	r3, #20
  121c64:	e5933000 	ldr	r3, [r3]
  121c68:	e2832001 	add	r2, r3, #1
  121c6c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121c70:	e5832028 	str	r2, [r3, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
  121c74:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121c78:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  121c7c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121c80:	e5832030 	str	r2, [r3, #48]	; 0x30
      pcb->lastack = ackno;
  121c84:	e30f3244 	movw	r3, #62020	; 0xf244
  121c88:	e3403014 	movt	r3, #20
  121c8c:	e5932000 	ldr	r2, [r3]
  121c90:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121c94:	e5832048 	str	r2, [r3, #72]	; 0x48
      pcb->snd_wnd = tcphdr->wnd;
  121c98:	e30f3230 	movw	r3, #62000	; 0xf230
  121c9c:	e3403014 	movt	r3, #20
  121ca0:	e5933000 	ldr	r3, [r3]
  121ca4:	e1d330be 	ldrh	r3, [r3, #14]
  121ca8:	e6ff2073 	uxth	r2, r3
  121cac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121cb0:	e1c326b0 	strh	r2, [r3, #96]	; 0x60
      pcb->snd_wnd_max = pcb->snd_wnd;
  121cb4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121cb8:	e1d326b0 	ldrh	r2, [r3, #96]	; 0x60
  121cbc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121cc0:	e1c326b2 	strh	r2, [r3, #98]	; 0x62
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  121cc4:	e30f3240 	movw	r3, #62016	; 0xf240
  121cc8:	e3403014 	movt	r3, #20
  121ccc:	e5933000 	ldr	r3, [r3]
  121cd0:	e2432001 	sub	r2, r3, #1
  121cd4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121cd8:	e5832054 	str	r2, [r3, #84]	; 0x54
      pcb->state = ESTABLISHED;
  121cdc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121ce0:	e3a02004 	mov	r2, #4
  121ce4:	e5832014 	str	r2, [r3, #20]

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
  121ce8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121cec:	e1d323b6 	ldrh	r2, [r3, #54]	; 0x36
  121cf0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121cf4:	e2833004 	add	r3, r3, #4
  121cf8:	e1a01003 	mov	r1, r3
  121cfc:	e1a00002 	mov	r0, r2
  121d00:	ebfff95d 	bl	12027c <tcp_eff_send_mss_impl>
  121d04:	e1a03000 	mov	r3, r0
  121d08:	e1a02003 	mov	r2, r3
  121d0c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121d10:	e1c323b6 	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
  121d14:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121d18:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  121d1c:	e1a03083 	lsl	r3, r3, #1
  121d20:	e301211c 	movw	r2, #4380	; 0x111c
  121d24:	e1530002 	cmp	r3, r2
  121d28:	21a02003 	movcs	r2, r3
  121d2c:	31a02002 	movcc	r2, r2
  121d30:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121d34:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  121d38:	e1a03103 	lsl	r3, r3, #2
  121d3c:	e1520003 	cmp	r2, r3
  121d40:	31a03002 	movcc	r3, r2
  121d44:	21a03003 	movcs	r3, r3
  121d48:	e6ff2073 	uxth	r2, r3
  121d4c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121d50:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
                                   " ssthresh %"TCPWNDSIZE_F"\n",
                                   pcb->cwnd, pcb->ssthresh));
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  121d54:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121d58:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  121d5c:	e3530000 	cmp	r3, #0
  121d60:	1a000006 	bne	121d80 <tcp_process+0x3bc>
  121d64:	e308066c 	movw	r0, #34412	; 0x866c
  121d68:	e3400014 	movt	r0, #20
  121d6c:	ebff84e8 	bl	103114 <rt_kprintf>
  121d70:	e3001307 	movw	r1, #775	; 0x307
  121d74:	e30804d0 	movw	r0, #34000	; 0x84d0
  121d78:	e3400014 	movt	r0, #20
  121d7c:	ebffa4be 	bl	10b07c <sys_arch_assert>
      --pcb->snd_queuelen;
  121d80:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121d84:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  121d88:	e2433001 	sub	r3, r3, #1
  121d8c:	e6ff2073 	uxth	r2, r3
  121d90:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121d94:	e1c326b6 	strh	r2, [r3, #102]	; 0x66
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  121d98:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121d9c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  121da0:	e50b3008 	str	r3, [fp, #-8]
      if (rseg == NULL) {
  121da4:	e51b3008 	ldr	r3, [fp, #-8]
  121da8:	e3530000 	cmp	r3, #0
  121dac:	1a000011 	bne	121df8 <tcp_process+0x434>
        /* might happen if tcp_output fails in tcp_rexmit_rto()
           in which case the segment is on the unsent list */
        rseg = pcb->unsent;
  121db0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121db4:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  121db8:	e50b3008 	str	r3, [fp, #-8]
        LWIP_ASSERT("no segment to free", rseg != NULL);
  121dbc:	e51b3008 	ldr	r3, [fp, #-8]
  121dc0:	e3530000 	cmp	r3, #0
  121dc4:	1a000006 	bne	121de4 <tcp_process+0x420>
  121dc8:	e3080684 	movw	r0, #34436	; 0x8684
  121dcc:	e3400014 	movt	r0, #20
  121dd0:	ebff84cf 	bl	103114 <rt_kprintf>
  121dd4:	e300130f 	movw	r1, #783	; 0x30f
  121dd8:	e30804d0 	movw	r0, #34000	; 0x84d0
  121ddc:	e3400014 	movt	r0, #20
  121de0:	ebffa4a5 	bl	10b07c <sys_arch_assert>
        pcb->unsent = rseg->next;
  121de4:	e51b3008 	ldr	r3, [fp, #-8]
  121de8:	e5932000 	ldr	r2, [r3]
  121dec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121df0:	e583206c 	str	r2, [r3, #108]	; 0x6c
  121df4:	ea000003 	b	121e08 <tcp_process+0x444>
      } else {
        pcb->unacked = rseg->next;
  121df8:	e51b3008 	ldr	r3, [fp, #-8]
  121dfc:	e5932000 	ldr	r2, [r3]
  121e00:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121e04:	e5832070 	str	r2, [r3, #112]	; 0x70
      }
      tcp_seg_free(rseg);
  121e08:	e51b0008 	ldr	r0, [fp, #-8]
  121e0c:	ebfff61a 	bl	11f67c <tcp_seg_free>

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if (pcb->unacked == NULL) {
  121e10:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121e14:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  121e18:	e3530000 	cmp	r3, #0
  121e1c:	1a000003 	bne	121e30 <tcp_process+0x46c>
        pcb->rtime = -1;
  121e20:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121e24:	e3e02000 	mvn	r2, #0
  121e28:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
  121e2c:	ea000005 	b	121e48 <tcp_process+0x484>
      } else {
        pcb->rtime = 0;
  121e30:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121e34:	e3a02000 	mov	r2, #0
  121e38:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
        pcb->nrtx = 0;
  121e3c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121e40:	e3a02000 	mov	r2, #0
  121e44:	e5c32046 	strb	r2, [r3, #70]	; 0x46
      }

      /* Call the user specified function to call when successfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  121e48:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121e4c:	e5933088 	ldr	r3, [r3, #136]	; 0x88
  121e50:	e3530000 	cmp	r3, #0
  121e54:	0a000009 	beq	121e80 <tcp_process+0x4bc>
  121e58:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121e5c:	e5933088 	ldr	r3, [r3, #136]	; 0x88
  121e60:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  121e64:	e5920010 	ldr	r0, [r2, #16]
  121e68:	e3a02000 	mov	r2, #0
  121e6c:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  121e70:	e12fff33 	blx	r3
  121e74:	e1a03000 	mov	r3, r0
  121e78:	e54b300a 	strb	r3, [fp, #-10]
  121e7c:	ea000001 	b	121e88 <tcp_process+0x4c4>
  121e80:	e3a03000 	mov	r3, #0
  121e84:	e54b300a 	strb	r3, [fp, #-10]
      if (err == ERR_ABRT) {
  121e88:	e15b30da 	ldrsb	r3, [fp, #-10]
  121e8c:	e373000d 	cmn	r3, #13
  121e90:	1a000001 	bne	121e9c <tcp_process+0x4d8>
        return ERR_ABRT;
  121e94:	e3e0300c 	mvn	r3, #12
  121e98:	ea000224 	b	122730 <tcp_process+0xd6c>
      }
      tcp_ack_now(pcb);
  121e9c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121ea0:	e5d3301e 	ldrb	r3, [r3, #30]
  121ea4:	e3833002 	orr	r3, r3, #2
  121ea8:	e6ef2073 	uxtb	r2, r3
  121eac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121eb0:	e5c3201e 	strb	r2, [r3, #30]
      if (pcb->nrtx < TCP_SYNMAXRTX) {
        pcb->rtime = 0;
        tcp_rexmit_rto(pcb);
      }
    }
    break;
  121eb4:	ea00020f 	b	1226f8 <tcp_process+0xd34>
    else if (flags & TCP_ACK) {
  121eb8:	e30f324c 	movw	r3, #62028	; 0xf24c
  121ebc:	e3403014 	movt	r3, #20
  121ec0:	e5d33000 	ldrb	r3, [r3]
  121ec4:	e2033010 	and	r3, r3, #16
  121ec8:	e3530000 	cmp	r3, #0
  121ecc:	0a000209 	beq	1226f8 <tcp_process+0xd34>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  121ed0:	e30f3244 	movw	r3, #62020	; 0xf244
  121ed4:	e3403014 	movt	r3, #20
  121ed8:	e5930000 	ldr	r0, [r3]
  121edc:	e30f324a 	movw	r3, #62026	; 0xf24a
  121ee0:	e3403014 	movt	r3, #20
  121ee4:	e1d330b0 	ldrh	r3, [r3]
  121ee8:	e1a02003 	mov	r2, r3
  121eec:	e30f3240 	movw	r3, #62016	; 0xf240
  121ef0:	e3403014 	movt	r3, #20
  121ef4:	e5933000 	ldr	r3, [r3]
  121ef8:	e0821003 	add	r1, r2, r3
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  121efc:	e30f3230 	movw	r3, #62000	; 0xf230
  121f00:	e3403014 	movt	r3, #20
  121f04:	e5933000 	ldr	r3, [r3]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  121f08:	e1d330b2 	ldrh	r3, [r3, #2]
  121f0c:	e6ff2073 	uxth	r2, r3
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  121f10:	e30f3230 	movw	r3, #62000	; 0xf230
  121f14:	e3403014 	movt	r3, #20
  121f18:	e5933000 	ldr	r3, [r3]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  121f1c:	e1d330b0 	ldrh	r3, [r3]
  121f20:	e6ff3073 	uxth	r3, r3
  121f24:	e58d3004 	str	r3, [sp, #4]
  121f28:	e58d2000 	str	r2, [sp]
  121f2c:	e59f3808 	ldr	r3, [pc, #2056]	; 12273c <tcp_process+0xd78>
  121f30:	e59f2808 	ldr	r2, [pc, #2056]	; 122740 <tcp_process+0xd7c>
  121f34:	eb0012ee 	bl	126af4 <tcp_rst>
      if (pcb->nrtx < TCP_SYNMAXRTX) {
  121f38:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121f3c:	e5d33046 	ldrb	r3, [r3, #70]	; 0x46
  121f40:	e3530003 	cmp	r3, #3
  121f44:	8a0001eb 	bhi	1226f8 <tcp_process+0xd34>
        pcb->rtime = 0;
  121f48:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121f4c:	e3a02000 	mov	r2, #0
  121f50:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
        tcp_rexmit_rto(pcb);
  121f54:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  121f58:	eb001361 	bl	126ce4 <tcp_rexmit_rto>
    break;
  121f5c:	ea0001e5 	b	1226f8 <tcp_process+0xd34>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
  121f60:	e30f324c 	movw	r3, #62028	; 0xf24c
  121f64:	e3403014 	movt	r3, #20
  121f68:	e5d33000 	ldrb	r3, [r3]
  121f6c:	e2033010 	and	r3, r3, #16
  121f70:	e3530000 	cmp	r3, #0
  121f74:	0a000090 	beq	1221bc <tcp_process+0x7f8>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  121f78:	e30f3244 	movw	r3, #62020	; 0xf244
  121f7c:	e3403014 	movt	r3, #20
  121f80:	e5932000 	ldr	r2, [r3]
  121f84:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121f88:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  121f8c:	e0423003 	sub	r3, r2, r3
  121f90:	e2433001 	sub	r3, r3, #1
  121f94:	e3530000 	cmp	r3, #0
  121f98:	ba00006c 	blt	122150 <tcp_process+0x78c>
  121f9c:	e30f3244 	movw	r3, #62020	; 0xf244
  121fa0:	e3403014 	movt	r3, #20
  121fa4:	e5932000 	ldr	r2, [r3]
  121fa8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121fac:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  121fb0:	e0423003 	sub	r3, r2, r3
  121fb4:	e3530000 	cmp	r3, #0
  121fb8:	ca000064 	bgt	122150 <tcp_process+0x78c>
        pcb->state = ESTABLISHED;
  121fbc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121fc0:	e3a02004 	mov	r2, #4
  121fc4:	e5832014 	str	r2, [r3, #20]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->listener->accept != NULL",
  121fc8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121fcc:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  121fd0:	e3530000 	cmp	r3, #0
  121fd4:	0a00000b 	beq	122008 <tcp_process+0x644>
  121fd8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  121fdc:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  121fe0:	e593301c 	ldr	r3, [r3, #28]
  121fe4:	e3530000 	cmp	r3, #0
  121fe8:	1a000006 	bne	122008 <tcp_process+0x644>
  121fec:	e3080698 	movw	r0, #34456	; 0x8698
  121ff0:	e3400014 	movt	r0, #20
  121ff4:	ebff8446 	bl	103114 <rt_kprintf>
  121ff8:	e300133e 	movw	r1, #830	; 0x33e
  121ffc:	e30804d0 	movw	r0, #34000	; 0x84d0
  122000:	e3400014 	movt	r0, #20
  122004:	ebffa41c 	bl	10b07c <sys_arch_assert>
          (pcb->listener == NULL) || (pcb->listener->accept != NULL));
#endif
        if (pcb->listener == NULL) {
  122008:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12200c:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  122010:	e3530000 	cmp	r3, #0
  122014:	1a000002 	bne	122024 <tcp_process+0x660>
          /* listen pcb might be closed by now */
          err = ERR_VAL;
  122018:	e3e03005 	mvn	r3, #5
  12201c:	e54b300a 	strb	r3, [fp, #-10]
  122020:	ea000011 	b	12206c <tcp_process+0x6a8>
        } else
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
        {
          tcp_backlog_accepted(pcb);
          /* Call the accept function. */
          TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
  122024:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122028:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  12202c:	e593301c 	ldr	r3, [r3, #28]
  122030:	e3530000 	cmp	r3, #0
  122034:	0a00000a 	beq	122064 <tcp_process+0x6a0>
  122038:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12203c:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  122040:	e593301c 	ldr	r3, [r3, #28]
  122044:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  122048:	e5920010 	ldr	r0, [r2, #16]
  12204c:	e3a02000 	mov	r2, #0
  122050:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  122054:	e12fff33 	blx	r3
  122058:	e1a03000 	mov	r3, r0
  12205c:	e54b300a 	strb	r3, [fp, #-10]
  122060:	ea000001 	b	12206c <tcp_process+0x6a8>
  122064:	e3e0300f 	mvn	r3, #15
  122068:	e54b300a 	strb	r3, [fp, #-10]
        }
        if (err != ERR_OK) {
  12206c:	e15b30da 	ldrsb	r3, [fp, #-10]
  122070:	e3530000 	cmp	r3, #0
  122074:	0a000006 	beq	122094 <tcp_process+0x6d0>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
  122078:	e15b30da 	ldrsb	r3, [fp, #-10]
  12207c:	e373000d 	cmn	r3, #13
  122080:	0a000001 	beq	12208c <tcp_process+0x6c8>
            tcp_abort(pcb);
  122084:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  122088:	ebffeee3 	bl	11dc1c <tcp_abort>
          }
          return ERR_ABRT;
  12208c:	e3e0300c 	mvn	r3, #12
  122090:	ea0001a6 	b	122730 <tcp_process+0xd6c>
        }
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
  122094:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  122098:	eb000217 	bl	1228fc <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (recv_acked != 0) {
  12209c:	e30f3248 	movw	r3, #62024	; 0xf248
  1220a0:	e3403014 	movt	r3, #20
  1220a4:	e1d330b0 	ldrh	r3, [r3]
  1220a8:	e3530000 	cmp	r3, #0
  1220ac:	0a000007 	beq	1220d0 <tcp_process+0x70c>
          recv_acked--;
  1220b0:	e30f3248 	movw	r3, #62024	; 0xf248
  1220b4:	e3403014 	movt	r3, #20
  1220b8:	e1d330b0 	ldrh	r3, [r3]
  1220bc:	e2433001 	sub	r3, r3, #1
  1220c0:	e6ff2073 	uxth	r2, r3
  1220c4:	e30f3248 	movw	r3, #62024	; 0xf248
  1220c8:	e3403014 	movt	r3, #20
  1220cc:	e1c320b0 	strh	r2, [r3]
        }

        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
  1220d0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1220d4:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  1220d8:	e1a03083 	lsl	r3, r3, #1
  1220dc:	e301211c 	movw	r2, #4380	; 0x111c
  1220e0:	e1530002 	cmp	r3, r2
  1220e4:	21a02003 	movcs	r2, r3
  1220e8:	31a02002 	movcc	r2, r2
  1220ec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1220f0:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  1220f4:	e1a03103 	lsl	r3, r3, #2
  1220f8:	e1520003 	cmp	r2, r3
  1220fc:	31a03002 	movcc	r3, r2
  122100:	21a03003 	movcs	r3, r3
  122104:	e6ff2073 	uxth	r2, r3
  122108:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12210c:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                     " ssthresh %"TCPWNDSIZE_F"\n",
                                     pcb->cwnd, pcb->ssthresh));

        if (recv_flags & TF_GOT_FIN) {
  122110:	e30f324d 	movw	r3, #62029	; 0xf24d
  122114:	e3403014 	movt	r3, #20
  122118:	e5d33000 	ldrb	r3, [r3]
  12211c:	e2033020 	and	r3, r3, #32
  122120:	e3530000 	cmp	r3, #0
  122124:	0a000035 	beq	122200 <tcp_process+0x83c>
          tcp_ack_now(pcb);
  122128:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12212c:	e5d3301e 	ldrb	r3, [r3, #30]
  122130:	e3833002 	orr	r3, r3, #2
  122134:	e6ef2073 	uxtb	r2, r3
  122138:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12213c:	e5c3201e 	strb	r2, [r3, #30]
          pcb->state = CLOSE_WAIT;
  122140:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122144:	e3a02007 	mov	r2, #7
  122148:	e5832014 	str	r2, [r3, #20]
        if (recv_flags & TF_GOT_FIN) {
  12214c:	ea00002b 	b	122200 <tcp_process+0x83c>
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  122150:	e30f3244 	movw	r3, #62020	; 0xf244
  122154:	e3403014 	movt	r3, #20
  122158:	e5930000 	ldr	r0, [r3]
  12215c:	e30f324a 	movw	r3, #62026	; 0xf24a
  122160:	e3403014 	movt	r3, #20
  122164:	e1d330b0 	ldrh	r3, [r3]
  122168:	e1a02003 	mov	r2, r3
  12216c:	e30f3240 	movw	r3, #62016	; 0xf240
  122170:	e3403014 	movt	r3, #20
  122174:	e5933000 	ldr	r3, [r3]
  122178:	e0821003 	add	r1, r2, r3
          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  12217c:	e30f3230 	movw	r3, #62000	; 0xf230
  122180:	e3403014 	movt	r3, #20
  122184:	e5933000 	ldr	r3, [r3]
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  122188:	e1d330b2 	ldrh	r3, [r3, #2]
  12218c:	e6ff2073 	uxth	r2, r3
          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  122190:	e30f3230 	movw	r3, #62000	; 0xf230
  122194:	e3403014 	movt	r3, #20
  122198:	e5933000 	ldr	r3, [r3]
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
  12219c:	e1d330b0 	ldrh	r3, [r3]
  1221a0:	e6ff3073 	uxth	r3, r3
  1221a4:	e58d3004 	str	r3, [sp, #4]
  1221a8:	e58d2000 	str	r2, [sp]
  1221ac:	e59f3588 	ldr	r3, [pc, #1416]	; 12273c <tcp_process+0xd78>
  1221b0:	e59f2588 	ldr	r2, [pc, #1416]	; 122740 <tcp_process+0xd7c>
  1221b4:	eb00124e 	bl	126af4 <tcp_rst>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
  1221b8:	ea000150 	b	122700 <tcp_process+0xd3c>
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
  1221bc:	e30f324c 	movw	r3, #62028	; 0xf24c
  1221c0:	e3403014 	movt	r3, #20
  1221c4:	e5d33000 	ldrb	r3, [r3]
  1221c8:	e2033002 	and	r3, r3, #2
  1221cc:	e3530000 	cmp	r3, #0
  1221d0:	0a00014a 	beq	122700 <tcp_process+0xd3c>
  1221d4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1221d8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  1221dc:	e2432001 	sub	r2, r3, #1
  1221e0:	e30f3240 	movw	r3, #62016	; 0xf240
  1221e4:	e3403014 	movt	r3, #20
  1221e8:	e5933000 	ldr	r3, [r3]
  1221ec:	e1520003 	cmp	r2, r3
  1221f0:	1a000142 	bne	122700 <tcp_process+0xd3c>
      tcp_rexmit(pcb);
  1221f4:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  1221f8:	eb0012ea 	bl	126da8 <tcp_rexmit>
    break;
  1221fc:	ea00013f 	b	122700 <tcp_process+0xd3c>
  122200:	ea00013e 	b	122700 <tcp_process+0xd3c>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
  122204:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  122208:	eb0001bb 	bl	1228fc <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
  12220c:	e30f324d 	movw	r3, #62029	; 0xf24d
  122210:	e3403014 	movt	r3, #20
  122214:	e5d33000 	ldrb	r3, [r3]
  122218:	e2033020 	and	r3, r3, #32
  12221c:	e3530000 	cmp	r3, #0
  122220:	0a000138 	beq	122708 <tcp_process+0xd44>
      tcp_ack_now(pcb);
  122224:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122228:	e5d3301e 	ldrb	r3, [r3, #30]
  12222c:	e3833002 	orr	r3, r3, #2
  122230:	e6ef2073 	uxtb	r2, r3
  122234:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122238:	e5c3201e 	strb	r2, [r3, #30]
      pcb->state = CLOSE_WAIT;
  12223c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122240:	e3a02007 	mov	r2, #7
  122244:	e5832014 	str	r2, [r3, #20]
    }
    break;
  122248:	ea00012e 	b	122708 <tcp_process+0xd44>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  12224c:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  122250:	eb0001a9 	bl	1228fc <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
  122254:	e30f324d 	movw	r3, #62029	; 0xf24d
  122258:	e3403014 	movt	r3, #20
  12225c:	e5d33000 	ldrb	r3, [r3]
  122260:	e2033020 	and	r3, r3, #32
  122264:	e3530000 	cmp	r3, #0
  122268:	0a00005a 	beq	1223d8 <tcp_process+0xa14>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
  12226c:	e30f324c 	movw	r3, #62028	; 0xf24c
  122270:	e3403014 	movt	r3, #20
  122274:	e5d33000 	ldrb	r3, [r3]
  122278:	e2033010 	and	r3, r3, #16
  12227c:	e3530000 	cmp	r3, #0
  122280:	0a00004a 	beq	1223b0 <tcp_process+0x9ec>
  122284:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122288:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  12228c:	e30f3244 	movw	r3, #62020	; 0xf244
  122290:	e3403014 	movt	r3, #20
  122294:	e5933000 	ldr	r3, [r3]
  122298:	e1520003 	cmp	r2, r3
  12229c:	1a000043 	bne	1223b0 <tcp_process+0x9ec>
          pcb->unsent == NULL) {
  1222a0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1222a4:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
  1222a8:	e3530000 	cmp	r3, #0
  1222ac:	1a00003f 	bne	1223b0 <tcp_process+0x9ec>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  1222b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1222b4:	e5d3301e 	ldrb	r3, [r3, #30]
  1222b8:	e3833002 	orr	r3, r3, #2
  1222bc:	e6ef2073 	uxtb	r2, r3
  1222c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1222c4:	e5c3201e 	strb	r2, [r3, #30]
        tcp_pcb_purge(pcb);
  1222c8:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  1222cc:	ebfff72f 	bl	11ff90 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
  1222d0:	e3063a30 	movw	r3, #27184	; 0x6a30
  1222d4:	e3403057 	movt	r3, #87	; 0x57
  1222d8:	e5933000 	ldr	r3, [r3]
  1222dc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1222e0:	e1520003 	cmp	r2, r3
  1222e4:	1a000007 	bne	122308 <tcp_process+0x944>
  1222e8:	e3063a30 	movw	r3, #27184	; 0x6a30
  1222ec:	e3403057 	movt	r3, #87	; 0x57
  1222f0:	e5933000 	ldr	r3, [r3]
  1222f4:	e593200c 	ldr	r2, [r3, #12]
  1222f8:	e3063a30 	movw	r3, #27184	; 0x6a30
  1222fc:	e3403057 	movt	r3, #87	; 0x57
  122300:	e5832000 	str	r2, [r3]
  122304:	ea000014 	b	12235c <tcp_process+0x998>
  122308:	e3063a30 	movw	r3, #27184	; 0x6a30
  12230c:	e3403057 	movt	r3, #87	; 0x57
  122310:	e5933000 	ldr	r3, [r3]
  122314:	e50b3010 	str	r3, [fp, #-16]
  122318:	ea00000c 	b	122350 <tcp_process+0x98c>
  12231c:	e51b3010 	ldr	r3, [fp, #-16]
  122320:	e593300c 	ldr	r3, [r3, #12]
  122324:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  122328:	e1520003 	cmp	r2, r3
  12232c:	1a000004 	bne	122344 <tcp_process+0x980>
  122330:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122334:	e593200c 	ldr	r2, [r3, #12]
  122338:	e51b3010 	ldr	r3, [fp, #-16]
  12233c:	e583200c 	str	r2, [r3, #12]
  122340:	ea000005 	b	12235c <tcp_process+0x998>
  122344:	e51b3010 	ldr	r3, [fp, #-16]
  122348:	e593300c 	ldr	r3, [r3, #12]
  12234c:	e50b3010 	str	r3, [fp, #-16]
  122350:	e51b3010 	ldr	r3, [fp, #-16]
  122354:	e3530000 	cmp	r3, #0
  122358:	1affffef 	bne	12231c <tcp_process+0x958>
  12235c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122360:	e3a02000 	mov	r2, #0
  122364:	e583200c 	str	r2, [r3, #12]
  122368:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  12236c:	e3403057 	movt	r3, #87	; 0x57
  122370:	e3a02001 	mov	r2, #1
  122374:	e5c32000 	strb	r2, [r3]
        pcb->state = TIME_WAIT;
  122378:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12237c:	e3a0200a 	mov	r2, #10
  122380:	e5832014 	str	r2, [r3, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
  122384:	e3063a40 	movw	r3, #27200	; 0x6a40
  122388:	e3403057 	movt	r3, #87	; 0x57
  12238c:	e5932000 	ldr	r2, [r3]
  122390:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122394:	e583200c 	str	r2, [r3, #12]
  122398:	e3063a40 	movw	r3, #27200	; 0x6a40
  12239c:	e3403057 	movt	r3, #87	; 0x57
  1223a0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1223a4:	e5832000 	str	r2, [r3]
  1223a8:	eb001424 	bl	127440 <tcp_timer_needed>
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
               pcb->unsent == NULL) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  1223ac:	ea0000d7 	b	122710 <tcp_process+0xd4c>
        tcp_ack_now(pcb);
  1223b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1223b4:	e5d3301e 	ldrb	r3, [r3, #30]
  1223b8:	e3833002 	orr	r3, r3, #2
  1223bc:	e6ef2073 	uxtb	r2, r3
  1223c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1223c4:	e5c3201e 	strb	r2, [r3, #30]
        pcb->state = CLOSING;
  1223c8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1223cc:	e3a02008 	mov	r2, #8
  1223d0:	e5832014 	str	r2, [r3, #20]
    break;
  1223d4:	ea0000cd 	b	122710 <tcp_process+0xd4c>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
  1223d8:	e30f324c 	movw	r3, #62028	; 0xf24c
  1223dc:	e3403014 	movt	r3, #20
  1223e0:	e5d33000 	ldrb	r3, [r3]
  1223e4:	e2033010 	and	r3, r3, #16
  1223e8:	e3530000 	cmp	r3, #0
  1223ec:	0a0000c7 	beq	122710 <tcp_process+0xd4c>
  1223f0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1223f4:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  1223f8:	e30f3244 	movw	r3, #62020	; 0xf244
  1223fc:	e3403014 	movt	r3, #20
  122400:	e5933000 	ldr	r3, [r3]
  122404:	e1520003 	cmp	r2, r3
  122408:	1a0000c0 	bne	122710 <tcp_process+0xd4c>
               pcb->unsent == NULL) {
  12240c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122410:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
  122414:	e3530000 	cmp	r3, #0
  122418:	1a0000bc 	bne	122710 <tcp_process+0xd4c>
      pcb->state = FIN_WAIT_2;
  12241c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122420:	e3a02006 	mov	r2, #6
  122424:	e5832014 	str	r2, [r3, #20]
    break;
  122428:	ea0000b8 	b	122710 <tcp_process+0xd4c>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  12242c:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  122430:	eb000131 	bl	1228fc <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
  122434:	e30f324d 	movw	r3, #62029	; 0xf24d
  122438:	e3403014 	movt	r3, #20
  12243c:	e5d33000 	ldrb	r3, [r3]
  122440:	e2033020 	and	r3, r3, #32
  122444:	e3530000 	cmp	r3, #0
  122448:	0a0000b2 	beq	122718 <tcp_process+0xd54>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  12244c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122450:	e5d3301e 	ldrb	r3, [r3, #30]
  122454:	e3833002 	orr	r3, r3, #2
  122458:	e6ef2073 	uxtb	r2, r3
  12245c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122460:	e5c3201e 	strb	r2, [r3, #30]
      tcp_pcb_purge(pcb);
  122464:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  122468:	ebfff6c8 	bl	11ff90 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
  12246c:	e3063a30 	movw	r3, #27184	; 0x6a30
  122470:	e3403057 	movt	r3, #87	; 0x57
  122474:	e5933000 	ldr	r3, [r3]
  122478:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  12247c:	e1520003 	cmp	r2, r3
  122480:	1a000007 	bne	1224a4 <tcp_process+0xae0>
  122484:	e3063a30 	movw	r3, #27184	; 0x6a30
  122488:	e3403057 	movt	r3, #87	; 0x57
  12248c:	e5933000 	ldr	r3, [r3]
  122490:	e593200c 	ldr	r2, [r3, #12]
  122494:	e3063a30 	movw	r3, #27184	; 0x6a30
  122498:	e3403057 	movt	r3, #87	; 0x57
  12249c:	e5832000 	str	r2, [r3]
  1224a0:	ea000014 	b	1224f8 <tcp_process+0xb34>
  1224a4:	e3063a30 	movw	r3, #27184	; 0x6a30
  1224a8:	e3403057 	movt	r3, #87	; 0x57
  1224ac:	e5933000 	ldr	r3, [r3]
  1224b0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1224b4:	ea00000c 	b	1224ec <tcp_process+0xb28>
  1224b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1224bc:	e593300c 	ldr	r3, [r3, #12]
  1224c0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1224c4:	e1520003 	cmp	r2, r3
  1224c8:	1a000004 	bne	1224e0 <tcp_process+0xb1c>
  1224cc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1224d0:	e593200c 	ldr	r2, [r3, #12]
  1224d4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1224d8:	e583200c 	str	r2, [r3, #12]
  1224dc:	ea000005 	b	1224f8 <tcp_process+0xb34>
  1224e0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1224e4:	e593300c 	ldr	r3, [r3, #12]
  1224e8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1224ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1224f0:	e3530000 	cmp	r3, #0
  1224f4:	1affffef 	bne	1224b8 <tcp_process+0xaf4>
  1224f8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1224fc:	e3a02000 	mov	r2, #0
  122500:	e583200c 	str	r2, [r3, #12]
  122504:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  122508:	e3403057 	movt	r3, #87	; 0x57
  12250c:	e3a02001 	mov	r2, #1
  122510:	e5c32000 	strb	r2, [r3]
      pcb->state = TIME_WAIT;
  122514:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122518:	e3a0200a 	mov	r2, #10
  12251c:	e5832014 	str	r2, [r3, #20]
      TCP_REG(&tcp_tw_pcbs, pcb);
  122520:	e3063a40 	movw	r3, #27200	; 0x6a40
  122524:	e3403057 	movt	r3, #87	; 0x57
  122528:	e5932000 	ldr	r2, [r3]
  12252c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122530:	e583200c 	str	r2, [r3, #12]
  122534:	e3063a40 	movw	r3, #27200	; 0x6a40
  122538:	e3403057 	movt	r3, #87	; 0x57
  12253c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  122540:	e5832000 	str	r2, [r3]
  122544:	eb0013bd 	bl	127440 <tcp_timer_needed>
    }
    break;
  122548:	ea000072 	b	122718 <tcp_process+0xd54>
  case CLOSING:
    tcp_receive(pcb);
  12254c:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  122550:	eb0000e9 	bl	1228fc <tcp_receive>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
  122554:	e30f324c 	movw	r3, #62028	; 0xf24c
  122558:	e3403014 	movt	r3, #20
  12255c:	e5d33000 	ldrb	r3, [r3]
  122560:	e2033010 	and	r3, r3, #16
  122564:	e3530000 	cmp	r3, #0
  122568:	0a00006c 	beq	122720 <tcp_process+0xd5c>
  12256c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122570:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  122574:	e30f3244 	movw	r3, #62020	; 0xf244
  122578:	e3403014 	movt	r3, #20
  12257c:	e5933000 	ldr	r3, [r3]
  122580:	e1520003 	cmp	r2, r3
  122584:	1a000065 	bne	122720 <tcp_process+0xd5c>
  122588:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12258c:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  122590:	e3530000 	cmp	r3, #0
  122594:	1a000061 	bne	122720 <tcp_process+0xd5c>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
  122598:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  12259c:	ebfff67b 	bl	11ff90 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
  1225a0:	e3063a30 	movw	r3, #27184	; 0x6a30
  1225a4:	e3403057 	movt	r3, #87	; 0x57
  1225a8:	e5933000 	ldr	r3, [r3]
  1225ac:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1225b0:	e1520003 	cmp	r2, r3
  1225b4:	1a000007 	bne	1225d8 <tcp_process+0xc14>
  1225b8:	e3063a30 	movw	r3, #27184	; 0x6a30
  1225bc:	e3403057 	movt	r3, #87	; 0x57
  1225c0:	e5933000 	ldr	r3, [r3]
  1225c4:	e593200c 	ldr	r2, [r3, #12]
  1225c8:	e3063a30 	movw	r3, #27184	; 0x6a30
  1225cc:	e3403057 	movt	r3, #87	; 0x57
  1225d0:	e5832000 	str	r2, [r3]
  1225d4:	ea000014 	b	12262c <tcp_process+0xc68>
  1225d8:	e3063a30 	movw	r3, #27184	; 0x6a30
  1225dc:	e3403057 	movt	r3, #87	; 0x57
  1225e0:	e5933000 	ldr	r3, [r3]
  1225e4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  1225e8:	ea00000c 	b	122620 <tcp_process+0xc5c>
  1225ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1225f0:	e593300c 	ldr	r3, [r3, #12]
  1225f4:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1225f8:	e1520003 	cmp	r2, r3
  1225fc:	1a000004 	bne	122614 <tcp_process+0xc50>
  122600:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122604:	e593200c 	ldr	r2, [r3, #12]
  122608:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12260c:	e583200c 	str	r2, [r3, #12]
  122610:	ea000005 	b	12262c <tcp_process+0xc68>
  122614:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  122618:	e593300c 	ldr	r3, [r3, #12]
  12261c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  122620:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  122624:	e3530000 	cmp	r3, #0
  122628:	1affffef 	bne	1225ec <tcp_process+0xc28>
  12262c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122630:	e3a02000 	mov	r2, #0
  122634:	e583200c 	str	r2, [r3, #12]
  122638:	e3063a2c 	movw	r3, #27180	; 0x6a2c
  12263c:	e3403057 	movt	r3, #87	; 0x57
  122640:	e3a02001 	mov	r2, #1
  122644:	e5c32000 	strb	r2, [r3]
      pcb->state = TIME_WAIT;
  122648:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12264c:	e3a0200a 	mov	r2, #10
  122650:	e5832014 	str	r2, [r3, #20]
      TCP_REG(&tcp_tw_pcbs, pcb);
  122654:	e3063a40 	movw	r3, #27200	; 0x6a40
  122658:	e3403057 	movt	r3, #87	; 0x57
  12265c:	e5932000 	ldr	r2, [r3]
  122660:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  122664:	e583200c 	str	r2, [r3, #12]
  122668:	e3063a40 	movw	r3, #27200	; 0x6a40
  12266c:	e3403057 	movt	r3, #87	; 0x57
  122670:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  122674:	e5832000 	str	r2, [r3]
  122678:	eb001370 	bl	127440 <tcp_timer_needed>
    }
    break;
  12267c:	ea000027 	b	122720 <tcp_process+0xd5c>
  case LAST_ACK:
    tcp_receive(pcb);
  122680:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  122684:	eb00009c 	bl	1228fc <tcp_receive>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
  122688:	e30f324c 	movw	r3, #62028	; 0xf24c
  12268c:	e3403014 	movt	r3, #20
  122690:	e5d33000 	ldrb	r3, [r3]
  122694:	e2033010 	and	r3, r3, #16
  122698:	e3530000 	cmp	r3, #0
  12269c:	0a000021 	beq	122728 <tcp_process+0xd64>
  1226a0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1226a4:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  1226a8:	e30f3244 	movw	r3, #62020	; 0xf244
  1226ac:	e3403014 	movt	r3, #20
  1226b0:	e5933000 	ldr	r3, [r3]
  1226b4:	e1520003 	cmp	r2, r3
  1226b8:	1a00001a 	bne	122728 <tcp_process+0xd64>
  1226bc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1226c0:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  1226c4:	e3530000 	cmp	r3, #0
  1226c8:	1a000016 	bne	122728 <tcp_process+0xd64>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
  1226cc:	e30f324d 	movw	r3, #62029	; 0xf24d
  1226d0:	e3403014 	movt	r3, #20
  1226d4:	e5d33000 	ldrb	r3, [r3]
  1226d8:	e3833010 	orr	r3, r3, #16
  1226dc:	e6ef2073 	uxtb	r2, r3
  1226e0:	e30f324d 	movw	r3, #62029	; 0xf24d
  1226e4:	e3403014 	movt	r3, #20
  1226e8:	e5c32000 	strb	r2, [r3]
    }
    break;
  1226ec:	ea00000d 	b	122728 <tcp_process+0xd64>
  default:
    break;
  1226f0:	e320f000 	nop	{0}
  1226f4:	ea00000c 	b	12272c <tcp_process+0xd68>
    break;
  1226f8:	e320f000 	nop	{0}
  1226fc:	ea00000a 	b	12272c <tcp_process+0xd68>
    break;
  122700:	e320f000 	nop	{0}
  122704:	ea000008 	b	12272c <tcp_process+0xd68>
    break;
  122708:	e320f000 	nop	{0}
  12270c:	ea000006 	b	12272c <tcp_process+0xd68>
    break;
  122710:	e320f000 	nop	{0}
  122714:	ea000004 	b	12272c <tcp_process+0xd68>
    break;
  122718:	e320f000 	nop	{0}
  12271c:	ea000002 	b	12272c <tcp_process+0xd68>
    break;
  122720:	e320f000 	nop	{0}
  122724:	ea000000 	b	12272c <tcp_process+0xd68>
    break;
  122728:	e320f000 	nop	{0}
  }
  return ERR_OK;
  12272c:	e3a03000 	mov	r3, #0
}
  122730:	e1a00003 	mov	r0, r3
  122734:	e24bd004 	sub	sp, fp, #4
  122738:	e8bd8800 	pop	{fp, pc}
  12273c:	001505f8 	.word	0x001505f8
  122740:	001505fc 	.word	0x001505fc

00122744 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
  122744:	e92d4810 	push	{r4, fp, lr}
  122748:	e28db008 	add	fp, sp, #8
  12274c:	e24dd014 	sub	sp, sp, #20
  122750:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  122754:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  122758:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12275c:	e593300c 	ldr	r3, [r3, #12]
  122760:	e1d330bc 	ldrh	r3, [r3, #12]
  122764:	e6ff3073 	uxth	r3, r3
  122768:	e1a00003 	mov	r0, r3
  12276c:	ebffd019 	bl	1167d8 <lwip_htons>
  122770:	e1a03000 	mov	r3, r0
  122774:	e2033001 	and	r3, r3, #1
  122778:	e3530000 	cmp	r3, #0
  12277c:	0a000022 	beq	12280c <tcp_oos_insert_segment+0xc8>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
  122780:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  122784:	ebfff3aa 	bl	11f634 <tcp_segs_free>
    next = NULL;
  122788:	e3a03000 	mov	r3, #0
  12278c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  122790:	ea000053 	b	1228e4 <tcp_oos_insert_segment+0x1a0>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
  122794:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  122798:	e593300c 	ldr	r3, [r3, #12]
  12279c:	e1d330bc 	ldrh	r3, [r3, #12]
  1227a0:	e6ff3073 	uxth	r3, r3
  1227a4:	e1a00003 	mov	r0, r3
  1227a8:	ebffd00a 	bl	1167d8 <lwip_htons>
  1227ac:	e1a03000 	mov	r3, r0
  1227b0:	e2033001 	and	r3, r3, #1
  1227b4:	e3530000 	cmp	r3, #0
  1227b8:	0a00000c 	beq	1227f0 <tcp_oos_insert_segment+0xac>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
  1227bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1227c0:	e593300c 	ldr	r3, [r3, #12]
  1227c4:	e1d330bc 	ldrh	r3, [r3, #12]
  1227c8:	e6ff4073 	uxth	r4, r3
  1227cc:	e3a00001 	mov	r0, #1
  1227d0:	ebffd000 	bl	1167d8 <lwip_htons>
  1227d4:	e1a03000 	mov	r3, r0
  1227d8:	e1a02003 	mov	r2, r3
  1227dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1227e0:	e593300c 	ldr	r3, [r3, #12]
  1227e4:	e1842002 	orr	r2, r4, r2
  1227e8:	e6ff2072 	uxth	r2, r2
  1227ec:	e1c320bc 	strh	r2, [r3, #12]
      }
      old_seg = next;
  1227f0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1227f4:	e50b3010 	str	r3, [fp, #-16]
      next = next->next;
  1227f8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1227fc:	e5933000 	ldr	r3, [r3]
  122800:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
      tcp_seg_free(old_seg);
  122804:	e51b0010 	ldr	r0, [fp, #-16]
  122808:	ebfff39b 	bl	11f67c <tcp_seg_free>
    while (next &&
  12280c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  122810:	e3530000 	cmp	r3, #0
  122814:	0a00000f 	beq	122858 <tcp_oos_insert_segment+0x114>
           TCP_SEQ_GEQ((seqno + cseg->len),
  122818:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12281c:	e1d330b8 	ldrh	r3, [r3, #8]
  122820:	e1a02003 	mov	r2, r3
  122824:	e30f3240 	movw	r3, #62016	; 0xf240
  122828:	e3403014 	movt	r3, #20
  12282c:	e5933000 	ldr	r3, [r3]
  122830:	e0822003 	add	r2, r2, r3
  122834:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  122838:	e593300c 	ldr	r3, [r3, #12]
  12283c:	e5933004 	ldr	r3, [r3, #4]
  122840:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  122844:	e1d110b8 	ldrh	r1, [r1, #8]
  122848:	e0833001 	add	r3, r3, r1
  12284c:	e0423003 	sub	r3, r2, r3
    while (next &&
  122850:	e3530000 	cmp	r3, #0
  122854:	aaffffce 	bge	122794 <tcp_oos_insert_segment+0x50>
    }
    if (next &&
  122858:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12285c:	e3530000 	cmp	r3, #0
  122860:	0a00001f 	beq	1228e4 <tcp_oos_insert_segment+0x1a0>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  122864:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  122868:	e1d330b8 	ldrh	r3, [r3, #8]
  12286c:	e1a02003 	mov	r2, r3
  122870:	e30f3240 	movw	r3, #62016	; 0xf240
  122874:	e3403014 	movt	r3, #20
  122878:	e5933000 	ldr	r3, [r3]
  12287c:	e0822003 	add	r2, r2, r3
  122880:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  122884:	e593300c 	ldr	r3, [r3, #12]
  122888:	e5933004 	ldr	r3, [r3, #4]
  12288c:	e0423003 	sub	r3, r2, r3
    if (next &&
  122890:	e3530000 	cmp	r3, #0
  122894:	da000012 	ble	1228e4 <tcp_oos_insert_segment+0x1a0>
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  122898:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12289c:	e593300c 	ldr	r3, [r3, #12]
  1228a0:	e5933004 	ldr	r3, [r3, #4]
  1228a4:	e6ff2073 	uxth	r2, r3
  1228a8:	e30f3240 	movw	r3, #62016	; 0xf240
  1228ac:	e3403014 	movt	r3, #20
  1228b0:	e5933000 	ldr	r3, [r3]
  1228b4:	e6ff3073 	uxth	r3, r3
  1228b8:	e0423003 	sub	r3, r2, r3
  1228bc:	e6ff2073 	uxth	r2, r3
  1228c0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1228c4:	e1c320b8 	strh	r2, [r3, #8]
      pbuf_realloc(cseg->p, cseg->len);
  1228c8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1228cc:	e5932004 	ldr	r2, [r3, #4]
  1228d0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1228d4:	e1d330b8 	ldrh	r3, [r3, #8]
  1228d8:	e1a01003 	mov	r1, r3
  1228dc:	e1a00002 	mov	r0, r2
  1228e0:	ebffe0aa 	bl	11ab90 <pbuf_realloc>
    }
  }
  cseg->next = next;
  1228e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1228e8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1228ec:	e5832000 	str	r2, [r3]
}
  1228f0:	e320f000 	nop	{0}
  1228f4:	e24bd008 	sub	sp, fp, #8
  1228f8:	e8bd8810 	pop	{r4, fp, pc}

001228fc <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
  1228fc:	e92d4870 	push	{r4, r5, r6, fp, lr}
  122900:	e28db010 	add	fp, sp, #16
  122904:	e24dd034 	sub	sp, sp, #52	; 0x34
  122908:	e50b0040 	str	r0, [fp, #-64]	; 0xffffffc0
#endif /* TCP_QUEUE_OOSEQ */
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
  12290c:	e3a03000 	mov	r3, #0
  122910:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
  122914:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122918:	e5933014 	ldr	r3, [r3, #20]
  12291c:	e3530003 	cmp	r3, #3
  122920:	8a000006 	bhi	122940 <tcp_receive+0x44>
  122924:	e30806b8 	movw	r0, #34488	; 0x86b8
  122928:	e3400014 	movt	r0, #20
  12292c:	ebff81f8 	bl	103114 <rt_kprintf>
  122930:	e30013f5 	movw	r1, #1013	; 0x3f5
  122934:	e30804d0 	movw	r0, #34000	; 0x84d0
  122938:	e3400014 	movt	r0, #20
  12293c:	ebffa1ce 	bl	10b07c <sys_arch_assert>

  if (flags & TCP_ACK) {
  122940:	e30f324c 	movw	r3, #62028	; 0xf24c
  122944:	e3403014 	movt	r3, #20
  122948:	e5d33000 	ldrb	r3, [r3]
  12294c:	e2033010 	and	r3, r3, #16
  122950:	e3530000 	cmp	r3, #0
  122954:	0a000268 	beq	1232fc <tcp_receive+0xa00>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
  122958:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  12295c:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  122960:	e1a02003 	mov	r2, r3
  122964:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122968:	e5933058 	ldr	r3, [r3, #88]	; 0x58
  12296c:	e0823003 	add	r3, r2, r3
  122970:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  122974:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122978:	e5932054 	ldr	r2, [r3, #84]	; 0x54
  12297c:	e30f3240 	movw	r3, #62016	; 0xf240
  122980:	e3403014 	movt	r3, #20
  122984:	e5933000 	ldr	r3, [r3]
  122988:	e0423003 	sub	r3, r2, r3
  12298c:	e3530000 	cmp	r3, #0
  122990:	ba00001e 	blt	122a10 <tcp_receive+0x114>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  122994:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122998:	e5932054 	ldr	r2, [r3, #84]	; 0x54
  12299c:	e30f3240 	movw	r3, #62016	; 0xf240
  1229a0:	e3403014 	movt	r3, #20
  1229a4:	e5933000 	ldr	r3, [r3]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  1229a8:	e1520003 	cmp	r2, r3
  1229ac:	1a000007 	bne	1229d0 <tcp_receive+0xd4>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  1229b0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1229b4:	e5932058 	ldr	r2, [r3, #88]	; 0x58
  1229b8:	e30f3244 	movw	r3, #62020	; 0xf244
  1229bc:	e3403014 	movt	r3, #20
  1229c0:	e5933000 	ldr	r3, [r3]
  1229c4:	e0423003 	sub	r3, r2, r3
  1229c8:	e3530000 	cmp	r3, #0
  1229cc:	ba00000f 	blt	122a10 <tcp_receive+0x114>
       (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
  1229d0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1229d4:	e5932058 	ldr	r2, [r3, #88]	; 0x58
  1229d8:	e30f3244 	movw	r3, #62020	; 0xf244
  1229dc:	e3403014 	movt	r3, #20
  1229e0:	e5933000 	ldr	r3, [r3]
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  1229e4:	e1520003 	cmp	r2, r3
  1229e8:	1a000039 	bne	122ad4 <tcp_receive+0x1d8>
       (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
  1229ec:	e30f3230 	movw	r3, #62000	; 0xf230
  1229f0:	e3403014 	movt	r3, #20
  1229f4:	e5933000 	ldr	r3, [r3]
  1229f8:	e1d330be 	ldrh	r3, [r3, #14]
  1229fc:	e6ff2073 	uxth	r2, r3
  122a00:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a04:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  122a08:	e1520003 	cmp	r2, r3
  122a0c:	9a000030 	bls	122ad4 <tcp_receive+0x1d8>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
  122a10:	e30f3230 	movw	r3, #62000	; 0xf230
  122a14:	e3403014 	movt	r3, #20
  122a18:	e5933000 	ldr	r3, [r3]
  122a1c:	e1d330be 	ldrh	r3, [r3, #14]
  122a20:	e6ff2073 	uxth	r2, r3
  122a24:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a28:	e1c326b0 	strh	r2, [r3, #96]	; 0x60
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
  122a2c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a30:	e1d326b2 	ldrh	r2, [r3, #98]	; 0x62
  122a34:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a38:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  122a3c:	e1520003 	cmp	r2, r3
  122a40:	2a000003 	bcs	122a54 <tcp_receive+0x158>
        pcb->snd_wnd_max = pcb->snd_wnd;
  122a44:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a48:	e1d326b0 	ldrh	r2, [r3, #96]	; 0x60
  122a4c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a50:	e1c326b2 	strh	r2, [r3, #98]	; 0x62
      }
      pcb->snd_wl1 = seqno;
  122a54:	e30f3240 	movw	r3, #62016	; 0xf240
  122a58:	e3403014 	movt	r3, #20
  122a5c:	e5932000 	ldr	r2, [r3]
  122a60:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a64:	e5832054 	str	r2, [r3, #84]	; 0x54
      pcb->snd_wl2 = ackno;
  122a68:	e30f3244 	movw	r3, #62020	; 0xf244
  122a6c:	e3403014 	movt	r3, #20
  122a70:	e5932000 	ldr	r2, [r3]
  122a74:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a78:	e5832058 	str	r2, [r3, #88]	; 0x58
      if (pcb->snd_wnd == 0) {
  122a7c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a80:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  122a84:	e3530000 	cmp	r3, #0
  122a88:	1a00000a 	bne	122ab8 <tcp_receive+0x1bc>
        if (pcb->persist_backoff == 0) {
  122a8c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122a90:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
  122a94:	e3530000 	cmp	r3, #0
  122a98:	1a00000d 	bne	122ad4 <tcp_receive+0x1d8>
          /* start persist timer */
          pcb->persist_cnt = 0;
  122a9c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122aa0:	e3a02000 	mov	r2, #0
  122aa4:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
          pcb->persist_backoff = 1;
  122aa8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122aac:	e3a02001 	mov	r2, #1
  122ab0:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1
  122ab4:	ea000006 	b	122ad4 <tcp_receive+0x1d8>
        }
      } else if (pcb->persist_backoff > 0) {
  122ab8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122abc:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
  122ac0:	e3530000 	cmp	r3, #0
  122ac4:	0a000002 	beq	122ad4 <tcp_receive+0x1d8>
        /* stop persist timer */
          pcb->persist_backoff = 0;
  122ac8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122acc:	e3a02000 	mov	r2, #0
  122ad0:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
  122ad4:	e30f3244 	movw	r3, #62020	; 0xf244
  122ad8:	e3403014 	movt	r3, #20
  122adc:	e5932000 	ldr	r2, [r3]
  122ae0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122ae4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  122ae8:	e0423003 	sub	r3, r2, r3
  122aec:	e3530000 	cmp	r3, #0
  122af0:	ca000047 	bgt	122c14 <tcp_receive+0x318>
      /* Clause 2 */
      if (tcplen == 0) {
  122af4:	e30f324a 	movw	r3, #62026	; 0xf24a
  122af8:	e3403014 	movt	r3, #20
  122afc:	e1d330b0 	ldrh	r3, [r3]
  122b00:	e3530000 	cmp	r3, #0
  122b04:	1a00003b 	bne	122bf8 <tcp_receive+0x2fc>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
  122b08:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122b0c:	e5933058 	ldr	r3, [r3, #88]	; 0x58
  122b10:	e51b2040 	ldr	r2, [fp, #-64]	; 0xffffffc0
  122b14:	e1d226b0 	ldrh	r2, [r2, #96]	; 0x60
  122b18:	e0833002 	add	r3, r3, r2
  122b1c:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  122b20:	e1520003 	cmp	r2, r3
  122b24:	1a000033 	bne	122bf8 <tcp_receive+0x2fc>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
  122b28:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122b2c:	e1d333f4 	ldrsh	r3, [r3, #52]	; 0x34
  122b30:	e3530000 	cmp	r3, #0
  122b34:	ba00002f 	blt	122bf8 <tcp_receive+0x2fc>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
  122b38:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122b3c:	e5932048 	ldr	r2, [r3, #72]	; 0x48
  122b40:	e30f3244 	movw	r3, #62020	; 0xf244
  122b44:	e3403014 	movt	r3, #20
  122b48:	e5933000 	ldr	r3, [r3]
  122b4c:	e1520003 	cmp	r2, r3
  122b50:	1a000028 	bne	122bf8 <tcp_receive+0x2fc>
              found_dupack = 1;
  122b54:	e3a03001 	mov	r3, #1
  122b58:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
  122b5c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122b60:	e5d33047 	ldrb	r3, [r3, #71]	; 0x47
  122b64:	e35300ff 	cmp	r3, #255	; 0xff
  122b68:	0a000005 	beq	122b84 <tcp_receive+0x288>
                ++pcb->dupacks;
  122b6c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122b70:	e5d33047 	ldrb	r3, [r3, #71]	; 0x47
  122b74:	e2833001 	add	r3, r3, #1
  122b78:	e6ef2073 	uxtb	r2, r3
  122b7c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122b80:	e5c32047 	strb	r2, [r3, #71]	; 0x47
              }
              if (pcb->dupacks > 3) {
  122b84:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122b88:	e5d33047 	ldrb	r3, [r3, #71]	; 0x47
  122b8c:	e3530003 	cmp	r3, #3
  122b90:	9a000012 	bls	122be0 <tcp_receive+0x2e4>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  122b94:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122b98:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
  122b9c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122ba0:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  122ba4:	e0823003 	add	r3, r2, r3
  122ba8:	e6ff2073 	uxth	r2, r3
  122bac:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122bb0:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
  122bb4:	e1520003 	cmp	r2, r3
  122bb8:	9a00000e 	bls	122bf8 <tcp_receive+0x2fc>
                  pcb->cwnd += pcb->mss;
  122bbc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122bc0:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
  122bc4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122bc8:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  122bcc:	e0823003 	add	r3, r2, r3
  122bd0:	e6ff2073 	uxth	r2, r3
  122bd4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122bd8:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
  122bdc:	ea000005 	b	122bf8 <tcp_receive+0x2fc>
                }
              } else if (pcb->dupacks == 3) {
  122be0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122be4:	e5d33047 	ldrb	r3, [r3, #71]	; 0x47
  122be8:	e3530003 	cmp	r3, #3
  122bec:	1a000001 	bne	122bf8 <tcp_receive+0x2fc>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
  122bf0:	e51b0040 	ldr	r0, [fp, #-64]	; 0xffffffc0
  122bf4:	eb0010bb 	bl	126ee8 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
  122bf8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  122bfc:	e3530000 	cmp	r3, #0
  122c00:	1a000136 	bne	1230e0 <tcp_receive+0x7e4>
        pcb->dupacks = 0;
  122c04:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122c08:	e3a02000 	mov	r2, #0
  122c0c:	e5c32047 	strb	r2, [r3, #71]	; 0x47
  122c10:	ea000132 	b	1230e0 <tcp_receive+0x7e4>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  122c14:	e30f3244 	movw	r3, #62020	; 0xf244
  122c18:	e3403014 	movt	r3, #20
  122c1c:	e5932000 	ldr	r2, [r3]
  122c20:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122c24:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  122c28:	e0423003 	sub	r3, r2, r3
  122c2c:	e2433001 	sub	r3, r3, #1
  122c30:	e3530000 	cmp	r3, #0
  122c34:	ba0000dc 	blt	122fac <tcp_receive+0x6b0>
  122c38:	e30f3244 	movw	r3, #62020	; 0xf244
  122c3c:	e3403014 	movt	r3, #20
  122c40:	e5932000 	ldr	r2, [r3]
  122c44:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122c48:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  122c4c:	e0423003 	sub	r3, r2, r3
  122c50:	e3530000 	cmp	r3, #0
  122c54:	ca0000d4 	bgt	122fac <tcp_receive+0x6b0>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  122c58:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122c5c:	e5d3301e 	ldrb	r3, [r3, #30]
  122c60:	e2033004 	and	r3, r3, #4
  122c64:	e3530000 	cmp	r3, #0
  122c68:	0a000009 	beq	122c94 <tcp_receive+0x398>
        pcb->flags &= ~TF_INFR;
  122c6c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122c70:	e5d3301e 	ldrb	r3, [r3, #30]
  122c74:	e3c33004 	bic	r3, r3, #4
  122c78:	e6ef2073 	uxtb	r2, r3
  122c7c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122c80:	e5c3201e 	strb	r2, [r3, #30]
        pcb->cwnd = pcb->ssthresh;
  122c84:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122c88:	e1d324be 	ldrh	r2, [r3, #78]	; 0x4e
  122c8c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122c90:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  122c94:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122c98:	e3a02000 	mov	r2, #0
  122c9c:	e5c32046 	strb	r2, [r3, #70]	; 0x46

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  122ca0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122ca4:	e1d334f0 	ldrsh	r3, [r3, #64]	; 0x40
  122ca8:	e1a031c3 	asr	r3, r3, #3
  122cac:	e6bf3073 	sxth	r3, r3
  122cb0:	e6ff2073 	uxth	r2, r3
  122cb4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122cb8:	e1d334f2 	ldrsh	r3, [r3, #66]	; 0x42
  122cbc:	e6ff3073 	uxth	r3, r3
  122cc0:	e0823003 	add	r3, r2, r3
  122cc4:	e6ff3073 	uxth	r3, r3
  122cc8:	e6bf2073 	sxth	r2, r3
  122ccc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122cd0:	e1c324b4 	strh	r2, [r3, #68]	; 0x44

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  122cd4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122cd8:	e3a02000 	mov	r2, #0
  122cdc:	e5c32047 	strb	r2, [r3, #71]	; 0x47
      pcb->lastack = ackno;
  122ce0:	e30f3244 	movw	r3, #62020	; 0xf244
  122ce4:	e3403014 	movt	r3, #20
  122ce8:	e5932000 	ldr	r2, [r3]
  122cec:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122cf0:	e5832048 	str	r2, [r3, #72]	; 0x48

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  122cf4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122cf8:	e5933014 	ldr	r3, [r3, #20]
  122cfc:	e3530003 	cmp	r3, #3
  122d00:	9a000075 	bls	122edc <tcp_receive+0x5e0>
        if (pcb->cwnd < pcb->ssthresh) {
  122d04:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d08:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
  122d0c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d10:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
  122d14:	e1520003 	cmp	r2, r3
  122d18:	2a000012 	bcs	122d68 <tcp_receive+0x46c>
          if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  122d1c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d20:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
  122d24:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d28:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  122d2c:	e0823003 	add	r3, r2, r3
  122d30:	e6ff2073 	uxth	r2, r3
  122d34:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d38:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
  122d3c:	e1520003 	cmp	r2, r3
  122d40:	9a000065 	bls	122edc <tcp_receive+0x5e0>
            pcb->cwnd += pcb->mss;
  122d44:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d48:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
  122d4c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d50:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  122d54:	e0823003 	add	r3, r2, r3
  122d58:	e6ff2073 	uxth	r2, r3
  122d5c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d60:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
  122d64:	ea00005c 	b	122edc <tcp_receive+0x5e0>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
        } else {
          tcpwnd_size_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  122d68:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d6c:	e1d344bc 	ldrh	r4, [r3, #76]	; 0x4c
  122d70:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d74:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  122d78:	e1a02003 	mov	r2, r3
  122d7c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d80:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  122d84:	e0020293 	mul	r2, r3, r2
  122d88:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122d8c:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
  122d90:	e1a01003 	mov	r1, r3
  122d94:	e1a00002 	mov	r0, r2
  122d98:	eb0057b8 	bl	138c80 <__divsi3>
  122d9c:	e1a03000 	mov	r3, r0
  122da0:	e6ff3073 	uxth	r3, r3
  122da4:	e0843003 	add	r3, r4, r3
  122da8:	e14b33b2 	strh	r3, [fp, #-50]	; 0xffffffce
          if (new_cwnd > pcb->cwnd) {
  122dac:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122db0:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
  122db4:	e15b23b2 	ldrh	r2, [fp, #-50]	; 0xffffffce
  122db8:	e1520003 	cmp	r2, r3
  122dbc:	9a000046 	bls	122edc <tcp_receive+0x5e0>
            pcb->cwnd = new_cwnd;
  122dc0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122dc4:	e15b23b2 	ldrh	r2, [fp, #-50]	; 0xffffffce
  122dc8:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
                                    pcb->unacked != NULL?
                                    lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowledges them. */
      while (pcb->unacked != NULL &&
  122dcc:	ea000042 	b	122edc <tcp_receive+0x5e0>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      lwip_ntohl(pcb->unacked->tcphdr->seqno),
                                      lwip_ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  122dd0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122dd4:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  122dd8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        pcb->unacked = pcb->unacked->next;
  122ddc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122de0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  122de4:	e5932000 	ldr	r2, [r3]
  122de8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122dec:	e5832070 	str	r2, [r3, #112]	; 0x70

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ", (tcpwnd_size_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  122df0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122df4:	e1d346b6 	ldrh	r4, [r3, #102]	; 0x66
  122df8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  122dfc:	e5933004 	ldr	r3, [r3, #4]
  122e00:	e1a00003 	mov	r0, r3
  122e04:	ebffe12f 	bl	11b2c8 <pbuf_clen>
  122e08:	e1a03000 	mov	r3, r0
  122e0c:	e1540003 	cmp	r4, r3
  122e10:	2a000006 	bcs	122e30 <tcp_receive+0x534>
  122e14:	e30806d4 	movw	r0, #34516	; 0x86d4
  122e18:	e3400014 	movt	r0, #20
  122e1c:	ebff80bc 	bl	103114 <rt_kprintf>
  122e20:	e300148b 	movw	r1, #1163	; 0x48b
  122e24:	e30804d0 	movw	r0, #34000	; 0x84d0
  122e28:	e3400014 	movt	r0, #20
  122e2c:	ebffa092 	bl	10b07c <sys_arch_assert>

        pcb->snd_queuelen -= pbuf_clen(next->p);
  122e30:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  122e34:	e5933004 	ldr	r3, [r3, #4]
  122e38:	e1a00003 	mov	r0, r3
  122e3c:	ebffe121 	bl	11b2c8 <pbuf_clen>
  122e40:	e1a03000 	mov	r3, r0
  122e44:	e1a02003 	mov	r2, r3
  122e48:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122e4c:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  122e50:	e0433002 	sub	r3, r3, r2
  122e54:	e6ff2073 	uxth	r2, r3
  122e58:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122e5c:	e1c326b6 	strh	r2, [r3, #102]	; 0x66
        recv_acked += next->len;
  122e60:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  122e64:	e1d320b8 	ldrh	r2, [r3, #8]
  122e68:	e30f3248 	movw	r3, #62024	; 0xf248
  122e6c:	e3403014 	movt	r3, #20
  122e70:	e1d330b0 	ldrh	r3, [r3]
  122e74:	e0823003 	add	r3, r2, r3
  122e78:	e6ff2073 	uxth	r2, r3
  122e7c:	e30f3248 	movw	r3, #62024	; 0xf248
  122e80:	e3403014 	movt	r3, #20
  122e84:	e1c320b0 	strh	r2, [r3]
        tcp_seg_free(next);
  122e88:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  122e8c:	ebfff1fa 	bl	11f67c <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing unacked)\n", (tcpwnd_size_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  122e90:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122e94:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  122e98:	e3530000 	cmp	r3, #0
  122e9c:	0a00000e 	beq	122edc <tcp_receive+0x5e0>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  122ea0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122ea4:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  122ea8:	e3530000 	cmp	r3, #0
  122eac:	1a00000a 	bne	122edc <tcp_receive+0x5e0>
  122eb0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122eb4:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  122eb8:	e3530000 	cmp	r3, #0
  122ebc:	1a000006 	bne	122edc <tcp_receive+0x5e0>
  122ec0:	e30806fc 	movw	r0, #34556	; 0x86fc
  122ec4:	e3400014 	movt	r0, #20
  122ec8:	ebff8091 	bl	103114 <rt_kprintf>
  122ecc:	e3001494 	movw	r1, #1172	; 0x494
  122ed0:	e30804d0 	movw	r0, #34000	; 0x84d0
  122ed4:	e3400014 	movt	r0, #20
  122ed8:	ebffa067 	bl	10b07c <sys_arch_assert>
      while (pcb->unacked != NULL &&
  122edc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122ee0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  122ee4:	e3530000 	cmp	r3, #0
  122ee8:	0a000020 	beq	122f70 <tcp_receive+0x674>
             TCP_SEQ_LEQ(lwip_ntohl(pcb->unacked->tcphdr->seqno) +
  122eec:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122ef0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  122ef4:	e593300c 	ldr	r3, [r3, #12]
  122ef8:	e5933004 	ldr	r3, [r3, #4]
  122efc:	e1a00003 	mov	r0, r3
  122f00:	ebffce40 	bl	116808 <lwip_htonl>
  122f04:	e1a04000 	mov	r4, r0
  122f08:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122f0c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  122f10:	e1d330b8 	ldrh	r3, [r3, #8]
  122f14:	e1a05003 	mov	r5, r3
  122f18:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122f1c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  122f20:	e593300c 	ldr	r3, [r3, #12]
  122f24:	e1d330bc 	ldrh	r3, [r3, #12]
  122f28:	e6ff3073 	uxth	r3, r3
  122f2c:	e1a00003 	mov	r0, r3
  122f30:	ebffce28 	bl	1167d8 <lwip_htons>
  122f34:	e1a03000 	mov	r3, r0
  122f38:	e2033003 	and	r3, r3, #3
  122f3c:	e3530000 	cmp	r3, #0
  122f40:	0a000001 	beq	122f4c <tcp_receive+0x650>
  122f44:	e3a03001 	mov	r3, #1
  122f48:	ea000000 	b	122f50 <tcp_receive+0x654>
  122f4c:	e3a03000 	mov	r3, #0
  122f50:	e0833005 	add	r3, r3, r5
  122f54:	e0842003 	add	r2, r4, r3
  122f58:	e30f3244 	movw	r3, #62020	; 0xf244
  122f5c:	e3403014 	movt	r3, #20
  122f60:	e5933000 	ldr	r3, [r3]
  122f64:	e0423003 	sub	r3, r2, r3
      while (pcb->unacked != NULL &&
  122f68:	e3530000 	cmp	r3, #0
  122f6c:	daffff97 	ble	122dd0 <tcp_receive+0x4d4>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if (pcb->unacked == NULL) {
  122f70:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122f74:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  122f78:	e3530000 	cmp	r3, #0
  122f7c:	1a000003 	bne	122f90 <tcp_receive+0x694>
        pcb->rtime = -1;
  122f80:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122f84:	e3e02000 	mvn	r2, #0
  122f88:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
  122f8c:	ea000002 	b	122f9c <tcp_receive+0x6a0>
      } else {
        pcb->rtime = 0;
  122f90:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122f94:	e3a02000 	mov	r2, #0
  122f98:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
      }

      pcb->polltmr = 0;
  122f9c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122fa0:	e3a02000 	mov	r2, #0
  122fa4:	e5c3201f 	strb	r2, [r3, #31]
  122fa8:	ea000001 	b	122fb4 <tcp_receive+0x6b8>
        nd6_reachability_hint(ip6_current_src_addr());
      }
#endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/
    } else {
      /* Out of sequence ACK, didn't really ack anything */
      tcp_send_empty_ack(pcb);
  122fac:	e51b0040 	ldr	r0, [fp, #-64]	; 0xffffffc0
  122fb0:	eb000c08 	bl	125fd8 <tcp_send_empty_ack>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  122fb4:	ea000049 	b	1230e0 <tcp_receive+0x7e4>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    lwip_ntohl(pcb->unsent->tcphdr->seqno), lwip_ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  122fb8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122fbc:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  122fc0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
      pcb->unsent = pcb->unsent->next;
  122fc4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122fc8:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  122fcc:	e5932000 	ldr	r2, [r3]
  122fd0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122fd4:	e583206c 	str	r2, [r3, #108]	; 0x6c
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
  122fd8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122fdc:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  122fe0:	e3530000 	cmp	r3, #0
  122fe4:	1a000002 	bne	122ff4 <tcp_receive+0x6f8>
        pcb->unsent_oversize = 0;
  122fe8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122fec:	e3a02000 	mov	r2, #0
  122ff0:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
      }
#endif /* TCP_OVERSIZE */
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ", (tcpwnd_size_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  122ff4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  122ff8:	e1d346b6 	ldrh	r4, [r3, #102]	; 0x66
  122ffc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123000:	e5933004 	ldr	r3, [r3, #4]
  123004:	e1a00003 	mov	r0, r3
  123008:	ebffe0ae 	bl	11b2c8 <pbuf_clen>
  12300c:	e1a03000 	mov	r3, r0
  123010:	e1540003 	cmp	r4, r3
  123014:	2a000006 	bcs	123034 <tcp_receive+0x738>
  123018:	e30806d4 	movw	r0, #34516	; 0x86d4
  12301c:	e3400014 	movt	r0, #20
  123020:	ebff803b 	bl	103114 <rt_kprintf>
  123024:	e30014c2 	movw	r1, #1218	; 0x4c2
  123028:	e30804d0 	movw	r0, #34000	; 0x84d0
  12302c:	e3400014 	movt	r0, #20
  123030:	ebffa011 	bl	10b07c <sys_arch_assert>
      /* Prevent ACK for FIN to generate a sent event */
      pcb->snd_queuelen -= pbuf_clen(next->p);
  123034:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123038:	e5933004 	ldr	r3, [r3, #4]
  12303c:	e1a00003 	mov	r0, r3
  123040:	ebffe0a0 	bl	11b2c8 <pbuf_clen>
  123044:	e1a03000 	mov	r3, r0
  123048:	e1a02003 	mov	r2, r3
  12304c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123050:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  123054:	e0433002 	sub	r3, r3, r2
  123058:	e6ff2073 	uxth	r2, r3
  12305c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123060:	e1c326b6 	strh	r2, [r3, #102]	; 0x66
      recv_acked += next->len;
  123064:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123068:	e1d320b8 	ldrh	r2, [r3, #8]
  12306c:	e30f3248 	movw	r3, #62024	; 0xf248
  123070:	e3403014 	movt	r3, #20
  123074:	e1d330b0 	ldrh	r3, [r3]
  123078:	e0823003 	add	r3, r2, r3
  12307c:	e6ff2073 	uxth	r2, r3
  123080:	e30f3248 	movw	r3, #62024	; 0xf248
  123084:	e3403014 	movt	r3, #20
  123088:	e1c320b0 	strh	r2, [r3]
      tcp_seg_free(next);
  12308c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  123090:	ebfff179 	bl	11f67c <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing unsent)\n", (tcpwnd_size_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  123094:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123098:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  12309c:	e3530000 	cmp	r3, #0
  1230a0:	0a00000e 	beq	1230e0 <tcp_receive+0x7e4>
        LWIP_ASSERT("tcp_receive: valid queue length",
  1230a4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1230a8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  1230ac:	e3530000 	cmp	r3, #0
  1230b0:	1a00000a 	bne	1230e0 <tcp_receive+0x7e4>
  1230b4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1230b8:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  1230bc:	e3530000 	cmp	r3, #0
  1230c0:	1a000006 	bne	1230e0 <tcp_receive+0x7e4>
  1230c4:	e30806fc 	movw	r0, #34556	; 0x86fc
  1230c8:	e3400014 	movt	r0, #20
  1230cc:	ebff8010 	bl	103114 <rt_kprintf>
  1230d0:	e30014ca 	movw	r1, #1226	; 0x4ca
  1230d4:	e30804d0 	movw	r0, #34000	; 0x84d0
  1230d8:	e3400014 	movt	r0, #20
  1230dc:	ebff9fe6 	bl	10b07c <sys_arch_assert>
    while (pcb->unsent != NULL &&
  1230e0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1230e4:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  1230e8:	e3530000 	cmp	r3, #0
  1230ec:	0a000028 	beq	123194 <tcp_receive+0x898>
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
  1230f0:	e30f3244 	movw	r3, #62020	; 0xf244
  1230f4:	e3403014 	movt	r3, #20
  1230f8:	e5934000 	ldr	r4, [r3]
  1230fc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123100:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  123104:	e593300c 	ldr	r3, [r3, #12]
  123108:	e5933004 	ldr	r3, [r3, #4]
  12310c:	e1a00003 	mov	r0, r3
  123110:	ebffcdbc 	bl	116808 <lwip_htonl>
  123114:	e1a05000 	mov	r5, r0
  123118:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  12311c:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  123120:	e1d330b8 	ldrh	r3, [r3, #8]
  123124:	e1a06003 	mov	r6, r3
  123128:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  12312c:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  123130:	e593300c 	ldr	r3, [r3, #12]
  123134:	e1d330bc 	ldrh	r3, [r3, #12]
  123138:	e6ff3073 	uxth	r3, r3
  12313c:	e1a00003 	mov	r0, r3
  123140:	ebffcda4 	bl	1167d8 <lwip_htons>
  123144:	e1a03000 	mov	r3, r0
  123148:	e2033003 	and	r3, r3, #3
  12314c:	e3530000 	cmp	r3, #0
  123150:	0a000001 	beq	12315c <tcp_receive+0x860>
  123154:	e3a03001 	mov	r3, #1
  123158:	ea000000 	b	123160 <tcp_receive+0x864>
  12315c:	e3a03000 	mov	r3, #0
  123160:	e0833006 	add	r3, r3, r6
  123164:	e0853003 	add	r3, r5, r3
  123168:	e0443003 	sub	r3, r4, r3
    while (pcb->unsent != NULL &&
  12316c:	e3530000 	cmp	r3, #0
  123170:	ba000007 	blt	123194 <tcp_receive+0x898>
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
  123174:	e30f3244 	movw	r3, #62020	; 0xf244
  123178:	e3403014 	movt	r3, #20
  12317c:	e5932000 	ldr	r2, [r3]
  123180:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123184:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  123188:	e0423003 	sub	r3, r2, r3
  12318c:	e3530000 	cmp	r3, #0
  123190:	daffff88 	ble	122fb8 <tcp_receive+0x6bc>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }
    }
    pcb->snd_buf += recv_acked;
  123194:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123198:	e1d326b4 	ldrh	r2, [r3, #100]	; 0x64
  12319c:	e30f3248 	movw	r3, #62024	; 0xf248
  1231a0:	e3403014 	movt	r3, #20
  1231a4:	e1d330b0 	ldrh	r3, [r3]
  1231a8:	e0823003 	add	r3, r2, r3
  1231ac:	e6ff2073 	uxth	r2, r3
  1231b0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1231b4:	e1c326b4 	strh	r2, [r3, #100]	; 0x64
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  1231b8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1231bc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  1231c0:	e3530000 	cmp	r3, #0
  1231c4:	0a00004c 	beq	1232fc <tcp_receive+0xa00>
  1231c8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1231cc:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
  1231d0:	e30f3244 	movw	r3, #62020	; 0xf244
  1231d4:	e3403014 	movt	r3, #20
  1231d8:	e5933000 	ldr	r3, [r3]
  1231dc:	e0423003 	sub	r3, r2, r3
  1231e0:	e3530000 	cmp	r3, #0
  1231e4:	aa000044 	bge	1232fc <tcp_receive+0xa00>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  1231e8:	e3063a34 	movw	r3, #27188	; 0x6a34
  1231ec:	e3403057 	movt	r3, #87	; 0x57
  1231f0:	e5933000 	ldr	r3, [r3]
  1231f4:	e6ff2073 	uxth	r2, r3
  1231f8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1231fc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  123200:	e6ff3073 	uxth	r3, r3
  123204:	e0423003 	sub	r3, r2, r3
  123208:	e6ff3073 	uxth	r3, r3
  12320c:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, (u16_t)(m * TCP_SLOW_INTERVAL)));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  123210:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  123214:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123218:	e1d334f0 	ldrsh	r3, [r3, #64]	; 0x40
  12321c:	e1a031c3 	asr	r3, r3, #3
  123220:	e6bf3073 	sxth	r3, r3
  123224:	e6ff3073 	uxth	r3, r3
  123228:	e0423003 	sub	r3, r2, r3
  12322c:	e6ff3073 	uxth	r3, r3
  123230:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
      pcb->sa += m;
  123234:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123238:	e1d334f0 	ldrsh	r3, [r3, #64]	; 0x40
  12323c:	e6ff2073 	uxth	r2, r3
  123240:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  123244:	e0823003 	add	r3, r2, r3
  123248:	e6ff3073 	uxth	r3, r3
  12324c:	e6bf2073 	sxth	r2, r3
  123250:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123254:	e1c324b0 	strh	r2, [r3, #64]	; 0x40
      if (m < 0) {
  123258:	e15b32f2 	ldrsh	r3, [fp, #-34]	; 0xffffffde
  12325c:	e3530000 	cmp	r3, #0
  123260:	aa000003 	bge	123274 <tcp_receive+0x978>
        m = -m;
  123264:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  123268:	e2633000 	rsb	r3, r3, #0
  12326c:	e6ff3073 	uxth	r3, r3
  123270:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
      }
      m = m - (pcb->sv >> 2);
  123274:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  123278:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  12327c:	e1d334f2 	ldrsh	r3, [r3, #66]	; 0x42
  123280:	e1a03143 	asr	r3, r3, #2
  123284:	e6bf3073 	sxth	r3, r3
  123288:	e6ff3073 	uxth	r3, r3
  12328c:	e0423003 	sub	r3, r2, r3
  123290:	e6ff3073 	uxth	r3, r3
  123294:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
      pcb->sv += m;
  123298:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  12329c:	e1d334f2 	ldrsh	r3, [r3, #66]	; 0x42
  1232a0:	e6ff2073 	uxth	r2, r3
  1232a4:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  1232a8:	e0823003 	add	r3, r2, r3
  1232ac:	e6ff3073 	uxth	r3, r3
  1232b0:	e6bf2073 	sxth	r2, r3
  1232b4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1232b8:	e1c324b2 	strh	r2, [r3, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  1232bc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1232c0:	e1d334f0 	ldrsh	r3, [r3, #64]	; 0x40
  1232c4:	e1a031c3 	asr	r3, r3, #3
  1232c8:	e6bf3073 	sxth	r3, r3
  1232cc:	e6ff2073 	uxth	r2, r3
  1232d0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1232d4:	e1d334f2 	ldrsh	r3, [r3, #66]	; 0x42
  1232d8:	e6ff3073 	uxth	r3, r3
  1232dc:	e0823003 	add	r3, r2, r3
  1232e0:	e6ff3073 	uxth	r3, r3
  1232e4:	e6bf2073 	sxth	r2, r3
  1232e8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1232ec:	e1c324b4 	strh	r2, [r3, #68]	; 0x44

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));

      pcb->rttest = 0;
  1232f0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1232f4:	e3a02000 	mov	r2, #0
  1232f8:	e5832038 	str	r2, [r3, #56]	; 0x38

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
  1232fc:	e30f324a 	movw	r3, #62026	; 0xf24a
  123300:	e3403014 	movt	r3, #20
  123304:	e1d330b0 	ldrh	r3, [r3]
  123308:	e3530000 	cmp	r3, #0
  12330c:	0a0004b3 	beq	1245e0 <tcp_receive+0x1ce4>
  123310:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123314:	e5933014 	ldr	r3, [r3, #20]
  123318:	e3530006 	cmp	r3, #6
  12331c:	8a0004af 	bhi	1245e0 <tcp_receive+0x1ce4>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
  123320:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123324:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  123328:	e30f3240 	movw	r3, #62016	; 0xf240
  12332c:	e3403014 	movt	r3, #20
  123330:	e5933000 	ldr	r3, [r3]
  123334:	e0423003 	sub	r3, r2, r3
  123338:	e2433001 	sub	r3, r3, #1
  12333c:	e3530000 	cmp	r3, #0
  123340:	ba0000aa 	blt	1235f0 <tcp_receive+0xcf4>
  123344:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123348:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  12334c:	e30f324a 	movw	r3, #62026	; 0xf24a
  123350:	e3403014 	movt	r3, #20
  123354:	e1d330b0 	ldrh	r3, [r3]
  123358:	e1a01003 	mov	r1, r3
  12335c:	e30f3240 	movw	r3, #62016	; 0xf240
  123360:	e3403014 	movt	r3, #20
  123364:	e5933000 	ldr	r3, [r3]
  123368:	e0813003 	add	r3, r1, r3
  12336c:	e0423003 	sub	r3, r2, r3
  123370:	e2833001 	add	r3, r3, #1
  123374:	e3530000 	cmp	r3, #0
  123378:	ca00009c 	bgt	1235f0 <tcp_receive+0xcf4>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      struct pbuf *p = inseg.p;
  12337c:	e30f3220 	movw	r3, #61984	; 0xf220
  123380:	e3403014 	movt	r3, #20
  123384:	e5933004 	ldr	r3, [r3, #4]
  123388:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
      off = pcb->rcv_nxt - seqno;
  12338c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123390:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  123394:	e30f3240 	movw	r3, #62016	; 0xf240
  123398:	e3403014 	movt	r3, #20
  12339c:	e5933000 	ldr	r3, [r3]
  1233a0:	e0423003 	sub	r3, r2, r3
  1233a4:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  1233a8:	e30f3220 	movw	r3, #61984	; 0xf220
  1233ac:	e3403014 	movt	r3, #20
  1233b0:	e5933004 	ldr	r3, [r3, #4]
  1233b4:	e3530000 	cmp	r3, #0
  1233b8:	1a000006 	bne	1233d8 <tcp_receive+0xadc>
  1233bc:	e308071c 	movw	r0, #34588	; 0x871c
  1233c0:	e3400014 	movt	r0, #20
  1233c4:	ebff7f52 	bl	103114 <rt_kprintf>
  1233c8:	e3001529 	movw	r1, #1321	; 0x529
  1233cc:	e30804d0 	movw	r0, #34000	; 0x84d0
  1233d0:	e3400014 	movt	r0, #20
  1233d4:	ebff9f28 	bl	10b07c <sys_arch_assert>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  1233d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1233dc:	e3072ffe 	movw	r2, #32766	; 0x7ffe
  1233e0:	e1530002 	cmp	r3, r2
  1233e4:	da000006 	ble	123404 <tcp_receive+0xb08>
  1233e8:	e308072c 	movw	r0, #34604	; 0x872c
  1233ec:	e3400014 	movt	r0, #20
  1233f0:	ebff7f47 	bl	103114 <rt_kprintf>
  1233f4:	e300152a 	movw	r1, #1322	; 0x52a
  1233f8:	e30804d0 	movw	r0, #34000	; 0x84d0
  1233fc:	e3400014 	movt	r0, #20
  123400:	ebff9f1d 	bl	10b07c <sys_arch_assert>
      if (inseg.p->len < off) {
  123404:	e30f3220 	movw	r3, #61984	; 0xf220
  123408:	e3403014 	movt	r3, #20
  12340c:	e5933004 	ldr	r3, [r3, #4]
  123410:	e1d330ba 	ldrh	r3, [r3, #10]
  123414:	e1a02003 	mov	r2, r3
  123418:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12341c:	e1530002 	cmp	r3, r2
  123420:	da00003f 	ble	123524 <tcp_receive+0xc28>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  123424:	e30f3220 	movw	r3, #61984	; 0xf220
  123428:	e3403014 	movt	r3, #20
  12342c:	e5933004 	ldr	r3, [r3, #4]
  123430:	e1d330b8 	ldrh	r3, [r3, #8]
  123434:	e1a02003 	mov	r2, r3
  123438:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12343c:	e1530002 	cmp	r3, r2
  123440:	da000006 	ble	123460 <tcp_receive+0xb64>
  123444:	e308073c 	movw	r0, #34620	; 0x873c
  123448:	e3400014 	movt	r0, #20
  12344c:	ebff7f30 	bl	103114 <rt_kprintf>
  123450:	e300152c 	movw	r1, #1324	; 0x52c
  123454:	e30804d0 	movw	r0, #34000	; 0x84d0
  123458:	e3400014 	movt	r0, #20
  12345c:	ebff9f06 	bl	10b07c <sys_arch_assert>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  123460:	e30f3220 	movw	r3, #61984	; 0xf220
  123464:	e3403014 	movt	r3, #20
  123468:	e5933004 	ldr	r3, [r3, #4]
  12346c:	e1d320b8 	ldrh	r2, [r3, #8]
  123470:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  123474:	e6ff3073 	uxth	r3, r3
  123478:	e0423003 	sub	r3, r2, r3
  12347c:	e14b33b4 	strh	r3, [fp, #-52]	; 0xffffffcc
        while (p->len < off) {
  123480:	ea00000e 	b	1234c0 <tcp_receive+0xbc4>
          off -= p->len;
  123484:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  123488:	e1d330ba 	ldrh	r3, [r3, #10]
  12348c:	e1a02003 	mov	r2, r3
  123490:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  123494:	e0433002 	sub	r3, r3, r2
  123498:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  12349c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1234a0:	e15b23b4 	ldrh	r2, [fp, #-52]	; 0xffffffcc
  1234a4:	e1c320b8 	strh	r2, [r3, #8]
          p->len = 0;
  1234a8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1234ac:	e3a02000 	mov	r2, #0
  1234b0:	e1c320ba 	strh	r2, [r3, #10]
          p = p->next;
  1234b4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1234b8:	e5933000 	ldr	r3, [r3]
  1234bc:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
        while (p->len < off) {
  1234c0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1234c4:	e1d330ba 	ldrh	r3, [r3, #10]
  1234c8:	e1a02003 	mov	r2, r3
  1234cc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1234d0:	e1530002 	cmp	r3, r2
  1234d4:	caffffea 	bgt	123484 <tcp_receive+0xb88>
        }
        if (pbuf_header(p, (s16_t)-off)) {
  1234d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1234dc:	e6ff3073 	uxth	r3, r3
  1234e0:	e2633000 	rsb	r3, r3, #0
  1234e4:	e6ff3073 	uxth	r3, r3
  1234e8:	e6bf3073 	sxth	r3, r3
  1234ec:	e1a01003 	mov	r1, r3
  1234f0:	e51b002c 	ldr	r0, [fp, #-44]	; 0xffffffd4
  1234f4:	ebffded0 	bl	11b03c <pbuf_header>
  1234f8:	e1a03000 	mov	r3, r0
  1234fc:	e3530000 	cmp	r3, #0
  123500:	0a00001c 	beq	123578 <tcp_receive+0xc7c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  123504:	e308074c 	movw	r0, #34636	; 0x874c
  123508:	e3400014 	movt	r0, #20
  12350c:	ebff7f00 	bl	103114 <rt_kprintf>
  123510:	e3001539 	movw	r1, #1337	; 0x539
  123514:	e30804d0 	movw	r0, #34000	; 0x84d0
  123518:	e3400014 	movt	r0, #20
  12351c:	ebff9ed6 	bl	10b07c <sys_arch_assert>
  123520:	ea000014 	b	123578 <tcp_receive+0xc7c>
        }
      } else {
        if (pbuf_header(inseg.p, (s16_t)-off)) {
  123524:	e30f3220 	movw	r3, #61984	; 0xf220
  123528:	e3403014 	movt	r3, #20
  12352c:	e5933004 	ldr	r3, [r3, #4]
  123530:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  123534:	e6ff2072 	uxth	r2, r2
  123538:	e2622000 	rsb	r2, r2, #0
  12353c:	e6ff2072 	uxth	r2, r2
  123540:	e6bf2072 	sxth	r2, r2
  123544:	e1a01002 	mov	r1, r2
  123548:	e1a00003 	mov	r0, r3
  12354c:	ebffdeba 	bl	11b03c <pbuf_header>
  123550:	e1a03000 	mov	r3, r0
  123554:	e3530000 	cmp	r3, #0
  123558:	0a000006 	beq	123578 <tcp_receive+0xc7c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  12355c:	e308074c 	movw	r0, #34636	; 0x874c
  123560:	e3400014 	movt	r0, #20
  123564:	ebff7eea 	bl	103114 <rt_kprintf>
  123568:	e300153e 	movw	r1, #1342	; 0x53e
  12356c:	e30804d0 	movw	r0, #34000	; 0x84d0
  123570:	e3400014 	movt	r0, #20
  123574:	ebff9ec0 	bl	10b07c <sys_arch_assert>
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  123578:	e30f3220 	movw	r3, #61984	; 0xf220
  12357c:	e3403014 	movt	r3, #20
  123580:	e1d320b8 	ldrh	r2, [r3, #8]
  123584:	e30f3240 	movw	r3, #62016	; 0xf240
  123588:	e3403014 	movt	r3, #20
  12358c:	e5933000 	ldr	r3, [r3]
  123590:	e6ff1073 	uxth	r1, r3
  123594:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123598:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12359c:	e6ff3073 	uxth	r3, r3
  1235a0:	e0413003 	sub	r3, r1, r3
  1235a4:	e6ff3073 	uxth	r3, r3
  1235a8:	e0823003 	add	r3, r2, r3
  1235ac:	e6ff2073 	uxth	r2, r3
  1235b0:	e30f3220 	movw	r3, #61984	; 0xf220
  1235b4:	e3403014 	movt	r3, #20
  1235b8:	e1c320b8 	strh	r2, [r3, #8]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  1235bc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1235c0:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  1235c4:	e30f3240 	movw	r3, #62016	; 0xf240
  1235c8:	e3403014 	movt	r3, #20
  1235cc:	e5832000 	str	r2, [r3]
  1235d0:	e30f3220 	movw	r3, #61984	; 0xf220
  1235d4:	e3403014 	movt	r3, #20
  1235d8:	e593200c 	ldr	r2, [r3, #12]
  1235dc:	e30f3240 	movw	r3, #62016	; 0xf240
  1235e0:	e3403014 	movt	r3, #20
  1235e4:	e5933000 	ldr	r3, [r3]
  1235e8:	e5823004 	str	r3, [r2, #4]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
  1235ec:	ea00000d 	b	123628 <tcp_receive+0xd2c>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
  1235f0:	e30f3240 	movw	r3, #62016	; 0xf240
  1235f4:	e3403014 	movt	r3, #20
  1235f8:	e5932000 	ldr	r2, [r3]
  1235fc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123600:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  123604:	e0423003 	sub	r3, r2, r3
  123608:	e3530000 	cmp	r3, #0
  12360c:	aa000005 	bge	123628 <tcp_receive+0xd2c>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  123610:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123614:	e5d3301e 	ldrb	r3, [r3, #30]
  123618:	e3833002 	orr	r3, r3, #2
  12361c:	e6ef2073 	uxtb	r2, r3
  123620:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123624:	e5c3201e 	strb	r2, [r3, #30]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
  123628:	e30f3240 	movw	r3, #62016	; 0xf240
  12362c:	e3403014 	movt	r3, #20
  123630:	e5932000 	ldr	r2, [r3]
  123634:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123638:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12363c:	e0423003 	sub	r3, r2, r3
  123640:	e3530000 	cmp	r3, #0
  123644:	ba0003e1 	blt	1245d0 <tcp_receive+0x1cd4>
  123648:	e30f3240 	movw	r3, #62016	; 0xf240
  12364c:	e3403014 	movt	r3, #20
  123650:	e5932000 	ldr	r2, [r3]
  123654:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123658:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12365c:	e51b1040 	ldr	r1, [fp, #-64]	; 0xffffffc0
  123660:	e1d112bc 	ldrh	r1, [r1, #44]	; 0x2c
  123664:	e0833001 	add	r3, r3, r1
  123668:	e0423003 	sub	r3, r2, r3
  12366c:	e2833001 	add	r3, r3, #1
  123670:	e3530000 	cmp	r3, #0
  123674:	ca0003d5 	bgt	1245d0 <tcp_receive+0x1cd4>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
  123678:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  12367c:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  123680:	e30f3240 	movw	r3, #62016	; 0xf240
  123684:	e3403014 	movt	r3, #20
  123688:	e5933000 	ldr	r3, [r3]
  12368c:	e1520003 	cmp	r2, r3
  123690:	1a00026b 	bne	124044 <tcp_receive+0x1748>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
  123694:	e30f3220 	movw	r3, #61984	; 0xf220
  123698:	e3403014 	movt	r3, #20
  12369c:	e1d340b8 	ldrh	r4, [r3, #8]
  1236a0:	e30f3220 	movw	r3, #61984	; 0xf220
  1236a4:	e3403014 	movt	r3, #20
  1236a8:	e593300c 	ldr	r3, [r3, #12]
  1236ac:	e1d330bc 	ldrh	r3, [r3, #12]
  1236b0:	e6ff3073 	uxth	r3, r3
  1236b4:	e1a00003 	mov	r0, r3
  1236b8:	ebffcc46 	bl	1167d8 <lwip_htons>
  1236bc:	e1a03000 	mov	r3, r0
  1236c0:	e2033003 	and	r3, r3, #3
  1236c4:	e3530000 	cmp	r3, #0
  1236c8:	0a000001 	beq	1236d4 <tcp_receive+0xdd8>
  1236cc:	e3a03001 	mov	r3, #1
  1236d0:	ea000000 	b	1236d8 <tcp_receive+0xddc>
  1236d4:	e3a03000 	mov	r3, #0
  1236d8:	e0833004 	add	r3, r3, r4
  1236dc:	e6ff2073 	uxth	r2, r3
  1236e0:	e30f324a 	movw	r3, #62026	; 0xf24a
  1236e4:	e3403014 	movt	r3, #20
  1236e8:	e1c320b0 	strh	r2, [r3]

        if (tcplen > pcb->rcv_wnd) {
  1236ec:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1236f0:	e1d322bc 	ldrh	r2, [r3, #44]	; 0x2c
  1236f4:	e30f324a 	movw	r3, #62026	; 0xf24a
  1236f8:	e3403014 	movt	r3, #20
  1236fc:	e1d330b0 	ldrh	r3, [r3]
  123700:	e1520003 	cmp	r2, r3
  123704:	2a000072 	bcs	1238d4 <tcp_receive+0xfd8>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  123708:	e30f3220 	movw	r3, #61984	; 0xf220
  12370c:	e3403014 	movt	r3, #20
  123710:	e593300c 	ldr	r3, [r3, #12]
  123714:	e1d330bc 	ldrh	r3, [r3, #12]
  123718:	e6ff3073 	uxth	r3, r3
  12371c:	e1a00003 	mov	r0, r3
  123720:	ebffcc2c 	bl	1167d8 <lwip_htons>
  123724:	e1a03000 	mov	r3, r0
  123728:	e2033001 	and	r3, r3, #1
  12372c:	e3530000 	cmp	r3, #0
  123730:	0a00001a 	beq	1237a0 <tcp_receive+0xea4>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
  123734:	e30f3220 	movw	r3, #61984	; 0xf220
  123738:	e3403014 	movt	r3, #20
  12373c:	e593300c 	ldr	r3, [r3, #12]
  123740:	e1d330bc 	ldrh	r3, [r3, #12]
  123744:	e6ff3073 	uxth	r3, r3
  123748:	e3c33c3f 	bic	r3, r3, #16128	; 0x3f00
  12374c:	e6ff4073 	uxth	r4, r3
  123750:	e30f3220 	movw	r3, #61984	; 0xf220
  123754:	e3403014 	movt	r3, #20
  123758:	e593300c 	ldr	r3, [r3, #12]
  12375c:	e1d330bc 	ldrh	r3, [r3, #12]
  123760:	e6ff3073 	uxth	r3, r3
  123764:	e1a00003 	mov	r0, r3
  123768:	ebffcc1a 	bl	1167d8 <lwip_htons>
  12376c:	e1a03000 	mov	r3, r0
  123770:	e203303e 	and	r3, r3, #62	; 0x3e
  123774:	e6ff3073 	uxth	r3, r3
  123778:	e1a00003 	mov	r0, r3
  12377c:	ebffcc15 	bl	1167d8 <lwip_htons>
  123780:	e1a03000 	mov	r3, r0
  123784:	e1a02003 	mov	r2, r3
  123788:	e30f3220 	movw	r3, #61984	; 0xf220
  12378c:	e3403014 	movt	r3, #20
  123790:	e593300c 	ldr	r3, [r3, #12]
  123794:	e1842002 	orr	r2, r4, r2
  123798:	e6ff2072 	uxth	r2, r2
  12379c:	e1c320bc 	strh	r2, [r3, #12]
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
  1237a0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1237a4:	e1d322bc 	ldrh	r2, [r3, #44]	; 0x2c
  1237a8:	e30f3220 	movw	r3, #61984	; 0xf220
  1237ac:	e3403014 	movt	r3, #20
  1237b0:	e1c320b8 	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
  1237b4:	e30f3220 	movw	r3, #61984	; 0xf220
  1237b8:	e3403014 	movt	r3, #20
  1237bc:	e593300c 	ldr	r3, [r3, #12]
  1237c0:	e1d330bc 	ldrh	r3, [r3, #12]
  1237c4:	e6ff3073 	uxth	r3, r3
  1237c8:	e1a00003 	mov	r0, r3
  1237cc:	ebffcc01 	bl	1167d8 <lwip_htons>
  1237d0:	e1a03000 	mov	r3, r0
  1237d4:	e2033002 	and	r3, r3, #2
  1237d8:	e3530000 	cmp	r3, #0
  1237dc:	0a000007 	beq	123800 <tcp_receive+0xf04>
            inseg.len -= 1;
  1237e0:	e30f3220 	movw	r3, #61984	; 0xf220
  1237e4:	e3403014 	movt	r3, #20
  1237e8:	e1d330b8 	ldrh	r3, [r3, #8]
  1237ec:	e2433001 	sub	r3, r3, #1
  1237f0:	e6ff2073 	uxth	r2, r3
  1237f4:	e30f3220 	movw	r3, #61984	; 0xf220
  1237f8:	e3403014 	movt	r3, #20
  1237fc:	e1c320b8 	strh	r2, [r3, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
  123800:	e30f3220 	movw	r3, #61984	; 0xf220
  123804:	e3403014 	movt	r3, #20
  123808:	e5932004 	ldr	r2, [r3, #4]
  12380c:	e30f3220 	movw	r3, #61984	; 0xf220
  123810:	e3403014 	movt	r3, #20
  123814:	e1d330b8 	ldrh	r3, [r3, #8]
  123818:	e1a01003 	mov	r1, r3
  12381c:	e1a00002 	mov	r0, r2
  123820:	ebffdcda 	bl	11ab90 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
  123824:	e30f3220 	movw	r3, #61984	; 0xf220
  123828:	e3403014 	movt	r3, #20
  12382c:	e1d340b8 	ldrh	r4, [r3, #8]
  123830:	e30f3220 	movw	r3, #61984	; 0xf220
  123834:	e3403014 	movt	r3, #20
  123838:	e593300c 	ldr	r3, [r3, #12]
  12383c:	e1d330bc 	ldrh	r3, [r3, #12]
  123840:	e6ff3073 	uxth	r3, r3
  123844:	e1a00003 	mov	r0, r3
  123848:	ebffcbe2 	bl	1167d8 <lwip_htons>
  12384c:	e1a03000 	mov	r3, r0
  123850:	e2033003 	and	r3, r3, #3
  123854:	e3530000 	cmp	r3, #0
  123858:	0a000001 	beq	123864 <tcp_receive+0xf68>
  12385c:	e3a03001 	mov	r3, #1
  123860:	ea000000 	b	123868 <tcp_receive+0xf6c>
  123864:	e3a03000 	mov	r3, #0
  123868:	e0833004 	add	r3, r3, r4
  12386c:	e6ff2073 	uxth	r2, r3
  123870:	e30f324a 	movw	r3, #62026	; 0xf24a
  123874:	e3403014 	movt	r3, #20
  123878:	e1c320b0 	strh	r2, [r3]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
  12387c:	e30f324a 	movw	r3, #62026	; 0xf24a
  123880:	e3403014 	movt	r3, #20
  123884:	e1d330b0 	ldrh	r3, [r3]
  123888:	e1a02003 	mov	r2, r3
  12388c:	e30f3240 	movw	r3, #62016	; 0xf240
  123890:	e3403014 	movt	r3, #20
  123894:	e5933000 	ldr	r3, [r3]
  123898:	e0822003 	add	r2, r2, r3
  12389c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1238a0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  1238a4:	e51b1040 	ldr	r1, [fp, #-64]	; 0xffffffc0
  1238a8:	e1d112bc 	ldrh	r1, [r1, #44]	; 0x2c
  1238ac:	e0833001 	add	r3, r3, r1
  1238b0:	e1520003 	cmp	r2, r3
  1238b4:	0a000006 	beq	1238d4 <tcp_receive+0xfd8>
  1238b8:	e3080760 	movw	r0, #34656	; 0x8760
  1238bc:	e3400014 	movt	r0, #20
  1238c0:	ebff7e13 	bl	103114 <rt_kprintf>
  1238c4:	e300156c 	movw	r1, #1388	; 0x56c
  1238c8:	e30804d0 	movw	r0, #34000	; 0x84d0
  1238cc:	e3400014 	movt	r0, #20
  1238d0:	ebff9de9 	bl	10b07c <sys_arch_assert>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
  1238d4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1238d8:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  1238dc:	e3530000 	cmp	r3, #0
  1238e0:	0a0000da 	beq	123c50 <tcp_receive+0x1354>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  1238e4:	e30f3220 	movw	r3, #61984	; 0xf220
  1238e8:	e3403014 	movt	r3, #20
  1238ec:	e593300c 	ldr	r3, [r3, #12]
  1238f0:	e1d330bc 	ldrh	r3, [r3, #12]
  1238f4:	e6ff3073 	uxth	r3, r3
  1238f8:	e1a00003 	mov	r0, r3
  1238fc:	ebffcbb5 	bl	1167d8 <lwip_htons>
  123900:	e1a03000 	mov	r3, r0
  123904:	e2033001 	and	r3, r3, #1
  123908:	e3530000 	cmp	r3, #0
  12390c:	0a00000f 	beq	123950 <tcp_receive+0x1054>
            LWIP_DEBUGF(TCP_INPUT_DEBUG,
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
  123910:	ea000009 	b	12393c <tcp_receive+0x1040>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  123914:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123918:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  12391c:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
              pcb->ooseq = pcb->ooseq->next;
  123920:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123924:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  123928:	e5932000 	ldr	r2, [r3]
  12392c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123930:	e5832074 	str	r2, [r3, #116]	; 0x74
              tcp_seg_free(old_ooseq);
  123934:	e51b003c 	ldr	r0, [fp, #-60]	; 0xffffffc4
  123938:	ebffef4f 	bl	11f67c <tcp_seg_free>
            while (pcb->ooseq != NULL) {
  12393c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123940:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  123944:	e3530000 	cmp	r3, #0
  123948:	1afffff1 	bne	123914 <tcp_receive+0x1018>
  12394c:	ea0000bf 	b	123c50 <tcp_receive+0x1354>
            }
          } else {
            next = pcb->ooseq;
  123950:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123954:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  123958:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
  12395c:	ea000040 	b	123a64 <tcp_receive+0x1168>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
  123960:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123964:	e593300c 	ldr	r3, [r3, #12]
  123968:	e1d330bc 	ldrh	r3, [r3, #12]
  12396c:	e6ff3073 	uxth	r3, r3
  123970:	e1a00003 	mov	r0, r3
  123974:	ebffcb97 	bl	1167d8 <lwip_htons>
  123978:	e1a03000 	mov	r3, r0
  12397c:	e2033001 	and	r3, r3, #1
  123980:	e3530000 	cmp	r3, #0
  123984:	0a00002f 	beq	123a48 <tcp_receive+0x114c>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
  123988:	e30f3220 	movw	r3, #61984	; 0xf220
  12398c:	e3403014 	movt	r3, #20
  123990:	e593300c 	ldr	r3, [r3, #12]
  123994:	e1d330bc 	ldrh	r3, [r3, #12]
  123998:	e6ff3073 	uxth	r3, r3
  12399c:	e1a00003 	mov	r0, r3
  1239a0:	ebffcb8c 	bl	1167d8 <lwip_htons>
  1239a4:	e1a03000 	mov	r3, r0
  1239a8:	e2033002 	and	r3, r3, #2
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
  1239ac:	e3530000 	cmp	r3, #0
  1239b0:	1a000024 	bne	123a48 <tcp_receive+0x114c>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
  1239b4:	e30f3220 	movw	r3, #61984	; 0xf220
  1239b8:	e3403014 	movt	r3, #20
  1239bc:	e593300c 	ldr	r3, [r3, #12]
  1239c0:	e1d330bc 	ldrh	r3, [r3, #12]
  1239c4:	e6ff4073 	uxth	r4, r3
  1239c8:	e3a00001 	mov	r0, #1
  1239cc:	ebffcb81 	bl	1167d8 <lwip_htons>
  1239d0:	e1a03000 	mov	r3, r0
  1239d4:	e1a02003 	mov	r2, r3
  1239d8:	e30f3220 	movw	r3, #61984	; 0xf220
  1239dc:	e3403014 	movt	r3, #20
  1239e0:	e593300c 	ldr	r3, [r3, #12]
  1239e4:	e1842002 	orr	r2, r4, r2
  1239e8:	e6ff2072 	uxth	r2, r2
  1239ec:	e1c320bc 	strh	r2, [r3, #12]
                tcplen = TCP_TCPLEN(&inseg);
  1239f0:	e30f3220 	movw	r3, #61984	; 0xf220
  1239f4:	e3403014 	movt	r3, #20
  1239f8:	e1d340b8 	ldrh	r4, [r3, #8]
  1239fc:	e30f3220 	movw	r3, #61984	; 0xf220
  123a00:	e3403014 	movt	r3, #20
  123a04:	e593300c 	ldr	r3, [r3, #12]
  123a08:	e1d330bc 	ldrh	r3, [r3, #12]
  123a0c:	e6ff3073 	uxth	r3, r3
  123a10:	e1a00003 	mov	r0, r3
  123a14:	ebffcb6f 	bl	1167d8 <lwip_htons>
  123a18:	e1a03000 	mov	r3, r0
  123a1c:	e2033003 	and	r3, r3, #3
  123a20:	e3530000 	cmp	r3, #0
  123a24:	0a000001 	beq	123a30 <tcp_receive+0x1134>
  123a28:	e3a03001 	mov	r3, #1
  123a2c:	ea000000 	b	123a34 <tcp_receive+0x1138>
  123a30:	e3a03000 	mov	r3, #0
  123a34:	e0833004 	add	r3, r3, r4
  123a38:	e6ff2073 	uxth	r2, r3
  123a3c:	e30f324a 	movw	r3, #62026	; 0xf24a
  123a40:	e3403014 	movt	r3, #20
  123a44:	e1c320b0 	strh	r2, [r3]
              }
              prev = next;
  123a48:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123a4c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
              next = next->next;
  123a50:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123a54:	e5933000 	ldr	r3, [r3]
  123a58:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
              tcp_seg_free(prev);
  123a5c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  123a60:	ebffef05 	bl	11f67c <tcp_seg_free>
            while (next &&
  123a64:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123a68:	e3530000 	cmp	r3, #0
  123a6c:	0a000010 	beq	123ab4 <tcp_receive+0x11b8>
                   TCP_SEQ_GEQ(seqno + tcplen,
  123a70:	e30f324a 	movw	r3, #62026	; 0xf24a
  123a74:	e3403014 	movt	r3, #20
  123a78:	e1d330b0 	ldrh	r3, [r3]
  123a7c:	e1a02003 	mov	r2, r3
  123a80:	e30f3240 	movw	r3, #62016	; 0xf240
  123a84:	e3403014 	movt	r3, #20
  123a88:	e5933000 	ldr	r3, [r3]
  123a8c:	e0822003 	add	r2, r2, r3
  123a90:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123a94:	e593300c 	ldr	r3, [r3, #12]
  123a98:	e5933004 	ldr	r3, [r3, #4]
  123a9c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  123aa0:	e1d110b8 	ldrh	r1, [r1, #8]
  123aa4:	e0833001 	add	r3, r3, r1
  123aa8:	e0423003 	sub	r3, r2, r3
            while (next &&
  123aac:	e3530000 	cmp	r3, #0
  123ab0:	aaffffaa 	bge	123960 <tcp_receive+0x1064>
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
  123ab4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123ab8:	e3530000 	cmp	r3, #0
  123abc:	0a000060 	beq	123c44 <tcp_receive+0x1348>
                TCP_SEQ_GT(seqno + tcplen,
  123ac0:	e30f324a 	movw	r3, #62026	; 0xf24a
  123ac4:	e3403014 	movt	r3, #20
  123ac8:	e1d330b0 	ldrh	r3, [r3]
  123acc:	e1a02003 	mov	r2, r3
  123ad0:	e30f3240 	movw	r3, #62016	; 0xf240
  123ad4:	e3403014 	movt	r3, #20
  123ad8:	e5933000 	ldr	r3, [r3]
  123adc:	e0822003 	add	r2, r2, r3
  123ae0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123ae4:	e593300c 	ldr	r3, [r3, #12]
  123ae8:	e5933004 	ldr	r3, [r3, #4]
  123aec:	e0423003 	sub	r3, r2, r3
            if (next &&
  123af0:	e3530000 	cmp	r3, #0
  123af4:	da000052 	ble	123c44 <tcp_receive+0x1348>
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  123af8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123afc:	e593300c 	ldr	r3, [r3, #12]
  123b00:	e5933004 	ldr	r3, [r3, #4]
  123b04:	e6ff2073 	uxth	r2, r3
  123b08:	e30f3240 	movw	r3, #62016	; 0xf240
  123b0c:	e3403014 	movt	r3, #20
  123b10:	e5933000 	ldr	r3, [r3]
  123b14:	e6ff3073 	uxth	r3, r3
  123b18:	e0423003 	sub	r3, r2, r3
  123b1c:	e6ff2073 	uxth	r2, r3
  123b20:	e30f3220 	movw	r3, #61984	; 0xf220
  123b24:	e3403014 	movt	r3, #20
  123b28:	e1c320b8 	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
  123b2c:	e30f3220 	movw	r3, #61984	; 0xf220
  123b30:	e3403014 	movt	r3, #20
  123b34:	e593300c 	ldr	r3, [r3, #12]
  123b38:	e1d330bc 	ldrh	r3, [r3, #12]
  123b3c:	e6ff3073 	uxth	r3, r3
  123b40:	e1a00003 	mov	r0, r3
  123b44:	ebffcb23 	bl	1167d8 <lwip_htons>
  123b48:	e1a03000 	mov	r3, r0
  123b4c:	e2033002 	and	r3, r3, #2
  123b50:	e3530000 	cmp	r3, #0
  123b54:	0a000007 	beq	123b78 <tcp_receive+0x127c>
                inseg.len -= 1;
  123b58:	e30f3220 	movw	r3, #61984	; 0xf220
  123b5c:	e3403014 	movt	r3, #20
  123b60:	e1d330b8 	ldrh	r3, [r3, #8]
  123b64:	e2433001 	sub	r3, r3, #1
  123b68:	e6ff2073 	uxth	r2, r3
  123b6c:	e30f3220 	movw	r3, #61984	; 0xf220
  123b70:	e3403014 	movt	r3, #20
  123b74:	e1c320b8 	strh	r2, [r3, #8]
              }
              pbuf_realloc(inseg.p, inseg.len);
  123b78:	e30f3220 	movw	r3, #61984	; 0xf220
  123b7c:	e3403014 	movt	r3, #20
  123b80:	e5932004 	ldr	r2, [r3, #4]
  123b84:	e30f3220 	movw	r3, #61984	; 0xf220
  123b88:	e3403014 	movt	r3, #20
  123b8c:	e1d330b8 	ldrh	r3, [r3, #8]
  123b90:	e1a01003 	mov	r1, r3
  123b94:	e1a00002 	mov	r0, r2
  123b98:	ebffdbfc 	bl	11ab90 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
  123b9c:	e30f3220 	movw	r3, #61984	; 0xf220
  123ba0:	e3403014 	movt	r3, #20
  123ba4:	e1d340b8 	ldrh	r4, [r3, #8]
  123ba8:	e30f3220 	movw	r3, #61984	; 0xf220
  123bac:	e3403014 	movt	r3, #20
  123bb0:	e593300c 	ldr	r3, [r3, #12]
  123bb4:	e1d330bc 	ldrh	r3, [r3, #12]
  123bb8:	e6ff3073 	uxth	r3, r3
  123bbc:	e1a00003 	mov	r0, r3
  123bc0:	ebffcb04 	bl	1167d8 <lwip_htons>
  123bc4:	e1a03000 	mov	r3, r0
  123bc8:	e2033003 	and	r3, r3, #3
  123bcc:	e3530000 	cmp	r3, #0
  123bd0:	0a000001 	beq	123bdc <tcp_receive+0x12e0>
  123bd4:	e3a03001 	mov	r3, #1
  123bd8:	ea000000 	b	123be0 <tcp_receive+0x12e4>
  123bdc:	e3a03000 	mov	r3, #0
  123be0:	e0833004 	add	r3, r3, r4
  123be4:	e6ff2073 	uxth	r2, r3
  123be8:	e30f324a 	movw	r3, #62026	; 0xf24a
  123bec:	e3403014 	movt	r3, #20
  123bf0:	e1c320b0 	strh	r2, [r3]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
  123bf4:	e30f324a 	movw	r3, #62026	; 0xf24a
  123bf8:	e3403014 	movt	r3, #20
  123bfc:	e1d330b0 	ldrh	r3, [r3]
  123c00:	e1a02003 	mov	r2, r3
  123c04:	e30f3240 	movw	r3, #62016	; 0xf240
  123c08:	e3403014 	movt	r3, #20
  123c0c:	e5933000 	ldr	r3, [r3]
  123c10:	e0822003 	add	r2, r2, r3
  123c14:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  123c18:	e593300c 	ldr	r3, [r3, #12]
  123c1c:	e5933004 	ldr	r3, [r3, #4]
  123c20:	e1520003 	cmp	r2, r3
  123c24:	0a000006 	beq	123c44 <tcp_receive+0x1348>
  123c28:	e3080798 	movw	r0, #34712	; 0x8798
  123c2c:	e3400014 	movt	r0, #20
  123c30:	ebff7d37 	bl	103114 <rt_kprintf>
  123c34:	e300159c 	movw	r1, #1436	; 0x59c
  123c38:	e30804d0 	movw	r0, #34000	; 0x84d0
  123c3c:	e3400014 	movt	r0, #20
  123c40:	ebff9d0d 	bl	10b07c <sys_arch_assert>
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
  123c44:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123c48:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  123c4c:	e5832074 	str	r2, [r3, #116]	; 0x74
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
  123c50:	e30f324a 	movw	r3, #62026	; 0xf24a
  123c54:	e3403014 	movt	r3, #20
  123c58:	e1d330b0 	ldrh	r3, [r3]
  123c5c:	e1a02003 	mov	r2, r3
  123c60:	e30f3240 	movw	r3, #62016	; 0xf240
  123c64:	e3403014 	movt	r3, #20
  123c68:	e5933000 	ldr	r3, [r3]
  123c6c:	e0822003 	add	r2, r2, r3
  123c70:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123c74:	e5832028 	str	r2, [r3, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
  123c78:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123c7c:	e1d322bc 	ldrh	r2, [r3, #44]	; 0x2c
  123c80:	e30f324a 	movw	r3, #62026	; 0xf24a
  123c84:	e3403014 	movt	r3, #20
  123c88:	e1d330b0 	ldrh	r3, [r3]
  123c8c:	e1520003 	cmp	r2, r3
  123c90:	2a000006 	bcs	123cb0 <tcp_receive+0x13b4>
  123c94:	e30807d4 	movw	r0, #34772	; 0x87d4
  123c98:	e3400014 	movt	r0, #20
  123c9c:	ebff7d1c 	bl	103114 <rt_kprintf>
  123ca0:	e30015a6 	movw	r1, #1446	; 0x5a6
  123ca4:	e30804d0 	movw	r0, #34000	; 0x84d0
  123ca8:	e3400014 	movt	r0, #20
  123cac:	ebff9cf2 	bl	10b07c <sys_arch_assert>
        pcb->rcv_wnd -= tcplen;
  123cb0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123cb4:	e1d322bc 	ldrh	r2, [r3, #44]	; 0x2c
  123cb8:	e30f324a 	movw	r3, #62026	; 0xf24a
  123cbc:	e3403014 	movt	r3, #20
  123cc0:	e1d330b0 	ldrh	r3, [r3]
  123cc4:	e0423003 	sub	r3, r2, r3
  123cc8:	e6ff2073 	uxth	r2, r3
  123ccc:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123cd0:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
  123cd4:	e51b0040 	ldr	r0, [fp, #-64]	; 0xffffffc0
  123cd8:	ebffe93b 	bl	11e1cc <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  123cdc:	e30f3220 	movw	r3, #61984	; 0xf220
  123ce0:	e3403014 	movt	r3, #20
  123ce4:	e5933004 	ldr	r3, [r3, #4]
  123ce8:	e1d330b8 	ldrh	r3, [r3, #8]
  123cec:	e3530000 	cmp	r3, #0
  123cf0:	0a000009 	beq	123d1c <tcp_receive+0x1420>
          recv_data = inseg.p;
  123cf4:	e30f3220 	movw	r3, #61984	; 0xf220
  123cf8:	e3403014 	movt	r3, #20
  123cfc:	e5932004 	ldr	r2, [r3, #4]
  123d00:	e30f3250 	movw	r3, #62032	; 0xf250
  123d04:	e3403014 	movt	r3, #20
  123d08:	e5832000 	str	r2, [r3]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  123d0c:	e30f3220 	movw	r3, #61984	; 0xf220
  123d10:	e3403014 	movt	r3, #20
  123d14:	e3a02000 	mov	r2, #0
  123d18:	e5832004 	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  123d1c:	e30f3220 	movw	r3, #61984	; 0xf220
  123d20:	e3403014 	movt	r3, #20
  123d24:	e593300c 	ldr	r3, [r3, #12]
  123d28:	e1d330bc 	ldrh	r3, [r3, #12]
  123d2c:	e6ff3073 	uxth	r3, r3
  123d30:	e1a00003 	mov	r0, r3
  123d34:	ebffcaa7 	bl	1167d8 <lwip_htons>
  123d38:	e1a03000 	mov	r3, r0
  123d3c:	e2033001 	and	r3, r3, #1
  123d40:	e3530000 	cmp	r3, #0
  123d44:	0a000099 	beq	123fb0 <tcp_receive+0x16b4>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
  123d48:	e30f324d 	movw	r3, #62029	; 0xf24d
  123d4c:	e3403014 	movt	r3, #20
  123d50:	e5d33000 	ldrb	r3, [r3]
  123d54:	e3833020 	orr	r3, r3, #32
  123d58:	e6ef2073 	uxtb	r2, r3
  123d5c:	e30f324d 	movw	r3, #62029	; 0xf24d
  123d60:	e3403014 	movt	r3, #20
  123d64:	e5c32000 	strb	r2, [r3]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
  123d68:	ea000090 	b	123fb0 <tcp_receive+0x16b4>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
  123d6c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123d70:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  123d74:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
          seqno = pcb->ooseq->tcphdr->seqno;
  123d78:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123d7c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  123d80:	e593300c 	ldr	r3, [r3, #12]
  123d84:	e5932004 	ldr	r2, [r3, #4]
  123d88:	e30f3240 	movw	r3, #62016	; 0xf240
  123d8c:	e3403014 	movt	r3, #20
  123d90:	e5832000 	str	r2, [r3]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  123d94:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123d98:	e1d330b8 	ldrh	r3, [r3, #8]
  123d9c:	e1a04003 	mov	r4, r3
  123da0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123da4:	e593300c 	ldr	r3, [r3, #12]
  123da8:	e1d330bc 	ldrh	r3, [r3, #12]
  123dac:	e6ff3073 	uxth	r3, r3
  123db0:	e1a00003 	mov	r0, r3
  123db4:	ebffca87 	bl	1167d8 <lwip_htons>
  123db8:	e1a03000 	mov	r3, r0
  123dbc:	e2033003 	and	r3, r3, #3
  123dc0:	e3530000 	cmp	r3, #0
  123dc4:	0a000001 	beq	123dd0 <tcp_receive+0x14d4>
  123dc8:	e3a03001 	mov	r3, #1
  123dcc:	ea000000 	b	123dd4 <tcp_receive+0x14d8>
  123dd0:	e3a03000 	mov	r3, #0
  123dd4:	e0832004 	add	r2, r3, r4
  123dd8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123ddc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  123de0:	e0822003 	add	r2, r2, r3
  123de4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123de8:	e5832028 	str	r2, [r3, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
  123dec:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123df0:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  123df4:	e1a04003 	mov	r4, r3
  123df8:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123dfc:	e1d330b8 	ldrh	r3, [r3, #8]
  123e00:	e1a05003 	mov	r5, r3
  123e04:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123e08:	e593300c 	ldr	r3, [r3, #12]
  123e0c:	e1d330bc 	ldrh	r3, [r3, #12]
  123e10:	e6ff3073 	uxth	r3, r3
  123e14:	e1a00003 	mov	r0, r3
  123e18:	ebffca6e 	bl	1167d8 <lwip_htons>
  123e1c:	e1a03000 	mov	r3, r0
  123e20:	e2033003 	and	r3, r3, #3
  123e24:	e3530000 	cmp	r3, #0
  123e28:	0a000001 	beq	123e34 <tcp_receive+0x1538>
  123e2c:	e3a03001 	mov	r3, #1
  123e30:	ea000000 	b	123e38 <tcp_receive+0x153c>
  123e34:	e3a03000 	mov	r3, #0
  123e38:	e0833005 	add	r3, r3, r5
  123e3c:	e1540003 	cmp	r4, r3
  123e40:	2a000006 	bcs	123e60 <tcp_receive+0x1564>
  123e44:	e30807f4 	movw	r0, #34804	; 0x87f4
  123e48:	e3400014 	movt	r0, #20
  123e4c:	ebff7cb0 	bl	103114 <rt_kprintf>
  123e50:	e30015cb 	movw	r1, #1483	; 0x5cb
  123e54:	e30804d0 	movw	r0, #34000	; 0x84d0
  123e58:	e3400014 	movt	r0, #20
  123e5c:	ebff9c86 	bl	10b07c <sys_arch_assert>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  123e60:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123e64:	e1d330b8 	ldrh	r3, [r3, #8]
  123e68:	e1a04003 	mov	r4, r3
  123e6c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123e70:	e593300c 	ldr	r3, [r3, #12]
  123e74:	e1d330bc 	ldrh	r3, [r3, #12]
  123e78:	e6ff3073 	uxth	r3, r3
  123e7c:	e1a00003 	mov	r0, r3
  123e80:	ebffca54 	bl	1167d8 <lwip_htons>
  123e84:	e1a03000 	mov	r3, r0
  123e88:	e2033003 	and	r3, r3, #3
  123e8c:	e3530000 	cmp	r3, #0
  123e90:	0a000001 	beq	123e9c <tcp_receive+0x15a0>
  123e94:	e3a03001 	mov	r3, #1
  123e98:	ea000000 	b	123ea0 <tcp_receive+0x15a4>
  123e9c:	e3a03000 	mov	r3, #0
  123ea0:	e0831004 	add	r1, r3, r4
  123ea4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123ea8:	e1d322bc 	ldrh	r2, [r3, #44]	; 0x2c
  123eac:	e6ff3071 	uxth	r3, r1
  123eb0:	e0423003 	sub	r3, r2, r3
  123eb4:	e6ff2073 	uxth	r2, r3
  123eb8:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123ebc:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c

          tcp_update_rcv_ann_wnd(pcb);
  123ec0:	e51b0040 	ldr	r0, [fp, #-64]	; 0xffffffc0
  123ec4:	ebffe8c0 	bl	11e1cc <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
  123ec8:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123ecc:	e5933004 	ldr	r3, [r3, #4]
  123ed0:	e1d330b8 	ldrh	r3, [r3, #8]
  123ed4:	e3530000 	cmp	r3, #0
  123ed8:	0a000015 	beq	123f34 <tcp_receive+0x1638>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            /* With window scaling, this can overflow recv_data->tot_len, but
               that's not a problem since we explicitly fix that before passing
               recv_data to the application. */
            if (recv_data) {
  123edc:	e30f3250 	movw	r3, #62032	; 0xf250
  123ee0:	e3403014 	movt	r3, #20
  123ee4:	e5933000 	ldr	r3, [r3]
  123ee8:	e3530000 	cmp	r3, #0
  123eec:	0a000008 	beq	123f14 <tcp_receive+0x1618>
              pbuf_cat(recv_data, cseg->p);
  123ef0:	e30f3250 	movw	r3, #62032	; 0xf250
  123ef4:	e3403014 	movt	r3, #20
  123ef8:	e5932000 	ldr	r2, [r3]
  123efc:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123f00:	e5933004 	ldr	r3, [r3, #4]
  123f04:	e1a01003 	mov	r1, r3
  123f08:	e1a00002 	mov	r0, r2
  123f0c:	ebffdd1f 	bl	11b390 <pbuf_cat>
  123f10:	ea000004 	b	123f28 <tcp_receive+0x162c>
            } else {
              recv_data = cseg->p;
  123f14:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123f18:	e5932004 	ldr	r2, [r3, #4]
  123f1c:	e30f3250 	movw	r3, #62032	; 0xf250
  123f20:	e3403014 	movt	r3, #20
  123f24:	e5832000 	str	r2, [r3]
            }
            cseg->p = NULL;
  123f28:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123f2c:	e3a02000 	mov	r2, #0
  123f30:	e5832004 	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  123f34:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123f38:	e593300c 	ldr	r3, [r3, #12]
  123f3c:	e1d330bc 	ldrh	r3, [r3, #12]
  123f40:	e6ff3073 	uxth	r3, r3
  123f44:	e1a00003 	mov	r0, r3
  123f48:	ebffca22 	bl	1167d8 <lwip_htons>
  123f4c:	e1a03000 	mov	r3, r0
  123f50:	e2033001 	and	r3, r3, #1
  123f54:	e3530000 	cmp	r3, #0
  123f58:	0a00000e 	beq	123f98 <tcp_receive+0x169c>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
  123f5c:	e30f324d 	movw	r3, #62029	; 0xf24d
  123f60:	e3403014 	movt	r3, #20
  123f64:	e5d33000 	ldrb	r3, [r3]
  123f68:	e3833020 	orr	r3, r3, #32
  123f6c:	e6ef2073 	uxtb	r2, r3
  123f70:	e30f324d 	movw	r3, #62029	; 0xf24d
  123f74:	e3403014 	movt	r3, #20
  123f78:	e5c32000 	strb	r2, [r3]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  123f7c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123f80:	e5933014 	ldr	r3, [r3, #20]
  123f84:	e3530004 	cmp	r3, #4
  123f88:	1a000002 	bne	123f98 <tcp_receive+0x169c>
              pcb->state = CLOSE_WAIT;
  123f8c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123f90:	e3a02007 	mov	r2, #7
  123f94:	e5832014 	str	r2, [r3, #20]
            }
          }

          pcb->ooseq = cseg->next;
  123f98:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  123f9c:	e5932000 	ldr	r2, [r3]
  123fa0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123fa4:	e5832074 	str	r2, [r3, #116]	; 0x74
          tcp_seg_free(cseg);
  123fa8:	e51b0038 	ldr	r0, [fp, #-56]	; 0xffffffc8
  123fac:	ebffedb2 	bl	11f67c <tcp_seg_free>
        while (pcb->ooseq != NULL &&
  123fb0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123fb4:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  123fb8:	e3530000 	cmp	r3, #0
  123fbc:	0a000007 	beq	123fe0 <tcp_receive+0x16e4>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  123fc0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123fc4:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  123fc8:	e593300c 	ldr	r3, [r3, #12]
  123fcc:	e5932004 	ldr	r2, [r3, #4]
  123fd0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123fd4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
        while (pcb->ooseq != NULL &&
  123fd8:	e1520003 	cmp	r2, r3
  123fdc:	0affff62 	beq	123d6c <tcp_receive+0x1470>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  123fe0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123fe4:	e5d3301e 	ldrb	r3, [r3, #30]
  123fe8:	e2033001 	and	r3, r3, #1
  123fec:	e3530000 	cmp	r3, #0
  123ff0:	0a00000c 	beq	124028 <tcp_receive+0x172c>
  123ff4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  123ff8:	e5d3301e 	ldrb	r3, [r3, #30]
  123ffc:	e3c33001 	bic	r3, r3, #1
  124000:	e6ef2073 	uxtb	r2, r3
  124004:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124008:	e5c3201e 	strb	r2, [r3, #30]
  12400c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124010:	e5d3301e 	ldrb	r3, [r3, #30]
  124014:	e3833002 	orr	r3, r3, #2
  124018:	e6ef2073 	uxtb	r2, r3
  12401c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124020:	e5c3201e 	strb	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
  124024:	ea00016c 	b	1245dc <tcp_receive+0x1ce0>
        tcp_ack(pcb);
  124028:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  12402c:	e5d3301e 	ldrb	r3, [r3, #30]
  124030:	e3833001 	orr	r3, r3, #1
  124034:	e6ef2073 	uxtb	r2, r3
  124038:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  12403c:	e5c3201e 	strb	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
  124040:	ea000165 	b	1245dc <tcp_receive+0x1ce0>
        }
#endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
  124044:	e51b0040 	ldr	r0, [fp, #-64]	; 0xffffffc0
  124048:	eb0007e2 	bl	125fd8 <tcp_send_empty_ack>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  12404c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124050:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  124054:	e3530000 	cmp	r3, #0
  124058:	1a000006 	bne	124078 <tcp_receive+0x177c>
          pcb->ooseq = tcp_seg_copy(&inseg);
  12405c:	e30f0220 	movw	r0, #61984	; 0xf220
  124060:	e3400014 	movt	r0, #20
  124064:	ebffeda6 	bl	11f704 <tcp_seg_copy>
  124068:	e1a02000 	mov	r2, r0
  12406c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124070:	e5832074 	str	r2, [r3, #116]	; 0x74
      if (pcb->rcv_nxt == seqno) {
  124074:	ea000158 	b	1245dc <tcp_receive+0x1ce0>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  124078:	e3a03000 	mov	r3, #0
  12407c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
          for (next = pcb->ooseq; next != NULL; next = next->next) {
  124080:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124084:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  124088:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  12408c:	ea00013f 	b	124590 <tcp_receive+0x1c94>
            if (seqno == next->tcphdr->seqno) {
  124090:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124094:	e593300c 	ldr	r3, [r3, #12]
  124098:	e5932004 	ldr	r2, [r3, #4]
  12409c:	e30f3240 	movw	r3, #62016	; 0xf240
  1240a0:	e3403014 	movt	r3, #20
  1240a4:	e5933000 	ldr	r3, [r3]
  1240a8:	e1520003 	cmp	r2, r3
  1240ac:	1a00001b 	bne	124120 <tcp_receive+0x1824>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  1240b0:	e30f3220 	movw	r3, #61984	; 0xf220
  1240b4:	e3403014 	movt	r3, #20
  1240b8:	e1d320b8 	ldrh	r2, [r3, #8]
  1240bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1240c0:	e1d330b8 	ldrh	r3, [r3, #8]
  1240c4:	e1520003 	cmp	r2, r3
  1240c8:	9a000134 	bls	1245a0 <tcp_receive+0x1ca4>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  1240cc:	e30f0220 	movw	r0, #61984	; 0xf220
  1240d0:	e3400014 	movt	r0, #20
  1240d4:	ebffed8a 	bl	11f704 <tcp_seg_copy>
  1240d8:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
                if (cseg != NULL) {
  1240dc:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1240e0:	e3530000 	cmp	r3, #0
  1240e4:	0a00012f 	beq	1245a8 <tcp_receive+0x1cac>
                  if (prev != NULL) {
  1240e8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1240ec:	e3530000 	cmp	r3, #0
  1240f0:	0a000003 	beq	124104 <tcp_receive+0x1808>
                    prev->next = cseg;
  1240f4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1240f8:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
  1240fc:	e5832000 	str	r2, [r3]
  124100:	ea000002 	b	124110 <tcp_receive+0x1814>
                  } else {
                    pcb->ooseq = cseg;
  124104:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124108:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
  12410c:	e5832074 	str	r2, [r3, #116]	; 0x74
                  }
                  tcp_oos_insert_segment(cseg, next);
  124110:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  124114:	e51b0038 	ldr	r0, [fp, #-56]	; 0xffffffc8
  124118:	ebfff989 	bl	122744 <tcp_oos_insert_segment>
                }
                break;
  12411c:	ea000121 	b	1245a8 <tcp_receive+0x1cac>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  124120:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  124124:	e3530000 	cmp	r3, #0
  124128:	1a000016 	bne	124188 <tcp_receive+0x188c>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  12412c:	e30f3240 	movw	r3, #62016	; 0xf240
  124130:	e3403014 	movt	r3, #20
  124134:	e5932000 	ldr	r2, [r3]
  124138:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12413c:	e593300c 	ldr	r3, [r3, #12]
  124140:	e5933004 	ldr	r3, [r3, #4]
  124144:	e0423003 	sub	r3, r2, r3
  124148:	e3530000 	cmp	r3, #0
  12414c:	aa00004e 	bge	12428c <tcp_receive+0x1990>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
  124150:	e30f0220 	movw	r0, #61984	; 0xf220
  124154:	e3400014 	movt	r0, #20
  124158:	ebffed69 	bl	11f704 <tcp_seg_copy>
  12415c:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
                  if (cseg != NULL) {
  124160:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  124164:	e3530000 	cmp	r3, #0
  124168:	0a000110 	beq	1245b0 <tcp_receive+0x1cb4>
                    pcb->ooseq = cseg;
  12416c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124170:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
  124174:	e5832074 	str	r2, [r3, #116]	; 0x74
                    tcp_oos_insert_segment(cseg, next);
  124178:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  12417c:	e51b0038 	ldr	r0, [fp, #-56]	; 0xffffffc8
  124180:	ebfff96f 	bl	122744 <tcp_oos_insert_segment>
                  }
                  break;
  124184:	ea000109 	b	1245b0 <tcp_receive+0x1cb4>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
  124188:	e30f3240 	movw	r3, #62016	; 0xf240
  12418c:	e3403014 	movt	r3, #20
  124190:	e5932000 	ldr	r2, [r3]
  124194:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  124198:	e593300c 	ldr	r3, [r3, #12]
  12419c:	e5933004 	ldr	r3, [r3, #4]
  1241a0:	e0423003 	sub	r3, r2, r3
  1241a4:	e2433001 	sub	r3, r3, #1
  1241a8:	e3530000 	cmp	r3, #0
  1241ac:	ba000036 	blt	12428c <tcp_receive+0x1990>
  1241b0:	e30f3240 	movw	r3, #62016	; 0xf240
  1241b4:	e3403014 	movt	r3, #20
  1241b8:	e5932000 	ldr	r2, [r3]
  1241bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1241c0:	e593300c 	ldr	r3, [r3, #12]
  1241c4:	e5933004 	ldr	r3, [r3, #4]
  1241c8:	e0423003 	sub	r3, r2, r3
  1241cc:	e2833001 	add	r3, r3, #1
  1241d0:	e3530000 	cmp	r3, #0
  1241d4:	ca00002c 	bgt	12428c <tcp_receive+0x1990>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
  1241d8:	e30f0220 	movw	r0, #61984	; 0xf220
  1241dc:	e3400014 	movt	r0, #20
  1241e0:	ebffed47 	bl	11f704 <tcp_seg_copy>
  1241e4:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
                  if (cseg != NULL) {
  1241e8:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1241ec:	e3530000 	cmp	r3, #0
  1241f0:	0a0000f0 	beq	1245b8 <tcp_receive+0x1cbc>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  1241f4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1241f8:	e593300c 	ldr	r3, [r3, #12]
  1241fc:	e5933004 	ldr	r3, [r3, #4]
  124200:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  124204:	e1d220b8 	ldrh	r2, [r2, #8]
  124208:	e0832002 	add	r2, r3, r2
  12420c:	e30f3240 	movw	r3, #62016	; 0xf240
  124210:	e3403014 	movt	r3, #20
  124214:	e5933000 	ldr	r3, [r3]
  124218:	e0423003 	sub	r3, r2, r3
  12421c:	e3530000 	cmp	r3, #0
  124220:	da000012 	ble	124270 <tcp_receive+0x1974>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  124224:	e30f3240 	movw	r3, #62016	; 0xf240
  124228:	e3403014 	movt	r3, #20
  12422c:	e5933000 	ldr	r3, [r3]
  124230:	e6ff2073 	uxth	r2, r3
  124234:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  124238:	e593300c 	ldr	r3, [r3, #12]
  12423c:	e5933004 	ldr	r3, [r3, #4]
  124240:	e6ff3073 	uxth	r3, r3
  124244:	e0423003 	sub	r3, r2, r3
  124248:	e6ff2073 	uxth	r2, r3
  12424c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  124250:	e1c320b8 	strh	r2, [r3, #8]
                      pbuf_realloc(prev->p, prev->len);
  124254:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  124258:	e5932004 	ldr	r2, [r3, #4]
  12425c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  124260:	e1d330b8 	ldrh	r3, [r3, #8]
  124264:	e1a01003 	mov	r1, r3
  124268:	e1a00002 	mov	r0, r2
  12426c:	ebffda47 	bl	11ab90 <pbuf_realloc>
                    }
                    prev->next = cseg;
  124270:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  124274:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
  124278:	e5832000 	str	r2, [r3]
                    tcp_oos_insert_segment(cseg, next);
  12427c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  124280:	e51b0038 	ldr	r0, [fp, #-56]	; 0xffffffc8
  124284:	ebfff92e 	bl	122744 <tcp_oos_insert_segment>
                  }
                  break;
  124288:	ea0000ca 	b	1245b8 <tcp_receive+0x1cbc>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  12428c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124290:	e5933000 	ldr	r3, [r3]
  124294:	e3530000 	cmp	r3, #0
  124298:	1a0000b7 	bne	12457c <tcp_receive+0x1c80>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  12429c:	e30f3240 	movw	r3, #62016	; 0xf240
  1242a0:	e3403014 	movt	r3, #20
  1242a4:	e5932000 	ldr	r2, [r3]
  1242a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1242ac:	e593300c 	ldr	r3, [r3, #12]
  1242b0:	e5933004 	ldr	r3, [r3, #4]
  1242b4:	e0423003 	sub	r3, r2, r3
              if (next->next == NULL &&
  1242b8:	e3530000 	cmp	r3, #0
  1242bc:	da0000ae 	ble	12457c <tcp_receive+0x1c80>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
  1242c0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1242c4:	e593300c 	ldr	r3, [r3, #12]
  1242c8:	e1d330bc 	ldrh	r3, [r3, #12]
  1242cc:	e6ff3073 	uxth	r3, r3
  1242d0:	e1a00003 	mov	r0, r3
  1242d4:	ebffc93f 	bl	1167d8 <lwip_htons>
  1242d8:	e1a03000 	mov	r3, r0
  1242dc:	e2033001 	and	r3, r3, #1
  1242e0:	e3530000 	cmp	r3, #0
  1242e4:	1a0000b5 	bne	1245c0 <tcp_receive+0x1cc4>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
  1242e8:	e30f0220 	movw	r0, #61984	; 0xf220
  1242ec:	e3400014 	movt	r0, #20
  1242f0:	ebffed03 	bl	11f704 <tcp_seg_copy>
  1242f4:	e1a02000 	mov	r2, r0
  1242f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1242fc:	e5832000 	str	r2, [r3]
                if (next->next != NULL) {
  124300:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124304:	e5933000 	ldr	r3, [r3]
  124308:	e3530000 	cmp	r3, #0
  12430c:	0a0000ad 	beq	1245c8 <tcp_receive+0x1ccc>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  124310:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124314:	e593300c 	ldr	r3, [r3, #12]
  124318:	e5933004 	ldr	r3, [r3, #4]
  12431c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  124320:	e1d220b8 	ldrh	r2, [r2, #8]
  124324:	e0832002 	add	r2, r3, r2
  124328:	e30f3240 	movw	r3, #62016	; 0xf240
  12432c:	e3403014 	movt	r3, #20
  124330:	e5933000 	ldr	r3, [r3]
  124334:	e0423003 	sub	r3, r2, r3
  124338:	e3530000 	cmp	r3, #0
  12433c:	da000012 	ble	12438c <tcp_receive+0x1a90>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  124340:	e30f3240 	movw	r3, #62016	; 0xf240
  124344:	e3403014 	movt	r3, #20
  124348:	e5933000 	ldr	r3, [r3]
  12434c:	e6ff2073 	uxth	r2, r3
  124350:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124354:	e593300c 	ldr	r3, [r3, #12]
  124358:	e5933004 	ldr	r3, [r3, #4]
  12435c:	e6ff3073 	uxth	r3, r3
  124360:	e0423003 	sub	r3, r2, r3
  124364:	e6ff2073 	uxth	r2, r3
  124368:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12436c:	e1c320b8 	strh	r2, [r3, #8]
                    pbuf_realloc(next->p, next->len);
  124370:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124374:	e5932004 	ldr	r2, [r3, #4]
  124378:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12437c:	e1d330b8 	ldrh	r3, [r3, #8]
  124380:	e1a01003 	mov	r1, r3
  124384:	e1a00002 	mov	r0, r2
  124388:	ebffda00 	bl	11ab90 <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
  12438c:	e30f324a 	movw	r3, #62026	; 0xf24a
  124390:	e3403014 	movt	r3, #20
  124394:	e1d330b0 	ldrh	r3, [r3]
  124398:	e1a02003 	mov	r2, r3
  12439c:	e30f3240 	movw	r3, #62016	; 0xf240
  1243a0:	e3403014 	movt	r3, #20
  1243a4:	e5933000 	ldr	r3, [r3]
  1243a8:	e0822003 	add	r2, r2, r3
  1243ac:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1243b0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  1243b4:	e51b1040 	ldr	r1, [fp, #-64]	; 0xffffffc0
  1243b8:	e1d112bc 	ldrh	r1, [r1, #44]	; 0x2c
  1243bc:	e0833001 	add	r3, r3, r1
  1243c0:	e0423003 	sub	r3, r2, r3
  1243c4:	e3530000 	cmp	r3, #0
  1243c8:	da00007e 	ble	1245c8 <tcp_receive+0x1ccc>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG,
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
  1243cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1243d0:	e5933000 	ldr	r3, [r3]
  1243d4:	e593300c 	ldr	r3, [r3, #12]
  1243d8:	e1d330bc 	ldrh	r3, [r3, #12]
  1243dc:	e6ff3073 	uxth	r3, r3
  1243e0:	e1a00003 	mov	r0, r3
  1243e4:	ebffc8fb 	bl	1167d8 <lwip_htons>
  1243e8:	e1a03000 	mov	r3, r0
  1243ec:	e2033001 	and	r3, r3, #1
  1243f0:	e3530000 	cmp	r3, #0
  1243f4:	0a00001a 	beq	124464 <tcp_receive+0x1b68>
                      /* Must remove the FIN from the header as we're trimming
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
  1243f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1243fc:	e5933000 	ldr	r3, [r3]
  124400:	e593300c 	ldr	r3, [r3, #12]
  124404:	e1d330bc 	ldrh	r3, [r3, #12]
  124408:	e6ff3073 	uxth	r3, r3
  12440c:	e3c33c3f 	bic	r3, r3, #16128	; 0x3f00
  124410:	e6ff4073 	uxth	r4, r3
  124414:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124418:	e5933000 	ldr	r3, [r3]
  12441c:	e593300c 	ldr	r3, [r3, #12]
  124420:	e1d330bc 	ldrh	r3, [r3, #12]
  124424:	e6ff3073 	uxth	r3, r3
  124428:	e1a00003 	mov	r0, r3
  12442c:	ebffc8e9 	bl	1167d8 <lwip_htons>
  124430:	e1a03000 	mov	r3, r0
  124434:	e203303e 	and	r3, r3, #62	; 0x3e
  124438:	e6ff3073 	uxth	r3, r3
  12443c:	e1a00003 	mov	r0, r3
  124440:	ebffc8e4 	bl	1167d8 <lwip_htons>
  124444:	e1a03000 	mov	r3, r0
  124448:	e1a02003 	mov	r2, r3
  12444c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124450:	e5933000 	ldr	r3, [r3]
  124454:	e593300c 	ldr	r3, [r3, #12]
  124458:	e1842002 	orr	r2, r4, r2
  12445c:	e6ff2072 	uxth	r2, r2
  124460:	e1c320bc 	strh	r2, [r3, #12]
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
  124464:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124468:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12446c:	e6ff2073 	uxth	r2, r3
  124470:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124474:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  124478:	e0823003 	add	r3, r2, r3
  12447c:	e6ff1073 	uxth	r1, r3
  124480:	e30f3240 	movw	r3, #62016	; 0xf240
  124484:	e3403014 	movt	r3, #20
  124488:	e5933000 	ldr	r3, [r3]
  12448c:	e6ff2073 	uxth	r2, r3
  124490:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124494:	e5933000 	ldr	r3, [r3]
  124498:	e0412002 	sub	r2, r1, r2
  12449c:	e6ff2072 	uxth	r2, r2
  1244a0:	e1c320b8 	strh	r2, [r3, #8]
                    pbuf_realloc(next->next->p, next->next->len);
  1244a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1244a8:	e5933000 	ldr	r3, [r3]
  1244ac:	e5932004 	ldr	r2, [r3, #4]
  1244b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1244b4:	e5933000 	ldr	r3, [r3]
  1244b8:	e1d330b8 	ldrh	r3, [r3, #8]
  1244bc:	e1a01003 	mov	r1, r3
  1244c0:	e1a00002 	mov	r0, r2
  1244c4:	ebffd9b1 	bl	11ab90 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
  1244c8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1244cc:	e5933000 	ldr	r3, [r3]
  1244d0:	e1d340b8 	ldrh	r4, [r3, #8]
  1244d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1244d8:	e5933000 	ldr	r3, [r3]
  1244dc:	e593300c 	ldr	r3, [r3, #12]
  1244e0:	e1d330bc 	ldrh	r3, [r3, #12]
  1244e4:	e6ff3073 	uxth	r3, r3
  1244e8:	e1a00003 	mov	r0, r3
  1244ec:	ebffc8b9 	bl	1167d8 <lwip_htons>
  1244f0:	e1a03000 	mov	r3, r0
  1244f4:	e2033003 	and	r3, r3, #3
  1244f8:	e3530000 	cmp	r3, #0
  1244fc:	0a000001 	beq	124508 <tcp_receive+0x1c0c>
  124500:	e3a03001 	mov	r3, #1
  124504:	ea000000 	b	12450c <tcp_receive+0x1c10>
  124508:	e3a03000 	mov	r3, #0
  12450c:	e0833004 	add	r3, r3, r4
  124510:	e6ff2073 	uxth	r2, r3
  124514:	e30f324a 	movw	r3, #62026	; 0xf24a
  124518:	e3403014 	movt	r3, #20
  12451c:	e1c320b0 	strh	r2, [r3]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
  124520:	e30f324a 	movw	r3, #62026	; 0xf24a
  124524:	e3403014 	movt	r3, #20
  124528:	e1d330b0 	ldrh	r3, [r3]
  12452c:	e1a02003 	mov	r2, r3
  124530:	e30f3240 	movw	r3, #62016	; 0xf240
  124534:	e3403014 	movt	r3, #20
  124538:	e5933000 	ldr	r3, [r3]
  12453c:	e0822003 	add	r2, r2, r3
  124540:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124544:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  124548:	e51b1040 	ldr	r1, [fp, #-64]	; 0xffffffc0
  12454c:	e1d112bc 	ldrh	r1, [r1, #44]	; 0x2c
  124550:	e0833001 	add	r3, r3, r1
  124554:	e1520003 	cmp	r2, r3
  124558:	0a00001a 	beq	1245c8 <tcp_receive+0x1ccc>
  12455c:	e3080760 	movw	r0, #34656	; 0x8760
  124560:	e3400014 	movt	r0, #20
  124564:	ebff7aea 	bl	103114 <rt_kprintf>
  124568:	e3001668 	movw	r1, #1640	; 0x668
  12456c:	e30804d0 	movw	r0, #34000	; 0x84d0
  124570:	e3400014 	movt	r0, #20
  124574:	ebff9ac0 	bl	10b07c <sys_arch_assert>
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
  124578:	ea000012 	b	1245c8 <tcp_receive+0x1ccc>
              }
            }
            prev = next;
  12457c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124580:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
          for (next = pcb->ooseq; next != NULL; next = next->next) {
  124584:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124588:	e5933000 	ldr	r3, [r3]
  12458c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  124590:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124594:	e3530000 	cmp	r3, #0
  124598:	1afffebc 	bne	124090 <tcp_receive+0x1794>
      if (pcb->rcv_nxt == seqno) {
  12459c:	ea00000e 	b	1245dc <tcp_receive+0x1ce0>
                break;
  1245a0:	e320f000 	nop	{0}
  1245a4:	ea00000c 	b	1245dc <tcp_receive+0x1ce0>
                break;
  1245a8:	e320f000 	nop	{0}
  1245ac:	ea00000a 	b	1245dc <tcp_receive+0x1ce0>
                  break;
  1245b0:	e320f000 	nop	{0}
  1245b4:	ea000008 	b	1245dc <tcp_receive+0x1ce0>
                  break;
  1245b8:	e320f000 	nop	{0}
  1245bc:	ea000006 	b	1245dc <tcp_receive+0x1ce0>
                  break;
  1245c0:	e320f000 	nop	{0}
  1245c4:	ea000004 	b	1245dc <tcp_receive+0x1ce0>
                break;
  1245c8:	e320f000 	nop	{0}
      if (pcb->rcv_nxt == seqno) {
  1245cc:	ea000002 	b	1245dc <tcp_receive+0x1ce0>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not within the window. */
      tcp_send_empty_ack(pcb);
  1245d0:	e51b0040 	ldr	r0, [fp, #-64]	; 0xffffffc0
  1245d4:	eb00067f 	bl	125fd8 <tcp_send_empty_ack>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
  1245d8:	ea00001b 	b	12464c <tcp_receive+0x1d50>
  1245dc:	ea00001a 	b	12464c <tcp_receive+0x1d50>
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
  1245e0:	e30f3240 	movw	r3, #62016	; 0xf240
  1245e4:	e3403014 	movt	r3, #20
  1245e8:	e5932000 	ldr	r2, [r3]
  1245ec:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  1245f0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  1245f4:	e0423003 	sub	r3, r2, r3
  1245f8:	e3530000 	cmp	r3, #0
  1245fc:	ba00000b 	blt	124630 <tcp_receive+0x1d34>
  124600:	e30f3240 	movw	r3, #62016	; 0xf240
  124604:	e3403014 	movt	r3, #20
  124608:	e5932000 	ldr	r2, [r3]
  12460c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124610:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  124614:	e51b1040 	ldr	r1, [fp, #-64]	; 0xffffffc0
  124618:	e1d112bc 	ldrh	r1, [r1, #44]	; 0x2c
  12461c:	e0833001 	add	r3, r3, r1
  124620:	e0423003 	sub	r3, r2, r3
  124624:	e2833001 	add	r3, r3, #1
  124628:	e3530000 	cmp	r3, #0
  12462c:	da000006 	ble	12464c <tcp_receive+0x1d50>
      tcp_ack_now(pcb);
  124630:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124634:	e5d3301e 	ldrb	r3, [r3, #30]
  124638:	e3833002 	orr	r3, r3, #2
  12463c:	e6ef2073 	uxtb	r2, r3
  124640:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
  124644:	e5c3201e 	strb	r2, [r3, #30]
    }
  }
}
  124648:	eaffffff 	b	12464c <tcp_receive+0x1d50>
  12464c:	e320f000 	nop	{0}
  124650:	e24bd010 	sub	sp, fp, #16
  124654:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

00124658 <tcp_getoptbyte>:

static u8_t
tcp_getoptbyte(void)
{
  124658:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  12465c:	e28db000 	add	fp, sp, #0
  124660:	e24dd00c 	sub	sp, sp, #12
  if ((tcphdr_opt2 == NULL) || (tcp_optidx < tcphdr_opt1len)) {
  124664:	e30f3238 	movw	r3, #62008	; 0xf238
  124668:	e3403014 	movt	r3, #20
  12466c:	e5933000 	ldr	r3, [r3]
  124670:	e3530000 	cmp	r3, #0
  124674:	0a000007 	beq	124698 <tcp_getoptbyte+0x40>
  124678:	e30f323c 	movw	r3, #62012	; 0xf23c
  12467c:	e3403014 	movt	r3, #20
  124680:	e1d320b0 	ldrh	r2, [r3]
  124684:	e30f3236 	movw	r3, #62006	; 0xf236
  124688:	e3403014 	movt	r3, #20
  12468c:	e1d330b0 	ldrh	r3, [r3]
  124690:	e1520003 	cmp	r2, r3
  124694:	2a000010 	bcs	1246dc <tcp_getoptbyte+0x84>
    u8_t* opts = (u8_t *)tcphdr + TCP_HLEN;
  124698:	e30f3230 	movw	r3, #62000	; 0xf230
  12469c:	e3403014 	movt	r3, #20
  1246a0:	e5933000 	ldr	r3, [r3]
  1246a4:	e2833014 	add	r3, r3, #20
  1246a8:	e50b300c 	str	r3, [fp, #-12]
    return opts[tcp_optidx++];
  1246ac:	e30f323c 	movw	r3, #62012	; 0xf23c
  1246b0:	e3403014 	movt	r3, #20
  1246b4:	e1d320b0 	ldrh	r2, [r3]
  1246b8:	e2823001 	add	r3, r2, #1
  1246bc:	e6ff1073 	uxth	r1, r3
  1246c0:	e30f323c 	movw	r3, #62012	; 0xf23c
  1246c4:	e3403014 	movt	r3, #20
  1246c8:	e1c310b0 	strh	r1, [r3]
  1246cc:	e51b300c 	ldr	r3, [fp, #-12]
  1246d0:	e0833002 	add	r3, r3, r2
  1246d4:	e5d33000 	ldrb	r3, [r3]
  1246d8:	ea000014 	b	124730 <tcp_getoptbyte+0xd8>
  } else {
    u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
  1246dc:	e30f323c 	movw	r3, #62012	; 0xf23c
  1246e0:	e3403014 	movt	r3, #20
  1246e4:	e1d320b0 	ldrh	r2, [r3]
  1246e8:	e2823001 	add	r3, r2, #1
  1246ec:	e6ff1073 	uxth	r1, r3
  1246f0:	e30f323c 	movw	r3, #62012	; 0xf23c
  1246f4:	e3403014 	movt	r3, #20
  1246f8:	e1c310b0 	strh	r1, [r3]
  1246fc:	e6ef2072 	uxtb	r2, r2
  124700:	e30f3236 	movw	r3, #62006	; 0xf236
  124704:	e3403014 	movt	r3, #20
  124708:	e1d330b0 	ldrh	r3, [r3]
  12470c:	e6ef3073 	uxtb	r3, r3
  124710:	e0423003 	sub	r3, r2, r3
  124714:	e54b3005 	strb	r3, [fp, #-5]
    return tcphdr_opt2[idx];
  124718:	e30f3238 	movw	r3, #62008	; 0xf238
  12471c:	e3403014 	movt	r3, #20
  124720:	e5932000 	ldr	r2, [r3]
  124724:	e55b3005 	ldrb	r3, [fp, #-5]
  124728:	e0823003 	add	r3, r2, r3
  12472c:	e5d33000 	ldrb	r3, [r3]
  }
}
  124730:	e1a00003 	mov	r0, r3
  124734:	e28bd000 	add	sp, fp, #0
  124738:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  12473c:	e12fff1e 	bx	lr

00124740 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  124740:	e92d4800 	push	{fp, lr}
  124744:	e28db004 	add	fp, sp, #4
  124748:	e24dd010 	sub	sp, sp, #16
  12474c:	e50b0010 	str	r0, [fp, #-16]
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
  124750:	e30f3234 	movw	r3, #62004	; 0xf234
  124754:	e3403014 	movt	r3, #20
  124758:	e1d330b0 	ldrh	r3, [r3]
  12475c:	e3530000 	cmp	r3, #0
  124760:	0a000054 	beq	1248b8 <tcp_parseopt+0x178>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
  124764:	e30f323c 	movw	r3, #62012	; 0xf23c
  124768:	e3403014 	movt	r3, #20
  12476c:	e3a02000 	mov	r2, #0
  124770:	e1c320b0 	strh	r2, [r3]
  124774:	ea000041 	b	124880 <tcp_parseopt+0x140>
      u8_t opt = tcp_getoptbyte();
  124778:	ebffffb6 	bl	124658 <tcp_getoptbyte>
  12477c:	e1a03000 	mov	r3, r0
  124780:	e54b3005 	strb	r3, [fp, #-5]
      switch (opt) {
  124784:	e55b3005 	ldrb	r3, [fp, #-5]
  124788:	e3530001 	cmp	r3, #1
  12478c:	0a00003b 	beq	124880 <tcp_parseopt+0x140>
  124790:	e3530002 	cmp	r3, #2
  124794:	0a000002 	beq	1247a4 <tcp_parseopt+0x64>
  124798:	e3530000 	cmp	r3, #0
  12479c:	0a000040 	beq	1248a4 <tcp_parseopt+0x164>
  1247a0:	ea000024 	b	124838 <tcp_parseopt+0xf8>
        /* NOP option. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
      case LWIP_TCP_OPT_MSS:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (tcp_getoptbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
  1247a4:	ebffffab 	bl	124658 <tcp_getoptbyte>
  1247a8:	e1a03000 	mov	r3, r0
  1247ac:	e3530004 	cmp	r3, #4
  1247b0:	1a00003d 	bne	1248ac <tcp_parseopt+0x16c>
  1247b4:	e30f323c 	movw	r3, #62012	; 0xf23c
  1247b8:	e3403014 	movt	r3, #20
  1247bc:	e1d330b0 	ldrh	r3, [r3]
  1247c0:	e2832002 	add	r2, r3, #2
  1247c4:	e30f3234 	movw	r3, #62004	; 0xf234
  1247c8:	e3403014 	movt	r3, #20
  1247cc:	e1d330b0 	ldrh	r3, [r3]
  1247d0:	e1520003 	cmp	r2, r3
  1247d4:	ca000034 	bgt	1248ac <tcp_parseopt+0x16c>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (tcp_getoptbyte() << 8);
  1247d8:	ebffff9e 	bl	124658 <tcp_getoptbyte>
  1247dc:	e1a03000 	mov	r3, r0
  1247e0:	e6ff3073 	uxth	r3, r3
  1247e4:	e1a03403 	lsl	r3, r3, #8
  1247e8:	e14b30b8 	strh	r3, [fp, #-8]
        mss |= tcp_getoptbyte();
  1247ec:	ebffff99 	bl	124658 <tcp_getoptbyte>
  1247f0:	e1a03000 	mov	r3, r0
  1247f4:	e6ff2073 	uxth	r2, r3
  1247f8:	e15b30b8 	ldrh	r3, [fp, #-8]
  1247fc:	e1823003 	orr	r3, r2, r3
  124800:	e14b30b8 	strh	r3, [fp, #-8]
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  124804:	e15b30b8 	ldrh	r3, [fp, #-8]
  124808:	e30025b4 	movw	r2, #1460	; 0x5b4
  12480c:	e1530002 	cmp	r3, r2
  124810:	8a000004 	bhi	124828 <tcp_parseopt+0xe8>
  124814:	e15b30b8 	ldrh	r3, [fp, #-8]
  124818:	e3530000 	cmp	r3, #0
  12481c:	0a000001 	beq	124828 <tcp_parseopt+0xe8>
  124820:	e15b30b8 	ldrh	r3, [fp, #-8]
  124824:	ea000000 	b	12482c <tcp_parseopt+0xec>
  124828:	e30035b4 	movw	r3, #1460	; 0x5b4
  12482c:	e51b2010 	ldr	r2, [fp, #-16]
  124830:	e1c233b6 	strh	r3, [r2, #54]	; 0x36
        break;
  124834:	ea000011 	b	124880 <tcp_parseopt+0x140>
        tcp_optidx += LWIP_TCP_OPT_LEN_TS - 6;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        data = tcp_getoptbyte();
  124838:	ebffff86 	bl	124658 <tcp_getoptbyte>
  12483c:	e1a03000 	mov	r3, r0
  124840:	e54b3009 	strb	r3, [fp, #-9]
        if (data < 2) {
  124844:	e55b3009 	ldrb	r3, [fp, #-9]
  124848:	e3530001 	cmp	r3, #1
  12484c:	9a000018 	bls	1248b4 <tcp_parseopt+0x174>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        tcp_optidx += data - 2;
  124850:	e55b3009 	ldrb	r3, [fp, #-9]
  124854:	e6ff2073 	uxth	r2, r3
  124858:	e30f323c 	movw	r3, #62012	; 0xf23c
  12485c:	e3403014 	movt	r3, #20
  124860:	e1d330b0 	ldrh	r3, [r3]
  124864:	e0823003 	add	r3, r2, r3
  124868:	e6ff3073 	uxth	r3, r3
  12486c:	e2433002 	sub	r3, r3, #2
  124870:	e6ff2073 	uxth	r2, r3
  124874:	e30f323c 	movw	r3, #62012	; 0xf23c
  124878:	e3403014 	movt	r3, #20
  12487c:	e1c320b0 	strh	r2, [r3]
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
  124880:	e30f323c 	movw	r3, #62012	; 0xf23c
  124884:	e3403014 	movt	r3, #20
  124888:	e1d320b0 	ldrh	r2, [r3]
  12488c:	e30f3234 	movw	r3, #62004	; 0xf234
  124890:	e3403014 	movt	r3, #20
  124894:	e1d330b0 	ldrh	r3, [r3]
  124898:	e1520003 	cmp	r2, r3
  12489c:	3affffb5 	bcc	124778 <tcp_parseopt+0x38>
  1248a0:	ea000004 	b	1248b8 <tcp_parseopt+0x178>
        return;
  1248a4:	e320f000 	nop	{0}
  1248a8:	ea000002 	b	1248b8 <tcp_parseopt+0x178>
          return;
  1248ac:	e320f000 	nop	{0}
  1248b0:	ea000000 	b	1248b8 <tcp_parseopt+0x178>
          return;
  1248b4:	e320f000 	nop	{0}
      }
    }
  }
}
  1248b8:	e24bd004 	sub	sp, fp, #4
  1248bc:	e8bd8800 	pop	{fp, pc}

001248c0 <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
  1248c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1248c4:	e28db000 	add	fp, sp, #0
  recv_flags |= TF_CLOSED;
  1248c8:	e30f324d 	movw	r3, #62029	; 0xf24d
  1248cc:	e3403014 	movt	r3, #20
  1248d0:	e5d33000 	ldrb	r3, [r3]
  1248d4:	e3833010 	orr	r3, r3, #16
  1248d8:	e6ef2073 	uxtb	r2, r3
  1248dc:	e30f324d 	movw	r3, #62029	; 0xf24d
  1248e0:	e3403014 	movt	r3, #20
  1248e4:	e5c32000 	strb	r2, [r3]
}
  1248e8:	e320f000 	nop	{0}
  1248ec:	e28bd000 	add	sp, fp, #0
  1248f0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1248f4:	e12fff1e 	bx	lr

001248f8 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  1248f8:	e92d4800 	push	{fp, lr}
  1248fc:	e28db004 	add	fp, sp, #4
  124900:	e24dd018 	sub	sp, sp, #24
  124904:	e50b0010 	str	r0, [fp, #-16]
  124908:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  12490c:	e1a03001 	mov	r3, r1
  124910:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  124914:	e1a03002 	mov	r3, r2
  124918:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  12491c:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
  124920:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
  124924:	e0823003 	add	r3, r2, r3
  124928:	e6ff3073 	uxth	r3, r3
  12492c:	e2833014 	add	r3, r3, #20
  124930:	e6ff3073 	uxth	r3, r3
  124934:	e3a02000 	mov	r2, #0
  124938:	e1a01003 	mov	r1, r3
  12493c:	e3a00001 	mov	r0, #1
  124940:	ebffd6d4 	bl	11a498 <pbuf_alloc>
  124944:	e50b0008 	str	r0, [fp, #-8]
  if (p != NULL) {
  124948:	e51b3008 	ldr	r3, [fp, #-8]
  12494c:	e3530000 	cmp	r3, #0
  124950:	0a000052 	beq	124aa0 <tcp_output_alloc_header+0x1a8>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  124954:	e51b3008 	ldr	r3, [fp, #-8]
  124958:	e1d330ba 	ldrh	r3, [r3, #10]
  12495c:	e1a02003 	mov	r2, r3
  124960:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  124964:	e2833014 	add	r3, r3, #20
  124968:	e1520003 	cmp	r2, r3
  12496c:	aa000006 	bge	12498c <tcp_output_alloc_header+0x94>
  124970:	e308081c 	movw	r0, #34844	; 0x881c
  124974:	e3400014 	movt	r0, #20
  124978:	ebff79e5 	bl	103114 <rt_kprintf>
  12497c:	e3a01073 	mov	r1, #115	; 0x73
  124980:	e308084c 	movw	r0, #34892	; 0x884c
  124984:	e3400014 	movt	r0, #20
  124988:	ebff99bb 	bl	10b07c <sys_arch_assert>
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
  12498c:	e51b3008 	ldr	r3, [fp, #-8]
  124990:	e5933004 	ldr	r3, [r3, #4]
  124994:	e50b300c 	str	r3, [fp, #-12]
    tcphdr->src = lwip_htons(pcb->local_port);
  124998:	e51b3010 	ldr	r3, [fp, #-16]
  12499c:	e1d331ba 	ldrh	r3, [r3, #26]
  1249a0:	e1a00003 	mov	r0, r3
  1249a4:	ebffc78b 	bl	1167d8 <lwip_htons>
  1249a8:	e1a03000 	mov	r3, r0
  1249ac:	e1a02003 	mov	r2, r3
  1249b0:	e51b300c 	ldr	r3, [fp, #-12]
  1249b4:	e1c320b0 	strh	r2, [r3]
    tcphdr->dest = lwip_htons(pcb->remote_port);
  1249b8:	e51b3010 	ldr	r3, [fp, #-16]
  1249bc:	e1d331bc 	ldrh	r3, [r3, #28]
  1249c0:	e1a00003 	mov	r0, r3
  1249c4:	ebffc783 	bl	1167d8 <lwip_htons>
  1249c8:	e1a03000 	mov	r3, r0
  1249cc:	e1a02003 	mov	r2, r3
  1249d0:	e51b300c 	ldr	r3, [fp, #-12]
  1249d4:	e1c320b2 	strh	r2, [r3, #2]
    tcphdr->seqno = seqno_be;
  1249d8:	e51b300c 	ldr	r3, [fp, #-12]
  1249dc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1249e0:	e5832004 	str	r2, [r3, #4]
    tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
  1249e4:	e51b3010 	ldr	r3, [fp, #-16]
  1249e8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  1249ec:	e1a00003 	mov	r0, r3
  1249f0:	ebffc784 	bl	116808 <lwip_htonl>
  1249f4:	e1a02000 	mov	r2, r0
  1249f8:	e51b300c 	ldr	r3, [fp, #-12]
  1249fc:	e5832008 	str	r2, [r3, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
  124a00:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  124a04:	e1a03123 	lsr	r3, r3, #2
  124a08:	e6ff3073 	uxth	r3, r3
  124a0c:	e2833005 	add	r3, r3, #5
  124a10:	e6ff3073 	uxth	r3, r3
  124a14:	e1a03603 	lsl	r3, r3, #12
  124a18:	e6ff3073 	uxth	r3, r3
  124a1c:	e3833010 	orr	r3, r3, #16
  124a20:	e6ff3073 	uxth	r3, r3
  124a24:	e1a00003 	mov	r0, r3
  124a28:	ebffc76a 	bl	1167d8 <lwip_htons>
  124a2c:	e1a03000 	mov	r3, r0
  124a30:	e1a02003 	mov	r2, r3
  124a34:	e51b300c 	ldr	r3, [fp, #-12]
  124a38:	e1c320bc 	strh	r2, [r3, #12]
    tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  124a3c:	e51b3010 	ldr	r3, [fp, #-16]
  124a40:	e1d332be 	ldrh	r3, [r3, #46]	; 0x2e
  124a44:	e1a00003 	mov	r0, r3
  124a48:	ebffc762 	bl	1167d8 <lwip_htons>
  124a4c:	e1a03000 	mov	r3, r0
  124a50:	e1a02003 	mov	r2, r3
  124a54:	e51b300c 	ldr	r3, [fp, #-12]
  124a58:	e1c320be 	strh	r2, [r3, #14]
    tcphdr->chksum = 0;
  124a5c:	e51b300c 	ldr	r3, [fp, #-12]
  124a60:	e3a02000 	mov	r2, #0
  124a64:	e5c32010 	strb	r2, [r3, #16]
  124a68:	e3a02000 	mov	r2, #0
  124a6c:	e5c32011 	strb	r2, [r3, #17]
    tcphdr->urgp = 0;
  124a70:	e51b300c 	ldr	r3, [fp, #-12]
  124a74:	e3a02000 	mov	r2, #0
  124a78:	e5c32012 	strb	r2, [r3, #18]
  124a7c:	e3a02000 	mov	r2, #0
  124a80:	e5c32013 	strb	r2, [r3, #19]

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
  124a84:	e51b3010 	ldr	r3, [fp, #-16]
  124a88:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  124a8c:	e51b2010 	ldr	r2, [fp, #-16]
  124a90:	e1d222be 	ldrh	r2, [r2, #46]	; 0x2e
  124a94:	e0832002 	add	r2, r3, r2
  124a98:	e51b3010 	ldr	r3, [fp, #-16]
  124a9c:	e5832030 	str	r2, [r3, #48]	; 0x30
  }
  return p;
  124aa0:	e51b3008 	ldr	r3, [fp, #-8]
}
  124aa4:	e1a00003 	mov	r0, r3
  124aa8:	e24bd004 	sub	sp, fp, #4
  124aac:	e8bd8800 	pop	{fp, pc}

00124ab0 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
  124ab0:	e92d4810 	push	{r4, fp, lr}
  124ab4:	e28db008 	add	fp, sp, #8
  124ab8:	e24dd014 	sub	sp, sp, #20
  124abc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
  124ac0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124ac4:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  124ac8:	e3530000 	cmp	r3, #0
  124acc:	0a000029 	beq	124b78 <tcp_send_fin+0xc8>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
  124ad0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124ad4:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  124ad8:	e50b3010 	str	r3, [fp, #-16]
  124adc:	ea000002 	b	124aec <tcp_send_fin+0x3c>
         last_unsent = last_unsent->next);
  124ae0:	e51b3010 	ldr	r3, [fp, #-16]
  124ae4:	e5933000 	ldr	r3, [r3]
  124ae8:	e50b3010 	str	r3, [fp, #-16]
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
  124aec:	e51b3010 	ldr	r3, [fp, #-16]
  124af0:	e5933000 	ldr	r3, [r3]
  124af4:	e3530000 	cmp	r3, #0
  124af8:	1afffff8 	bne	124ae0 <tcp_send_fin+0x30>

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
  124afc:	e51b3010 	ldr	r3, [fp, #-16]
  124b00:	e593300c 	ldr	r3, [r3, #12]
  124b04:	e1d330bc 	ldrh	r3, [r3, #12]
  124b08:	e6ff3073 	uxth	r3, r3
  124b0c:	e1a00003 	mov	r0, r3
  124b10:	ebffc730 	bl	1167d8 <lwip_htons>
  124b14:	e1a03000 	mov	r3, r0
  124b18:	e2033007 	and	r3, r3, #7
  124b1c:	e3530000 	cmp	r3, #0
  124b20:	1a000014 	bne	124b78 <tcp_send_fin+0xc8>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
  124b24:	e51b3010 	ldr	r3, [fp, #-16]
  124b28:	e593300c 	ldr	r3, [r3, #12]
  124b2c:	e1d330bc 	ldrh	r3, [r3, #12]
  124b30:	e6ff4073 	uxth	r4, r3
  124b34:	e3a00001 	mov	r0, #1
  124b38:	ebffc726 	bl	1167d8 <lwip_htons>
  124b3c:	e1a03000 	mov	r3, r0
  124b40:	e1a02003 	mov	r2, r3
  124b44:	e51b3010 	ldr	r3, [fp, #-16]
  124b48:	e593300c 	ldr	r3, [r3, #12]
  124b4c:	e1842002 	orr	r2, r4, r2
  124b50:	e6ff2072 	uxth	r2, r2
  124b54:	e1c320bc 	strh	r2, [r3, #12]
      pcb->flags |= TF_FIN;
  124b58:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124b5c:	e5d3301e 	ldrb	r3, [r3, #30]
  124b60:	e3833020 	orr	r3, r3, #32
  124b64:	e6ef2073 	uxtb	r2, r3
  124b68:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124b6c:	e5c3201e 	strb	r2, [r3, #30]
      return ERR_OK;
  124b70:	e3a03000 	mov	r3, #0
  124b74:	ea000003 	b	124b88 <tcp_send_fin+0xd8>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
  124b78:	e3a01001 	mov	r1, #1
  124b7c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  124b80:	eb000426 	bl	125c20 <tcp_enqueue_flags>
  124b84:	e1a03000 	mov	r3, r0
}
  124b88:	e1a00003 	mov	r0, r3
  124b8c:	e24bd008 	sub	sp, fp, #8
  124b90:	e8bd8810 	pop	{r4, fp, pc}

00124b94 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  124b94:	e92d4810 	push	{r4, fp, lr}
  124b98:	e28db008 	add	fp, sp, #8
  124b9c:	e24dd01c 	sub	sp, sp, #28
  124ba0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  124ba4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  124ba8:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  124bac:	e1a03002 	mov	r3, r2
  124bb0:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
  124bb4:	e5db3004 	ldrb	r3, [fp, #4]
  124bb8:	e1a03103 	lsl	r3, r3, #2
  124bbc:	e6ef3073 	uxtb	r3, r3
  124bc0:	e2033004 	and	r3, r3, #4
  124bc4:	e54b300d 	strb	r3, [fp, #-13]

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
  124bc8:	e3a020b2 	mov	r2, #178	; 0xb2
  124bcc:	e308184c 	movw	r1, #34892	; 0x884c
  124bd0:	e3401014 	movt	r1, #20
  124bd4:	e3a00004 	mov	r0, #4
  124bd8:	ebffd1bf 	bl	1192dc <memp_malloc_fn>
  124bdc:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  124be0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124be4:	e3530000 	cmp	r3, #0
  124be8:	1a000003 	bne	124bfc <tcp_create_segment+0x68>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
  124bec:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  124bf0:	ebffd92f 	bl	11b0b4 <pbuf_free>
    return NULL;
  124bf4:	e3a03000 	mov	r3, #0
  124bf8:	ea000063 	b	124d8c <tcp_create_segment+0x1f8>
  }
  seg->flags = optflags;
  124bfc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124c00:	e5db2004 	ldrb	r2, [fp, #4]
  124c04:	e5c3200a 	strb	r2, [r3, #10]
  seg->next = NULL;
  124c08:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124c0c:	e3a02000 	mov	r2, #0
  124c10:	e5832000 	str	r2, [r3]
  seg->p = p;
  124c14:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124c18:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  124c1c:	e5832004 	str	r2, [r3, #4]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
  124c20:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  124c24:	e1d320b8 	ldrh	r2, [r3, #8]
  124c28:	e55b300d 	ldrb	r3, [fp, #-13]
  124c2c:	e6ff3073 	uxth	r3, r3
  124c30:	e1520003 	cmp	r2, r3
  124c34:	2a000006 	bcs	124c54 <tcp_create_segment+0xc0>
  124c38:	e308087c 	movw	r0, #34940	; 0x887c
  124c3c:	e3400014 	movt	r0, #20
  124c40:	ebff7933 	bl	103114 <rt_kprintf>
  124c44:	e3a010ba 	mov	r1, #186	; 0xba
  124c48:	e308084c 	movw	r0, #34892	; 0x884c
  124c4c:	e3400014 	movt	r0, #20
  124c50:	ebff9909 	bl	10b07c <sys_arch_assert>
  seg->len = p->tot_len - optlen;
  124c54:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  124c58:	e1d320b8 	ldrh	r2, [r3, #8]
  124c5c:	e55b300d 	ldrb	r3, [fp, #-13]
  124c60:	e6ff3073 	uxth	r3, r3
  124c64:	e0423003 	sub	r3, r2, r3
  124c68:	e6ff2073 	uxth	r2, r3
  124c6c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124c70:	e1c320b8 	strh	r2, [r3, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
  124c74:	e3a01014 	mov	r1, #20
  124c78:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  124c7c:	ebffd8ee 	bl	11b03c <pbuf_header>
  124c80:	e1a03000 	mov	r3, r0
  124c84:	e3530000 	cmp	r3, #0
  124c88:	0a00000b 	beq	124cbc <tcp_create_segment+0x128>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
  124c8c:	e3063840 	movw	r3, #26688	; 0x6840
  124c90:	e3403057 	movt	r3, #87	; 0x57
  124c94:	e1d33cb0 	ldrh	r3, [r3, #192]	; 0xc0
  124c98:	e2833001 	add	r3, r3, #1
  124c9c:	e6ff2073 	uxth	r2, r3
  124ca0:	e3063840 	movw	r3, #26688	; 0x6840
  124ca4:	e3403057 	movt	r3, #87	; 0x57
  124ca8:	e1c32cb0 	strh	r2, [r3, #192]	; 0xc0
    tcp_seg_free(seg);
  124cac:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  124cb0:	ebffea71 	bl	11f67c <tcp_seg_free>
    return NULL;
  124cb4:	e3a03000 	mov	r3, #0
  124cb8:	ea000033 	b	124d8c <tcp_create_segment+0x1f8>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  124cbc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124cc0:	e5933004 	ldr	r3, [r3, #4]
  124cc4:	e5932004 	ldr	r2, [r3, #4]
  124cc8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124ccc:	e583200c 	str	r2, [r3, #12]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
  124cd0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124cd4:	e1d321ba 	ldrh	r2, [r3, #26]
  124cd8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124cdc:	e593400c 	ldr	r4, [r3, #12]
  124ce0:	e1a00002 	mov	r0, r2
  124ce4:	ebffc6bb 	bl	1167d8 <lwip_htons>
  124ce8:	e1a03000 	mov	r3, r0
  124cec:	e1c430b0 	strh	r3, [r4]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
  124cf0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124cf4:	e1d321bc 	ldrh	r2, [r3, #28]
  124cf8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124cfc:	e593400c 	ldr	r4, [r3, #12]
  124d00:	e1a00002 	mov	r0, r2
  124d04:	ebffc6b3 	bl	1167d8 <lwip_htons>
  124d08:	e1a03000 	mov	r3, r0
  124d0c:	e1c430b2 	strh	r3, [r4, #2]
  seg->tcphdr->seqno = lwip_htonl(seqno);
  124d10:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124d14:	e593400c 	ldr	r4, [r3, #12]
  124d18:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  124d1c:	ebffc6b9 	bl	116808 <lwip_htonl>
  124d20:	e1a03000 	mov	r3, r0
  124d24:	e5843004 	str	r3, [r4, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
  124d28:	e55b300d 	ldrb	r3, [fp, #-13]
  124d2c:	e1a03123 	lsr	r3, r3, #2
  124d30:	e6ef3073 	uxtb	r3, r3
  124d34:	e6ff3073 	uxth	r3, r3
  124d38:	e2833005 	add	r3, r3, #5
  124d3c:	e6ff3073 	uxth	r3, r3
  124d40:	e1a03603 	lsl	r3, r3, #12
  124d44:	e6ff2073 	uxth	r2, r3
  124d48:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  124d4c:	e6ff3073 	uxth	r3, r3
  124d50:	e1823003 	orr	r3, r2, r3
  124d54:	e6ff2073 	uxth	r2, r3
  124d58:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124d5c:	e593400c 	ldr	r4, [r3, #12]
  124d60:	e1a00002 	mov	r0, r2
  124d64:	ebffc69b 	bl	1167d8 <lwip_htons>
  124d68:	e1a03000 	mov	r3, r0
  124d6c:	e1c430bc 	strh	r3, [r4, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
  124d70:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  124d74:	e593300c 	ldr	r3, [r3, #12]
  124d78:	e3a02000 	mov	r2, #0
  124d7c:	e5c32012 	strb	r2, [r3, #18]
  124d80:	e3a02000 	mov	r2, #0
  124d84:	e5c32013 	strb	r2, [r3, #19]
  return seg;
  124d88:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
  124d8c:	e1a00003 	mov	r0, r3
  124d90:	e24bd008 	sub	sp, fp, #8
  124d94:	e8bd8810 	pop	{r4, fp, pc}

00124d98 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
  124d98:	e92d4800 	push	{fp, lr}
  124d9c:	e28db004 	add	fp, sp, #4
  124da0:	e24dd018 	sub	sp, sp, #24
  124da4:	e50b0010 	str	r0, [fp, #-16]
  124da8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  124dac:	e1a03001 	mov	r3, r1
  124db0:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  124db4:	e1a03002 	mov	r3, r2
  124db8:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  struct pbuf *p;
  u16_t alloc = length;
  124dbc:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  124dc0:	e14b30b6 	strh	r3, [fp, #-6]
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
  124dc4:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
  124dc8:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
  124dcc:	e1520003 	cmp	r2, r3
  124dd0:	2a00001c 	bcs	124e48 <tcp_pbuf_prealloc+0xb0>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
  124dd4:	e5db3008 	ldrb	r3, [fp, #8]
  124dd8:	e2033002 	and	r3, r3, #2
  124ddc:	e3530000 	cmp	r3, #0
  124de0:	1a00000f 	bne	124e24 <tcp_pbuf_prealloc+0x8c>
        (!(pcb->flags & TF_NODELAY) &&
  124de4:	e59b3004 	ldr	r3, [fp, #4]
  124de8:	e5d3301e 	ldrb	r3, [r3, #30]
  124dec:	e2033040 	and	r3, r3, #64	; 0x40
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
  124df0:	e3530000 	cmp	r3, #0
  124df4:	1a000013 	bne	124e48 <tcp_pbuf_prealloc+0xb0>
        (!(pcb->flags & TF_NODELAY) &&
  124df8:	e5db300c 	ldrb	r3, [fp, #12]
  124dfc:	e3530000 	cmp	r3, #0
  124e00:	0a000007 	beq	124e24 <tcp_pbuf_prealloc+0x8c>
         (!first_seg ||
          pcb->unsent != NULL ||
  124e04:	e59b3004 	ldr	r3, [fp, #4]
  124e08:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
         (!first_seg ||
  124e0c:	e3530000 	cmp	r3, #0
  124e10:	1a000003 	bne	124e24 <tcp_pbuf_prealloc+0x8c>
          pcb->unacked != NULL))) {
  124e14:	e59b3004 	ldr	r3, [fp, #4]
  124e18:	e5933070 	ldr	r3, [r3, #112]	; 0x70
          pcb->unsent != NULL ||
  124e1c:	e3530000 	cmp	r3, #0
  124e20:	0a000008 	beq	124e48 <tcp_pbuf_prealloc+0xb0>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
  124e24:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  124e28:	e2833e5b 	add	r3, r3, #1456	; 0x5b0
  124e2c:	e2833007 	add	r3, r3, #7
  124e30:	e3c32003 	bic	r2, r3, #3
  124e34:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
  124e38:	e1520003 	cmp	r2, r3
  124e3c:	31a03002 	movcc	r3, r2
  124e40:	21a03003 	movcs	r3, r3
  124e44:	e14b30b6 	strh	r3, [fp, #-6]
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  124e48:	e15b30b6 	ldrh	r3, [fp, #-6]
  124e4c:	e3a02000 	mov	r2, #0
  124e50:	e1a01003 	mov	r1, r3
  124e54:	e51b0010 	ldr	r0, [fp, #-16]
  124e58:	ebffd58e 	bl	11a498 <pbuf_alloc>
  124e5c:	e50b000c 	str	r0, [fp, #-12]
  if (p == NULL) {
  124e60:	e51b300c 	ldr	r3, [fp, #-12]
  124e64:	e3530000 	cmp	r3, #0
  124e68:	1a000001 	bne	124e74 <tcp_pbuf_prealloc+0xdc>
    return NULL;
  124e6c:	e3a03000 	mov	r3, #0
  124e70:	ea000019 	b	124edc <tcp_pbuf_prealloc+0x144>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  124e74:	e51b300c 	ldr	r3, [fp, #-12]
  124e78:	e5933000 	ldr	r3, [r3]
  124e7c:	e3530000 	cmp	r3, #0
  124e80:	0a000006 	beq	124ea0 <tcp_pbuf_prealloc+0x108>
  124e84:	e3080894 	movw	r0, #34964	; 0x8894
  124e88:	e3400014 	movt	r0, #20
  124e8c:	ebff78a0 	bl	103114 <rt_kprintf>
  124e90:	e3a01e11 	mov	r1, #272	; 0x110
  124e94:	e308084c 	movw	r0, #34892	; 0x884c
  124e98:	e3400014 	movt	r0, #20
  124e9c:	ebff9876 	bl	10b07c <sys_arch_assert>
  *oversize = p->len - length;
  124ea0:	e51b300c 	ldr	r3, [fp, #-12]
  124ea4:	e1d320ba 	ldrh	r2, [r3, #10]
  124ea8:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  124eac:	e0423003 	sub	r3, r2, r3
  124eb0:	e6ff2073 	uxth	r2, r3
  124eb4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  124eb8:	e1c320b0 	strh	r2, [r3]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
  124ebc:	e51b300c 	ldr	r3, [fp, #-12]
  124ec0:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
  124ec4:	e1c320b8 	strh	r2, [r3, #8]
  124ec8:	e51b300c 	ldr	r3, [fp, #-12]
  124ecc:	e1d320b8 	ldrh	r2, [r3, #8]
  124ed0:	e51b300c 	ldr	r3, [fp, #-12]
  124ed4:	e1c320ba 	strh	r2, [r3, #10]
  return p;
  124ed8:	e51b300c 	ldr	r3, [fp, #-12]
}
  124edc:	e1a00003 	mov	r0, r3
  124ee0:	e24bd004 	sub	sp, fp, #4
  124ee4:	e8bd8800 	pop	{fp, pc}

00124ee8 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  124ee8:	e92d4800 	push	{fp, lr}
  124eec:	e28db004 	add	fp, sp, #4
  124ef0:	e24dd008 	sub	sp, sp, #8
  124ef4:	e50b0008 	str	r0, [fp, #-8]
  124ef8:	e1a03001 	mov	r3, r1
  124efc:	e14b30ba 	strh	r3, [fp, #-10]
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
  124f00:	e51b3008 	ldr	r3, [fp, #-8]
  124f04:	e5933014 	ldr	r3, [r3, #20]
  124f08:	e3530004 	cmp	r3, #4
  124f0c:	0a00000d 	beq	124f48 <tcp_write_checks+0x60>
      (pcb->state != CLOSE_WAIT) &&
  124f10:	e51b3008 	ldr	r3, [fp, #-8]
  124f14:	e5933014 	ldr	r3, [r3, #20]
  if ((pcb->state != ESTABLISHED) &&
  124f18:	e3530007 	cmp	r3, #7
  124f1c:	0a000009 	beq	124f48 <tcp_write_checks+0x60>
      (pcb->state != SYN_SENT) &&
  124f20:	e51b3008 	ldr	r3, [fp, #-8]
  124f24:	e5933014 	ldr	r3, [r3, #20]
      (pcb->state != CLOSE_WAIT) &&
  124f28:	e3530002 	cmp	r3, #2
  124f2c:	0a000005 	beq	124f48 <tcp_write_checks+0x60>
      (pcb->state != SYN_RCVD)) {
  124f30:	e51b3008 	ldr	r3, [fp, #-8]
  124f34:	e5933014 	ldr	r3, [r3, #20]
      (pcb->state != SYN_SENT) &&
  124f38:	e3530003 	cmp	r3, #3
  124f3c:	0a000001 	beq	124f48 <tcp_write_checks+0x60>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  124f40:	e3e0300a 	mvn	r3, #10
  124f44:	ea000050 	b	12508c <tcp_write_checks+0x1a4>
  } else if (len == 0) {
  124f48:	e15b30ba 	ldrh	r3, [fp, #-10]
  124f4c:	e3530000 	cmp	r3, #0
  124f50:	1a000001 	bne	124f5c <tcp_write_checks+0x74>
    return ERR_OK;
  124f54:	e3a03000 	mov	r3, #0
  124f58:	ea00004b 	b	12508c <tcp_write_checks+0x1a4>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
  124f5c:	e51b3008 	ldr	r3, [fp, #-8]
  124f60:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
  124f64:	e15b20ba 	ldrh	r2, [fp, #-10]
  124f68:	e1520003 	cmp	r2, r3
  124f6c:	9a000008 	bls	124f94 <tcp_write_checks+0xac>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  124f70:	e51b3008 	ldr	r3, [fp, #-8]
  124f74:	e5d3301e 	ldrb	r3, [r3, #30]
  124f78:	e1e03c83 	mvn	r3, r3, lsl #25
  124f7c:	e1e03ca3 	mvn	r3, r3, lsr #25
  124f80:	e6ef2073 	uxtb	r2, r3
  124f84:	e51b3008 	ldr	r3, [fp, #-8]
  124f88:	e5c3201e 	strb	r2, [r3, #30]
    return ERR_MEM;
  124f8c:	e3e03000 	mvn	r3, #0
  124f90:	ea00003d 	b	12508c <tcp_write_checks+0x1a4>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  124f94:	e51b3008 	ldr	r3, [fp, #-8]
  124f98:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  124f9c:	e3530015 	cmp	r3, #21
  124fa0:	8a000004 	bhi	124fb8 <tcp_write_checks+0xd0>
  124fa4:	e51b3008 	ldr	r3, [fp, #-8]
  124fa8:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  124fac:	e30f2ffc 	movw	r2, #65532	; 0xfffc
  124fb0:	e1530002 	cmp	r3, r2
  124fb4:	9a000010 	bls	124ffc <tcp_write_checks+0x114>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
  124fb8:	e3063840 	movw	r3, #26688	; 0x6840
  124fbc:	e3403057 	movt	r3, #87	; 0x57
  124fc0:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
  124fc4:	e2833001 	add	r3, r3, #1
  124fc8:	e6ff2073 	uxth	r2, r3
  124fcc:	e3063840 	movw	r3, #26688	; 0x6840
  124fd0:	e3403057 	movt	r3, #87	; 0x57
  124fd4:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
    pcb->flags |= TF_NAGLEMEMERR;
  124fd8:	e51b3008 	ldr	r3, [fp, #-8]
  124fdc:	e5d3301e 	ldrb	r3, [r3, #30]
  124fe0:	e1e03c83 	mvn	r3, r3, lsl #25
  124fe4:	e1e03ca3 	mvn	r3, r3, lsr #25
  124fe8:	e6ef2073 	uxtb	r2, r3
  124fec:	e51b3008 	ldr	r3, [fp, #-8]
  124ff0:	e5c3201e 	strb	r2, [r3, #30]
    return ERR_MEM;
  124ff4:	e3e03000 	mvn	r3, #0
  124ff8:	ea000023 	b	12508c <tcp_write_checks+0x1a4>
  }
  if (pcb->snd_queuelen != 0) {
  124ffc:	e51b3008 	ldr	r3, [fp, #-8]
  125000:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  125004:	e3530000 	cmp	r3, #0
  125008:	0a00000f 	beq	12504c <tcp_write_checks+0x164>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
  12500c:	e51b3008 	ldr	r3, [fp, #-8]
  125010:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  125014:	e3530000 	cmp	r3, #0
  125018:	1a00001a 	bne	125088 <tcp_write_checks+0x1a0>
  12501c:	e51b3008 	ldr	r3, [fp, #-8]
  125020:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  125024:	e3530000 	cmp	r3, #0
  125028:	1a000016 	bne	125088 <tcp_write_checks+0x1a0>
  12502c:	e30808a8 	movw	r0, #34984	; 0x88a8
  125030:	e3400014 	movt	r0, #20
  125034:	ebff7836 	bl	103114 <rt_kprintf>
  125038:	e3001156 	movw	r1, #342	; 0x156
  12503c:	e308084c 	movw	r0, #34892	; 0x884c
  125040:	e3400014 	movt	r0, #20
  125044:	ebff980c 	bl	10b07c <sys_arch_assert>
  125048:	ea00000e 	b	125088 <tcp_write_checks+0x1a0>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
  12504c:	e51b3008 	ldr	r3, [fp, #-8]
  125050:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  125054:	e3530000 	cmp	r3, #0
  125058:	1a000003 	bne	12506c <tcp_write_checks+0x184>
  12505c:	e51b3008 	ldr	r3, [fp, #-8]
  125060:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  125064:	e3530000 	cmp	r3, #0
  125068:	0a000006 	beq	125088 <tcp_write_checks+0x1a0>
  12506c:	e30808e4 	movw	r0, #35044	; 0x88e4
  125070:	e3400014 	movt	r0, #20
  125074:	ebff7826 	bl	103114 <rt_kprintf>
  125078:	e3001159 	movw	r1, #345	; 0x159
  12507c:	e308084c 	movw	r0, #34892	; 0x884c
  125080:	e3400014 	movt	r0, #20
  125084:	ebff97fc 	bl	10b07c <sys_arch_assert>
      pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
  125088:	e3a03000 	mov	r3, #0
}
  12508c:	e1a00003 	mov	r0, r3
  125090:	e24bd004 	sub	sp, fp, #4
  125094:	e8bd8800 	pop	{fp, pc}

00125098 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  125098:	e92d4810 	push	{r4, fp, lr}
  12509c:	e28db008 	add	fp, sp, #8
  1250a0:	e24dd06c 	sub	sp, sp, #108	; 0x6c
  1250a4:	e50b0058 	str	r0, [fp, #-88]	; 0xffffffa8
  1250a8:	e50b105c 	str	r1, [fp, #-92]	; 0xffffffa4
  1250ac:	e1a01002 	mov	r1, r2
  1250b0:	e1a02003 	mov	r2, r3
  1250b4:	e1a03001 	mov	r3, r1
  1250b8:	e14b35be 	strh	r3, [fp, #-94]	; 0xffffffa2
  1250bc:	e1a03002 	mov	r3, r2
  1250c0:	e54b305f 	strb	r3, [fp, #-95]	; 0xffffffa1
  struct pbuf *concat_p = NULL;
  1250c4:	e3a03000 	mov	r3, #0
  1250c8:	e50b3010 	str	r3, [fp, #-16]
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  1250cc:	e3a03000 	mov	r3, #0
  1250d0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1250d4:	e3a03000 	mov	r3, #0
  1250d8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  1250dc:	e3a03000 	mov	r3, #0
  1250e0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  1250e4:	e3a03000 	mov	r3, #0
  1250e8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  u16_t pos = 0; /* position in 'arg' data */
  1250ec:	e3a03000 	mov	r3, #0
  1250f0:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
  u16_t queuelen;
  u8_t optlen = 0;
  1250f4:	e3a03000 	mov	r3, #0
  1250f8:	e54b303d 	strb	r3, [fp, #-61]	; 0xffffffc3
  u8_t optflags = 0;
  1250fc:	e3a03000 	mov	r3, #0
  125100:	e54b303e 	strb	r3, [fp, #-62]	; 0xffffffc2
#if TCP_OVERSIZE
  u16_t oversize = 0;
  125104:	e3a03000 	mov	r3, #0
  125108:	e14b35b2 	strh	r3, [fp, #-82]	; 0xffffffae
  u16_t oversize_used = 0;
  12510c:	e3a03000 	mov	r3, #0
  125110:	e14b32b6 	strh	r3, [fp, #-38]	; 0xffffffda
#if TCP_OVERSIZE_DBGCHECK
  u16_t oversize_add = 0;
#endif /* TCP_OVERSIZE_DBGCHECK*/
#endif /* TCP_OVERSIZE */
  u16_t extendlen = 0;
  125114:	e3a03000 	mov	r3, #0
  125118:	e14b32b8 	strh	r3, [fp, #-40]	; 0xffffffd8
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
  12511c:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125120:	e1d336b2 	ldrh	r3, [r3, #98]	; 0x62
  125124:	e1a030a3 	lsr	r3, r3, #1
  125128:	e6ff2073 	uxth	r2, r3
  12512c:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125130:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  125134:	e1520003 	cmp	r2, r3
  125138:	31a03002 	movcc	r3, r2
  12513c:	21a03003 	movcs	r3, r3
  125140:	e14b34b0 	strh	r3, [fp, #-64]	; 0xffffffc0
  mss_local = mss_local ? mss_local : pcb->mss;
  125144:	e15b34b0 	ldrh	r3, [fp, #-64]	; 0xffffffc0
  125148:	e3530000 	cmp	r3, #0
  12514c:	1a000002 	bne	12515c <tcp_write+0xc4>
  125150:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125154:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  125158:	ea000000 	b	125160 <tcp_write+0xc8>
  12515c:	e15b34b0 	ldrh	r3, [fp, #-64]	; 0xffffffc0
  125160:	e14b34b0 	strh	r3, [fp, #-64]	; 0xffffffc0
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
  125164:	e51b305c 	ldr	r3, [fp, #-92]	; 0xffffffa4
  125168:	e3530000 	cmp	r3, #0
  12516c:	1a000008 	bne	125194 <tcp_write+0xfc>
  125170:	e3080918 	movw	r0, #35096	; 0x8918
  125174:	e3400014 	movt	r0, #20
  125178:	ebff77e5 	bl	103114 <rt_kprintf>
  12517c:	e3001192 	movw	r1, #402	; 0x192
  125180:	e308084c 	movw	r0, #34892	; 0x884c
  125184:	e3400014 	movt	r0, #20
  125188:	ebff97bb 	bl	10b07c <sys_arch_assert>
  12518c:	e3e0300f 	mvn	r3, #15
  125190:	ea00029f 	b	125c14 <tcp_write+0xb7c>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
  125194:	e15b35be 	ldrh	r3, [fp, #-94]	; 0xffffffa2
  125198:	e1a01003 	mov	r1, r3
  12519c:	e51b0058 	ldr	r0, [fp, #-88]	; 0xffffffa8
  1251a0:	ebffff50 	bl	124ee8 <tcp_write_checks>
  1251a4:	e1a03000 	mov	r3, r0
  1251a8:	e54b3041 	strb	r3, [fp, #-65]	; 0xffffffbf
  if (err != ERR_OK) {
  1251ac:	e15b34d1 	ldrsb	r3, [fp, #-65]	; 0xffffffbf
  1251b0:	e3530000 	cmp	r3, #0
  1251b4:	0a000001 	beq	1251c0 <tcp_write+0x128>
    return err;
  1251b8:	e15b34d1 	ldrsb	r3, [fp, #-65]	; 0xffffffbf
  1251bc:	ea000294 	b	125c14 <tcp_write+0xb7c>
  }
  queuelen = pcb->snd_queuelen;
  1251c0:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  1251c4:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  1251c8:	e14b32b4 	strh	r3, [fp, #-36]	; 0xffffffdc
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
  1251cc:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  1251d0:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  1251d4:	e3530000 	cmp	r3, #0
  1251d8:	0a0000d8 	beq	125540 <tcp_write+0x4a8>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
  1251dc:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  1251e0:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  1251e4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1251e8:	ea000002 	b	1251f8 <tcp_write+0x160>
         last_unsent = last_unsent->next);
  1251ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1251f0:	e5933000 	ldr	r3, [r3]
  1251f4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
  1251f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1251fc:	e5933000 	ldr	r3, [r3]
  125200:	e3530000 	cmp	r3, #0
  125204:	1afffff8 	bne	1251ec <tcp_write+0x154>

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
  125208:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12520c:	e5d3300a 	ldrb	r3, [r3, #10]
  125210:	e1a03103 	lsl	r3, r3, #2
  125214:	e6ff3073 	uxth	r3, r3
  125218:	e2033004 	and	r3, r3, #4
  12521c:	e14b34b4 	strh	r3, [fp, #-68]	; 0xffffffbc
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
  125220:	e15b24b0 	ldrh	r2, [fp, #-64]	; 0xffffffc0
  125224:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125228:	e1d330b8 	ldrh	r3, [r3, #8]
  12522c:	e1a01003 	mov	r1, r3
  125230:	e15b34b4 	ldrh	r3, [fp, #-68]	; 0xffffffbc
  125234:	e0813003 	add	r3, r1, r3
  125238:	e1520003 	cmp	r2, r3
  12523c:	aa000006 	bge	12525c <tcp_write+0x1c4>
  125240:	e308094c 	movw	r0, #35148	; 0x894c
  125244:	e3400014 	movt	r0, #20
  125248:	ebff77b1 	bl	103114 <rt_kprintf>
  12524c:	e30011c7 	movw	r1, #455	; 0x1c7
  125250:	e308084c 	movw	r0, #34892	; 0x884c
  125254:	e3400014 	movt	r0, #20
  125258:	ebff9787 	bl	10b07c <sys_arch_assert>
    space = mss_local - (last_unsent->len + unsent_optlen);
  12525c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125260:	e1d320b8 	ldrh	r2, [r3, #8]
  125264:	e15b34b4 	ldrh	r3, [fp, #-68]	; 0xffffffbc
  125268:	e0823003 	add	r3, r2, r3
  12526c:	e6ff3073 	uxth	r3, r3
  125270:	e15b24b0 	ldrh	r2, [fp, #-64]	; 0xffffffc0
  125274:	e0423003 	sub	r3, r2, r3
  125278:	e14b32ba 	strh	r3, [fp, #-42]	; 0xffffffd6
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
  12527c:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125280:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
  125284:	e14b35b2 	strh	r3, [fp, #-82]	; 0xffffffae
    if (oversize > 0) {
  125288:	e15b35b2 	ldrh	r3, [fp, #-82]	; 0xffffffae
  12528c:	e3530000 	cmp	r3, #0
  125290:	0a000025 	beq	12532c <tcp_write+0x294>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
  125294:	e15b35b2 	ldrh	r3, [fp, #-82]	; 0xffffffae
  125298:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
  12529c:	e1520003 	cmp	r2, r3
  1252a0:	2a000006 	bcs	1252c0 <tcp_write+0x228>
  1252a4:	e3080964 	movw	r0, #35172	; 0x8964
  1252a8:	e3400014 	movt	r0, #20
  1252ac:	ebff7798 	bl	103114 <rt_kprintf>
  1252b0:	e30011d9 	movw	r1, #473	; 0x1d9
  1252b4:	e308084c 	movw	r0, #34892	; 0x884c
  1252b8:	e3400014 	movt	r0, #20
  1252bc:	ebff976e 	bl	10b07c <sys_arch_assert>
      seg = last_unsent;
  1252c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1252c4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
  1252c8:	e15b35b2 	ldrh	r3, [fp, #-82]	; 0xffffffae
  1252cc:	e15b25be 	ldrh	r2, [fp, #-94]	; 0xffffffa2
  1252d0:	e1520003 	cmp	r2, r3
  1252d4:	9a000001 	bls	1252e0 <tcp_write+0x248>
  1252d8:	e15b35b2 	ldrh	r3, [fp, #-82]	; 0xffffffae
  1252dc:	ea000000 	b	1252e4 <tcp_write+0x24c>
  1252e0:	e15b35be 	ldrh	r3, [fp, #-94]	; 0xffffffa2
  1252e4:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
  1252e8:	e1530002 	cmp	r3, r2
  1252ec:	b1a03003 	movlt	r3, r3
  1252f0:	a1a03002 	movge	r3, r2
  1252f4:	e14b32b6 	strh	r3, [fp, #-38]	; 0xffffffda
      pos += oversize_used;
  1252f8:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  1252fc:	e15b32b6 	ldrh	r3, [fp, #-38]	; 0xffffffda
  125300:	e0823003 	add	r3, r2, r3
  125304:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
      oversize -= oversize_used;
  125308:	e15b25b2 	ldrh	r2, [fp, #-82]	; 0xffffffae
  12530c:	e15b32b6 	ldrh	r3, [fp, #-38]	; 0xffffffda
  125310:	e0423003 	sub	r3, r2, r3
  125314:	e6ff3073 	uxth	r3, r3
  125318:	e14b35b2 	strh	r3, [fp, #-82]	; 0xffffffae
      space -= oversize_used;
  12531c:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
  125320:	e15b32b6 	ldrh	r3, [fp, #-38]	; 0xffffffda
  125324:	e0423003 	sub	r3, r2, r3
  125328:	e14b32ba 	strh	r3, [fp, #-42]	; 0xffffffd6
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
  12532c:	e15b35b2 	ldrh	r3, [fp, #-82]	; 0xffffffae
  125330:	e3530000 	cmp	r3, #0
  125334:	0a00000a 	beq	125364 <tcp_write+0x2cc>
  125338:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  12533c:	e15b35be 	ldrh	r3, [fp, #-94]	; 0xffffffa2
  125340:	e1520003 	cmp	r2, r3
  125344:	0a000006 	beq	125364 <tcp_write+0x2cc>
  125348:	e3080984 	movw	r0, #35204	; 0x8984
  12534c:	e3400014 	movt	r0, #20
  125350:	ebff776f 	bl	103114 <rt_kprintf>
  125354:	e30011e1 	movw	r1, #481	; 0x1e1
  125358:	e308084c 	movw	r0, #34892	; 0x884c
  12535c:	e3400014 	movt	r0, #20
  125360:	ebff9745 	bl	10b07c <sys_arch_assert>
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
  125364:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  125368:	e15b35be 	ldrh	r3, [fp, #-94]	; 0xffffffa2
  12536c:	e1520003 	cmp	r2, r3
  125370:	2a000121 	bcs	1257fc <tcp_write+0x764>
  125374:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
  125378:	e3530000 	cmp	r3, #0
  12537c:	0a00011e 	beq	1257fc <tcp_write+0x764>
  125380:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125384:	e1d330b8 	ldrh	r3, [r3, #8]
  125388:	e3530000 	cmp	r3, #0
  12538c:	0a00011a 	beq	1257fc <tcp_write+0x764>
      u16_t seglen = LWIP_MIN(space, len - pos);
  125390:	e15b25be 	ldrh	r2, [fp, #-94]	; 0xffffffa2
  125394:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  125398:	e0422003 	sub	r2, r2, r3
  12539c:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
  1253a0:	e1520003 	cmp	r2, r3
  1253a4:	b1a03002 	movlt	r3, r2
  1253a8:	a1a03003 	movge	r3, r3
  1253ac:	e14b34b6 	strh	r3, [fp, #-70]	; 0xffffffba
      seg = last_unsent;
  1253b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1253b4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
  1253b8:	e55b305f 	ldrb	r3, [fp, #-95]	; 0xffffffa1
  1253bc:	e2033001 	and	r3, r3, #1
  1253c0:	e3530000 	cmp	r3, #0
  1253c4:	0a00001f 	beq	125448 <tcp_write+0x3b0>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
  1253c8:	e24b0052 	sub	r0, fp, #82	; 0x52
  1253cc:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
  1253d0:	e15b14b6 	ldrh	r1, [fp, #-70]	; 0xffffffba
  1253d4:	e3a03001 	mov	r3, #1
  1253d8:	e58d3008 	str	r3, [sp, #8]
  1253dc:	e55b305f 	ldrb	r3, [fp, #-95]	; 0xffffffa1
  1253e0:	e58d3004 	str	r3, [sp, #4]
  1253e4:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  1253e8:	e58d3000 	str	r3, [sp]
  1253ec:	e1a03000 	mov	r3, r0
  1253f0:	e3a00004 	mov	r0, #4
  1253f4:	ebfffe67 	bl	124d98 <tcp_pbuf_prealloc>
  1253f8:	e50b0010 	str	r0, [fp, #-16]
  1253fc:	e51b3010 	ldr	r3, [fp, #-16]
  125400:	e3530000 	cmp	r3, #0
  125404:	0a0001cc 	beq	125b3c <tcp_write+0xaa4>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        oversize_add = oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (const u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
  125408:	e51b3010 	ldr	r3, [fp, #-16]
  12540c:	e5930004 	ldr	r0, [r3, #4]
  125410:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  125414:	e51b205c 	ldr	r2, [fp, #-92]	; 0xffffffa4
  125418:	e0823003 	add	r3, r2, r3
  12541c:	e15b24b6 	ldrh	r2, [fp, #-70]	; 0xffffffba
  125420:	e1a01003 	mov	r1, r3
  125424:	eb006eda 	bl	140f94 <memcpy>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        queuelen += pbuf_clen(concat_p);
  125428:	e51b0010 	ldr	r0, [fp, #-16]
  12542c:	ebffd7a5 	bl	11b2c8 <pbuf_clen>
  125430:	e1a03000 	mov	r3, r0
  125434:	e1a02003 	mov	r2, r3
  125438:	e15b32b4 	ldrh	r3, [fp, #-36]	; 0xffffffdc
  12543c:	e0823003 	add	r3, r2, r3
  125440:	e14b32b4 	strh	r3, [fp, #-36]	; 0xffffffdc
  125444:	ea000038 	b	12552c <tcp_write+0x494>
      } else {
        /* Data is not copied */
        /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
        struct pbuf *p;
        for (p = last_unsent->p; p->next != NULL; p = p->next);
  125448:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12544c:	e5933004 	ldr	r3, [r3, #4]
  125450:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
  125454:	ea000002 	b	125464 <tcp_write+0x3cc>
  125458:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12545c:	e5933000 	ldr	r3, [r3]
  125460:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
  125464:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  125468:	e5933000 	ldr	r3, [r3]
  12546c:	e3530000 	cmp	r3, #0
  125470:	1afffff8 	bne	125458 <tcp_write+0x3c0>
        if (p->type == PBUF_ROM && (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
  125474:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  125478:	e5d3300c 	ldrb	r3, [r3, #12]
  12547c:	e3530001 	cmp	r3, #1
  125480:	1a000014 	bne	1254d8 <tcp_write+0x440>
  125484:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  125488:	e5933004 	ldr	r3, [r3, #4]
  12548c:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  125490:	e1d220ba 	ldrh	r2, [r2, #10]
  125494:	e0833002 	add	r3, r3, r2
  125498:	e51b205c 	ldr	r2, [fp, #-92]	; 0xffffffa4
  12549c:	e1520003 	cmp	r2, r3
  1254a0:	1a00000c 	bne	1254d8 <tcp_write+0x440>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
  1254a4:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  1254a8:	e3530000 	cmp	r3, #0
  1254ac:	0a000006 	beq	1254cc <tcp_write+0x434>
  1254b0:	e30809a4 	movw	r0, #35236	; 0x89a4
  1254b4:	e3400014 	movt	r0, #20
  1254b8:	ebff7715 	bl	103114 <rt_kprintf>
  1254bc:	e3a01f83 	mov	r1, #524	; 0x20c
  1254c0:	e308084c 	movw	r0, #34892	; 0x884c
  1254c4:	e3400014 	movt	r0, #20
  1254c8:	ebff96eb 	bl	10b07c <sys_arch_assert>
          extendlen = seglen;
  1254cc:	e15b34b6 	ldrh	r3, [fp, #-70]	; 0xffffffba
  1254d0:	e14b32b8 	strh	r3, [fp, #-40]	; 0xffffffd8
  1254d4:	ea000014 	b	12552c <tcp_write+0x494>
        } else {
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
  1254d8:	e15b34b6 	ldrh	r3, [fp, #-70]	; 0xffffffba
  1254dc:	e3a02001 	mov	r2, #1
  1254e0:	e1a01003 	mov	r1, r3
  1254e4:	e3a00004 	mov	r0, #4
  1254e8:	ebffd3ea 	bl	11a498 <pbuf_alloc>
  1254ec:	e50b0010 	str	r0, [fp, #-16]
  1254f0:	e51b3010 	ldr	r3, [fp, #-16]
  1254f4:	e3530000 	cmp	r3, #0
  1254f8:	0a000191 	beq	125b44 <tcp_write+0xaac>
            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                        ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
            goto memerr;
          }
          /* reference the non-volatile payload data */
          ((struct pbuf_rom*)concat_p)->payload = (const u8_t*)arg + pos;
  1254fc:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  125500:	e51b205c 	ldr	r2, [fp, #-92]	; 0xffffffa4
  125504:	e0822003 	add	r2, r2, r3
  125508:	e51b3010 	ldr	r3, [fp, #-16]
  12550c:	e5832004 	str	r2, [r3, #4]
          queuelen += pbuf_clen(concat_p);
  125510:	e51b0010 	ldr	r0, [fp, #-16]
  125514:	ebffd76b 	bl	11b2c8 <pbuf_clen>
  125518:	e1a03000 	mov	r3, r0
  12551c:	e1a02003 	mov	r2, r3
  125520:	e15b32b4 	ldrh	r3, [fp, #-36]	; 0xffffffdc
  125524:	e0823003 	add	r3, r2, r3
  125528:	e14b32b4 	strh	r3, [fp, #-36]	; 0xffffffdc
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      }

      pos += seglen;
  12552c:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  125530:	e15b34b6 	ldrh	r3, [fp, #-70]	; 0xffffffba
  125534:	e0823003 	add	r3, r2, r3
  125538:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
  12553c:	ea0000ae 	b	1257fc <tcp_write+0x764>
    }
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
  125540:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125544:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
  125548:	e3530000 	cmp	r3, #0
  12554c:	0a0000aa 	beq	1257fc <tcp_write+0x764>
  125550:	e30809d0 	movw	r0, #35280	; 0x89d0
  125554:	e3400014 	movt	r0, #20
  125558:	ebff76ed 	bl	103114 <rt_kprintf>
  12555c:	e3001225 	movw	r1, #549	; 0x225
  125560:	e308084c 	movw	r0, #34892	; 0x884c
  125564:	e3400014 	movt	r0, #20
  125568:	ebff96c3 	bl	10b07c <sys_arch_assert>
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
  12556c:	ea0000a2 	b	1257fc <tcp_write+0x764>
    struct pbuf *p;
    u16_t left = len - pos;
  125570:	e15b25be 	ldrh	r2, [fp, #-94]	; 0xffffffa2
  125574:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  125578:	e0423003 	sub	r3, r2, r3
  12557c:	e14b34b8 	strh	r3, [fp, #-72]	; 0xffffffb8
    u16_t max_len = mss_local - optlen;
  125580:	e55b303d 	ldrb	r3, [fp, #-61]	; 0xffffffc3
  125584:	e6ff3073 	uxth	r3, r3
  125588:	e15b24b0 	ldrh	r2, [fp, #-64]	; 0xffffffc0
  12558c:	e0423003 	sub	r3, r2, r3
  125590:	e14b34ba 	strh	r3, [fp, #-74]	; 0xffffffb6
    u16_t seglen = LWIP_MIN(left, max_len);
  125594:	e15b24ba 	ldrh	r2, [fp, #-74]	; 0xffffffb6
  125598:	e15b34b8 	ldrh	r3, [fp, #-72]	; 0xffffffb8
  12559c:	e1520003 	cmp	r2, r3
  1255a0:	31a03002 	movcc	r3, r2
  1255a4:	21a03003 	movcs	r3, r3
  1255a8:	e14b34bc 	strh	r3, [fp, #-76]	; 0xffffffb4
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
  1255ac:	e55b305f 	ldrb	r3, [fp, #-95]	; 0xffffffa1
  1255b0:	e2033001 	and	r3, r3, #1
  1255b4:	e3530000 	cmp	r3, #0
  1255b8:	0a00002e 	beq	125678 <tcp_write+0x5e0>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
  1255bc:	e55b303d 	ldrb	r3, [fp, #-61]	; 0xffffffc3
  1255c0:	e6ff2073 	uxth	r2, r3
  1255c4:	e15b34bc 	ldrh	r3, [fp, #-76]	; 0xffffffb4
  1255c8:	e0823003 	add	r3, r2, r3
  1255cc:	e6ff1073 	uxth	r1, r3
  1255d0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1255d4:	e3530000 	cmp	r3, #0
  1255d8:	03a03001 	moveq	r3, #1
  1255dc:	13a03000 	movne	r3, #0
  1255e0:	e6ef3073 	uxtb	r3, r3
  1255e4:	e24b0052 	sub	r0, fp, #82	; 0x52
  1255e8:	e15b24b0 	ldrh	r2, [fp, #-64]	; 0xffffffc0
  1255ec:	e58d3008 	str	r3, [sp, #8]
  1255f0:	e55b305f 	ldrb	r3, [fp, #-95]	; 0xffffffa1
  1255f4:	e58d3004 	str	r3, [sp, #4]
  1255f8:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  1255fc:	e58d3000 	str	r3, [sp]
  125600:	e1a03000 	mov	r3, r0
  125604:	e3a00000 	mov	r0, #0
  125608:	ebfffde2 	bl	124d98 <tcp_pbuf_prealloc>
  12560c:	e50b0034 	str	r0, [fp, #-52]	; 0xffffffcc
  125610:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  125614:	e3530000 	cmp	r3, #0
  125618:	0a00014b 	beq	125b4c <tcp_write+0xab4>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
  12561c:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  125620:	e1d330ba 	ldrh	r3, [r3, #10]
  125624:	e15b24bc 	ldrh	r2, [fp, #-76]	; 0xffffffb4
  125628:	e1520003 	cmp	r2, r3
  12562c:	9a000006 	bls	12564c <tcp_write+0x5b4>
  125630:	e3080a00 	movw	r0, #35328	; 0x8a00
  125634:	e3400014 	movt	r0, #20
  125638:	ebff76b5 	bl	103114 <rt_kprintf>
  12563c:	e3001241 	movw	r1, #577	; 0x241
  125640:	e308084c 	movw	r0, #34892	; 0x884c
  125644:	e3400014 	movt	r0, #20
  125648:	ebff968b 	bl	10b07c <sys_arch_assert>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
  12564c:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  125650:	e5932004 	ldr	r2, [r3, #4]
  125654:	e55b303d 	ldrb	r3, [fp, #-61]	; 0xffffffc3
  125658:	e0820003 	add	r0, r2, r3
  12565c:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  125660:	e51b205c 	ldr	r2, [fp, #-92]	; 0xffffffa4
  125664:	e0823003 	add	r3, r2, r3
  125668:	e15b24bc 	ldrh	r2, [fp, #-76]	; 0xffffffb4
  12566c:	e1a01003 	mov	r1, r3
  125670:	eb006e47 	bl	140f94 <memcpy>
  125674:	ea000027 	b	125718 <tcp_write+0x680>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
  125678:	e15b35b2 	ldrh	r3, [fp, #-82]	; 0xffffffae
  12567c:	e3530000 	cmp	r3, #0
  125680:	0a000006 	beq	1256a0 <tcp_write+0x608>
  125684:	e3080a40 	movw	r0, #35392	; 0x8a40
  125688:	e3400014 	movt	r0, #20
  12568c:	ebff76a0 	bl	103114 <rt_kprintf>
  125690:	e300124b 	movw	r1, #587	; 0x24b
  125694:	e308084c 	movw	r0, #34892	; 0x884c
  125698:	e3400014 	movt	r0, #20
  12569c:	ebff9676 	bl	10b07c <sys_arch_assert>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  1256a0:	e15b34bc 	ldrh	r3, [fp, #-76]	; 0xffffffb4
  1256a4:	e3a02001 	mov	r2, #1
  1256a8:	e1a01003 	mov	r1, r3
  1256ac:	e3a00000 	mov	r0, #0
  1256b0:	ebffd378 	bl	11a498 <pbuf_alloc>
  1256b4:	e50b0050 	str	r0, [fp, #-80]	; 0xffffffb0
  1256b8:	e51b3050 	ldr	r3, [fp, #-80]	; 0xffffffb0
  1256bc:	e3530000 	cmp	r3, #0
  1256c0:	0a000123 	beq	125b54 <tcp_write+0xabc>
        chksum_swapped = 1;
        chksum = SWAP_BYTES_IN_WORD(chksum);
      }
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      ((struct pbuf_rom*)p2)->payload = (const u8_t*)arg + pos;
  1256c4:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  1256c8:	e51b205c 	ldr	r2, [fp, #-92]	; 0xffffffa4
  1256cc:	e0822003 	add	r2, r2, r3
  1256d0:	e51b3050 	ldr	r3, [fp, #-80]	; 0xffffffb0
  1256d4:	e5832004 	str	r2, [r3, #4]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  1256d8:	e55b303d 	ldrb	r3, [fp, #-61]	; 0xffffffc3
  1256dc:	e6ff3073 	uxth	r3, r3
  1256e0:	e3a02000 	mov	r2, #0
  1256e4:	e1a01003 	mov	r1, r3
  1256e8:	e3a00000 	mov	r0, #0
  1256ec:	ebffd369 	bl	11a498 <pbuf_alloc>
  1256f0:	e50b0034 	str	r0, [fp, #-52]	; 0xffffffcc
  1256f4:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  1256f8:	e3530000 	cmp	r3, #0
  1256fc:	1a000002 	bne	12570c <tcp_write+0x674>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
  125700:	e51b0050 	ldr	r0, [fp, #-80]	; 0xffffffb0
  125704:	ebffd66a 	bl	11b0b4 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
  125708:	ea000114 	b	125b60 <tcp_write+0xac8>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
  12570c:	e51b1050 	ldr	r1, [fp, #-80]	; 0xffffffb0
  125710:	e51b0034 	ldr	r0, [fp, #-52]	; 0xffffffcc
  125714:	ebffd71d 	bl	11b390 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
  125718:	e51b0034 	ldr	r0, [fp, #-52]	; 0xffffffcc
  12571c:	ebffd6e9 	bl	11b2c8 <pbuf_clen>
  125720:	e1a03000 	mov	r3, r0
  125724:	e1a02003 	mov	r2, r3
  125728:	e15b32b4 	ldrh	r3, [fp, #-36]	; 0xffffffdc
  12572c:	e0823003 	add	r3, r2, r3
  125730:	e14b32b4 	strh	r3, [fp, #-36]	; 0xffffffdc

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  125734:	e15b32b4 	ldrh	r3, [fp, #-36]	; 0xffffffdc
  125738:	e3530016 	cmp	r3, #22
  12573c:	8a000003 	bhi	125750 <tcp_write+0x6b8>
  125740:	e15b32b4 	ldrh	r3, [fp, #-36]	; 0xffffffdc
  125744:	e30f2ffc 	movw	r2, #65532	; 0xfffc
  125748:	e1530002 	cmp	r3, r2
  12574c:	9a000002 	bls	12575c <tcp_write+0x6c4>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
        queuelen, (int)TCP_SND_QUEUELEN));
      pbuf_free(p);
  125750:	e51b0034 	ldr	r0, [fp, #-52]	; 0xffffffcc
  125754:	ebffd656 	bl	11b0b4 <pbuf_free>
      goto memerr;
  125758:	ea000100 	b	125b60 <tcp_write+0xac8>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
  12575c:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125760:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
  125764:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  125768:	e0822003 	add	r2, r2, r3
  12576c:	e55b303e 	ldrb	r3, [fp, #-62]	; 0xffffffc2
  125770:	e58d3000 	str	r3, [sp]
  125774:	e1a03002 	mov	r3, r2
  125778:	e3a02000 	mov	r2, #0
  12577c:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  125780:	e51b0058 	ldr	r0, [fp, #-88]	; 0xffffffa8
  125784:	ebfffd02 	bl	124b94 <tcp_create_segment>
  125788:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12578c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  125790:	e3530000 	cmp	r3, #0
  125794:	0a0000f0 	beq	125b5c <tcp_write+0xac4>
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  125798:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12579c:	e3530000 	cmp	r3, #0
  1257a0:	1a000002 	bne	1257b0 <tcp_write+0x718>
      queue = seg;
  1257a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1257a8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  1257ac:	ea00000c 	b	1257e4 <tcp_write+0x74c>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
  1257b0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1257b4:	e3530000 	cmp	r3, #0
  1257b8:	1a000006 	bne	1257d8 <tcp_write+0x740>
  1257bc:	e3080a50 	movw	r0, #35408	; 0x8a50
  1257c0:	e3400014 	movt	r0, #20
  1257c4:	ebff7652 	bl	103114 <rt_kprintf>
  1257c8:	e3001285 	movw	r1, #645	; 0x285
  1257cc:	e308084c 	movw	r0, #34892	; 0x884c
  1257d0:	e3400014 	movt	r0, #20
  1257d4:	ebff9628 	bl	10b07c <sys_arch_assert>
      prev_seg->next = seg;
  1257d8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1257dc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1257e0:	e5832000 	str	r2, [r3]
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
  1257e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1257e8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      lwip_ntohl(seg->tcphdr->seqno),
      lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
  1257ec:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  1257f0:	e15b34bc 	ldrh	r3, [fp, #-76]	; 0xffffffb4
  1257f4:	e0823003 	add	r3, r2, r3
  1257f8:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
  while (pos < len) {
  1257fc:	e15b22b2 	ldrh	r2, [fp, #-34]	; 0xffffffde
  125800:	e15b35be 	ldrh	r3, [fp, #-94]	; 0xffffffa2
  125804:	e1520003 	cmp	r2, r3
  125808:	3affff58 	bcc	125570 <tcp_write+0x4d8>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
  12580c:	e15b32b6 	ldrh	r3, [fp, #-38]	; 0xffffffda
  125810:	e3530000 	cmp	r3, #0
  125814:	0a00002b 	beq	1258c8 <tcp_write+0x830>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
  125818:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12581c:	e5933004 	ldr	r3, [r3, #4]
  125820:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
  125824:	ea00001d 	b	1258a0 <tcp_write+0x808>
      p->tot_len += oversize_used;
  125828:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  12582c:	e1d320b8 	ldrh	r2, [r3, #8]
  125830:	e15b32b6 	ldrh	r3, [fp, #-38]	; 0xffffffda
  125834:	e0823003 	add	r3, r2, r3
  125838:	e6ff2073 	uxth	r2, r3
  12583c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  125840:	e1c320b8 	strh	r2, [r3, #8]
      if (p->next == NULL) {
  125844:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  125848:	e5933000 	ldr	r3, [r3]
  12584c:	e3530000 	cmp	r3, #0
  125850:	1a00000f 	bne	125894 <tcp_write+0x7fc>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
  125854:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  125858:	e5933004 	ldr	r3, [r3, #4]
  12585c:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
  125860:	e1d220ba 	ldrh	r2, [r2, #10]
  125864:	e0833002 	add	r3, r3, r2
  125868:	e15b22b6 	ldrh	r2, [fp, #-38]	; 0xffffffda
  12586c:	e51b105c 	ldr	r1, [fp, #-92]	; 0xffffffa4
  125870:	e1a00003 	mov	r0, r3
  125874:	eb006dc6 	bl	140f94 <memcpy>
        p->len += oversize_used;
  125878:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  12587c:	e1d320ba 	ldrh	r2, [r3, #10]
  125880:	e15b32b6 	ldrh	r3, [fp, #-38]	; 0xffffffda
  125884:	e0823003 	add	r3, r2, r3
  125888:	e6ff2073 	uxth	r2, r3
  12588c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  125890:	e1c320ba 	strh	r2, [r3, #10]
    for (p = last_unsent->p; p; p = p->next) {
  125894:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  125898:	e5933000 	ldr	r3, [r3]
  12589c:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
  1258a0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1258a4:	e3530000 	cmp	r3, #0
  1258a8:	1affffde 	bne	125828 <tcp_write+0x790>
      }
    }
    last_unsent->len += oversize_used;
  1258ac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1258b0:	e1d320b8 	ldrh	r2, [r3, #8]
  1258b4:	e15b32b6 	ldrh	r3, [fp, #-38]	; 0xffffffda
  1258b8:	e0823003 	add	r3, r2, r3
  1258bc:	e6ff2073 	uxth	r2, r3
  1258c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1258c4:	e1c320b8 	strh	r2, [r3, #8]
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
  1258c8:	e15b25b2 	ldrh	r2, [fp, #-82]	; 0xffffffae
  1258cc:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  1258d0:	e1c326b8 	strh	r2, [r3, #104]	; 0x68

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
   * determined that the last ROM pbuf can be extended to include the new data.
   */
  if (concat_p != NULL) {
  1258d4:	e51b3010 	ldr	r3, [fp, #-16]
  1258d8:	e3530000 	cmp	r3, #0
  1258dc:	0a000017 	beq	125940 <tcp_write+0x8a8>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
  1258e0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1258e4:	e3530000 	cmp	r3, #0
  1258e8:	1a000006 	bne	125908 <tcp_write+0x870>
  1258ec:	e3080a64 	movw	r0, #35428	; 0x8a64
  1258f0:	e3400014 	movt	r0, #20
  1258f4:	ebff7606 	bl	103114 <rt_kprintf>
  1258f8:	e30012bb 	movw	r1, #699	; 0x2bb
  1258fc:	e308084c 	movw	r0, #34892	; 0x884c
  125900:	e3400014 	movt	r0, #20
  125904:	ebff95dc 	bl	10b07c <sys_arch_assert>
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
  125908:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12590c:	e5933004 	ldr	r3, [r3, #4]
  125910:	e51b1010 	ldr	r1, [fp, #-16]
  125914:	e1a00003 	mov	r0, r3
  125918:	ebffd69c 	bl	11b390 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
  12591c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125920:	e1d320b8 	ldrh	r2, [r3, #8]
  125924:	e51b3010 	ldr	r3, [fp, #-16]
  125928:	e1d330b8 	ldrh	r3, [r3, #8]
  12592c:	e0823003 	add	r3, r2, r3
  125930:	e6ff2073 	uxth	r2, r3
  125934:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125938:	e1c320b8 	strh	r2, [r3, #8]
  12593c:	ea000037 	b	125a20 <tcp_write+0x988>
  } else if (extendlen > 0) {
  125940:	e15b32b8 	ldrh	r3, [fp, #-40]	; 0xffffffd8
  125944:	e3530000 	cmp	r3, #0
  125948:	0a000034 	beq	125a20 <tcp_write+0x988>
    struct pbuf *p;
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
  12594c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125950:	e3530000 	cmp	r3, #0
  125954:	0a000003 	beq	125968 <tcp_write+0x8d0>
  125958:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12595c:	e5933004 	ldr	r3, [r3, #4]
  125960:	e3530000 	cmp	r3, #0
  125964:	1a000006 	bne	125984 <tcp_write+0x8ec>
  125968:	e3080a9c 	movw	r0, #35484	; 0x8a9c
  12596c:	e3400014 	movt	r0, #20
  125970:	ebff75e7 	bl	103114 <rt_kprintf>
  125974:	e30012c1 	movw	r1, #705	; 0x2c1
  125978:	e308084c 	movw	r0, #34892	; 0x884c
  12597c:	e3400014 	movt	r0, #20
  125980:	ebff95bd 	bl	10b07c <sys_arch_assert>
      last_unsent != NULL && last_unsent->p != NULL);
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
  125984:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125988:	e5933004 	ldr	r3, [r3, #4]
  12598c:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  125990:	ea000009 	b	1259bc <tcp_write+0x924>
      p->tot_len += extendlen;
  125994:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  125998:	e1d320b8 	ldrh	r2, [r3, #8]
  12599c:	e15b32b8 	ldrh	r3, [fp, #-40]	; 0xffffffd8
  1259a0:	e0823003 	add	r3, r2, r3
  1259a4:	e6ff2073 	uxth	r2, r3
  1259a8:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  1259ac:	e1c320b8 	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
  1259b0:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  1259b4:	e5933000 	ldr	r3, [r3]
  1259b8:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
  1259bc:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  1259c0:	e5933000 	ldr	r3, [r3]
  1259c4:	e3530000 	cmp	r3, #0
  1259c8:	1afffff1 	bne	125994 <tcp_write+0x8fc>
    }
    p->tot_len += extendlen;
  1259cc:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  1259d0:	e1d320b8 	ldrh	r2, [r3, #8]
  1259d4:	e15b32b8 	ldrh	r3, [fp, #-40]	; 0xffffffd8
  1259d8:	e0823003 	add	r3, r2, r3
  1259dc:	e6ff2073 	uxth	r2, r3
  1259e0:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  1259e4:	e1c320b8 	strh	r2, [r3, #8]
    p->len += extendlen;
  1259e8:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  1259ec:	e1d320ba 	ldrh	r2, [r3, #10]
  1259f0:	e15b32b8 	ldrh	r3, [fp, #-40]	; 0xffffffd8
  1259f4:	e0823003 	add	r3, r2, r3
  1259f8:	e6ff2073 	uxth	r2, r3
  1259fc:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  125a00:	e1c320ba 	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
  125a04:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125a08:	e1d320b8 	ldrh	r2, [r3, #8]
  125a0c:	e15b32b8 	ldrh	r3, [fp, #-40]	; 0xffffffd8
  125a10:	e0823003 	add	r3, r2, r3
  125a14:	e6ff2073 	uxth	r2, r3
  125a18:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125a1c:	e1c320b8 	strh	r2, [r3, #8]

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
  125a20:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125a24:	e3530000 	cmp	r3, #0
  125a28:	1a000003 	bne	125a3c <tcp_write+0x9a4>
    pcb->unsent = queue;
  125a2c:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125a30:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  125a34:	e583206c 	str	r2, [r3, #108]	; 0x6c
  125a38:	ea000002 	b	125a48 <tcp_write+0x9b0>
  } else {
    last_unsent->next = queue;
  125a3c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125a40:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  125a44:	e5832000 	str	r2, [r3]
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
  125a48:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125a4c:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
  125a50:	e15b35be 	ldrh	r3, [fp, #-94]	; 0xffffffa2
  125a54:	e0822003 	add	r2, r2, r3
  125a58:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125a5c:	e583205c 	str	r2, [r3, #92]	; 0x5c
  pcb->snd_buf -= len;
  125a60:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125a64:	e1d326b4 	ldrh	r2, [r3, #100]	; 0x64
  125a68:	e15b35be 	ldrh	r3, [fp, #-94]	; 0xffffffa2
  125a6c:	e0423003 	sub	r3, r2, r3
  125a70:	e6ff2073 	uxth	r2, r3
  125a74:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125a78:	e1c326b4 	strh	r2, [r3, #100]	; 0x64
  pcb->snd_queuelen = queuelen;
  125a7c:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125a80:	e15b22b4 	ldrh	r2, [fp, #-36]	; 0xffffffdc
  125a84:	e1c326b6 	strh	r2, [r3, #102]	; 0x66

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  125a88:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125a8c:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  125a90:	e3530000 	cmp	r3, #0
  125a94:	0a00000e 	beq	125ad4 <tcp_write+0xa3c>
    LWIP_ASSERT("tcp_write: valid queue length",
  125a98:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125a9c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  125aa0:	e3530000 	cmp	r3, #0
  125aa4:	1a00000a 	bne	125ad4 <tcp_write+0xa3c>
  125aa8:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125aac:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  125ab0:	e3530000 	cmp	r3, #0
  125ab4:	1a000006 	bne	125ad4 <tcp_write+0xa3c>
  125ab8:	e3080ad4 	movw	r0, #35540	; 0x8ad4
  125abc:	e3400014 	movt	r0, #20
  125ac0:	ebff7593 	bl	103114 <rt_kprintf>
  125ac4:	e30012ed 	movw	r1, #749	; 0x2ed
  125ac8:	e308084c 	movw	r0, #34892	; 0x884c
  125acc:	e3400014 	movt	r0, #20
  125ad0:	ebff9569 	bl	10b07c <sys_arch_assert>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  125ad4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  125ad8:	e3530000 	cmp	r3, #0
  125adc:	0a000014 	beq	125b34 <tcp_write+0xa9c>
  125ae0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  125ae4:	e593300c 	ldr	r3, [r3, #12]
  125ae8:	e3530000 	cmp	r3, #0
  125aec:	0a000010 	beq	125b34 <tcp_write+0xa9c>
  125af0:	e55b305f 	ldrb	r3, [fp, #-95]	; 0xffffffa1
  125af4:	e2033002 	and	r3, r3, #2
  125af8:	e3530000 	cmp	r3, #0
  125afc:	1a00000c 	bne	125b34 <tcp_write+0xa9c>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  125b00:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  125b04:	e593300c 	ldr	r3, [r3, #12]
  125b08:	e1d330bc 	ldrh	r3, [r3, #12]
  125b0c:	e6ff4073 	uxth	r4, r3
  125b10:	e3a00008 	mov	r0, #8
  125b14:	ebffc32f 	bl	1167d8 <lwip_htons>
  125b18:	e1a03000 	mov	r3, r0
  125b1c:	e1a02003 	mov	r2, r3
  125b20:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  125b24:	e593300c 	ldr	r3, [r3, #12]
  125b28:	e1842002 	orr	r2, r4, r2
  125b2c:	e6ff2072 	uxth	r2, r2
  125b30:	e1c320bc 	strh	r2, [r3, #12]
  }

  return ERR_OK;
  125b34:	e3a03000 	mov	r3, #0
  125b38:	ea000035 	b	125c14 <tcp_write+0xb7c>
          goto memerr;
  125b3c:	e320f000 	nop	{0}
  125b40:	ea000006 	b	125b60 <tcp_write+0xac8>
            goto memerr;
  125b44:	e320f000 	nop	{0}
  125b48:	ea000004 	b	125b60 <tcp_write+0xac8>
        goto memerr;
  125b4c:	e320f000 	nop	{0}
  125b50:	ea000002 	b	125b60 <tcp_write+0xac8>
        goto memerr;
  125b54:	e320f000 	nop	{0}
  125b58:	ea000000 	b	125b60 <tcp_write+0xac8>
      goto memerr;
  125b5c:	e320f000 	nop	{0}
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  125b60:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125b64:	e5d3301e 	ldrb	r3, [r3, #30]
  125b68:	e1e03c83 	mvn	r3, r3, lsl #25
  125b6c:	e1e03ca3 	mvn	r3, r3, lsr #25
  125b70:	e6ef2073 	uxtb	r2, r3
  125b74:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125b78:	e5c3201e 	strb	r2, [r3, #30]
  TCP_STATS_INC(tcp.memerr);
  125b7c:	e3063840 	movw	r3, #26688	; 0x6840
  125b80:	e3403057 	movt	r3, #87	; 0x57
  125b84:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
  125b88:	e2833001 	add	r3, r3, #1
  125b8c:	e6ff2073 	uxth	r2, r3
  125b90:	e3063840 	movw	r3, #26688	; 0x6840
  125b94:	e3403057 	movt	r3, #87	; 0x57
  125b98:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8

  if (concat_p != NULL) {
  125b9c:	e51b3010 	ldr	r3, [fp, #-16]
  125ba0:	e3530000 	cmp	r3, #0
  125ba4:	0a000001 	beq	125bb0 <tcp_write+0xb18>
    pbuf_free(concat_p);
  125ba8:	e51b0010 	ldr	r0, [fp, #-16]
  125bac:	ebffd540 	bl	11b0b4 <pbuf_free>
  }
  if (queue != NULL) {
  125bb0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125bb4:	e3530000 	cmp	r3, #0
  125bb8:	0a000001 	beq	125bc4 <tcp_write+0xb2c>
    tcp_segs_free(queue);
  125bbc:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  125bc0:	ebffe69b 	bl	11f634 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  125bc4:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125bc8:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  125bcc:	e3530000 	cmp	r3, #0
  125bd0:	0a00000e 	beq	125c10 <tcp_write+0xb78>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
  125bd4:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125bd8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  125bdc:	e3530000 	cmp	r3, #0
  125be0:	1a00000a 	bne	125c10 <tcp_write+0xb78>
  125be4:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  125be8:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  125bec:	e3530000 	cmp	r3, #0
  125bf0:	1a000006 	bne	125c10 <tcp_write+0xb78>
  125bf4:	e3080ad4 	movw	r0, #35540	; 0x8ad4
  125bf8:	e3400014 	movt	r0, #20
  125bfc:	ebff7544 	bl	103114 <rt_kprintf>
  125c00:	e3001302 	movw	r1, #770	; 0x302
  125c04:	e308084c 	movw	r0, #34892	; 0x884c
  125c08:	e3400014 	movt	r0, #20
  125c0c:	ebff951a 	bl	10b07c <sys_arch_assert>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  125c10:	e3e03000 	mvn	r3, #0
}
  125c14:	e1a00003 	mov	r0, r3
  125c18:	e24bd008 	sub	sp, fp, #8
  125c1c:	e8bd8810 	pop	{r4, fp, pc}

00125c20 <tcp_enqueue_flags>:
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
  125c20:	e92d4800 	push	{fp, lr}
  125c24:	e28db004 	add	fp, sp, #4
  125c28:	e24dd028 	sub	sp, sp, #40	; 0x28
  125c2c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  125c30:	e1a03001 	mov	r3, r1
  125c34:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
  125c38:	e3a03000 	mov	r3, #0
  125c3c:	e54b3005 	strb	r3, [fp, #-5]
  u8_t optlen = 0;
  125c40:	e3a03000 	mov	r3, #0
  125c44:	e54b300d 	strb	r3, [fp, #-13]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
  125c48:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  125c4c:	e2033003 	and	r3, r3, #3
  125c50:	e3530000 	cmp	r3, #0
  125c54:	1a000006 	bne	125c74 <tcp_enqueue_flags+0x54>
  125c58:	e3080af4 	movw	r0, #35572	; 0x8af4
  125c5c:	e3400014 	movt	r0, #20
  125c60:	ebff752b 	bl	103114 <rt_kprintf>
  125c64:	e300131b 	movw	r1, #795	; 0x31b
  125c68:	e308084c 	movw	r0, #34892	; 0x884c
  125c6c:	e3400014 	movt	r0, #20
  125c70:	ebff9501 	bl	10b07c <sys_arch_assert>
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow (FIN flag should always come through!) */
  if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
  125c74:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125c78:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  125c7c:	e3530015 	cmp	r3, #21
  125c80:	8a000004 	bhi	125c98 <tcp_enqueue_flags+0x78>
  125c84:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125c88:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  125c8c:	e30f2ffc 	movw	r2, #65532	; 0xfffc
  125c90:	e1530002 	cmp	r3, r2
  125c94:	9a000014 	bls	125cec <tcp_enqueue_flags+0xcc>
      ((flags & TCP_FIN) == 0)) {
  125c98:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  125c9c:	e2033001 	and	r3, r3, #1
  if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
  125ca0:	e3530000 	cmp	r3, #0
  125ca4:	1a000010 	bne	125cec <tcp_enqueue_flags+0xcc>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
  125ca8:	e3063840 	movw	r3, #26688	; 0x6840
  125cac:	e3403057 	movt	r3, #87	; 0x57
  125cb0:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
  125cb4:	e2833001 	add	r3, r3, #1
  125cb8:	e6ff2073 	uxth	r2, r3
  125cbc:	e3063840 	movw	r3, #26688	; 0x6840
  125cc0:	e3403057 	movt	r3, #87	; 0x57
  125cc4:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
    pcb->flags |= TF_NAGLEMEMERR;
  125cc8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125ccc:	e5d3301e 	ldrb	r3, [r3, #30]
  125cd0:	e1e03c83 	mvn	r3, r3, lsl #25
  125cd4:	e1e03ca3 	mvn	r3, r3, lsr #25
  125cd8:	e6ef2073 	uxtb	r2, r3
  125cdc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125ce0:	e5c3201e 	strb	r2, [r3, #30]
    return ERR_MEM;
  125ce4:	e3e03000 	mvn	r3, #0
  125ce8:	ea0000b7 	b	125fcc <tcp_enqueue_flags+0x3ac>
  }

  if (flags & TCP_SYN) {
  125cec:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  125cf0:	e2033002 	and	r3, r3, #2
  125cf4:	e3530000 	cmp	r3, #0
  125cf8:	0a000001 	beq	125d04 <tcp_enqueue_flags+0xe4>
    optflags = TF_SEG_OPTS_MSS;
  125cfc:	e3a03001 	mov	r3, #1
  125d00:	e54b3005 	strb	r3, [fp, #-5]
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host. */
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
  125d04:	e55b3005 	ldrb	r3, [fp, #-5]
  125d08:	e1a03103 	lsl	r3, r3, #2
  125d0c:	e6ef3073 	uxtb	r3, r3
  125d10:	e2033004 	and	r3, r3, #4
  125d14:	e54b300d 	strb	r3, [fp, #-13]

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  125d18:	e55b300d 	ldrb	r3, [fp, #-13]
  125d1c:	e6ff3073 	uxth	r3, r3
  125d20:	e3a02000 	mov	r2, #0
  125d24:	e1a01003 	mov	r1, r3
  125d28:	e3a00000 	mov	r0, #0
  125d2c:	ebffd1d9 	bl	11a498 <pbuf_alloc>
  125d30:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  125d34:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125d38:	e3530000 	cmp	r3, #0
  125d3c:	1a000010 	bne	125d84 <tcp_enqueue_flags+0x164>
    pcb->flags |= TF_NAGLEMEMERR;
  125d40:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125d44:	e5d3301e 	ldrb	r3, [r3, #30]
  125d48:	e1e03c83 	mvn	r3, r3, lsl #25
  125d4c:	e1e03ca3 	mvn	r3, r3, lsr #25
  125d50:	e6ef2073 	uxtb	r2, r3
  125d54:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125d58:	e5c3201e 	strb	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
  125d5c:	e3063840 	movw	r3, #26688	; 0x6840
  125d60:	e3403057 	movt	r3, #87	; 0x57
  125d64:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
  125d68:	e2833001 	add	r3, r3, #1
  125d6c:	e6ff2073 	uxth	r2, r3
  125d70:	e3063840 	movw	r3, #26688	; 0x6840
  125d74:	e3403057 	movt	r3, #87	; 0x57
  125d78:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
    return ERR_MEM;
  125d7c:	e3e03000 	mvn	r3, #0
  125d80:	ea000091 	b	125fcc <tcp_enqueue_flags+0x3ac>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
  125d84:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  125d88:	e1d320ba 	ldrh	r2, [r3, #10]
  125d8c:	e55b300d 	ldrb	r3, [fp, #-13]
  125d90:	e6ff3073 	uxth	r3, r3
  125d94:	e1520003 	cmp	r2, r3
  125d98:	2a000006 	bcs	125db8 <tcp_enqueue_flags+0x198>
  125d9c:	e3080b4c 	movw	r0, #35660	; 0x8b4c
  125da0:	e3400014 	movt	r0, #20
  125da4:	ebff74da 	bl	103114 <rt_kprintf>
  125da8:	e3001341 	movw	r1, #833	; 0x341
  125dac:	e308084c 	movw	r0, #34892	; 0x884c
  125db0:	e3400014 	movt	r0, #20
  125db4:	ebff94b0 	bl	10b07c <sys_arch_assert>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
  125db8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125dbc:	e593105c 	ldr	r1, [r3, #92]	; 0x5c
  125dc0:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
  125dc4:	e55b3005 	ldrb	r3, [fp, #-5]
  125dc8:	e58d3000 	str	r3, [sp]
  125dcc:	e1a03001 	mov	r3, r1
  125dd0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  125dd4:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  125dd8:	ebfffb6d 	bl	124b94 <tcp_create_segment>
  125ddc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  125de0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  125de4:	e3530000 	cmp	r3, #0
  125de8:	1a000010 	bne	125e30 <tcp_enqueue_flags+0x210>
    pcb->flags |= TF_NAGLEMEMERR;
  125dec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125df0:	e5d3301e 	ldrb	r3, [r3, #30]
  125df4:	e1e03c83 	mvn	r3, r3, lsl #25
  125df8:	e1e03ca3 	mvn	r3, r3, lsr #25
  125dfc:	e6ef2073 	uxtb	r2, r3
  125e00:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125e04:	e5c3201e 	strb	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
  125e08:	e3063840 	movw	r3, #26688	; 0x6840
  125e0c:	e3403057 	movt	r3, #87	; 0x57
  125e10:	e1d33bb8 	ldrh	r3, [r3, #184]	; 0xb8
  125e14:	e2833001 	add	r3, r3, #1
  125e18:	e6ff2073 	uxth	r2, r3
  125e1c:	e3063840 	movw	r3, #26688	; 0x6840
  125e20:	e3403057 	movt	r3, #87	; 0x57
  125e24:	e1c32bb8 	strh	r2, [r3, #184]	; 0xb8
    return ERR_MEM;
  125e28:	e3e03000 	mvn	r3, #0
  125e2c:	ea000066 	b	125fcc <tcp_enqueue_flags+0x3ac>
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
  125e30:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  125e34:	e593300c 	ldr	r3, [r3, #12]
  125e38:	e2033003 	and	r3, r3, #3
  125e3c:	e3530000 	cmp	r3, #0
  125e40:	0a000006 	beq	125e60 <tcp_enqueue_flags+0x240>
  125e44:	e3080b88 	movw	r0, #35720	; 0x8b88
  125e48:	e3400014 	movt	r0, #20
  125e4c:	ebff74b0 	bl	103114 <rt_kprintf>
  125e50:	e3001349 	movw	r1, #841	; 0x349
  125e54:	e308084c 	movw	r0, #34892	; 0x884c
  125e58:	e3400014 	movt	r0, #20
  125e5c:	ebff9486 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
  125e60:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  125e64:	e1d330b8 	ldrh	r3, [r3, #8]
  125e68:	e3530000 	cmp	r3, #0
  125e6c:	0a000006 	beq	125e8c <tcp_enqueue_flags+0x26c>
  125e70:	e3080ba0 	movw	r0, #35744	; 0x8ba0
  125e74:	e3400014 	movt	r0, #20
  125e78:	ebff74a5 	bl	103114 <rt_kprintf>
  125e7c:	e300134a 	movw	r1, #842	; 0x34a
  125e80:	e308084c 	movw	r0, #34892	; 0x884c
  125e84:	e3400014 	movt	r0, #20
  125e88:	ebff947b 	bl	10b07c <sys_arch_assert>
               lwip_ntohl(seg->tcphdr->seqno),
               lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
  125e8c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125e90:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  125e94:	e3530000 	cmp	r3, #0
  125e98:	1a000003 	bne	125eac <tcp_enqueue_flags+0x28c>
    pcb->unsent = seg;
  125e9c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125ea0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  125ea4:	e583206c 	str	r2, [r3, #108]	; 0x6c
  125ea8:	ea00000d 	b	125ee4 <tcp_enqueue_flags+0x2c4>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  125eac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125eb0:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  125eb4:	e50b300c 	str	r3, [fp, #-12]
  125eb8:	ea000002 	b	125ec8 <tcp_enqueue_flags+0x2a8>
  125ebc:	e51b300c 	ldr	r3, [fp, #-12]
  125ec0:	e5933000 	ldr	r3, [r3]
  125ec4:	e50b300c 	str	r3, [fp, #-12]
  125ec8:	e51b300c 	ldr	r3, [fp, #-12]
  125ecc:	e5933000 	ldr	r3, [r3]
  125ed0:	e3530000 	cmp	r3, #0
  125ed4:	1afffff8 	bne	125ebc <tcp_enqueue_flags+0x29c>
    useg->next = seg;
  125ed8:	e51b300c 	ldr	r3, [fp, #-12]
  125edc:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  125ee0:	e5832000 	str	r2, [r3]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
  125ee4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125ee8:	e3a02000 	mov	r2, #0
  125eec:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  125ef0:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  125ef4:	e2033002 	and	r3, r3, #2
  125ef8:	e3530000 	cmp	r3, #0
  125efc:	1a000003 	bne	125f10 <tcp_enqueue_flags+0x2f0>
  125f00:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  125f04:	e2033001 	and	r3, r3, #1
  125f08:	e3530000 	cmp	r3, #0
  125f0c:	0a000004 	beq	125f24 <tcp_enqueue_flags+0x304>
    pcb->snd_lbb++;
  125f10:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125f14:	e593305c 	ldr	r3, [r3, #92]	; 0x5c
  125f18:	e2832001 	add	r2, r3, #1
  125f1c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125f20:	e583205c 	str	r2, [r3, #92]	; 0x5c
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
  125f24:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  125f28:	e2033001 	and	r3, r3, #1
  125f2c:	e3530000 	cmp	r3, #0
  125f30:	0a000005 	beq	125f4c <tcp_enqueue_flags+0x32c>
    pcb->flags |= TF_FIN;
  125f34:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125f38:	e5d3301e 	ldrb	r3, [r3, #30]
  125f3c:	e3833020 	orr	r3, r3, #32
  125f40:	e6ef2073 	uxtb	r2, r3
  125f44:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125f48:	e5c3201e 	strb	r2, [r3, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
  125f4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  125f50:	e5933004 	ldr	r3, [r3, #4]
  125f54:	e1a00003 	mov	r0, r3
  125f58:	ebffd4da 	bl	11b2c8 <pbuf_clen>
  125f5c:	e1a03000 	mov	r3, r0
  125f60:	e1a02003 	mov	r2, r3
  125f64:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125f68:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  125f6c:	e0823003 	add	r3, r2, r3
  125f70:	e6ff2073 	uxth	r2, r3
  125f74:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125f78:	e1c326b6 	strh	r2, [r3, #102]	; 0x66
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  125f7c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125f80:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  125f84:	e3530000 	cmp	r3, #0
  125f88:	0a00000e 	beq	125fc8 <tcp_enqueue_flags+0x3a8>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
  125f8c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125f90:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  125f94:	e3530000 	cmp	r3, #0
  125f98:	1a00000a 	bne	125fc8 <tcp_enqueue_flags+0x3a8>
  125f9c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125fa0:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  125fa4:	e3530000 	cmp	r3, #0
  125fa8:	1a000006 	bne	125fc8 <tcp_enqueue_flags+0x3a8>
  125fac:	e3080bcc 	movw	r0, #35788	; 0x8bcc
  125fb0:	e3400014 	movt	r0, #20
  125fb4:	ebff7456 	bl	103114 <rt_kprintf>
  125fb8:	e300136d 	movw	r1, #877	; 0x36d
  125fbc:	e308084c 	movw	r0, #34892	; 0x884c
  125fc0:	e3400014 	movt	r0, #20
  125fc4:	ebff942c 	bl	10b07c <sys_arch_assert>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
  125fc8:	e3a03000 	mov	r3, #0
}
  125fcc:	e1a00003 	mov	r0, r3
  125fd0:	e24bd004 	sub	sp, fp, #4
  125fd4:	e8bd8800 	pop	{fp, pc}

00125fd8 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
  125fd8:	e92d4810 	push	{r4, fp, lr}
  125fdc:	e28db008 	add	fp, sp, #8
  125fe0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
  125fe4:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  err_t err;
  struct pbuf *p;
  u8_t optlen = 0;
  125fe8:	e3a03000 	mov	r3, #0
  125fec:	e54b300e 	strb	r3, [fp, #-14]
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
  125ff0:	e55b300e 	ldrb	r3, [fp, #-14]
  125ff4:	e6ff4073 	uxth	r4, r3
  125ff8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  125ffc:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  126000:	e1a00003 	mov	r0, r3
  126004:	ebffc1ff 	bl	116808 <lwip_htonl>
  126008:	e1a03000 	mov	r3, r0
  12600c:	e3a02000 	mov	r2, #0
  126010:	e1a01004 	mov	r1, r4
  126014:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  126018:	ebfffa36 	bl	1248f8 <tcp_output_alloc_header>
  12601c:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  if (p == NULL) {
  126020:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126024:	e3530000 	cmp	r3, #0
  126028:	1a000007 	bne	12604c <tcp_send_empty_ack+0x74>
    /* let tcp_fasttmr retry sending this ACK */
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
  12602c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126030:	e5d3301e 	ldrb	r3, [r3, #30]
  126034:	e3833003 	orr	r3, r3, #3
  126038:	e6ef2073 	uxtb	r2, r3
  12603c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126040:	e5c3201e 	strb	r2, [r3, #30]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
  126044:	e3e03001 	mvn	r3, #1
  126048:	ea000040 	b	126150 <tcp_send_empty_ack+0x178>
  }
#if LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP
  tcphdr = (struct tcp_hdr *)p->payload;
  12604c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126050:	e5933004 	ldr	r3, [r3, #4]
  126054:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  if (pcb->flags & TF_TIMESTAMP) {
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif

  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
  126058:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12605c:	e2833004 	add	r3, r3, #4
  126060:	e1a00003 	mov	r0, r3
  126064:	eb002cc9 	bl	131390 <ip4_route>
  126068:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
  if (netif == NULL) {
  12606c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  126070:	e3530000 	cmp	r3, #0
  126074:	1a000002 	bne	126084 <tcp_send_empty_ack+0xac>
    err = ERR_RTE;
  126078:	e3e03003 	mvn	r3, #3
  12607c:	e54b300d 	strb	r3, [fp, #-13]
  126080:	ea00001f 	b	126104 <tcp_send_empty_ack+0x12c>
  } else {
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
  126084:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126088:	e1d320b8 	ldrh	r2, [r3, #8]
        &pcb->local_ip, &pcb->remote_ip);
  12608c:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  126090:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126094:	e2833004 	add	r3, r3, #4
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
  126098:	e58d3000 	str	r3, [sp]
  12609c:	e1a03001 	mov	r3, r1
  1260a0:	e3a01006 	mov	r1, #6
  1260a4:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1260a8:	ebffc9e9 	bl	118854 <ip_chksum_pseudo>
  1260ac:	e1a03000 	mov	r3, r0
  1260b0:	e1a02003 	mov	r2, r3
  1260b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1260b8:	e1c321b0 	strh	r2, [r3, #16]
    }
#endif
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip,
  1260bc:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  1260c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1260c4:	e2830004 	add	r0, r3, #4
  1260c8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1260cc:	e5d3c00a 	ldrb	ip, [r3, #10]
  1260d0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1260d4:	e5d33009 	ldrb	r3, [r3, #9]
  1260d8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1260dc:	e58d2008 	str	r2, [sp, #8]
  1260e0:	e3a02006 	mov	r2, #6
  1260e4:	e58d2004 	str	r2, [sp, #4]
  1260e8:	e58d3000 	str	r3, [sp]
  1260ec:	e1a0300c 	mov	r3, ip
  1260f0:	e1a02000 	mov	r2, r0
  1260f4:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  1260f8:	eb002f7d 	bl	131ef4 <ip4_output_if>
  1260fc:	e1a03000 	mov	r3, r0
  126100:	e54b300d 	strb	r3, [fp, #-13]
      pcb->ttl, pcb->tos, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }
  pbuf_free(p);
  126104:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  126108:	ebffd3e9 	bl	11b0b4 <pbuf_free>

  if (err != ERR_OK) {
  12610c:	e15b30dd 	ldrsb	r3, [fp, #-13]
  126110:	e3530000 	cmp	r3, #0
  126114:	0a000006 	beq	126134 <tcp_send_empty_ack+0x15c>
    /* let tcp_fasttmr retry sending this ACK */
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
  126118:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12611c:	e5d3301e 	ldrb	r3, [r3, #30]
  126120:	e3833003 	orr	r3, r3, #3
  126124:	e6ef2073 	uxtb	r2, r3
  126128:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12612c:	e5c3201e 	strb	r2, [r3, #30]
  126130:	ea000005 	b	12614c <tcp_send_empty_ack+0x174>
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  126134:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126138:	e5d3301e 	ldrb	r3, [r3, #30]
  12613c:	e3c33003 	bic	r3, r3, #3
  126140:	e6ef2073 	uxtb	r2, r3
  126144:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126148:	e5c3201e 	strb	r2, [r3, #30]
  }

  return err;
  12614c:	e15b30dd 	ldrsb	r3, [fp, #-13]
}
  126150:	e1a00003 	mov	r0, r3
  126154:	e24bd008 	sub	sp, fp, #8
  126158:	e8bd8810 	pop	{r4, fp, pc}

0012615c <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  12615c:	e92d4830 	push	{r4, r5, fp, lr}
  126160:	e28db00c 	add	fp, sp, #12
  126164:	e24dd028 	sub	sp, sp, #40	; 0x28
  126168:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
  12616c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126170:	e5933014 	ldr	r3, [r3, #20]
  126174:	e3530001 	cmp	r3, #1
  126178:	1a000006 	bne	126198 <tcp_output+0x3c>
  12617c:	e3080bf4 	movw	r0, #35828	; 0x8bf4
  126180:	e3400014 	movt	r0, #20
  126184:	ebff73e2 	bl	103114 <rt_kprintf>
  126188:	e30013ed 	movw	r1, #1005	; 0x3ed
  12618c:	e308084c 	movw	r0, #34892	; 0x884c
  126190:	e3400014 	movt	r0, #20
  126194:	ebff93b8 	bl	10b07c <sys_arch_assert>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  126198:	e3063a44 	movw	r3, #27204	; 0x6a44
  12619c:	e3403057 	movt	r3, #87	; 0x57
  1261a0:	e5933000 	ldr	r3, [r3]
  1261a4:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  1261a8:	e1520003 	cmp	r2, r3
  1261ac:	1a000001 	bne	1261b8 <tcp_output+0x5c>
    return ERR_OK;
  1261b0:	e3a03000 	mov	r3, #0
  1261b4:	ea000196 	b	126814 <tcp_output+0x6b8>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  1261b8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1261bc:	e1d326b0 	ldrh	r2, [r3, #96]	; 0x60
  1261c0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1261c4:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
  1261c8:	e1520003 	cmp	r2, r3
  1261cc:	2a000002 	bcs	1261dc <tcp_output+0x80>
  1261d0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1261d4:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  1261d8:	ea000001 	b	1261e4 <tcp_output+0x88>
  1261dc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1261e0:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
  1261e4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

  seg = pcb->unsent;
  1261e8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1261ec:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  1261f0:	e50b3010 	str	r3, [fp, #-16]
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  1261f4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1261f8:	e5d3301e 	ldrb	r3, [r3, #30]
  1261fc:	e2033002 	and	r3, r3, #2
  126200:	e3530000 	cmp	r3, #0
  126204:	0a000015 	beq	126260 <tcp_output+0x104>
  126208:	e51b3010 	ldr	r3, [fp, #-16]
  12620c:	e3530000 	cmp	r3, #0
  126210:	0a00000e 	beq	126250 <tcp_output+0xf4>
     (seg == NULL ||
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  126214:	e51b3010 	ldr	r3, [fp, #-16]
  126218:	e593300c 	ldr	r3, [r3, #12]
  12621c:	e5933004 	ldr	r3, [r3, #4]
  126220:	e1a00003 	mov	r0, r3
  126224:	ebffc177 	bl	116808 <lwip_htonl>
  126228:	e1a02000 	mov	r2, r0
  12622c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126230:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  126234:	e0423003 	sub	r3, r2, r3
  126238:	e51b2010 	ldr	r2, [fp, #-16]
  12623c:	e1d220b8 	ldrh	r2, [r2, #8]
  126240:	e0833002 	add	r3, r3, r2
     (seg == NULL ||
  126244:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  126248:	e1520003 	cmp	r2, r3
  12624c:	2a000003 	bcs	126260 <tcp_output+0x104>
     return tcp_send_empty_ack(pcb);
  126250:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  126254:	ebffff5f 	bl	125fd8 <tcp_send_empty_ack>
  126258:	e1a03000 	mov	r3, r0
  12625c:	ea00016c 	b	126814 <tcp_output+0x6b8>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  126260:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126264:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  126268:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  if (useg != NULL) {
  12626c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126270:	e3530000 	cmp	r3, #0
  126274:	0a000007 	beq	126298 <tcp_output+0x13c>
    for (; useg->next != NULL; useg = useg->next);
  126278:	ea000002 	b	126288 <tcp_output+0x12c>
  12627c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126280:	e5933000 	ldr	r3, [r3]
  126284:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  126288:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12628c:	e5933000 	ldr	r3, [r3]
  126290:	e3530000 	cmp	r3, #0
  126294:	1afffff8 	bne	12627c <tcp_output+0x120>
  }

  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
  126298:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12629c:	e2833004 	add	r3, r3, #4
  1262a0:	e1a00003 	mov	r0, r3
  1262a4:	eb002c39 	bl	131390 <ip4_route>
  1262a8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  if (netif == NULL) {
  1262ac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1262b0:	e3530000 	cmp	r3, #0
  1262b4:	1a000001 	bne	1262c0 <tcp_output+0x164>
    return ERR_RTE;
  1262b8:	e3e03003 	mvn	r3, #3
  1262bc:	ea000154 	b	126814 <tcp_output+0x6b8>
  }

  /* If we don't have a local IP address, we get one from netif */
  if (ip_addr_isany(&pcb->local_ip)) {
  1262c0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1262c4:	e3530000 	cmp	r3, #0
  1262c8:	0a000003 	beq	1262dc <tcp_output+0x180>
  1262cc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1262d0:	e5933000 	ldr	r3, [r3]
  1262d4:	e3530000 	cmp	r3, #0
  1262d8:	1a000010 	bne	126320 <tcp_output+0x1c4>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
  1262dc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1262e0:	e3530000 	cmp	r3, #0
  1262e4:	0a000002 	beq	1262f4 <tcp_output+0x198>
  1262e8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1262ec:	e2833004 	add	r3, r3, #4
  1262f0:	ea000000 	b	1262f8 <tcp_output+0x19c>
  1262f4:	e3a03000 	mov	r3, #0
  1262f8:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    if (local_ip == NULL) {
  1262fc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126300:	e3530000 	cmp	r3, #0
  126304:	1a000001 	bne	126310 <tcp_output+0x1b4>
      return ERR_RTE;
  126308:	e3e03003 	mvn	r3, #3
  12630c:	ea000140 	b	126814 <tcp_output+0x6b8>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
  126310:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126314:	e5932000 	ldr	r2, [r3]
  126318:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12631c:	e5832000 	str	r2, [r3]
   * with part of the unsent segment (which will engage zero-window probing upon
   * reception of the zero window update from the receiver). This ensures the
   * subsequent window update is reliably received. With the goal of being lightweight,
   * we avoid splitting the unsent segment and treat the window as already zero.
   */
  if (seg != NULL &&
  126320:	e51b3010 	ldr	r3, [fp, #-16]
  126324:	e3530000 	cmp	r3, #0
  126328:	0a000113 	beq	12677c <tcp_output+0x620>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
  12632c:	e51b3010 	ldr	r3, [fp, #-16]
  126330:	e593300c 	ldr	r3, [r3, #12]
  126334:	e5933004 	ldr	r3, [r3, #4]
  126338:	e1a00003 	mov	r0, r3
  12633c:	ebffc131 	bl	116808 <lwip_htonl>
  126340:	e1a02000 	mov	r2, r0
  126344:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126348:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  12634c:	e0423003 	sub	r3, r2, r3
  126350:	e51b2010 	ldr	r2, [fp, #-16]
  126354:	e1d220b8 	ldrh	r2, [r2, #8]
  126358:	e0833002 	add	r3, r3, r2
  if (seg != NULL &&
  12635c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  126360:	e1520003 	cmp	r2, r3
  126364:	2a000104 	bcs	12677c <tcp_output+0x620>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
  126368:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12636c:	e3530000 	cmp	r3, #0
  126370:	0a000101 	beq	12677c <tcp_output+0x620>
      wnd > 0 && wnd == pcb->snd_wnd && pcb->unacked == NULL) {
  126374:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126378:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  12637c:	e1a02003 	mov	r2, r3
  126380:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  126384:	e1530002 	cmp	r3, r2
  126388:	1a0000fb 	bne	12677c <tcp_output+0x620>
  12638c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126390:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  126394:	e3530000 	cmp	r3, #0
  126398:	1a0000f7 	bne	12677c <tcp_output+0x620>
    /* Start the persist timer */
    if (pcb->persist_backoff == 0) {
  12639c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1263a0:	e5d330a1 	ldrb	r3, [r3, #161]	; 0xa1
  1263a4:	e3530000 	cmp	r3, #0
  1263a8:	1a000106 	bne	1267c8 <tcp_output+0x66c>
      pcb->persist_cnt = 0;
  1263ac:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1263b0:	e3a02000 	mov	r2, #0
  1263b4:	e5c320a0 	strb	r2, [r3, #160]	; 0xa0
      pcb->persist_backoff = 1;
  1263b8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1263bc:	e3a02001 	mov	r2, #1
  1263c0:	e5c320a1 	strb	r2, [r3, #161]	; 0xa1
    }
    goto output_done;
  1263c4:	ea0000ff 	b	1267c8 <tcp_output+0x66c>
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!",
  1263c8:	e51b3010 	ldr	r3, [fp, #-16]
  1263cc:	e593300c 	ldr	r3, [r3, #12]
  1263d0:	e1d330bc 	ldrh	r3, [r3, #12]
  1263d4:	e6ff3073 	uxth	r3, r3
  1263d8:	e1a00003 	mov	r0, r3
  1263dc:	ebffc0fd 	bl	1167d8 <lwip_htons>
  1263e0:	e1a03000 	mov	r3, r0
  1263e4:	e2033004 	and	r3, r3, #4
  1263e8:	e3530000 	cmp	r3, #0
  1263ec:	0a000006 	beq	12640c <tcp_output+0x2b0>
  1263f0:	e3080c1c 	movw	r0, #35868	; 0x8c1c
  1263f4:	e3400014 	movt	r0, #20
  1263f8:	ebff7345 	bl	103114 <rt_kprintf>
  1263fc:	e3001446 	movw	r1, #1094	; 0x446
  126400:	e308084c 	movw	r0, #34892	; 0x884c
  126404:	e3400014 	movt	r0, #20
  126408:	ebff931b 	bl	10b07c <sys_arch_assert>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
  12640c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126410:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  126414:	e3530000 	cmp	r3, #0
  126418:	0a00001c 	beq	126490 <tcp_output+0x334>
  12641c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126420:	e5d3301e 	ldrb	r3, [r3, #30]
  126424:	e2033044 	and	r3, r3, #68	; 0x44
  126428:	e3530000 	cmp	r3, #0
  12642c:	1a000017 	bne	126490 <tcp_output+0x334>
  126430:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126434:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  126438:	e3530000 	cmp	r3, #0
  12643c:	0a00000b 	beq	126470 <tcp_output+0x314>
  126440:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126444:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  126448:	e5933000 	ldr	r3, [r3]
  12644c:	e3530000 	cmp	r3, #0
  126450:	1a00000e 	bne	126490 <tcp_output+0x334>
  126454:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126458:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  12645c:	e1d320b8 	ldrh	r2, [r3, #8]
  126460:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126464:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  126468:	e1520003 	cmp	r2, r3
  12646c:	2a000007 	bcs	126490 <tcp_output+0x334>
  126470:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126474:	e1d336b4 	ldrh	r3, [r3, #100]	; 0x64
  126478:	e3530000 	cmp	r3, #0
  12647c:	0a000003 	beq	126490 <tcp_output+0x334>
  126480:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126484:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  126488:	e3530015 	cmp	r3, #21
  12648c:	9a000001 	bls	126498 <tcp_output+0x33c>
  126490:	e3a03001 	mov	r3, #1
  126494:	ea000000 	b	12649c <tcp_output+0x340>
  126498:	e3a03000 	mov	r3, #0
  12649c:	e3530000 	cmp	r3, #0
  1264a0:	1a000004 	bne	1264b8 <tcp_output+0x35c>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
  1264a4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1264a8:	e5d3301e 	ldrb	r3, [r3, #30]
  1264ac:	e20330a0 	and	r3, r3, #160	; 0xa0
    if ((tcp_do_output_nagle(pcb) == 0) &&
  1264b0:	e3530000 	cmp	r3, #0
  1264b4:	0a0000c5 	beq	1267d0 <tcp_output+0x674>
                            pcb->lastack,
                            lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    if (pcb->state != SYN_SENT) {
  1264b8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1264bc:	e5933014 	ldr	r3, [r3, #20]
  1264c0:	e3530002 	cmp	r3, #2
  1264c4:	0a00000c 	beq	1264fc <tcp_output+0x3a0>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  1264c8:	e51b3010 	ldr	r3, [fp, #-16]
  1264cc:	e593300c 	ldr	r3, [r3, #12]
  1264d0:	e1d330bc 	ldrh	r3, [r3, #12]
  1264d4:	e6ff4073 	uxth	r4, r3
  1264d8:	e3a00010 	mov	r0, #16
  1264dc:	ebffc0bd 	bl	1167d8 <lwip_htons>
  1264e0:	e1a03000 	mov	r3, r0
  1264e4:	e1a02003 	mov	r2, r3
  1264e8:	e51b3010 	ldr	r3, [fp, #-16]
  1264ec:	e593300c 	ldr	r3, [r3, #12]
  1264f0:	e1842002 	orr	r2, r4, r2
  1264f4:	e6ff2072 	uxth	r2, r2
  1264f8:	e1c320bc 	strh	r2, [r3, #12]
    }

#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */
    err = tcp_output_segment(seg, pcb, netif);
  1264fc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  126500:	e51b1030 	ldr	r1, [fp, #-48]	; 0xffffffd0
  126504:	e51b0010 	ldr	r0, [fp, #-16]
  126508:	eb0000c4 	bl	126820 <tcp_output_segment>
  12650c:	e1a03000 	mov	r3, r0
  126510:	e54b3025 	strb	r3, [fp, #-37]	; 0xffffffdb
    if (err != ERR_OK) {
  126514:	e15b32d5 	ldrsb	r3, [fp, #-37]	; 0xffffffdb
  126518:	e3530000 	cmp	r3, #0
  12651c:	0a000008 	beq	126544 <tcp_output+0x3e8>
      /* segment could not be sent, for whatever reason */
      pcb->flags |= TF_NAGLEMEMERR;
  126520:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126524:	e5d3301e 	ldrb	r3, [r3, #30]
  126528:	e1e03c83 	mvn	r3, r3, lsl #25
  12652c:	e1e03ca3 	mvn	r3, r3, lsr #25
  126530:	e6ef2073 	uxtb	r2, r3
  126534:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126538:	e5c3201e 	strb	r2, [r3, #30]
      return err;
  12653c:	e15b32d5 	ldrsb	r3, [fp, #-37]	; 0xffffffdb
  126540:	ea0000b3 	b	126814 <tcp_output+0x6b8>
    }
    pcb->unsent = seg->next;
  126544:	e51b3010 	ldr	r3, [fp, #-16]
  126548:	e5932000 	ldr	r2, [r3]
  12654c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126550:	e583206c 	str	r2, [r3, #108]	; 0x6c
    if (pcb->state != SYN_SENT) {
  126554:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126558:	e5933014 	ldr	r3, [r3, #20]
  12655c:	e3530002 	cmp	r3, #2
  126560:	0a000005 	beq	12657c <tcp_output+0x420>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  126564:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126568:	e5d3301e 	ldrb	r3, [r3, #30]
  12656c:	e3c33003 	bic	r3, r3, #3
  126570:	e6ef2073 	uxtb	r2, r3
  126574:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126578:	e5c3201e 	strb	r2, [r3, #30]
    }
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  12657c:	e51b3010 	ldr	r3, [fp, #-16]
  126580:	e593300c 	ldr	r3, [r3, #12]
  126584:	e5933004 	ldr	r3, [r3, #4]
  126588:	e1a00003 	mov	r0, r3
  12658c:	ebffc09d 	bl	116808 <lwip_htonl>
  126590:	e1a04000 	mov	r4, r0
  126594:	e51b3010 	ldr	r3, [fp, #-16]
  126598:	e1d330b8 	ldrh	r3, [r3, #8]
  12659c:	e1a05003 	mov	r5, r3
  1265a0:	e51b3010 	ldr	r3, [fp, #-16]
  1265a4:	e593300c 	ldr	r3, [r3, #12]
  1265a8:	e1d330bc 	ldrh	r3, [r3, #12]
  1265ac:	e6ff3073 	uxth	r3, r3
  1265b0:	e1a00003 	mov	r0, r3
  1265b4:	ebffc087 	bl	1167d8 <lwip_htons>
  1265b8:	e1a03000 	mov	r3, r0
  1265bc:	e2033003 	and	r3, r3, #3
  1265c0:	e3530000 	cmp	r3, #0
  1265c4:	0a000001 	beq	1265d0 <tcp_output+0x474>
  1265c8:	e3a03001 	mov	r3, #1
  1265cc:	ea000000 	b	1265d4 <tcp_output+0x478>
  1265d0:	e3a03000 	mov	r3, #0
  1265d4:	e0833005 	add	r3, r3, r5
  1265d8:	e0843003 	add	r3, r4, r3
  1265dc:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
  1265e0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1265e4:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  1265e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1265ec:	e0423003 	sub	r3, r2, r3
  1265f0:	e3530000 	cmp	r3, #0
  1265f4:	aa000002 	bge	126604 <tcp_output+0x4a8>
      pcb->snd_nxt = snd_nxt;
  1265f8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1265fc:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  126600:	e5832050 	str	r2, [r3, #80]	; 0x50
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  126604:	e51b3010 	ldr	r3, [fp, #-16]
  126608:	e1d330b8 	ldrh	r3, [r3, #8]
  12660c:	e1a04003 	mov	r4, r3
  126610:	e51b3010 	ldr	r3, [fp, #-16]
  126614:	e593300c 	ldr	r3, [r3, #12]
  126618:	e1d330bc 	ldrh	r3, [r3, #12]
  12661c:	e6ff3073 	uxth	r3, r3
  126620:	e1a00003 	mov	r0, r3
  126624:	ebffc06b 	bl	1167d8 <lwip_htons>
  126628:	e1a03000 	mov	r3, r0
  12662c:	e2033003 	and	r3, r3, #3
  126630:	e3530000 	cmp	r3, #0
  126634:	0a000001 	beq	126640 <tcp_output+0x4e4>
  126638:	e3a03001 	mov	r3, #1
  12663c:	ea000000 	b	126644 <tcp_output+0x4e8>
  126640:	e3a03000 	mov	r3, #0
  126644:	e0833004 	add	r3, r3, r4
  126648:	e3530000 	cmp	r3, #0
  12664c:	0a000045 	beq	126768 <tcp_output+0x60c>
      seg->next = NULL;
  126650:	e51b3010 	ldr	r3, [fp, #-16]
  126654:	e3a02000 	mov	r2, #0
  126658:	e5832000 	str	r2, [r3]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  12665c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126660:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  126664:	e3530000 	cmp	r3, #0
  126668:	1a000005 	bne	126684 <tcp_output+0x528>
        pcb->unacked = seg;
  12666c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126670:	e51b2010 	ldr	r2, [fp, #-16]
  126674:	e5832070 	str	r2, [r3, #112]	; 0x70
        useg = seg;
  126678:	e51b3010 	ldr	r3, [fp, #-16]
  12667c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  126680:	ea00003a 	b	126770 <tcp_output+0x614>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
  126684:	e51b3010 	ldr	r3, [fp, #-16]
  126688:	e593300c 	ldr	r3, [r3, #12]
  12668c:	e5933004 	ldr	r3, [r3, #4]
  126690:	e1a00003 	mov	r0, r3
  126694:	ebffc05b 	bl	116808 <lwip_htonl>
  126698:	e1a04000 	mov	r4, r0
  12669c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1266a0:	e593300c 	ldr	r3, [r3, #12]
  1266a4:	e5933004 	ldr	r3, [r3, #4]
  1266a8:	e1a00003 	mov	r0, r3
  1266ac:	ebffc055 	bl	116808 <lwip_htonl>
  1266b0:	e1a03000 	mov	r3, r0
  1266b4:	e0443003 	sub	r3, r4, r3
  1266b8:	e3530000 	cmp	r3, #0
  1266bc:	aa000022 	bge	12674c <tcp_output+0x5f0>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
  1266c0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1266c4:	e2833070 	add	r3, r3, #112	; 0x70
  1266c8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
          while (*cur_seg &&
  1266cc:	ea000002 	b	1266dc <tcp_output+0x580>
            TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
  1266d0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1266d4:	e5933000 	ldr	r3, [r3]
  1266d8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
          while (*cur_seg &&
  1266dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1266e0:	e5933000 	ldr	r3, [r3]
  1266e4:	e3530000 	cmp	r3, #0
  1266e8:	0a00000f 	beq	12672c <tcp_output+0x5d0>
            TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
  1266ec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1266f0:	e5933000 	ldr	r3, [r3]
  1266f4:	e593300c 	ldr	r3, [r3, #12]
  1266f8:	e5933004 	ldr	r3, [r3, #4]
  1266fc:	e1a00003 	mov	r0, r3
  126700:	ebffc040 	bl	116808 <lwip_htonl>
  126704:	e1a04000 	mov	r4, r0
  126708:	e51b3010 	ldr	r3, [fp, #-16]
  12670c:	e593300c 	ldr	r3, [r3, #12]
  126710:	e5933004 	ldr	r3, [r3, #4]
  126714:	e1a00003 	mov	r0, r3
  126718:	ebffc03a 	bl	116808 <lwip_htonl>
  12671c:	e1a03000 	mov	r3, r0
  126720:	e0443003 	sub	r3, r4, r3
          while (*cur_seg &&
  126724:	e3530000 	cmp	r3, #0
  126728:	baffffe8 	blt	1266d0 <tcp_output+0x574>
          }
          seg->next = (*cur_seg);
  12672c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126730:	e5932000 	ldr	r2, [r3]
  126734:	e51b3010 	ldr	r3, [fp, #-16]
  126738:	e5832000 	str	r2, [r3]
          (*cur_seg) = seg;
  12673c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126740:	e51b2010 	ldr	r2, [fp, #-16]
  126744:	e5832000 	str	r2, [r3]
  126748:	ea000008 	b	126770 <tcp_output+0x614>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  12674c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126750:	e51b2010 	ldr	r2, [fp, #-16]
  126754:	e5832000 	str	r2, [r3]
          useg = useg->next;
  126758:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12675c:	e5933000 	ldr	r3, [r3]
  126760:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  126764:	ea000001 	b	126770 <tcp_output+0x614>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  126768:	e51b0010 	ldr	r0, [fp, #-16]
  12676c:	ebffe3c2 	bl	11f67c <tcp_seg_free>
    }
    seg = pcb->unsent;
  126770:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  126774:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  126778:	e50b3010 	str	r3, [fp, #-16]
  while (seg != NULL &&
  12677c:	e51b3010 	ldr	r3, [fp, #-16]
  126780:	e3530000 	cmp	r3, #0
  126784:	0a000013 	beq	1267d8 <tcp_output+0x67c>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  126788:	e51b3010 	ldr	r3, [fp, #-16]
  12678c:	e593300c 	ldr	r3, [r3, #12]
  126790:	e5933004 	ldr	r3, [r3, #4]
  126794:	e1a00003 	mov	r0, r3
  126798:	ebffc01a 	bl	116808 <lwip_htonl>
  12679c:	e1a02000 	mov	r2, r0
  1267a0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1267a4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
  1267a8:	e0423003 	sub	r3, r2, r3
  1267ac:	e51b2010 	ldr	r2, [fp, #-16]
  1267b0:	e1d220b8 	ldrh	r2, [r2, #8]
  1267b4:	e0833002 	add	r3, r3, r2
  while (seg != NULL &&
  1267b8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1267bc:	e1520003 	cmp	r2, r3
  1267c0:	2affff00 	bcs	1263c8 <tcp_output+0x26c>
  }
output_done:
  1267c4:	ea000003 	b	1267d8 <tcp_output+0x67c>
    goto output_done;
  1267c8:	e320f000 	nop	{0}
  1267cc:	ea000002 	b	1267dc <tcp_output+0x680>
      break;
  1267d0:	e320f000 	nop	{0}
  1267d4:	ea000000 	b	1267dc <tcp_output+0x680>
output_done:
  1267d8:	e320f000 	nop	{0}
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
  1267dc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1267e0:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  1267e4:	e3530000 	cmp	r3, #0
  1267e8:	1a000002 	bne	1267f8 <tcp_output+0x69c>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  1267ec:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1267f0:	e3a02000 	mov	r2, #0
  1267f4:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
  1267f8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1267fc:	e5d3301e 	ldrb	r3, [r3, #30]
  126800:	e203307f 	and	r3, r3, #127	; 0x7f
  126804:	e6ef2073 	uxtb	r2, r3
  126808:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12680c:	e5c3201e 	strb	r2, [r3, #30]
  return ERR_OK;
  126810:	e3a03000 	mov	r3, #0
}
  126814:	e1a00003 	mov	r0, r3
  126818:	e24bd00c 	sub	sp, fp, #12
  12681c:	e8bd8830 	pop	{r4, r5, fp, pc}

00126820 <tcp_output_segment>:
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static err_t
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
{
  126820:	e92d4810 	push	{r4, fp, lr}
  126824:	e28db008 	add	fp, sp, #8
  126828:	e24dd034 	sub	sp, sp, #52	; 0x34
  12682c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  126830:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  126834:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  err_t err;
  u16_t len;
  u32_t *opts;

  if (seg->p->ref != 1) {
  126838:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12683c:	e5933004 	ldr	r3, [r3, #4]
  126840:	e1d330be 	ldrh	r3, [r3, #14]
  126844:	e3530001 	cmp	r3, #1
  126848:	0a000001 	beq	126854 <tcp_output_segment+0x34>
    /* This can happen if the pbuf of this segment is still referenced by the
       netif driver due to deferred transmission. Since this function modifies
       p->len, we must not continue in this case. */
    return ERR_OK;
  12684c:	e3a03000 	mov	r3, #0
  126850:	ea0000a4 	b	126ae8 <tcp_output_segment+0x2c8>
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
  126854:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126858:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  12685c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126860:	e593400c 	ldr	r4, [r3, #12]
  126864:	e1a00002 	mov	r0, r2
  126868:	ebffbfe6 	bl	116808 <lwip_htonl>
  12686c:	e1a03000 	mov	r3, r0
  126870:	e5843008 	str	r3, [r4, #8]
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  126874:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126878:	e1d322be 	ldrh	r2, [r3, #46]	; 0x2e
  12687c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126880:	e593400c 	ldr	r4, [r3, #12]
  126884:	e1a00002 	mov	r0, r2
  126888:	ebffbfd2 	bl	1167d8 <lwip_htons>
  12688c:	e1a03000 	mov	r3, r0
  126890:	e1c430be 	strh	r3, [r4, #14]
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
  126894:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126898:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12689c:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  1268a0:	e1d222be 	ldrh	r2, [r2, #46]	; 0x2e
  1268a4:	e0832002 	add	r2, r3, r2
  1268a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1268ac:	e5832030 	str	r2, [r3, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  1268b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1268b4:	e593300c 	ldr	r3, [r3, #12]
  1268b8:	e2833014 	add	r3, r3, #20
  1268bc:	e50b3010 	str	r3, [fp, #-16]
  if (seg->flags & TF_SEG_OPTS_MSS) {
  1268c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1268c4:	e5d3300a 	ldrb	r3, [r3, #10]
  1268c8:	e2033001 	and	r3, r3, #1
  1268cc:	e3530000 	cmp	r3, #0
  1268d0:	0a000010 	beq	126918 <tcp_output_segment+0xf8>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->local_ip, &pcb->remote_ip);
  1268d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1268d8:	e2833004 	add	r3, r3, #4
  1268dc:	e1a01003 	mov	r1, r3
  1268e0:	e30005b4 	movw	r0, #1460	; 0x5b4
  1268e4:	ebffe664 	bl	12027c <tcp_eff_send_mss_impl>
  1268e8:	e1a03000 	mov	r3, r0
  1268ec:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
  1268f0:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  1268f4:	e3833781 	orr	r3, r3, #33816576	; 0x2040000
  1268f8:	e1a00003 	mov	r0, r3
  1268fc:	ebffbfc1 	bl	116808 <lwip_htonl>
  126900:	e1a02000 	mov	r2, r0
  126904:	e51b3010 	ldr	r3, [fp, #-16]
  126908:	e5832000 	str	r2, [r3]
    opts += 1;
  12690c:	e51b3010 	ldr	r3, [fp, #-16]
  126910:	e2833004 	add	r3, r3, #4
  126914:	e50b3010 	str	r3, [fp, #-16]
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
  126918:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  12691c:	e1d333f4 	ldrsh	r3, [r3, #52]	; 0x34
  126920:	e3530000 	cmp	r3, #0
  126924:	aa000002 	bge	126934 <tcp_output_segment+0x114>
    pcb->rtime = 0;
  126928:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  12692c:	e3a02000 	mov	r2, #0
  126930:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
  }

  if (pcb->rttest == 0) {
  126934:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126938:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  12693c:	e3530000 	cmp	r3, #0
  126940:	1a00000c 	bne	126978 <tcp_output_segment+0x158>
    pcb->rttest = tcp_ticks;
  126944:	e3063a34 	movw	r3, #27188	; 0x6a34
  126948:	e3403057 	movt	r3, #87	; 0x57
  12694c:	e5932000 	ldr	r2, [r3]
  126950:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126954:	e5832038 	str	r2, [r3, #56]	; 0x38
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
  126958:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12695c:	e593300c 	ldr	r3, [r3, #12]
  126960:	e5933004 	ldr	r3, [r3, #4]
  126964:	e1a00003 	mov	r0, r3
  126968:	ebffbfa6 	bl	116808 <lwip_htonl>
  12696c:	e1a02000 	mov	r2, r0
  126970:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126974:	e583203c 	str	r2, [r3, #60]	; 0x3c
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  126978:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12697c:	e593300c 	ldr	r3, [r3, #12]
  126980:	e1a02003 	mov	r2, r3
  126984:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126988:	e5933004 	ldr	r3, [r3, #4]
  12698c:	e5933004 	ldr	r3, [r3, #4]
  126990:	e0423003 	sub	r3, r2, r3
  126994:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec
  if (len == 0) {
  126998:	e15b31b4 	ldrh	r3, [fp, #-20]	; 0xffffffec
  12699c:	e3530000 	cmp	r3, #0
  1269a0:	1a000006 	bne	1269c0 <tcp_output_segment+0x1a0>
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  1269a4:	e3063840 	movw	r3, #26688	; 0x6840
  1269a8:	e3403057 	movt	r3, #87	; 0x57
  1269ac:	e593317c 	ldr	r3, [r3, #380]	; 0x17c
  1269b0:	e2832001 	add	r2, r3, #1
  1269b4:	e3063840 	movw	r3, #26688	; 0x6840
  1269b8:	e3403057 	movt	r3, #87	; 0x57
  1269bc:	e583217c 	str	r2, [r3, #380]	; 0x17c
  }

  seg->p->len -= len;
  1269c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1269c4:	e5933004 	ldr	r3, [r3, #4]
  1269c8:	e1d310ba 	ldrh	r1, [r3, #10]
  1269cc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1269d0:	e5933004 	ldr	r3, [r3, #4]
  1269d4:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
  1269d8:	e0412002 	sub	r2, r1, r2
  1269dc:	e6ff2072 	uxth	r2, r2
  1269e0:	e1c320ba 	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
  1269e4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1269e8:	e5933004 	ldr	r3, [r3, #4]
  1269ec:	e1d310b8 	ldrh	r1, [r3, #8]
  1269f0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1269f4:	e5933004 	ldr	r3, [r3, #4]
  1269f8:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
  1269fc:	e0412002 	sub	r2, r1, r2
  126a00:	e6ff2072 	uxth	r2, r2
  126a04:	e1c320b8 	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
  126a08:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126a0c:	e5933004 	ldr	r3, [r3, #4]
  126a10:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  126a14:	e592200c 	ldr	r2, [r2, #12]
  126a18:	e5832004 	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
  126a1c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126a20:	e593300c 	ldr	r3, [r3, #12]
  126a24:	e3a02000 	mov	r2, #0
  126a28:	e5c32010 	strb	r2, [r3, #16]
  126a2c:	e3a02000 	mov	r2, #0
  126a30:	e5c32011 	strb	r2, [r3, #17]
                  seg->tcphdr->chksum, chksum_slow));
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
#else /* TCP_CHECKSUM_ON_COPY */
    seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
  126a34:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126a38:	e5930004 	ldr	r0, [r3, #4]
      seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
  126a3c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126a40:	e5933004 	ldr	r3, [r3, #4]
    seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
  126a44:	e1d310b8 	ldrh	r1, [r3, #8]
      seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
  126a48:	e51bc024 	ldr	ip, [fp, #-36]	; 0xffffffdc
  126a4c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126a50:	e2833004 	add	r3, r3, #4
    seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
  126a54:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  126a58:	e592400c 	ldr	r4, [r2, #12]
  126a5c:	e58d3000 	str	r3, [sp]
  126a60:	e1a0300c 	mov	r3, ip
  126a64:	e1a02001 	mov	r2, r1
  126a68:	e3a01006 	mov	r1, #6
  126a6c:	ebffc778 	bl	118854 <ip_chksum_pseudo>
  126a70:	e1a03000 	mov	r3, r0
  126a74:	e1c431b0 	strh	r3, [r4, #16]
#endif /* TCP_CHECKSUM_ON_COPY */
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
  126a78:	e3063840 	movw	r3, #26688	; 0x6840
  126a7c:	e3403057 	movt	r3, #87	; 0x57
  126a80:	e1d33abc 	ldrh	r3, [r3, #172]	; 0xac
  126a84:	e2833001 	add	r3, r3, #1
  126a88:	e6ff2073 	uxth	r2, r3
  126a8c:	e3063840 	movw	r3, #26688	; 0x6840
  126a90:	e3403057 	movt	r3, #87	; 0x57
  126a94:	e1c32abc 	strh	r2, [r3, #172]	; 0xac

  NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
  126a98:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126a9c:	e5930004 	ldr	r0, [r3, #4]
  126aa0:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  126aa4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126aa8:	e283c004 	add	ip, r3, #4
  126aac:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126ab0:	e5d3e00a 	ldrb	lr, [r3, #10]
  126ab4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126ab8:	e5d33009 	ldrb	r3, [r3, #9]
  126abc:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  126ac0:	e58d2008 	str	r2, [sp, #8]
  126ac4:	e3a02006 	mov	r2, #6
  126ac8:	e58d2004 	str	r2, [sp, #4]
  126acc:	e58d3000 	str	r3, [sp]
  126ad0:	e1a0300e 	mov	r3, lr
  126ad4:	e1a0200c 	mov	r2, ip
  126ad8:	eb002d05 	bl	131ef4 <ip4_output_if>
  126adc:	e1a03000 	mov	r3, r0
  126ae0:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    pcb->tos, IP_PROTO_TCP, netif);
  NETIF_SET_HWADDRHINT(netif, NULL);
  return err;
  126ae4:	e15b31d5 	ldrsb	r3, [fp, #-21]	; 0xffffffeb
}
  126ae8:	e1a00003 	mov	r0, r3
  126aec:	e24bd008 	sub	sp, fp, #8
  126af0:	e8bd8810 	pop	{r4, fp, pc}

00126af4 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  126af4:	e92d4800 	push	{fp, lr}
  126af8:	e28db004 	add	fp, sp, #4
  126afc:	e24dd030 	sub	sp, sp, #48	; 0x30
  126b00:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  126b04:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  126b08:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  126b0c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct netif *netif;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  126b10:	e3a02000 	mov	r2, #0
  126b14:	e3a01014 	mov	r1, #20
  126b18:	e3a00001 	mov	r0, #1
  126b1c:	ebffce5d 	bl	11a498 <pbuf_alloc>
  126b20:	e50b0008 	str	r0, [fp, #-8]
  if (p == NULL) {
  126b24:	e51b3008 	ldr	r3, [fp, #-8]
  126b28:	e3530000 	cmp	r3, #0
  126b2c:	0a000069 	beq	126cd8 <tcp_rst+0x1e4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  126b30:	e51b3008 	ldr	r3, [fp, #-8]
  126b34:	e1d330ba 	ldrh	r3, [r3, #10]
  126b38:	e3530013 	cmp	r3, #19
  126b3c:	8a000006 	bhi	126b5c <tcp_rst+0x68>
  126b40:	e308081c 	movw	r0, #34844	; 0x881c
  126b44:	e3400014 	movt	r0, #20
  126b48:	ebff7171 	bl	103114 <rt_kprintf>
  126b4c:	e300154d 	movw	r1, #1357	; 0x54d
  126b50:	e308084c 	movw	r0, #34892	; 0x884c
  126b54:	e3400014 	movt	r0, #20
  126b58:	ebff9147 	bl	10b07c <sys_arch_assert>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  126b5c:	e51b3008 	ldr	r3, [fp, #-8]
  126b60:	e5933004 	ldr	r3, [r3, #4]
  126b64:	e50b300c 	str	r3, [fp, #-12]
  tcphdr->src = lwip_htons(local_port);
  126b68:	e1db30b4 	ldrh	r3, [fp, #4]
  126b6c:	e1a00003 	mov	r0, r3
  126b70:	ebffbf18 	bl	1167d8 <lwip_htons>
  126b74:	e1a03000 	mov	r3, r0
  126b78:	e1a02003 	mov	r2, r3
  126b7c:	e51b300c 	ldr	r3, [fp, #-12]
  126b80:	e1c320b0 	strh	r2, [r3]
  tcphdr->dest = lwip_htons(remote_port);
  126b84:	e1db30b8 	ldrh	r3, [fp, #8]
  126b88:	e1a00003 	mov	r0, r3
  126b8c:	ebffbf11 	bl	1167d8 <lwip_htons>
  126b90:	e1a03000 	mov	r3, r0
  126b94:	e1a02003 	mov	r2, r3
  126b98:	e51b300c 	ldr	r3, [fp, #-12]
  126b9c:	e1c320b2 	strh	r2, [r3, #2]
  tcphdr->seqno = lwip_htonl(seqno);
  126ba0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  126ba4:	ebffbf17 	bl	116808 <lwip_htonl>
  126ba8:	e1a02000 	mov	r2, r0
  126bac:	e51b300c 	ldr	r3, [fp, #-12]
  126bb0:	e5832004 	str	r2, [r3, #4]
  tcphdr->ackno = lwip_htonl(ackno);
  126bb4:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  126bb8:	ebffbf12 	bl	116808 <lwip_htonl>
  126bbc:	e1a02000 	mov	r2, r0
  126bc0:	e51b300c 	ldr	r3, [fp, #-12]
  126bc4:	e5832008 	str	r2, [r3, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  126bc8:	e3050014 	movw	r0, #20500	; 0x5014
  126bcc:	ebffbf01 	bl	1167d8 <lwip_htons>
  126bd0:	e1a03000 	mov	r3, r0
  126bd4:	e1a02003 	mov	r2, r3
  126bd8:	e51b300c 	ldr	r3, [fp, #-12]
  126bdc:	e1c320bc 	strh	r2, [r3, #12]
#if LWIP_WND_SCALE
  tcphdr->wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  tcphdr->wnd = PP_HTONS(TCP_WND);
  126be0:	e51b300c 	ldr	r3, [fp, #-12]
  126be4:	e3e02000 	mvn	r2, #0
  126be8:	e5c3200e 	strb	r2, [r3, #14]
  126bec:	e3e02000 	mvn	r2, #0
  126bf0:	e5c3200f 	strb	r2, [r3, #15]
#endif
  tcphdr->chksum = 0;
  126bf4:	e51b300c 	ldr	r3, [fp, #-12]
  126bf8:	e3a02000 	mov	r2, #0
  126bfc:	e5c32010 	strb	r2, [r3, #16]
  126c00:	e3a02000 	mov	r2, #0
  126c04:	e5c32011 	strb	r2, [r3, #17]
  tcphdr->urgp = 0;
  126c08:	e51b300c 	ldr	r3, [fp, #-12]
  126c0c:	e3a02000 	mov	r2, #0
  126c10:	e5c32012 	strb	r2, [r3, #18]
  126c14:	e3a02000 	mov	r2, #0
  126c18:	e5c32013 	strb	r2, [r3, #19]

  TCP_STATS_INC(tcp.xmit);
  126c1c:	e3063840 	movw	r3, #26688	; 0x6840
  126c20:	e3403057 	movt	r3, #87	; 0x57
  126c24:	e1d33abc 	ldrh	r3, [r3, #172]	; 0xac
  126c28:	e2833001 	add	r3, r3, #1
  126c2c:	e6ff2073 	uxth	r2, r3
  126c30:	e3063840 	movw	r3, #26688	; 0x6840
  126c34:	e3403057 	movt	r3, #87	; 0x57
  126c38:	e1c32abc 	strh	r2, [r3, #172]	; 0xac
  MIB2_STATS_INC(mib2.tcpoutrsts);
  126c3c:	e3063840 	movw	r3, #26688	; 0x6840
  126c40:	e3403057 	movt	r3, #87	; 0x57
  126c44:	e593318c 	ldr	r3, [r3, #396]	; 0x18c
  126c48:	e2832001 	add	r2, r3, #1
  126c4c:	e3063840 	movw	r3, #26688	; 0x6840
  126c50:	e3403057 	movt	r3, #87	; 0x57
  126c54:	e583218c 	str	r2, [r3, #396]	; 0x18c

  netif = ip_route(local_ip, remote_ip);
  126c58:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  126c5c:	eb0029cb 	bl	131390 <ip4_route>
  126c60:	e50b0010 	str	r0, [fp, #-16]
  if (netif != NULL) {
  126c64:	e51b3010 	ldr	r3, [fp, #-16]
  126c68:	e3530000 	cmp	r3, #0
  126c6c:	0a000016 	beq	126ccc <tcp_rst+0x1d8>
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
  126c70:	e51b3008 	ldr	r3, [fp, #-8]
  126c74:	e1d320b8 	ldrh	r2, [r3, #8]
  126c78:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  126c7c:	e58d3000 	str	r3, [sp]
  126c80:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  126c84:	e3a01006 	mov	r1, #6
  126c88:	e51b0008 	ldr	r0, [fp, #-8]
  126c8c:	ebffc6f0 	bl	118854 <ip_chksum_pseudo>
  126c90:	e1a03000 	mov	r3, r0
  126c94:	e1a02003 	mov	r2, r3
  126c98:	e51b300c 	ldr	r3, [fp, #-12]
  126c9c:	e1c321b0 	strh	r2, [r3, #16]
                                        local_ip, remote_ip);
    }
#endif
    /* Send output with hardcoded TTL/HL since we have no access to the pcb */
    ip_output_if(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP, netif);
  126ca0:	e51b3010 	ldr	r3, [fp, #-16]
  126ca4:	e58d3008 	str	r3, [sp, #8]
  126ca8:	e3a03006 	mov	r3, #6
  126cac:	e58d3004 	str	r3, [sp, #4]
  126cb0:	e3a03000 	mov	r3, #0
  126cb4:	e58d3000 	str	r3, [sp]
  126cb8:	e3a030ff 	mov	r3, #255	; 0xff
  126cbc:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  126cc0:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  126cc4:	e51b0008 	ldr	r0, [fp, #-8]
  126cc8:	eb002c89 	bl	131ef4 <ip4_output_if>
  }
  pbuf_free(p);
  126ccc:	e51b0008 	ldr	r0, [fp, #-8]
  126cd0:	ebffd0f7 	bl	11b0b4 <pbuf_free>
  126cd4:	ea000000 	b	126cdc <tcp_rst+0x1e8>
    return;
  126cd8:	e320f000 	nop	{0}
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  126cdc:	e24bd004 	sub	sp, fp, #4
  126ce0:	e8bd8800 	pop	{fp, pc}

00126ce4 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  126ce4:	e92d4800 	push	{fp, lr}
  126ce8:	e28db004 	add	fp, sp, #4
  126cec:	e24dd010 	sub	sp, sp, #16
  126cf0:	e50b0010 	str	r0, [fp, #-16]
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  126cf4:	e51b3010 	ldr	r3, [fp, #-16]
  126cf8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  126cfc:	e3530000 	cmp	r3, #0
  126d00:	0a000025 	beq	126d9c <tcp_rexmit_rto+0xb8>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  126d04:	e51b3010 	ldr	r3, [fp, #-16]
  126d08:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  126d0c:	e50b3008 	str	r3, [fp, #-8]
  126d10:	ea000002 	b	126d20 <tcp_rexmit_rto+0x3c>
  126d14:	e51b3008 	ldr	r3, [fp, #-8]
  126d18:	e5933000 	ldr	r3, [r3]
  126d1c:	e50b3008 	str	r3, [fp, #-8]
  126d20:	e51b3008 	ldr	r3, [fp, #-8]
  126d24:	e5933000 	ldr	r3, [r3]
  126d28:	e3530000 	cmp	r3, #0
  126d2c:	1afffff8 	bne	126d14 <tcp_rexmit_rto+0x30>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  126d30:	e51b3010 	ldr	r3, [fp, #-16]
  126d34:	e593206c 	ldr	r2, [r3, #108]	; 0x6c
  126d38:	e51b3008 	ldr	r3, [fp, #-8]
  126d3c:	e5832000 	str	r2, [r3]
  if (pcb->unsent == NULL) {
    pcb->unsent_oversize = seg->oversize_left;
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  126d40:	e51b3010 	ldr	r3, [fp, #-16]
  126d44:	e5932070 	ldr	r2, [r3, #112]	; 0x70
  126d48:	e51b3010 	ldr	r3, [fp, #-16]
  126d4c:	e583206c 	str	r2, [r3, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  126d50:	e51b3010 	ldr	r3, [fp, #-16]
  126d54:	e3a02000 	mov	r2, #0
  126d58:	e5832070 	str	r2, [r3, #112]	; 0x70

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
  126d5c:	e51b3010 	ldr	r3, [fp, #-16]
  126d60:	e5d33046 	ldrb	r3, [r3, #70]	; 0x46
  126d64:	e35300ff 	cmp	r3, #255	; 0xff
  126d68:	0a000005 	beq	126d84 <tcp_rexmit_rto+0xa0>
    ++pcb->nrtx;
  126d6c:	e51b3010 	ldr	r3, [fp, #-16]
  126d70:	e5d33046 	ldrb	r3, [r3, #70]	; 0x46
  126d74:	e2833001 	add	r3, r3, #1
  126d78:	e6ef2073 	uxtb	r2, r3
  126d7c:	e51b3010 	ldr	r3, [fp, #-16]
  126d80:	e5c32046 	strb	r2, [r3, #70]	; 0x46
  }

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  126d84:	e51b3010 	ldr	r3, [fp, #-16]
  126d88:	e3a02000 	mov	r2, #0
  126d8c:	e5832038 	str	r2, [r3, #56]	; 0x38

  /* Do the actual retransmission */
  tcp_output(pcb);
  126d90:	e51b0010 	ldr	r0, [fp, #-16]
  126d94:	ebfffcf0 	bl	12615c <tcp_output>
  126d98:	ea000000 	b	126da0 <tcp_rexmit_rto+0xbc>
    return;
  126d9c:	e320f000 	nop	{0}
}
  126da0:	e24bd004 	sub	sp, fp, #4
  126da4:	e8bd8800 	pop	{fp, pc}

00126da8 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  126da8:	e92d4810 	push	{r4, fp, lr}
  126dac:	e28db008 	add	fp, sp, #8
  126db0:	e24dd014 	sub	sp, sp, #20
  126db4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
  126db8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126dbc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  126dc0:	e3530000 	cmp	r3, #0
  126dc4:	0a000044 	beq	126edc <tcp_rexmit+0x134>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  126dc8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126dcc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  126dd0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  pcb->unacked = seg->next;
  126dd4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126dd8:	e5932000 	ldr	r2, [r3]
  126ddc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126de0:	e5832070 	str	r2, [r3, #112]	; 0x70

  cur_seg = &(pcb->unsent);
  126de4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126de8:	e283306c 	add	r3, r3, #108	; 0x6c
  126dec:	e50b3010 	str	r3, [fp, #-16]
  while (*cur_seg &&
  126df0:	ea000002 	b	126e00 <tcp_rexmit+0x58>
    TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  126df4:	e51b3010 	ldr	r3, [fp, #-16]
  126df8:	e5933000 	ldr	r3, [r3]
  126dfc:	e50b3010 	str	r3, [fp, #-16]
  while (*cur_seg &&
  126e00:	e51b3010 	ldr	r3, [fp, #-16]
  126e04:	e5933000 	ldr	r3, [r3]
  126e08:	e3530000 	cmp	r3, #0
  126e0c:	0a00000f 	beq	126e50 <tcp_rexmit+0xa8>
    TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
  126e10:	e51b3010 	ldr	r3, [fp, #-16]
  126e14:	e5933000 	ldr	r3, [r3]
  126e18:	e593300c 	ldr	r3, [r3, #12]
  126e1c:	e5933004 	ldr	r3, [r3, #4]
  126e20:	e1a00003 	mov	r0, r3
  126e24:	ebffbe77 	bl	116808 <lwip_htonl>
  126e28:	e1a04000 	mov	r4, r0
  126e2c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126e30:	e593300c 	ldr	r3, [r3, #12]
  126e34:	e5933004 	ldr	r3, [r3, #4]
  126e38:	e1a00003 	mov	r0, r3
  126e3c:	ebffbe71 	bl	116808 <lwip_htonl>
  126e40:	e1a03000 	mov	r3, r0
  126e44:	e0443003 	sub	r3, r4, r3
  while (*cur_seg &&
  126e48:	e3530000 	cmp	r3, #0
  126e4c:	baffffe8 	blt	126df4 <tcp_rexmit+0x4c>
  }
  seg->next = *cur_seg;
  126e50:	e51b3010 	ldr	r3, [fp, #-16]
  126e54:	e5932000 	ldr	r2, [r3]
  126e58:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126e5c:	e5832000 	str	r2, [r3]
  *cur_seg = seg;
  126e60:	e51b3010 	ldr	r3, [fp, #-16]
  126e64:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  126e68:	e5832000 	str	r2, [r3]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
  126e6c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  126e70:	e5933000 	ldr	r3, [r3]
  126e74:	e3530000 	cmp	r3, #0
  126e78:	1a000002 	bne	126e88 <tcp_rexmit+0xe0>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  126e7c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126e80:	e3a02000 	mov	r2, #0
  126e84:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
  126e88:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126e8c:	e5d33046 	ldrb	r3, [r3, #70]	; 0x46
  126e90:	e35300ff 	cmp	r3, #255	; 0xff
  126e94:	0a000005 	beq	126eb0 <tcp_rexmit+0x108>
    ++pcb->nrtx;
  126e98:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126e9c:	e5d33046 	ldrb	r3, [r3, #70]	; 0x46
  126ea0:	e2833001 	add	r3, r3, #1
  126ea4:	e6ef2073 	uxtb	r2, r3
  126ea8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126eac:	e5c32046 	strb	r2, [r3, #70]	; 0x46
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  126eb0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  126eb4:	e3a02000 	mov	r2, #0
  126eb8:	e5832038 	str	r2, [r3, #56]	; 0x38

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  126ebc:	e3063840 	movw	r3, #26688	; 0x6840
  126ec0:	e3403057 	movt	r3, #87	; 0x57
  126ec4:	e5933180 	ldr	r3, [r3, #384]	; 0x180
  126ec8:	e2832001 	add	r2, r3, #1
  126ecc:	e3063840 	movw	r3, #26688	; 0x6840
  126ed0:	e3403057 	movt	r3, #87	; 0x57
  126ed4:	e5832180 	str	r2, [r3, #384]	; 0x180
  126ed8:	ea000000 	b	126ee0 <tcp_rexmit+0x138>
    return;
  126edc:	e320f000 	nop	{0}
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
  126ee0:	e24bd008 	sub	sp, fp, #8
  126ee4:	e8bd8810 	pop	{r4, fp, pc}

00126ee8 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  126ee8:	e92d4800 	push	{fp, lr}
  126eec:	e28db004 	add	fp, sp, #4
  126ef0:	e24dd008 	sub	sp, sp, #8
  126ef4:	e50b0008 	str	r0, [fp, #-8]
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
  126ef8:	e51b3008 	ldr	r3, [fp, #-8]
  126efc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  126f00:	e3530000 	cmp	r3, #0
  126f04:	0a00003e 	beq	127004 <tcp_rexmit_fast+0x11c>
  126f08:	e51b3008 	ldr	r3, [fp, #-8]
  126f0c:	e5d3301e 	ldrb	r3, [r3, #30]
  126f10:	e2033004 	and	r3, r3, #4
  126f14:	e3530000 	cmp	r3, #0
  126f18:	1a000039 	bne	127004 <tcp_rexmit_fast+0x11c>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
  126f1c:	e51b0008 	ldr	r0, [fp, #-8]
  126f20:	ebffffa0 	bl	126da8 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
  126f24:	e51b3008 	ldr	r3, [fp, #-8]
  126f28:	e1d324bc 	ldrh	r2, [r3, #76]	; 0x4c
  126f2c:	e51b3008 	ldr	r3, [fp, #-8]
  126f30:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  126f34:	e1520003 	cmp	r2, r3
  126f38:	2a000006 	bcs	126f58 <tcp_rexmit_fast+0x70>
  126f3c:	e51b3008 	ldr	r3, [fp, #-8]
  126f40:	e1d334bc 	ldrh	r3, [r3, #76]	; 0x4c
  126f44:	e1a02fa3 	lsr	r2, r3, #31
  126f48:	e0823003 	add	r3, r2, r3
  126f4c:	e1a030c3 	asr	r3, r3, #1
  126f50:	e6ff3073 	uxth	r3, r3
  126f54:	ea000005 	b	126f70 <tcp_rexmit_fast+0x88>
  126f58:	e51b3008 	ldr	r3, [fp, #-8]
  126f5c:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  126f60:	e1a02fa3 	lsr	r2, r3, #31
  126f64:	e0823003 	add	r3, r2, r3
  126f68:	e1a030c3 	asr	r3, r3, #1
  126f6c:	e6ff3073 	uxth	r3, r3
  126f70:	e51b2008 	ldr	r2, [fp, #-8]
  126f74:	e1c234be 	strh	r3, [r2, #78]	; 0x4e

    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < (2U * pcb->mss)) {
  126f78:	e51b3008 	ldr	r3, [fp, #-8]
  126f7c:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
  126f80:	e1a02003 	mov	r2, r3
  126f84:	e51b3008 	ldr	r3, [fp, #-8]
  126f88:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  126f8c:	e1a03083 	lsl	r3, r3, #1
  126f90:	e1520003 	cmp	r2, r3
  126f94:	2a000005 	bcs	126fb0 <tcp_rexmit_fast+0xc8>
      LWIP_DEBUGF(TCP_FR_DEBUG,
                  ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, (u16_t)(2*pcb->mss)));
      pcb->ssthresh = 2*pcb->mss;
  126f98:	e51b3008 	ldr	r3, [fp, #-8]
  126f9c:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  126fa0:	e1a03083 	lsl	r3, r3, #1
  126fa4:	e6ff2073 	uxth	r2, r3
  126fa8:	e51b3008 	ldr	r3, [fp, #-8]
  126fac:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
    }

    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  126fb0:	e51b3008 	ldr	r3, [fp, #-8]
  126fb4:	e1d324be 	ldrh	r2, [r3, #78]	; 0x4e
  126fb8:	e51b3008 	ldr	r3, [fp, #-8]
  126fbc:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  126fc0:	e1a01003 	mov	r1, r3
  126fc4:	e1a01081 	lsl	r1, r1, #1
  126fc8:	e0813003 	add	r3, r1, r3
  126fcc:	e6ff3073 	uxth	r3, r3
  126fd0:	e0823003 	add	r3, r2, r3
  126fd4:	e6ff2073 	uxth	r2, r3
  126fd8:	e51b3008 	ldr	r3, [fp, #-8]
  126fdc:	e1c324bc 	strh	r2, [r3, #76]	; 0x4c
    pcb->flags |= TF_INFR;
  126fe0:	e51b3008 	ldr	r3, [fp, #-8]
  126fe4:	e5d3301e 	ldrb	r3, [r3, #30]
  126fe8:	e3833004 	orr	r3, r3, #4
  126fec:	e6ef2073 	uxtb	r2, r3
  126ff0:	e51b3008 	ldr	r3, [fp, #-8]
  126ff4:	e5c3201e 	strb	r2, [r3, #30]

    /* Reset the retransmission timer to prevent immediate rto retransmissions */
    pcb->rtime = 0;
  126ff8:	e51b3008 	ldr	r3, [fp, #-8]
  126ffc:	e3a02000 	mov	r2, #0
  127000:	e1c323b4 	strh	r2, [r3, #52]	; 0x34
  }
}
  127004:	e320f000 	nop	{0}
  127008:	e24bd004 	sub	sp, fp, #4
  12700c:	e8bd8800 	pop	{fp, pc}

00127010 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
  127010:	e92d4800 	push	{fp, lr}
  127014:	e28db004 	add	fp, sp, #4
  127018:	e24dd028 	sub	sp, sp, #40	; 0x28
  12701c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, 0, 0, lwip_htonl(pcb->snd_nxt - 1));
  127020:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  127024:	e5933050 	ldr	r3, [r3, #80]	; 0x50
  127028:	e2433001 	sub	r3, r3, #1
  12702c:	e1a00003 	mov	r0, r3
  127030:	ebffbdf4 	bl	116808 <lwip_htonl>
  127034:	e1a03000 	mov	r3, r0
  127038:	e3a02000 	mov	r2, #0
  12703c:	e3a01000 	mov	r1, #0
  127040:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  127044:	ebfff62b 	bl	1248f8 <tcp_output_alloc_header>
  127048:	e50b000c 	str	r0, [fp, #-12]
  if (p == NULL) {
  12704c:	e51b300c 	ldr	r3, [fp, #-12]
  127050:	e3530000 	cmp	r3, #0
  127054:	1a000001 	bne	127060 <tcp_keepalive+0x50>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
  127058:	e3e03000 	mvn	r3, #0
  12705c:	ea000036 	b	12713c <tcp_keepalive+0x12c>
  }
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
  127060:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  127064:	e2833004 	add	r3, r3, #4
  127068:	e1a00003 	mov	r0, r3
  12706c:	eb0028c7 	bl	131390 <ip4_route>
  127070:	e50b0010 	str	r0, [fp, #-16]
  if (netif == NULL) {
  127074:	e51b3010 	ldr	r3, [fp, #-16]
  127078:	e3530000 	cmp	r3, #0
  12707c:	1a000002 	bne	12708c <tcp_keepalive+0x7c>
    err = ERR_RTE;
  127080:	e3e03003 	mvn	r3, #3
  127084:	e54b3005 	strb	r3, [fp, #-5]
  127088:	ea000028 	b	127130 <tcp_keepalive+0x120>
  } else {
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
  12708c:	e51b300c 	ldr	r3, [fp, #-12]
  127090:	e5933004 	ldr	r3, [r3, #4]
  127094:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
  127098:	e51b300c 	ldr	r3, [fp, #-12]
  12709c:	e1d320b8 	ldrh	r2, [r3, #8]
        &pcb->local_ip, &pcb->remote_ip);
  1270a0:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  1270a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1270a8:	e2833004 	add	r3, r3, #4
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
  1270ac:	e58d3000 	str	r3, [sp]
  1270b0:	e1a03001 	mov	r3, r1
  1270b4:	e3a01006 	mov	r1, #6
  1270b8:	e51b000c 	ldr	r0, [fp, #-12]
  1270bc:	ebffc5e4 	bl	118854 <ip_chksum_pseudo>
  1270c0:	e1a03000 	mov	r3, r0
  1270c4:	e1a02003 	mov	r2, r3
  1270c8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1270cc:	e1c321b0 	strh	r2, [r3, #16]
    }
#endif /* CHECKSUM_GEN_TCP */
    TCP_STATS_INC(tcp.xmit);
  1270d0:	e3063840 	movw	r3, #26688	; 0x6840
  1270d4:	e3403057 	movt	r3, #87	; 0x57
  1270d8:	e1d33abc 	ldrh	r3, [r3, #172]	; 0xac
  1270dc:	e2833001 	add	r3, r3, #1
  1270e0:	e6ff2073 	uxth	r2, r3
  1270e4:	e3063840 	movw	r3, #26688	; 0x6840
  1270e8:	e3403057 	movt	r3, #87	; 0x57
  1270ec:	e1c32abc 	strh	r2, [r3, #172]	; 0xac

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, netif);
  1270f0:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  1270f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1270f8:	e2832004 	add	r2, r3, #4
  1270fc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  127100:	e5d3000a 	ldrb	r0, [r3, #10]
  127104:	e51b3010 	ldr	r3, [fp, #-16]
  127108:	e58d3008 	str	r3, [sp, #8]
  12710c:	e3a03006 	mov	r3, #6
  127110:	e58d3004 	str	r3, [sp, #4]
  127114:	e3a03000 	mov	r3, #0
  127118:	e58d3000 	str	r3, [sp]
  12711c:	e1a03000 	mov	r3, r0
  127120:	e51b000c 	ldr	r0, [fp, #-12]
  127124:	eb002b72 	bl	131ef4 <ip4_output_if>
  127128:	e1a03000 	mov	r3, r0
  12712c:	e54b3005 	strb	r3, [fp, #-5]
    NETIF_SET_HWADDRHINT(netif, NULL);
  }
  pbuf_free(p);
  127130:	e51b000c 	ldr	r0, [fp, #-12]
  127134:	ebffcfde 	bl	11b0b4 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
  127138:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  12713c:	e1a00003 	mov	r0, r3
  127140:	e24bd004 	sub	sp, fp, #4
  127144:	e8bd8800 	pop	{fp, pc}

00127148 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  127148:	e92d4810 	push	{r4, fp, lr}
  12714c:	e28db008 	add	fp, sp, #8
  127150:	e24dd03c 	sub	sp, sp, #60	; 0x3c
  127154:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  LWIP_DEBUGF(TCP_DEBUG,
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  seg = pcb->unacked;
  127158:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12715c:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  127160:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

  if (seg == NULL) {
  127164:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127168:	e3530000 	cmp	r3, #0
  12716c:	1a000002 	bne	12717c <tcp_zero_window_probe+0x34>
    seg = pcb->unsent;
  127170:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  127174:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
  127178:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  }
  if (seg == NULL) {
  12717c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127180:	e3530000 	cmp	r3, #0
  127184:	1a000001 	bne	127190 <tcp_zero_window_probe+0x48>
    /* nothing to send, zero window probe not needed */
    return ERR_OK;
  127188:	e3a03000 	mov	r3, #0
  12718c:	ea00008c 	b	1273c4 <tcp_zero_window_probe+0x27c>
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
  127190:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127194:	e593300c 	ldr	r3, [r3, #12]
  127198:	e1d330bc 	ldrh	r3, [r3, #12]
  12719c:	e6ff3073 	uxth	r3, r3
  1271a0:	e1a00003 	mov	r0, r3
  1271a4:	ebffbd8b 	bl	1167d8 <lwip_htons>
  1271a8:	e1a03000 	mov	r3, r0
  1271ac:	e2033001 	and	r3, r3, #1
  1271b0:	e3530000 	cmp	r3, #0
  1271b4:	0a000005 	beq	1271d0 <tcp_zero_window_probe+0x88>
  1271b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1271bc:	e1d330b8 	ldrh	r3, [r3, #8]
  1271c0:	e3530000 	cmp	r3, #0
  1271c4:	1a000001 	bne	1271d0 <tcp_zero_window_probe+0x88>
  1271c8:	e3a03001 	mov	r3, #1
  1271cc:	ea000000 	b	1271d4 <tcp_zero_window_probe+0x8c>
  1271d0:	e3a03000 	mov	r3, #0
  1271d4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
  1271d8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  1271dc:	e3530000 	cmp	r3, #0
  1271e0:	03a03001 	moveq	r3, #1
  1271e4:	13a03000 	movne	r3, #0
  1271e8:	e6ef3073 	uxtb	r3, r3
  1271ec:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  1271f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1271f4:	e593300c 	ldr	r3, [r3, #12]
  1271f8:	e5933004 	ldr	r3, [r3, #4]
  1271fc:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
  127200:	e3a01000 	mov	r1, #0
  127204:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  127208:	ebfff5ba 	bl	1248f8 <tcp_output_alloc_header>
  12720c:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
  if (p == NULL) {
  127210:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  127214:	e3530000 	cmp	r3, #0
  127218:	1a000001 	bne	127224 <tcp_zero_window_probe+0xdc>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
  12721c:	e3e03000 	mvn	r3, #0
  127220:	ea000067 	b	1273c4 <tcp_zero_window_probe+0x27c>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  127224:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  127228:	e5933004 	ldr	r3, [r3, #4]
  12722c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

  if (is_fin) {
  127230:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  127234:	e3530000 	cmp	r3, #0
  127238:	0a00000c 	beq	127270 <tcp_zero_window_probe+0x128>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
  12723c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  127240:	e1d330bc 	ldrh	r3, [r3, #12]
  127244:	e6ff3073 	uxth	r3, r3
  127248:	e3c33c3f 	bic	r3, r3, #16128	; 0x3f00
  12724c:	e6ff4073 	uxth	r4, r3
  127250:	e3a00011 	mov	r0, #17
  127254:	ebffbd5f 	bl	1167d8 <lwip_htons>
  127258:	e1a03000 	mov	r3, r0
  12725c:	e1843003 	orr	r3, r4, r3
  127260:	e6ff2073 	uxth	r2, r3
  127264:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  127268:	e1c320bc 	strh	r2, [r3, #12]
  12726c:	ea00000f 	b	1272b0 <tcp_zero_window_probe+0x168>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
  127270:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  127274:	e5933004 	ldr	r3, [r3, #4]
  127278:	e2833014 	add	r3, r3, #20
  12727c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  127280:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127284:	e5930004 	ldr	r0, [r3, #4]
  127288:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12728c:	e5933004 	ldr	r3, [r3, #4]
  127290:	e1d320b8 	ldrh	r2, [r3, #8]
  127294:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127298:	e1d330b8 	ldrh	r3, [r3, #8]
  12729c:	e0423003 	sub	r3, r2, r3
  1272a0:	e6ff3073 	uxth	r3, r3
  1272a4:	e3a02001 	mov	r2, #1
  1272a8:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  1272ac:	ebffd18b 	bl	11b8e0 <pbuf_copy_partial>
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
  1272b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1272b4:	e593300c 	ldr	r3, [r3, #12]
  1272b8:	e5933004 	ldr	r3, [r3, #4]
  1272bc:	e1a00003 	mov	r0, r3
  1272c0:	ebffbd50 	bl	116808 <lwip_htonl>
  1272c4:	e1a03000 	mov	r3, r0
  1272c8:	e2833001 	add	r3, r3, #1
  1272cc:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
  1272d0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1272d4:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  1272d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1272dc:	e0423003 	sub	r3, r2, r3
  1272e0:	e3530000 	cmp	r3, #0
  1272e4:	aa000002 	bge	1272f4 <tcp_zero_window_probe+0x1ac>
    pcb->snd_nxt = snd_nxt;
  1272e8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1272ec:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  1272f0:	e5832050 	str	r2, [r3, #80]	; 0x50
  }

  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
  1272f4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1272f8:	e2833004 	add	r3, r3, #4
  1272fc:	e1a00003 	mov	r0, r3
  127300:	eb002822 	bl	131390 <ip4_route>
  127304:	e50b002c 	str	r0, [fp, #-44]	; 0xffffffd4
  if (netif == NULL) {
  127308:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  12730c:	e3530000 	cmp	r3, #0
  127310:	1a000002 	bne	127320 <tcp_zero_window_probe+0x1d8>
    err = ERR_RTE;
  127314:	e3e03003 	mvn	r3, #3
  127318:	e54b300d 	strb	r3, [fp, #-13]
  12731c:	ea000025 	b	1273b8 <tcp_zero_window_probe+0x270>
  } else {
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
  127320:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  127324:	e1d320b8 	ldrh	r2, [r3, #8]
        &pcb->local_ip, &pcb->remote_ip);
  127328:	e51b1030 	ldr	r1, [fp, #-48]	; 0xffffffd0
  12732c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  127330:	e2833004 	add	r3, r3, #4
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
  127334:	e58d3000 	str	r3, [sp]
  127338:	e1a03001 	mov	r3, r1
  12733c:	e3a01006 	mov	r1, #6
  127340:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  127344:	ebffc542 	bl	118854 <ip_chksum_pseudo>
  127348:	e1a03000 	mov	r3, r0
  12734c:	e1a02003 	mov	r2, r3
  127350:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  127354:	e1c321b0 	strh	r2, [r3, #16]
    }
#endif
    TCP_STATS_INC(tcp.xmit);
  127358:	e3063840 	movw	r3, #26688	; 0x6840
  12735c:	e3403057 	movt	r3, #87	; 0x57
  127360:	e1d33abc 	ldrh	r3, [r3, #172]	; 0xac
  127364:	e2833001 	add	r3, r3, #1
  127368:	e6ff2073 	uxth	r2, r3
  12736c:	e3063840 	movw	r3, #26688	; 0x6840
  127370:	e3403057 	movt	r3, #87	; 0x57
  127374:	e1c32abc 	strh	r2, [r3, #172]	; 0xac

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
  127378:	e51b1030 	ldr	r1, [fp, #-48]	; 0xffffffd0
  12737c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  127380:	e2832004 	add	r2, r3, #4
  127384:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  127388:	e5d3000a 	ldrb	r0, [r3, #10]
  12738c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  127390:	e58d3008 	str	r3, [sp, #8]
  127394:	e3a03006 	mov	r3, #6
  127398:	e58d3004 	str	r3, [sp, #4]
  12739c:	e3a03000 	mov	r3, #0
  1273a0:	e58d3000 	str	r3, [sp]
  1273a4:	e1a03000 	mov	r3, r0
  1273a8:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  1273ac:	eb002ad0 	bl	131ef4 <ip4_output_if>
  1273b0:	e1a03000 	mov	r3, r0
  1273b4:	e54b300d 	strb	r3, [fp, #-13]
      0, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }

  pbuf_free(p);
  1273b8:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  1273bc:	ebffcf3c 	bl	11b0b4 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
  1273c0:	e15b30dd 	ldrsb	r3, [fp, #-13]
}
  1273c4:	e1a00003 	mov	r0, r3
  1273c8:	e24bd008 	sub	sp, fp, #8
  1273cc:	e8bd8810 	pop	{r4, fp, pc}

001273d0 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  1273d0:	e92d4800 	push	{fp, lr}
  1273d4:	e28db004 	add	fp, sp, #4
  1273d8:	e24dd008 	sub	sp, sp, #8
  1273dc:	e50b0008 	str	r0, [fp, #-8]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  1273e0:	ebffd77b 	bl	11d1d4 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  1273e4:	e3063a30 	movw	r3, #27184	; 0x6a30
  1273e8:	e3403057 	movt	r3, #87	; 0x57
  1273ec:	e5933000 	ldr	r3, [r3]
  1273f0:	e3530000 	cmp	r3, #0
  1273f4:	1a000004 	bne	12740c <tcpip_tcp_timer+0x3c>
  1273f8:	e3063a40 	movw	r3, #27200	; 0x6a40
  1273fc:	e3403057 	movt	r3, #87	; 0x57
  127400:	e5933000 	ldr	r3, [r3]
  127404:	e3530000 	cmp	r3, #0
  127408:	0a000005 	beq	127424 <tcpip_tcp_timer+0x54>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  12740c:	e3a02000 	mov	r2, #0
  127410:	e30713d0 	movw	r1, #29648	; 0x73d0
  127414:	e3401012 	movt	r1, #18
  127418:	e3a000fa 	mov	r0, #250	; 0xfa
  12741c:	eb000057 	bl	127580 <sys_timeout>
  127420:	ea000003 	b	127434 <tcpip_tcp_timer+0x64>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  127424:	e30f325c 	movw	r3, #62044	; 0xf25c
  127428:	e3403014 	movt	r3, #20
  12742c:	e3a02000 	mov	r2, #0
  127430:	e5832000 	str	r2, [r3]
  }
}
  127434:	e320f000 	nop	{0}
  127438:	e24bd004 	sub	sp, fp, #4
  12743c:	e8bd8800 	pop	{fp, pc}

00127440 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  127440:	e92d4800 	push	{fp, lr}
  127444:	e28db004 	add	fp, sp, #4
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  127448:	e30f325c 	movw	r3, #62044	; 0xf25c
  12744c:	e3403014 	movt	r3, #20
  127450:	e5933000 	ldr	r3, [r3]
  127454:	e3530000 	cmp	r3, #0
  127458:	1a000012 	bne	1274a8 <tcp_timer_needed+0x68>
  12745c:	e3063a30 	movw	r3, #27184	; 0x6a30
  127460:	e3403057 	movt	r3, #87	; 0x57
  127464:	e5933000 	ldr	r3, [r3]
  127468:	e3530000 	cmp	r3, #0
  12746c:	1a000004 	bne	127484 <tcp_timer_needed+0x44>
  127470:	e3063a40 	movw	r3, #27200	; 0x6a40
  127474:	e3403057 	movt	r3, #87	; 0x57
  127478:	e5933000 	ldr	r3, [r3]
  12747c:	e3530000 	cmp	r3, #0
  127480:	0a000008 	beq	1274a8 <tcp_timer_needed+0x68>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  127484:	e30f325c 	movw	r3, #62044	; 0xf25c
  127488:	e3403014 	movt	r3, #20
  12748c:	e3a02001 	mov	r2, #1
  127490:	e5832000 	str	r2, [r3]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  127494:	e3a02000 	mov	r2, #0
  127498:	e30713d0 	movw	r1, #29648	; 0x73d0
  12749c:	e3401012 	movt	r1, #18
  1274a0:	e3a000fa 	mov	r0, #250	; 0xfa
  1274a4:	eb000035 	bl	127580 <sys_timeout>
  }
}
  1274a8:	e320f000 	nop	{0}
  1274ac:	e8bd8800 	pop	{fp, pc}

001274b0 <cyclic_timer>:
 *
 * @param arg unused argument
 */
static void
cyclic_timer(void *arg)
{
  1274b0:	e92d4800 	push	{fp, lr}
  1274b4:	e28db004 	add	fp, sp, #4
  1274b8:	e24dd010 	sub	sp, sp, #16
  1274bc:	e50b0010 	str	r0, [fp, #-16]
  const struct lwip_cyclic_timer* cyclic = (const struct lwip_cyclic_timer*)arg;
  1274c0:	e51b3010 	ldr	r3, [fp, #-16]
  1274c4:	e50b3008 	str	r3, [fp, #-8]
#if LWIP_DEBUG_TIMERNAMES
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
#endif
  cyclic->handler();
  1274c8:	e51b3008 	ldr	r3, [fp, #-8]
  1274cc:	e5933004 	ldr	r3, [r3, #4]
  1274d0:	e12fff33 	blx	r3
  sys_timeout(cyclic->interval_ms, cyclic_timer, arg);
  1274d4:	e51b3008 	ldr	r3, [fp, #-8]
  1274d8:	e5933000 	ldr	r3, [r3]
  1274dc:	e51b2010 	ldr	r2, [fp, #-16]
  1274e0:	e30714b0 	movw	r1, #29872	; 0x74b0
  1274e4:	e3401012 	movt	r1, #18
  1274e8:	e1a00003 	mov	r0, r3
  1274ec:	eb000023 	bl	127580 <sys_timeout>
}
  1274f0:	e320f000 	nop	{0}
  1274f4:	e24bd004 	sub	sp, fp, #4
  1274f8:	e8bd8800 	pop	{fp, pc}

001274fc <sys_timeouts_init>:

/** Initialize this module */
void sys_timeouts_init(void)
{
  1274fc:	e92d4800 	push	{fp, lr}
  127500:	e28db004 	add	fp, sp, #4
  127504:	e24dd008 	sub	sp, sp, #8
  size_t i;
  /* tcp_tmr() at index 0 is started on demand */
  for (i = 1; i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
  127508:	e3a03001 	mov	r3, #1
  12750c:	e50b3008 	str	r3, [fp, #-8]
  127510:	ea00000f 	b	127554 <sys_timeouts_init+0x58>
    /* we have to cast via size_t to get rid of const warning
      (this is OK as cyclic_timer() casts back to const* */
    sys_timeout(lwip_cyclic_timers[i].interval_ms, cyclic_timer, LWIP_CONST_CAST(void*, &lwip_cyclic_timers[i]));
  127514:	e3083c34 	movw	r3, #35892	; 0x8c34
  127518:	e3403014 	movt	r3, #20
  12751c:	e51b2008 	ldr	r2, [fp, #-8]
  127520:	e7930182 	ldr	r0, [r3, r2, lsl #3]
  127524:	e51b3008 	ldr	r3, [fp, #-8]
  127528:	e1a02183 	lsl	r2, r3, #3
  12752c:	e3083c34 	movw	r3, #35892	; 0x8c34
  127530:	e3403014 	movt	r3, #20
  127534:	e0823003 	add	r3, r2, r3
  127538:	e1a02003 	mov	r2, r3
  12753c:	e30714b0 	movw	r1, #29872	; 0x74b0
  127540:	e3401012 	movt	r1, #18
  127544:	eb00000d 	bl	127580 <sys_timeout>
  for (i = 1; i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
  127548:	e51b3008 	ldr	r3, [fp, #-8]
  12754c:	e2833001 	add	r3, r3, #1
  127550:	e50b3008 	str	r3, [fp, #-8]
  127554:	e51b3008 	ldr	r3, [fp, #-8]
  127558:	e3530006 	cmp	r3, #6
  12755c:	9affffec 	bls	127514 <sys_timeouts_init+0x18>
  }

  /* Initialise timestamp for sys_check_timeouts */
  timeouts_last_time = sys_now();
  127560:	ebff8ede 	bl	10b0e0 <sys_now>
  127564:	e1a02000 	mov	r2, r0
  127568:	e30f3258 	movw	r3, #62040	; 0xf258
  12756c:	e3403014 	movt	r3, #20
  127570:	e5832000 	str	r2, [r3]
}
  127574:	e320f000 	nop	{0}
  127578:	e24bd004 	sub	sp, fp, #4
  12757c:	e8bd8800 	pop	{fp, pc}

00127580 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
  127580:	e92d4800 	push	{fp, lr}
  127584:	e28db004 	add	fp, sp, #4
  127588:	e24dd020 	sub	sp, sp, #32
  12758c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  127590:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  127594:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  struct sys_timeo *timeout, *t;
  u32_t now, diff;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  127598:	e3a020d2 	mov	r2, #210	; 0xd2
  12759c:	e3081c6c 	movw	r1, #35948	; 0x8c6c
  1275a0:	e3401014 	movt	r1, #20
  1275a4:	e3a0000d 	mov	r0, #13
  1275a8:	ebffc74b 	bl	1192dc <memp_malloc_fn>
  1275ac:	e50b0010 	str	r0, [fp, #-16]
  if (timeout == NULL) {
  1275b0:	e51b3010 	ldr	r3, [fp, #-16]
  1275b4:	e3530000 	cmp	r3, #0
  1275b8:	1a00000a 	bne	1275e8 <sys_timeout+0x68>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
  1275bc:	e51b3010 	ldr	r3, [fp, #-16]
  1275c0:	e3530000 	cmp	r3, #0
  1275c4:	1a00008f 	bne	127808 <sys_timeout+0x288>
  1275c8:	e3080c9c 	movw	r0, #35996	; 0x8c9c
  1275cc:	e3400014 	movt	r0, #20
  1275d0:	ebff6ecf 	bl	103114 <rt_kprintf>
  1275d4:	e3a010d4 	mov	r1, #212	; 0xd4
  1275d8:	e3080c6c 	movw	r0, #35948	; 0x8c6c
  1275dc:	e3400014 	movt	r0, #20
  1275e0:	ebff8ea5 	bl	10b07c <sys_arch_assert>
    return;
  1275e4:	ea000087 	b	127808 <sys_timeout+0x288>
  }

  now = sys_now();
  1275e8:	ebff8ebc 	bl	10b0e0 <sys_now>
  1275ec:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  if (next_timeout == NULL) {
  1275f0:	e30f3254 	movw	r3, #62036	; 0xf254
  1275f4:	e3403014 	movt	r3, #20
  1275f8:	e5933000 	ldr	r3, [r3]
  1275fc:	e3530000 	cmp	r3, #0
  127600:	1a000006 	bne	127620 <sys_timeout+0xa0>
    diff = 0;
  127604:	e3a03000 	mov	r3, #0
  127608:	e50b300c 	str	r3, [fp, #-12]
    timeouts_last_time = now;
  12760c:	e30f3258 	movw	r3, #62040	; 0xf258
  127610:	e3403014 	movt	r3, #20
  127614:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  127618:	e5832000 	str	r2, [r3]
  12761c:	ea000005 	b	127638 <sys_timeout+0xb8>
  } else {
    diff = now - timeouts_last_time;
  127620:	e30f3258 	movw	r3, #62040	; 0xf258
  127624:	e3403014 	movt	r3, #20
  127628:	e5933000 	ldr	r3, [r3]
  12762c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  127630:	e0423003 	sub	r3, r2, r3
  127634:	e50b300c 	str	r3, [fp, #-12]
  }

  timeout->next = NULL;
  127638:	e51b3010 	ldr	r3, [fp, #-16]
  12763c:	e3a02000 	mov	r2, #0
  127640:	e5832000 	str	r2, [r3]
  timeout->h = handler;
  127644:	e51b3010 	ldr	r3, [fp, #-16]
  127648:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  12764c:	e5832008 	str	r2, [r3, #8]
  timeout->arg = arg;
  127650:	e51b3010 	ldr	r3, [fp, #-16]
  127654:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  127658:	e583200c 	str	r2, [r3, #12]
  timeout->time = msecs + diff;
  12765c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  127660:	e51b300c 	ldr	r3, [fp, #-12]
  127664:	e0822003 	add	r2, r2, r3
  127668:	e51b3010 	ldr	r3, [fp, #-16]
  12766c:	e5832004 	str	r2, [r3, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
  127670:	e30f3254 	movw	r3, #62036	; 0xf254
  127674:	e3403014 	movt	r3, #20
  127678:	e5933000 	ldr	r3, [r3]
  12767c:	e3530000 	cmp	r3, #0
  127680:	1a000004 	bne	127698 <sys_timeout+0x118>
    next_timeout = timeout;
  127684:	e30f3254 	movw	r3, #62036	; 0xf254
  127688:	e3403014 	movt	r3, #20
  12768c:	e51b2010 	ldr	r2, [fp, #-16]
  127690:	e5832000 	str	r2, [r3]
    return;
  127694:	ea00005c 	b	12780c <sys_timeout+0x28c>
  }

  if (next_timeout->time > msecs) {
  127698:	e30f3254 	movw	r3, #62036	; 0xf254
  12769c:	e3403014 	movt	r3, #20
  1276a0:	e5933000 	ldr	r3, [r3]
  1276a4:	e5933004 	ldr	r3, [r3, #4]
  1276a8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1276ac:	e1520003 	cmp	r2, r3
  1276b0:	2a000013 	bcs	127704 <sys_timeout+0x184>
    next_timeout->time -= msecs;
  1276b4:	e30f3254 	movw	r3, #62036	; 0xf254
  1276b8:	e3403014 	movt	r3, #20
  1276bc:	e5933000 	ldr	r3, [r3]
  1276c0:	e5931004 	ldr	r1, [r3, #4]
  1276c4:	e30f3254 	movw	r3, #62036	; 0xf254
  1276c8:	e3403014 	movt	r3, #20
  1276cc:	e5933000 	ldr	r3, [r3]
  1276d0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1276d4:	e0412002 	sub	r2, r1, r2
  1276d8:	e5832004 	str	r2, [r3, #4]
    timeout->next = next_timeout;
  1276dc:	e30f3254 	movw	r3, #62036	; 0xf254
  1276e0:	e3403014 	movt	r3, #20
  1276e4:	e5932000 	ldr	r2, [r3]
  1276e8:	e51b3010 	ldr	r3, [fp, #-16]
  1276ec:	e5832000 	str	r2, [r3]
    next_timeout = timeout;
  1276f0:	e30f3254 	movw	r3, #62036	; 0xf254
  1276f4:	e3403014 	movt	r3, #20
  1276f8:	e51b2010 	ldr	r2, [fp, #-16]
  1276fc:	e5832000 	str	r2, [r3]
  127700:	ea000041 	b	12780c <sys_timeout+0x28c>
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
  127704:	e30f3254 	movw	r3, #62036	; 0xf254
  127708:	e3403014 	movt	r3, #20
  12770c:	e5933000 	ldr	r3, [r3]
  127710:	e50b3008 	str	r3, [fp, #-8]
  127714:	ea000037 	b	1277f8 <sys_timeout+0x278>
      timeout->time -= t->time;
  127718:	e51b3010 	ldr	r3, [fp, #-16]
  12771c:	e5932004 	ldr	r2, [r3, #4]
  127720:	e51b3008 	ldr	r3, [fp, #-8]
  127724:	e5933004 	ldr	r3, [r3, #4]
  127728:	e0422003 	sub	r2, r2, r3
  12772c:	e51b3010 	ldr	r3, [fp, #-16]
  127730:	e5832004 	str	r2, [r3, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
  127734:	e51b3008 	ldr	r3, [fp, #-8]
  127738:	e5933000 	ldr	r3, [r3]
  12773c:	e3530000 	cmp	r3, #0
  127740:	0a000006 	beq	127760 <sys_timeout+0x1e0>
  127744:	e51b3008 	ldr	r3, [fp, #-8]
  127748:	e5933000 	ldr	r3, [r3]
  12774c:	e5932004 	ldr	r2, [r3, #4]
  127750:	e51b3010 	ldr	r3, [fp, #-16]
  127754:	e5933004 	ldr	r3, [r3, #4]
  127758:	e1520003 	cmp	r2, r3
  12775c:	9a000022 	bls	1277ec <sys_timeout+0x26c>
        if (t->next != NULL) {
  127760:	e51b3008 	ldr	r3, [fp, #-8]
  127764:	e5933000 	ldr	r3, [r3]
  127768:	e3530000 	cmp	r3, #0
  12776c:	0a000009 	beq	127798 <sys_timeout+0x218>
          t->next->time -= timeout->time;
  127770:	e51b3008 	ldr	r3, [fp, #-8]
  127774:	e5933000 	ldr	r3, [r3]
  127778:	e5931004 	ldr	r1, [r3, #4]
  12777c:	e51b3010 	ldr	r3, [fp, #-16]
  127780:	e5932004 	ldr	r2, [r3, #4]
  127784:	e51b3008 	ldr	r3, [fp, #-8]
  127788:	e5933000 	ldr	r3, [r3]
  12778c:	e0412002 	sub	r2, r1, r2
  127790:	e5832004 	str	r2, [r3, #4]
  127794:	ea00000c 	b	1277cc <sys_timeout+0x24c>
        } else if (timeout->time > msecs) {
  127798:	e51b3010 	ldr	r3, [fp, #-16]
  12779c:	e5933004 	ldr	r3, [r3, #4]
  1277a0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1277a4:	e1520003 	cmp	r2, r3
  1277a8:	2a000007 	bcs	1277cc <sys_timeout+0x24c>
          /* If this is the case, 'timeouts_last_time' and 'now' differs too much.
             This can be due to sys_check_timeouts() not being called at the right
             times, but also when stopping in a breakpoint. Anyway, let's assume
             this is not wanted, so add the first timer's time instead of 'diff' */
          timeout->time = msecs + next_timeout->time;
  1277ac:	e30f3254 	movw	r3, #62036	; 0xf254
  1277b0:	e3403014 	movt	r3, #20
  1277b4:	e5933000 	ldr	r3, [r3]
  1277b8:	e5932004 	ldr	r2, [r3, #4]
  1277bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1277c0:	e0822003 	add	r2, r2, r3
  1277c4:	e51b3010 	ldr	r3, [fp, #-16]
  1277c8:	e5832004 	str	r2, [r3, #4]
        }
        timeout->next = t->next;
  1277cc:	e51b3008 	ldr	r3, [fp, #-8]
  1277d0:	e5932000 	ldr	r2, [r3]
  1277d4:	e51b3010 	ldr	r3, [fp, #-16]
  1277d8:	e5832000 	str	r2, [r3]
        t->next = timeout;
  1277dc:	e51b3008 	ldr	r3, [fp, #-8]
  1277e0:	e51b2010 	ldr	r2, [fp, #-16]
  1277e4:	e5832000 	str	r2, [r3]
        break;
  1277e8:	ea000007 	b	12780c <sys_timeout+0x28c>
    for (t = next_timeout; t != NULL; t = t->next) {
  1277ec:	e51b3008 	ldr	r3, [fp, #-8]
  1277f0:	e5933000 	ldr	r3, [r3]
  1277f4:	e50b3008 	str	r3, [fp, #-8]
  1277f8:	e51b3008 	ldr	r3, [fp, #-8]
  1277fc:	e3530000 	cmp	r3, #0
  127800:	1affffc4 	bne	127718 <sys_timeout+0x198>
  127804:	ea000000 	b	12780c <sys_timeout+0x28c>
    return;
  127808:	e320f000 	nop	{0}
      }
    }
  }
}
  12780c:	e24bd004 	sub	sp, fp, #4
  127810:	e8bd8800 	pop	{fp, pc}

00127814 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
  127814:	e92d4800 	push	{fp, lr}
  127818:	e28db004 	add	fp, sp, #4
  12781c:	e24dd010 	sub	sp, sp, #16
  127820:	e50b0010 	str	r0, [fp, #-16]
  127824:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
  127828:	e30f3254 	movw	r3, #62036	; 0xf254
  12782c:	e3403014 	movt	r3, #20
  127830:	e5933000 	ldr	r3, [r3]
  127834:	e3530000 	cmp	r3, #0
  127838:	0a000038 	beq	127920 <sys_untimeout+0x10c>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  12783c:	e30f3254 	movw	r3, #62036	; 0xf254
  127840:	e3403014 	movt	r3, #20
  127844:	e5933000 	ldr	r3, [r3]
  127848:	e50b300c 	str	r3, [fp, #-12]
  12784c:	e3a03000 	mov	r3, #0
  127850:	e50b3008 	str	r3, [fp, #-8]
  127854:	ea00002c 	b	12790c <sys_untimeout+0xf8>
    if ((t->h == handler) && (t->arg == arg)) {
  127858:	e51b300c 	ldr	r3, [fp, #-12]
  12785c:	e5933008 	ldr	r3, [r3, #8]
  127860:	e51b2010 	ldr	r2, [fp, #-16]
  127864:	e1520003 	cmp	r2, r3
  127868:	1a000022 	bne	1278f8 <sys_untimeout+0xe4>
  12786c:	e51b300c 	ldr	r3, [fp, #-12]
  127870:	e593300c 	ldr	r3, [r3, #12]
  127874:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  127878:	e1520003 	cmp	r2, r3
  12787c:	1a00001d 	bne	1278f8 <sys_untimeout+0xe4>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
  127880:	e51b3008 	ldr	r3, [fp, #-8]
  127884:	e3530000 	cmp	r3, #0
  127888:	1a000005 	bne	1278a4 <sys_untimeout+0x90>
        next_timeout = t->next;
  12788c:	e51b300c 	ldr	r3, [fp, #-12]
  127890:	e5932000 	ldr	r2, [r3]
  127894:	e30f3254 	movw	r3, #62036	; 0xf254
  127898:	e3403014 	movt	r3, #20
  12789c:	e5832000 	str	r2, [r3]
  1278a0:	ea000003 	b	1278b4 <sys_untimeout+0xa0>
      } else {
        prev_t->next = t->next;
  1278a4:	e51b300c 	ldr	r3, [fp, #-12]
  1278a8:	e5932000 	ldr	r2, [r3]
  1278ac:	e51b3008 	ldr	r3, [fp, #-8]
  1278b0:	e5832000 	str	r2, [r3]
      }
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL) {
  1278b4:	e51b300c 	ldr	r3, [fp, #-12]
  1278b8:	e5933000 	ldr	r3, [r3]
  1278bc:	e3530000 	cmp	r3, #0
  1278c0:	0a000008 	beq	1278e8 <sys_untimeout+0xd4>
        t->next->time += t->time;
  1278c4:	e51b300c 	ldr	r3, [fp, #-12]
  1278c8:	e5933000 	ldr	r3, [r3]
  1278cc:	e5931004 	ldr	r1, [r3, #4]
  1278d0:	e51b300c 	ldr	r3, [fp, #-12]
  1278d4:	e5932004 	ldr	r2, [r3, #4]
  1278d8:	e51b300c 	ldr	r3, [fp, #-12]
  1278dc:	e5933000 	ldr	r3, [r3]
  1278e0:	e0812002 	add	r2, r1, r2
  1278e4:	e5832004 	str	r2, [r3, #4]
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
  1278e8:	e51b100c 	ldr	r1, [fp, #-12]
  1278ec:	e3a0000d 	mov	r0, #13
  1278f0:	ebffc6e1 	bl	11947c <memp_free>
      return;
  1278f4:	ea00000a 	b	127924 <sys_untimeout+0x110>
  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  1278f8:	e51b300c 	ldr	r3, [fp, #-12]
  1278fc:	e50b3008 	str	r3, [fp, #-8]
  127900:	e51b300c 	ldr	r3, [fp, #-12]
  127904:	e5933000 	ldr	r3, [r3]
  127908:	e50b300c 	str	r3, [fp, #-12]
  12790c:	e51b300c 	ldr	r3, [fp, #-12]
  127910:	e3530000 	cmp	r3, #0
  127914:	1affffcf 	bne	127858 <sys_untimeout+0x44>
    }
  }
  return;
  127918:	e320f000 	nop	{0}
  12791c:	ea000000 	b	127924 <sys_untimeout+0x110>
    return;
  127920:	e320f000 	nop	{0}
}
  127924:	e24bd004 	sub	sp, fp, #4
  127928:	e8bd8800 	pop	{fp, pc}

0012792c <sys_check_timeouts>:
#if !NO_SYS && !defined __DOXYGEN__
static
#endif /* !NO_SYS */
void
sys_check_timeouts(void)
{
  12792c:	e92d4800 	push	{fp, lr}
  127930:	e28db004 	add	fp, sp, #4
  127934:	e24dd018 	sub	sp, sp, #24
  if (next_timeout) {
  127938:	e30f3254 	movw	r3, #62036	; 0xf254
  12793c:	e3403014 	movt	r3, #20
  127940:	e5933000 	ldr	r3, [r3]
  127944:	e3530000 	cmp	r3, #0
  127948:	0a000042 	beq	127a58 <sys_check_timeouts+0x12c>
    sys_timeout_handler handler;
    void *arg;
    u8_t had_one;
    u32_t now;

    now = sys_now();
  12794c:	ebff8de3 	bl	10b0e0 <sys_now>
  127950:	e50b0010 	str	r0, [fp, #-16]
    /* this cares for wraparounds */
    diff = now - timeouts_last_time;
  127954:	e30f3258 	movw	r3, #62040	; 0xf258
  127958:	e3403014 	movt	r3, #20
  12795c:	e5933000 	ldr	r3, [r3]
  127960:	e51b2010 	ldr	r2, [fp, #-16]
  127964:	e0423003 	sub	r3, r2, r3
  127968:	e50b3008 	str	r3, [fp, #-8]
    do {
      PBUF_CHECK_FREE_OOSEQ();
      had_one = 0;
  12796c:	e3a03000 	mov	r3, #0
  127970:	e54b3009 	strb	r3, [fp, #-9]
      tmptimeout = next_timeout;
  127974:	e30f3254 	movw	r3, #62036	; 0xf254
  127978:	e3403014 	movt	r3, #20
  12797c:	e5933000 	ldr	r3, [r3]
  127980:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      if (tmptimeout && (tmptimeout->time <= diff)) {
  127984:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127988:	e3530000 	cmp	r3, #0
  12798c:	0a00002e 	beq	127a4c <sys_check_timeouts+0x120>
  127990:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127994:	e5933004 	ldr	r3, [r3, #4]
  127998:	e51b2008 	ldr	r2, [fp, #-8]
  12799c:	e1520003 	cmp	r2, r3
  1279a0:	3a000029 	bcc	127a4c <sys_check_timeouts+0x120>
        /* timeout has expired */
        had_one = 1;
  1279a4:	e3a03001 	mov	r3, #1
  1279a8:	e54b3009 	strb	r3, [fp, #-9]
        timeouts_last_time += tmptimeout->time;
  1279ac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1279b0:	e5932004 	ldr	r2, [r3, #4]
  1279b4:	e30f3258 	movw	r3, #62040	; 0xf258
  1279b8:	e3403014 	movt	r3, #20
  1279bc:	e5933000 	ldr	r3, [r3]
  1279c0:	e0822003 	add	r2, r2, r3
  1279c4:	e30f3258 	movw	r3, #62040	; 0xf258
  1279c8:	e3403014 	movt	r3, #20
  1279cc:	e5832000 	str	r2, [r3]
        diff -= tmptimeout->time;
  1279d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1279d4:	e5933004 	ldr	r3, [r3, #4]
  1279d8:	e51b2008 	ldr	r2, [fp, #-8]
  1279dc:	e0423003 	sub	r3, r2, r3
  1279e0:	e50b3008 	str	r3, [fp, #-8]
        next_timeout = tmptimeout->next;
  1279e4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1279e8:	e5932000 	ldr	r2, [r3]
  1279ec:	e30f3254 	movw	r3, #62036	; 0xf254
  1279f0:	e3403014 	movt	r3, #20
  1279f4:	e5832000 	str	r2, [r3]
        handler = tmptimeout->h;
  1279f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1279fc:	e5933008 	ldr	r3, [r3, #8]
  127a00:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        arg = tmptimeout->arg;
  127a04:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127a08:	e593300c 	ldr	r3, [r3, #12]
  127a0c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
        if (handler != NULL) {
          LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s arg=%p\n",
            tmptimeout->handler_name, arg));
        }
#endif /* LWIP_DEBUG_TIMERNAMES */
        memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  127a10:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  127a14:	e3a0000d 	mov	r0, #13
  127a18:	ebffc697 	bl	11947c <memp_free>
        if (handler != NULL) {
  127a1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  127a20:	e3530000 	cmp	r3, #0
  127a24:	0a000008 	beq	127a4c <sys_check_timeouts+0x120>
#if !NO_SYS
          /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
             timeout handler function. */
          LOCK_TCPIP_CORE();
  127a28:	e30005e4 	movw	r0, #1508	; 0x5e4
  127a2c:	e3400015 	movt	r0, #21
  127a30:	ebff8bb0 	bl	10a8f8 <sys_mutex_lock>
#endif /* !NO_SYS */
          handler(arg);
  127a34:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  127a38:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  127a3c:	e12fff33 	blx	r3
#if !NO_SYS
          UNLOCK_TCPIP_CORE();
  127a40:	e30005e4 	movw	r0, #1508	; 0x5e4
  127a44:	e3400015 	movt	r0, #21
  127a48:	ebff8bb6 	bl	10a928 <sys_mutex_unlock>
#endif /* !NO_SYS */
        }
        LWIP_TCPIP_THREAD_ALIVE();
      }
    /* repeat until all expired timers have been called */
    } while (had_one);
  127a4c:	e55b3009 	ldrb	r3, [fp, #-9]
  127a50:	e3530000 	cmp	r3, #0
  127a54:	1affffc4 	bne	12796c <sys_check_timeouts+0x40>
  }
}
  127a58:	e320f000 	nop	{0}
  127a5c:	e24bd004 	sub	sp, fp, #4
  127a60:	e8bd8800 	pop	{fp, pc}

00127a64 <sys_restart_timeouts>:
 * time (e.g. while saving energy) to prevent all timer functions of that
 * period being called.
 */
void
sys_restart_timeouts(void)
{
  127a64:	e92d4800 	push	{fp, lr}
  127a68:	e28db004 	add	fp, sp, #4
  timeouts_last_time = sys_now();
  127a6c:	ebff8d9b 	bl	10b0e0 <sys_now>
  127a70:	e1a02000 	mov	r2, r0
  127a74:	e30f3258 	movw	r3, #62040	; 0xf258
  127a78:	e3403014 	movt	r3, #20
  127a7c:	e5832000 	str	r2, [r3]
}
  127a80:	e320f000 	nop	{0}
  127a84:	e8bd8800 	pop	{fp, pc}

00127a88 <sys_timeouts_sleeptime>:
#if !NO_SYS
static
#endif /* !NO_SYS */
u32_t
sys_timeouts_sleeptime(void)
{
  127a88:	e92d4800 	push	{fp, lr}
  127a8c:	e28db004 	add	fp, sp, #4
  127a90:	e24dd008 	sub	sp, sp, #8
  u32_t diff;
  if (next_timeout == NULL) {
  127a94:	e30f3254 	movw	r3, #62036	; 0xf254
  127a98:	e3403014 	movt	r3, #20
  127a9c:	e5933000 	ldr	r3, [r3]
  127aa0:	e3530000 	cmp	r3, #0
  127aa4:	1a000001 	bne	127ab0 <sys_timeouts_sleeptime+0x28>
    return 0xffffffff;
  127aa8:	e3e03000 	mvn	r3, #0
  127aac:	ea000015 	b	127b08 <sys_timeouts_sleeptime+0x80>
  }
  diff = sys_now() - timeouts_last_time;
  127ab0:	ebff8d8a 	bl	10b0e0 <sys_now>
  127ab4:	e1a02000 	mov	r2, r0
  127ab8:	e30f3258 	movw	r3, #62040	; 0xf258
  127abc:	e3403014 	movt	r3, #20
  127ac0:	e5933000 	ldr	r3, [r3]
  127ac4:	e0423003 	sub	r3, r2, r3
  127ac8:	e50b3008 	str	r3, [fp, #-8]
  if (diff > next_timeout->time) {
  127acc:	e30f3254 	movw	r3, #62036	; 0xf254
  127ad0:	e3403014 	movt	r3, #20
  127ad4:	e5933000 	ldr	r3, [r3]
  127ad8:	e5933004 	ldr	r3, [r3, #4]
  127adc:	e51b2008 	ldr	r2, [fp, #-8]
  127ae0:	e1520003 	cmp	r2, r3
  127ae4:	9a000001 	bls	127af0 <sys_timeouts_sleeptime+0x68>
    return 0;
  127ae8:	e3a03000 	mov	r3, #0
  127aec:	ea000005 	b	127b08 <sys_timeouts_sleeptime+0x80>
  } else {
    return next_timeout->time - diff;
  127af0:	e30f3254 	movw	r3, #62036	; 0xf254
  127af4:	e3403014 	movt	r3, #20
  127af8:	e5933000 	ldr	r3, [r3]
  127afc:	e5932004 	ldr	r2, [r3, #4]
  127b00:	e51b3008 	ldr	r3, [fp, #-8]
  127b04:	e0423003 	sub	r3, r2, r3
  }
}
  127b08:	e1a00003 	mov	r0, r3
  127b0c:	e24bd004 	sub	sp, fp, #4
  127b10:	e8bd8800 	pop	{fp, pc}

00127b14 <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
  127b14:	e92d4800 	push	{fp, lr}
  127b18:	e28db004 	add	fp, sp, #4
  127b1c:	e24dd010 	sub	sp, sp, #16
  127b20:	e50b0010 	str	r0, [fp, #-16]
  127b24:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  u32_t sleeptime;

again:
  if (!next_timeout) {
  127b28:	e30f3254 	movw	r3, #62036	; 0xf254
  127b2c:	e3403014 	movt	r3, #20
  127b30:	e5933000 	ldr	r3, [r3]
  127b34:	e3530000 	cmp	r3, #0
  127b38:	1a000004 	bne	127b50 <sys_timeouts_mbox_fetch+0x3c>
    sys_arch_mbox_fetch(mbox, msg, 0);
  127b3c:	e3a02000 	mov	r2, #0
  127b40:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  127b44:	e51b0010 	ldr	r0, [fp, #-16]
  127b48:	ebff8cb1 	bl	10ae14 <sys_arch_mbox_fetch>
    return;
  127b4c:	ea00000d 	b	127b88 <sys_timeouts_mbox_fetch+0x74>
  }

  sleeptime = sys_timeouts_sleeptime();
  127b50:	ebffffcc 	bl	127a88 <sys_timeouts_sleeptime>
  127b54:	e50b0008 	str	r0, [fp, #-8]
  if (sleeptime == 0 || sys_arch_mbox_fetch(mbox, msg, sleeptime) == SYS_ARCH_TIMEOUT) {
  127b58:	e51b3008 	ldr	r3, [fp, #-8]
  127b5c:	e3530000 	cmp	r3, #0
  127b60:	0a000006 	beq	127b80 <sys_timeouts_mbox_fetch+0x6c>
  127b64:	e51b2008 	ldr	r2, [fp, #-8]
  127b68:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  127b6c:	e51b0010 	ldr	r0, [fp, #-16]
  127b70:	ebff8ca7 	bl	10ae14 <sys_arch_mbox_fetch>
  127b74:	e1a03000 	mov	r3, r0
  127b78:	e3730001 	cmn	r3, #1
  127b7c:	1a000001 	bne	127b88 <sys_timeouts_mbox_fetch+0x74>
    /* If a SYS_ARCH_TIMEOUT value is returned, a timeout occurred
       before a message could be fetched. */
    sys_check_timeouts();
  127b80:	ebffff69 	bl	12792c <sys_check_timeouts>
    /* We try again to fetch a message from the mbox. */
    goto again;
  127b84:	eaffffe7 	b	127b28 <sys_timeouts_mbox_fetch+0x14>
  }
}
  127b88:	e24bd004 	sub	sp, fp, #4
  127b8c:	e8bd8800 	pop	{fp, pc}

00127b90 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
  127b90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  127b94:	e28db000 	add	fp, sp, #0
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
  127b98:	e320f000 	nop	{0}
  127b9c:	e28bd000 	add	sp, fp, #0
  127ba0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  127ba4:	e12fff1e 	bx	lr

00127ba8 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
  127ba8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  127bac:	e28db000 	add	fp, sp, #0
  127bb0:	e24dd00c 	sub	sp, sp, #12
  u16_t n = 0;
  127bb4:	e3a03000 	mov	r3, #0
  127bb8:	e14b30b6 	strh	r3, [fp, #-6]
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
  127bbc:	e30e3038 	movw	r3, #57400	; 0xe038
  127bc0:	e3403014 	movt	r3, #20
  127bc4:	e1d320b0 	ldrh	r2, [r3]
  127bc8:	e2823001 	add	r3, r2, #1
  127bcc:	e6ff1073 	uxth	r1, r3
  127bd0:	e30e3038 	movw	r3, #57400	; 0xe038
  127bd4:	e3403014 	movt	r3, #20
  127bd8:	e1c310b0 	strh	r1, [r3]
  127bdc:	e30f3fff 	movw	r3, #65535	; 0xffff
  127be0:	e1520003 	cmp	r2, r3
  127be4:	1a000003 	bne	127bf8 <udp_new_port+0x50>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  127be8:	e30e3038 	movw	r3, #57400	; 0xe038
  127bec:	e3403014 	movt	r3, #20
  127bf0:	e3a02903 	mov	r2, #49152	; 0xc000
  127bf4:	e1c320b0 	strh	r2, [r3]
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  127bf8:	e3063a48 	movw	r3, #27208	; 0x6a48
  127bfc:	e3403057 	movt	r3, #87	; 0x57
  127c00:	e5933000 	ldr	r3, [r3]
  127c04:	e50b300c 	str	r3, [fp, #-12]
  127c08:	ea000011 	b	127c54 <udp_new_port+0xac>
    if (pcb->local_port == udp_port) {
  127c0c:	e51b300c 	ldr	r3, [fp, #-12]
  127c10:	e1d321b2 	ldrh	r2, [r3, #18]
  127c14:	e30e3038 	movw	r3, #57400	; 0xe038
  127c18:	e3403014 	movt	r3, #20
  127c1c:	e1d330b0 	ldrh	r3, [r3]
  127c20:	e1520003 	cmp	r2, r3
  127c24:	1a000007 	bne	127c48 <udp_new_port+0xa0>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
  127c28:	e15b30b6 	ldrh	r3, [fp, #-6]
  127c2c:	e2833001 	add	r3, r3, #1
  127c30:	e14b30b6 	strh	r3, [fp, #-6]
  127c34:	e15b30b6 	ldrh	r3, [fp, #-6]
  127c38:	e3530901 	cmp	r3, #16384	; 0x4000
  127c3c:	3affffde 	bcc	127bbc <udp_new_port+0x14>
        return 0;
  127c40:	e3a03000 	mov	r3, #0
  127c44:	ea000008 	b	127c6c <udp_new_port+0xc4>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  127c48:	e51b300c 	ldr	r3, [fp, #-12]
  127c4c:	e593300c 	ldr	r3, [r3, #12]
  127c50:	e50b300c 	str	r3, [fp, #-12]
  127c54:	e51b300c 	ldr	r3, [fp, #-12]
  127c58:	e3530000 	cmp	r3, #0
  127c5c:	1affffea 	bne	127c0c <udp_new_port+0x64>
      }
      goto again;
    }
  }
  return udp_port;
  127c60:	e30e3038 	movw	r3, #57400	; 0xe038
  127c64:	e3403014 	movt	r3, #20
  127c68:	e1d330b0 	ldrh	r3, [r3]
}
  127c6c:	e1a00003 	mov	r0, r3
  127c70:	e28bd000 	add	sp, fp, #0
  127c74:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  127c78:	e12fff1e 	bx	lr

00127c7c <udp_input_local_match>:
 * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used for IPv4)
 * @return 1 on match, 0 otherwise
 */
static u8_t
udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
{
  127c7c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  127c80:	e28db000 	add	fp, sp, #0
  127c84:	e24dd014 	sub	sp, sp, #20
  127c88:	e50b0008 	str	r0, [fp, #-8]
  127c8c:	e50b100c 	str	r1, [fp, #-12]
  127c90:	e1a03002 	mov	r3, r2
  127c94:	e54b300d 	strb	r3, [fp, #-13]
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
  127c98:	e55b300d 	ldrb	r3, [fp, #-13]
  127c9c:	e3530000 	cmp	r3, #0
  127ca0:	0a00001e 	beq	127d20 <udp_input_local_match+0xa4>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
  127ca4:	e51b3008 	ldr	r3, [fp, #-8]
  127ca8:	e5d33008 	ldrb	r3, [r3, #8]
  127cac:	e2033020 	and	r3, r3, #32
  127cb0:	e3530000 	cmp	r3, #0
  127cb4:	0a000029 	beq	127d60 <udp_input_local_match+0xe4>
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
  127cb8:	e51b3008 	ldr	r3, [fp, #-8]
  127cbc:	e3530000 	cmp	r3, #0
  127cc0:	0a000014 	beq	127d18 <udp_input_local_match+0x9c>
  127cc4:	e51b3008 	ldr	r3, [fp, #-8]
  127cc8:	e5933000 	ldr	r3, [r3]
  127ccc:	e3530000 	cmp	r3, #0
  127cd0:	0a000010 	beq	127d18 <udp_input_local_match+0x9c>
          ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
  127cd4:	e30035e8 	movw	r3, #1512	; 0x5e8
  127cd8:	e3403015 	movt	r3, #21
  127cdc:	e5933014 	ldr	r3, [r3, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
  127ce0:	e3730001 	cmn	r3, #1
  127ce4:	0a00000b 	beq	127d18 <udp_input_local_match+0x9c>
           ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
  127ce8:	e51b3008 	ldr	r3, [fp, #-8]
  127cec:	e5932000 	ldr	r2, [r3]
  127cf0:	e30035e8 	movw	r3, #1512	; 0x5e8
  127cf4:	e3403015 	movt	r3, #21
  127cf8:	e5933014 	ldr	r3, [r3, #20]
  127cfc:	e0222003 	eor	r2, r2, r3
  127d00:	e51b300c 	ldr	r3, [fp, #-12]
  127d04:	e2833008 	add	r3, r3, #8
  127d08:	e5933000 	ldr	r3, [r3]
  127d0c:	e0033002 	and	r3, r3, r2
          ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
  127d10:	e3530000 	cmp	r3, #0
  127d14:	1a000011 	bne	127d60 <udp_input_local_match+0xe4>
          return 1;
  127d18:	e3a03001 	mov	r3, #1
  127d1c:	ea000010 	b	127d64 <udp_input_local_match+0xe8>
        }
      }
    } else
#endif /* LWIP_IPV4 */
    /* Handle IPv4 and IPv6: all or exact match */
    if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
  127d20:	e51b3008 	ldr	r3, [fp, #-8]
  127d24:	e3530000 	cmp	r3, #0
  127d28:	0a00000a 	beq	127d58 <udp_input_local_match+0xdc>
  127d2c:	e51b3008 	ldr	r3, [fp, #-8]
  127d30:	e5933000 	ldr	r3, [r3]
  127d34:	e3530000 	cmp	r3, #0
  127d38:	0a000006 	beq	127d58 <udp_input_local_match+0xdc>
  127d3c:	e51b3008 	ldr	r3, [fp, #-8]
  127d40:	e5932000 	ldr	r2, [r3]
  127d44:	e30035e8 	movw	r3, #1512	; 0x5e8
  127d48:	e3403015 	movt	r3, #21
  127d4c:	e5933014 	ldr	r3, [r3, #20]
  127d50:	e1520003 	cmp	r2, r3
  127d54:	1a000001 	bne	127d60 <udp_input_local_match+0xe4>
      return 1;
  127d58:	e3a03001 	mov	r3, #1
  127d5c:	ea000000 	b	127d64 <udp_input_local_match+0xe8>
    }
  }

  return 0;
  127d60:	e3a03000 	mov	r3, #0
}
  127d64:	e1a00003 	mov	r0, r3
  127d68:	e28bd000 	add	sp, fp, #0
  127d6c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  127d70:	e12fff1e 	bx	lr

00127d74 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  127d74:	e92d4810 	push	{r4, fp, lr}
  127d78:	e28db008 	add	fp, sp, #8
  127d7c:	e24dd034 	sub	sp, sp, #52	; 0x34
  127d80:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  127d84:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb, *prev;
  struct udp_pcb *uncon_pcb;
  u16_t src, dest;
  u8_t broadcast;
  u8_t for_us = 0;
  127d88:	e3a03000 	mov	r3, #0
  127d8c:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7

  LWIP_UNUSED_ARG(inp);

  PERF_START;

  UDP_STATS_INC(udp.recv);
  127d90:	e3063840 	movw	r3, #26688	; 0x6840
  127d94:	e3403057 	movt	r3, #87	; 0x57
  127d98:	e1d339b6 	ldrh	r3, [r3, #150]	; 0x96
  127d9c:	e2833001 	add	r3, r3, #1
  127da0:	e6ff2073 	uxth	r2, r3
  127da4:	e3063840 	movw	r3, #26688	; 0x6840
  127da8:	e3403057 	movt	r3, #87	; 0x57
  127dac:	e1c329b6 	strh	r2, [r3, #150]	; 0x96

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
  127db0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  127db4:	e1d330ba 	ldrh	r3, [r3, #10]
  127db8:	e3530007 	cmp	r3, #7
  127dbc:	8a000019 	bhi	127e28 <udp_input+0xb4>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
  127dc0:	e3063840 	movw	r3, #26688	; 0x6840
  127dc4:	e3403057 	movt	r3, #87	; 0x57
  127dc8:	e1d339be 	ldrh	r3, [r3, #158]	; 0x9e
  127dcc:	e2833001 	add	r3, r3, #1
  127dd0:	e6ff2073 	uxth	r2, r3
  127dd4:	e3063840 	movw	r3, #26688	; 0x6840
  127dd8:	e3403057 	movt	r3, #87	; 0x57
  127ddc:	e1c329be 	strh	r2, [r3, #158]	; 0x9e
    UDP_STATS_INC(udp.drop);
  127de0:	e3063840 	movw	r3, #26688	; 0x6840
  127de4:	e3403057 	movt	r3, #87	; 0x57
  127de8:	e1d339ba 	ldrh	r3, [r3, #154]	; 0x9a
  127dec:	e2833001 	add	r3, r3, #1
  127df0:	e6ff2073 	uxth	r2, r3
  127df4:	e3063840 	movw	r3, #26688	; 0x6840
  127df8:	e3403057 	movt	r3, #87	; 0x57
  127dfc:	e1c329ba 	strh	r2, [r3, #154]	; 0x9a
    MIB2_STATS_INC(mib2.udpinerrors);
  127e00:	e3063840 	movw	r3, #26688	; 0x6840
  127e04:	e3403057 	movt	r3, #87	; 0x57
  127e08:	e5933198 	ldr	r3, [r3, #408]	; 0x198
  127e0c:	e2832001 	add	r2, r3, #1
  127e10:	e3063840 	movw	r3, #26688	; 0x6840
  127e14:	e3403057 	movt	r3, #87	; 0x57
  127e18:	e5832198 	str	r2, [r3, #408]	; 0x198
    pbuf_free(p);
  127e1c:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  127e20:	ebffcca3 	bl	11b0b4 <pbuf_free>
    goto end;
  127e24:	ea00010c 	b	12825c <udp_input+0x4e8>
  }

  udphdr = (struct udp_hdr *)p->payload;
  127e28:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  127e2c:	e5933004 	ldr	r3, [r3, #4]
  127e30:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
  127e34:	e30035e8 	movw	r3, #1512	; 0x5e8
  127e38:	e3403015 	movt	r3, #21
  127e3c:	e5932014 	ldr	r2, [r3, #20]
  127e40:	e30035e8 	movw	r3, #1512	; 0x5e8
  127e44:	e3403015 	movt	r3, #21
  127e48:	e5933000 	ldr	r3, [r3]
  127e4c:	e1a01003 	mov	r1, r3
  127e50:	e1a00002 	mov	r0, r2
  127e54:	eb002a2c 	bl	13270c <ip4_addr_isbroadcast_u32>
  127e58:	e1a03000 	mov	r3, r0
  127e5c:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
  127e60:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  127e64:	e1d330b0 	ldrh	r3, [r3]
  127e68:	e6ff3073 	uxth	r3, r3
  127e6c:	e1a00003 	mov	r0, r3
  127e70:	ebffba58 	bl	1167d8 <lwip_htons>
  127e74:	e1a03000 	mov	r3, r0
  127e78:	e14b32b4 	strh	r3, [fp, #-36]	; 0xffffffdc
  dest = lwip_ntohs(udphdr->dest);
  127e7c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  127e80:	e1d330b2 	ldrh	r3, [r3, #2]
  127e84:	e6ff3073 	uxth	r3, r3
  127e88:	e1a00003 	mov	r0, r3
  127e8c:	ebffba51 	bl	1167d8 <lwip_htons>
  127e90:	e1a03000 	mov	r3, r0
  127e94:	e14b32b6 	strh	r3, [fp, #-38]	; 0xffffffda
  ip_addr_debug_print(UDP_DEBUG, ip_current_dest_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
  ip_addr_debug_print(UDP_DEBUG, ip_current_src_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));

  pcb = NULL;
  127e98:	e3a03000 	mov	r3, #0
  127e9c:	e50b3010 	str	r3, [fp, #-16]
  prev = NULL;
  127ea0:	e3a03000 	mov	r3, #0
  127ea4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  uncon_pcb = NULL;
  127ea8:	e3a03000 	mov	r3, #0
  127eac:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  127eb0:	e3063a48 	movw	r3, #27208	; 0x6a48
  127eb4:	e3403057 	movt	r3, #87	; 0x57
  127eb8:	e5933000 	ldr	r3, [r3]
  127ebc:	e50b3010 	str	r3, [fp, #-16]
  127ec0:	ea00004c 	b	127ff8 <udp_input+0x284>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    ip_addr_debug_print(UDP_DEBUG, &pcb->remote_ip);
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));

    /* compare PCB local addr+port to UDP destination addr+port */
    if ((pcb->local_port == dest) &&
  127ec4:	e51b3010 	ldr	r3, [fp, #-16]
  127ec8:	e1d331b2 	ldrh	r3, [r3, #18]
  127ecc:	e15b22b6 	ldrh	r2, [fp, #-38]	; 0xffffffda
  127ed0:	e1520003 	cmp	r2, r3
  127ed4:	1a000042 	bne	127fe4 <udp_input+0x270>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
  127ed8:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  127edc:	e1a02003 	mov	r2, r3
  127ee0:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  127ee4:	e51b0010 	ldr	r0, [fp, #-16]
  127ee8:	ebffff63 	bl	127c7c <udp_input_local_match>
  127eec:	e1a03000 	mov	r3, r0
    if ((pcb->local_port == dest) &&
  127ef0:	e3530000 	cmp	r3, #0
  127ef4:	0a00003a 	beq	127fe4 <udp_input+0x270>
      if (((pcb->flags & UDP_FLAGS_CONNECTED) == 0) &&
  127ef8:	e51b3010 	ldr	r3, [fp, #-16]
  127efc:	e5d33010 	ldrb	r3, [r3, #16]
  127f00:	e2033004 	and	r3, r3, #4
  127f04:	e3530000 	cmp	r3, #0
  127f08:	1a00000b 	bne	127f3c <udp_input+0x1c8>
  127f0c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  127f10:	e3530000 	cmp	r3, #0
  127f14:	0a000006 	beq	127f34 <udp_input+0x1c0>
          ((uncon_pcb == NULL)
#if SO_REUSE
          /* prefer specific IPs over cath-all */
          || !ip_addr_isany(&pcb->local_ip)
  127f18:	e51b3010 	ldr	r3, [fp, #-16]
  127f1c:	e3530000 	cmp	r3, #0
  127f20:	0a000005 	beq	127f3c <udp_input+0x1c8>
  127f24:	e51b3010 	ldr	r3, [fp, #-16]
  127f28:	e5933000 	ldr	r3, [r3]
  127f2c:	e3530000 	cmp	r3, #0
  127f30:	0a000001 	beq	127f3c <udp_input+0x1c8>
#endif /* SO_REUSE */
          )) {
        /* the first unconnected matching PCB */
        uncon_pcb = pcb;
  127f34:	e51b3010 	ldr	r3, [fp, #-16]
  127f38:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
  127f3c:	e51b3010 	ldr	r3, [fp, #-16]
  127f40:	e1d331b4 	ldrh	r3, [r3, #20]
  127f44:	e15b22b4 	ldrh	r2, [fp, #-36]	; 0xffffffdc
  127f48:	e1520003 	cmp	r2, r3
  127f4c:	1a000024 	bne	127fe4 <udp_input+0x270>
          (ip_addr_isany_val(pcb->remote_ip) ||
  127f50:	e51b3010 	ldr	r3, [fp, #-16]
  127f54:	e5933004 	ldr	r3, [r3, #4]
      if ((pcb->remote_port == src) &&
  127f58:	e3530000 	cmp	r3, #0
  127f5c:	0a000006 	beq	127f7c <udp_input+0x208>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
  127f60:	e51b3010 	ldr	r3, [fp, #-16]
  127f64:	e5932004 	ldr	r2, [r3, #4]
  127f68:	e30035e8 	movw	r3, #1512	; 0x5e8
  127f6c:	e3403015 	movt	r3, #21
  127f70:	e5933010 	ldr	r3, [r3, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
  127f74:	e1520003 	cmp	r2, r3
  127f78:	1a000019 	bne	127fe4 <udp_input+0x270>
        /* the first fully matching PCB */
        if (prev != NULL) {
  127f7c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127f80:	e3530000 	cmp	r3, #0
  127f84:	0a00000d 	beq	127fc0 <udp_input+0x24c>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  127f88:	e51b3010 	ldr	r3, [fp, #-16]
  127f8c:	e593200c 	ldr	r2, [r3, #12]
  127f90:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  127f94:	e583200c 	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
  127f98:	e3063a48 	movw	r3, #27208	; 0x6a48
  127f9c:	e3403057 	movt	r3, #87	; 0x57
  127fa0:	e5932000 	ldr	r2, [r3]
  127fa4:	e51b3010 	ldr	r3, [fp, #-16]
  127fa8:	e583200c 	str	r2, [r3, #12]
          udp_pcbs = pcb;
  127fac:	e3063a48 	movw	r3, #27208	; 0x6a48
  127fb0:	e3403057 	movt	r3, #87	; 0x57
  127fb4:	e51b2010 	ldr	r2, [fp, #-16]
  127fb8:	e5832000 	str	r2, [r3]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  127fbc:	ea000010 	b	128004 <udp_input+0x290>
          UDP_STATS_INC(udp.cachehit);
  127fc0:	e3063840 	movw	r3, #26688	; 0x6840
  127fc4:	e3403057 	movt	r3, #87	; 0x57
  127fc8:	e1d33aba 	ldrh	r3, [r3, #170]	; 0xaa
  127fcc:	e2833001 	add	r3, r3, #1
  127fd0:	e6ff2073 	uxth	r2, r3
  127fd4:	e3063840 	movw	r3, #26688	; 0x6840
  127fd8:	e3403057 	movt	r3, #87	; 0x57
  127fdc:	e1c32aba 	strh	r2, [r3, #170]	; 0xaa
        break;
  127fe0:	ea000007 	b	128004 <udp_input+0x290>
      }
    }

    prev = pcb;
  127fe4:	e51b3010 	ldr	r3, [fp, #-16]
  127fe8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  127fec:	e51b3010 	ldr	r3, [fp, #-16]
  127ff0:	e593300c 	ldr	r3, [r3, #12]
  127ff4:	e50b3010 	str	r3, [fp, #-16]
  127ff8:	e51b3010 	ldr	r3, [fp, #-16]
  127ffc:	e3530000 	cmp	r3, #0
  128000:	1affffaf 	bne	127ec4 <udp_input+0x150>
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
  128004:	e51b3010 	ldr	r3, [fp, #-16]
  128008:	e3530000 	cmp	r3, #0
  12800c:	1a000001 	bne	128018 <udp_input+0x2a4>
    pcb = uncon_pcb;
  128010:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128014:	e50b3010 	str	r3, [fp, #-16]
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL) {
  128018:	e51b3010 	ldr	r3, [fp, #-16]
  12801c:	e3530000 	cmp	r3, #0
  128020:	0a000002 	beq	128030 <udp_input+0x2bc>
    for_us = 1;
  128024:	e3a03001 	mov	r3, #1
  128028:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
  12802c:	ea00000a 	b	12805c <udp_input+0x2e8>
      for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
    }
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    if (!ip_current_is_v6()) {
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
  128030:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  128034:	e2833004 	add	r3, r3, #4
  128038:	e5932000 	ldr	r2, [r3]
  12803c:	e30035e8 	movw	r3, #1512	; 0x5e8
  128040:	e3403015 	movt	r3, #21
  128044:	e5933014 	ldr	r3, [r3, #20]
  128048:	e1520003 	cmp	r2, r3
  12804c:	03a03001 	moveq	r3, #1
  128050:	13a03000 	movne	r3, #0
  128054:	e6ef3073 	uxtb	r3, r3
  128058:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    }
#endif /* LWIP_IPV4 */
  }

  if (for_us) {
  12805c:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
  128060:	e3530000 	cmp	r3, #0
  128064:	0a000079 	beq	128250 <udp_input+0x4dc>
          goto chkerr;
        }
      } else
#endif /* LWIP_UDPLITE */
      {
        if (udphdr->chksum != 0) {
  128068:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12806c:	e1d330b6 	ldrh	r3, [r3, #6]
  128070:	e6ff3073 	uxth	r3, r3
  128074:	e3530000 	cmp	r3, #0
  128078:	0a00000a 	beq	1280a8 <udp_input+0x334>
          if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
  12807c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  128080:	e1d320b8 	ldrh	r2, [r3, #8]
  128084:	e59f3244 	ldr	r3, [pc, #580]	; 1282d0 <udp_input+0x55c>
  128088:	e58d3000 	str	r3, [sp]
  12808c:	e59f3240 	ldr	r3, [pc, #576]	; 1282d4 <udp_input+0x560>
  128090:	e3a01011 	mov	r1, #17
  128094:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  128098:	ebffc1ed 	bl	118854 <ip_chksum_pseudo>
  12809c:	e1a03000 	mov	r3, r0
  1280a0:	e3530000 	cmp	r3, #0
  1280a4:	1a00006d 	bne	128260 <udp_input+0x4ec>
          }
        }
      }
    }
#endif /* CHECKSUM_CHECK_UDP */
    if (pbuf_header(p, -UDP_HLEN)) {
  1280a8:	e3e01007 	mvn	r1, #7
  1280ac:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  1280b0:	ebffcbe1 	bl	11b03c <pbuf_header>
  1280b4:	e1a03000 	mov	r3, r0
  1280b8:	e3530000 	cmp	r3, #0
  1280bc:	0a000018 	beq	128124 <udp_input+0x3b0>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  1280c0:	e3080cdc 	movw	r0, #36060	; 0x8cdc
  1280c4:	e3400014 	movt	r0, #20
  1280c8:	ebff6c11 	bl	103114 <rt_kprintf>
  1280cc:	e3001155 	movw	r1, #341	; 0x155
  1280d0:	e3080cf0 	movw	r0, #36080	; 0x8cf0
  1280d4:	e3400014 	movt	r0, #20
  1280d8:	ebff8be7 	bl	10b07c <sys_arch_assert>
      UDP_STATS_INC(udp.drop);
  1280dc:	e3063840 	movw	r3, #26688	; 0x6840
  1280e0:	e3403057 	movt	r3, #87	; 0x57
  1280e4:	e1d339ba 	ldrh	r3, [r3, #154]	; 0x9a
  1280e8:	e2833001 	add	r3, r3, #1
  1280ec:	e6ff2073 	uxth	r2, r3
  1280f0:	e3063840 	movw	r3, #26688	; 0x6840
  1280f4:	e3403057 	movt	r3, #87	; 0x57
  1280f8:	e1c329ba 	strh	r2, [r3, #154]	; 0x9a
      MIB2_STATS_INC(mib2.udpinerrors);
  1280fc:	e3063840 	movw	r3, #26688	; 0x6840
  128100:	e3403057 	movt	r3, #87	; 0x57
  128104:	e5933198 	ldr	r3, [r3, #408]	; 0x198
  128108:	e2832001 	add	r2, r3, #1
  12810c:	e3063840 	movw	r3, #26688	; 0x6840
  128110:	e3403057 	movt	r3, #87	; 0x57
  128114:	e5832198 	str	r2, [r3, #408]	; 0x198
      pbuf_free(p);
  128118:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  12811c:	ebffcbe4 	bl	11b0b4 <pbuf_free>
      goto end;
  128120:	ea00004d 	b	12825c <udp_input+0x4e8>
    }

    if (pcb != NULL) {
  128124:	e51b3010 	ldr	r3, [fp, #-16]
  128128:	e3530000 	cmp	r3, #0
  12812c:	0a000018 	beq	128194 <udp_input+0x420>
      MIB2_STATS_INC(mib2.udpindatagrams);
  128130:	e3063840 	movw	r3, #26688	; 0x6840
  128134:	e3403057 	movt	r3, #87	; 0x57
  128138:	e5933190 	ldr	r3, [r3, #400]	; 0x190
  12813c:	e2832001 	add	r2, r3, #1
  128140:	e3063840 	movw	r3, #26688	; 0x6840
  128144:	e3403057 	movt	r3, #87	; 0x57
  128148:	e5832190 	str	r2, [r3, #400]	; 0x190
          pbuf_header(p, -hdrs_len);
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
  12814c:	e51b3010 	ldr	r3, [fp, #-16]
  128150:	e5933020 	ldr	r3, [r3, #32]
  128154:	e3530000 	cmp	r3, #0
  128158:	0a00000a 	beq	128188 <udp_input+0x414>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
  12815c:	e51b3010 	ldr	r3, [fp, #-16]
  128160:	e5934020 	ldr	r4, [r3, #32]
  128164:	e51b3010 	ldr	r3, [fp, #-16]
  128168:	e5930024 	ldr	r0, [r3, #36]	; 0x24
  12816c:	e15b32b4 	ldrh	r3, [fp, #-36]	; 0xffffffdc
  128170:	e58d3000 	str	r3, [sp]
  128174:	e59f3158 	ldr	r3, [pc, #344]	; 1282d4 <udp_input+0x560>
  128178:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  12817c:	e51b1010 	ldr	r1, [fp, #-16]
  128180:	e12fff34 	blx	r4
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
  return;
  128184:	ea00004f 	b	1282c8 <udp_input+0x554>
        pbuf_free(p);
  128188:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  12818c:	ebffcbc8 	bl	11b0b4 <pbuf_free>
        goto end;
  128190:	ea000031 	b	12825c <udp_input+0x4e8>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
  128194:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  128198:	e3530000 	cmp	r3, #0
  12819c:	1a000011 	bne	1281e8 <udp_input+0x474>
  1281a0:	e30035e8 	movw	r3, #1512	; 0x5e8
  1281a4:	e3403015 	movt	r3, #21
  1281a8:	e5933014 	ldr	r3, [r3, #20]
  1281ac:	e20330f0 	and	r3, r3, #240	; 0xf0
  1281b0:	e35300e0 	cmp	r3, #224	; 0xe0
  1281b4:	0a00000b 	beq	1281e8 <udp_input+0x474>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
  1281b8:	e30035e8 	movw	r3, #1512	; 0x5e8
  1281bc:	e3403015 	movt	r3, #21
  1281c0:	e1d330bc 	ldrh	r3, [r3, #12]
  1281c4:	e2833008 	add	r3, r3, #8
  1281c8:	e6ff3073 	uxth	r3, r3
  1281cc:	e6bf3073 	sxth	r3, r3
  1281d0:	e1a01003 	mov	r1, r3
  1281d4:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  1281d8:	ebffcba6 	bl	11b078 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
  1281dc:	e3a01003 	mov	r1, #3
  1281e0:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  1281e4:	eb001f27 	bl	12fe88 <icmp_dest_unreach>
      UDP_STATS_INC(udp.proterr);
  1281e8:	e3063840 	movw	r3, #26688	; 0x6840
  1281ec:	e3403057 	movt	r3, #87	; 0x57
  1281f0:	e1d33ab4 	ldrh	r3, [r3, #164]	; 0xa4
  1281f4:	e2833001 	add	r3, r3, #1
  1281f8:	e6ff2073 	uxth	r2, r3
  1281fc:	e3063840 	movw	r3, #26688	; 0x6840
  128200:	e3403057 	movt	r3, #87	; 0x57
  128204:	e1c32ab4 	strh	r2, [r3, #164]	; 0xa4
      UDP_STATS_INC(udp.drop);
  128208:	e3063840 	movw	r3, #26688	; 0x6840
  12820c:	e3403057 	movt	r3, #87	; 0x57
  128210:	e1d339ba 	ldrh	r3, [r3, #154]	; 0x9a
  128214:	e2833001 	add	r3, r3, #1
  128218:	e6ff2073 	uxth	r2, r3
  12821c:	e3063840 	movw	r3, #26688	; 0x6840
  128220:	e3403057 	movt	r3, #87	; 0x57
  128224:	e1c329ba 	strh	r2, [r3, #154]	; 0x9a
      MIB2_STATS_INC(mib2.udpnoports);
  128228:	e3063840 	movw	r3, #26688	; 0x6840
  12822c:	e3403057 	movt	r3, #87	; 0x57
  128230:	e5933194 	ldr	r3, [r3, #404]	; 0x194
  128234:	e2832001 	add	r2, r3, #1
  128238:	e3063840 	movw	r3, #26688	; 0x6840
  12823c:	e3403057 	movt	r3, #87	; 0x57
  128240:	e5832194 	str	r2, [r3, #404]	; 0x194
      pbuf_free(p);
  128244:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  128248:	ebffcb99 	bl	11b0b4 <pbuf_free>
  return;
  12824c:	ea00001d 	b	1282c8 <udp_input+0x554>
    pbuf_free(p);
  128250:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  128254:	ebffcb96 	bl	11b0b4 <pbuf_free>
  return;
  128258:	ea00001a 	b	1282c8 <udp_input+0x554>
  12825c:	ea000019 	b	1282c8 <udp_input+0x554>
            goto chkerr;
  128260:	e320f000 	nop	{0}
#if CHECKSUM_CHECK_UDP
chkerr:
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
              ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
  UDP_STATS_INC(udp.chkerr);
  128264:	e3063840 	movw	r3, #26688	; 0x6840
  128268:	e3403057 	movt	r3, #87	; 0x57
  12826c:	e1d339bc 	ldrh	r3, [r3, #156]	; 0x9c
  128270:	e2833001 	add	r3, r3, #1
  128274:	e6ff2073 	uxth	r2, r3
  128278:	e3063840 	movw	r3, #26688	; 0x6840
  12827c:	e3403057 	movt	r3, #87	; 0x57
  128280:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
  UDP_STATS_INC(udp.drop);
  128284:	e3063840 	movw	r3, #26688	; 0x6840
  128288:	e3403057 	movt	r3, #87	; 0x57
  12828c:	e1d339ba 	ldrh	r3, [r3, #154]	; 0x9a
  128290:	e2833001 	add	r3, r3, #1
  128294:	e6ff2073 	uxth	r2, r3
  128298:	e3063840 	movw	r3, #26688	; 0x6840
  12829c:	e3403057 	movt	r3, #87	; 0x57
  1282a0:	e1c329ba 	strh	r2, [r3, #154]	; 0x9a
  MIB2_STATS_INC(mib2.udpinerrors);
  1282a4:	e3063840 	movw	r3, #26688	; 0x6840
  1282a8:	e3403057 	movt	r3, #87	; 0x57
  1282ac:	e5933198 	ldr	r3, [r3, #408]	; 0x198
  1282b0:	e2832001 	add	r2, r3, #1
  1282b4:	e3063840 	movw	r3, #26688	; 0x6840
  1282b8:	e3403057 	movt	r3, #87	; 0x57
  1282bc:	e5832198 	str	r2, [r3, #408]	; 0x198
  pbuf_free(p);
  1282c0:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  1282c4:	ebffcb7a 	bl	11b0b4 <pbuf_free>
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
  1282c8:	e24bd008 	sub	sp, fp, #8
  1282cc:	e8bd8810 	pop	{r4, fp, pc}
  1282d0:	001505fc 	.word	0x001505fc
  1282d4:	001505f8 	.word	0x001505f8

001282d8 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  1282d8:	e92d4800 	push	{fp, lr}
  1282dc:	e28db004 	add	fp, sp, #4
  1282e0:	e24dd008 	sub	sp, sp, #8
  1282e4:	e50b0008 	str	r0, [fp, #-8]
  1282e8:	e50b100c 	str	r1, [fp, #-12]
  if ((pcb == NULL) || IP_IS_ANY_TYPE_VAL(pcb->remote_ip)) {
  1282ec:	e51b3008 	ldr	r3, [fp, #-8]
  1282f0:	e3530000 	cmp	r3, #0
  1282f4:	1a000001 	bne	128300 <udp_send+0x28>
    return ERR_VAL;
  1282f8:	e3e03005 	mvn	r3, #5
  1282fc:	ea000007 	b	128320 <udp_send+0x48>
  }

  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  128300:	e51b3008 	ldr	r3, [fp, #-8]
  128304:	e2832004 	add	r2, r3, #4
  128308:	e51b3008 	ldr	r3, [fp, #-8]
  12830c:	e1d331b4 	ldrh	r3, [r3, #20]
  128310:	e51b100c 	ldr	r1, [fp, #-12]
  128314:	e51b0008 	ldr	r0, [fp, #-8]
  128318:	eb000003 	bl	12832c <udp_sendto>
  12831c:	e1a03000 	mov	r3, r0
}
  128320:	e1a00003 	mov	r0, r3
  128324:	e24bd004 	sub	sp, fp, #4
  128328:	e8bd8800 	pop	{fp, pc}

0012832c <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  const ip_addr_t *dst_ip, u16_t dst_port)
{
  12832c:	e92d4800 	push	{fp, lr}
  128330:	e28db004 	add	fp, sp, #4
  128334:	e24dd020 	sub	sp, sp, #32
  128338:	e50b0010 	str	r0, [fp, #-16]
  12833c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  128340:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  128344:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  struct netif *netif;
  const ip_addr_t *dst_ip_route = dst_ip;
  128348:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12834c:	e50b3008 	str	r3, [fp, #-8]

  if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
  128350:	e51b3010 	ldr	r3, [fp, #-16]
  128354:	e3530000 	cmp	r3, #0
  128358:	0a000002 	beq	128368 <udp_sendto+0x3c>
  12835c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128360:	e3530000 	cmp	r3, #0
  128364:	1a000001 	bne	128370 <udp_sendto+0x44>
    return ERR_VAL;
  128368:	e3e03005 	mvn	r3, #5
  12836c:	ea00002b 	b	128420 <udp_sendto+0xf4>
  }

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));

#if LWIP_IPV6 || (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS)
  if (ip_addr_ismulticast(dst_ip_route)) {
  128370:	e51b3008 	ldr	r3, [fp, #-8]
  128374:	e5933000 	ldr	r3, [r3]
  128378:	e20330f0 	and	r3, r3, #240	; 0xf0
  12837c:	e35300e0 	cmp	r3, #224	; 0xe0
  128380:	1a00000d 	bne	1283bc <udp_sendto+0x90>
#if LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS
      /* IPv4 does not use source-based routing by default, so we use an
         administratively selected interface for multicast by default.
         However, this can be overridden by setting an interface address
         in pcb->multicast_ip that is used for routing. */
      if (!ip_addr_isany_val(pcb->multicast_ip) &&
  128384:	e51b3010 	ldr	r3, [fp, #-16]
  128388:	e5933018 	ldr	r3, [r3, #24]
  12838c:	e3530000 	cmp	r3, #0
  128390:	0a000009 	beq	1283bc <udp_sendto+0x90>
          !ip4_addr_cmp(ip_2_ip4(&pcb->multicast_ip), IP4_ADDR_BROADCAST)) {
  128394:	e51b3010 	ldr	r3, [fp, #-16]
  128398:	e5932018 	ldr	r2, [r3, #24]
  12839c:	e3093b28 	movw	r3, #39720	; 0x9b28
  1283a0:	e3403014 	movt	r3, #20
  1283a4:	e5933000 	ldr	r3, [r3]
      if (!ip_addr_isany_val(pcb->multicast_ip) &&
  1283a8:	e1520003 	cmp	r2, r3
  1283ac:	0a000002 	beq	1283bc <udp_sendto+0x90>
        dst_ip_route = &pcb->multicast_ip;
  1283b0:	e51b3010 	ldr	r3, [fp, #-16]
  1283b4:	e2833018 	add	r3, r3, #24
  1283b8:	e50b3008 	str	r3, [fp, #-8]
  /* find the outgoing network interface for this packet */
  if(IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
    /* Don't call ip_route() with IP_ANY_TYPE */
    netif = ip_route(IP46_ADDR_ANY(IP_GET_TYPE(dst_ip_route)), dst_ip_route);
  } else {
    netif = ip_route(&pcb->local_ip, dst_ip_route);
  1283bc:	e51b0008 	ldr	r0, [fp, #-8]
  1283c0:	eb0023f2 	bl	131390 <ip4_route>
  1283c4:	e50b000c 	str	r0, [fp, #-12]
  }

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  1283c8:	e51b300c 	ldr	r3, [fp, #-12]
  1283cc:	e3530000 	cmp	r3, #0
  1283d0:	1a000009 	bne	1283fc <udp_sendto+0xd0>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
    ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
    LWIP_DEBUGF(UDP_DEBUG, ("\n"));
    UDP_STATS_INC(udp.rterr);
  1283d4:	e3063840 	movw	r3, #26688	; 0x6840
  1283d8:	e3403057 	movt	r3, #87	; 0x57
  1283dc:	e1d33ab2 	ldrh	r3, [r3, #162]	; 0xa2
  1283e0:	e2833001 	add	r3, r3, #1
  1283e4:	e6ff2073 	uxth	r2, r3
  1283e8:	e3063840 	movw	r3, #26688	; 0x6840
  1283ec:	e3403057 	movt	r3, #87	; 0x57
  1283f0:	e1c32ab2 	strh	r2, [r3, #162]	; 0xa2
    return ERR_RTE;
  1283f4:	e3e03003 	mvn	r3, #3
  1283f8:	ea000008 	b	128420 <udp_sendto+0xf4>
  }
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  1283fc:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
  128400:	e51b300c 	ldr	r3, [fp, #-12]
  128404:	e58d3000 	str	r3, [sp]
  128408:	e1a03002 	mov	r3, r2
  12840c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  128410:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  128414:	e51b0010 	ldr	r0, [fp, #-16]
  128418:	eb000003 	bl	12842c <udp_sendto_if>
  12841c:	e1a03000 	mov	r3, r0
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
  128420:	e1a00003 	mov	r0, r3
  128424:	e24bd004 	sub	sp, fp, #4
  128428:	e8bd8800 	pop	{fp, pc}

0012842c <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
  12842c:	e92d4800 	push	{fp, lr}
  128430:	e28db004 	add	fp, sp, #4
  128434:	e24dd020 	sub	sp, sp, #32
  128438:	e50b0010 	str	r0, [fp, #-16]
  12843c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  128440:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  128444:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
                     u16_t chksum)
{
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  const ip_addr_t *src_ip;

  if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
  128448:	e51b3010 	ldr	r3, [fp, #-16]
  12844c:	e3530000 	cmp	r3, #0
  128450:	0a000002 	beq	128460 <udp_sendto_if+0x34>
  128454:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128458:	e3530000 	cmp	r3, #0
  12845c:	1a000001 	bne	128468 <udp_sendto_if+0x3c>
    return ERR_VAL;
  128460:	e3e03005 	mvn	r3, #5
  128464:	ea000025 	b	128500 <udp_sendto_if+0xd4>
#endif /* LWIP_IPV6 */
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
  128468:	e51b3010 	ldr	r3, [fp, #-16]
  12846c:	e3530000 	cmp	r3, #0
  128470:	0a000008 	beq	128498 <udp_sendto_if+0x6c>
  128474:	e51b3010 	ldr	r3, [fp, #-16]
  128478:	e5933000 	ldr	r3, [r3]
  12847c:	e3530000 	cmp	r3, #0
  128480:	0a000004 	beq	128498 <udp_sendto_if+0x6c>
      ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
  128484:	e51b3010 	ldr	r3, [fp, #-16]
  128488:	e5933000 	ldr	r3, [r3]
  12848c:	e20330f0 	and	r3, r3, #240	; 0xf0
  if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
  128490:	e35300e0 	cmp	r3, #224	; 0xe0
  128494:	1a000003 	bne	1284a8 <udp_sendto_if+0x7c>
    /* if the local_ip is any or multicast
     * use the outgoing network interface IP address as source address */
    src_ip = netif_ip_addr4(netif);
  128498:	e59b3004 	ldr	r3, [fp, #4]
  12849c:	e2833004 	add	r3, r3, #4
  1284a0:	e50b3008 	str	r3, [fp, #-8]
  1284a4:	ea00000a 	b	1284d4 <udp_sendto_if+0xa8>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
  1284a8:	e51b3010 	ldr	r3, [fp, #-16]
  1284ac:	e5932000 	ldr	r2, [r3]
  1284b0:	e59b3004 	ldr	r3, [fp, #4]
  1284b4:	e2833004 	add	r3, r3, #4
  1284b8:	e5933000 	ldr	r3, [r3]
  1284bc:	e1520003 	cmp	r2, r3
  1284c0:	0a000001 	beq	1284cc <udp_sendto_if+0xa0>
      /* local_ip doesn't match, drop the packet */
      return ERR_RTE;
  1284c4:	e3e03003 	mvn	r3, #3
  1284c8:	ea00000c 	b	128500 <udp_sendto_if+0xd4>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &pcb->local_ip;
  1284cc:	e51b3010 	ldr	r3, [fp, #-16]
  1284d0:	e50b3008 	str	r3, [fp, #-8]
  }
#endif /* LWIP_IPV4 */
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
  1284d4:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
  1284d8:	e51b3008 	ldr	r3, [fp, #-8]
  1284dc:	e58d3004 	str	r3, [sp, #4]
  1284e0:	e59b3004 	ldr	r3, [fp, #4]
  1284e4:	e58d3000 	str	r3, [sp]
  1284e8:	e1a03002 	mov	r3, r2
  1284ec:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1284f0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1284f4:	e51b0010 	ldr	r0, [fp, #-16]
  1284f8:	eb000003 	bl	12850c <udp_sendto_if_src>
  1284fc:	e1a03000 	mov	r3, r0
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
  128500:	e1a00003 	mov	r0, r3
  128504:	e24bd004 	sub	sp, fp, #4
  128508:	e8bd8800 	pop	{fp, pc}

0012850c <udp_sendto_if_src>:
/** @ingroup udp_raw
 * Same as @ref udp_sendto_if, but with source address */
err_t
udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
  const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *src_ip)
{
  12850c:	e92d4800 	push	{fp, lr}
  128510:	e28db004 	add	fp, sp, #4
  128514:	e24dd030 	sub	sp, sp, #48	; 0x30
  128518:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12851c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  128520:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  128524:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */
  u8_t ip_proto;
  u8_t ttl;

  if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) ||
  128528:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12852c:	e3530000 	cmp	r3, #0
  128530:	0a000002 	beq	128540 <udp_sendto_if_src+0x34>
  128534:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  128538:	e3530000 	cmp	r3, #0
  12853c:	1a000001 	bne	128548 <udp_sendto_if_src+0x3c>
      !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
    return ERR_VAL;
  128540:	e3e03005 	mvn	r3, #5
  128544:	ea0000be 	b	128844 <udp_sendto_if_src+0x338>
  }

#if LWIP_IPV4 && IP_SOF_BROADCAST
  /* broadcast filter? */
  if (!ip_get_option(pcb, SOF_BROADCAST) &&
  128548:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12854c:	e5d33008 	ldrb	r3, [r3, #8]
  128550:	e2033020 	and	r3, r3, #32
  128554:	e3530000 	cmp	r3, #0
  128558:	1a000009 	bne	128584 <udp_sendto_if_src+0x78>
#if LWIP_IPV6
      IP_IS_V4(dst_ip) &&
#endif /* LWIP_IPV6 */
      ip_addr_isbroadcast(dst_ip, netif)) {
  12855c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  128560:	e5933000 	ldr	r3, [r3]
  128564:	e59b1004 	ldr	r1, [fp, #4]
  128568:	e1a00003 	mov	r0, r3
  12856c:	eb002866 	bl	13270c <ip4_addr_isbroadcast_u32>
  128570:	e1a03000 	mov	r3, r0
  if (!ip_get_option(pcb, SOF_BROADCAST) &&
  128574:	e3530000 	cmp	r3, #0
  128578:	0a000001 	beq	128584 <udp_sendto_if_src+0x78>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
    return ERR_VAL;
  12857c:	e3e03005 	mvn	r3, #5
  128580:	ea0000af 	b	128844 <udp_sendto_if_src+0x338>
  }
#endif /* LWIP_IPV4 && IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  128584:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128588:	e1d331b2 	ldrh	r3, [r3, #18]
  12858c:	e3530000 	cmp	r3, #0
  128590:	1a00000c 	bne	1285c8 <udp_sendto_if_src+0xbc>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  128594:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  128598:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12859c:	e1d331b2 	ldrh	r3, [r3, #18]
  1285a0:	e1a02003 	mov	r2, r3
  1285a4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1285a8:	eb0000a8 	bl	128850 <udp_bind>
  1285ac:	e1a03000 	mov	r3, r0
  1285b0:	e54b300b 	strb	r3, [fp, #-11]
    if (err != ERR_OK) {
  1285b4:	e15b30db 	ldrsb	r3, [fp, #-11]
  1285b8:	e3530000 	cmp	r3, #0
  1285bc:	0a000001 	beq	1285c8 <udp_sendto_if_src+0xbc>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
  1285c0:	e15b30db 	ldrsb	r3, [fp, #-11]
  1285c4:	ea00009e 	b	128844 <udp_sendto_if_src+0x338>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  1285c8:	e3a01008 	mov	r1, #8
  1285cc:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  1285d0:	ebffca99 	bl	11b03c <pbuf_header>
  1285d4:	e1a03000 	mov	r3, r0
  1285d8:	e3530000 	cmp	r3, #0
  1285dc:	0a000011 	beq	128628 <udp_sendto_if_src+0x11c>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  1285e0:	e3a02000 	mov	r2, #0
  1285e4:	e3a01008 	mov	r1, #8
  1285e8:	e3a00001 	mov	r0, #1
  1285ec:	ebffc7a9 	bl	11a498 <pbuf_alloc>
  1285f0:	e50b0008 	str	r0, [fp, #-8]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  1285f4:	e51b3008 	ldr	r3, [fp, #-8]
  1285f8:	e3530000 	cmp	r3, #0
  1285fc:	1a000001 	bne	128608 <udp_sendto_if_src+0xfc>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  128600:	e3e03000 	mvn	r3, #0
  128604:	ea00008e 	b	128844 <udp_sendto_if_src+0x338>
    }
    if (p->tot_len != 0) {
  128608:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12860c:	e1d330b8 	ldrh	r3, [r3, #8]
  128610:	e3530000 	cmp	r3, #0
  128614:	0a000005 	beq	128630 <udp_sendto_if_src+0x124>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
  128618:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  12861c:	e51b0008 	ldr	r0, [fp, #-8]
  128620:	ebffcba4 	bl	11b4b8 <pbuf_chain>
  128624:	ea000001 	b	128630 <udp_sendto_if_src+0x124>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  128628:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12862c:	e50b3008 	str	r3, [fp, #-8]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  128630:	e51b3008 	ldr	r3, [fp, #-8]
  128634:	e1d330ba 	ldrh	r3, [r3, #10]
  128638:	e3530007 	cmp	r3, #7
  12863c:	8a000006 	bhi	12865c <udp_sendto_if_src+0x150>
  128640:	e3080d1c 	movw	r0, #36124	; 0x8d1c
  128644:	e3400014 	movt	r0, #20
  128648:	ebff6ab1 	bl	103114 <rt_kprintf>
  12864c:	e3a01fb7 	mov	r1, #732	; 0x2dc
  128650:	e3080cf0 	movw	r0, #36080	; 0x8cf0
  128654:	e3400014 	movt	r0, #20
  128658:	ebff8a87 	bl	10b07c <sys_arch_assert>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  12865c:	e51b3008 	ldr	r3, [fp, #-8]
  128660:	e5933004 	ldr	r3, [r3, #4]
  128664:	e50b3010 	str	r3, [fp, #-16]
  udphdr->src = lwip_htons(pcb->local_port);
  128668:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12866c:	e1d331b2 	ldrh	r3, [r3, #18]
  128670:	e1a00003 	mov	r0, r3
  128674:	ebffb857 	bl	1167d8 <lwip_htons>
  128678:	e1a03000 	mov	r3, r0
  12867c:	e1a02003 	mov	r2, r3
  128680:	e51b3010 	ldr	r3, [fp, #-16]
  128684:	e1c320b0 	strh	r2, [r3]
  udphdr->dest = lwip_htons(dst_port);
  128688:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
  12868c:	e1a00003 	mov	r0, r3
  128690:	ebffb850 	bl	1167d8 <lwip_htons>
  128694:	e1a03000 	mov	r3, r0
  128698:	e1a02003 	mov	r2, r3
  12869c:	e51b3010 	ldr	r3, [fp, #-16]
  1286a0:	e1c320b2 	strh	r2, [r3, #2]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000;
  1286a4:	e51b3010 	ldr	r3, [fp, #-16]
  1286a8:	e3a02000 	mov	r2, #0
  1286ac:	e5c32006 	strb	r2, [r3, #6]
  1286b0:	e3a02000 	mov	r2, #0
  1286b4:	e5c32007 	strb	r2, [r3, #7]

  /* Multicast Loop? */
#if (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS) || (LWIP_IPV6 && LWIP_IPV6_MLD)
  if (((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) && ip_addr_ismulticast(dst_ip)) {
  1286b8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1286bc:	e5d33010 	ldrb	r3, [r3, #16]
  1286c0:	e2033008 	and	r3, r3, #8
  1286c4:	e3530000 	cmp	r3, #0
  1286c8:	0a00000a 	beq	1286f8 <udp_sendto_if_src+0x1ec>
  1286cc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1286d0:	e5933000 	ldr	r3, [r3]
  1286d4:	e20330f0 	and	r3, r3, #240	; 0xf0
  1286d8:	e35300e0 	cmp	r3, #224	; 0xe0
  1286dc:	1a000005 	bne	1286f8 <udp_sendto_if_src+0x1ec>
    q->flags |= PBUF_FLAG_MCASTLOOP;
  1286e0:	e51b3008 	ldr	r3, [fp, #-8]
  1286e4:	e5d3300d 	ldrb	r3, [r3, #13]
  1286e8:	e3833004 	orr	r3, r3, #4
  1286ec:	e6ef2073 	uxtb	r2, r3
  1286f0:	e51b3008 	ldr	r3, [fp, #-8]
  1286f4:	e5c3200d 	strb	r2, [r3, #13]
    ip_proto = IP_PROTO_UDPLITE;
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = lwip_htons(q->tot_len);
  1286f8:	e51b3008 	ldr	r3, [fp, #-8]
  1286fc:	e1d330b8 	ldrh	r3, [r3, #8]
  128700:	e1a00003 	mov	r0, r3
  128704:	ebffb833 	bl	1167d8 <lwip_htons>
  128708:	e1a03000 	mov	r3, r0
  12870c:	e1a02003 	mov	r2, r3
  128710:	e51b3010 	ldr	r3, [fp, #-16]
  128714:	e1c320b4 	strh	r2, [r3, #4]
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
      /* Checksum is mandatory over IPv6. */
      if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  128718:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12871c:	e5d33010 	ldrb	r3, [r3, #16]
  128720:	e2033001 	and	r3, r3, #1
  128724:	e3530000 	cmp	r3, #0
  128728:	1a000011 	bne	128774 <udp_sendto_if_src+0x268>
          acc = udpchksum + (u16_t)~(chksum);
          udpchksum = FOLD_U32T(acc);
        } else
#endif /* LWIP_CHECKSUM_ON_COPY */
        {
          udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
  12872c:	e51b3008 	ldr	r3, [fp, #-8]
  128730:	e1d320b8 	ldrh	r2, [r3, #8]
  128734:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  128738:	e58d3000 	str	r3, [sp]
  12873c:	e59b3008 	ldr	r3, [fp, #8]
  128740:	e3a01011 	mov	r1, #17
  128744:	e51b0008 	ldr	r0, [fp, #-8]
  128748:	ebffc041 	bl	118854 <ip_chksum_pseudo>
  12874c:	e1a03000 	mov	r3, r0
  128750:	e14b30ba 	strh	r3, [fp, #-10]
            src_ip, dst_ip);
        }

        /* chksum zero must become 0xffff, as zero means 'no checksum' */
        if (udpchksum == 0x0000) {
  128754:	e15b30ba 	ldrh	r3, [fp, #-10]
  128758:	e3530000 	cmp	r3, #0
  12875c:	1a000001 	bne	128768 <udp_sendto_if_src+0x25c>
          udpchksum = 0xffff;
  128760:	e3e03000 	mvn	r3, #0
  128764:	e14b30ba 	strh	r3, [fp, #-10]
        }
        udphdr->chksum = udpchksum;
  128768:	e51b3010 	ldr	r3, [fp, #-16]
  12876c:	e15b20ba 	ldrh	r2, [fp, #-10]
  128770:	e1c320b6 	strh	r2, [r3, #6]
      }
    }
#endif /* CHECKSUM_GEN_UDP */
    ip_proto = IP_PROTO_UDP;
  128774:	e3a03011 	mov	r3, #17
  128778:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  }

  /* Determine TTL to use */
#if LWIP_MULTICAST_TX_OPTIONS
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
  12877c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  128780:	e5933000 	ldr	r3, [r3]
  128784:	e20330f0 	and	r3, r3, #240	; 0xf0
  128788:	e35300e0 	cmp	r3, #224	; 0xe0
  12878c:	1a000002 	bne	12879c <udp_sendto_if_src+0x290>
  128790:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128794:	e5d3301c 	ldrb	r3, [r3, #28]
  128798:	ea000001 	b	1287a4 <udp_sendto_if_src+0x298>
  12879c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1287a0:	e5d3300a 	ldrb	r3, [r3, #10]
  1287a4:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
  /* output to IP */
  NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
  1287a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1287ac:	e5d33009 	ldrb	r3, [r3, #9]
  1287b0:	e55b1012 	ldrb	r1, [fp, #-18]	; 0xffffffee
  1287b4:	e59b2004 	ldr	r2, [fp, #4]
  1287b8:	e58d2008 	str	r2, [sp, #8]
  1287bc:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  1287c0:	e58d2004 	str	r2, [sp, #4]
  1287c4:	e58d3000 	str	r3, [sp]
  1287c8:	e1a03001 	mov	r3, r1
  1287cc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  1287d0:	e59b1008 	ldr	r1, [fp, #8]
  1287d4:	e51b0008 	ldr	r0, [fp, #-8]
  1287d8:	eb00260a 	bl	132008 <ip4_output_if_src>
  1287dc:	e1a03000 	mov	r3, r0
  1287e0:	e54b300b 	strb	r3, [fp, #-11]
  NETIF_SET_HWADDRHINT(netif, NULL);

  /* @todo: must this be increased even if error occurred? */
  MIB2_STATS_INC(mib2.udpoutdatagrams);
  1287e4:	e3063840 	movw	r3, #26688	; 0x6840
  1287e8:	e3403057 	movt	r3, #87	; 0x57
  1287ec:	e593319c 	ldr	r3, [r3, #412]	; 0x19c
  1287f0:	e2832001 	add	r2, r3, #1
  1287f4:	e3063840 	movw	r3, #26688	; 0x6840
  1287f8:	e3403057 	movt	r3, #87	; 0x57
  1287fc:	e583219c 	str	r2, [r3, #412]	; 0x19c

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  128800:	e51b2008 	ldr	r2, [fp, #-8]
  128804:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  128808:	e1520003 	cmp	r2, r3
  12880c:	0a000003 	beq	128820 <udp_sendto_if_src+0x314>
    /* free the header pbuf */
    pbuf_free(q);
  128810:	e51b0008 	ldr	r0, [fp, #-8]
  128814:	ebffca26 	bl	11b0b4 <pbuf_free>
    q = NULL;
  128818:	e3a03000 	mov	r3, #0
  12881c:	e50b3008 	str	r3, [fp, #-8]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  128820:	e3063840 	movw	r3, #26688	; 0x6840
  128824:	e3403057 	movt	r3, #87	; 0x57
  128828:	e1d339b4 	ldrh	r3, [r3, #148]	; 0x94
  12882c:	e2833001 	add	r3, r3, #1
  128830:	e6ff2073 	uxth	r2, r3
  128834:	e3063840 	movw	r3, #26688	; 0x6840
  128838:	e3403057 	movt	r3, #87	; 0x57
  12883c:	e1c329b4 	strh	r2, [r3, #148]	; 0x94
  return err;
  128840:	e15b30db 	ldrsb	r3, [fp, #-11]
}
  128844:	e1a00003 	mov	r0, r3
  128848:	e24bd004 	sub	sp, fp, #4
  12884c:	e8bd8800 	pop	{fp, pc}

00128850 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
  128850:	e92d4800 	push	{fp, lr}
  128854:	e28db004 	add	fp, sp, #4
  128858:	e24dd018 	sub	sp, sp, #24
  12885c:	e50b0010 	str	r0, [fp, #-16]
  128860:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  128864:	e1a03002 	mov	r3, r2
  128868:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  struct udp_pcb *ipcb;
  u8_t rebind;

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
  12886c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  128870:	e3530000 	cmp	r3, #0
  128874:	1a000002 	bne	128884 <udp_bind+0x34>
    ipaddr = IP4_ADDR_ANY;
  128878:	e3093b24 	movw	r3, #39716	; 0x9b24
  12887c:	e3403014 	movt	r3, #20
  128880:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  }
#endif /* LWIP_IPV4 */

  /* still need to check for ipaddr == NULL in IPv6 only case */
  if ((pcb == NULL) || (ipaddr == NULL)) {
  128884:	e51b3010 	ldr	r3, [fp, #-16]
  128888:	e3530000 	cmp	r3, #0
  12888c:	0a000002 	beq	12889c <udp_bind+0x4c>
  128890:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  128894:	e3530000 	cmp	r3, #0
  128898:	1a000001 	bne	1288a4 <udp_bind+0x54>
    return ERR_VAL;
  12889c:	e3e03005 	mvn	r3, #5
  1288a0:	ea00005d 	b	128a1c <udp_bind+0x1cc>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  1288a4:	e3a03000 	mov	r3, #0
  1288a8:	e54b3009 	strb	r3, [fp, #-9]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  1288ac:	e3063a48 	movw	r3, #27208	; 0x6a48
  1288b0:	e3403057 	movt	r3, #87	; 0x57
  1288b4:	e5933000 	ldr	r3, [r3]
  1288b8:	e50b3008 	str	r3, [fp, #-8]
  1288bc:	ea000009 	b	1288e8 <udp_bind+0x98>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  1288c0:	e51b2010 	ldr	r2, [fp, #-16]
  1288c4:	e51b3008 	ldr	r3, [fp, #-8]
  1288c8:	e1520003 	cmp	r2, r3
  1288cc:	1a000002 	bne	1288dc <udp_bind+0x8c>
      rebind = 1;
  1288d0:	e3a03001 	mov	r3, #1
  1288d4:	e54b3009 	strb	r3, [fp, #-9]
      break;
  1288d8:	ea000005 	b	1288f4 <udp_bind+0xa4>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  1288dc:	e51b3008 	ldr	r3, [fp, #-8]
  1288e0:	e593300c 	ldr	r3, [r3, #12]
  1288e4:	e50b3008 	str	r3, [fp, #-8]
  1288e8:	e51b3008 	ldr	r3, [fp, #-8]
  1288ec:	e3530000 	cmp	r3, #0
  1288f0:	1afffff2 	bne	1288c0 <udp_bind+0x70>
    }
  }

  /* no port specified? */
  if (port == 0) {
  1288f4:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  1288f8:	e3530000 	cmp	r3, #0
  1288fc:	1a000007 	bne	128920 <udp_bind+0xd0>
    port = udp_new_port();
  128900:	ebfffca8 	bl	127ba8 <udp_new_port>
  128904:	e1a03000 	mov	r3, r0
  128908:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
    if (port == 0) {
  12890c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  128910:	e3530000 	cmp	r3, #0
  128914:	1a000027 	bne	1289b8 <udp_bind+0x168>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  128918:	e3e03007 	mvn	r3, #7
  12891c:	ea00003e 	b	128a1c <udp_bind+0x1cc>
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  128920:	e3063a48 	movw	r3, #27208	; 0x6a48
  128924:	e3403057 	movt	r3, #87	; 0x57
  128928:	e5933000 	ldr	r3, [r3]
  12892c:	e50b3008 	str	r3, [fp, #-8]
  128930:	ea00001d 	b	1289ac <udp_bind+0x15c>
      if (pcb != ipcb) {
  128934:	e51b2010 	ldr	r2, [fp, #-16]
  128938:	e51b3008 	ldr	r3, [fp, #-8]
  12893c:	e1520003 	cmp	r2, r3
  128940:	0a000016 	beq	1289a0 <udp_bind+0x150>
      /* By default, we don't allow to bind to a port that any other udp
         PCB is already bound to, unless *all* PCBs with that port have tha
         REUSEADDR flag set. */
#if SO_REUSE
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
  128944:	e51b3010 	ldr	r3, [fp, #-16]
  128948:	e5d33008 	ldrb	r3, [r3, #8]
  12894c:	e2033004 	and	r3, r3, #4
  128950:	e3530000 	cmp	r3, #0
  128954:	0a000004 	beq	12896c <udp_bind+0x11c>
            !ip_get_option(ipcb, SOF_REUSEADDR))
  128958:	e51b3008 	ldr	r3, [fp, #-8]
  12895c:	e5d33008 	ldrb	r3, [r3, #8]
  128960:	e2033004 	and	r3, r3, #4
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
  128964:	e3530000 	cmp	r3, #0
  128968:	1a00000c 	bne	1289a0 <udp_bind+0x150>
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
  12896c:	e51b3008 	ldr	r3, [fp, #-8]
  128970:	e1d331b2 	ldrh	r3, [r3, #18]
  128974:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  128978:	e1520003 	cmp	r2, r3
  12897c:	1a000007 	bne	1289a0 <udp_bind+0x150>
              /* IP address matches? */
              ip_addr_cmp(&ipcb->local_ip, ipaddr)) {
  128980:	e51b3008 	ldr	r3, [fp, #-8]
  128984:	e5932000 	ldr	r2, [r3]
  128988:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12898c:	e5933000 	ldr	r3, [r3]
          if ((ipcb->local_port == port) &&
  128990:	e1520003 	cmp	r2, r3
  128994:	1a000001 	bne	1289a0 <udp_bind+0x150>
            /* other PCB already binds to this local IP and port */
            LWIP_DEBUGF(UDP_DEBUG,
                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
            return ERR_USE;
  128998:	e3e03007 	mvn	r3, #7
  12899c:	ea00001e 	b	128a1c <udp_bind+0x1cc>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  1289a0:	e51b3008 	ldr	r3, [fp, #-8]
  1289a4:	e593300c 	ldr	r3, [r3, #12]
  1289a8:	e50b3008 	str	r3, [fp, #-8]
  1289ac:	e51b3008 	ldr	r3, [fp, #-8]
  1289b0:	e3530000 	cmp	r3, #0
  1289b4:	1affffde 	bne	128934 <udp_bind+0xe4>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
  1289b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1289bc:	e3530000 	cmp	r3, #0
  1289c0:	0a000002 	beq	1289d0 <udp_bind+0x180>
  1289c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1289c8:	e5933000 	ldr	r3, [r3]
  1289cc:	ea000000 	b	1289d4 <udp_bind+0x184>
  1289d0:	e3a03000 	mov	r3, #0
  1289d4:	e51b2010 	ldr	r2, [fp, #-16]
  1289d8:	e5823000 	str	r3, [r2]

  pcb->local_port = port;
  1289dc:	e51b3010 	ldr	r3, [fp, #-16]
  1289e0:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  1289e4:	e1c321b2 	strh	r2, [r3, #18]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  1289e8:	e55b3009 	ldrb	r3, [fp, #-9]
  1289ec:	e3530000 	cmp	r3, #0
  1289f0:	1a000008 	bne	128a18 <udp_bind+0x1c8>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  1289f4:	e3063a48 	movw	r3, #27208	; 0x6a48
  1289f8:	e3403057 	movt	r3, #87	; 0x57
  1289fc:	e5932000 	ldr	r2, [r3]
  128a00:	e51b3010 	ldr	r3, [fp, #-16]
  128a04:	e583200c 	str	r2, [r3, #12]
    udp_pcbs = pcb;
  128a08:	e3063a48 	movw	r3, #27208	; 0x6a48
  128a0c:	e3403057 	movt	r3, #87	; 0x57
  128a10:	e51b2010 	ldr	r2, [fp, #-16]
  128a14:	e5832000 	str	r2, [r3]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, &pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
  128a18:	e3a03000 	mov	r3, #0
}
  128a1c:	e1a00003 	mov	r0, r3
  128a20:	e24bd004 	sub	sp, fp, #4
  128a24:	e8bd8800 	pop	{fp, pc}

00128a28 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
  128a28:	e92d4800 	push	{fp, lr}
  128a2c:	e28db004 	add	fp, sp, #4
  128a30:	e24dd018 	sub	sp, sp, #24
  128a34:	e50b0010 	str	r0, [fp, #-16]
  128a38:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  128a3c:	e1a03002 	mov	r3, r2
  128a40:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  struct udp_pcb *ipcb;

  if ((pcb == NULL) || (ipaddr == NULL)) {
  128a44:	e51b3010 	ldr	r3, [fp, #-16]
  128a48:	e3530000 	cmp	r3, #0
  128a4c:	0a000002 	beq	128a5c <udp_connect+0x34>
  128a50:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  128a54:	e3530000 	cmp	r3, #0
  128a58:	1a000001 	bne	128a64 <udp_connect+0x3c>
    return ERR_VAL;
  128a5c:	e3e03005 	mvn	r3, #5
  128a60:	ea00003d 	b	128b5c <udp_connect+0x134>
  }

  if (pcb->local_port == 0) {
  128a64:	e51b3010 	ldr	r3, [fp, #-16]
  128a68:	e1d331b2 	ldrh	r3, [r3, #18]
  128a6c:	e3530000 	cmp	r3, #0
  128a70:	1a00000c 	bne	128aa8 <udp_connect+0x80>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  128a74:	e51b1010 	ldr	r1, [fp, #-16]
  128a78:	e51b3010 	ldr	r3, [fp, #-16]
  128a7c:	e1d331b2 	ldrh	r3, [r3, #18]
  128a80:	e1a02003 	mov	r2, r3
  128a84:	e51b0010 	ldr	r0, [fp, #-16]
  128a88:	ebffff70 	bl	128850 <udp_bind>
  128a8c:	e1a03000 	mov	r3, r0
  128a90:	e54b3009 	strb	r3, [fp, #-9]
    if (err != ERR_OK) {
  128a94:	e15b30d9 	ldrsb	r3, [fp, #-9]
  128a98:	e3530000 	cmp	r3, #0
  128a9c:	0a000001 	beq	128aa8 <udp_connect+0x80>
      return err;
  128aa0:	e15b30d9 	ldrsb	r3, [fp, #-9]
  128aa4:	ea00002c 	b	128b5c <udp_connect+0x134>
    }
  }

  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
  128aa8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  128aac:	e3530000 	cmp	r3, #0
  128ab0:	0a000002 	beq	128ac0 <udp_connect+0x98>
  128ab4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  128ab8:	e5933000 	ldr	r3, [r3]
  128abc:	ea000000 	b	128ac4 <udp_connect+0x9c>
  128ac0:	e3a03000 	mov	r3, #0
  128ac4:	e51b2010 	ldr	r2, [fp, #-16]
  128ac8:	e5823004 	str	r3, [r2, #4]
  pcb->remote_port = port;
  128acc:	e51b3010 	ldr	r3, [fp, #-16]
  128ad0:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  128ad4:	e1c321b4 	strh	r2, [r3, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
  128ad8:	e51b3010 	ldr	r3, [fp, #-16]
  128adc:	e5d33010 	ldrb	r3, [r3, #16]
  128ae0:	e3833004 	orr	r3, r3, #4
  128ae4:	e6ef2073 	uxtb	r2, r3
  128ae8:	e51b3010 	ldr	r3, [fp, #-16]
  128aec:	e5c32010 	strb	r2, [r3, #16]
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                      &pcb->remote_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  128af0:	e3063a48 	movw	r3, #27208	; 0x6a48
  128af4:	e3403057 	movt	r3, #87	; 0x57
  128af8:	e5933000 	ldr	r3, [r3]
  128afc:	e50b3008 	str	r3, [fp, #-8]
  128b00:	ea000008 	b	128b28 <udp_connect+0x100>
    if (pcb == ipcb) {
  128b04:	e51b2010 	ldr	r2, [fp, #-16]
  128b08:	e51b3008 	ldr	r3, [fp, #-8]
  128b0c:	e1520003 	cmp	r2, r3
  128b10:	1a000001 	bne	128b1c <udp_connect+0xf4>
      /* already on the list, just return */
      return ERR_OK;
  128b14:	e3a03000 	mov	r3, #0
  128b18:	ea00000f 	b	128b5c <udp_connect+0x134>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  128b1c:	e51b3008 	ldr	r3, [fp, #-8]
  128b20:	e593300c 	ldr	r3, [r3, #12]
  128b24:	e50b3008 	str	r3, [fp, #-8]
  128b28:	e51b3008 	ldr	r3, [fp, #-8]
  128b2c:	e3530000 	cmp	r3, #0
  128b30:	1afffff3 	bne	128b04 <udp_connect+0xdc>
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  128b34:	e3063a48 	movw	r3, #27208	; 0x6a48
  128b38:	e3403057 	movt	r3, #87	; 0x57
  128b3c:	e5932000 	ldr	r2, [r3]
  128b40:	e51b3010 	ldr	r3, [fp, #-16]
  128b44:	e583200c 	str	r2, [r3, #12]
  udp_pcbs = pcb;
  128b48:	e3063a48 	movw	r3, #27208	; 0x6a48
  128b4c:	e3403057 	movt	r3, #87	; 0x57
  128b50:	e51b2010 	ldr	r2, [fp, #-16]
  128b54:	e5832000 	str	r2, [r3]
  return ERR_OK;
  128b58:	e3a03000 	mov	r3, #0
}
  128b5c:	e1a00003 	mov	r0, r3
  128b60:	e24bd004 	sub	sp, fp, #4
  128b64:	e8bd8800 	pop	{fp, pc}

00128b68 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  128b68:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  128b6c:	e28db000 	add	fp, sp, #0
  128b70:	e24dd00c 	sub	sp, sp, #12
  128b74:	e50b0008 	str	r0, [fp, #-8]
#if LWIP_IPV4 && LWIP_IPV6
  if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
    ip_addr_copy(pcb->remote_ip, *IP_ANY_TYPE);
  } else {
#endif
    ip_addr_set_any(IP_IS_V6_VAL(pcb->remote_ip), &pcb->remote_ip);
  128b78:	e51b3008 	ldr	r3, [fp, #-8]
  128b7c:	e3a02000 	mov	r2, #0
  128b80:	e5832004 	str	r2, [r3, #4]
#if LWIP_IPV4 && LWIP_IPV6
  }
#endif
  pcb->remote_port = 0;
  128b84:	e51b3008 	ldr	r3, [fp, #-8]
  128b88:	e3a02000 	mov	r2, #0
  128b8c:	e1c321b4 	strh	r2, [r3, #20]
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  128b90:	e51b3008 	ldr	r3, [fp, #-8]
  128b94:	e5d33010 	ldrb	r3, [r3, #16]
  128b98:	e3c33004 	bic	r3, r3, #4
  128b9c:	e6ef2073 	uxtb	r2, r3
  128ba0:	e51b3008 	ldr	r3, [fp, #-8]
  128ba4:	e5c32010 	strb	r2, [r3, #16]
}
  128ba8:	e320f000 	nop	{0}
  128bac:	e28bd000 	add	sp, fp, #0
  128bb0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  128bb4:	e12fff1e 	bx	lr

00128bb8 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  128bb8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  128bbc:	e28db000 	add	fp, sp, #0
  128bc0:	e24dd014 	sub	sp, sp, #20
  128bc4:	e50b0008 	str	r0, [fp, #-8]
  128bc8:	e50b100c 	str	r1, [fp, #-12]
  128bcc:	e50b2010 	str	r2, [fp, #-16]
  /* remember recv() callback and user data */
  pcb->recv = recv;
  128bd0:	e51b3008 	ldr	r3, [fp, #-8]
  128bd4:	e51b200c 	ldr	r2, [fp, #-12]
  128bd8:	e5832020 	str	r2, [r3, #32]
  pcb->recv_arg = recv_arg;
  128bdc:	e51b3008 	ldr	r3, [fp, #-8]
  128be0:	e51b2010 	ldr	r2, [fp, #-16]
  128be4:	e5832024 	str	r2, [r3, #36]	; 0x24
}
  128be8:	e320f000 	nop	{0}
  128bec:	e28bd000 	add	sp, fp, #0
  128bf0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  128bf4:	e12fff1e 	bx	lr

00128bf8 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  128bf8:	e92d4800 	push	{fp, lr}
  128bfc:	e28db004 	add	fp, sp, #4
  128c00:	e24dd010 	sub	sp, sp, #16
  128c04:	e50b0010 	str	r0, [fp, #-16]
  struct udp_pcb *pcb2;

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  128c08:	e3063a48 	movw	r3, #27208	; 0x6a48
  128c0c:	e3403057 	movt	r3, #87	; 0x57
  128c10:	e5933000 	ldr	r3, [r3]
  128c14:	e51b2010 	ldr	r2, [fp, #-16]
  128c18:	e1520003 	cmp	r2, r3
  128c1c:	1a000007 	bne	128c40 <udp_remove+0x48>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  128c20:	e3063a48 	movw	r3, #27208	; 0x6a48
  128c24:	e3403057 	movt	r3, #87	; 0x57
  128c28:	e5933000 	ldr	r3, [r3]
  128c2c:	e593200c 	ldr	r2, [r3, #12]
  128c30:	e3063a48 	movw	r3, #27208	; 0x6a48
  128c34:	e3403057 	movt	r3, #87	; 0x57
  128c38:	e5832000 	str	r2, [r3]
  128c3c:	ea000018 	b	128ca4 <udp_remove+0xac>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  128c40:	e3063a48 	movw	r3, #27208	; 0x6a48
  128c44:	e3403057 	movt	r3, #87	; 0x57
  128c48:	e5933000 	ldr	r3, [r3]
  128c4c:	e50b3008 	str	r3, [fp, #-8]
  128c50:	ea000010 	b	128c98 <udp_remove+0xa0>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  128c54:	e51b3008 	ldr	r3, [fp, #-8]
  128c58:	e593300c 	ldr	r3, [r3, #12]
  128c5c:	e3530000 	cmp	r3, #0
  128c60:	0a000009 	beq	128c8c <udp_remove+0x94>
  128c64:	e51b3008 	ldr	r3, [fp, #-8]
  128c68:	e593300c 	ldr	r3, [r3, #12]
  128c6c:	e51b2010 	ldr	r2, [fp, #-16]
  128c70:	e1520003 	cmp	r2, r3
  128c74:	1a000004 	bne	128c8c <udp_remove+0x94>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  128c78:	e51b3010 	ldr	r3, [fp, #-16]
  128c7c:	e593200c 	ldr	r2, [r3, #12]
  128c80:	e51b3008 	ldr	r3, [fp, #-8]
  128c84:	e583200c 	str	r2, [r3, #12]
        break;
  128c88:	ea000005 	b	128ca4 <udp_remove+0xac>
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  128c8c:	e51b3008 	ldr	r3, [fp, #-8]
  128c90:	e593300c 	ldr	r3, [r3, #12]
  128c94:	e50b3008 	str	r3, [fp, #-8]
  128c98:	e51b3008 	ldr	r3, [fp, #-8]
  128c9c:	e3530000 	cmp	r3, #0
  128ca0:	1affffeb 	bne	128c54 <udp_remove+0x5c>
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
  128ca4:	e51b1010 	ldr	r1, [fp, #-16]
  128ca8:	e3a00001 	mov	r0, #1
  128cac:	ebffc1f2 	bl	11947c <memp_free>
}
  128cb0:	e320f000 	nop	{0}
  128cb4:	e24bd004 	sub	sp, fp, #4
  128cb8:	e8bd8800 	pop	{fp, pc}

00128cbc <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  128cbc:	e92d4800 	push	{fp, lr}
  128cc0:	e28db004 	add	fp, sp, #4
  128cc4:	e24dd008 	sub	sp, sp, #8
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
  128cc8:	e3002452 	movw	r2, #1106	; 0x452
  128ccc:	e3081cf0 	movw	r1, #36080	; 0x8cf0
  128cd0:	e3401014 	movt	r1, #20
  128cd4:	e3a00001 	mov	r0, #1
  128cd8:	ebffc17f 	bl	1192dc <memp_malloc_fn>
  128cdc:	e50b0008 	str	r0, [fp, #-8]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  128ce0:	e51b3008 	ldr	r3, [fp, #-8]
  128ce4:	e3530000 	cmp	r3, #0
  128ce8:	0a000009 	beq	128d14 <udp_new+0x58>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  128cec:	e3a02028 	mov	r2, #40	; 0x28
  128cf0:	e3a01000 	mov	r1, #0
  128cf4:	e51b0008 	ldr	r0, [fp, #-8]
  128cf8:	eb0061dd 	bl	141474 <memset>
    pcb->ttl = UDP_TTL;
  128cfc:	e51b3008 	ldr	r3, [fp, #-8]
  128d00:	e3e02000 	mvn	r2, #0
  128d04:	e5c3200a 	strb	r2, [r3, #10]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
  128d08:	e51b3008 	ldr	r3, [fp, #-8]
  128d0c:	e3e02000 	mvn	r2, #0
  128d10:	e5c3201c 	strb	r2, [r3, #28]
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
  128d14:	e51b3008 	ldr	r3, [fp, #-8]
}
  128d18:	e1a00003 	mov	r0, r3
  128d1c:	e24bd004 	sub	sp, fp, #4
  128d20:	e8bd8800 	pop	{fp, pc}

00128d24 <udp_new_ip_type>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new_ip_type(u8_t type)
{
  128d24:	e92d4800 	push	{fp, lr}
  128d28:	e28db004 	add	fp, sp, #4
  128d2c:	e24dd010 	sub	sp, sp, #16
  128d30:	e1a03000 	mov	r3, r0
  128d34:	e54b300d 	strb	r3, [fp, #-13]
  struct udp_pcb *pcb;
  pcb = udp_new();
  128d38:	ebffffdf 	bl	128cbc <udp_new>
  128d3c:	e50b0008 	str	r0, [fp, #-8]
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
  128d40:	e51b3008 	ldr	r3, [fp, #-8]
}
  128d44:	e1a00003 	mov	r0, r3
  128d48:	e24bd004 	sub	sp, fp, #4
  128d4c:	e8bd8800 	pop	{fp, pc}

00128d50 <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
  128d50:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  128d54:	e28db000 	add	fp, sp, #0
  128d58:	e24dd014 	sub	sp, sp, #20
  128d5c:	e50b0010 	str	r0, [fp, #-16]
  128d60:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct udp_pcb* upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
  128d64:	e51b3010 	ldr	r3, [fp, #-16]
  128d68:	e3530000 	cmp	r3, #0
  128d6c:	0a00001f 	beq	128df0 <udp_netif_ip_addr_changed+0xa0>
  128d70:	e51b3010 	ldr	r3, [fp, #-16]
  128d74:	e5933000 	ldr	r3, [r3]
  128d78:	e3530000 	cmp	r3, #0
  128d7c:	0a00001b 	beq	128df0 <udp_netif_ip_addr_changed+0xa0>
  128d80:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  128d84:	e3530000 	cmp	r3, #0
  128d88:	0a000018 	beq	128df0 <udp_netif_ip_addr_changed+0xa0>
  128d8c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  128d90:	e5933000 	ldr	r3, [r3]
  128d94:	e3530000 	cmp	r3, #0
  128d98:	0a000014 	beq	128df0 <udp_netif_ip_addr_changed+0xa0>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
  128d9c:	e3063a48 	movw	r3, #27208	; 0x6a48
  128da0:	e3403057 	movt	r3, #87	; 0x57
  128da4:	e5933000 	ldr	r3, [r3]
  128da8:	e50b3008 	str	r3, [fp, #-8]
  128dac:	ea00000c 	b	128de4 <udp_netif_ip_addr_changed+0x94>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
  128db0:	e51b3008 	ldr	r3, [fp, #-8]
  128db4:	e5932000 	ldr	r2, [r3]
  128db8:	e51b3010 	ldr	r3, [fp, #-16]
  128dbc:	e5933000 	ldr	r3, [r3]
  128dc0:	e1520003 	cmp	r2, r3
  128dc4:	1a000003 	bne	128dd8 <udp_netif_ip_addr_changed+0x88>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
  128dc8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  128dcc:	e5932000 	ldr	r2, [r3]
  128dd0:	e51b3008 	ldr	r3, [fp, #-8]
  128dd4:	e5832000 	str	r2, [r3]
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
  128dd8:	e51b3008 	ldr	r3, [fp, #-8]
  128ddc:	e593300c 	ldr	r3, [r3, #12]
  128de0:	e50b3008 	str	r3, [fp, #-8]
  128de4:	e51b3008 	ldr	r3, [fp, #-8]
  128de8:	e3530000 	cmp	r3, #0
  128dec:	1affffef 	bne	128db0 <udp_netif_ip_addr_changed+0x60>
      }
    }
  }
}
  128df0:	e320f000 	nop	{0}
  128df4:	e28bd000 	add	sp, fp, #0
  128df8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  128dfc:	e12fff1e 	bx	lr

00128e00 <ethernet_input>:
 * @see ETHARP_SUPPORT_VLAN
 * @see LWIP_HOOK_VLAN_CHECK
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  128e00:	e92d4800 	push	{fp, lr}
  128e04:	e28db004 	add	fp, sp, #4
  128e08:	e24dd018 	sub	sp, sp, #24
  128e0c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  128e10:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  struct eth_hdr* ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
  128e14:	e3a0300e 	mov	r3, #14
  128e18:	e14b30b6 	strh	r3, [fp, #-6]
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
  128e1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128e20:	e1d330ba 	ldrh	r3, [r3, #10]
  128e24:	e353000e 	cmp	r3, #14
  128e28:	8a000015 	bhi	128e84 <ethernet_input+0x84>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
  128e2c:	e3063840 	movw	r3, #26688	; 0x6840
  128e30:	e3403057 	movt	r3, #87	; 0x57
  128e34:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
  128e38:	e2833001 	add	r3, r3, #1
  128e3c:	e6ff2073 	uxth	r2, r3
  128e40:	e3063840 	movw	r3, #26688	; 0x6840
  128e44:	e3403057 	movt	r3, #87	; 0x57
  128e48:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
  128e4c:	e3063840 	movw	r3, #26688	; 0x6840
  128e50:	e3403057 	movt	r3, #87	; 0x57
  128e54:	e1d331be 	ldrh	r3, [r3, #30]
  128e58:	e2833001 	add	r3, r3, #1
  128e5c:	e6ff2073 	uxth	r2, r3
  128e60:	e3063840 	movw	r3, #26688	; 0x6840
  128e64:	e3403057 	movt	r3, #87	; 0x57
  128e68:	e1c321be 	strh	r2, [r3, #30]
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
  128e6c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  128e70:	e5933060 	ldr	r3, [r3, #96]	; 0x60
  128e74:	e2832001 	add	r2, r3, #1
  128e78:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  128e7c:	e5832060 	str	r2, [r3, #96]	; 0x60
    goto free_and_return;
  128e80:	ea000096 	b	1290e0 <ethernet_input+0x2e0>
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
  128e84:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128e88:	e5933004 	ldr	r3, [r3, #4]
  128e8c:	e50b300c 	str	r3, [fp, #-12]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0],  (unsigned)ethhdr->src.addr[1],  (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3],  (unsigned)ethhdr->src.addr[4],  (unsigned)ethhdr->src.addr[5],
     lwip_htons(ethhdr->type)));

  type = ethhdr->type;
  128e90:	e51b300c 	ldr	r3, [fp, #-12]
  128e94:	e5d3200c 	ldrb	r2, [r3, #12]
  128e98:	e5d3300d 	ldrb	r3, [r3, #13]
  128e9c:	e1a03403 	lsl	r3, r3, #8
  128ea0:	e1833002 	orr	r3, r3, r2
  128ea4:	e14b30be 	strh	r3, [fp, #-14]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
  128ea8:	e51b300c 	ldr	r3, [fp, #-12]
  128eac:	e5d33000 	ldrb	r3, [r3]
  128eb0:	e2033001 	and	r3, r3, #1
  128eb4:	e3530000 	cmp	r3, #0
  128eb8:	0a000021 	beq	128f44 <ethernet_input+0x144>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
  128ebc:	e51b300c 	ldr	r3, [fp, #-12]
  128ec0:	e5d33000 	ldrb	r3, [r3]
  128ec4:	e3530001 	cmp	r3, #1
  128ec8:	1a00000e 	bne	128f08 <ethernet_input+0x108>
#if LWIP_IPV4
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
  128ecc:	e51b300c 	ldr	r3, [fp, #-12]
  128ed0:	e5d33001 	ldrb	r3, [r3, #1]
  128ed4:	e3530000 	cmp	r3, #0
  128ed8:	1a000019 	bne	128f44 <ethernet_input+0x144>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
  128edc:	e51b300c 	ldr	r3, [fp, #-12]
  128ee0:	e5d33002 	ldrb	r3, [r3, #2]
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
  128ee4:	e353005e 	cmp	r3, #94	; 0x5e
  128ee8:	1a000015 	bne	128f44 <ethernet_input+0x144>
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
  128eec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128ef0:	e5d3300d 	ldrb	r3, [r3, #13]
  128ef4:	e3833010 	orr	r3, r3, #16
  128ef8:	e6ef2073 	uxtb	r2, r3
  128efc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128f00:	e5c3200d 	strb	r2, [r3, #13]
  128f04:	ea00000e 	b	128f44 <ethernet_input+0x144>
             (ethhdr->dest.addr[1] == LL_IP6_MULTICAST_ADDR_1)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
  128f08:	e51b300c 	ldr	r3, [fp, #-12]
  128f0c:	e3a02006 	mov	r2, #6
  128f10:	e3081d4c 	movw	r1, #36172	; 0x8d4c
  128f14:	e3401014 	movt	r1, #20
  128f18:	e1a00003 	mov	r0, r3
  128f1c:	eb0060db 	bl	141290 <memcmp>
  128f20:	e1a03000 	mov	r3, r0
  128f24:	e3530000 	cmp	r3, #0
  128f28:	1a000005 	bne	128f44 <ethernet_input+0x144>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
  128f2c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128f30:	e5d3300d 	ldrb	r3, [r3, #13]
  128f34:	e3833008 	orr	r3, r3, #8
  128f38:	e6ef2073 	uxtb	r2, r3
  128f3c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128f40:	e5c3200d 	strb	r2, [r3, #13]
    }
  }

  switch (type) {
  128f44:	e15b30be 	ldrh	r3, [fp, #-14]
  128f48:	e3530008 	cmp	r3, #8
  128f4c:	0a000003 	beq	128f60 <ethernet_input+0x160>
  128f50:	e3002608 	movw	r2, #1544	; 0x608
  128f54:	e1530002 	cmp	r3, r2
  128f58:	0a000019 	beq	128fc4 <ethernet_input+0x1c4>
  128f5c:	ea000042 	b	12906c <ethernet_input+0x26c>
#if LWIP_IPV4 && LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
  128f60:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  128f64:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  128f68:	e2033008 	and	r3, r3, #8
  128f6c:	e3530000 	cmp	r3, #0
  128f70:	0a000055 	beq	1290cc <ethernet_input+0x2cc>
        goto free_and_return;
      }
      /* skip Ethernet header */
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
  128f74:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128f78:	e1d330ba 	ldrh	r3, [r3, #10]
  128f7c:	e1a02003 	mov	r2, r3
  128f80:	e15b30f6 	ldrsh	r3, [fp, #-6]
  128f84:	e1520003 	cmp	r2, r3
  128f88:	ba000051 	blt	1290d4 <ethernet_input+0x2d4>
  128f8c:	e15b30b6 	ldrh	r3, [fp, #-6]
  128f90:	e2633000 	rsb	r3, r3, #0
  128f94:	e6ff3073 	uxth	r3, r3
  128f98:	e6bf3073 	sxth	r3, r3
  128f9c:	e1a01003 	mov	r1, r3
  128fa0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  128fa4:	ebffc824 	bl	11b03c <pbuf_header>
  128fa8:	e1a03000 	mov	r3, r0
  128fac:	e3530000 	cmp	r3, #0
  128fb0:	1a000047 	bne	1290d4 <ethernet_input+0x2d4>
          p->tot_len, ip_hdr_offset));
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("Can't move over header in packet"));
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip4_input(p, netif);
  128fb4:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  128fb8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  128fbc:	eb00219b 	bl	131630 <ip4_input>
      }
      break;
  128fc0:	ea00003f 	b	1290c4 <ethernet_input+0x2c4>

    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
  128fc4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  128fc8:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  128fcc:	e2033008 	and	r3, r3, #8
  128fd0:	e3530000 	cmp	r3, #0
  128fd4:	0a000040 	beq	1290dc <ethernet_input+0x2dc>
        goto free_and_return;
      }
      /* skip Ethernet header */
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
  128fd8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  128fdc:	e1d330ba 	ldrh	r3, [r3, #10]
  128fe0:	e1a02003 	mov	r2, r3
  128fe4:	e15b30f6 	ldrsh	r3, [fp, #-6]
  128fe8:	e1520003 	cmp	r2, r3
  128fec:	ba000009 	blt	129018 <ethernet_input+0x218>
  128ff0:	e15b30b6 	ldrh	r3, [fp, #-6]
  128ff4:	e2633000 	rsb	r3, r3, #0
  128ff8:	e6ff3073 	uxth	r3, r3
  128ffc:	e6bf3073 	sxth	r3, r3
  129000:	e1a01003 	mov	r1, r3
  129004:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  129008:	ebffc80b 	bl	11b03c <pbuf_header>
  12900c:	e1a03000 	mov	r3, r0
  129010:	e3530000 	cmp	r3, #0
  129014:	0a000010 	beq	12905c <ethernet_input+0x25c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
          ("ethernet_input: ARP response packet dropped, too short (%"S16_F"/%"S16_F")\n",
          p->tot_len, ip_hdr_offset));
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("Can't move over header in packet"));
        ETHARP_STATS_INC(etharp.lenerr);
  129018:	e3063840 	movw	r3, #26688	; 0x6840
  12901c:	e3403057 	movt	r3, #87	; 0x57
  129020:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
  129024:	e2833001 	add	r3, r3, #1
  129028:	e6ff2073 	uxth	r2, r3
  12902c:	e3063840 	movw	r3, #26688	; 0x6840
  129030:	e3403057 	movt	r3, #87	; 0x57
  129034:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
        ETHARP_STATS_INC(etharp.drop);
  129038:	e3063840 	movw	r3, #26688	; 0x6840
  12903c:	e3403057 	movt	r3, #87	; 0x57
  129040:	e1d331be 	ldrh	r3, [r3, #30]
  129044:	e2833001 	add	r3, r3, #1
  129048:	e6ff2073 	uxth	r2, r3
  12904c:	e3063840 	movw	r3, #26688	; 0x6840
  129050:	e3403057 	movt	r3, #87	; 0x57
  129054:	e1c321be 	strh	r2, [r3, #30]
        goto free_and_return;
  129058:	ea000020 	b	1290e0 <ethernet_input+0x2e0>
      } else {
        /* pass p to ARP module */
        etharp_input(p, netif);
  12905c:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  129060:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  129064:	eb0015a9 	bl	12e710 <etharp_input>
      }
      break;
  129068:	ea000015 	b	1290c4 <ethernet_input+0x2c4>
#ifdef LWIP_HOOK_UNKNOWN_ETH_PROTOCOL
      if(LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(p, netif) == ERR_OK) {
        break;
      }
#endif
      ETHARP_STATS_INC(etharp.proterr);
  12906c:	e3063840 	movw	r3, #26688	; 0x6840
  129070:	e3403057 	movt	r3, #87	; 0x57
  129074:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
  129078:	e2833001 	add	r3, r3, #1
  12907c:	e6ff2073 	uxth	r2, r3
  129080:	e3063840 	movw	r3, #26688	; 0x6840
  129084:	e3403057 	movt	r3, #87	; 0x57
  129088:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
      ETHARP_STATS_INC(etharp.drop);
  12908c:	e3063840 	movw	r3, #26688	; 0x6840
  129090:	e3403057 	movt	r3, #87	; 0x57
  129094:	e1d331be 	ldrh	r3, [r3, #30]
  129098:	e2833001 	add	r3, r3, #1
  12909c:	e6ff2073 	uxth	r2, r3
  1290a0:	e3063840 	movw	r3, #26688	; 0x6840
  1290a4:	e3403057 	movt	r3, #87	; 0x57
  1290a8:	e1c321be 	strh	r2, [r3, #30]
      MIB2_STATS_NETIF_INC(netif, ifinunknownprotos);
  1290ac:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1290b0:	e5933064 	ldr	r3, [r3, #100]	; 0x64
  1290b4:	e2832001 	add	r2, r3, #1
  1290b8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1290bc:	e5832064 	str	r2, [r3, #100]	; 0x64
      goto free_and_return;
  1290c0:	ea000006 	b	1290e0 <ethernet_input+0x2e0>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
  1290c4:	e3a03000 	mov	r3, #0
  1290c8:	ea000007 	b	1290ec <ethernet_input+0x2ec>
        goto free_and_return;
  1290cc:	e320f000 	nop	{0}
  1290d0:	ea000002 	b	1290e0 <ethernet_input+0x2e0>

free_and_return:
  1290d4:	e320f000 	nop	{0}
  1290d8:	ea000000 	b	1290e0 <ethernet_input+0x2e0>
        goto free_and_return;
  1290dc:	e320f000 	nop	{0}
  pbuf_free(p);
  1290e0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1290e4:	ebffc7f2 	bl	11b0b4 <pbuf_free>
  return ERR_OK;
  1290e8:	e3a03000 	mov	r3, #0
}
  1290ec:	e1a00003 	mov	r0, r3
  1290f0:	e24bd004 	sub	sp, fp, #4
  1290f4:	e8bd8800 	pop	{fp, pc}

001290f8 <ethernet_output>:
 */
err_t
ethernet_output(struct netif* netif, struct pbuf* p,
                const struct eth_addr* src, const struct eth_addr* dst,
                u16_t eth_type)
{
  1290f8:	e92d4800 	push	{fp, lr}
  1290fc:	e28db004 	add	fp, sp, #4
  129100:	e24dd018 	sub	sp, sp, #24
  129104:	e50b0010 	str	r0, [fp, #-16]
  129108:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  12910c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  129110:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  struct eth_hdr* ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
  129114:	e1db30b4 	ldrh	r3, [fp, #4]
  129118:	e1a00003 	mov	r0, r3
  12911c:	ebffb5ad 	bl	1167d8 <lwip_htons>
  129120:	e1a03000 	mov	r3, r0
  129124:	e14b30b6 	strh	r3, [fp, #-6]

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  {
    if (pbuf_header(p, SIZEOF_ETH_HDR) != 0) {
  129128:	e3a0100e 	mov	r1, #14
  12912c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  129130:	ebffc7c1 	bl	11b03c <pbuf_header>
  129134:	e1a03000 	mov	r3, r0
  129138:	e3530000 	cmp	r3, #0
  12913c:	1a000022 	bne	1291cc <ethernet_output+0xd4>
      goto pbuf_header_failed;
    }
  }

  ethhdr = (struct eth_hdr*)p->payload;
  129140:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  129144:	e5933004 	ldr	r3, [r3, #4]
  129148:	e50b300c 	str	r3, [fp, #-12]
  ethhdr->type = eth_type_be;
  12914c:	e51b300c 	ldr	r3, [fp, #-12]
  129150:	e15b20b6 	ldrh	r2, [fp, #-6]
  129154:	e1c320bc 	strh	r2, [r3, #12]
  ETHADDR32_COPY(&ethhdr->dest, dst);
  129158:	e51b300c 	ldr	r3, [fp, #-12]
  12915c:	e3a02006 	mov	r2, #6
  129160:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  129164:	e1a00003 	mov	r0, r3
  129168:	eb005f89 	bl	140f94 <memcpy>
  ETHADDR16_COPY(&ethhdr->src,  src);
  12916c:	e51b300c 	ldr	r3, [fp, #-12]
  129170:	e2833006 	add	r3, r3, #6
  129174:	e3a02006 	mov	r2, #6
  129178:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  12917c:	e1a00003 	mov	r0, r3
  129180:	eb005f83 	bl	140f94 <memcpy>

  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
  129184:	e51b3010 	ldr	r3, [fp, #-16]
  129188:	e5d3303a 	ldrb	r3, [r3, #58]	; 0x3a
  12918c:	e3530006 	cmp	r3, #6
  129190:	0a000006 	beq	1291b0 <ethernet_output+0xb8>
  129194:	e3080d5c 	movw	r0, #36188	; 0x8d5c
  129198:	e3400014 	movt	r0, #20
  12919c:	ebff67dc 	bl	103114 <rt_kprintf>
  1291a0:	e300112e 	movw	r1, #302	; 0x12e
  1291a4:	e3080d90 	movw	r0, #36240	; 0x8d90
  1291a8:	e3400014 	movt	r0, #20
  1291ac:	ebff87b2 	bl	10b07c <sys_arch_assert>
    (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
    ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
  1291b0:	e51b3010 	ldr	r3, [fp, #-16]
  1291b4:	e5933018 	ldr	r3, [r3, #24]
  1291b8:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1291bc:	e51b0010 	ldr	r0, [fp, #-16]
  1291c0:	e12fff33 	blx	r3
  1291c4:	e1a03000 	mov	r3, r0
  1291c8:	ea000009 	b	1291f4 <ethernet_output+0xfc>
      goto pbuf_header_failed;
  1291cc:	e320f000 	nop	{0}

pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
  1291d0:	e3063840 	movw	r3, #26688	; 0x6840
  1291d4:	e3403057 	movt	r3, #87	; 0x57
  1291d8:	e1d330ba 	ldrh	r3, [r3, #10]
  1291dc:	e2833001 	add	r3, r3, #1
  1291e0:	e6ff2073 	uxth	r2, r3
  1291e4:	e3063840 	movw	r3, #26688	; 0x6840
  1291e8:	e3403057 	movt	r3, #87	; 0x57
  1291ec:	e1c320ba 	strh	r2, [r3, #10]
  return ERR_BUF;
  1291f0:	e3e03001 	mvn	r3, #1
}
  1291f4:	e1a00003 	mov	r0, r3
  1291f8:	e24bd004 	sub	sp, fp, #4
  1291fc:	e8bd8800 	pop	{fp, pc}

00129200 <lwip_netdev_set_up>:
#include "lwip/netdb.h"
#include "../../../netdev/netdev.h"
#include "../../../netdev/eth_device_manager.h"

static int lwip_netdev_set_up(struct netdev *netif)
{
  129200:	e92d4800 	push	{fp, lr}
  129204:	e28db004 	add	fp, sp, #4
  129208:	e24dd008 	sub	sp, sp, #8
  12920c:	e50b0008 	str	r0, [fp, #-8]
    netif_set_up((struct netif *)netif->user_data);
  129210:	e51b3008 	ldr	r3, [fp, #-8]
  129214:	e5933040 	ldr	r3, [r3, #64]	; 0x40
  129218:	e1a00003 	mov	r0, r3
  12921c:	ebffc26a 	bl	119bcc <netif_set_up>
    return ERR_OK;
  129220:	e3a03000 	mov	r3, #0
}
  129224:	e1a00003 	mov	r0, r3
  129228:	e24bd004 	sub	sp, fp, #4
  12922c:	e8bd8800 	pop	{fp, pc}

00129230 <lwip_netdev_set_down>:

static int lwip_netdev_set_down(struct netdev *netif)
{
  129230:	e92d4800 	push	{fp, lr}
  129234:	e28db004 	add	fp, sp, #4
  129238:	e24dd008 	sub	sp, sp, #8
  12923c:	e50b0008 	str	r0, [fp, #-8]
    netif_set_down((struct netif *)netif->user_data);
  129240:	e51b3008 	ldr	r3, [fp, #-8]
  129244:	e5933040 	ldr	r3, [r3, #64]	; 0x40
  129248:	e1a00003 	mov	r0, r3
  12924c:	ebffc2b3 	bl	119d20 <netif_set_down>
    return ERR_OK;
  129250:	e3a03000 	mov	r3, #0
}
  129254:	e1a00003 	mov	r0, r3
  129258:	e24bd004 	sub	sp, fp, #4
  12925c:	e8bd8800 	pop	{fp, pc}

00129260 <lwip_netdev_set_addr_info>:

static int lwip_netdev_set_addr_info(struct netdev *netif, ip_addr_t *ip_addr, ip_addr_t *netmask, ip_addr_t *gw)
{
  129260:	e92d4800 	push	{fp, lr}
  129264:	e28db004 	add	fp, sp, #4
  129268:	e24dd010 	sub	sp, sp, #16
  12926c:	e50b0008 	str	r0, [fp, #-8]
  129270:	e50b100c 	str	r1, [fp, #-12]
  129274:	e50b2010 	str	r2, [fp, #-16]
  129278:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    if (ip_addr && netmask && gw)
  12927c:	e51b300c 	ldr	r3, [fp, #-12]
  129280:	e3530000 	cmp	r3, #0
  129284:	0a00000c 	beq	1292bc <lwip_netdev_set_addr_info+0x5c>
  129288:	e51b3010 	ldr	r3, [fp, #-16]
  12928c:	e3530000 	cmp	r3, #0
  129290:	0a000009 	beq	1292bc <lwip_netdev_set_addr_info+0x5c>
  129294:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  129298:	e3530000 	cmp	r3, #0
  12929c:	0a000006 	beq	1292bc <lwip_netdev_set_addr_info+0x5c>
    {
        netif_set_addr((struct netif *)netif->user_data, ip_2_ip4(ip_addr), ip_2_ip4(netmask), ip_2_ip4(gw));
  1292a0:	e51b3008 	ldr	r3, [fp, #-8]
  1292a4:	e5930040 	ldr	r0, [r3, #64]	; 0x40
  1292a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1292ac:	e51b2010 	ldr	r2, [fp, #-16]
  1292b0:	e51b100c 	ldr	r1, [fp, #-12]
  1292b4:	ebffc110 	bl	1196fc <netif_set_addr>
  1292b8:	ea000017 	b	12931c <lwip_netdev_set_addr_info+0xbc>
    }
    else
    {
        if (ip_addr)
  1292bc:	e51b300c 	ldr	r3, [fp, #-12]
  1292c0:	e3530000 	cmp	r3, #0
  1292c4:	0a000004 	beq	1292dc <lwip_netdev_set_addr_info+0x7c>
        {
            netif_set_ipaddr((struct netif *)netif->user_data, ip_2_ip4(ip_addr));
  1292c8:	e51b3008 	ldr	r3, [fp, #-8]
  1292cc:	e5933040 	ldr	r3, [r3, #64]	; 0x40
  1292d0:	e51b100c 	ldr	r1, [fp, #-12]
  1292d4:	e1a00003 	mov	r0, r3
  1292d8:	ebffc1b6 	bl	1199b8 <netif_set_ipaddr>
        }

        if (netmask)
  1292dc:	e51b3010 	ldr	r3, [fp, #-16]
  1292e0:	e3530000 	cmp	r3, #0
  1292e4:	0a000004 	beq	1292fc <lwip_netdev_set_addr_info+0x9c>
        {
            netif_set_netmask((struct netif *)netif->user_data, ip_2_ip4(netmask));
  1292e8:	e51b3008 	ldr	r3, [fp, #-8]
  1292ec:	e5933040 	ldr	r3, [r3, #64]	; 0x40
  1292f0:	e51b1010 	ldr	r1, [fp, #-16]
  1292f4:	e1a00003 	mov	r0, r3
  1292f8:	ebffc20e 	bl	119b38 <netif_set_netmask>
        }

        if (gw)
  1292fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  129300:	e3530000 	cmp	r3, #0
  129304:	0a000004 	beq	12931c <lwip_netdev_set_addr_info+0xbc>
        {
            netif_set_gw((struct netif *)netif->user_data, ip_2_ip4(gw));
  129308:	e51b3008 	ldr	r3, [fp, #-8]
  12930c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
  129310:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  129314:	e1a00003 	mov	r0, r3
  129318:	ebffc1ed 	bl	119ad4 <netif_set_gw>
        }
    }

    return ERR_OK;
  12931c:	e3a03000 	mov	r3, #0
}
  129320:	e1a00003 	mov	r0, r3
  129324:	e24bd004 	sub	sp, fp, #4
  129328:	e8bd8800 	pop	{fp, pc}

0012932c <lwip_netdev_set_dns_server>:

#ifdef RT_LWIP_DNS
static int lwip_netdev_set_dns_server(struct netdev *netif, uint8_t dns_num, ip_addr_t *dns_server)
{
  12932c:	e92d4800 	push	{fp, lr}
  129330:	e28db004 	add	fp, sp, #4
  129334:	e24dd010 	sub	sp, sp, #16
  129338:	e50b0008 	str	r0, [fp, #-8]
  12933c:	e1a03001 	mov	r3, r1
  129340:	e50b2010 	str	r2, [fp, #-16]
  129344:	e54b3009 	strb	r3, [fp, #-9]
    extern void dns_setserver(uint8_t dns_num, const ip_addr_t *dns_server);
    dns_setserver(dns_num, dns_server);
  129348:	e55b3009 	ldrb	r3, [fp, #-9]
  12934c:	e51b1010 	ldr	r1, [fp, #-16]
  129350:	e1a00003 	mov	r0, r3
  129354:	ebffb625 	bl	116bf0 <dns_setserver>
    return ERR_OK;
  129358:	e3a03000 	mov	r3, #0
}
  12935c:	e1a00003 	mov	r0, r3
  129360:	e24bd004 	sub	sp, fp, #4
  129364:	e8bd8800 	pop	{fp, pc}

00129368 <lwip_netdev_set_dhcp>:
#endif /* RT_LWIP_DNS */

#ifdef RT_LWIP_DHCP
static int lwip_netdev_set_dhcp(struct netdev *netif, rt_bool_t is_enabled)
{
  129368:	e92d4800 	push	{fp, lr}
  12936c:	e28db004 	add	fp, sp, #4
  129370:	e24dd008 	sub	sp, sp, #8
  129374:	e50b0008 	str	r0, [fp, #-8]
  129378:	e50b100c 	str	r1, [fp, #-12]
    if(RT_TRUE == is_enabled)
  12937c:	e51b300c 	ldr	r3, [fp, #-12]
  129380:	e3530001 	cmp	r3, #1
  129384:	1a000004 	bne	12939c <lwip_netdev_set_dhcp+0x34>
    {
        dhcp_start((struct netif *)netif->user_data);
  129388:	e51b3008 	ldr	r3, [fp, #-8]
  12938c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
  129390:	e1a00003 	mov	r0, r3
  129394:	eb0006d5 	bl	12aef0 <dhcp_start>
  129398:	ea000003 	b	1293ac <lwip_netdev_set_dhcp+0x44>
    }
    else
    {
        dhcp_stop((struct netif *)netif->user_data);
  12939c:	e51b3008 	ldr	r3, [fp, #-8]
  1293a0:	e5933040 	ldr	r3, [r3, #64]	; 0x40
  1293a4:	e1a00003 	mov	r0, r3
  1293a8:	eb000b48 	bl	12c0d0 <dhcp_stop>
    }
    netdev_low_level_set_dhcp_status(netif, is_enabled);
  1293ac:	e51b100c 	ldr	r1, [fp, #-12]
  1293b0:	e51b0008 	ldr	r0, [fp, #-8]
  1293b4:	ebff7499 	bl	106620 <netdev_low_level_set_dhcp_status>
    return ERR_OK;
  1293b8:	e3a03000 	mov	r3, #0
}
  1293bc:	e1a00003 	mov	r0, r3
  1293c0:	e24bd004 	sub	sp, fp, #4
  1293c4:	e8bd8800 	pop	{fp, pc}

001293c8 <lwip_netdev_ping>:
extern int lwip_ping_recv(int s, int *ttl);
extern err_t lwip_ping_send(int s, ip_addr_t *addr, int size);

int lwip_netdev_ping(struct netdev *netif, const char *host, size_t data_len, 
                        uint32_t timeout, struct netdev_ping_resp *ping_resp)
{
  1293c8:	e92d4800 	push	{fp, lr}
  1293cc:	e28db004 	add	fp, sp, #4
  1293d0:	e24dd070 	sub	sp, sp, #112	; 0x70
  1293d4:	e50b0060 	str	r0, [fp, #-96]	; 0xffffffa0
  1293d8:	e50b1064 	str	r1, [fp, #-100]	; 0xffffff9c
  1293dc:	e50b2068 	str	r2, [fp, #-104]	; 0xffffff98
  1293e0:	e50b306c 	str	r3, [fp, #-108]	; 0xffffff94
    int s, ttl, recv_len, result = 0;
  1293e4:	e3a03000 	mov	r3, #0
  1293e8:	e50b3008 	str	r3, [fp, #-8]
    int elapsed_time;
    rt_tick_t recv_start_tick;
#if LWIP_VERSION_MAJOR >= 2U
    struct timeval recv_timeout = { timeout / RT_TICK_PER_SECOND, timeout % RT_TICK_PER_SECOND };
  1293ec:	e51b206c 	ldr	r2, [fp, #-108]	; 0xffffff94
  1293f0:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  1293f4:	e3413062 	movt	r3, #4194	; 0x1062
  1293f8:	e0832392 	umull	r2, r3, r2, r3
  1293fc:	e1a03323 	lsr	r3, r3, #6
  129400:	e1a02003 	mov	r2, r3
  129404:	e3a03000 	mov	r3, #0
  129408:	e14b22fc 	strd	r2, [fp, #-44]	; 0xffffffd4
  12940c:	e51b106c 	ldr	r1, [fp, #-108]	; 0xffffff94
  129410:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  129414:	e3413062 	movt	r3, #4194	; 0x1062
  129418:	e0832391 	umull	r2, r3, r1, r3
  12941c:	e1a03323 	lsr	r3, r3, #6
  129420:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  129424:	e0030392 	mul	r3, r2, r3
  129428:	e0413003 	sub	r3, r1, r3
  12942c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
#else
    int recv_timeout = timeout * 1000UL / RT_TICK_PER_SECOND;
#endif
    ip_addr_t target_addr;
    struct addrinfo hint, *res = RT_NULL;
  129430:	e3a03000 	mov	r3, #0
  129434:	e50b3054 	str	r3, [fp, #-84]	; 0xffffffac
    struct sockaddr_in *h = RT_NULL;
  129438:	e3a03000 	mov	r3, #0
  12943c:	e50b3058 	str	r3, [fp, #-88]	; 0xffffffa8
    struct in_addr ina;
    
    RT_ASSERT(netif);
  129440:	e51b3060 	ldr	r3, [fp, #-96]	; 0xffffffa0
  129444:	e3530000 	cmp	r3, #0
  129448:	1a000005 	bne	129464 <lwip_netdev_ping+0x9c>
  12944c:	e3a020ca 	mov	r2, #202	; 0xca
  129450:	e3081ed4 	movw	r1, #36564	; 0x8ed4
  129454:	e3401014 	movt	r1, #20
  129458:	e3080dc4 	movw	r0, #36292	; 0x8dc4
  12945c:	e3400014 	movt	r0, #20
  129460:	ebff684c 	bl	103598 <rt_assert_handler>
    RT_ASSERT(host);
  129464:	e51b3064 	ldr	r3, [fp, #-100]	; 0xffffff9c
  129468:	e3530000 	cmp	r3, #0
  12946c:	1a000005 	bne	129488 <lwip_netdev_ping+0xc0>
  129470:	e3a020cb 	mov	r2, #203	; 0xcb
  129474:	e3081ed4 	movw	r1, #36564	; 0x8ed4
  129478:	e3401014 	movt	r1, #20
  12947c:	e3080dcc 	movw	r0, #36300	; 0x8dcc
  129480:	e3400014 	movt	r0, #20
  129484:	ebff6843 	bl	103598 <rt_assert_handler>
    RT_ASSERT(ping_resp);
  129488:	e59b3004 	ldr	r3, [fp, #4]
  12948c:	e3530000 	cmp	r3, #0
  129490:	1a000005 	bne	1294ac <lwip_netdev_ping+0xe4>
  129494:	e3a020cc 	mov	r2, #204	; 0xcc
  129498:	e3081ed4 	movw	r1, #36564	; 0x8ed4
  12949c:	e3401014 	movt	r1, #20
  1294a0:	e3080dd4 	movw	r0, #36308	; 0x8dd4
  1294a4:	e3400014 	movt	r0, #20
  1294a8:	ebff683a 	bl	103598 <rt_assert_handler>

    rt_memset(&hint, 0x00, sizeof(hint));
  1294ac:	e24b3050 	sub	r3, fp, #80	; 0x50
  1294b0:	e3a02020 	mov	r2, #32
  1294b4:	e3a01000 	mov	r1, #0
  1294b8:	e1a00003 	mov	r0, r3
  1294bc:	ebff6781 	bl	1032c8 <rt_memset>
    /* convert URL to IP */
    if (lwip_getaddrinfo(host, RT_NULL, &hint, &res) != 0)
  1294c0:	e24b3054 	sub	r3, fp, #84	; 0x54
  1294c4:	e24b2050 	sub	r2, fp, #80	; 0x50
  1294c8:	e3a01000 	mov	r1, #0
  1294cc:	e51b0064 	ldr	r0, [fp, #-100]	; 0xffffff9c
  1294d0:	ebff9d43 	bl	1109e4 <lwip_getaddrinfo>
  1294d4:	e1a03000 	mov	r3, r0
  1294d8:	e3530000 	cmp	r3, #0
  1294dc:	0a000001 	beq	1294e8 <lwip_netdev_ping+0x120>
    {
        return -RT_ERROR;
  1294e0:	e3e03000 	mvn	r3, #0
  1294e4:	ea000064 	b	12967c <lwip_netdev_ping+0x2b4>
    }
    rt_memcpy(&h, &res->ai_addr, sizeof(struct sockaddr_in *));
  1294e8:	e51b3054 	ldr	r3, [fp, #-84]	; 0xffffffac
  1294ec:	e2831014 	add	r1, r3, #20
  1294f0:	e24b3058 	sub	r3, fp, #88	; 0x58
  1294f4:	e3a02004 	mov	r2, #4
  1294f8:	e1a00003 	mov	r0, r3
  1294fc:	ebff677f 	bl	103300 <rt_memcpy>
    rt_memcpy(&ina, &h->sin_addr, sizeof(ina));
  129500:	e51b3058 	ldr	r3, [fp, #-88]	; 0xffffffa8
  129504:	e2831004 	add	r1, r3, #4
  129508:	e24b305c 	sub	r3, fp, #92	; 0x5c
  12950c:	e3a02004 	mov	r2, #4
  129510:	e1a00003 	mov	r0, r3
  129514:	ebff6779 	bl	103300 <rt_memcpy>
    lwip_freeaddrinfo(res);
  129518:	e51b3054 	ldr	r3, [fp, #-84]	; 0xffffffac
  12951c:	e1a00003 	mov	r0, r3
  129520:	ebff9d1c 	bl	110998 <lwip_freeaddrinfo>
    if (inet_aton(inet_ntoa(ina), &target_addr) == 0)
  129524:	e24b305c 	sub	r3, fp, #92	; 0x5c
  129528:	e1a00003 	mov	r0, r3
  12952c:	eb0025f0 	bl	132cf4 <ip4addr_ntoa>
  129530:	e1a02000 	mov	r2, r0
  129534:	e24b3030 	sub	r3, fp, #48	; 0x30
  129538:	e1a01003 	mov	r1, r3
  12953c:	e1a00002 	mov	r0, r2
  129540:	eb0024e7 	bl	1328e4 <ip4addr_aton>
  129544:	e1a03000 	mov	r3, r0
  129548:	e3530000 	cmp	r3, #0
  12954c:	1a000001 	bne	129558 <lwip_netdev_ping+0x190>
    {
        return -RT_ERROR;
  129550:	e3e03000 	mvn	r3, #0
  129554:	ea000048 	b	12967c <lwip_netdev_ping+0x2b4>
    }
    rt_memcpy(&(ping_resp->ip_addr), &target_addr, sizeof(ip_addr_t));
  129558:	e59b3004 	ldr	r3, [fp, #4]
  12955c:	e24b1030 	sub	r1, fp, #48	; 0x30
  129560:	e3a02004 	mov	r2, #4
  129564:	e1a00003 	mov	r0, r3
  129568:	ebff6764 	bl	103300 <rt_memcpy>
    
    /* new a socket */
    if ((s = lwip_socket(AF_INET, SOCK_RAW, IP_PROTO_ICMP)) < 0)
  12956c:	e3a02001 	mov	r2, #1
  129570:	e3a01003 	mov	r1, #3
  129574:	e3a00002 	mov	r0, #2
  129578:	ebffa65a 	bl	112ee8 <lwip_socket>
  12957c:	e50b000c 	str	r0, [fp, #-12]
  129580:	e51b300c 	ldr	r3, [fp, #-12]
  129584:	e3530000 	cmp	r3, #0
  129588:	aa000001 	bge	129594 <lwip_netdev_ping+0x1cc>
    {
        return -RT_ERROR;
  12958c:	e3e03000 	mvn	r3, #0
  129590:	ea000039 	b	12967c <lwip_netdev_ping+0x2b4>
    }

    lwip_setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &recv_timeout, sizeof(recv_timeout));
  129594:	e24b202c 	sub	r2, fp, #44	; 0x2c
  129598:	e3a03010 	mov	r3, #16
  12959c:	e58d3000 	str	r3, [sp]
  1295a0:	e1a03002 	mov	r3, r2
  1295a4:	e3012006 	movw	r2, #4102	; 0x1006
  1295a8:	e3001fff 	movw	r1, #4095	; 0xfff
  1295ac:	e51b000c 	ldr	r0, [fp, #-12]
  1295b0:	ebffae2a 	bl	114e60 <lwip_setsockopt>

    if (lwip_ping_send(s, &target_addr, data_len) == ERR_OK)
  1295b4:	e51b2068 	ldr	r2, [fp, #-104]	; 0xffffff98
  1295b8:	e24b3030 	sub	r3, fp, #48	; 0x30
  1295bc:	e1a01003 	mov	r1, r3
  1295c0:	e51b000c 	ldr	r0, [fp, #-12]
  1295c4:	eb002c05 	bl	1345e0 <lwip_ping_send>
  1295c8:	e1a03000 	mov	r3, r0
  1295cc:	e3530000 	cmp	r3, #0
  1295d0:	1a000023 	bne	129664 <lwip_netdev_ping+0x29c>
    {
        recv_start_tick = rt_tick_get();
  1295d4:	ebff6221 	bl	101e60 <rt_tick_get>
  1295d8:	e50b0010 	str	r0, [fp, #-16]
        if ((recv_len = lwip_ping_recv(s, &ttl)) >= 0)
  1295dc:	e24b301c 	sub	r3, fp, #28
  1295e0:	e1a01003 	mov	r1, r3
  1295e4:	e51b000c 	ldr	r0, [fp, #-12]
  1295e8:	eb002c3a 	bl	1346d8 <lwip_ping_recv>
  1295ec:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
  1295f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1295f4:	e3530000 	cmp	r3, #0
  1295f8:	ba000016 	blt	129658 <lwip_netdev_ping+0x290>
        {
            elapsed_time = (rt_tick_get() - recv_start_tick) * 1000UL / RT_TICK_PER_SECOND;
  1295fc:	ebff6217 	bl	101e60 <rt_tick_get>
  129600:	e1a02000 	mov	r2, r0
  129604:	e51b3010 	ldr	r3, [fp, #-16]
  129608:	e0423003 	sub	r3, r2, r3
  12960c:	e3a02ffa 	mov	r2, #1000	; 0x3e8
  129610:	e0020392 	mul	r2, r2, r3
  129614:	e3043dd3 	movw	r3, #19923	; 0x4dd3
  129618:	e3413062 	movt	r3, #4194	; 0x1062
  12961c:	e0832392 	umull	r2, r3, r2, r3
  129620:	e1a03323 	lsr	r3, r3, #6
  129624:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
            ping_resp->data_len = recv_len;
  129628:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12962c:	e6ff2073 	uxth	r2, r3
  129630:	e59b3004 	ldr	r3, [fp, #4]
  129634:	e1c320b4 	strh	r2, [r3, #4]
            ping_resp->ttl = ttl;
  129638:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12963c:	e6ff2073 	uxth	r2, r3
  129640:	e59b3004 	ldr	r3, [fp, #4]
  129644:	e1c320b6 	strh	r2, [r3, #6]
            ping_resp->ticks = elapsed_time;
  129648:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  12964c:	e59b3004 	ldr	r3, [fp, #4]
  129650:	e5832008 	str	r2, [r3, #8]
  129654:	ea000005 	b	129670 <lwip_netdev_ping+0x2a8>
        }
        else
        {
            result = -RT_ETIMEOUT;
  129658:	e3e03001 	mvn	r3, #1
  12965c:	e50b3008 	str	r3, [fp, #-8]
            goto __exit;
  129660:	ea000002 	b	129670 <lwip_netdev_ping+0x2a8>
        }
    }
    else
    {
        result = -RT_ETIMEOUT;
  129664:	e3e03001 	mvn	r3, #1
  129668:	e50b3008 	str	r3, [fp, #-8]
        goto __exit;
  12966c:	e320f000 	nop	{0}
    }

__exit:
    lwip_close(s);
  129670:	e51b000c 	ldr	r0, [fp, #-12]
  129674:	ebffa105 	bl	111a90 <lwip_close>

    return result;
  129678:	e51b3008 	ldr	r3, [fp, #-8]
}
  12967c:	e1a00003 	mov	r0, r3
  129680:	e24bd004 	sub	sp, fp, #4
  129684:	e8bd8800 	pop	{fp, pc}

00129688 <lwip_netdev_set_default>:
// }
// #endif /* RT_LWIP_TCP || RT_LWIP_UDP */
#endif /* RT_USING_FINSH */

static int lwip_netdev_set_default(struct netdev *netif)
{
  129688:	e92d4800 	push	{fp, lr}
  12968c:	e28db004 	add	fp, sp, #4
  129690:	e24dd008 	sub	sp, sp, #8
  129694:	e50b0008 	str	r0, [fp, #-8]
    netif_set_default((struct netif *)netif->user_data);
  129698:	e51b3008 	ldr	r3, [fp, #-8]
  12969c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
  1296a0:	e1a00003 	mov	r0, r3
  1296a4:	ebffc13c 	bl	119b9c <netif_set_default>
    return ERR_OK;
  1296a8:	e3a03000 	mov	r3, #0
}
  1296ac:	e1a00003 	mov	r0, r3
  1296b0:	e24bd004 	sub	sp, fp, #4
  1296b4:	e8bd8800 	pop	{fp, pc}

001296b8 <netdev_add>:

    lwip_netdev_set_default,
};

static int netdev_add(struct netif *lwip_netif)
{
  1296b8:	e92d4800 	push	{fp, lr}
  1296bc:	e28db004 	add	fp, sp, #4
  1296c0:	e24dd018 	sub	sp, sp, #24
  1296c4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
#define LWIP_NETIF_NAME_LEN 2
    int result = 0;
  1296c8:	e3a03000 	mov	r3, #0
  1296cc:	e50b3008 	str	r3, [fp, #-8]
    struct netdev *netdev = RT_NULL;
  1296d0:	e3a03000 	mov	r3, #0
  1296d4:	e50b300c 	str	r3, [fp, #-12]
    char name[LWIP_NETIF_NAME_LEN + 1] = {0};
  1296d8:	e24b3010 	sub	r3, fp, #16
  1296dc:	e3a02000 	mov	r2, #0
  1296e0:	e1c320b0 	strh	r2, [r3]
  1296e4:	e5c32002 	strb	r2, [r3, #2]

    RT_ASSERT(lwip_netif);
  1296e8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1296ec:	e3530000 	cmp	r3, #0
  1296f0:	1a000005 	bne	12970c <netdev_add+0x54>
  1296f4:	e3002141 	movw	r2, #321	; 0x141
  1296f8:	e3081ee8 	movw	r1, #36584	; 0x8ee8
  1296fc:	e3401014 	movt	r1, #20
  129700:	e3080e00 	movw	r0, #36352	; 0x8e00
  129704:	e3400014 	movt	r0, #20
  129708:	ebff67a2 	bl	103598 <rt_assert_handler>

    netdev = (struct netdev *)rt_calloc(1, sizeof(struct netdev));
  12970c:	e3a01044 	mov	r1, #68	; 0x44
  129710:	e3a00001 	mov	r0, #1
  129714:	ebff663c 	bl	10300c <rt_calloc>
  129718:	e50b000c 	str	r0, [fp, #-12]
    if (netdev == RT_NULL)
  12971c:	e51b300c 	ldr	r3, [fp, #-12]
  129720:	e3530000 	cmp	r3, #0
  129724:	1a000001 	bne	129730 <netdev_add+0x78>
    {
        return -ERR_IF;
  129728:	e3a0300c 	mov	r3, #12
  12972c:	ea000036 	b	12980c <netdev_add+0x154>
//     extern int sal_lwip_netdev_set_pf_info(struct netdev *netdev);
//     /* set the lwIP network interface device protocol family information */
//     sal_lwip_netdev_set_pf_info(netdev);
// #endif /* SAL_USING_LWIP */
    extern int sal_unet_netdev_set_pf_info(struct netdev *netdev);
    sal_unet_netdev_set_pf_info(netdev);
  129730:	e51b000c 	ldr	r0, [fp, #-12]
  129734:	ebff6c85 	bl	104950 <sal_unet_netdev_set_pf_info>

    rt_strncpy(name, lwip_netif->name, LWIP_NETIF_NAME_LEN);
  129738:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12973c:	e2831042 	add	r1, r3, #66	; 0x42
  129740:	e24b3010 	sub	r3, fp, #16
  129744:	e3a02002 	mov	r2, #2
  129748:	e1a00003 	mov	r0, r3
  12974c:	ebff66c3 	bl	103260 <rt_strncpy>
    result = netdev_register(netdev, name, (void *)lwip_netif);
  129750:	e24b3010 	sub	r3, fp, #16
  129754:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  129758:	e1a01003 	mov	r1, r3
  12975c:	e51b000c 	ldr	r0, [fp, #-12]
  129760:	ebff6e45 	bl	10507c <netdev_register>
  129764:	e50b0008 	str	r0, [fp, #-8]
    // result = ueth_netdev_register(netdev, name, (void *)lwip_netif);
	
    /* Update netdev info after registered */
    netdev->flags = lwip_netif->flags;
  129768:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12976c:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  129770:	e6ff2073 	uxth	r2, r3
  129774:	e51b300c 	ldr	r3, [fp, #-12]
  129778:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a
    netdev->mtu = lwip_netif->mtu;
  12977c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  129780:	e1d323b8 	ldrh	r2, [r3, #56]	; 0x38
  129784:	e51b300c 	ldr	r3, [fp, #-12]
  129788:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
    netdev->ops = &lwip_netdev_ops;
  12978c:	e51b200c 	ldr	r2, [fp, #-12]
  129790:	e3083de0 	movw	r3, #36320	; 0x8de0
  129794:	e3403014 	movt	r3, #20
  129798:	e5823030 	str	r3, [r2, #48]	; 0x30
    netdev->hwaddr_len =  lwip_netif->hwaddr_len;
  12979c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1297a0:	e5d3203a 	ldrb	r2, [r3, #58]	; 0x3a
  1297a4:	e51b300c 	ldr	r3, [fp, #-12]
  1297a8:	e5c32020 	strb	r2, [r3, #32]
    rt_memcpy(netdev->hwaddr, lwip_netif->hwaddr, lwip_netif->hwaddr_len);
  1297ac:	e51b300c 	ldr	r3, [fp, #-12]
  1297b0:	e2830021 	add	r0, r3, #33	; 0x21
  1297b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1297b8:	e283103b 	add	r1, r3, #59	; 0x3b
  1297bc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1297c0:	e5d3303a 	ldrb	r3, [r3, #58]	; 0x3a
  1297c4:	e1a02003 	mov	r2, r3
  1297c8:	ebff66cc 	bl	103300 <rt_memcpy>
    netdev->ip_addr = lwip_netif->ip_addr;
  1297cc:	e51b300c 	ldr	r3, [fp, #-12]
  1297d0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1297d4:	e5922004 	ldr	r2, [r2, #4]
  1297d8:	e583200c 	str	r2, [r3, #12]
    netdev->gw = lwip_netif->gw;
  1297dc:	e51b300c 	ldr	r3, [fp, #-12]
  1297e0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1297e4:	e592200c 	ldr	r2, [r2, #12]
  1297e8:	e5832014 	str	r2, [r3, #20]
    netdev->netmask = lwip_netif->netmask;
  1297ec:	e51b300c 	ldr	r3, [fp, #-12]
  1297f0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1297f4:	e5922008 	ldr	r2, [r2, #8]
  1297f8:	e5832010 	str	r2, [r3, #16]

#ifdef RT_LWIP_DHCP
    netdev_low_level_set_dhcp_status(netdev, RT_TRUE);
  1297fc:	e3a01001 	mov	r1, #1
  129800:	e51b000c 	ldr	r0, [fp, #-12]
  129804:	ebff7385 	bl	106620 <netdev_low_level_set_dhcp_status>
#endif

    return result;
  129808:	e51b3008 	ldr	r3, [fp, #-8]
}
  12980c:	e1a00003 	mov	r0, r3
  129810:	e24bd004 	sub	sp, fp, #4
  129814:	e8bd8800 	pop	{fp, pc}

00129818 <netdev_del>:

static void netdev_del(struct netif *lwip_netif)
{
  129818:	e92d4800 	push	{fp, lr}
  12981c:	e28db004 	add	fp, sp, #4
  129820:	e24dd010 	sub	sp, sp, #16
  129824:	e50b0010 	str	r0, [fp, #-16]
    char name[LWIP_NETIF_NAME_LEN + 1];
    struct netdev *netdev;

    RT_ASSERT(lwip_netif);
  129828:	e51b3010 	ldr	r3, [fp, #-16]
  12982c:	e3530000 	cmp	r3, #0
  129830:	1a000005 	bne	12984c <netdev_del+0x34>
  129834:	e300216b 	movw	r2, #363	; 0x16b
  129838:	e3081ef4 	movw	r1, #36596	; 0x8ef4
  12983c:	e3401014 	movt	r1, #20
  129840:	e3080e00 	movw	r0, #36352	; 0x8e00
  129844:	e3400014 	movt	r0, #20
  129848:	ebff6752 	bl	103598 <rt_assert_handler>

    rt_strncpy(name, lwip_netif->name, LWIP_NETIF_NAME_LEN);
  12984c:	e51b3010 	ldr	r3, [fp, #-16]
  129850:	e2831042 	add	r1, r3, #66	; 0x42
  129854:	e24b300c 	sub	r3, fp, #12
  129858:	e3a02002 	mov	r2, #2
  12985c:	e1a00003 	mov	r0, r3
  129860:	ebff667e 	bl	103260 <rt_strncpy>
    netdev = netdev_get_by_name(name);
  129864:	e24b300c 	sub	r3, fp, #12
  129868:	e1a00003 	mov	r0, r3
  12986c:	ebff6f26 	bl	10550c <netdev_get_by_name>
  129870:	e50b0008 	str	r0, [fp, #-8]
    netdev_unregister(netdev);
  129874:	e51b0008 	ldr	r0, [fp, #-8]
  129878:	ebff6e6a 	bl	105228 <netdev_unregister>
    rt_free(netdev);
  12987c:	e51b0008 	ldr	r0, [fp, #-8]
  129880:	ebff65cd 	bl	102fbc <rt_free>
}
  129884:	e320f000 	nop	{0}
  129888:	e24bd004 	sub	sp, fp, #4
  12988c:	e8bd8800 	pop	{fp, pc}

00129890 <netdev_flags_sync>:

/* synchronize lwIP network interface device and network interface device flags */
static int netdev_flags_sync(struct netif *lwip_netif)
{
  129890:	e92d4800 	push	{fp, lr}
  129894:	e28db004 	add	fp, sp, #4
  129898:	e24dd010 	sub	sp, sp, #16
  12989c:	e50b0010 	str	r0, [fp, #-16]
    struct netdev *netdev = NULL;
  1298a0:	e3a03000 	mov	r3, #0
  1298a4:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(lwip_netif);
  1298a8:	e51b3010 	ldr	r3, [fp, #-16]
  1298ac:	e3530000 	cmp	r3, #0
  1298b0:	1a000005 	bne	1298cc <netdev_flags_sync+0x3c>
  1298b4:	e3a02f5e 	mov	r2, #376	; 0x178
  1298b8:	e3081f00 	movw	r1, #36608	; 0x8f00
  1298bc:	e3401014 	movt	r1, #20
  1298c0:	e3080e00 	movw	r0, #36352	; 0x8e00
  1298c4:	e3400014 	movt	r0, #20
  1298c8:	ebff6732 	bl	103598 <rt_assert_handler>

    netdev = netdev_get_by_name(lwip_netif->name);
  1298cc:	e51b3010 	ldr	r3, [fp, #-16]
  1298d0:	e2833042 	add	r3, r3, #66	; 0x42
  1298d4:	e1a00003 	mov	r0, r3
  1298d8:	ebff6f0b 	bl	10550c <netdev_get_by_name>
  1298dc:	e50b0008 	str	r0, [fp, #-8]
    if (netdev == RT_NULL)
  1298e0:	e51b3008 	ldr	r3, [fp, #-8]
  1298e4:	e3530000 	cmp	r3, #0
  1298e8:	1a000001 	bne	1298f4 <netdev_flags_sync+0x64>
    {
        return -ERR_IF;
  1298ec:	e3a0300c 	mov	r3, #12
  1298f0:	ea00000d 	b	12992c <netdev_flags_sync+0x9c>
    }
    
    netdev->mtu = lwip_netif->mtu;
  1298f4:	e51b3010 	ldr	r3, [fp, #-16]
  1298f8:	e1d323b8 	ldrh	r2, [r3, #56]	; 0x38
  1298fc:	e51b3008 	ldr	r3, [fp, #-8]
  129900:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
    netdev->flags |= lwip_netif->flags;
  129904:	e51b3008 	ldr	r3, [fp, #-8]
  129908:	e1d322ba 	ldrh	r2, [r3, #42]	; 0x2a
  12990c:	e51b3010 	ldr	r3, [fp, #-16]
  129910:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  129914:	e6ff3073 	uxth	r3, r3
  129918:	e1823003 	orr	r3, r2, r3
  12991c:	e6ff2073 	uxth	r2, r3
  129920:	e51b3008 	ldr	r3, [fp, #-8]
  129924:	e1c322ba 	strh	r2, [r3, #42]	; 0x2a

    return ERR_OK;
  129928:	e3a03000 	mov	r3, #0
}
  12992c:	e1a00003 	mov	r0, r3
  129930:	e24bd004 	sub	sp, fp, #4
  129934:	e8bd8800 	pop	{fp, pc}

00129938 <ethernetif_linkoutput>:
// #endif /* RT_USING_NETDEV */

static err_t ethernetif_linkoutput(struct netif *netif, struct pbuf *p)
{
  129938:	e92d4800 	push	{fp, lr}
  12993c:	e28db004 	add	fp, sp, #4
  129940:	e24dd010 	sub	sp, sp, #16
  129944:	e50b0010 	str	r0, [fp, #-16]
  129948:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
//         return ERR_IF;
//     }
// #endif
    struct eth_device* enetif;

    RT_ASSERT(netif != RT_NULL);
  12994c:	e51b3010 	ldr	r3, [fp, #-16]
  129950:	e3530000 	cmp	r3, #0
  129954:	1a000005 	bne	129970 <ethernetif_linkoutput+0x38>
  129958:	e30021a5 	movw	r2, #421	; 0x1a5
  12995c:	e3081f14 	movw	r1, #36628	; 0x8f14
  129960:	e3401014 	movt	r1, #20
  129964:	e3080e0c 	movw	r0, #36364	; 0x8e0c
  129968:	e3400014 	movt	r0, #20
  12996c:	ebff6709 	bl	103598 <rt_assert_handler>
    enetif = (struct eth_device*)netif->state;
  129970:	e51b3010 	ldr	r3, [fp, #-16]
  129974:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  129978:	e50b3008 	str	r3, [fp, #-8]

    if (enetif->eth_tx(&(enetif->parent), p) != RT_EOK)
  12997c:	e51b3008 	ldr	r3, [fp, #-8]
  129980:	e5933074 	ldr	r3, [r3, #116]	; 0x74
  129984:	e51b2008 	ldr	r2, [fp, #-8]
  129988:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  12998c:	e1a00002 	mov	r0, r2
  129990:	e12fff33 	blx	r3
  129994:	e1a03000 	mov	r3, r0
  129998:	e3530000 	cmp	r3, #0
  12999c:	0a000001 	beq	1299a8 <ethernetif_linkoutput+0x70>
    {
        return ERR_IF;
  1299a0:	e3e0300b 	mvn	r3, #11
  1299a4:	ea000000 	b	1299ac <ethernetif_linkoutput+0x74>
    }
    return ERR_OK;
  1299a8:	e3a03000 	mov	r3, #0
}
  1299ac:	e1a00003 	mov	r0, r3
  1299b0:	e24bd004 	sub	sp, fp, #4
  1299b4:	e8bd8800 	pop	{fp, pc}

001299b8 <eth_netif_device_init>:

static err_t eth_netif_device_init(struct netif *netif)
{
  1299b8:	e92d4800 	push	{fp, lr}
  1299bc:	e28db004 	add	fp, sp, #4
  1299c0:	e24dd010 	sub	sp, sp, #16
  1299c4:	e50b0010 	str	r0, [fp, #-16]
    struct eth_device *ethif;

    ethif = (struct eth_device*)netif->state;
  1299c8:	e51b3010 	ldr	r3, [fp, #-16]
  1299cc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  1299d0:	e50b3008 	str	r3, [fp, #-8]
    if (ethif != RT_NULL)
  1299d4:	e51b3008 	ldr	r3, [fp, #-8]
  1299d8:	e3530000 	cmp	r3, #0
  1299dc:	0a000032 	beq	129aac <eth_netif_device_init+0xf4>
    {
        rt_device_t device;

#ifdef RT_USING_NETDEV
    /* network interface device register */
    netdev_add(netif);
  1299e0:	e51b0010 	ldr	r0, [fp, #-16]
  1299e4:	ebffff33 	bl	1296b8 <netdev_add>
#endif /* RT_USING_NETDEV */

        /* get device object */
        device = (rt_device_t) ethif;
  1299e8:	e51b3008 	ldr	r3, [fp, #-8]
  1299ec:	e50b300c 	str	r3, [fp, #-12]
        if (ueth_device_init(device) != RT_EOK)
  1299f0:	e51b000c 	ldr	r0, [fp, #-12]
  1299f4:	ebff6ca5 	bl	104c90 <ueth_device_init>
  1299f8:	e1a03000 	mov	r3, r0
  1299fc:	e3530000 	cmp	r3, #0
  129a00:	0a000001 	beq	129a0c <eth_netif_device_init+0x54>
        // if (rt_device_init(device) != RT_EOK)
        {
            return ERR_IF;
  129a04:	e3e0300b 	mvn	r3, #11
  129a08:	ea000028 	b	129ab0 <eth_netif_device_init+0xf8>
        }

        /* copy device flags to netif flags */
        netif->flags = (ethif->flags & 0xff);
  129a0c:	e51b3008 	ldr	r3, [fp, #-8]
  129a10:	e1d336bc 	ldrh	r3, [r3, #108]	; 0x6c
  129a14:	e6ef2073 	uxtb	r2, r3
  129a18:	e51b3010 	ldr	r3, [fp, #-16]
  129a1c:	e5c32041 	strb	r2, [r3, #65]	; 0x41
        netif->mtu = ETHERNET_MTU;
  129a20:	e51b3010 	ldr	r3, [fp, #-16]
  129a24:	e30025dc 	movw	r2, #1500	; 0x5dc
  129a28:	e1c323b8 	strh	r2, [r3, #56]	; 0x38
        
        /* set output */
        netif->output       = etharp_output;
  129a2c:	e51b2010 	ldr	r2, [fp, #-16]
  129a30:	e30e3b74 	movw	r3, #60276	; 0xeb74
  129a34:	e3403012 	movt	r3, #18
  129a38:	e5823014 	str	r3, [r2, #20]
#endif /* LWIP_IPV6_MLD */

#endif /* LWIP_IPV6 */

        /* set default netif */
        if (netif_default == RT_NULL)
  129a3c:	e3063838 	movw	r3, #26680	; 0x6838
  129a40:	e3403057 	movt	r3, #87	; 0x57
  129a44:	e5933000 	ldr	r3, [r3]
  129a48:	e3530000 	cmp	r3, #0
  129a4c:	1a000003 	bne	129a60 <eth_netif_device_init+0xa8>
            netif_set_default(ethif->netif);
  129a50:	e51b3008 	ldr	r3, [fp, #-8]
  129a54:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  129a58:	e1a00003 	mov	r0, r3
  129a5c:	ebffc04e 	bl	119b9c <netif_set_default>
#if LWIP_DHCP
        /* set interface up */
        netif_set_up(ethif->netif);
  129a60:	e51b3008 	ldr	r3, [fp, #-8]
  129a64:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  129a68:	e1a00003 	mov	r0, r3
  129a6c:	ebffc056 	bl	119bcc <netif_set_up>
        /* if this interface uses DHCP, start the DHCP client */
        dhcp_start(ethif->netif);
  129a70:	e51b3008 	ldr	r3, [fp, #-8]
  129a74:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  129a78:	e1a00003 	mov	r0, r3
  129a7c:	eb00051b 	bl	12aef0 <dhcp_start>
#else
        /* set interface up */
        netif_set_up(ethif->netif);
#endif
        if (ethif->flags & ETHIF_LINK_PHYUP)
  129a80:	e51b3008 	ldr	r3, [fp, #-8]
  129a84:	e1d336bc 	ldrh	r3, [r3, #108]	; 0x6c
  129a88:	e2033c01 	and	r3, r3, #256	; 0x100
  129a8c:	e3530000 	cmp	r3, #0
  129a90:	0a000003 	beq	129aa4 <eth_netif_device_init+0xec>
        {
            /* set link_up for this netif */
            netif_set_link_up(ethif->netif);
  129a94:	e51b3008 	ldr	r3, [fp, #-8]
  129a98:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  129a9c:	e1a00003 	mov	r0, r3
  129aa0:	ebffc0de 	bl	119e20 <netif_set_link_up>
        }
        return ERR_OK;
  129aa4:	e3a03000 	mov	r3, #0
  129aa8:	ea000000 	b	129ab0 <eth_netif_device_init+0xf8>
    }

    return ERR_IF;
  129aac:	e3e0300b 	mvn	r3, #11
}
  129ab0:	e1a00003 	mov	r0, r3
  129ab4:	e24bd004 	sub	sp, fp, #4
  129ab8:	e8bd8800 	pop	{fp, pc}

00129abc <eth_device_init_with_flag>:

/* Keep old drivers compatible in RT-Thread */
rt_err_t eth_device_init_with_flag(struct eth_device *dev, const char *name, rt_uint16_t flags)
{
  129abc:	e92d4800 	push	{fp, lr}
  129ac0:	e28db004 	add	fp, sp, #4
  129ac4:	e24dd038 	sub	sp, sp, #56	; 0x38
  129ac8:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  129acc:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  129ad0:	e1a03002 	mov	r3, r2
  129ad4:	e14b32b6 	strh	r3, [fp, #-38]	; 0xffffffda
    struct netif* netif;
#if LWIP_NETIF_HOSTNAME
#define LWIP_HOSTNAME_LEN 16
    char *hostname = RT_NULL;
  129ad8:	e3a03000 	mov	r3, #0
  129adc:	e50b3008 	str	r3, [fp, #-8]
    netif = (struct netif*) rt_calloc (1, sizeof(struct netif) + LWIP_HOSTNAME_LEN);
  129ae0:	e3a01098 	mov	r1, #152	; 0x98
  129ae4:	e3a00001 	mov	r0, #1
  129ae8:	ebff6547 	bl	10300c <rt_calloc>
  129aec:	e50b000c 	str	r0, [fp, #-12]
#else
    netif = (struct netif*) rt_calloc (1, sizeof(struct netif));
#endif
    if (netif == RT_NULL)
  129af0:	e51b300c 	ldr	r3, [fp, #-12]
  129af4:	e3530000 	cmp	r3, #0
  129af8:	1a000004 	bne	129b10 <eth_device_init_with_flag+0x54>
    {
        rt_kprintf("malloc netif failed\n");
  129afc:	e3080e20 	movw	r0, #36384	; 0x8e20
  129b00:	e3400014 	movt	r0, #20
  129b04:	ebff6582 	bl	103114 <rt_kprintf>
        return -RT_ERROR;
  129b08:	e3e03000 	mvn	r3, #0
  129b0c:	ea00005b 	b	129c80 <eth_device_init_with_flag+0x1c4>
    }

    /* set netif */
    dev->netif = netif;
  129b10:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  129b14:	e51b200c 	ldr	r2, [fp, #-12]
  129b18:	e5832044 	str	r2, [r3, #68]	; 0x44
    /* device flags, which will be set to netif flags when initializing */
    dev->flags = flags;
  129b1c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  129b20:	e15b22b6 	ldrh	r2, [fp, #-38]	; 0xffffffda
  129b24:	e1c326bc 	strh	r2, [r3, #108]	; 0x6c
    /* link changed status of device */
    dev->link_changed = 0x00;
  129b28:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  129b2c:	e3a02000 	mov	r2, #0
  129b30:	e5c3206e 	strb	r2, [r3, #110]	; 0x6e
    dev->parent.type = RT_Device_Class_NetIf;
  129b34:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  129b38:	e3a02002 	mov	r2, #2
  129b3c:	e5832018 	str	r2, [r3, #24]
    /* register to RT-Thread device manager */
   // rt_device_register(&(dev->parent), name, RT_DEVICE_FLAG_RDWR);
    ueth_device_register(&(dev->parent), name, RT_DEVICE_FLAG_RDWR);
  129b40:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  129b44:	e3a02003 	mov	r2, #3
  129b48:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  129b4c:	e1a00003 	mov	r0, r3
  129b50:	ebff6bc1 	bl	104a5c <ueth_device_register>
    rt_sem_init(&(dev->tx_ack), name, 0, RT_IPC_FLAG_FIFO);
  129b54:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  129b58:	e2830048 	add	r0, r3, #72	; 0x48
  129b5c:	e3a03000 	mov	r3, #0
  129b60:	e3a02000 	mov	r2, #0
  129b64:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  129b68:	ebff5d47 	bl	10108c <rt_sem_init>

    /* set name */
    netif->name[0] = name[0];
  129b6c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  129b70:	e5d32000 	ldrb	r2, [r3]
  129b74:	e51b300c 	ldr	r3, [fp, #-12]
  129b78:	e5c32042 	strb	r2, [r3, #66]	; 0x42
    netif->name[1] = name[1];
  129b7c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  129b80:	e5d32001 	ldrb	r2, [r3, #1]
  129b84:	e51b300c 	ldr	r3, [fp, #-12]
  129b88:	e5c32043 	strb	r2, [r3, #67]	; 0x43

    /* set hw address to 6 */
    netif->hwaddr_len   = 6;
  129b8c:	e51b300c 	ldr	r3, [fp, #-12]
  129b90:	e3a02006 	mov	r2, #6
  129b94:	e5c3203a 	strb	r2, [r3, #58]	; 0x3a
    /* maximum transfer unit */
    netif->mtu          = ETHERNET_MTU;
  129b98:	e51b300c 	ldr	r3, [fp, #-12]
  129b9c:	e30025dc 	movw	r2, #1500	; 0x5dc
  129ba0:	e1c323b8 	strh	r2, [r3, #56]	; 0x38

    /* set linkoutput */
    netif->linkoutput   = ethernetif_linkoutput;
  129ba4:	e51b200c 	ldr	r2, [fp, #-12]
  129ba8:	e3093938 	movw	r3, #39224	; 0x9938
  129bac:	e3403012 	movt	r3, #18
  129bb0:	e5823018 	str	r3, [r2, #24]
        
    /* get hardware MAC address */
    ueth_device_control(&(dev->parent), NIOCTL_GADDR, netif->hwaddr);
  129bb4:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  129bb8:	e51b300c 	ldr	r3, [fp, #-12]
  129bbc:	e283303b 	add	r3, r3, #59	; 0x3b
  129bc0:	e1a02003 	mov	r2, r3
  129bc4:	e3a01001 	mov	r1, #1
  129bc8:	ebff6cb0 	bl	104e90 <ueth_device_control>
    

#if LWIP_NETIF_HOSTNAME
    /* Initialize interface hostname */
    hostname = (char *)netif + sizeof(struct netif);
  129bcc:	e51b300c 	ldr	r3, [fp, #-12]
  129bd0:	e2833088 	add	r3, r3, #136	; 0x88
  129bd4:	e50b3008 	str	r3, [fp, #-8]
    rt_sprintf(hostname, "rtthread_%02x%02x", name[0], name[1]);
  129bd8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  129bdc:	e5d33000 	ldrb	r3, [r3]
  129be0:	e1a02003 	mov	r2, r3
  129be4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  129be8:	e2833001 	add	r3, r3, #1
  129bec:	e5d33000 	ldrb	r3, [r3]
  129bf0:	e3081e38 	movw	r1, #36408	; 0x8e38
  129bf4:	e3401014 	movt	r1, #20
  129bf8:	e51b0008 	ldr	r0, [fp, #-8]
  129bfc:	ebff6522 	bl	10308c <rt_sprintf>
    netif->hostname = hostname;
  129c00:	e51b300c 	ldr	r3, [fp, #-12]
  129c04:	e51b2008 	ldr	r2, [fp, #-8]
  129c08:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif /* LWIP_NETIF_HOSTNAME */
    /* if tcp thread has been started up, we add this netif to the system */
    if (rt_thread_find("tcpip") != RT_NULL)
  129c0c:	e3080e4c 	movw	r0, #36428	; 0x8e4c
  129c10:	e3400014 	movt	r0, #20
  129c14:	ebff6117 	bl	102078 <rt_thread_find>
  129c18:	e1a03000 	mov	r3, r0
  129c1c:	e3530000 	cmp	r3, #0
  129c20:	0a000013 	beq	129c74 <eth_device_init_with_flag+0x1b8>
#if !LWIP_DHCP
        ipaddr.addr = inet_addr(RT_LWIP_IPADDR);
        gw.addr = inet_addr(RT_LWIP_GWADDR);
        netmask.addr = inet_addr(RT_LWIP_MSKADDR);
#else        
        IP4_ADDR(&ipaddr, 0, 0, 0, 0);
  129c24:	e3a03000 	mov	r3, #0
  129c28:	e50b3010 	str	r3, [fp, #-16]
        IP4_ADDR(&gw, 0, 0, 0, 0);
  129c2c:	e3a03000 	mov	r3, #0
  129c30:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        IP4_ADDR(&netmask, 0, 0, 0, 0);
  129c34:	e3a03000 	mov	r3, #0
  129c38:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
#endif
        netifapi_netif_add(netif, &ipaddr, &netmask, &gw, dev, eth_netif_device_init, tcpip_input);
  129c3c:	e24b0018 	sub	r0, fp, #24
  129c40:	e24b2014 	sub	r2, fp, #20
  129c44:	e24b1010 	sub	r1, fp, #16
  129c48:	e306336c 	movw	r3, #25452	; 0x636c
  129c4c:	e3403011 	movt	r3, #17
  129c50:	e58d3008 	str	r3, [sp, #8]
  129c54:	e30939b8 	movw	r3, #39352	; 0x99b8
  129c58:	e3403012 	movt	r3, #18
  129c5c:	e58d3004 	str	r3, [sp, #4]
  129c60:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  129c64:	e58d3000 	str	r3, [sp]
  129c68:	e1a03000 	mov	r3, r0
  129c6c:	e51b000c 	ldr	r0, [fp, #-12]
  129c70:	ebff9c94 	bl	110ec8 <netifapi_netif_add>
    }
#ifdef RT_USING_NETDEV
    /* network interface device flags synchronize */
    netdev_flags_sync(netif);
  129c74:	e51b000c 	ldr	r0, [fp, #-12]
  129c78:	ebffff04 	bl	129890 <netdev_flags_sync>
#endif /* RT_USING_NETDEV */
    return RT_EOK;
  129c7c:	e3a03000 	mov	r3, #0
}
  129c80:	e1a00003 	mov	r0, r3
  129c84:	e24bd004 	sub	sp, fp, #4
  129c88:	e8bd8800 	pop	{fp, pc}

00129c8c <eth_device_init>:

rt_err_t eth_device_init(struct eth_device * dev, const char *name)
{
  129c8c:	e92d4800 	push	{fp, lr}
  129c90:	e28db004 	add	fp, sp, #4
  129c94:	e24dd010 	sub	sp, sp, #16
  129c98:	e50b0010 	str	r0, [fp, #-16]
  129c9c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    rt_uint16_t flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
  129ca0:	e3a0300a 	mov	r3, #10
  129ca4:	e14b30b6 	strh	r3, [fp, #-6]

#if LWIP_IGMP
    /* IGMP support */
    flags |= NETIF_FLAG_IGMP;
  129ca8:	e15b30b6 	ldrh	r3, [fp, #-6]
  129cac:	e3833020 	orr	r3, r3, #32
  129cb0:	e14b30b6 	strh	r3, [fp, #-6]
#endif
    return eth_device_init_with_flag(dev, name, flags);
  129cb4:	e15b30b6 	ldrh	r3, [fp, #-6]
  129cb8:	e1a02003 	mov	r2, r3
  129cbc:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  129cc0:	e51b0010 	ldr	r0, [fp, #-16]
  129cc4:	ebffff7c 	bl	129abc <eth_device_init_with_flag>
  129cc8:	e1a03000 	mov	r3, r0
}
  129ccc:	e1a00003 	mov	r0, r3
  129cd0:	e24bd004 	sub	sp, fp, #4
  129cd4:	e8bd8800 	pop	{fp, pc}

00129cd8 <eth_device_deinit>:

void eth_device_deinit(struct eth_device *dev)
{
  129cd8:	e92d4800 	push	{fp, lr}
  129cdc:	e28db004 	add	fp, sp, #4
  129ce0:	e24dd010 	sub	sp, sp, #16
  129ce4:	e50b0010 	str	r0, [fp, #-16]
    struct netif* netif = dev->netif;
  129ce8:	e51b3010 	ldr	r3, [fp, #-16]
  129cec:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  129cf0:	e50b3008 	str	r3, [fp, #-8]

#if LWIP_DHCP
    dhcp_stop(netif);
  129cf4:	e51b0008 	ldr	r0, [fp, #-8]
  129cf8:	eb0008f4 	bl	12c0d0 <dhcp_stop>
    dhcp_cleanup(netif);
  129cfc:	e51b0008 	ldr	r0, [fp, #-8]
  129d00:	eb00045e 	bl	12ae80 <dhcp_cleanup>
#endif
    netif_set_down(netif);
  129d04:	e51b0008 	ldr	r0, [fp, #-8]
  129d08:	ebffc004 	bl	119d20 <netif_set_down>
    netif_remove(netif);
  129d0c:	e51b0008 	ldr	r0, [fp, #-8]
  129d10:	ebffbe9d 	bl	11978c <netif_remove>
// #ifdef RT_USING_NETDEV
    netdev_del(netif);
  129d14:	e51b0008 	ldr	r0, [fp, #-8]
  129d18:	ebfffebe 	bl	129818 <netdev_del>
// #endif
    ueth_device_close(&(dev->parent));
  129d1c:	e51b3010 	ldr	r3, [fp, #-16]
  129d20:	e1a00003 	mov	r0, r3
  129d24:	ebff6c16 	bl	104d84 <ueth_device_close>
    ueth_device_unregister(&(dev->parent));
  129d28:	e51b3010 	ldr	r3, [fp, #-16]
  129d2c:	e1a00003 	mov	r0, r3
  129d30:	ebff6b9b 	bl	104ba4 <ueth_device_unregister>
    rt_sem_detach(&(dev->tx_ack));
  129d34:	e51b3010 	ldr	r3, [fp, #-16]
  129d38:	e2833048 	add	r3, r3, #72	; 0x48
  129d3c:	e1a00003 	mov	r0, r3
  129d40:	ebff5d17 	bl	1011a4 <rt_sem_detach>
    rt_free(netif);
  129d44:	e51b0008 	ldr	r0, [fp, #-8]
  129d48:	ebff649b 	bl	102fbc <rt_free>
}
  129d4c:	e320f000 	nop	{0}
  129d50:	e24bd004 	sub	sp, fp, #4
  129d54:	e8bd8800 	pop	{fp, pc}

00129d58 <eth_device_ready>:
}
#endif /* SAL_USING_AF_UNIX */

#ifndef LWIP_NO_RX_THREAD
rt_err_t eth_device_ready(struct eth_device* dev)
{
  129d58:	e92d4800 	push	{fp, lr}
  129d5c:	e28db004 	add	fp, sp, #4
  129d60:	e24dd008 	sub	sp, sp, #8
  129d64:	e50b0008 	str	r0, [fp, #-8]
    if (dev->netif)
  129d68:	e51b3008 	ldr	r3, [fp, #-8]
  129d6c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  129d70:	e3530000 	cmp	r3, #0
  129d74:	0a000006 	beq	129d94 <eth_device_ready+0x3c>
    {
        /* post message to Ethernet thread */
        return rt_mb_send(&eth_rx_thread_mb, (rt_ubase_t)dev);        
  129d78:	e51b3008 	ldr	r3, [fp, #-8]
  129d7c:	e1a01003 	mov	r1, r3
  129d80:	e30f0694 	movw	r0, #63124	; 0xf694
  129d84:	e3400014 	movt	r0, #20
  129d88:	ebff5e1d 	bl	101604 <rt_mb_send>
  129d8c:	e1a03000 	mov	r3, r0
  129d90:	ea000000 	b	129d98 <eth_device_ready+0x40>
    }
    else
        return ERR_OK; /* netif is not initialized yet, just return. */
  129d94:	e3a03000 	mov	r3, #0
}
  129d98:	e1a00003 	mov	r0, r3
  129d9c:	e24bd004 	sub	sp, fp, #4
  129da0:	e8bd8800 	pop	{fp, pc}

00129da4 <eth_device_linkchange>:

rt_err_t eth_device_linkchange(struct eth_device* dev, rt_bool_t up)
{
  129da4:	e92d4800 	push	{fp, lr}
  129da8:	e28db004 	add	fp, sp, #4
  129dac:	e24dd010 	sub	sp, sp, #16
  129db0:	e50b0010 	str	r0, [fp, #-16]
  129db4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    // rt_uint32_t level;

    RT_ASSERT(dev != RT_NULL);
  129db8:	e51b3010 	ldr	r3, [fp, #-16]
  129dbc:	e3530000 	cmp	r3, #0
  129dc0:	1a000005 	bne	129ddc <eth_device_linkchange+0x38>
  129dc4:	e3a02fc3 	mov	r2, #780	; 0x30c
  129dc8:	e3081f2c 	movw	r1, #36652	; 0x8f2c
  129dcc:	e3401014 	movt	r1, #20
  129dd0:	e3080e54 	movw	r0, #36436	; 0x8e54
  129dd4:	e3400014 	movt	r0, #20
  129dd8:	ebff65ee 	bl	103598 <rt_assert_handler>

    // level = rt_hw_interrupt_disable();
    dev->link_changed = 0x01;
  129ddc:	e51b3010 	ldr	r3, [fp, #-16]
  129de0:	e3a02001 	mov	r2, #1
  129de4:	e5c3206e 	strb	r2, [r3, #110]	; 0x6e
    if (up == RT_TRUE)
  129de8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  129dec:	e3530001 	cmp	r3, #1
  129df0:	1a000003 	bne	129e04 <eth_device_linkchange+0x60>
        dev->link_status = 0x01;
  129df4:	e51b3010 	ldr	r3, [fp, #-16]
  129df8:	e3a02001 	mov	r2, #1
  129dfc:	e5c3206f 	strb	r2, [r3, #111]	; 0x6f
  129e00:	ea000002 	b	129e10 <eth_device_linkchange+0x6c>
    else
        dev->link_status = 0x00;
  129e04:	e51b3010 	ldr	r3, [fp, #-16]
  129e08:	e3a02000 	mov	r2, #0
  129e0c:	e5c3206f 	strb	r2, [r3, #111]	; 0x6f
    // rt_hw_interrupt_enable(level);
    
    // rt_uint32_t level;
    // level = rt_hw_interrupt_disable();
    int status = dev->link_status;
  129e10:	e51b3010 	ldr	r3, [fp, #-16]
  129e14:	e5d3306f 	ldrb	r3, [r3, #111]	; 0x6f
  129e18:	e50b3008 	str	r3, [fp, #-8]
    dev->link_changed = 0x00;
  129e1c:	e51b3010 	ldr	r3, [fp, #-16]
  129e20:	e3a02000 	mov	r2, #0
  129e24:	e5c3206e 	strb	r2, [r3, #110]	; 0x6e
    // rt_hw_interrupt_enable(level);

    if (status)
  129e28:	e51b3008 	ldr	r3, [fp, #-8]
  129e2c:	e3530000 	cmp	r3, #0
  129e30:	0a000007 	beq	129e54 <eth_device_linkchange+0xb0>
        netifapi_netif_set_link_up(dev->netif);
  129e34:	e51b3010 	ldr	r3, [fp, #-16]
  129e38:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  129e3c:	e3a02000 	mov	r2, #0
  129e40:	e3091e20 	movw	r1, #40480	; 0x9e20
  129e44:	e3401011 	movt	r1, #17
  129e48:	e1a00003 	mov	r0, r3
  129e4c:	ebff9c7b 	bl	111040 <netifapi_netif_common>
  129e50:	ea000006 	b	129e70 <eth_device_linkchange+0xcc>
    else
        netifapi_netif_set_link_down(dev->netif);
  129e54:	e51b3010 	ldr	r3, [fp, #-16]
  129e58:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  129e5c:	e3a02000 	mov	r2, #0
  129e60:	e3091ed0 	movw	r1, #40656	; 0x9ed0
  129e64:	e3401011 	movt	r1, #17
  129e68:	e1a00003 	mov	r0, r3
  129e6c:	ebff9c73 	bl	111040 <netifapi_netif_common>

    return RT_EOK;
  129e70:	e3a03000 	mov	r3, #0
}
  129e74:	e1a00003 	mov	r0, r3
  129e78:	e24bd004 	sub	sp, fp, #4
  129e7c:	e8bd8800 	pop	{fp, pc}

00129e80 <eth_rx_thread_entry>:
#ifndef LWIP_NO_RX_THREAD

/* Ethernet Rx Thread */
extern void* ueth_rx_interrupt_detect(void);
static void eth_rx_thread_entry(void* parameter)
{
  129e80:	e92d4800 	push	{fp, lr}
  129e84:	e28db004 	add	fp, sp, #4
  129e88:	e24dd010 	sub	sp, sp, #16
  129e8c:	e50b0010 	str	r0, [fp, #-16]
    struct eth_device* device;
    struct pbuf *p;

    while (!eth_init_done)
  129e90:	ea000001 	b	129e9c <eth_rx_thread_entry+0x1c>
    {
        rt_thread_mdelay(10);
  129e94:	e3a0000a 	mov	r0, #10
  129e98:	ebff5ff7 	bl	101e7c <rt_thread_mdelay>
    while (!eth_init_done)
  129e9c:	e30f3bf0 	movw	r3, #64496	; 0xfbf0
  129ea0:	e3403014 	movt	r3, #20
  129ea4:	e5933000 	ldr	r3, [r3]
  129ea8:	e3530000 	cmp	r3, #0
  129eac:	0afffff8 	beq	129e94 <eth_rx_thread_entry+0x14>
    }

    while (1)
    {
        device = (struct eth_device*)ueth_rx_interrupt_detect();
  129eb0:	eb002e61 	bl	13583c <ueth_rx_interrupt_detect>
  129eb4:	e50b0008 	str	r0, [fp, #-8]
        if(device->eth_rx == RT_NULL) break;
  129eb8:	e51b3008 	ldr	r3, [fp, #-8]
  129ebc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  129ec0:	e3530000 	cmp	r3, #0
  129ec4:	0a00001a 	beq	129f34 <eth_rx_thread_entry+0xb4>

        /* receive all of buffer */
        while (1)
        {
            p = device->eth_rx(&(device->parent));
  129ec8:	e51b3008 	ldr	r3, [fp, #-8]
  129ecc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
  129ed0:	e51b2008 	ldr	r2, [fp, #-8]
  129ed4:	e1a00002 	mov	r0, r2
  129ed8:	e12fff33 	blx	r3
  129edc:	e50b000c 	str	r0, [fp, #-12]
            if (p != RT_NULL)
  129ee0:	e51b300c 	ldr	r3, [fp, #-12]
  129ee4:	e3530000 	cmp	r3, #0
  129ee8:	0a00000f 	beq	129f2c <eth_rx_thread_entry+0xac>
            {
                /* notify to upper layer */
                if(device->netif->input(p, device->netif) != ERR_OK)
  129eec:	e51b3008 	ldr	r3, [fp, #-8]
  129ef0:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  129ef4:	e5933010 	ldr	r3, [r3, #16]
  129ef8:	e51b2008 	ldr	r2, [fp, #-8]
  129efc:	e5922044 	ldr	r2, [r2, #68]	; 0x44
  129f00:	e1a01002 	mov	r1, r2
  129f04:	e51b000c 	ldr	r0, [fp, #-12]
  129f08:	e12fff33 	blx	r3
  129f0c:	e1a03000 	mov	r3, r0
  129f10:	e3530000 	cmp	r3, #0
  129f14:	0affffeb 	beq	129ec8 <eth_rx_thread_entry+0x48>
                {
                    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: Input error\n"));
                    pbuf_free(p);
  129f18:	e51b000c 	ldr	r0, [fp, #-12]
  129f1c:	ebffc464 	bl	11b0b4 <pbuf_free>
                    p = NULL;
  129f20:	e3a03000 	mov	r3, #0
  129f24:	e50b300c 	str	r3, [fp, #-12]
            p = device->eth_rx(&(device->parent));
  129f28:	eaffffe6 	b	129ec8 <eth_rx_thread_entry+0x48>
                }
            }
            else break;
  129f2c:	e320f000 	nop	{0}
        device = (struct eth_device*)ueth_rx_interrupt_detect();
  129f30:	eaffffde 	b	129eb0 <eth_rx_thread_entry+0x30>
        if(device->eth_rx == RT_NULL) break;
  129f34:	e320f000 	nop	{0}
        }
    }
}
  129f38:	e320f000 	nop	{0}
  129f3c:	e24bd004 	sub	sp, fp, #4
  129f40:	e8bd8800 	pop	{fp, pc}

00129f44 <eth_system_device_init>:
/* this function does not need, 
 * use eth_system_device_init_private() 
 * call by lwip_system_init(). 
 */
int eth_system_device_init(void)
{
  129f44:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  129f48:	e28db000 	add	fp, sp, #0
    return 0;
  129f4c:	e3a03000 	mov	r3, #0
}
  129f50:	e1a00003 	mov	r0, r3
  129f54:	e28bd000 	add	sp, fp, #0
  129f58:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  129f5c:	e12fff1e 	bx	lr

00129f60 <eth_system_device_init_private>:
int eth_system_device_init_private(void)
{
  129f60:	e92d4800 	push	{fp, lr}
  129f64:	e28db004 	add	fp, sp, #4
  129f68:	e24dd010 	sub	sp, sp, #16
    rt_err_t result = RT_EOK;
  129f6c:	e3a03000 	mov	r3, #0
  129f70:	e50b3008 	str	r3, [fp, #-8]

    /* initialize Rx thread. */
#ifndef LWIP_NO_RX_THREAD
    /* initialize mailbox and create Ethernet Rx thread */
    result = rt_mb_init(&eth_rx_thread_mb, "erxmb",
  129f74:	e3a03000 	mov	r3, #0
  129f78:	e58d3000 	str	r3, [sp]
  129f7c:	e3a03c01 	mov	r3, #256	; 0x100
  129f80:	e30f26c8 	movw	r2, #63176	; 0xf6c8
  129f84:	e3402014 	movt	r2, #20
  129f88:	e3081e64 	movw	r1, #36452	; 0x8e64
  129f8c:	e3401014 	movt	r1, #20
  129f90:	e30f0694 	movw	r0, #63124	; 0xf694
  129f94:	e3400014 	movt	r0, #20
  129f98:	ebff5d0c 	bl	1013d0 <rt_mb_init>
  129f9c:	e50b0008 	str	r0, [fp, #-8]
                        &eth_rx_thread_mb_pool[0], sizeof(eth_rx_thread_mb_pool)/sizeof(void *),
                        RT_IPC_FLAG_FIFO);
    RT_ASSERT(result == RT_EOK);
  129fa0:	e51b3008 	ldr	r3, [fp, #-8]
  129fa4:	e3530000 	cmp	r3, #0
  129fa8:	0a000005 	beq	129fc4 <eth_system_device_init_private+0x64>
  129fac:	e300238e 	movw	r2, #910	; 0x38e
  129fb0:	e3081f44 	movw	r1, #36676	; 0x8f44
  129fb4:	e3401014 	movt	r1, #20
  129fb8:	e3080e6c 	movw	r0, #36460	; 0x8e6c
  129fbc:	e3400014 	movt	r0, #20
  129fc0:	ebff6574 	bl	103598 <rt_assert_handler>

    rt_thread_t erx_tid = rt_thread_create("erx", eth_rx_thread_entry, RT_NULL, RT_LWIP_ETHTHREAD_STACKSIZE, 25, 16);
  129fc4:	e3a03010 	mov	r3, #16
  129fc8:	e58d3004 	str	r3, [sp, #4]
  129fcc:	e3a03019 	mov	r3, #25
  129fd0:	e58d3000 	str	r3, [sp]
  129fd4:	e3a03a02 	mov	r3, #8192	; 0x2000
  129fd8:	e3a02000 	mov	r2, #0
  129fdc:	e3091e80 	movw	r1, #40576	; 0x9e80
  129fe0:	e3401012 	movt	r1, #18
  129fe4:	e3080e80 	movw	r0, #36480	; 0x8e80
  129fe8:	e3400014 	movt	r0, #20
  129fec:	ebff6040 	bl	1020f4 <rt_thread_create>
  129ff0:	e50b000c 	str	r0, [fp, #-12]
    // rt_thread_t erx_tid = rt_thread_create("erx", eth_rx_thread_entry, RT_NULL, RT_LWIP_ETHTHREAD_STACKSIZE, 30, 16);
    result = rt_thread_startup(erx_tid);
  129ff4:	e51b000c 	ldr	r0, [fp, #-12]
  129ff8:	ebff6072 	bl	1021c8 <rt_thread_startup>
  129ffc:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(result == RT_EOK);
  12a000:	e51b3008 	ldr	r3, [fp, #-8]
  12a004:	e3530000 	cmp	r3, #0
  12a008:	0a000005 	beq	12a024 <eth_system_device_init_private+0xc4>
  12a00c:	e3002393 	movw	r2, #915	; 0x393
  12a010:	e3081f44 	movw	r1, #36676	; 0x8f44
  12a014:	e3401014 	movt	r1, #20
  12a018:	e3080e6c 	movw	r0, #36460	; 0x8e6c
  12a01c:	e3400014 	movt	r0, #20
  12a020:	ebff655c 	bl	103598 <rt_assert_handler>
#endif

    /* initialize Tx thread */
#ifndef LWIP_NO_TX_THREAD
    /* initialize mailbox and create Ethernet Tx thread */
    result = rt_mb_init(&eth_tx_thread_mb, "etxmb",
  12a024:	e3a03000 	mov	r3, #0
  12a028:	e58d3000 	str	r3, [sp]
  12a02c:	e3a03c01 	mov	r3, #256	; 0x100
  12a030:	e30f2294 	movw	r2, #62100	; 0xf294
  12a034:	e3402014 	movt	r2, #20
  12a038:	e3081e84 	movw	r1, #36484	; 0x8e84
  12a03c:	e3401014 	movt	r1, #20
  12a040:	e30f0260 	movw	r0, #62048	; 0xf260
  12a044:	e3400014 	movt	r0, #20
  12a048:	ebff5ce0 	bl	1013d0 <rt_mb_init>
  12a04c:	e50b0008 	str	r0, [fp, #-8]
                        &eth_tx_thread_mb_pool[0], sizeof(eth_tx_thread_mb_pool)/sizeof(void *),
                        RT_IPC_FLAG_FIFO);
    RT_ASSERT(result == RT_EOK);
  12a050:	e51b3008 	ldr	r3, [fp, #-8]
  12a054:	e3530000 	cmp	r3, #0
  12a058:	0a000005 	beq	12a074 <eth_system_device_init_private+0x114>
  12a05c:	e30023a3 	movw	r2, #931	; 0x3a3
  12a060:	e3081f44 	movw	r1, #36676	; 0x8f44
  12a064:	e3401014 	movt	r1, #20
  12a068:	e3080e6c 	movw	r0, #36460	; 0x8e6c
  12a06c:	e3400014 	movt	r0, #20
  12a070:	ebff6548 	bl	103598 <rt_assert_handler>

    // rt_thread_t etx_tid = rt_thread_create("etx", eth_tx_thread_entry, RT_NULL, RT_LWIP_ETHTHREAD_STACKSIZE, RT_ETHERNETIF_THREAD_PREORITY, 16);
    // result = rt_thread_startup(etx_tid);
    // RT_ASSERT(result == RT_EOK);
#endif
    return (int)result;
  12a074:	e51b3008 	ldr	r3, [fp, #-8]
}
  12a078:	e1a00003 	mov	r0, r3
  12a07c:	e24bd004 	sub	sp, fp, #4
  12a080:	e8bd8800 	pop	{fp, pc}

0012a084 <set_if>:

void set_if(char* netif_name, char* ip_addr, char* gw_addr, char* nm_addr)
{
  12a084:	e92d4800 	push	{fp, lr}
  12a088:	e28db004 	add	fp, sp, #4
  12a08c:	e24dd020 	sub	sp, sp, #32
  12a090:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12a094:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  12a098:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  12a09c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    ip4_addr_t *ip;
    ip4_addr_t addr;
    struct netif * netif = netif_list;
  12a0a0:	e3063834 	movw	r3, #26676	; 0x6834
  12a0a4:	e3403057 	movt	r3, #87	; 0x57
  12a0a8:	e5933000 	ldr	r3, [r3]
  12a0ac:	e50b3008 	str	r3, [fp, #-8]

    if(strlen(netif_name) > sizeof(netif->name))
  12a0b0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12a0b4:	eb005d7f 	bl	1416b8 <strlen>
  12a0b8:	e1a03000 	mov	r3, r0
  12a0bc:	e3530002 	cmp	r3, #2
  12a0c0:	9a000017 	bls	12a124 <set_if+0xa0>
    {
        rt_kprintf("network interface name too long!\r\n");
  12a0c4:	e3080e8c 	movw	r0, #36492	; 0x8e8c
  12a0c8:	e3400014 	movt	r0, #20
  12a0cc:	ebff6410 	bl	103114 <rt_kprintf>
        return;
  12a0d0:	ea000041 	b	12a1dc <set_if+0x158>
    }

    while(netif != RT_NULL)
    {
        if(strncmp(netif_name, netif->name, sizeof(netif->name)) == 0)
  12a0d4:	e51b3008 	ldr	r3, [fp, #-8]
  12a0d8:	e2833042 	add	r3, r3, #66	; 0x42
  12a0dc:	e3a02002 	mov	r2, #2
  12a0e0:	e1a01003 	mov	r1, r3
  12a0e4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12a0e8:	eb005d9e 	bl	141768 <strncmp>
  12a0ec:	e1a03000 	mov	r3, r0
  12a0f0:	e3530000 	cmp	r3, #0
  12a0f4:	0a00000e 	beq	12a134 <set_if+0xb0>
            break;

        netif = netif->next;
  12a0f8:	e51b3008 	ldr	r3, [fp, #-8]
  12a0fc:	e5933000 	ldr	r3, [r3]
  12a100:	e50b3008 	str	r3, [fp, #-8]
        if( netif == RT_NULL )
  12a104:	e51b3008 	ldr	r3, [fp, #-8]
  12a108:	e3530000 	cmp	r3, #0
  12a10c:	1a000004 	bne	12a124 <set_if+0xa0>
        {
            rt_kprintf("network interface: %s not found!\r\n", netif_name);
  12a110:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  12a114:	e3080eb0 	movw	r0, #36528	; 0x8eb0
  12a118:	e3400014 	movt	r0, #20
  12a11c:	ebff63fc 	bl	103114 <rt_kprintf>
            return;
  12a120:	ea00002d 	b	12a1dc <set_if+0x158>
    while(netif != RT_NULL)
  12a124:	e51b3008 	ldr	r3, [fp, #-8]
  12a128:	e3530000 	cmp	r3, #0
  12a12c:	1affffe8 	bne	12a0d4 <set_if+0x50>
  12a130:	ea000000 	b	12a138 <set_if+0xb4>
            break;
  12a134:	e320f000 	nop	{0}
        }
    }

    ip = (ip4_addr_t *)&addr;
  12a138:	e24b3010 	sub	r3, fp, #16
  12a13c:	e50b300c 	str	r3, [fp, #-12]

    /* set ip address */
    if ((ip_addr != RT_NULL) && ip4addr_aton(ip_addr, &addr))
  12a140:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12a144:	e3530000 	cmp	r3, #0
  12a148:	0a000009 	beq	12a174 <set_if+0xf0>
  12a14c:	e24b3010 	sub	r3, fp, #16
  12a150:	e1a01003 	mov	r1, r3
  12a154:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  12a158:	eb0021e1 	bl	1328e4 <ip4addr_aton>
  12a15c:	e1a03000 	mov	r3, r0
  12a160:	e3530000 	cmp	r3, #0
  12a164:	0a000002 	beq	12a174 <set_if+0xf0>
    {
        netif_set_ipaddr(netif, ip);
  12a168:	e51b100c 	ldr	r1, [fp, #-12]
  12a16c:	e51b0008 	ldr	r0, [fp, #-8]
  12a170:	ebffbe10 	bl	1199b8 <netif_set_ipaddr>
    }

    /* set gateway address */
    if ((gw_addr != RT_NULL) && ip4addr_aton(gw_addr, &addr))
  12a174:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12a178:	e3530000 	cmp	r3, #0
  12a17c:	0a000009 	beq	12a1a8 <set_if+0x124>
  12a180:	e24b3010 	sub	r3, fp, #16
  12a184:	e1a01003 	mov	r1, r3
  12a188:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  12a18c:	eb0021d4 	bl	1328e4 <ip4addr_aton>
  12a190:	e1a03000 	mov	r3, r0
  12a194:	e3530000 	cmp	r3, #0
  12a198:	0a000002 	beq	12a1a8 <set_if+0x124>
    {
        netif_set_gw(netif, ip);
  12a19c:	e51b100c 	ldr	r1, [fp, #-12]
  12a1a0:	e51b0008 	ldr	r0, [fp, #-8]
  12a1a4:	ebffbe4a 	bl	119ad4 <netif_set_gw>
    }

    /* set netmask address */
    if ((nm_addr != RT_NULL) && ip4addr_aton(nm_addr, &addr))
  12a1a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  12a1ac:	e3530000 	cmp	r3, #0
  12a1b0:	0a000009 	beq	12a1dc <set_if+0x158>
  12a1b4:	e24b3010 	sub	r3, fp, #16
  12a1b8:	e1a01003 	mov	r1, r3
  12a1bc:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  12a1c0:	eb0021c7 	bl	1328e4 <ip4addr_aton>
  12a1c4:	e1a03000 	mov	r3, r0
  12a1c8:	e3530000 	cmp	r3, #0
  12a1cc:	0a000002 	beq	12a1dc <set_if+0x158>
    {
        netif_set_netmask(netif, ip);
  12a1d0:	e51b100c 	ldr	r1, [fp, #-12]
  12a1d4:	e51b0008 	ldr	r0, [fp, #-8]
  12a1d8:	ebffbe56 	bl	119b38 <netif_set_netmask>
    }
}
  12a1dc:	e24bd004 	sub	sp, fp, #4
  12a1e0:	e8bd8800 	pop	{fp, pc}

0012a1e4 <dhcp_inc_pcb_refcount>:
static void dhcp_option_trailer(struct dhcp *dhcp);

/** Ensure DHCP PCB is allocated and bound */
static err_t
dhcp_inc_pcb_refcount(void)
{
  12a1e4:	e92d4800 	push	{fp, lr}
  12a1e8:	e28db004 	add	fp, sp, #4
  if (dhcp_pcb_refcount == 0) {
  12a1ec:	e30f3acc 	movw	r3, #64204	; 0xfacc
  12a1f0:	e3403014 	movt	r3, #20
  12a1f4:	e5d33000 	ldrb	r3, [r3]
  12a1f8:	e3530000 	cmp	r3, #0
  12a1fc:	1a000039 	bne	12a2e8 <dhcp_inc_pcb_refcount+0x104>
    LWIP_ASSERT("dhcp_inc_pcb_refcount(): memory leak", dhcp_pcb == NULL);
  12a200:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a204:	e3403014 	movt	r3, #20
  12a208:	e5933000 	ldr	r3, [r3]
  12a20c:	e3530000 	cmp	r3, #0
  12a210:	0a000006 	beq	12a230 <dhcp_inc_pcb_refcount+0x4c>
  12a214:	e3080f64 	movw	r0, #36708	; 0x8f64
  12a218:	e3400014 	movt	r0, #20
  12a21c:	ebff63bc 	bl	103114 <rt_kprintf>
  12a220:	e3a010db 	mov	r1, #219	; 0xdb
  12a224:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12a228:	e3400014 	movt	r0, #20
  12a22c:	ebff8392 	bl	10b07c <sys_arch_assert>

    /* allocate UDP PCB */
    dhcp_pcb = udp_new();
  12a230:	ebfffaa1 	bl	128cbc <udp_new>
  12a234:	e1a02000 	mov	r2, r0
  12a238:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a23c:	e3403014 	movt	r3, #20
  12a240:	e5832000 	str	r2, [r3]

    if (dhcp_pcb == NULL) {
  12a244:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a248:	e3403014 	movt	r3, #20
  12a24c:	e5933000 	ldr	r3, [r3]
  12a250:	e3530000 	cmp	r3, #0
  12a254:	1a000001 	bne	12a260 <dhcp_inc_pcb_refcount+0x7c>
      return ERR_MEM;
  12a258:	e3e03000 	mvn	r3, #0
  12a25c:	ea00002a 	b	12a30c <dhcp_inc_pcb_refcount+0x128>
    }

    ip_set_option(dhcp_pcb, SOF_BROADCAST);
  12a260:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a264:	e3403014 	movt	r3, #20
  12a268:	e5933000 	ldr	r3, [r3]
  12a26c:	e5d32008 	ldrb	r2, [r3, #8]
  12a270:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a274:	e3403014 	movt	r3, #20
  12a278:	e5933000 	ldr	r3, [r3]
  12a27c:	e3822020 	orr	r2, r2, #32
  12a280:	e6ef2072 	uxtb	r2, r2
  12a284:	e5c32008 	strb	r2, [r3, #8]

    /* set up local and remote port for the pcb -> listen on all interfaces on all src/dest IPs */
    udp_bind(dhcp_pcb, IP4_ADDR_ANY, DHCP_CLIENT_PORT);
  12a288:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a28c:	e3403014 	movt	r3, #20
  12a290:	e5933000 	ldr	r3, [r3]
  12a294:	e3a02044 	mov	r2, #68	; 0x44
  12a298:	e3091b24 	movw	r1, #39716	; 0x9b24
  12a29c:	e3401014 	movt	r1, #20
  12a2a0:	e1a00003 	mov	r0, r3
  12a2a4:	ebfff969 	bl	128850 <udp_bind>
    udp_connect(dhcp_pcb, IP4_ADDR_ANY, DHCP_SERVER_PORT);
  12a2a8:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a2ac:	e3403014 	movt	r3, #20
  12a2b0:	e5933000 	ldr	r3, [r3]
  12a2b4:	e3a02043 	mov	r2, #67	; 0x43
  12a2b8:	e3091b24 	movw	r1, #39716	; 0x9b24
  12a2bc:	e3401014 	movt	r1, #20
  12a2c0:	e1a00003 	mov	r0, r3
  12a2c4:	ebfff9d7 	bl	128a28 <udp_connect>
    udp_recv(dhcp_pcb, dhcp_recv, NULL);
  12a2c8:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a2cc:	e3403014 	movt	r3, #20
  12a2d0:	e5933000 	ldr	r3, [r3]
  12a2d4:	e3a02000 	mov	r2, #0
  12a2d8:	e30c1f4c 	movw	r1, #53068	; 0xcf4c
  12a2dc:	e3401012 	movt	r1, #18
  12a2e0:	e1a00003 	mov	r0, r3
  12a2e4:	ebfffa33 	bl	128bb8 <udp_recv>
  }

  dhcp_pcb_refcount++;
  12a2e8:	e30f3acc 	movw	r3, #64204	; 0xfacc
  12a2ec:	e3403014 	movt	r3, #20
  12a2f0:	e5d33000 	ldrb	r3, [r3]
  12a2f4:	e2833001 	add	r3, r3, #1
  12a2f8:	e6ef2073 	uxtb	r2, r3
  12a2fc:	e30f3acc 	movw	r3, #64204	; 0xfacc
  12a300:	e3403014 	movt	r3, #20
  12a304:	e5c32000 	strb	r2, [r3]

  return ERR_OK;
  12a308:	e3a03000 	mov	r3, #0
}
  12a30c:	e1a00003 	mov	r0, r3
  12a310:	e8bd8800 	pop	{fp, pc}

0012a314 <dhcp_dec_pcb_refcount>:

/** Free DHCP PCB if the last netif stops using it */
static void
dhcp_dec_pcb_refcount(void)
{
  12a314:	e92d4800 	push	{fp, lr}
  12a318:	e28db004 	add	fp, sp, #4
  LWIP_ASSERT("dhcp_pcb_refcount(): refcount error", (dhcp_pcb_refcount > 0));
  12a31c:	e30f3acc 	movw	r3, #64204	; 0xfacc
  12a320:	e3403014 	movt	r3, #20
  12a324:	e5d33000 	ldrb	r3, [r3]
  12a328:	e3530000 	cmp	r3, #0
  12a32c:	1a000006 	bne	12a34c <dhcp_dec_pcb_refcount+0x38>
  12a330:	e3080fc0 	movw	r0, #36800	; 0x8fc0
  12a334:	e3400014 	movt	r0, #20
  12a338:	ebff6375 	bl	103114 <rt_kprintf>
  12a33c:	e3a010f5 	mov	r1, #245	; 0xf5
  12a340:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12a344:	e3400014 	movt	r0, #20
  12a348:	ebff834b 	bl	10b07c <sys_arch_assert>
  dhcp_pcb_refcount--;
  12a34c:	e30f3acc 	movw	r3, #64204	; 0xfacc
  12a350:	e3403014 	movt	r3, #20
  12a354:	e5d33000 	ldrb	r3, [r3]
  12a358:	e2433001 	sub	r3, r3, #1
  12a35c:	e6ef2073 	uxtb	r2, r3
  12a360:	e30f3acc 	movw	r3, #64204	; 0xfacc
  12a364:	e3403014 	movt	r3, #20
  12a368:	e5c32000 	strb	r2, [r3]

  if (dhcp_pcb_refcount == 0) {
  12a36c:	e30f3acc 	movw	r3, #64204	; 0xfacc
  12a370:	e3403014 	movt	r3, #20
  12a374:	e5d33000 	ldrb	r3, [r3]
  12a378:	e3530000 	cmp	r3, #0
  12a37c:	1a000008 	bne	12a3a4 <dhcp_dec_pcb_refcount+0x90>
    udp_remove(dhcp_pcb);
  12a380:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a384:	e3403014 	movt	r3, #20
  12a388:	e5933000 	ldr	r3, [r3]
  12a38c:	e1a00003 	mov	r0, r3
  12a390:	ebfffa18 	bl	128bf8 <udp_remove>
    dhcp_pcb = NULL;
  12a394:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a398:	e3403014 	movt	r3, #20
  12a39c:	e3a02000 	mov	r2, #0
  12a3a0:	e5832000 	str	r2, [r3]
  }
}
  12a3a4:	e320f000 	nop	{0}
  12a3a8:	e8bd8800 	pop	{fp, pc}

0012a3ac <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  12a3ac:	e92d4800 	push	{fp, lr}
  12a3b0:	e28db004 	add	fp, sp, #4
  12a3b4:	e24dd010 	sub	sp, sp, #16
  12a3b8:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12a3bc:	e51b3010 	ldr	r3, [fp, #-16]
  12a3c0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12a3c4:	e50b3008 	str	r3, [fp, #-8]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Change to a defined state - set this before assigning the address
     to ensure the callback can use dhcp_supplied_address() */
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
  12a3c8:	e3a0100c 	mov	r1, #12
  12a3cc:	e51b0008 	ldr	r0, [fp, #-8]
  12a3d0:	eb00076b 	bl	12c184 <dhcp_set_state>
  /* remove IP address from interface (must no longer be used, as per RFC2131) */
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
  12a3d4:	e3093b24 	movw	r3, #39716	; 0x9b24
  12a3d8:	e3403014 	movt	r3, #20
  12a3dc:	e3092b24 	movw	r2, #39716	; 0x9b24
  12a3e0:	e3402014 	movt	r2, #20
  12a3e4:	e3091b24 	movw	r1, #39716	; 0x9b24
  12a3e8:	e3401014 	movt	r1, #20
  12a3ec:	e51b0010 	ldr	r0, [fp, #-16]
  12a3f0:	ebffbcc1 	bl	1196fc <netif_set_addr>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  12a3f4:	e51b0010 	ldr	r0, [fp, #-16]
  12a3f8:	eb000420 	bl	12b480 <dhcp_discover>
}
  12a3fc:	e320f000 	nop	{0}
  12a400:	e24bd004 	sub	sp, fp, #4
  12a404:	e8bd8800 	pop	{fp, pc}

0012a408 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  12a408:	e92d4800 	push	{fp, lr}
  12a40c:	e28db004 	add	fp, sp, #4
  12a410:	e24dd010 	sub	sp, sp, #16
  12a414:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12a418:	e51b3010 	ldr	r3, [fp, #-16]
  12a41c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12a420:	e50b3008 	str	r3, [fp, #-8]
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_STATE_CHECKING);
  12a424:	e3a01008 	mov	r1, #8
  12a428:	e51b0008 	ldr	r0, [fp, #-8]
  12a42c:	eb000754 	bl	12c184 <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  12a430:	e51b3008 	ldr	r3, [fp, #-8]
  12a434:	e2833028 	add	r3, r3, #40	; 0x28
  12a438:	e3a02000 	mov	r2, #0
  12a43c:	e1a01003 	mov	r1, r3
  12a440:	e51b0010 	ldr	r0, [fp, #-16]
  12a444:	eb0012a0 	bl	12eecc <etharp_query>
  12a448:	e1a03000 	mov	r3, r0
  12a44c:	e54b3009 	strb	r3, [fp, #-9]
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  if (dhcp->tries < 255) {
  12a450:	e51b3008 	ldr	r3, [fp, #-8]
  12a454:	e5d3300a 	ldrb	r3, [r3, #10]
  12a458:	e35300ff 	cmp	r3, #255	; 0xff
  12a45c:	0a000005 	beq	12a478 <dhcp_check+0x70>
    dhcp->tries++;
  12a460:	e51b3008 	ldr	r3, [fp, #-8]
  12a464:	e5d3300a 	ldrb	r3, [r3, #10]
  12a468:	e2833001 	add	r3, r3, #1
  12a46c:	e6ef2073 	uxtb	r2, r3
  12a470:	e51b3008 	ldr	r3, [fp, #-8]
  12a474:	e5c3200a 	strb	r2, [r3, #10]
  }
  msecs = 500;
  12a478:	e3a03f7d 	mov	r3, #500	; 0x1f4
  12a47c:	e14b30bc 	strh	r3, [fp, #-12]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  12a480:	e15b30bc 	ldrh	r3, [fp, #-12]
  12a484:	e2833e1f 	add	r3, r3, #496	; 0x1f0
  12a488:	e2833003 	add	r3, r3, #3
  12a48c:	e3042dd3 	movw	r2, #19923	; 0x4dd3
  12a490:	e3412062 	movt	r2, #4194	; 0x1062
  12a494:	e0c10293 	smull	r0, r1, r3, r2
  12a498:	e1a022c1 	asr	r2, r1, #5
  12a49c:	e1a03fc3 	asr	r3, r3, #31
  12a4a0:	e0423003 	sub	r3, r2, r3
  12a4a4:	e6ff2073 	uxth	r2, r3
  12a4a8:	e51b3008 	ldr	r3, [fp, #-8]
  12a4ac:	e1c321b6 	strh	r2, [r3, #22]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
  12a4b0:	e320f000 	nop	{0}
  12a4b4:	e24bd004 	sub	sp, fp, #4
  12a4b8:	e8bd8800 	pop	{fp, pc}

0012a4bc <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  12a4bc:	e92d4800 	push	{fp, lr}
  12a4c0:	e28db004 	add	fp, sp, #4
  12a4c4:	e24dd010 	sub	sp, sp, #16
  12a4c8:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12a4cc:	e51b3010 	ldr	r3, [fp, #-16]
  12a4d0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12a4d4:	e50b3008 	str	r3, [fp, #-8]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
  12a4d8:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12a4dc:	e3403057 	movt	r3, #87	; 0x57
  12a4e0:	e5d33002 	ldrb	r3, [r3, #2]
  12a4e4:	e3530000 	cmp	r3, #0
  12a4e8:	0a00000e 	beq	12a528 <dhcp_handle_offer+0x6c>
    ip_addr_set_ip4_u32(&dhcp->server_ip_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
  12a4ec:	e3063a58 	movw	r3, #27224	; 0x6a58
  12a4f0:	e3403057 	movt	r3, #87	; 0x57
  12a4f4:	e5933008 	ldr	r3, [r3, #8]
  12a4f8:	e1a00003 	mov	r0, r3
  12a4fc:	ebffb0c1 	bl	116808 <lwip_htonl>
  12a500:	e1a02000 	mov	r2, r0
  12a504:	e51b3008 	ldr	r3, [fp, #-8]
  12a508:	e5832024 	str	r2, [r3, #36]	; 0x24
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
    /* remember offered address */
    ip4_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
  12a50c:	e51b3008 	ldr	r3, [fp, #-8]
  12a510:	e5933004 	ldr	r3, [r3, #4]
  12a514:	e5932010 	ldr	r2, [r3, #16]
  12a518:	e51b3008 	ldr	r3, [fp, #-8]
  12a51c:	e5832028 	str	r2, [r3, #40]	; 0x28
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
  12a520:	e51b0010 	ldr	r0, [fp, #-16]
  12a524:	eb000002 	bl	12a534 <dhcp_select>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void*)netif));
  }
}
  12a528:	e320f000 	nop	{0}
  12a52c:	e24bd004 	sub	sp, fp, #4
  12a530:	e8bd8800 	pop	{fp, pc}

0012a534 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  12a534:	e92d4800 	push	{fp, lr}
  12a538:	e28db004 	add	fp, sp, #4
  12a53c:	e24dd020 	sub	sp, sp, #32
  12a540:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12a544:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12a548:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12a54c:	e50b300c 	str	r3, [fp, #-12]
  err_t result;
  u16_t msecs;
  u8_t i;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_STATE_REQUESTING);
  12a550:	e3a01001 	mov	r1, #1
  12a554:	e51b000c 	ldr	r0, [fp, #-12]
  12a558:	eb000709 	bl	12c184 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  12a55c:	e3a02003 	mov	r2, #3
  12a560:	e51b100c 	ldr	r1, [fp, #-12]
  12a564:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12a568:	eb000b35 	bl	12d244 <dhcp_create_msg>
  12a56c:	e1a03000 	mov	r3, r0
  12a570:	e54b300d 	strb	r3, [fp, #-13]
  if (result == ERR_OK) {
  12a574:	e15b30dd 	ldrsb	r3, [fp, #-13]
  12a578:	e3530000 	cmp	r3, #0
  12a57c:	1a000052 	bne	12a6cc <dhcp_select+0x198>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  12a580:	e3a02002 	mov	r2, #2
  12a584:	e3a01039 	mov	r1, #57	; 0x39
  12a588:	e51b000c 	ldr	r0, [fp, #-12]
  12a58c:	eb000714 	bl	12c1e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
  12a590:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12a594:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  12a598:	e1a01003 	mov	r1, r3
  12a59c:	e51b000c 	ldr	r0, [fp, #-12]
  12a5a0:	eb00075e 	bl	12c320 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  12a5a4:	e3a02004 	mov	r2, #4
  12a5a8:	e3a01032 	mov	r1, #50	; 0x32
  12a5ac:	e51b000c 	ldr	r0, [fp, #-12]
  12a5b0:	eb00070b 	bl	12c1e4 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  12a5b4:	e51b300c 	ldr	r3, [fp, #-12]
  12a5b8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12a5bc:	e1a00003 	mov	r0, r3
  12a5c0:	ebffb090 	bl	116808 <lwip_htonl>
  12a5c4:	e1a03000 	mov	r3, r0
  12a5c8:	e1a01003 	mov	r1, r3
  12a5cc:	e51b000c 	ldr	r0, [fp, #-12]
  12a5d0:	eb000783 	bl	12c3e4 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  12a5d4:	e3a02004 	mov	r2, #4
  12a5d8:	e3a01036 	mov	r1, #54	; 0x36
  12a5dc:	e51b000c 	ldr	r0, [fp, #-12]
  12a5e0:	eb0006ff 	bl	12c1e4 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
  12a5e4:	e51b300c 	ldr	r3, [fp, #-12]
  12a5e8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  12a5ec:	e1a00003 	mov	r0, r3
  12a5f0:	ebffb084 	bl	116808 <lwip_htonl>
  12a5f4:	e1a03000 	mov	r3, r0
  12a5f8:	e1a01003 	mov	r1, r3
  12a5fc:	e51b000c 	ldr	r0, [fp, #-12]
  12a600:	eb000777 	bl	12c3e4 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
  12a604:	e3a02004 	mov	r2, #4
  12a608:	e3a01037 	mov	r1, #55	; 0x37
  12a60c:	e51b000c 	ldr	r0, [fp, #-12]
  12a610:	eb0006f3 	bl	12c1e4 <dhcp_option>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12a614:	e3a03000 	mov	r3, #0
  12a618:	e54b3005 	strb	r3, [fp, #-5]
  12a61c:	ea000009 	b	12a648 <dhcp_select+0x114>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
  12a620:	e55b2005 	ldrb	r2, [fp, #-5]
  12a624:	e30e303c 	movw	r3, #57404	; 0xe03c
  12a628:	e3403014 	movt	r3, #20
  12a62c:	e7d33002 	ldrb	r3, [r3, r2]
  12a630:	e1a01003 	mov	r1, r3
  12a634:	e51b000c 	ldr	r0, [fp, #-12]
  12a638:	eb000719 	bl	12c2a4 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12a63c:	e55b3005 	ldrb	r3, [fp, #-5]
  12a640:	e2833001 	add	r3, r3, #1
  12a644:	e54b3005 	strb	r3, [fp, #-5]
  12a648:	e55b3005 	ldrb	r3, [fp, #-5]
  12a64c:	e3530003 	cmp	r3, #3
  12a650:	9afffff2 	bls	12a620 <dhcp_select+0xec>
    }

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
  12a654:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  12a658:	e51b000c 	ldr	r0, [fp, #-12]
  12a65c:	eb0007ab 	bl	12c510 <dhcp_option_hostname>
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  12a660:	e51b000c 	ldr	r0, [fp, #-12]
  12a664:	eb000c63 	bl	12d7f8 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  12a668:	e51b300c 	ldr	r3, [fp, #-12]
  12a66c:	e593200c 	ldr	r2, [r3, #12]
  12a670:	e51b300c 	ldr	r3, [fp, #-12]
  12a674:	e1d331b4 	ldrh	r3, [r3, #20]
  12a678:	e28330f0 	add	r3, r3, #240	; 0xf0
  12a67c:	e6ff3073 	uxth	r3, r3
  12a680:	e1a01003 	mov	r1, r3
  12a684:	e1a00002 	mov	r0, r2
  12a688:	ebffc140 	bl	11ab90 <pbuf_realloc>

    /* send broadcast to any DHCP server */
    udp_sendto_if_src(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif, IP4_ADDR_ANY);
  12a68c:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12a690:	e3403014 	movt	r3, #20
  12a694:	e5930000 	ldr	r0, [r3]
  12a698:	e51b300c 	ldr	r3, [fp, #-12]
  12a69c:	e593100c 	ldr	r1, [r3, #12]
  12a6a0:	e3093b24 	movw	r3, #39716	; 0x9b24
  12a6a4:	e3403014 	movt	r3, #20
  12a6a8:	e58d3004 	str	r3, [sp, #4]
  12a6ac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12a6b0:	e58d3000 	str	r3, [sp]
  12a6b4:	e3a03043 	mov	r3, #67	; 0x43
  12a6b8:	e3092b28 	movw	r2, #39720	; 0x9b28
  12a6bc:	e3402014 	movt	r2, #20
  12a6c0:	ebfff791 	bl	12850c <udp_sendto_if_src>
    dhcp_delete_msg(dhcp);
  12a6c4:	e51b000c 	ldr	r0, [fp, #-12]
  12a6c8:	eb000c15 	bl	12d724 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  if (dhcp->tries < 255) {
  12a6cc:	e51b300c 	ldr	r3, [fp, #-12]
  12a6d0:	e5d3300a 	ldrb	r3, [r3, #10]
  12a6d4:	e35300ff 	cmp	r3, #255	; 0xff
  12a6d8:	0a000005 	beq	12a6f4 <dhcp_select+0x1c0>
    dhcp->tries++;
  12a6dc:	e51b300c 	ldr	r3, [fp, #-12]
  12a6e0:	e5d3300a 	ldrb	r3, [r3, #10]
  12a6e4:	e2833001 	add	r3, r3, #1
  12a6e8:	e6ef2073 	uxtb	r2, r3
  12a6ec:	e51b300c 	ldr	r3, [fp, #-12]
  12a6f0:	e5c3200a 	strb	r2, [r3, #10]
  }
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  12a6f4:	e51b300c 	ldr	r3, [fp, #-12]
  12a6f8:	e5d3300a 	ldrb	r3, [r3, #10]
  12a6fc:	e3530005 	cmp	r3, #5
  12a700:	8a000006 	bhi	12a720 <dhcp_select+0x1ec>
  12a704:	e51b300c 	ldr	r3, [fp, #-12]
  12a708:	e5d3300a 	ldrb	r3, [r3, #10]
  12a70c:	e1a02003 	mov	r2, r3
  12a710:	e3a03ffa 	mov	r3, #1000	; 0x3e8
  12a714:	e1a03213 	lsl	r3, r3, r2
  12a718:	e6ff3073 	uxth	r3, r3
  12a71c:	ea000000 	b	12a724 <dhcp_select+0x1f0>
  12a720:	e30e3a60 	movw	r3, #60000	; 0xea60
  12a724:	e14b31b0 	strh	r3, [fp, #-16]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  12a728:	e15b31b0 	ldrh	r3, [fp, #-16]
  12a72c:	e2833e1f 	add	r3, r3, #496	; 0x1f0
  12a730:	e2833003 	add	r3, r3, #3
  12a734:	e3042dd3 	movw	r2, #19923	; 0x4dd3
  12a738:	e3412062 	movt	r2, #4194	; 0x1062
  12a73c:	e0c10293 	smull	r0, r1, r3, r2
  12a740:	e1a022c1 	asr	r2, r1, #5
  12a744:	e1a03fc3 	asr	r3, r3, #31
  12a748:	e0423003 	sub	r3, r2, r3
  12a74c:	e6ff2073 	uxth	r2, r3
  12a750:	e51b300c 	ldr	r3, [fp, #-12]
  12a754:	e1c321b6 	strh	r2, [r3, #22]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  12a758:	e15b30dd 	ldrsb	r3, [fp, #-13]
}
  12a75c:	e1a00003 	mov	r0, r3
  12a760:	e24bd004 	sub	sp, fp, #4
  12a764:	e8bd8800 	pop	{fp, pc}

0012a768 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 * Must be called once a minute (see @ref DHCP_COARSE_TIMER_SECS).
 */
void
dhcp_coarse_tmr(void)
{
  12a768:	e92d4800 	push	{fp, lr}
  12a76c:	e28db004 	add	fp, sp, #4
  12a770:	e24dd008 	sub	sp, sp, #8
  struct netif *netif = netif_list;
  12a774:	e3063834 	movw	r3, #26676	; 0x6834
  12a778:	e3403057 	movt	r3, #87	; 0x57
  12a77c:	e5933000 	ldr	r3, [r3]
  12a780:	e50b3008 	str	r3, [fp, #-8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  12a784:	ea00003e 	b	12a884 <dhcp_coarse_tmr+0x11c>
    /* only act on DHCP configured interfaces */
    struct dhcp *dhcp = netif_dhcp_data(netif);
  12a788:	e51b3008 	ldr	r3, [fp, #-8]
  12a78c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12a790:	e50b300c 	str	r3, [fp, #-12]
    if ((dhcp != NULL) && (dhcp->state != DHCP_STATE_OFF)) {
  12a794:	e51b300c 	ldr	r3, [fp, #-12]
  12a798:	e3530000 	cmp	r3, #0
  12a79c:	0a000035 	beq	12a878 <dhcp_coarse_tmr+0x110>
  12a7a0:	e51b300c 	ldr	r3, [fp, #-12]
  12a7a4:	e5d33009 	ldrb	r3, [r3, #9]
  12a7a8:	e3530000 	cmp	r3, #0
  12a7ac:	0a000031 	beq	12a878 <dhcp_coarse_tmr+0x110>
      /* compare lease time to expire timeout */
      if (dhcp->t0_timeout && (++dhcp->lease_used == dhcp->t0_timeout)) {
  12a7b0:	e51b300c 	ldr	r3, [fp, #-12]
  12a7b4:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
  12a7b8:	e3530000 	cmp	r3, #0
  12a7bc:	0a000010 	beq	12a804 <dhcp_coarse_tmr+0x9c>
  12a7c0:	e51b300c 	ldr	r3, [fp, #-12]
  12a7c4:	e1d332b0 	ldrh	r3, [r3, #32]
  12a7c8:	e2833001 	add	r3, r3, #1
  12a7cc:	e6ff2073 	uxth	r2, r3
  12a7d0:	e51b300c 	ldr	r3, [fp, #-12]
  12a7d4:	e1c322b0 	strh	r2, [r3, #32]
  12a7d8:	e51b300c 	ldr	r3, [fp, #-12]
  12a7dc:	e1d322b0 	ldrh	r2, [r3, #32]
  12a7e0:	e51b300c 	ldr	r3, [fp, #-12]
  12a7e4:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
  12a7e8:	e1520003 	cmp	r2, r3
  12a7ec:	1a000004 	bne	12a804 <dhcp_coarse_tmr+0x9c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t0 timeout\n"));
        /* this clients' lease time has expired */
        dhcp_release(netif);
  12a7f0:	e51b0008 	ldr	r0, [fp, #-8]
  12a7f4:	eb0005bd 	bl	12bef0 <dhcp_release>
        dhcp_discover(netif);
  12a7f8:	e51b0008 	ldr	r0, [fp, #-8]
  12a7fc:	eb00031f 	bl	12b480 <dhcp_discover>
  12a800:	ea00001c 	b	12a878 <dhcp_coarse_tmr+0x110>
      /* timer is active (non zero), and triggers (zeroes) now? */
      } else if (dhcp->t2_rebind_time && (dhcp->t2_rebind_time-- == 1)) {
  12a804:	e51b300c 	ldr	r3, [fp, #-12]
  12a808:	e1d331be 	ldrh	r3, [r3, #30]
  12a80c:	e3530000 	cmp	r3, #0
  12a810:	0a00000a 	beq	12a840 <dhcp_coarse_tmr+0xd8>
  12a814:	e51b300c 	ldr	r3, [fp, #-12]
  12a818:	e1d331be 	ldrh	r3, [r3, #30]
  12a81c:	e2432001 	sub	r2, r3, #1
  12a820:	e6ff1072 	uxth	r1, r2
  12a824:	e51b200c 	ldr	r2, [fp, #-12]
  12a828:	e1c211be 	strh	r1, [r2, #30]
  12a82c:	e3530001 	cmp	r3, #1
  12a830:	1a000002 	bne	12a840 <dhcp_coarse_tmr+0xd8>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
  12a834:	e51b0008 	ldr	r0, [fp, #-8]
  12a838:	eb0000b1 	bl	12ab04 <dhcp_t2_timeout>
  12a83c:	ea00000d 	b	12a878 <dhcp_coarse_tmr+0x110>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (dhcp->t1_renew_time && (dhcp->t1_renew_time-- == 1)) {
  12a840:	e51b300c 	ldr	r3, [fp, #-12]
  12a844:	e1d331bc 	ldrh	r3, [r3, #28]
  12a848:	e3530000 	cmp	r3, #0
  12a84c:	0a000009 	beq	12a878 <dhcp_coarse_tmr+0x110>
  12a850:	e51b300c 	ldr	r3, [fp, #-12]
  12a854:	e1d331bc 	ldrh	r3, [r3, #28]
  12a858:	e2432001 	sub	r2, r3, #1
  12a85c:	e6ff1072 	uxth	r1, r2
  12a860:	e51b200c 	ldr	r2, [fp, #-12]
  12a864:	e1c211bc 	strh	r1, [r2, #28]
  12a868:	e3530001 	cmp	r3, #1
  12a86c:	1a000001 	bne	12a878 <dhcp_coarse_tmr+0x110>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
  12a870:	e51b0008 	ldr	r0, [fp, #-8]
  12a874:	eb000076 	bl	12aa54 <dhcp_t1_timeout>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  12a878:	e51b3008 	ldr	r3, [fp, #-8]
  12a87c:	e5933000 	ldr	r3, [r3]
  12a880:	e50b3008 	str	r3, [fp, #-8]
  while (netif != NULL) {
  12a884:	e51b3008 	ldr	r3, [fp, #-8]
  12a888:	e3530000 	cmp	r3, #0
  12a88c:	1affffbd 	bne	12a788 <dhcp_coarse_tmr+0x20>
  }
}
  12a890:	e320f000 	nop	{0}
  12a894:	e24bd004 	sub	sp, fp, #4
  12a898:	e8bd8800 	pop	{fp, pc}

0012a89c <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr(void)
{
  12a89c:	e92d4800 	push	{fp, lr}
  12a8a0:	e28db004 	add	fp, sp, #4
  12a8a4:	e24dd008 	sub	sp, sp, #8
  struct netif *netif = netif_list;
  12a8a8:	e3063834 	movw	r3, #26676	; 0x6834
  12a8ac:	e3403057 	movt	r3, #87	; 0x57
  12a8b0:	e5933000 	ldr	r3, [r3]
  12a8b4:	e50b3008 	str	r3, [fp, #-8]
  /* loop through netif's */
  while (netif != NULL) {
  12a8b8:	ea00001f 	b	12a93c <dhcp_fine_tmr+0xa0>
    struct dhcp *dhcp = netif_dhcp_data(netif);
  12a8bc:	e51b3008 	ldr	r3, [fp, #-8]
  12a8c0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12a8c4:	e50b300c 	str	r3, [fp, #-12]
    /* only act on DHCP configured interfaces */
    if (dhcp != NULL) {
  12a8c8:	e51b300c 	ldr	r3, [fp, #-12]
  12a8cc:	e3530000 	cmp	r3, #0
  12a8d0:	0a000016 	beq	12a930 <dhcp_fine_tmr+0x94>
      /* timer is active (non zero), and is about to trigger now */
      if (dhcp->request_timeout > 1) {
  12a8d4:	e51b300c 	ldr	r3, [fp, #-12]
  12a8d8:	e1d331b6 	ldrh	r3, [r3, #22]
  12a8dc:	e3530001 	cmp	r3, #1
  12a8e0:	9a000006 	bls	12a900 <dhcp_fine_tmr+0x64>
        dhcp->request_timeout--;
  12a8e4:	e51b300c 	ldr	r3, [fp, #-12]
  12a8e8:	e1d331b6 	ldrh	r3, [r3, #22]
  12a8ec:	e2433001 	sub	r3, r3, #1
  12a8f0:	e6ff2073 	uxth	r2, r3
  12a8f4:	e51b300c 	ldr	r3, [fp, #-12]
  12a8f8:	e1c321b6 	strh	r2, [r3, #22]
  12a8fc:	ea00000b 	b	12a930 <dhcp_fine_tmr+0x94>
      }
      else if (dhcp->request_timeout == 1) {
  12a900:	e51b300c 	ldr	r3, [fp, #-12]
  12a904:	e1d331b6 	ldrh	r3, [r3, #22]
  12a908:	e3530001 	cmp	r3, #1
  12a90c:	1a000007 	bne	12a930 <dhcp_fine_tmr+0x94>
        dhcp->request_timeout--;
  12a910:	e51b300c 	ldr	r3, [fp, #-12]
  12a914:	e1d331b6 	ldrh	r3, [r3, #22]
  12a918:	e2433001 	sub	r3, r3, #1
  12a91c:	e6ff2073 	uxth	r2, r3
  12a920:	e51b300c 	ldr	r3, [fp, #-12]
  12a924:	e1c321b6 	strh	r2, [r3, #22]
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
  12a928:	e51b0008 	ldr	r0, [fp, #-8]
  12a92c:	eb000008 	bl	12a954 <dhcp_timeout>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  12a930:	e51b3008 	ldr	r3, [fp, #-8]
  12a934:	e5933000 	ldr	r3, [r3]
  12a938:	e50b3008 	str	r3, [fp, #-8]
  while (netif != NULL) {
  12a93c:	e51b3008 	ldr	r3, [fp, #-8]
  12a940:	e3530000 	cmp	r3, #0
  12a944:	1affffdc 	bne	12a8bc <dhcp_fine_tmr+0x20>
  }
}
  12a948:	e320f000 	nop	{0}
  12a94c:	e24bd004 	sub	sp, fp, #4
  12a950:	e8bd8800 	pop	{fp, pc}

0012a954 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  12a954:	e92d4800 	push	{fp, lr}
  12a958:	e28db004 	add	fp, sp, #4
  12a95c:	e24dd010 	sub	sp, sp, #16
  12a960:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12a964:	e51b3010 	ldr	r3, [fp, #-16]
  12a968:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12a96c:	e50b3008 	str	r3, [fp, #-8]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
  12a970:	e51b3008 	ldr	r3, [fp, #-8]
  12a974:	e5d33009 	ldrb	r3, [r3, #9]
  12a978:	e353000c 	cmp	r3, #12
  12a97c:	0a000003 	beq	12a990 <dhcp_timeout+0x3c>
  12a980:	e51b3008 	ldr	r3, [fp, #-8]
  12a984:	e5d33009 	ldrb	r3, [r3, #9]
  12a988:	e3530006 	cmp	r3, #6
  12a98c:	1a000002 	bne	12a99c <dhcp_timeout+0x48>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  12a990:	e51b0010 	ldr	r0, [fp, #-16]
  12a994:	eb0002b9 	bl	12b480 <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
  12a998:	ea00002a 	b	12aa48 <dhcp_timeout+0xf4>
  } else if (dhcp->state == DHCP_STATE_REQUESTING) {
  12a99c:	e51b3008 	ldr	r3, [fp, #-8]
  12a9a0:	e5d33009 	ldrb	r3, [r3, #9]
  12a9a4:	e3530001 	cmp	r3, #1
  12a9a8:	1a00000b 	bne	12a9dc <dhcp_timeout+0x88>
    if (dhcp->tries <= 5) {
  12a9ac:	e51b3008 	ldr	r3, [fp, #-8]
  12a9b0:	e5d3300a 	ldrb	r3, [r3, #10]
  12a9b4:	e3530005 	cmp	r3, #5
  12a9b8:	8a000002 	bhi	12a9c8 <dhcp_timeout+0x74>
      dhcp_select(netif);
  12a9bc:	e51b0010 	ldr	r0, [fp, #-16]
  12a9c0:	ebfffedb 	bl	12a534 <dhcp_select>
}
  12a9c4:	ea00001f 	b	12aa48 <dhcp_timeout+0xf4>
      dhcp_release(netif);
  12a9c8:	e51b0010 	ldr	r0, [fp, #-16]
  12a9cc:	eb000547 	bl	12bef0 <dhcp_release>
      dhcp_discover(netif);
  12a9d0:	e51b0010 	ldr	r0, [fp, #-16]
  12a9d4:	eb0002a9 	bl	12b480 <dhcp_discover>
}
  12a9d8:	ea00001a 	b	12aa48 <dhcp_timeout+0xf4>
  } else if (dhcp->state == DHCP_STATE_CHECKING) {
  12a9dc:	e51b3008 	ldr	r3, [fp, #-8]
  12a9e0:	e5d33009 	ldrb	r3, [r3, #9]
  12a9e4:	e3530008 	cmp	r3, #8
  12a9e8:	1a000009 	bne	12aa14 <dhcp_timeout+0xc0>
    if (dhcp->tries <= 1) {
  12a9ec:	e51b3008 	ldr	r3, [fp, #-8]
  12a9f0:	e5d3300a 	ldrb	r3, [r3, #10]
  12a9f4:	e3530001 	cmp	r3, #1
  12a9f8:	8a000002 	bhi	12aa08 <dhcp_timeout+0xb4>
      dhcp_check(netif);
  12a9fc:	e51b0010 	ldr	r0, [fp, #-16]
  12aa00:	ebfffe80 	bl	12a408 <dhcp_check>
}
  12aa04:	ea00000f 	b	12aa48 <dhcp_timeout+0xf4>
      dhcp_bind(netif);
  12aa08:	e51b0010 	ldr	r0, [fp, #-16]
  12aa0c:	eb000312 	bl	12b65c <dhcp_bind>
}
  12aa10:	ea00000c 	b	12aa48 <dhcp_timeout+0xf4>
  } else if (dhcp->state == DHCP_STATE_REBOOTING) {
  12aa14:	e51b3008 	ldr	r3, [fp, #-8]
  12aa18:	e5d33009 	ldrb	r3, [r3, #9]
  12aa1c:	e3530003 	cmp	r3, #3
  12aa20:	1a000008 	bne	12aa48 <dhcp_timeout+0xf4>
    if (dhcp->tries < REBOOT_TRIES) {
  12aa24:	e51b3008 	ldr	r3, [fp, #-8]
  12aa28:	e5d3300a 	ldrb	r3, [r3, #10]
  12aa2c:	e3530001 	cmp	r3, #1
  12aa30:	8a000002 	bhi	12aa40 <dhcp_timeout+0xec>
      dhcp_reboot(netif);
  12aa34:	e51b0010 	ldr	r0, [fp, #-16]
  12aa38:	eb0004af 	bl	12bcfc <dhcp_reboot>
}
  12aa3c:	ea000001 	b	12aa48 <dhcp_timeout+0xf4>
      dhcp_discover(netif);
  12aa40:	e51b0010 	ldr	r0, [fp, #-16]
  12aa44:	eb00028d 	bl	12b480 <dhcp_discover>
}
  12aa48:	e320f000 	nop	{0}
  12aa4c:	e24bd004 	sub	sp, fp, #4
  12aa50:	e8bd8800 	pop	{fp, pc}

0012aa54 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  12aa54:	e92d4800 	push	{fp, lr}
  12aa58:	e28db004 	add	fp, sp, #4
  12aa5c:	e24dd010 	sub	sp, sp, #16
  12aa60:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12aa64:	e51b3010 	ldr	r3, [fp, #-16]
  12aa68:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12aa6c:	e50b3008 	str	r3, [fp, #-8]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
  12aa70:	e51b3008 	ldr	r3, [fp, #-8]
  12aa74:	e5d33009 	ldrb	r3, [r3, #9]
  12aa78:	e3530001 	cmp	r3, #1
  12aa7c:	0a000007 	beq	12aaa0 <dhcp_t1_timeout+0x4c>
  12aa80:	e51b3008 	ldr	r3, [fp, #-8]
  12aa84:	e5d33009 	ldrb	r3, [r3, #9]
  12aa88:	e353000a 	cmp	r3, #10
  12aa8c:	0a000003 	beq	12aaa0 <dhcp_t1_timeout+0x4c>
      (dhcp->state == DHCP_STATE_RENEWING)) {
  12aa90:	e51b3008 	ldr	r3, [fp, #-8]
  12aa94:	e5d33009 	ldrb	r3, [r3, #9]
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
  12aa98:	e3530005 	cmp	r3, #5
  12aa9c:	1a000015 	bne	12aaf8 <dhcp_t1_timeout+0xa4>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_STATE_RENEWING, not DHCP_STATE_BOUND */
    dhcp_renew(netif);
  12aaa0:	e51b0010 	ldr	r0, [fp, #-16]
  12aaa4:	eb0003a8 	bl	12b94c <dhcp_renew>
    /* Calculate next timeout */
    if (((dhcp->t2_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS))
  12aaa8:	e51b3008 	ldr	r3, [fp, #-8]
  12aaac:	e1d331ba 	ldrh	r3, [r3, #26]
  12aab0:	e1a02003 	mov	r2, r3
  12aab4:	e51b3008 	ldr	r3, [fp, #-8]
  12aab8:	e1d332b0 	ldrh	r3, [r3, #32]
  12aabc:	e0423003 	sub	r3, r2, r3
  12aac0:	e3530001 	cmp	r3, #1
  12aac4:	da00000b 	ble	12aaf8 <dhcp_t1_timeout+0xa4>
    {
       dhcp->t1_renew_time = ((dhcp->t2_timeout - dhcp->lease_used) / 2);
  12aac8:	e51b3008 	ldr	r3, [fp, #-8]
  12aacc:	e1d331ba 	ldrh	r3, [r3, #26]
  12aad0:	e1a02003 	mov	r2, r3
  12aad4:	e51b3008 	ldr	r3, [fp, #-8]
  12aad8:	e1d332b0 	ldrh	r3, [r3, #32]
  12aadc:	e0423003 	sub	r3, r2, r3
  12aae0:	e1a02fa3 	lsr	r2, r3, #31
  12aae4:	e0823003 	add	r3, r2, r3
  12aae8:	e1a030c3 	asr	r3, r3, #1
  12aaec:	e6ff2073 	uxth	r2, r3
  12aaf0:	e51b3008 	ldr	r3, [fp, #-8]
  12aaf4:	e1c321bc 	strh	r2, [r3, #28]
    }
  }
}
  12aaf8:	e320f000 	nop	{0}
  12aafc:	e24bd004 	sub	sp, fp, #4
  12ab00:	e8bd8800 	pop	{fp, pc}

0012ab04 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  12ab04:	e92d4800 	push	{fp, lr}
  12ab08:	e28db004 	add	fp, sp, #4
  12ab0c:	e24dd010 	sub	sp, sp, #16
  12ab10:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12ab14:	e51b3010 	ldr	r3, [fp, #-16]
  12ab18:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12ab1c:	e50b3008 	str	r3, [fp, #-8]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
  12ab20:	e51b3008 	ldr	r3, [fp, #-8]
  12ab24:	e5d33009 	ldrb	r3, [r3, #9]
  12ab28:	e3530001 	cmp	r3, #1
  12ab2c:	0a00000b 	beq	12ab60 <dhcp_t2_timeout+0x5c>
  12ab30:	e51b3008 	ldr	r3, [fp, #-8]
  12ab34:	e5d33009 	ldrb	r3, [r3, #9]
  12ab38:	e353000a 	cmp	r3, #10
  12ab3c:	0a000007 	beq	12ab60 <dhcp_t2_timeout+0x5c>
      (dhcp->state == DHCP_STATE_RENEWING) || (dhcp->state == DHCP_STATE_REBINDING)) {
  12ab40:	e51b3008 	ldr	r3, [fp, #-8]
  12ab44:	e5d33009 	ldrb	r3, [r3, #9]
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
  12ab48:	e3530005 	cmp	r3, #5
  12ab4c:	0a000003 	beq	12ab60 <dhcp_t2_timeout+0x5c>
      (dhcp->state == DHCP_STATE_RENEWING) || (dhcp->state == DHCP_STATE_REBINDING)) {
  12ab50:	e51b3008 	ldr	r3, [fp, #-8]
  12ab54:	e5d33009 	ldrb	r3, [r3, #9]
  12ab58:	e3530004 	cmp	r3, #4
  12ab5c:	1a000015 	bne	12abb8 <dhcp_t2_timeout+0xb4>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_STATE_REBINDING, not DHCP_STATE_BOUND */
    dhcp_rebind(netif);
  12ab60:	e51b0010 	ldr	r0, [fp, #-16]
  12ab64:	eb0003ee 	bl	12bb24 <dhcp_rebind>
    /* Calculate next timeout */
    if (((dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS))
  12ab68:	e51b3008 	ldr	r3, [fp, #-8]
  12ab6c:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
  12ab70:	e1a02003 	mov	r2, r3
  12ab74:	e51b3008 	ldr	r3, [fp, #-8]
  12ab78:	e1d332b0 	ldrh	r3, [r3, #32]
  12ab7c:	e0423003 	sub	r3, r2, r3
  12ab80:	e3530001 	cmp	r3, #1
  12ab84:	da00000b 	ble	12abb8 <dhcp_t2_timeout+0xb4>
    {
       dhcp->t2_rebind_time = ((dhcp->t0_timeout - dhcp->lease_used) / 2);
  12ab88:	e51b3008 	ldr	r3, [fp, #-8]
  12ab8c:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
  12ab90:	e1a02003 	mov	r2, r3
  12ab94:	e51b3008 	ldr	r3, [fp, #-8]
  12ab98:	e1d332b0 	ldrh	r3, [r3, #32]
  12ab9c:	e0423003 	sub	r3, r2, r3
  12aba0:	e1a02fa3 	lsr	r2, r3, #31
  12aba4:	e0823003 	add	r3, r2, r3
  12aba8:	e1a030c3 	asr	r3, r3, #1
  12abac:	e6ff2073 	uxth	r2, r3
  12abb0:	e51b3008 	ldr	r3, [fp, #-8]
  12abb4:	e1c321be 	strh	r2, [r3, #30]
    }
  }
}
  12abb8:	e320f000 	nop	{0}
  12abbc:	e24bd004 	sub	sp, fp, #4
  12abc0:	e8bd8800 	pop	{fp, pc}

0012abc4 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  12abc4:	e92d4800 	push	{fp, lr}
  12abc8:	e28db004 	add	fp, sp, #4
  12abcc:	e24dd018 	sub	sp, sp, #24
  12abd0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12abd4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12abd8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12abdc:	e50b300c 	str	r3, [fp, #-12]
#if LWIP_DHCP_GET_NTP_SRV
  ip4_addr_t ntp_server_addrs[LWIP_DHCP_MAX_NTP_SERVERS];
#endif

  /* clear options we might not get from the ACK */
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
  12abe0:	e51b300c 	ldr	r3, [fp, #-12]
  12abe4:	e3a02000 	mov	r2, #0
  12abe8:	e583202c 	str	r2, [r3, #44]	; 0x2c
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
  12abec:	e51b300c 	ldr	r3, [fp, #-12]
  12abf0:	e3a02000 	mov	r2, #0
  12abf4:	e5832030 	str	r2, [r3, #48]	; 0x30
#if LWIP_DHCP_BOOTP_FILE
  ip4_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
  12abf8:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12abfc:	e3403057 	movt	r3, #87	; 0x57
  12ac00:	e5d33003 	ldrb	r3, [r3, #3]
  12ac04:	e3530000 	cmp	r3, #0
  12ac08:	0a000004 	beq	12ac20 <dhcp_handle_ack+0x5c>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
  12ac0c:	e3063a58 	movw	r3, #27224	; 0x6a58
  12ac10:	e3403057 	movt	r3, #87	; 0x57
  12ac14:	e593200c 	ldr	r2, [r3, #12]
  12ac18:	e51b300c 	ldr	r3, [fp, #-12]
  12ac1c:	e5832034 	str	r2, [r3, #52]	; 0x34
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
  12ac20:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12ac24:	e3403057 	movt	r3, #87	; 0x57
  12ac28:	e5d33004 	ldrb	r3, [r3, #4]
  12ac2c:	e3530000 	cmp	r3, #0
  12ac30:	0a000005 	beq	12ac4c <dhcp_handle_ack+0x88>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
  12ac34:	e3063a58 	movw	r3, #27224	; 0x6a58
  12ac38:	e3403057 	movt	r3, #87	; 0x57
  12ac3c:	e5932010 	ldr	r2, [r3, #16]
  12ac40:	e51b300c 	ldr	r3, [fp, #-12]
  12ac44:	e5832038 	str	r2, [r3, #56]	; 0x38
  12ac48:	ea000004 	b	12ac60 <dhcp_handle_ack+0x9c>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  12ac4c:	e51b300c 	ldr	r3, [fp, #-12]
  12ac50:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  12ac54:	e1a020a3 	lsr	r2, r3, #1
  12ac58:	e51b300c 	ldr	r3, [fp, #-12]
  12ac5c:	e5832038 	str	r2, [r3, #56]	; 0x38
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
  12ac60:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12ac64:	e3403057 	movt	r3, #87	; 0x57
  12ac68:	e5d33005 	ldrb	r3, [r3, #5]
  12ac6c:	e3530000 	cmp	r3, #0
  12ac70:	0a000005 	beq	12ac8c <dhcp_handle_ack+0xc8>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
  12ac74:	e3063a58 	movw	r3, #27224	; 0x6a58
  12ac78:	e3403057 	movt	r3, #87	; 0x57
  12ac7c:	e5932014 	ldr	r2, [r3, #20]
  12ac80:	e51b300c 	ldr	r3, [fp, #-12]
  12ac84:	e583203c 	str	r2, [r3, #60]	; 0x3c
  12ac88:	ea000007 	b	12acac <dhcp_handle_ack+0xe8>
  } else {
    /* calculate safe periods for rebinding (offered_t0_lease * 0.875 -> 87.5%)*/
    dhcp->offered_t2_rebind = (dhcp->offered_t0_lease * 7U) / 8U;
  12ac8c:	e51b300c 	ldr	r3, [fp, #-12]
  12ac90:	e5932034 	ldr	r2, [r3, #52]	; 0x34
  12ac94:	e1a03002 	mov	r3, r2
  12ac98:	e1a03183 	lsl	r3, r3, #3
  12ac9c:	e0433002 	sub	r3, r3, r2
  12aca0:	e1a021a3 	lsr	r2, r3, #3
  12aca4:	e51b300c 	ldr	r3, [fp, #-12]
  12aca8:	e583203c 	str	r2, [r3, #60]	; 0x3c
  }

  /* (y)our internet address */
  ip4_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
  12acac:	e51b300c 	ldr	r3, [fp, #-12]
  12acb0:	e5933004 	ldr	r3, [r3, #4]
  12acb4:	e5932010 	ldr	r2, [r3, #16]
  12acb8:	e51b300c 	ldr	r3, [fp, #-12]
  12acbc:	e5832028 	str	r2, [r3, #40]	; 0x28
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip4_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
  12acc0:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12acc4:	e3403057 	movt	r3, #87	; 0x57
  12acc8:	e5d33006 	ldrb	r3, [r3, #6]
  12accc:	e3530000 	cmp	r3, #0
  12acd0:	0a00000b 	beq	12ad04 <dhcp_handle_ack+0x140>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
  12acd4:	e3063a58 	movw	r3, #27224	; 0x6a58
  12acd8:	e3403057 	movt	r3, #87	; 0x57
  12acdc:	e5933018 	ldr	r3, [r3, #24]
  12ace0:	e1a00003 	mov	r0, r3
  12ace4:	ebffaec7 	bl	116808 <lwip_htonl>
  12ace8:	e1a02000 	mov	r2, r0
  12acec:	e51b300c 	ldr	r3, [fp, #-12]
  12acf0:	e583202c 	str	r2, [r3, #44]	; 0x2c
    dhcp->subnet_mask_given = 1;
  12acf4:	e51b300c 	ldr	r3, [fp, #-12]
  12acf8:	e3a02001 	mov	r2, #1
  12acfc:	e5c3200b 	strb	r2, [r3, #11]
  12ad00:	ea000002 	b	12ad10 <dhcp_handle_ack+0x14c>
  } else {
    dhcp->subnet_mask_given = 0;
  12ad04:	e51b300c 	ldr	r3, [fp, #-12]
  12ad08:	e3a02000 	mov	r2, #0
  12ad0c:	e5c3200b 	strb	r2, [r3, #11]
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
  12ad10:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12ad14:	e3403057 	movt	r3, #87	; 0x57
  12ad18:	e5d33007 	ldrb	r3, [r3, #7]
  12ad1c:	e3530000 	cmp	r3, #0
  12ad20:	0a000007 	beq	12ad44 <dhcp_handle_ack+0x180>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
  12ad24:	e3063a58 	movw	r3, #27224	; 0x6a58
  12ad28:	e3403057 	movt	r3, #87	; 0x57
  12ad2c:	e593301c 	ldr	r3, [r3, #28]
  12ad30:	e1a00003 	mov	r0, r3
  12ad34:	ebffaeb3 	bl	116808 <lwip_htonl>
  12ad38:	e1a02000 	mov	r2, r0
  12ad3c:	e51b300c 	ldr	r3, [fp, #-12]
  12ad40:	e5832030 	str	r2, [r3, #48]	; 0x30
  dhcp_set_ntp_servers(n, ntp_server_addrs);
#endif /* LWIP_DHCP_GET_NTP_SRV */

#if LWIP_DHCP_PROVIDE_DNS_SERVERS
  /* DNS servers */
  for (n = 0; (n < LWIP_DHCP_PROVIDE_DNS_SERVERS) && dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n); n++) {
  12ad44:	e3a03000 	mov	r3, #0
  12ad48:	e54b3005 	strb	r3, [fp, #-5]
  12ad4c:	ea000010 	b	12ad94 <dhcp_handle_ack+0x1d0>
    ip_addr_t dns_addr;
    ip_addr_set_ip4_u32(&dns_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
  12ad50:	e55b3005 	ldrb	r3, [fp, #-5]
  12ad54:	e2832008 	add	r2, r3, #8
  12ad58:	e3063a58 	movw	r3, #27224	; 0x6a58
  12ad5c:	e3403057 	movt	r3, #87	; 0x57
  12ad60:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  12ad64:	e1a00003 	mov	r0, r3
  12ad68:	ebffaea6 	bl	116808 <lwip_htonl>
  12ad6c:	e1a03000 	mov	r3, r0
  12ad70:	e50b3010 	str	r3, [fp, #-16]
    dns_setserver(n, &dns_addr);
  12ad74:	e24b2010 	sub	r2, fp, #16
  12ad78:	e55b3005 	ldrb	r3, [fp, #-5]
  12ad7c:	e1a01002 	mov	r1, r2
  12ad80:	e1a00003 	mov	r0, r3
  12ad84:	ebffaf99 	bl	116bf0 <dns_setserver>
  for (n = 0; (n < LWIP_DHCP_PROVIDE_DNS_SERVERS) && dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n); n++) {
  12ad88:	e55b3005 	ldrb	r3, [fp, #-5]
  12ad8c:	e2833001 	add	r3, r3, #1
  12ad90:	e54b3005 	strb	r3, [fp, #-5]
  12ad94:	e55b3005 	ldrb	r3, [fp, #-5]
  12ad98:	e3530001 	cmp	r3, #1
  12ad9c:	8a000006 	bhi	12adbc <dhcp_handle_ack+0x1f8>
  12ada0:	e55b3005 	ldrb	r3, [fp, #-5]
  12ada4:	e2832008 	add	r2, r3, #8
  12ada8:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12adac:	e3403057 	movt	r3, #87	; 0x57
  12adb0:	e7d33002 	ldrb	r3, [r3, r2]
  12adb4:	e3530000 	cmp	r3, #0
  12adb8:	1affffe4 	bne	12ad50 <dhcp_handle_ack+0x18c>
  }
#endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
}
  12adbc:	e320f000 	nop	{0}
  12adc0:	e24bd004 	sub	sp, fp, #4
  12adc4:	e8bd8800 	pop	{fp, pc}

0012adc8 <dhcp_set_struct>:
 * @param netif the netif for which to set the struct dhcp
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
  12adc8:	e92d4800 	push	{fp, lr}
  12adcc:	e28db004 	add	fp, sp, #4
  12add0:	e24dd008 	sub	sp, sp, #8
  12add4:	e50b0008 	str	r0, [fp, #-8]
  12add8:	e50b100c 	str	r1, [fp, #-12]
  LWIP_ASSERT("netif != NULL", netif != NULL);
  12addc:	e51b3008 	ldr	r3, [fp, #-8]
  12ade0:	e3530000 	cmp	r3, #0
  12ade4:	1a000006 	bne	12ae04 <dhcp_set_struct+0x3c>
  12ade8:	e3080fe4 	movw	r0, #36836	; 0x8fe4
  12adec:	e3400014 	movt	r0, #20
  12adf0:	ebff60c7 	bl	103114 <rt_kprintf>
  12adf4:	e3a01faa 	mov	r1, #680	; 0x2a8
  12adf8:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12adfc:	e3400014 	movt	r0, #20
  12ae00:	ebff809d 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
  12ae04:	e51b300c 	ldr	r3, [fp, #-12]
  12ae08:	e3530000 	cmp	r3, #0
  12ae0c:	1a000006 	bne	12ae2c <dhcp_set_struct+0x64>
  12ae10:	e3080ff4 	movw	r0, #36852	; 0x8ff4
  12ae14:	e3400014 	movt	r0, #20
  12ae18:	ebff60bd 	bl	103114 <rt_kprintf>
  12ae1c:	e30012a9 	movw	r1, #681	; 0x2a9
  12ae20:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12ae24:	e3400014 	movt	r0, #20
  12ae28:	ebff8093 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("netif already has a struct dhcp set", netif_dhcp_data(netif) == NULL);
  12ae2c:	e51b3008 	ldr	r3, [fp, #-8]
  12ae30:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12ae34:	e3530000 	cmp	r3, #0
  12ae38:	0a000006 	beq	12ae58 <dhcp_set_struct+0x90>
  12ae3c:	e3090004 	movw	r0, #36868	; 0x9004
  12ae40:	e3400014 	movt	r0, #20
  12ae44:	ebff60b2 	bl	103114 <rt_kprintf>
  12ae48:	e30012aa 	movw	r1, #682	; 0x2aa
  12ae4c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12ae50:	e3400014 	movt	r0, #20
  12ae54:	ebff8088 	bl	10b07c <sys_arch_assert>

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  12ae58:	e3a02040 	mov	r2, #64	; 0x40
  12ae5c:	e3a01000 	mov	r1, #0
  12ae60:	e51b000c 	ldr	r0, [fp, #-12]
  12ae64:	eb005982 	bl	141474 <memset>
  /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */
  netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
  12ae68:	e51b3008 	ldr	r3, [fp, #-8]
  12ae6c:	e51b200c 	ldr	r2, [fp, #-12]
  12ae70:	e5832028 	str	r2, [r3, #40]	; 0x28
}
  12ae74:	e320f000 	nop	{0}
  12ae78:	e24bd004 	sub	sp, fp, #4
  12ae7c:	e8bd8800 	pop	{fp, pc}

0012ae80 <dhcp_cleanup>:
 *            struct dhcp since the memory is passed back to the heap.
 *
 * @param netif the netif from which to remove the struct dhcp
 */
void dhcp_cleanup(struct netif *netif)
{
  12ae80:	e92d4800 	push	{fp, lr}
  12ae84:	e28db004 	add	fp, sp, #4
  12ae88:	e24dd008 	sub	sp, sp, #8
  12ae8c:	e50b0008 	str	r0, [fp, #-8]
  LWIP_ASSERT("netif != NULL", netif != NULL);
  12ae90:	e51b3008 	ldr	r3, [fp, #-8]
  12ae94:	e3530000 	cmp	r3, #0
  12ae98:	1a000006 	bne	12aeb8 <dhcp_cleanup+0x38>
  12ae9c:	e3080fe4 	movw	r0, #36836	; 0x8fe4
  12aea0:	e3400014 	movt	r0, #20
  12aea4:	ebff609a 	bl	103114 <rt_kprintf>
  12aea8:	e30012bd 	movw	r1, #701	; 0x2bd
  12aeac:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12aeb0:	e3400014 	movt	r0, #20
  12aeb4:	ebff8070 	bl	10b07c <sys_arch_assert>

  if (netif_dhcp_data(netif) != NULL) {
  12aeb8:	e51b3008 	ldr	r3, [fp, #-8]
  12aebc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12aec0:	e3530000 	cmp	r3, #0
  12aec4:	0a000006 	beq	12aee4 <dhcp_cleanup+0x64>
    mem_free(netif_dhcp_data(netif));
  12aec8:	e51b3008 	ldr	r3, [fp, #-8]
  12aecc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12aed0:	e1a00003 	mov	r0, r3
  12aed4:	ebff80b5 	bl	10b1b0 <mem_free>
    netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, NULL);
  12aed8:	e51b3008 	ldr	r3, [fp, #-8]
  12aedc:	e3a02000 	mov	r2, #0
  12aee0:	e5832028 	str	r2, [r3, #40]	; 0x28
  }
}
  12aee4:	e320f000 	nop	{0}
  12aee8:	e24bd004 	sub	sp, fp, #4
  12aeec:	e8bd8800 	pop	{fp, pc}

0012aef0 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  12aef0:	e92d4800 	push	{fp, lr}
  12aef4:	e28db004 	add	fp, sp, #4
  12aef8:	e24dd010 	sub	sp, sp, #16
  12aefc:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp;
  err_t result;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  12af00:	e51b3010 	ldr	r3, [fp, #-16]
  12af04:	e3530000 	cmp	r3, #0
  12af08:	1a000008 	bne	12af30 <dhcp_start+0x40>
  12af0c:	e3080fe4 	movw	r0, #36836	; 0x8fe4
  12af10:	e3400014 	movt	r0, #20
  12af14:	ebff607e 	bl	103114 <rt_kprintf>
  12af18:	e3a01fb6 	mov	r1, #728	; 0x2d8
  12af1c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12af20:	e3400014 	movt	r0, #20
  12af24:	ebff8054 	bl	10b07c <sys_arch_assert>
  12af28:	e3e0300f 	mvn	r3, #15
  12af2c:	ea000059 	b	12b098 <dhcp_start+0x1a8>
  LWIP_ERROR("netif is not up, old style port?", netif_is_up(netif), return ERR_ARG;);
  12af30:	e51b3010 	ldr	r3, [fp, #-16]
  12af34:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  12af38:	e2033001 	and	r3, r3, #1
  12af3c:	e3530000 	cmp	r3, #0
  12af40:	1a000008 	bne	12af68 <dhcp_start+0x78>
  12af44:	e3090028 	movw	r0, #36904	; 0x9028
  12af48:	e3400014 	movt	r0, #20
  12af4c:	ebff6070 	bl	103114 <rt_kprintf>
  12af50:	e30012d9 	movw	r1, #729	; 0x2d9
  12af54:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12af58:	e3400014 	movt	r0, #20
  12af5c:	ebff8046 	bl	10b07c <sys_arch_assert>
  12af60:	e3e0300f 	mvn	r3, #15
  12af64:	ea00004b 	b	12b098 <dhcp_start+0x1a8>
  dhcp = netif_dhcp_data(netif);
  12af68:	e51b3010 	ldr	r3, [fp, #-16]
  12af6c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12af70:	e50b3008 	str	r3, [fp, #-8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
  12af74:	e51b3010 	ldr	r3, [fp, #-16]
  12af78:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  12af7c:	e3530d09 	cmp	r3, #576	; 0x240
  12af80:	2a000001 	bcs	12af8c <dhcp_start+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
  12af84:	e3e03000 	mvn	r3, #0
  12af88:	ea000042 	b	12b098 <dhcp_start+0x1a8>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  12af8c:	e51b3008 	ldr	r3, [fp, #-8]
  12af90:	e3530000 	cmp	r3, #0
  12af94:	1a00000b 	bne	12afc8 <dhcp_start+0xd8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
  12af98:	e3a00040 	mov	r0, #64	; 0x40
  12af9c:	ebff8077 	bl	10b180 <mem_malloc>
  12afa0:	e50b0008 	str	r0, [fp, #-8]
    if (dhcp == NULL) {
  12afa4:	e51b3008 	ldr	r3, [fp, #-8]
  12afa8:	e3530000 	cmp	r3, #0
  12afac:	1a000001 	bne	12afb8 <dhcp_start+0xc8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  12afb0:	e3e03000 	mvn	r3, #0
  12afb4:	ea000037 	b	12b098 <dhcp_start+0x1a8>
    }

    /* store this dhcp client in the netif */
    netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
  12afb8:	e51b3010 	ldr	r3, [fp, #-16]
  12afbc:	e51b2008 	ldr	r2, [fp, #-8]
  12afc0:	e5832028 	str	r2, [r3, #40]	; 0x28
  12afc4:	ea00001a 	b	12b034 <dhcp_start+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
  12afc8:	e51b3008 	ldr	r3, [fp, #-8]
  12afcc:	e593300c 	ldr	r3, [r3, #12]
  12afd0:	e3530000 	cmp	r3, #0
  12afd4:	0a000006 	beq	12aff4 <dhcp_start+0x104>
  12afd8:	e309004c 	movw	r0, #36940	; 0x904c
  12afdc:	e3400014 	movt	r0, #20
  12afe0:	ebff604b 	bl	103114 <rt_kprintf>
  12afe4:	e30012f2 	movw	r1, #754	; 0x2f2
  12afe8:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12afec:	e3400014 	movt	r0, #20
  12aff0:	ebff8021 	bl	10b07c <sys_arch_assert>
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
  12aff4:	e51b3008 	ldr	r3, [fp, #-8]
  12aff8:	e5933004 	ldr	r3, [r3, #4]
  12affc:	e3530000 	cmp	r3, #0
  12b000:	0a000006 	beq	12b020 <dhcp_start+0x130>
  12b004:	e3090064 	movw	r0, #36964	; 0x9064
  12b008:	e3400014 	movt	r0, #20
  12b00c:	ebff6040 	bl	103114 <rt_kprintf>
  12b010:	e30012f3 	movw	r1, #755	; 0x2f3
  12b014:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12b018:	e3400014 	movt	r0, #20
  12b01c:	ebff8016 	bl	10b07c <sys_arch_assert>

    if (dhcp->pcb_allocated != 0) {
  12b020:	e51b3008 	ldr	r3, [fp, #-8]
  12b024:	e5d33008 	ldrb	r3, [r3, #8]
  12b028:	e3530000 	cmp	r3, #0
  12b02c:	0a000000 	beq	12b034 <dhcp_start+0x144>
      dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
  12b030:	ebfffcb7 	bl	12a314 <dhcp_dec_pcb_refcount>
    }
    /* dhcp is cleared below, no need to reset flag*/
  }

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  12b034:	e3a02040 	mov	r2, #64	; 0x40
  12b038:	e3a01000 	mov	r1, #0
  12b03c:	e51b0008 	ldr	r0, [fp, #-8]
  12b040:	eb00590b 	bl	141474 <memset>
  /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));

  if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
  12b044:	ebfffc66 	bl	12a1e4 <dhcp_inc_pcb_refcount>
  12b048:	e1a03000 	mov	r3, r0
  12b04c:	e3530000 	cmp	r3, #0
  12b050:	0a000001 	beq	12b05c <dhcp_start+0x16c>
    return ERR_MEM;
  12b054:	e3e03000 	mvn	r3, #0
  12b058:	ea00000e 	b	12b098 <dhcp_start+0x1a8>
  }
  dhcp->pcb_allocated = 1;
  12b05c:	e51b3008 	ldr	r3, [fp, #-8]
  12b060:	e3a02001 	mov	r2, #1
  12b064:	e5c32008 	strb	r2, [r3, #8]
  }
#endif /* LWIP_DHCP_CHECK_LINK_UP */


  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  12b068:	e51b0010 	ldr	r0, [fp, #-16]
  12b06c:	eb000103 	bl	12b480 <dhcp_discover>
  12b070:	e1a03000 	mov	r3, r0
  12b074:	e54b3009 	strb	r3, [fp, #-9]
  if (result != ERR_OK) {
  12b078:	e15b30d9 	ldrsb	r3, [fp, #-9]
  12b07c:	e3530000 	cmp	r3, #0
  12b080:	0a000003 	beq	12b094 <dhcp_start+0x1a4>
    /* free resources allocated above */
    dhcp_stop(netif);
  12b084:	e51b0010 	ldr	r0, [fp, #-16]
  12b088:	eb000410 	bl	12c0d0 <dhcp_stop>
    return ERR_MEM;
  12b08c:	e3e03000 	mvn	r3, #0
  12b090:	ea000000 	b	12b098 <dhcp_start+0x1a8>
  }
  return result;
  12b094:	e15b30d9 	ldrsb	r3, [fp, #-9]
}
  12b098:	e1a00003 	mov	r0, r3
  12b09c:	e24bd004 	sub	sp, fp, #4
  12b0a0:	e8bd8800 	pop	{fp, pc}

0012b0a4 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  12b0a4:	e92d4800 	push	{fp, lr}
  12b0a8:	e28db004 	add	fp, sp, #4
  12b0ac:	e24dd058 	sub	sp, sp, #88	; 0x58
  12b0b0:	e50b0050 	str	r0, [fp, #-80]	; 0xffffffb0
  struct dhcp dhcp;
  err_t result = ERR_OK;
  12b0b4:	e3a03000 	mov	r3, #0
  12b0b8:	e54b3005 	strb	r3, [fp, #-5]

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  12b0bc:	e51b3050 	ldr	r3, [fp, #-80]	; 0xffffffb0
  12b0c0:	e3530000 	cmp	r3, #0
  12b0c4:	1a000007 	bne	12b0e8 <dhcp_inform+0x44>
  12b0c8:	e3080fe4 	movw	r0, #36836	; 0x8fe4
  12b0cc:	e3400014 	movt	r0, #20
  12b0d0:	ebff600f 	bl	103114 <rt_kprintf>
  12b0d4:	e3001329 	movw	r1, #809	; 0x329
  12b0d8:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12b0dc:	e3400014 	movt	r0, #20
  12b0e0:	ebff7fe5 	bl	10b07c <sys_arch_assert>
  12b0e4:	ea00003b 	b	12b1d8 <dhcp_inform+0x134>

  if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
  12b0e8:	ebfffc3d 	bl	12a1e4 <dhcp_inc_pcb_refcount>
  12b0ec:	e1a03000 	mov	r3, r0
  12b0f0:	e3530000 	cmp	r3, #0
  12b0f4:	1a000036 	bne	12b1d4 <dhcp_inform+0x130>
    return;
  }

  memset(&dhcp, 0, sizeof(struct dhcp));
  12b0f8:	e24b3048 	sub	r3, fp, #72	; 0x48
  12b0fc:	e3a02040 	mov	r2, #64	; 0x40
  12b100:	e3a01000 	mov	r1, #0
  12b104:	e1a00003 	mov	r0, r3
  12b108:	eb0058d9 	bl	141474 <memset>
  dhcp_set_state(&dhcp, DHCP_STATE_INFORMING);
  12b10c:	e24b3048 	sub	r3, fp, #72	; 0x48
  12b110:	e3a01007 	mov	r1, #7
  12b114:	e1a00003 	mov	r0, r3
  12b118:	eb000419 	bl	12c184 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, &dhcp, DHCP_INFORM);
  12b11c:	e24b3048 	sub	r3, fp, #72	; 0x48
  12b120:	e3a02008 	mov	r2, #8
  12b124:	e1a01003 	mov	r1, r3
  12b128:	e51b0050 	ldr	r0, [fp, #-80]	; 0xffffffb0
  12b12c:	eb000844 	bl	12d244 <dhcp_create_msg>
  12b130:	e1a03000 	mov	r3, r0
  12b134:	e54b3005 	strb	r3, [fp, #-5]
  if (result == ERR_OK) {
  12b138:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12b13c:	e3530000 	cmp	r3, #0
  12b140:	1a000021 	bne	12b1cc <dhcp_inform+0x128>
    dhcp_option(&dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  12b144:	e24b3048 	sub	r3, fp, #72	; 0x48
  12b148:	e3a02002 	mov	r2, #2
  12b14c:	e3a01039 	mov	r1, #57	; 0x39
  12b150:	e1a00003 	mov	r0, r3
  12b154:	eb000422 	bl	12c1e4 <dhcp_option>
    dhcp_option_short(&dhcp, DHCP_MAX_MSG_LEN(netif));
  12b158:	e51b3050 	ldr	r3, [fp, #-80]	; 0xffffffb0
  12b15c:	e1d323b8 	ldrh	r2, [r3, #56]	; 0x38
  12b160:	e24b3048 	sub	r3, fp, #72	; 0x48
  12b164:	e1a01002 	mov	r1, r2
  12b168:	e1a00003 	mov	r0, r3
  12b16c:	eb00046b 	bl	12c320 <dhcp_option_short>

    dhcp_option_trailer(&dhcp);
  12b170:	e24b3048 	sub	r3, fp, #72	; 0x48
  12b174:	e1a00003 	mov	r0, r3
  12b178:	eb00099e 	bl	12d7f8 <dhcp_option_trailer>

    pbuf_realloc(dhcp.p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp.options_out_len);
  12b17c:	e51b203c 	ldr	r2, [fp, #-60]	; 0xffffffc4
  12b180:	e15b33b4 	ldrh	r3, [fp, #-52]	; 0xffffffcc
  12b184:	e28330f0 	add	r3, r3, #240	; 0xf0
  12b188:	e6ff3073 	uxth	r3, r3
  12b18c:	e1a01003 	mov	r1, r3
  12b190:	e1a00002 	mov	r0, r2
  12b194:	ebffbe7d 	bl	11ab90 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));

    udp_sendto_if(dhcp_pcb, dhcp.p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  12b198:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12b19c:	e3403014 	movt	r3, #20
  12b1a0:	e5930000 	ldr	r0, [r3]
  12b1a4:	e51b103c 	ldr	r1, [fp, #-60]	; 0xffffffc4
  12b1a8:	e51b3050 	ldr	r3, [fp, #-80]	; 0xffffffb0
  12b1ac:	e58d3000 	str	r3, [sp]
  12b1b0:	e3a03043 	mov	r3, #67	; 0x43
  12b1b4:	e3092b28 	movw	r2, #39720	; 0x9b28
  12b1b8:	e3402014 	movt	r2, #20
  12b1bc:	ebfff49a 	bl	12842c <udp_sendto_if>

    dhcp_delete_msg(&dhcp);
  12b1c0:	e24b3048 	sub	r3, fp, #72	; 0x48
  12b1c4:	e1a00003 	mov	r0, r3
  12b1c8:	eb000955 	bl	12d724 <dhcp_delete_msg>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  dhcp_dec_pcb_refcount(); /* delete DHCP PCB if not needed any more */
  12b1cc:	ebfffc50 	bl	12a314 <dhcp_dec_pcb_refcount>
  12b1d0:	ea000000 	b	12b1d8 <dhcp_inform+0x134>
    return;
  12b1d4:	e320f000 	nop	{0}
}
  12b1d8:	e24bd004 	sub	sp, fp, #4
  12b1dc:	e8bd8800 	pop	{fp, pc}

0012b1e0 <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
  12b1e0:	e92d4800 	push	{fp, lr}
  12b1e4:	e28db004 	add	fp, sp, #4
  12b1e8:	e24dd010 	sub	sp, sp, #16
  12b1ec:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12b1f0:	e51b3010 	ldr	r3, [fp, #-16]
  12b1f4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12b1f8:	e50b3008 	str	r3, [fp, #-8]

  if (!dhcp)
  12b1fc:	e51b3008 	ldr	r3, [fp, #-8]
  12b200:	e3530000 	cmp	r3, #0
  12b204:	0a00001c 	beq	12b27c <dhcp_network_changed+0x9c>
    return;
  switch (dhcp->state) {
  12b208:	e51b3008 	ldr	r3, [fp, #-8]
  12b20c:	e5d33009 	ldrb	r3, [r3, #9]
  12b210:	e353000a 	cmp	r3, #10
  12b214:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  12b218:	ea000010 	b	12b260 <dhcp_network_changed+0x80>
  12b21c:	0012b284 	.word	0x0012b284
  12b220:	0012b260 	.word	0x0012b260
  12b224:	0012b260 	.word	0x0012b260
  12b228:	0012b248 	.word	0x0012b248
  12b22c:	0012b248 	.word	0x0012b248
  12b230:	0012b248 	.word	0x0012b248
  12b234:	0012b260 	.word	0x0012b260
  12b238:	0012b260 	.word	0x0012b260
  12b23c:	0012b260 	.word	0x0012b260
  12b240:	0012b260 	.word	0x0012b260
  12b244:	0012b248 	.word	0x0012b248
  case DHCP_STATE_REBINDING:
  case DHCP_STATE_RENEWING:
  case DHCP_STATE_BOUND:
  case DHCP_STATE_REBOOTING:
    dhcp->tries = 0;
  12b248:	e51b3008 	ldr	r3, [fp, #-8]
  12b24c:	e3a02000 	mov	r2, #0
  12b250:	e5c3200a 	strb	r2, [r3, #10]
    dhcp_reboot(netif);
  12b254:	e51b0010 	ldr	r0, [fp, #-16]
  12b258:	eb0002a7 	bl	12bcfc <dhcp_reboot>
    break;
  12b25c:	ea000009 	b	12b288 <dhcp_network_changed+0xa8>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    /* ensure we start with short timeouts, even if already discovering */
    dhcp->tries = 0;
  12b260:	e51b3008 	ldr	r3, [fp, #-8]
  12b264:	e3a02000 	mov	r2, #0
  12b268:	e5c3200a 	strb	r2, [r3, #10]
    dhcp_discover(netif);
  12b26c:	e51b0010 	ldr	r0, [fp, #-16]
  12b270:	eb000082 	bl	12b480 <dhcp_discover>
    break;
  12b274:	e320f000 	nop	{0}
  12b278:	ea000002 	b	12b288 <dhcp_network_changed+0xa8>
    return;
  12b27c:	e320f000 	nop	{0}
  12b280:	ea000000 	b	12b288 <dhcp_network_changed+0xa8>
    break;
  12b284:	e320f000 	nop	{0}
  }
}
  12b288:	e24bd004 	sub	sp, fp, #4
  12b28c:	e8bd8800 	pop	{fp, pc}

0012b290 <dhcp_arp_reply>:
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void
dhcp_arp_reply(struct netif *netif, const ip4_addr_t *addr)
{
  12b290:	e92d4800 	push	{fp, lr}
  12b294:	e28db004 	add	fp, sp, #4
  12b298:	e24dd010 	sub	sp, sp, #16
  12b29c:	e50b0010 	str	r0, [fp, #-16]
  12b2a0:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct dhcp *dhcp;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  12b2a4:	e51b3010 	ldr	r3, [fp, #-16]
  12b2a8:	e3530000 	cmp	r3, #0
  12b2ac:	1a000007 	bne	12b2d0 <dhcp_arp_reply+0x40>
  12b2b0:	e3080fe4 	movw	r0, #36836	; 0x8fe4
  12b2b4:	e3400014 	movt	r0, #20
  12b2b8:	ebff5f95 	bl	103114 <rt_kprintf>
  12b2bc:	e300137d 	movw	r1, #893	; 0x37d
  12b2c0:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12b2c4:	e3400014 	movt	r0, #20
  12b2c8:	ebff7f6b 	bl	10b07c <sys_arch_assert>
  12b2cc:	ea000011 	b	12b318 <dhcp_arp_reply+0x88>
  dhcp = netif_dhcp_data(netif);
  12b2d0:	e51b3010 	ldr	r3, [fp, #-16]
  12b2d4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12b2d8:	e50b3008 	str	r3, [fp, #-8]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((dhcp != NULL) && (dhcp->state == DHCP_STATE_CHECKING)) {
  12b2dc:	e51b3008 	ldr	r3, [fp, #-8]
  12b2e0:	e3530000 	cmp	r3, #0
  12b2e4:	0a00000b 	beq	12b318 <dhcp_arp_reply+0x88>
  12b2e8:	e51b3008 	ldr	r3, [fp, #-8]
  12b2ec:	e5d33009 	ldrb	r3, [r3, #9]
  12b2f0:	e3530008 	cmp	r3, #8
  12b2f4:	1a000007 	bne	12b318 <dhcp_arp_reply+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
      ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip4_addr_cmp(addr, &dhcp->offered_ip_addr)) {
  12b2f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12b2fc:	e5932000 	ldr	r2, [r3]
  12b300:	e51b3008 	ldr	r3, [fp, #-8]
  12b304:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12b308:	e1520003 	cmp	r2, r3
  12b30c:	1a000001 	bne	12b318 <dhcp_arp_reply+0x88>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  12b310:	e51b0010 	ldr	r0, [fp, #-16]
  12b314:	eb000001 	bl	12b320 <dhcp_decline>
    }
  }
}
  12b318:	e24bd004 	sub	sp, fp, #4
  12b31c:	e8bd8800 	pop	{fp, pc}

0012b320 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  12b320:	e92d4800 	push	{fp, lr}
  12b324:	e28db004 	add	fp, sp, #4
  12b328:	e24dd018 	sub	sp, sp, #24
  12b32c:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12b330:	e51b3010 	ldr	r3, [fp, #-16]
  12b334:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12b338:	e50b3008 	str	r3, [fp, #-8]
  err_t result = ERR_OK;
  12b33c:	e3a03000 	mov	r3, #0
  12b340:	e54b3009 	strb	r3, [fp, #-9]
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
  12b344:	e3a0100c 	mov	r1, #12
  12b348:	e51b0008 	ldr	r0, [fp, #-8]
  12b34c:	eb00038c 	bl	12c184 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
  12b350:	e3a02004 	mov	r2, #4
  12b354:	e51b1008 	ldr	r1, [fp, #-8]
  12b358:	e51b0010 	ldr	r0, [fp, #-16]
  12b35c:	eb0007b8 	bl	12d244 <dhcp_create_msg>
  12b360:	e1a03000 	mov	r3, r0
  12b364:	e54b3009 	strb	r3, [fp, #-9]
  if (result == ERR_OK) {
  12b368:	e15b30d9 	ldrsb	r3, [fp, #-9]
  12b36c:	e3530000 	cmp	r3, #0
  12b370:	1a000026 	bne	12b410 <dhcp_decline+0xf0>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  12b374:	e3a02004 	mov	r2, #4
  12b378:	e3a01032 	mov	r1, #50	; 0x32
  12b37c:	e51b0008 	ldr	r0, [fp, #-8]
  12b380:	eb000397 	bl	12c1e4 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  12b384:	e51b3008 	ldr	r3, [fp, #-8]
  12b388:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12b38c:	e1a00003 	mov	r0, r3
  12b390:	ebffad1c 	bl	116808 <lwip_htonl>
  12b394:	e1a03000 	mov	r3, r0
  12b398:	e1a01003 	mov	r1, r3
  12b39c:	e51b0008 	ldr	r0, [fp, #-8]
  12b3a0:	eb00040f 	bl	12c3e4 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  12b3a4:	e51b0008 	ldr	r0, [fp, #-8]
  12b3a8:	eb000912 	bl	12d7f8 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  12b3ac:	e51b3008 	ldr	r3, [fp, #-8]
  12b3b0:	e593200c 	ldr	r2, [r3, #12]
  12b3b4:	e51b3008 	ldr	r3, [fp, #-8]
  12b3b8:	e1d331b4 	ldrh	r3, [r3, #20]
  12b3bc:	e28330f0 	add	r3, r3, #240	; 0xf0
  12b3c0:	e6ff3073 	uxth	r3, r3
  12b3c4:	e1a01003 	mov	r1, r3
  12b3c8:	e1a00002 	mov	r0, r2
  12b3cc:	ebffbdef 	bl	11ab90 <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if_src(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif, IP4_ADDR_ANY);
  12b3d0:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12b3d4:	e3403014 	movt	r3, #20
  12b3d8:	e5930000 	ldr	r0, [r3]
  12b3dc:	e51b3008 	ldr	r3, [fp, #-8]
  12b3e0:	e593100c 	ldr	r1, [r3, #12]
  12b3e4:	e3093b24 	movw	r3, #39716	; 0x9b24
  12b3e8:	e3403014 	movt	r3, #20
  12b3ec:	e58d3004 	str	r3, [sp, #4]
  12b3f0:	e51b3010 	ldr	r3, [fp, #-16]
  12b3f4:	e58d3000 	str	r3, [sp]
  12b3f8:	e3a03043 	mov	r3, #67	; 0x43
  12b3fc:	e3092b28 	movw	r2, #39720	; 0x9b28
  12b400:	e3402014 	movt	r2, #20
  12b404:	ebfff440 	bl	12850c <udp_sendto_if_src>
    dhcp_delete_msg(dhcp);
  12b408:	e51b0008 	ldr	r0, [fp, #-8]
  12b40c:	eb0008c4 	bl	12d724 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  if (dhcp->tries < 255) {
  12b410:	e51b3008 	ldr	r3, [fp, #-8]
  12b414:	e5d3300a 	ldrb	r3, [r3, #10]
  12b418:	e35300ff 	cmp	r3, #255	; 0xff
  12b41c:	0a000005 	beq	12b438 <dhcp_decline+0x118>
    dhcp->tries++;
  12b420:	e51b3008 	ldr	r3, [fp, #-8]
  12b424:	e5d3300a 	ldrb	r3, [r3, #10]
  12b428:	e2833001 	add	r3, r3, #1
  12b42c:	e6ef2073 	uxtb	r2, r3
  12b430:	e51b3008 	ldr	r3, [fp, #-8]
  12b434:	e5c3200a 	strb	r2, [r3, #10]
  }
  msecs = 10*1000;
  12b438:	e3023710 	movw	r3, #10000	; 0x2710
  12b43c:	e14b30bc 	strh	r3, [fp, #-12]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  12b440:	e15b30bc 	ldrh	r3, [fp, #-12]
  12b444:	e2833e1f 	add	r3, r3, #496	; 0x1f0
  12b448:	e2833003 	add	r3, r3, #3
  12b44c:	e3042dd3 	movw	r2, #19923	; 0x4dd3
  12b450:	e3412062 	movt	r2, #4194	; 0x1062
  12b454:	e0c10293 	smull	r0, r1, r3, r2
  12b458:	e1a022c1 	asr	r2, r1, #5
  12b45c:	e1a03fc3 	asr	r3, r3, #31
  12b460:	e0423003 	sub	r3, r2, r3
  12b464:	e6ff2073 	uxth	r2, r3
  12b468:	e51b3008 	ldr	r3, [fp, #-8]
  12b46c:	e1c321b6 	strh	r2, [r3, #22]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  12b470:	e15b30d9 	ldrsb	r3, [fp, #-9]
}
  12b474:	e1a00003 	mov	r0, r3
  12b478:	e24bd004 	sub	sp, fp, #4
  12b47c:	e8bd8800 	pop	{fp, pc}

0012b480 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  12b480:	e92d4800 	push	{fp, lr}
  12b484:	e28db004 	add	fp, sp, #4
  12b488:	e24dd020 	sub	sp, sp, #32
  12b48c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12b490:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12b494:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12b498:	e50b300c 	str	r3, [fp, #-12]
  err_t result = ERR_OK;
  12b49c:	e3a03000 	mov	r3, #0
  12b4a0:	e54b300d 	strb	r3, [fp, #-13]
  u16_t msecs;
  u8_t i;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip4_addr_set_any(&dhcp->offered_ip_addr);
  12b4a4:	e51b300c 	ldr	r3, [fp, #-12]
  12b4a8:	e3a02000 	mov	r2, #0
  12b4ac:	e5832028 	str	r2, [r3, #40]	; 0x28
  dhcp_set_state(dhcp, DHCP_STATE_SELECTING);
  12b4b0:	e3a01006 	mov	r1, #6
  12b4b4:	e51b000c 	ldr	r0, [fp, #-12]
  12b4b8:	eb000331 	bl	12c184 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
  12b4bc:	e3a02001 	mov	r2, #1
  12b4c0:	e51b100c 	ldr	r1, [fp, #-12]
  12b4c4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12b4c8:	eb00075d 	bl	12d244 <dhcp_create_msg>
  12b4cc:	e1a03000 	mov	r3, r0
  12b4d0:	e54b300d 	strb	r3, [fp, #-13]
  if (result == ERR_OK) {
  12b4d4:	e15b30dd 	ldrsb	r3, [fp, #-13]
  12b4d8:	e3530000 	cmp	r3, #0
  12b4dc:	1a000037 	bne	12b5c0 <dhcp_discover+0x140>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  12b4e0:	e3a02002 	mov	r2, #2
  12b4e4:	e3a01039 	mov	r1, #57	; 0x39
  12b4e8:	e51b000c 	ldr	r0, [fp, #-12]
  12b4ec:	eb00033c 	bl	12c1e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
  12b4f0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12b4f4:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  12b4f8:	e1a01003 	mov	r1, r3
  12b4fc:	e51b000c 	ldr	r0, [fp, #-12]
  12b500:	eb000386 	bl	12c320 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
  12b504:	e3a02004 	mov	r2, #4
  12b508:	e3a01037 	mov	r1, #55	; 0x37
  12b50c:	e51b000c 	ldr	r0, [fp, #-12]
  12b510:	eb000333 	bl	12c1e4 <dhcp_option>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12b514:	e3a03000 	mov	r3, #0
  12b518:	e54b3005 	strb	r3, [fp, #-5]
  12b51c:	ea000009 	b	12b548 <dhcp_discover+0xc8>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
  12b520:	e55b2005 	ldrb	r2, [fp, #-5]
  12b524:	e30e303c 	movw	r3, #57404	; 0xe03c
  12b528:	e3403014 	movt	r3, #20
  12b52c:	e7d33002 	ldrb	r3, [r3, r2]
  12b530:	e1a01003 	mov	r1, r3
  12b534:	e51b000c 	ldr	r0, [fp, #-12]
  12b538:	eb000359 	bl	12c2a4 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12b53c:	e55b3005 	ldrb	r3, [fp, #-5]
  12b540:	e2833001 	add	r3, r3, #1
  12b544:	e54b3005 	strb	r3, [fp, #-5]
  12b548:	e55b3005 	ldrb	r3, [fp, #-5]
  12b54c:	e3530003 	cmp	r3, #3
  12b550:	9afffff2 	bls	12b520 <dhcp_discover+0xa0>
    }
    dhcp_option_trailer(dhcp);
  12b554:	e51b000c 	ldr	r0, [fp, #-12]
  12b558:	eb0008a6 	bl	12d7f8 <dhcp_option_trailer>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  12b55c:	e51b300c 	ldr	r3, [fp, #-12]
  12b560:	e593200c 	ldr	r2, [r3, #12]
  12b564:	e51b300c 	ldr	r3, [fp, #-12]
  12b568:	e1d331b4 	ldrh	r3, [r3, #20]
  12b56c:	e28330f0 	add	r3, r3, #240	; 0xf0
  12b570:	e6ff3073 	uxth	r3, r3
  12b574:	e1a01003 	mov	r1, r3
  12b578:	e1a00002 	mov	r0, r2
  12b57c:	ebffbd83 	bl	11ab90 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if_src(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif, IP4_ADDR_ANY);
  12b580:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12b584:	e3403014 	movt	r3, #20
  12b588:	e5930000 	ldr	r0, [r3]
  12b58c:	e51b300c 	ldr	r3, [fp, #-12]
  12b590:	e593100c 	ldr	r1, [r3, #12]
  12b594:	e3093b24 	movw	r3, #39716	; 0x9b24
  12b598:	e3403014 	movt	r3, #20
  12b59c:	e58d3004 	str	r3, [sp, #4]
  12b5a0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12b5a4:	e58d3000 	str	r3, [sp]
  12b5a8:	e3a03043 	mov	r3, #67	; 0x43
  12b5ac:	e3092b28 	movw	r2, #39720	; 0x9b28
  12b5b0:	e3402014 	movt	r2, #20
  12b5b4:	ebfff3d4 	bl	12850c <udp_sendto_if_src>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_msg(dhcp);
  12b5b8:	e51b000c 	ldr	r0, [fp, #-12]
  12b5bc:	eb000858 	bl	12d724 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  if (dhcp->tries < 255) {
  12b5c0:	e51b300c 	ldr	r3, [fp, #-12]
  12b5c4:	e5d3300a 	ldrb	r3, [r3, #10]
  12b5c8:	e35300ff 	cmp	r3, #255	; 0xff
  12b5cc:	0a000005 	beq	12b5e8 <dhcp_discover+0x168>
    dhcp->tries++;
  12b5d0:	e51b300c 	ldr	r3, [fp, #-12]
  12b5d4:	e5d3300a 	ldrb	r3, [r3, #10]
  12b5d8:	e2833001 	add	r3, r3, #1
  12b5dc:	e6ef2073 	uxtb	r2, r3
  12b5e0:	e51b300c 	ldr	r3, [fp, #-12]
  12b5e4:	e5c3200a 	strb	r2, [r3, #10]
  if (dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  12b5e8:	e51b300c 	ldr	r3, [fp, #-12]
  12b5ec:	e5d3300a 	ldrb	r3, [r3, #10]
  12b5f0:	e3530005 	cmp	r3, #5
  12b5f4:	8a000006 	bhi	12b614 <dhcp_discover+0x194>
  12b5f8:	e51b300c 	ldr	r3, [fp, #-12]
  12b5fc:	e5d3300a 	ldrb	r3, [r3, #10]
  12b600:	e1a02003 	mov	r2, r3
  12b604:	e3a03ffa 	mov	r3, #1000	; 0x3e8
  12b608:	e1a03213 	lsl	r3, r3, r2
  12b60c:	e6ff3073 	uxth	r3, r3
  12b610:	ea000000 	b	12b618 <dhcp_discover+0x198>
  12b614:	e30e3a60 	movw	r3, #60000	; 0xea60
  12b618:	e14b31b0 	strh	r3, [fp, #-16]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  12b61c:	e15b31b0 	ldrh	r3, [fp, #-16]
  12b620:	e2833e1f 	add	r3, r3, #496	; 0x1f0
  12b624:	e2833003 	add	r3, r3, #3
  12b628:	e3042dd3 	movw	r2, #19923	; 0x4dd3
  12b62c:	e3412062 	movt	r2, #4194	; 0x1062
  12b630:	e0c10293 	smull	r0, r1, r3, r2
  12b634:	e1a022c1 	asr	r2, r1, #5
  12b638:	e1a03fc3 	asr	r3, r3, #31
  12b63c:	e0423003 	sub	r3, r2, r3
  12b640:	e6ff2073 	uxth	r2, r3
  12b644:	e51b300c 	ldr	r3, [fp, #-12]
  12b648:	e1c321b6 	strh	r2, [r3, #22]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  12b64c:	e15b30dd 	ldrsb	r3, [fp, #-13]
}
  12b650:	e1a00003 	mov	r0, r3
  12b654:	e24bd004 	sub	sp, fp, #4
  12b658:	e8bd8800 	pop	{fp, pc}

0012b65c <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  12b65c:	e92d4800 	push	{fp, lr}
  12b660:	e28db004 	add	fp, sp, #4
  12b664:	e24dd020 	sub	sp, sp, #32
  12b668:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  u32_t timeout;
  struct dhcp *dhcp;
  ip4_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  12b66c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12b670:	e3530000 	cmp	r3, #0
  12b674:	1a000007 	bne	12b698 <dhcp_bind+0x3c>
  12b678:	e3090078 	movw	r0, #36984	; 0x9078
  12b67c:	e3400014 	movt	r0, #20
  12b680:	ebff5ea3 	bl	103114 <rt_kprintf>
  12b684:	e30013ff 	movw	r1, #1023	; 0x3ff
  12b688:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12b68c:	e3400014 	movt	r0, #20
  12b690:	ebff7e79 	bl	10b07c <sys_arch_assert>
  12b694:	ea0000aa 	b	12b944 <dhcp_bind+0x2e8>
  dhcp = netif_dhcp_data(netif);
  12b698:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12b69c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12b6a0:	e50b300c 	str	r3, [fp, #-12]
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  12b6a4:	e51b300c 	ldr	r3, [fp, #-12]
  12b6a8:	e3530000 	cmp	r3, #0
  12b6ac:	1a000007 	bne	12b6d0 <dhcp_bind+0x74>
  12b6b0:	e3090094 	movw	r0, #37012	; 0x9094
  12b6b4:	e3400014 	movt	r0, #20
  12b6b8:	ebff5e95 	bl	103114 <rt_kprintf>
  12b6bc:	e3001401 	movw	r1, #1025	; 0x401
  12b6c0:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12b6c4:	e3400014 	movt	r0, #20
  12b6c8:	ebff7e6b 	bl	10b07c <sys_arch_assert>
  12b6cc:	ea00009c 	b	12b944 <dhcp_bind+0x2e8>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* reset time used of lease */
  dhcp->lease_used = 0;
  12b6d0:	e51b300c 	ldr	r3, [fp, #-12]
  12b6d4:	e3a02000 	mov	r2, #0
  12b6d8:	e1c322b0 	strh	r2, [r3, #32]

  if (dhcp->offered_t0_lease != 0xffffffffUL) {
  12b6dc:	e51b300c 	ldr	r3, [fp, #-12]
  12b6e0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  12b6e4:	e3730001 	cmn	r3, #1
  12b6e8:	0a000017 	beq	12b74c <dhcp_bind+0xf0>
     /* set renewal period timer */
     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t0 renewal timer %"U32_F" secs\n", dhcp->offered_t0_lease));
     timeout = (dhcp->offered_t0_lease + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  12b6ec:	e51b300c 	ldr	r3, [fp, #-12]
  12b6f0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  12b6f4:	e283201e 	add	r2, r3, #30
  12b6f8:	e3083889 	movw	r3, #34953	; 0x8889
  12b6fc:	e3483888 	movt	r3, #34952	; 0x8888
  12b700:	e0832392 	umull	r2, r3, r2, r3
  12b704:	e1a032a3 	lsr	r3, r3, #5
  12b708:	e50b3008 	str	r3, [fp, #-8]
     if (timeout > 0xffff) {
  12b70c:	e51b3008 	ldr	r3, [fp, #-8]
  12b710:	e3530801 	cmp	r3, #65536	; 0x10000
  12b714:	3a000001 	bcc	12b720 <dhcp_bind+0xc4>
       timeout = 0xffff;
  12b718:	e30f3fff 	movw	r3, #65535	; 0xffff
  12b71c:	e50b3008 	str	r3, [fp, #-8]
     }
     dhcp->t0_timeout = (u16_t)timeout;
  12b720:	e51b3008 	ldr	r3, [fp, #-8]
  12b724:	e6ff2073 	uxth	r2, r3
  12b728:	e51b300c 	ldr	r3, [fp, #-12]
  12b72c:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
     if (dhcp->t0_timeout == 0) {
  12b730:	e51b300c 	ldr	r3, [fp, #-12]
  12b734:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
  12b738:	e3530000 	cmp	r3, #0
  12b73c:	1a000002 	bne	12b74c <dhcp_bind+0xf0>
       dhcp->t0_timeout = 1;
  12b740:	e51b300c 	ldr	r3, [fp, #-12]
  12b744:	e3a02001 	mov	r2, #1
  12b748:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
     }
     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t0_lease*1000));
  }

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  12b74c:	e51b300c 	ldr	r3, [fp, #-12]
  12b750:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  12b754:	e3730001 	cmn	r3, #1
  12b758:	0a00001b 	beq	12b7cc <dhcp_bind+0x170>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  12b75c:	e51b300c 	ldr	r3, [fp, #-12]
  12b760:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  12b764:	e283201e 	add	r2, r3, #30
  12b768:	e3083889 	movw	r3, #34953	; 0x8889
  12b76c:	e3483888 	movt	r3, #34952	; 0x8888
  12b770:	e0832392 	umull	r2, r3, r2, r3
  12b774:	e1a032a3 	lsr	r3, r3, #5
  12b778:	e50b3008 	str	r3, [fp, #-8]
    if (timeout > 0xffff) {
  12b77c:	e51b3008 	ldr	r3, [fp, #-8]
  12b780:	e3530801 	cmp	r3, #65536	; 0x10000
  12b784:	3a000001 	bcc	12b790 <dhcp_bind+0x134>
      timeout = 0xffff;
  12b788:	e30f3fff 	movw	r3, #65535	; 0xffff
  12b78c:	e50b3008 	str	r3, [fp, #-8]
    }
    dhcp->t1_timeout = (u16_t)timeout;
  12b790:	e51b3008 	ldr	r3, [fp, #-8]
  12b794:	e6ff2073 	uxth	r2, r3
  12b798:	e51b300c 	ldr	r3, [fp, #-12]
  12b79c:	e1c321b8 	strh	r2, [r3, #24]
    if (dhcp->t1_timeout == 0) {
  12b7a0:	e51b300c 	ldr	r3, [fp, #-12]
  12b7a4:	e1d331b8 	ldrh	r3, [r3, #24]
  12b7a8:	e3530000 	cmp	r3, #0
  12b7ac:	1a000002 	bne	12b7bc <dhcp_bind+0x160>
      dhcp->t1_timeout = 1;
  12b7b0:	e51b300c 	ldr	r3, [fp, #-12]
  12b7b4:	e3a02001 	mov	r2, #1
  12b7b8:	e1c321b8 	strh	r2, [r3, #24]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
    dhcp->t1_renew_time = dhcp->t1_timeout;
  12b7bc:	e51b300c 	ldr	r3, [fp, #-12]
  12b7c0:	e1d321b8 	ldrh	r2, [r3, #24]
  12b7c4:	e51b300c 	ldr	r3, [fp, #-12]
  12b7c8:	e1c321bc 	strh	r2, [r3, #28]
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  12b7cc:	e51b300c 	ldr	r3, [fp, #-12]
  12b7d0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  12b7d4:	e3730001 	cmn	r3, #1
  12b7d8:	0a00001b 	beq	12b84c <dhcp_bind+0x1f0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  12b7dc:	e51b300c 	ldr	r3, [fp, #-12]
  12b7e0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
  12b7e4:	e283201e 	add	r2, r3, #30
  12b7e8:	e3083889 	movw	r3, #34953	; 0x8889
  12b7ec:	e3483888 	movt	r3, #34952	; 0x8888
  12b7f0:	e0832392 	umull	r2, r3, r2, r3
  12b7f4:	e1a032a3 	lsr	r3, r3, #5
  12b7f8:	e50b3008 	str	r3, [fp, #-8]
    if (timeout > 0xffff) {
  12b7fc:	e51b3008 	ldr	r3, [fp, #-8]
  12b800:	e3530801 	cmp	r3, #65536	; 0x10000
  12b804:	3a000001 	bcc	12b810 <dhcp_bind+0x1b4>
      timeout = 0xffff;
  12b808:	e30f3fff 	movw	r3, #65535	; 0xffff
  12b80c:	e50b3008 	str	r3, [fp, #-8]
    }
    dhcp->t2_timeout = (u16_t)timeout;
  12b810:	e51b3008 	ldr	r3, [fp, #-8]
  12b814:	e6ff2073 	uxth	r2, r3
  12b818:	e51b300c 	ldr	r3, [fp, #-12]
  12b81c:	e1c321ba 	strh	r2, [r3, #26]
    if (dhcp->t2_timeout == 0) {
  12b820:	e51b300c 	ldr	r3, [fp, #-12]
  12b824:	e1d331ba 	ldrh	r3, [r3, #26]
  12b828:	e3530000 	cmp	r3, #0
  12b82c:	1a000002 	bne	12b83c <dhcp_bind+0x1e0>
      dhcp->t2_timeout = 1;
  12b830:	e51b300c 	ldr	r3, [fp, #-12]
  12b834:	e3a02001 	mov	r2, #1
  12b838:	e1c321ba 	strh	r2, [r3, #26]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
    dhcp->t2_rebind_time = dhcp->t2_timeout;
  12b83c:	e51b300c 	ldr	r3, [fp, #-12]
  12b840:	e1d321ba 	ldrh	r2, [r3, #26]
  12b844:	e51b300c 	ldr	r3, [fp, #-12]
  12b848:	e1c321be 	strh	r2, [r3, #30]
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
  12b84c:	e51b300c 	ldr	r3, [fp, #-12]
  12b850:	e1d321b8 	ldrh	r2, [r3, #24]
  12b854:	e51b300c 	ldr	r3, [fp, #-12]
  12b858:	e1d331ba 	ldrh	r3, [r3, #26]
  12b85c:	e1520003 	cmp	r2, r3
  12b860:	3a000006 	bcc	12b880 <dhcp_bind+0x224>
  12b864:	e51b300c 	ldr	r3, [fp, #-12]
  12b868:	e1d331ba 	ldrh	r3, [r3, #26]
  12b86c:	e3530000 	cmp	r3, #0
  12b870:	0a000002 	beq	12b880 <dhcp_bind+0x224>
    dhcp->t1_timeout = 0;
  12b874:	e51b300c 	ldr	r3, [fp, #-12]
  12b878:	e3a02000 	mov	r2, #0
  12b87c:	e1c321b8 	strh	r2, [r3, #24]
  }

  if (dhcp->subnet_mask_given) {
  12b880:	e51b300c 	ldr	r3, [fp, #-12]
  12b884:	e5d3300b 	ldrb	r3, [r3, #11]
  12b888:	e3530000 	cmp	r3, #0
  12b88c:	0a000003 	beq	12b8a0 <dhcp_bind+0x244>
    /* copy offered network mask */
    ip4_addr_copy(sn_mask, dhcp->offered_sn_mask);
  12b890:	e51b300c 	ldr	r3, [fp, #-12]
  12b894:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  12b898:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  12b89c:	ea000011 	b	12b8e8 <dhcp_bind+0x28c>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
  12b8a0:	e51b300c 	ldr	r3, [fp, #-12]
  12b8a4:	e2833028 	add	r3, r3, #40	; 0x28
  12b8a8:	e5d33000 	ldrb	r3, [r3]
  12b8ac:	e54b300d 	strb	r3, [fp, #-13]
    if (first_octet <= 127) {
  12b8b0:	e15b30dd 	ldrsb	r3, [fp, #-13]
  12b8b4:	e3530000 	cmp	r3, #0
  12b8b8:	ba000002 	blt	12b8c8 <dhcp_bind+0x26c>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
  12b8bc:	e3a030ff 	mov	r3, #255	; 0xff
  12b8c0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  12b8c4:	ea000007 	b	12b8e8 <dhcp_bind+0x28c>
    } else if (first_octet >= 192) {
  12b8c8:	e55b300d 	ldrb	r3, [fp, #-13]
  12b8cc:	e35300bf 	cmp	r3, #191	; 0xbf
  12b8d0:	9a000002 	bls	12b8e0 <dhcp_bind+0x284>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
  12b8d4:	e3e034ff 	mvn	r3, #-16777216	; 0xff000000
  12b8d8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  12b8dc:	ea000001 	b	12b8e8 <dhcp_bind+0x28c>
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
  12b8e0:	e30f3fff 	movw	r3, #65535	; 0xffff
  12b8e4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    }
  }

  ip4_addr_copy(gw_addr, dhcp->offered_gw_addr);
  12b8e8:	e51b300c 	ldr	r3, [fp, #-12]
  12b8ec:	e5933030 	ldr	r3, [r3, #48]	; 0x30
  12b8f0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  /* gateway address not given? */
  if (ip4_addr_isany_val(gw_addr)) {
  12b8f4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12b8f8:	e3530000 	cmp	r3, #0
  12b8fc:	1a000007 	bne	12b920 <dhcp_bind+0x2c4>
    /* copy network address */
    ip4_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
  12b900:	e51b300c 	ldr	r3, [fp, #-12]
  12b904:	e5932028 	ldr	r2, [r3, #40]	; 0x28
  12b908:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12b90c:	e0033002 	and	r3, r3, r2
  12b910:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
  12b914:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12b918:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
  12b91c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F" SN: 0x%08"X32_F" GW: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&dhcp->offered_ip_addr), ip4_addr_get_u32(&sn_mask), ip4_addr_get_u32(&gw_addr)));
  /* netif is now bound to DHCP leased address - set this before assigning the address
     to ensure the callback can use dhcp_supplied_address() */
  dhcp_set_state(dhcp, DHCP_STATE_BOUND);
  12b920:	e3a0100a 	mov	r1, #10
  12b924:	e51b000c 	ldr	r0, [fp, #-12]
  12b928:	eb000215 	bl	12c184 <dhcp_set_state>

  netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
  12b92c:	e51b300c 	ldr	r3, [fp, #-12]
  12b930:	e2831028 	add	r1, r3, #40	; 0x28
  12b934:	e24b3018 	sub	r3, fp, #24
  12b938:	e24b2014 	sub	r2, fp, #20
  12b93c:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  12b940:	ebffb76d 	bl	1196fc <netif_set_addr>
  /* interface is used by routing now that an address is set */
}
  12b944:	e24bd004 	sub	sp, fp, #4
  12b948:	e8bd8800 	pop	{fp, pc}

0012b94c <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  12b94c:	e92d4800 	push	{fp, lr}
  12b950:	e28db004 	add	fp, sp, #4
  12b954:	e24dd020 	sub	sp, sp, #32
  12b958:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12b95c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12b960:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12b964:	e50b300c 	str	r3, [fp, #-12]
  err_t result;
  u16_t msecs;
  u8_t i;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_RENEWING);
  12b968:	e3a01005 	mov	r1, #5
  12b96c:	e51b000c 	ldr	r0, [fp, #-12]
  12b970:	eb000203 	bl	12c184 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  12b974:	e3a02003 	mov	r2, #3
  12b978:	e51b100c 	ldr	r1, [fp, #-12]
  12b97c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12b980:	eb00062f 	bl	12d244 <dhcp_create_msg>
  12b984:	e1a03000 	mov	r3, r0
  12b988:	e54b300d 	strb	r3, [fp, #-13]
  if (result == ERR_OK) {
  12b98c:	e15b30dd 	ldrsb	r3, [fp, #-13]
  12b990:	e3530000 	cmp	r3, #0
  12b994:	1a000037 	bne	12ba78 <dhcp_renew+0x12c>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  12b998:	e3a02002 	mov	r2, #2
  12b99c:	e3a01039 	mov	r1, #57	; 0x39
  12b9a0:	e51b000c 	ldr	r0, [fp, #-12]
  12b9a4:	eb00020e 	bl	12c1e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
  12b9a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12b9ac:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  12b9b0:	e1a01003 	mov	r1, r3
  12b9b4:	e51b000c 	ldr	r0, [fp, #-12]
  12b9b8:	eb000258 	bl	12c320 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
  12b9bc:	e3a02004 	mov	r2, #4
  12b9c0:	e3a01037 	mov	r1, #55	; 0x37
  12b9c4:	e51b000c 	ldr	r0, [fp, #-12]
  12b9c8:	eb000205 	bl	12c1e4 <dhcp_option>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12b9cc:	e3a03000 	mov	r3, #0
  12b9d0:	e54b3005 	strb	r3, [fp, #-5]
  12b9d4:	ea000009 	b	12ba00 <dhcp_renew+0xb4>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
  12b9d8:	e55b2005 	ldrb	r2, [fp, #-5]
  12b9dc:	e30e303c 	movw	r3, #57404	; 0xe03c
  12b9e0:	e3403014 	movt	r3, #20
  12b9e4:	e7d33002 	ldrb	r3, [r3, r2]
  12b9e8:	e1a01003 	mov	r1, r3
  12b9ec:	e51b000c 	ldr	r0, [fp, #-12]
  12b9f0:	eb00022b 	bl	12c2a4 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12b9f4:	e55b3005 	ldrb	r3, [fp, #-5]
  12b9f8:	e2833001 	add	r3, r3, #1
  12b9fc:	e54b3005 	strb	r3, [fp, #-5]
  12ba00:	e55b3005 	ldrb	r3, [fp, #-5]
  12ba04:	e3530003 	cmp	r3, #3
  12ba08:	9afffff2 	bls	12b9d8 <dhcp_renew+0x8c>
    }

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
  12ba0c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  12ba10:	e51b000c 	ldr	r0, [fp, #-12]
  12ba14:	eb0002bd 	bl	12c510 <dhcp_option_hostname>
#endif /* LWIP_NETIF_HOSTNAME */

    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  12ba18:	e51b000c 	ldr	r0, [fp, #-12]
  12ba1c:	eb000775 	bl	12d7f8 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  12ba20:	e51b300c 	ldr	r3, [fp, #-12]
  12ba24:	e593200c 	ldr	r2, [r3, #12]
  12ba28:	e51b300c 	ldr	r3, [fp, #-12]
  12ba2c:	e1d331b4 	ldrh	r3, [r3, #20]
  12ba30:	e28330f0 	add	r3, r3, #240	; 0xf0
  12ba34:	e6ff3073 	uxth	r3, r3
  12ba38:	e1a01003 	mov	r1, r3
  12ba3c:	e1a00002 	mov	r0, r2
  12ba40:	ebffbc52 	bl	11ab90 <pbuf_realloc>

    udp_sendto_if(dhcp_pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  12ba44:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12ba48:	e3403014 	movt	r3, #20
  12ba4c:	e5930000 	ldr	r0, [r3]
  12ba50:	e51b300c 	ldr	r3, [fp, #-12]
  12ba54:	e593100c 	ldr	r1, [r3, #12]
  12ba58:	e51b300c 	ldr	r3, [fp, #-12]
  12ba5c:	e2832024 	add	r2, r3, #36	; 0x24
  12ba60:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12ba64:	e58d3000 	str	r3, [sp]
  12ba68:	e3a03043 	mov	r3, #67	; 0x43
  12ba6c:	ebfff26e 	bl	12842c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
  12ba70:	e51b000c 	ldr	r0, [fp, #-12]
  12ba74:	eb00072a 	bl	12d724 <dhcp_delete_msg>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  if (dhcp->tries < 255) {
  12ba78:	e51b300c 	ldr	r3, [fp, #-12]
  12ba7c:	e5d3300a 	ldrb	r3, [r3, #10]
  12ba80:	e35300ff 	cmp	r3, #255	; 0xff
  12ba84:	0a000005 	beq	12baa0 <dhcp_renew+0x154>
    dhcp->tries++;
  12ba88:	e51b300c 	ldr	r3, [fp, #-12]
  12ba8c:	e5d3300a 	ldrb	r3, [r3, #10]
  12ba90:	e2833001 	add	r3, r3, #1
  12ba94:	e6ef2073 	uxtb	r2, r3
  12ba98:	e51b300c 	ldr	r3, [fp, #-12]
  12ba9c:	e5c3200a 	strb	r2, [r3, #10]
  }
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  12baa0:	e51b300c 	ldr	r3, [fp, #-12]
  12baa4:	e5d3300a 	ldrb	r3, [r3, #10]
  12baa8:	e3530009 	cmp	r3, #9
  12baac:	8a00000a 	bhi	12badc <dhcp_renew+0x190>
  12bab0:	e51b300c 	ldr	r3, [fp, #-12]
  12bab4:	e5d3300a 	ldrb	r3, [r3, #10]
  12bab8:	e6ff3073 	uxth	r3, r3
  12babc:	e1a02003 	mov	r2, r3
  12bac0:	e1a02282 	lsl	r2, r2, #5
  12bac4:	e0422003 	sub	r2, r2, r3
  12bac8:	e1a02102 	lsl	r2, r2, #2
  12bacc:	e0823003 	add	r3, r2, r3
  12bad0:	e1a03203 	lsl	r3, r3, #4
  12bad4:	e6ff3073 	uxth	r3, r3
  12bad8:	ea000000 	b	12bae0 <dhcp_renew+0x194>
  12badc:	e3043e20 	movw	r3, #20000	; 0x4e20
  12bae0:	e14b31b0 	strh	r3, [fp, #-16]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  12bae4:	e15b31b0 	ldrh	r3, [fp, #-16]
  12bae8:	e2833e1f 	add	r3, r3, #496	; 0x1f0
  12baec:	e2833003 	add	r3, r3, #3
  12baf0:	e3042dd3 	movw	r2, #19923	; 0x4dd3
  12baf4:	e3412062 	movt	r2, #4194	; 0x1062
  12baf8:	e0c10293 	smull	r0, r1, r3, r2
  12bafc:	e1a022c1 	asr	r2, r1, #5
  12bb00:	e1a03fc3 	asr	r3, r3, #31
  12bb04:	e0423003 	sub	r3, r2, r3
  12bb08:	e6ff2073 	uxth	r2, r3
  12bb0c:	e51b300c 	ldr	r3, [fp, #-12]
  12bb10:	e1c321b6 	strh	r2, [r3, #22]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  12bb14:	e15b30dd 	ldrsb	r3, [fp, #-13]
}
  12bb18:	e1a00003 	mov	r0, r3
  12bb1c:	e24bd004 	sub	sp, fp, #4
  12bb20:	e8bd8800 	pop	{fp, pc}

0012bb24 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  12bb24:	e92d4800 	push	{fp, lr}
  12bb28:	e28db004 	add	fp, sp, #4
  12bb2c:	e24dd020 	sub	sp, sp, #32
  12bb30:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12bb34:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12bb38:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12bb3c:	e50b300c 	str	r3, [fp, #-12]
  err_t result;
  u16_t msecs;
  u8_t i;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_REBINDING);
  12bb40:	e3a01004 	mov	r1, #4
  12bb44:	e51b000c 	ldr	r0, [fp, #-12]
  12bb48:	eb00018d 	bl	12c184 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  12bb4c:	e3a02003 	mov	r2, #3
  12bb50:	e51b100c 	ldr	r1, [fp, #-12]
  12bb54:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12bb58:	eb0005b9 	bl	12d244 <dhcp_create_msg>
  12bb5c:	e1a03000 	mov	r3, r0
  12bb60:	e54b300d 	strb	r3, [fp, #-13]
  if (result == ERR_OK) {
  12bb64:	e15b30dd 	ldrsb	r3, [fp, #-13]
  12bb68:	e3530000 	cmp	r3, #0
  12bb6c:	1a000037 	bne	12bc50 <dhcp_rebind+0x12c>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  12bb70:	e3a02002 	mov	r2, #2
  12bb74:	e3a01039 	mov	r1, #57	; 0x39
  12bb78:	e51b000c 	ldr	r0, [fp, #-12]
  12bb7c:	eb000198 	bl	12c1e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
  12bb80:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12bb84:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  12bb88:	e1a01003 	mov	r1, r3
  12bb8c:	e51b000c 	ldr	r0, [fp, #-12]
  12bb90:	eb0001e2 	bl	12c320 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
  12bb94:	e3a02004 	mov	r2, #4
  12bb98:	e3a01037 	mov	r1, #55	; 0x37
  12bb9c:	e51b000c 	ldr	r0, [fp, #-12]
  12bba0:	eb00018f 	bl	12c1e4 <dhcp_option>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12bba4:	e3a03000 	mov	r3, #0
  12bba8:	e54b3005 	strb	r3, [fp, #-5]
  12bbac:	ea000009 	b	12bbd8 <dhcp_rebind+0xb4>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
  12bbb0:	e55b2005 	ldrb	r2, [fp, #-5]
  12bbb4:	e30e303c 	movw	r3, #57404	; 0xe03c
  12bbb8:	e3403014 	movt	r3, #20
  12bbbc:	e7d33002 	ldrb	r3, [r3, r2]
  12bbc0:	e1a01003 	mov	r1, r3
  12bbc4:	e51b000c 	ldr	r0, [fp, #-12]
  12bbc8:	eb0001b5 	bl	12c2a4 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12bbcc:	e55b3005 	ldrb	r3, [fp, #-5]
  12bbd0:	e2833001 	add	r3, r3, #1
  12bbd4:	e54b3005 	strb	r3, [fp, #-5]
  12bbd8:	e55b3005 	ldrb	r3, [fp, #-5]
  12bbdc:	e3530003 	cmp	r3, #3
  12bbe0:	9afffff2 	bls	12bbb0 <dhcp_rebind+0x8c>
    }

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
  12bbe4:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  12bbe8:	e51b000c 	ldr	r0, [fp, #-12]
  12bbec:	eb000247 	bl	12c510 <dhcp_option_hostname>
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  12bbf0:	e51b000c 	ldr	r0, [fp, #-12]
  12bbf4:	eb0006ff 	bl	12d7f8 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  12bbf8:	e51b300c 	ldr	r3, [fp, #-12]
  12bbfc:	e593200c 	ldr	r2, [r3, #12]
  12bc00:	e51b300c 	ldr	r3, [fp, #-12]
  12bc04:	e1d331b4 	ldrh	r3, [r3, #20]
  12bc08:	e28330f0 	add	r3, r3, #240	; 0xf0
  12bc0c:	e6ff3073 	uxth	r3, r3
  12bc10:	e1a01003 	mov	r1, r3
  12bc14:	e1a00002 	mov	r0, r2
  12bc18:	ebffbbdc 	bl	11ab90 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  12bc1c:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12bc20:	e3403014 	movt	r3, #20
  12bc24:	e5930000 	ldr	r0, [r3]
  12bc28:	e51b300c 	ldr	r3, [fp, #-12]
  12bc2c:	e593100c 	ldr	r1, [r3, #12]
  12bc30:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12bc34:	e58d3000 	str	r3, [sp]
  12bc38:	e3a03043 	mov	r3, #67	; 0x43
  12bc3c:	e3092b28 	movw	r2, #39720	; 0x9b28
  12bc40:	e3402014 	movt	r2, #20
  12bc44:	ebfff1f8 	bl	12842c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
  12bc48:	e51b000c 	ldr	r0, [fp, #-12]
  12bc4c:	eb0006b4 	bl	12d724 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  if (dhcp->tries < 255) {
  12bc50:	e51b300c 	ldr	r3, [fp, #-12]
  12bc54:	e5d3300a 	ldrb	r3, [r3, #10]
  12bc58:	e35300ff 	cmp	r3, #255	; 0xff
  12bc5c:	0a000005 	beq	12bc78 <dhcp_rebind+0x154>
    dhcp->tries++;
  12bc60:	e51b300c 	ldr	r3, [fp, #-12]
  12bc64:	e5d3300a 	ldrb	r3, [r3, #10]
  12bc68:	e2833001 	add	r3, r3, #1
  12bc6c:	e6ef2073 	uxtb	r2, r3
  12bc70:	e51b300c 	ldr	r3, [fp, #-12]
  12bc74:	e5c3200a 	strb	r2, [r3, #10]
  }
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  12bc78:	e51b300c 	ldr	r3, [fp, #-12]
  12bc7c:	e5d3300a 	ldrb	r3, [r3, #10]
  12bc80:	e3530009 	cmp	r3, #9
  12bc84:	8a00000a 	bhi	12bcb4 <dhcp_rebind+0x190>
  12bc88:	e51b300c 	ldr	r3, [fp, #-12]
  12bc8c:	e5d3300a 	ldrb	r3, [r3, #10]
  12bc90:	e6ff3073 	uxth	r3, r3
  12bc94:	e1a02003 	mov	r2, r3
  12bc98:	e1a02282 	lsl	r2, r2, #5
  12bc9c:	e0422003 	sub	r2, r2, r3
  12bca0:	e1a02102 	lsl	r2, r2, #2
  12bca4:	e0823003 	add	r3, r2, r3
  12bca8:	e1a03183 	lsl	r3, r3, #3
  12bcac:	e6ff3073 	uxth	r3, r3
  12bcb0:	ea000000 	b	12bcb8 <dhcp_rebind+0x194>
  12bcb4:	e3023710 	movw	r3, #10000	; 0x2710
  12bcb8:	e14b31b0 	strh	r3, [fp, #-16]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  12bcbc:	e15b31b0 	ldrh	r3, [fp, #-16]
  12bcc0:	e2833e1f 	add	r3, r3, #496	; 0x1f0
  12bcc4:	e2833003 	add	r3, r3, #3
  12bcc8:	e3042dd3 	movw	r2, #19923	; 0x4dd3
  12bccc:	e3412062 	movt	r2, #4194	; 0x1062
  12bcd0:	e0c10293 	smull	r0, r1, r3, r2
  12bcd4:	e1a022c1 	asr	r2, r1, #5
  12bcd8:	e1a03fc3 	asr	r3, r3, #31
  12bcdc:	e0423003 	sub	r3, r2, r3
  12bce0:	e6ff2073 	uxth	r2, r3
  12bce4:	e51b300c 	ldr	r3, [fp, #-12]
  12bce8:	e1c321b6 	strh	r2, [r3, #22]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  12bcec:	e15b30dd 	ldrsb	r3, [fp, #-13]
}
  12bcf0:	e1a00003 	mov	r0, r3
  12bcf4:	e24bd004 	sub	sp, fp, #4
  12bcf8:	e8bd8800 	pop	{fp, pc}

0012bcfc <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
  12bcfc:	e92d4800 	push	{fp, lr}
  12bd00:	e28db004 	add	fp, sp, #4
  12bd04:	e24dd020 	sub	sp, sp, #32
  12bd08:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12bd0c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12bd10:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12bd14:	e50b300c 	str	r3, [fp, #-12]
  err_t result;
  u16_t msecs;
  u8_t i;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_REBOOTING);
  12bd18:	e3a01003 	mov	r1, #3
  12bd1c:	e51b000c 	ldr	r0, [fp, #-12]
  12bd20:	eb000117 	bl	12c184 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  12bd24:	e3a02003 	mov	r2, #3
  12bd28:	e51b100c 	ldr	r1, [fp, #-12]
  12bd2c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12bd30:	eb000543 	bl	12d244 <dhcp_create_msg>
  12bd34:	e1a03000 	mov	r3, r0
  12bd38:	e54b300d 	strb	r3, [fp, #-13]
  if (result == ERR_OK) {
  12bd3c:	e15b30dd 	ldrsb	r3, [fp, #-13]
  12bd40:	e3530000 	cmp	r3, #0
  12bd44:	1a00003e 	bne	12be44 <dhcp_reboot+0x148>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  12bd48:	e3a02002 	mov	r2, #2
  12bd4c:	e3a01039 	mov	r1, #57	; 0x39
  12bd50:	e51b000c 	ldr	r0, [fp, #-12]
  12bd54:	eb000122 	bl	12c1e4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN_MIN_REQUIRED);
  12bd58:	e3a01d09 	mov	r1, #576	; 0x240
  12bd5c:	e51b000c 	ldr	r0, [fp, #-12]
  12bd60:	eb00016e 	bl	12c320 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  12bd64:	e3a02004 	mov	r2, #4
  12bd68:	e3a01032 	mov	r1, #50	; 0x32
  12bd6c:	e51b000c 	ldr	r0, [fp, #-12]
  12bd70:	eb00011b 	bl	12c1e4 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  12bd74:	e51b300c 	ldr	r3, [fp, #-12]
  12bd78:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12bd7c:	e1a00003 	mov	r0, r3
  12bd80:	ebffaaa0 	bl	116808 <lwip_htonl>
  12bd84:	e1a03000 	mov	r3, r0
  12bd88:	e1a01003 	mov	r1, r3
  12bd8c:	e51b000c 	ldr	r0, [fp, #-12]
  12bd90:	eb000193 	bl	12c3e4 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
  12bd94:	e3a02004 	mov	r2, #4
  12bd98:	e3a01037 	mov	r1, #55	; 0x37
  12bd9c:	e51b000c 	ldr	r0, [fp, #-12]
  12bda0:	eb00010f 	bl	12c1e4 <dhcp_option>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12bda4:	e3a03000 	mov	r3, #0
  12bda8:	e54b3005 	strb	r3, [fp, #-5]
  12bdac:	ea000009 	b	12bdd8 <dhcp_reboot+0xdc>
      dhcp_option_byte(dhcp, dhcp_discover_request_options[i]);
  12bdb0:	e55b2005 	ldrb	r2, [fp, #-5]
  12bdb4:	e30e303c 	movw	r3, #57404	; 0xe03c
  12bdb8:	e3403014 	movt	r3, #20
  12bdbc:	e7d33002 	ldrb	r3, [r3, r2]
  12bdc0:	e1a01003 	mov	r1, r3
  12bdc4:	e51b000c 	ldr	r0, [fp, #-12]
  12bdc8:	eb000135 	bl	12c2a4 <dhcp_option_byte>
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
  12bdcc:	e55b3005 	ldrb	r3, [fp, #-5]
  12bdd0:	e2833001 	add	r3, r3, #1
  12bdd4:	e54b3005 	strb	r3, [fp, #-5]
  12bdd8:	e55b3005 	ldrb	r3, [fp, #-5]
  12bddc:	e3530003 	cmp	r3, #3
  12bde0:	9afffff2 	bls	12bdb0 <dhcp_reboot+0xb4>
    }

    dhcp_option_trailer(dhcp);
  12bde4:	e51b000c 	ldr	r0, [fp, #-12]
  12bde8:	eb000682 	bl	12d7f8 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  12bdec:	e51b300c 	ldr	r3, [fp, #-12]
  12bdf0:	e593200c 	ldr	r2, [r3, #12]
  12bdf4:	e51b300c 	ldr	r3, [fp, #-12]
  12bdf8:	e1d331b4 	ldrh	r3, [r3, #20]
  12bdfc:	e28330f0 	add	r3, r3, #240	; 0xf0
  12be00:	e6ff3073 	uxth	r3, r3
  12be04:	e1a01003 	mov	r1, r3
  12be08:	e1a00002 	mov	r0, r2
  12be0c:	ebffbb5f 	bl	11ab90 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp_pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  12be10:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12be14:	e3403014 	movt	r3, #20
  12be18:	e5930000 	ldr	r0, [r3]
  12be1c:	e51b300c 	ldr	r3, [fp, #-12]
  12be20:	e593100c 	ldr	r1, [r3, #12]
  12be24:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12be28:	e58d3000 	str	r3, [sp]
  12be2c:	e3a03043 	mov	r3, #67	; 0x43
  12be30:	e3092b28 	movw	r2, #39720	; 0x9b28
  12be34:	e3402014 	movt	r2, #20
  12be38:	ebfff17b 	bl	12842c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
  12be3c:	e51b000c 	ldr	r0, [fp, #-12]
  12be40:	eb000637 	bl	12d724 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  if (dhcp->tries < 255) {
  12be44:	e51b300c 	ldr	r3, [fp, #-12]
  12be48:	e5d3300a 	ldrb	r3, [r3, #10]
  12be4c:	e35300ff 	cmp	r3, #255	; 0xff
  12be50:	0a000005 	beq	12be6c <dhcp_reboot+0x170>
    dhcp->tries++;
  12be54:	e51b300c 	ldr	r3, [fp, #-12]
  12be58:	e5d3300a 	ldrb	r3, [r3, #10]
  12be5c:	e2833001 	add	r3, r3, #1
  12be60:	e6ef2073 	uxtb	r2, r3
  12be64:	e51b300c 	ldr	r3, [fp, #-12]
  12be68:	e5c3200a 	strb	r2, [r3, #10]
  }
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  12be6c:	e51b300c 	ldr	r3, [fp, #-12]
  12be70:	e5d3300a 	ldrb	r3, [r3, #10]
  12be74:	e3530009 	cmp	r3, #9
  12be78:	8a00000a 	bhi	12bea8 <dhcp_reboot+0x1ac>
  12be7c:	e51b300c 	ldr	r3, [fp, #-12]
  12be80:	e5d3300a 	ldrb	r3, [r3, #10]
  12be84:	e6ff3073 	uxth	r3, r3
  12be88:	e1a02003 	mov	r2, r3
  12be8c:	e1a02282 	lsl	r2, r2, #5
  12be90:	e0422003 	sub	r2, r2, r3
  12be94:	e1a02102 	lsl	r2, r2, #2
  12be98:	e0823003 	add	r3, r2, r3
  12be9c:	e1a03183 	lsl	r3, r3, #3
  12bea0:	e6ff3073 	uxth	r3, r3
  12bea4:	ea000000 	b	12beac <dhcp_reboot+0x1b0>
  12bea8:	e3023710 	movw	r3, #10000	; 0x2710
  12beac:	e14b31b0 	strh	r3, [fp, #-16]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  12beb0:	e15b31b0 	ldrh	r3, [fp, #-16]
  12beb4:	e2833e1f 	add	r3, r3, #496	; 0x1f0
  12beb8:	e2833003 	add	r3, r3, #3
  12bebc:	e3042dd3 	movw	r2, #19923	; 0x4dd3
  12bec0:	e3412062 	movt	r2, #4194	; 0x1062
  12bec4:	e0c10293 	smull	r0, r1, r3, r2
  12bec8:	e1a022c1 	asr	r2, r1, #5
  12becc:	e1a03fc3 	asr	r3, r3, #31
  12bed0:	e0423003 	sub	r3, r2, r3
  12bed4:	e6ff2073 	uxth	r2, r3
  12bed8:	e51b300c 	ldr	r3, [fp, #-12]
  12bedc:	e1c321b6 	strh	r2, [r3, #22]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  12bee0:	e15b30dd 	ldrsb	r3, [fp, #-13]
}
  12bee4:	e1a00003 	mov	r0, r3
  12bee8:	e24bd004 	sub	sp, fp, #4
  12beec:	e8bd8800 	pop	{fp, pc}

0012bef0 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  12bef0:	e92d4800 	push	{fp, lr}
  12bef4:	e28db004 	add	fp, sp, #4
  12bef8:	e24dd020 	sub	sp, sp, #32
  12befc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12bf00:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12bf04:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12bf08:	e50b3008 	str	r3, [fp, #-8]
  err_t result;
  ip_addr_t server_ip_addr;
  u8_t is_dhcp_supplied_address;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));
  if (dhcp == NULL) {
  12bf0c:	e51b3008 	ldr	r3, [fp, #-8]
  12bf10:	e3530000 	cmp	r3, #0
  12bf14:	1a000001 	bne	12bf20 <dhcp_release+0x30>
    return ERR_ARG;
  12bf18:	e3e0300f 	mvn	r3, #15
  12bf1c:	ea000068 	b	12c0c4 <dhcp_release+0x1d4>
  }
  ip_addr_copy(server_ip_addr, dhcp->server_ip_addr);
  12bf20:	e51b3008 	ldr	r3, [fp, #-8]
  12bf24:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  12bf28:	e50b3010 	str	r3, [fp, #-16]

  is_dhcp_supplied_address = dhcp_supplied_address(netif);
  12bf2c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12bf30:	eb00067b 	bl	12d924 <dhcp_supplied_address>
  12bf34:	e1a03000 	mov	r3, r0
  12bf38:	e54b3009 	strb	r3, [fp, #-9]

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_STATE_OFF);
  12bf3c:	e3a01000 	mov	r1, #0
  12bf40:	e51b0008 	ldr	r0, [fp, #-8]
  12bf44:	eb00008e 	bl	12c184 <dhcp_set_state>
  /* clean old DHCP offer */
  ip_addr_set_zero_ip4(&dhcp->server_ip_addr);
  12bf48:	e51b3008 	ldr	r3, [fp, #-8]
  12bf4c:	e3a02000 	mov	r2, #0
  12bf50:	e5832024 	str	r2, [r3, #36]	; 0x24
  ip4_addr_set_zero(&dhcp->offered_ip_addr);
  12bf54:	e51b3008 	ldr	r3, [fp, #-8]
  12bf58:	e3a02000 	mov	r2, #0
  12bf5c:	e5832028 	str	r2, [r3, #40]	; 0x28
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
  12bf60:	e51b3008 	ldr	r3, [fp, #-8]
  12bf64:	e3a02000 	mov	r2, #0
  12bf68:	e583202c 	str	r2, [r3, #44]	; 0x2c
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
  12bf6c:	e51b3008 	ldr	r3, [fp, #-8]
  12bf70:	e3a02000 	mov	r2, #0
  12bf74:	e5832030 	str	r2, [r3, #48]	; 0x30
#if LWIP_DHCP_BOOTP_FILE
  ip4_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  12bf78:	e51b3008 	ldr	r3, [fp, #-8]
  12bf7c:	e3a02000 	mov	r2, #0
  12bf80:	e583203c 	str	r2, [r3, #60]	; 0x3c
  12bf84:	e51b3008 	ldr	r3, [fp, #-8]
  12bf88:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
  12bf8c:	e51b3008 	ldr	r3, [fp, #-8]
  12bf90:	e5832038 	str	r2, [r3, #56]	; 0x38
  12bf94:	e51b3008 	ldr	r3, [fp, #-8]
  12bf98:	e5932038 	ldr	r2, [r3, #56]	; 0x38
  12bf9c:	e51b3008 	ldr	r3, [fp, #-8]
  12bfa0:	e5832034 	str	r2, [r3, #52]	; 0x34
  dhcp->t1_renew_time = dhcp->t2_rebind_time = dhcp->lease_used = dhcp->t0_timeout = 0;
  12bfa4:	e51b3008 	ldr	r3, [fp, #-8]
  12bfa8:	e3a02000 	mov	r2, #0
  12bfac:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
  12bfb0:	e51b3008 	ldr	r3, [fp, #-8]
  12bfb4:	e1d322b2 	ldrh	r2, [r3, #34]	; 0x22
  12bfb8:	e51b3008 	ldr	r3, [fp, #-8]
  12bfbc:	e1c322b0 	strh	r2, [r3, #32]
  12bfc0:	e51b3008 	ldr	r3, [fp, #-8]
  12bfc4:	e1d322b0 	ldrh	r2, [r3, #32]
  12bfc8:	e51b3008 	ldr	r3, [fp, #-8]
  12bfcc:	e1c321be 	strh	r2, [r3, #30]
  12bfd0:	e51b3008 	ldr	r3, [fp, #-8]
  12bfd4:	e1d321be 	ldrh	r2, [r3, #30]
  12bfd8:	e51b3008 	ldr	r3, [fp, #-8]
  12bfdc:	e1c321bc 	strh	r2, [r3, #28]

  if (!is_dhcp_supplied_address) {
  12bfe0:	e55b3009 	ldrb	r3, [fp, #-9]
  12bfe4:	e3530000 	cmp	r3, #0
  12bfe8:	1a000001 	bne	12bff4 <dhcp_release+0x104>
    /* don't issue release message when address is not dhcp-assigned */
    return ERR_OK;
  12bfec:	e3a03000 	mov	r3, #0
  12bff0:	ea000033 	b	12c0c4 <dhcp_release+0x1d4>
  }

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
  12bff4:	e3a02007 	mov	r2, #7
  12bff8:	e51b1008 	ldr	r1, [fp, #-8]
  12bffc:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12c000:	eb00048f 	bl	12d244 <dhcp_create_msg>
  12c004:	e1a03000 	mov	r3, r0
  12c008:	e54b300a 	strb	r3, [fp, #-10]
  if (result == ERR_OK) {
  12c00c:	e15b30da 	ldrsb	r3, [fp, #-10]
  12c010:	e3530000 	cmp	r3, #0
  12c014:	1a000021 	bne	12c0a0 <dhcp_release+0x1b0>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  12c018:	e3a02004 	mov	r2, #4
  12c01c:	e3a01036 	mov	r1, #54	; 0x36
  12c020:	e51b0008 	ldr	r0, [fp, #-8]
  12c024:	eb00006e 	bl	12c1e4 <dhcp_option>
    dhcp_option_long(dhcp, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&server_ip_addr))));
  12c028:	e51b3010 	ldr	r3, [fp, #-16]
  12c02c:	e1a00003 	mov	r0, r3
  12c030:	ebffa9f4 	bl	116808 <lwip_htonl>
  12c034:	e1a03000 	mov	r3, r0
  12c038:	e1a01003 	mov	r1, r3
  12c03c:	e51b0008 	ldr	r0, [fp, #-8]
  12c040:	eb0000e7 	bl	12c3e4 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  12c044:	e51b0008 	ldr	r0, [fp, #-8]
  12c048:	eb0005ea 	bl	12d7f8 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  12c04c:	e51b3008 	ldr	r3, [fp, #-8]
  12c050:	e593200c 	ldr	r2, [r3, #12]
  12c054:	e51b3008 	ldr	r3, [fp, #-8]
  12c058:	e1d331b4 	ldrh	r3, [r3, #20]
  12c05c:	e28330f0 	add	r3, r3, #240	; 0xf0
  12c060:	e6ff3073 	uxth	r3, r3
  12c064:	e1a01003 	mov	r1, r3
  12c068:	e1a00002 	mov	r0, r2
  12c06c:	ebffbac7 	bl	11ab90 <pbuf_realloc>

    udp_sendto_if(dhcp_pcb, dhcp->p_out, &server_ip_addr, DHCP_SERVER_PORT, netif);
  12c070:	e30f3ac8 	movw	r3, #64200	; 0xfac8
  12c074:	e3403014 	movt	r3, #20
  12c078:	e5930000 	ldr	r0, [r3]
  12c07c:	e51b3008 	ldr	r3, [fp, #-8]
  12c080:	e593100c 	ldr	r1, [r3, #12]
  12c084:	e24b2010 	sub	r2, fp, #16
  12c088:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12c08c:	e58d3000 	str	r3, [sp]
  12c090:	e3a03043 	mov	r3, #67	; 0x43
  12c094:	ebfff0e4 	bl	12842c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
  12c098:	e51b0008 	ldr	r0, [fp, #-8]
  12c09c:	eb0005a0 	bl	12d724 <dhcp_delete_msg>
  } else {
    /* sending release failed, but that's not a problem since the correct behaviour of dhcp does not rely on release */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  /* remove IP address from interface (prevents routing from selecting this interface) */
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
  12c0a0:	e3093b24 	movw	r3, #39716	; 0x9b24
  12c0a4:	e3403014 	movt	r3, #20
  12c0a8:	e3092b24 	movw	r2, #39716	; 0x9b24
  12c0ac:	e3402014 	movt	r2, #20
  12c0b0:	e3091b24 	movw	r1, #39716	; 0x9b24
  12c0b4:	e3401014 	movt	r1, #20
  12c0b8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12c0bc:	ebffb58e 	bl	1196fc <netif_set_addr>

  return result;
  12c0c0:	e15b30da 	ldrsb	r3, [fp, #-10]
}
  12c0c4:	e1a00003 	mov	r0, r3
  12c0c8:	e24bd004 	sub	sp, fp, #4
  12c0cc:	e8bd8800 	pop	{fp, pc}

0012c0d0 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  12c0d0:	e92d4800 	push	{fp, lr}
  12c0d4:	e28db004 	add	fp, sp, #4
  12c0d8:	e24dd010 	sub	sp, sp, #16
  12c0dc:	e50b0010 	str	r0, [fp, #-16]
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  12c0e0:	e51b3010 	ldr	r3, [fp, #-16]
  12c0e4:	e3530000 	cmp	r3, #0
  12c0e8:	1a000007 	bne	12c10c <dhcp_stop+0x3c>
  12c0ec:	e30900ac 	movw	r0, #37036	; 0x90ac
  12c0f0:	e3400014 	movt	r0, #20
  12c0f4:	ebff5c06 	bl	103114 <rt_kprintf>
  12c0f8:	e3001543 	movw	r1, #1347	; 0x543
  12c0fc:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c100:	e3400014 	movt	r0, #20
  12c104:	ebff7bdc 	bl	10b07c <sys_arch_assert>
  12c108:	ea00001b 	b	12c17c <dhcp_stop+0xac>
  dhcp = netif_dhcp_data(netif);
  12c10c:	e51b3010 	ldr	r3, [fp, #-16]
  12c110:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12c114:	e50b3008 	str	r3, [fp, #-8]

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  12c118:	e51b3008 	ldr	r3, [fp, #-8]
  12c11c:	e3530000 	cmp	r3, #0
  12c120:	0a000015 	beq	12c17c <dhcp_stop+0xac>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
  12c124:	e51b3008 	ldr	r3, [fp, #-8]
  12c128:	e5933004 	ldr	r3, [r3, #4]
  12c12c:	e3530000 	cmp	r3, #0
  12c130:	0a000006 	beq	12c150 <dhcp_stop+0x80>
  12c134:	e3090064 	movw	r0, #36964	; 0x9064
  12c138:	e3400014 	movt	r0, #20
  12c13c:	ebff5bf4 	bl	103114 <rt_kprintf>
  12c140:	e3a01e55 	mov	r1, #1360	; 0x550
  12c144:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c148:	e3400014 	movt	r0, #20
  12c14c:	ebff7bca 	bl	10b07c <sys_arch_assert>
    dhcp_set_state(dhcp, DHCP_STATE_OFF);
  12c150:	e3a01000 	mov	r1, #0
  12c154:	e51b0008 	ldr	r0, [fp, #-8]
  12c158:	eb000009 	bl	12c184 <dhcp_set_state>

    if (dhcp->pcb_allocated != 0) {
  12c15c:	e51b3008 	ldr	r3, [fp, #-8]
  12c160:	e5d33008 	ldrb	r3, [r3, #8]
  12c164:	e3530000 	cmp	r3, #0
  12c168:	0a000003 	beq	12c17c <dhcp_stop+0xac>
      dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
  12c16c:	ebfff868 	bl	12a314 <dhcp_dec_pcb_refcount>
      dhcp->pcb_allocated = 0;
  12c170:	e51b3008 	ldr	r3, [fp, #-8]
  12c174:	e3a02000 	mov	r2, #0
  12c178:	e5c32008 	strb	r2, [r3, #8]
    }
  }
}
  12c17c:	e24bd004 	sub	sp, fp, #4
  12c180:	e8bd8800 	pop	{fp, pc}

0012c184 <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  12c184:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  12c188:	e28db000 	add	fp, sp, #0
  12c18c:	e24dd00c 	sub	sp, sp, #12
  12c190:	e50b0008 	str	r0, [fp, #-8]
  12c194:	e1a03001 	mov	r3, r1
  12c198:	e54b3009 	strb	r3, [fp, #-9]
  if (new_state != dhcp->state) {
  12c19c:	e51b3008 	ldr	r3, [fp, #-8]
  12c1a0:	e5d33009 	ldrb	r3, [r3, #9]
  12c1a4:	e55b2009 	ldrb	r2, [fp, #-9]
  12c1a8:	e1520003 	cmp	r2, r3
  12c1ac:	0a000008 	beq	12c1d4 <dhcp_set_state+0x50>
    dhcp->state = new_state;
  12c1b0:	e51b3008 	ldr	r3, [fp, #-8]
  12c1b4:	e55b2009 	ldrb	r2, [fp, #-9]
  12c1b8:	e5c32009 	strb	r2, [r3, #9]
    dhcp->tries = 0;
  12c1bc:	e51b3008 	ldr	r3, [fp, #-8]
  12c1c0:	e3a02000 	mov	r2, #0
  12c1c4:	e5c3200a 	strb	r2, [r3, #10]
    dhcp->request_timeout = 0;
  12c1c8:	e51b3008 	ldr	r3, [fp, #-8]
  12c1cc:	e3a02000 	mov	r2, #0
  12c1d0:	e1c321b6 	strh	r2, [r3, #22]
  }
}
  12c1d4:	e320f000 	nop	{0}
  12c1d8:	e28bd000 	add	sp, fp, #0
  12c1dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  12c1e0:	e12fff1e 	bx	lr

0012c1e4 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  12c1e4:	e92d4800 	push	{fp, lr}
  12c1e8:	e28db004 	add	fp, sp, #4
  12c1ec:	e24dd008 	sub	sp, sp, #8
  12c1f0:	e50b0008 	str	r0, [fp, #-8]
  12c1f4:	e1a03001 	mov	r3, r1
  12c1f8:	e54b3009 	strb	r3, [fp, #-9]
  12c1fc:	e1a03002 	mov	r3, r2
  12c200:	e54b300a 	strb	r3, [fp, #-10]
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  12c204:	e51b3008 	ldr	r3, [fp, #-8]
  12c208:	e1d331b4 	ldrh	r3, [r3, #20]
  12c20c:	e1a02003 	mov	r2, r3
  12c210:	e55b300a 	ldrb	r3, [fp, #-10]
  12c214:	e0823003 	add	r3, r2, r3
  12c218:	e2833002 	add	r3, r3, #2
  12c21c:	e3530044 	cmp	r3, #68	; 0x44
  12c220:	9a000006 	bls	12c240 <dhcp_option+0x5c>
  12c224:	e30900c8 	movw	r0, #37064	; 0x90c8
  12c228:	e3400014 	movt	r0, #20
  12c22c:	ebff5bb8 	bl	103114 <rt_kprintf>
  12c230:	e3001571 	movw	r1, #1393	; 0x571
  12c234:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c238:	e3400014 	movt	r0, #20
  12c23c:	ebff7b8e 	bl	10b07c <sys_arch_assert>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  12c240:	e51b3008 	ldr	r3, [fp, #-8]
  12c244:	e5932010 	ldr	r2, [r3, #16]
  12c248:	e51b3008 	ldr	r3, [fp, #-8]
  12c24c:	e1d331b4 	ldrh	r3, [r3, #20]
  12c250:	e2831001 	add	r1, r3, #1
  12c254:	e6ff0071 	uxth	r0, r1
  12c258:	e51b1008 	ldr	r1, [fp, #-8]
  12c25c:	e1c101b4 	strh	r0, [r1, #20]
  12c260:	e0823003 	add	r3, r2, r3
  12c264:	e55b2009 	ldrb	r2, [fp, #-9]
  12c268:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  12c26c:	e51b3008 	ldr	r3, [fp, #-8]
  12c270:	e5932010 	ldr	r2, [r3, #16]
  12c274:	e51b3008 	ldr	r3, [fp, #-8]
  12c278:	e1d331b4 	ldrh	r3, [r3, #20]
  12c27c:	e2831001 	add	r1, r3, #1
  12c280:	e6ff0071 	uxth	r0, r1
  12c284:	e51b1008 	ldr	r1, [fp, #-8]
  12c288:	e1c101b4 	strh	r0, [r1, #20]
  12c28c:	e0823003 	add	r3, r2, r3
  12c290:	e55b200a 	ldrb	r2, [fp, #-10]
  12c294:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
}
  12c298:	e320f000 	nop	{0}
  12c29c:	e24bd004 	sub	sp, fp, #4
  12c2a0:	e8bd8800 	pop	{fp, pc}

0012c2a4 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  12c2a4:	e92d4800 	push	{fp, lr}
  12c2a8:	e28db004 	add	fp, sp, #4
  12c2ac:	e24dd008 	sub	sp, sp, #8
  12c2b0:	e50b0008 	str	r0, [fp, #-8]
  12c2b4:	e1a03001 	mov	r3, r1
  12c2b8:	e54b3009 	strb	r3, [fp, #-9]
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  12c2bc:	e51b3008 	ldr	r3, [fp, #-8]
  12c2c0:	e1d331b4 	ldrh	r3, [r3, #20]
  12c2c4:	e3530043 	cmp	r3, #67	; 0x43
  12c2c8:	9a000006 	bls	12c2e8 <dhcp_option_byte+0x44>
  12c2cc:	e3090110 	movw	r0, #37136	; 0x9110
  12c2d0:	e3400014 	movt	r0, #20
  12c2d4:	ebff5b8e 	bl	103114 <rt_kprintf>
  12c2d8:	e300157c 	movw	r1, #1404	; 0x57c
  12c2dc:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c2e0:	e3400014 	movt	r0, #20
  12c2e4:	ebff7b64 	bl	10b07c <sys_arch_assert>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  12c2e8:	e51b3008 	ldr	r3, [fp, #-8]
  12c2ec:	e5932010 	ldr	r2, [r3, #16]
  12c2f0:	e51b3008 	ldr	r3, [fp, #-8]
  12c2f4:	e1d331b4 	ldrh	r3, [r3, #20]
  12c2f8:	e2831001 	add	r1, r3, #1
  12c2fc:	e6ff0071 	uxth	r0, r1
  12c300:	e51b1008 	ldr	r1, [fp, #-8]
  12c304:	e1c101b4 	strh	r0, [r1, #20]
  12c308:	e0823003 	add	r3, r2, r3
  12c30c:	e55b2009 	ldrb	r2, [fp, #-9]
  12c310:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
}
  12c314:	e320f000 	nop	{0}
  12c318:	e24bd004 	sub	sp, fp, #4
  12c31c:	e8bd8800 	pop	{fp, pc}

0012c320 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  12c320:	e92d4800 	push	{fp, lr}
  12c324:	e28db004 	add	fp, sp, #4
  12c328:	e24dd008 	sub	sp, sp, #8
  12c32c:	e50b0008 	str	r0, [fp, #-8]
  12c330:	e1a03001 	mov	r3, r1
  12c334:	e14b30ba 	strh	r3, [fp, #-10]
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  12c338:	e51b3008 	ldr	r3, [fp, #-8]
  12c33c:	e1d331b4 	ldrh	r3, [r3, #20]
  12c340:	e2833002 	add	r3, r3, #2
  12c344:	e3530044 	cmp	r3, #68	; 0x44
  12c348:	9a000006 	bls	12c368 <dhcp_option_short+0x48>
  12c34c:	e309014c 	movw	r0, #37196	; 0x914c
  12c350:	e3400014 	movt	r0, #20
  12c354:	ebff5b6e 	bl	103114 <rt_kprintf>
  12c358:	e3001583 	movw	r1, #1411	; 0x583
  12c35c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c360:	e3400014 	movt	r0, #20
  12c364:	ebff7b44 	bl	10b07c <sys_arch_assert>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  12c368:	e15b30ba 	ldrh	r3, [fp, #-10]
  12c36c:	e1a03423 	lsr	r3, r3, #8
  12c370:	e6ffc073 	uxth	ip, r3
  12c374:	e51b3008 	ldr	r3, [fp, #-8]
  12c378:	e5932010 	ldr	r2, [r3, #16]
  12c37c:	e51b3008 	ldr	r3, [fp, #-8]
  12c380:	e1d331b4 	ldrh	r3, [r3, #20]
  12c384:	e2831001 	add	r1, r3, #1
  12c388:	e6ff0071 	uxth	r0, r1
  12c38c:	e51b1008 	ldr	r1, [fp, #-8]
  12c390:	e1c101b4 	strh	r0, [r1, #20]
  12c394:	e6ef107c 	uxtb	r1, ip
  12c398:	e0823003 	add	r3, r2, r3
  12c39c:	e1a02001 	mov	r2, r1
  12c3a0:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  12c3a4:	e51b3008 	ldr	r3, [fp, #-8]
  12c3a8:	e5932010 	ldr	r2, [r3, #16]
  12c3ac:	e51b3008 	ldr	r3, [fp, #-8]
  12c3b0:	e1d331b4 	ldrh	r3, [r3, #20]
  12c3b4:	e2831001 	add	r1, r3, #1
  12c3b8:	e6ff0071 	uxth	r0, r1
  12c3bc:	e51b1008 	ldr	r1, [fp, #-8]
  12c3c0:	e1c101b4 	strh	r0, [r1, #20]
  12c3c4:	e15b10ba 	ldrh	r1, [fp, #-10]
  12c3c8:	e6ef1071 	uxtb	r1, r1
  12c3cc:	e0823003 	add	r3, r2, r3
  12c3d0:	e1a02001 	mov	r2, r1
  12c3d4:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
}
  12c3d8:	e320f000 	nop	{0}
  12c3dc:	e24bd004 	sub	sp, fp, #4
  12c3e0:	e8bd8800 	pop	{fp, pc}

0012c3e4 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  12c3e4:	e92d4800 	push	{fp, lr}
  12c3e8:	e28db004 	add	fp, sp, #4
  12c3ec:	e24dd008 	sub	sp, sp, #8
  12c3f0:	e50b0008 	str	r0, [fp, #-8]
  12c3f4:	e50b100c 	str	r1, [fp, #-12]
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  12c3f8:	e51b3008 	ldr	r3, [fp, #-8]
  12c3fc:	e1d331b4 	ldrh	r3, [r3, #20]
  12c400:	e2833004 	add	r3, r3, #4
  12c404:	e3530044 	cmp	r3, #68	; 0x44
  12c408:	9a000006 	bls	12c428 <dhcp_option_long+0x44>
  12c40c:	e3090190 	movw	r0, #37264	; 0x9190
  12c410:	e3400014 	movt	r0, #20
  12c414:	ebff5b3e 	bl	103114 <rt_kprintf>
  12c418:	e300158b 	movw	r1, #1419	; 0x58b
  12c41c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c420:	e3400014 	movt	r0, #20
  12c424:	ebff7b14 	bl	10b07c <sys_arch_assert>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  12c428:	e51b300c 	ldr	r3, [fp, #-12]
  12c42c:	e1a0cc23 	lsr	ip, r3, #24
  12c430:	e51b3008 	ldr	r3, [fp, #-8]
  12c434:	e5932010 	ldr	r2, [r3, #16]
  12c438:	e51b3008 	ldr	r3, [fp, #-8]
  12c43c:	e1d331b4 	ldrh	r3, [r3, #20]
  12c440:	e2831001 	add	r1, r3, #1
  12c444:	e6ff0071 	uxth	r0, r1
  12c448:	e51b1008 	ldr	r1, [fp, #-8]
  12c44c:	e1c101b4 	strh	r0, [r1, #20]
  12c450:	e6ef107c 	uxtb	r1, ip
  12c454:	e0823003 	add	r3, r2, r3
  12c458:	e1a02001 	mov	r2, r1
  12c45c:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  12c460:	e51b300c 	ldr	r3, [fp, #-12]
  12c464:	e1a0c823 	lsr	ip, r3, #16
  12c468:	e51b3008 	ldr	r3, [fp, #-8]
  12c46c:	e5932010 	ldr	r2, [r3, #16]
  12c470:	e51b3008 	ldr	r3, [fp, #-8]
  12c474:	e1d331b4 	ldrh	r3, [r3, #20]
  12c478:	e2831001 	add	r1, r3, #1
  12c47c:	e6ff0071 	uxth	r0, r1
  12c480:	e51b1008 	ldr	r1, [fp, #-8]
  12c484:	e1c101b4 	strh	r0, [r1, #20]
  12c488:	e6ef107c 	uxtb	r1, ip
  12c48c:	e0823003 	add	r3, r2, r3
  12c490:	e1a02001 	mov	r2, r1
  12c494:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  12c498:	e51b300c 	ldr	r3, [fp, #-12]
  12c49c:	e1a0c423 	lsr	ip, r3, #8
  12c4a0:	e51b3008 	ldr	r3, [fp, #-8]
  12c4a4:	e5932010 	ldr	r2, [r3, #16]
  12c4a8:	e51b3008 	ldr	r3, [fp, #-8]
  12c4ac:	e1d331b4 	ldrh	r3, [r3, #20]
  12c4b0:	e2831001 	add	r1, r3, #1
  12c4b4:	e6ff0071 	uxth	r0, r1
  12c4b8:	e51b1008 	ldr	r1, [fp, #-8]
  12c4bc:	e1c101b4 	strh	r0, [r1, #20]
  12c4c0:	e6ef107c 	uxtb	r1, ip
  12c4c4:	e0823003 	add	r3, r2, r3
  12c4c8:	e1a02001 	mov	r2, r1
  12c4cc:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  12c4d0:	e51b3008 	ldr	r3, [fp, #-8]
  12c4d4:	e5932010 	ldr	r2, [r3, #16]
  12c4d8:	e51b3008 	ldr	r3, [fp, #-8]
  12c4dc:	e1d331b4 	ldrh	r3, [r3, #20]
  12c4e0:	e2831001 	add	r1, r3, #1
  12c4e4:	e6ff0071 	uxth	r0, r1
  12c4e8:	e51b1008 	ldr	r1, [fp, #-8]
  12c4ec:	e1c101b4 	strh	r0, [r1, #20]
  12c4f0:	e51b100c 	ldr	r1, [fp, #-12]
  12c4f4:	e6ef1071 	uxtb	r1, r1
  12c4f8:	e0823003 	add	r3, r2, r3
  12c4fc:	e1a02001 	mov	r2, r1
  12c500:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
}
  12c504:	e320f000 	nop	{0}
  12c508:	e24bd004 	sub	sp, fp, #4
  12c50c:	e8bd8800 	pop	{fp, pc}

0012c510 <dhcp_option_hostname>:

#if LWIP_NETIF_HOSTNAME
static void
dhcp_option_hostname(struct dhcp *dhcp, struct netif *netif)
{
  12c510:	e92d4800 	push	{fp, lr}
  12c514:	e28db004 	add	fp, sp, #4
  12c518:	e24dd018 	sub	sp, sp, #24
  12c51c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12c520:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  if (netif->hostname != NULL) {
  12c524:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12c528:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  12c52c:	e3530000 	cmp	r3, #0
  12c530:	0a00003c 	beq	12c628 <dhcp_option_hostname+0x118>
    size_t namelen = strlen(netif->hostname);
  12c534:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12c538:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  12c53c:	e1a00003 	mov	r0, r3
  12c540:	eb00545c 	bl	1416b8 <strlen>
  12c544:	e50b0010 	str	r0, [fp, #-16]
    if (namelen > 0) {
  12c548:	e51b3010 	ldr	r3, [fp, #-16]
  12c54c:	e3530000 	cmp	r3, #0
  12c550:	0a000034 	beq	12c628 <dhcp_option_hostname+0x118>
      size_t len;
      const char *p = netif->hostname;
  12c554:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12c558:	e5933034 	ldr	r3, [r3, #52]	; 0x34
  12c55c:	e50b300c 	str	r3, [fp, #-12]
      /* Shrink len to available bytes (need 2 bytes for OPTION_HOSTNAME
         and 1 byte for trailer) */
      size_t available = DHCP_OPTIONS_LEN - dhcp->options_out_len - 3;
  12c560:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12c564:	e1d331b4 	ldrh	r3, [r3, #20]
  12c568:	e2633041 	rsb	r3, r3, #65	; 0x41
  12c56c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
  12c570:	e51b2010 	ldr	r2, [fp, #-16]
  12c574:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c578:	e1520003 	cmp	r2, r3
  12c57c:	9a000006 	bls	12c59c <dhcp_option_hostname+0x8c>
  12c580:	e30901d0 	movw	r0, #37328	; 0x91d0
  12c584:	e3400014 	movt	r0, #20
  12c588:	ebff5ae1 	bl	103114 <rt_kprintf>
  12c58c:	e300159e 	movw	r1, #1438	; 0x59e
  12c590:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c594:	e3400014 	movt	r0, #20
  12c598:	ebff7ab7 	bl	10b07c <sys_arch_assert>
      len = LWIP_MIN(namelen, available);
  12c59c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  12c5a0:	e51b3010 	ldr	r3, [fp, #-16]
  12c5a4:	e1520003 	cmp	r2, r3
  12c5a8:	31a03002 	movcc	r3, r2
  12c5ac:	21a03003 	movcs	r3, r3
  12c5b0:	e50b3008 	str	r3, [fp, #-8]
      LWIP_ASSERT("DHCP: hostname is too long!", len <= 0xFF);
  12c5b4:	e51b3008 	ldr	r3, [fp, #-8]
  12c5b8:	e35300ff 	cmp	r3, #255	; 0xff
  12c5bc:	9a000006 	bls	12c5dc <dhcp_option_hostname+0xcc>
  12c5c0:	e30901d0 	movw	r0, #37328	; 0x91d0
  12c5c4:	e3400014 	movt	r0, #20
  12c5c8:	ebff5ad1 	bl	103114 <rt_kprintf>
  12c5cc:	e3a01e5a 	mov	r1, #1440	; 0x5a0
  12c5d0:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c5d4:	e3400014 	movt	r0, #20
  12c5d8:	ebff7aa7 	bl	10b07c <sys_arch_assert>
      dhcp_option(dhcp, DHCP_OPTION_HOSTNAME, (u8_t)len);
  12c5dc:	e51b3008 	ldr	r3, [fp, #-8]
  12c5e0:	e6ef3073 	uxtb	r3, r3
  12c5e4:	e1a02003 	mov	r2, r3
  12c5e8:	e3a0100c 	mov	r1, #12
  12c5ec:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12c5f0:	ebfffefb 	bl	12c1e4 <dhcp_option>
      while (len--) {
  12c5f4:	ea000006 	b	12c614 <dhcp_option_hostname+0x104>
        dhcp_option_byte(dhcp, *p++);
  12c5f8:	e51b300c 	ldr	r3, [fp, #-12]
  12c5fc:	e2832001 	add	r2, r3, #1
  12c600:	e50b200c 	str	r2, [fp, #-12]
  12c604:	e5d33000 	ldrb	r3, [r3]
  12c608:	e1a01003 	mov	r1, r3
  12c60c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12c610:	ebffff23 	bl	12c2a4 <dhcp_option_byte>
      while (len--) {
  12c614:	e51b3008 	ldr	r3, [fp, #-8]
  12c618:	e2432001 	sub	r2, r3, #1
  12c61c:	e50b2008 	str	r2, [fp, #-8]
  12c620:	e3530000 	cmp	r3, #0
  12c624:	1afffff3 	bne	12c5f8 <dhcp_option_hostname+0xe8>
      }
    }
  }
}
  12c628:	e320f000 	nop	{0}
  12c62c:	e24bd004 	sub	sp, fp, #4
  12c630:	e8bd8800 	pop	{fp, pc}

0012c634 <dhcp_parse_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_parse_reply(struct dhcp *dhcp, struct pbuf *p)
{
  12c634:	e92d4800 	push	{fp, lr}
  12c638:	e28db004 	add	fp, sp, #4
  12c63c:	e24dd038 	sub	sp, sp, #56	; 0x38
  12c640:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
  12c644:	e50b103c 	str	r1, [fp, #-60]	; 0xffffffc4
  u16_t offset;
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
  12c648:	e3a03000 	mov	r3, #0
  12c64c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  int parse_sname_as_options = 0;
  12c650:	e3a03000 	mov	r3, #0
  12c654:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

  /* clear received options */
  dhcp_clear_all_options(dhcp);
  12c658:	e3a0200a 	mov	r2, #10
  12c65c:	e3a01000 	mov	r1, #0
  12c660:	e3060a4c 	movw	r0, #27212	; 0x6a4c
  12c664:	e3400057 	movt	r0, #87	; 0x57
  12c668:	eb005381 	bl	141474 <memset>
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
  12c66c:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  12c670:	e1d330ba 	ldrh	r3, [r3, #10]
  12c674:	e353002b 	cmp	r3, #43	; 0x2b
  12c678:	8a000001 	bhi	12c684 <dhcp_parse_reply+0x50>
    return ERR_BUF;
  12c67c:	e3e03001 	mvn	r3, #1
  12c680:	ea00022e 	b	12cf40 <dhcp_parse_reply+0x90c>
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;
  12c684:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  12c688:	e5932004 	ldr	r2, [r3, #4]
  12c68c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  12c690:	e5832004 	str	r2, [r3, #4]
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
  12c694:	e3a030f0 	mov	r3, #240	; 0xf0
  12c698:	e14b30be 	strh	r3, [fp, #-14]
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
  12c69c:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  12c6a0:	e1d330b8 	ldrh	r3, [r3, #8]
  12c6a4:	e14b31b0 	strh	r3, [fp, #-16]
again:
  q = p;
  12c6a8:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  12c6ac:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  while ((q != NULL) && (options_idx >= q->len)) {
  12c6b0:	ea00000c 	b	12c6e8 <dhcp_parse_reply+0xb4>
    options_idx -= q->len;
  12c6b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c6b8:	e1d330ba 	ldrh	r3, [r3, #10]
  12c6bc:	e15b20be 	ldrh	r2, [fp, #-14]
  12c6c0:	e0423003 	sub	r3, r2, r3
  12c6c4:	e14b30be 	strh	r3, [fp, #-14]
    options_idx_max -= q->len;
  12c6c8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c6cc:	e1d330ba 	ldrh	r3, [r3, #10]
  12c6d0:	e15b21b0 	ldrh	r2, [fp, #-16]
  12c6d4:	e0423003 	sub	r3, r2, r3
  12c6d8:	e14b31b0 	strh	r3, [fp, #-16]
    q = q->next;
  12c6dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c6e0:	e5933000 	ldr	r3, [r3]
  12c6e4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  while ((q != NULL) && (options_idx >= q->len)) {
  12c6e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c6ec:	e3530000 	cmp	r3, #0
  12c6f0:	0a000004 	beq	12c708 <dhcp_parse_reply+0xd4>
  12c6f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c6f8:	e1d330ba 	ldrh	r3, [r3, #10]
  12c6fc:	e15b20be 	ldrh	r2, [fp, #-14]
  12c700:	e1520003 	cmp	r2, r3
  12c704:	2affffea 	bcs	12c6b4 <dhcp_parse_reply+0x80>
  }
  if (q == NULL) {
  12c708:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c70c:	e3530000 	cmp	r3, #0
  12c710:	1a000001 	bne	12c71c <dhcp_parse_reply+0xe8>
    return ERR_BUF;
  12c714:	e3e03001 	mvn	r3, #1
  12c718:	ea000208 	b	12cf40 <dhcp_parse_reply+0x90c>
  }
  offset = options_idx;
  12c71c:	e15b30be 	ldrh	r3, [fp, #-14]
  12c720:	e14b30ba 	strh	r3, [fp, #-10]
  offset_max = options_idx_max;
  12c724:	e15b31b0 	ldrh	r3, [fp, #-16]
  12c728:	e14b30bc 	strh	r3, [fp, #-12]
  options = (u8_t*)q->payload;
  12c72c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c730:	e5933004 	ldr	r3, [r3, #4]
  12c734:	e50b3008 	str	r3, [fp, #-8]
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
  12c738:	ea0001be 	b	12ce38 <dhcp_parse_reply+0x804>
    u8_t op = options[offset];
  12c73c:	e15b30ba 	ldrh	r3, [fp, #-10]
  12c740:	e51b2008 	ldr	r2, [fp, #-8]
  12c744:	e0823003 	add	r3, r2, r3
  12c748:	e5d33000 	ldrb	r3, [r3]
  12c74c:	e54b3027 	strb	r3, [fp, #-39]	; 0xffffffd9
    u8_t len;
    u8_t decode_len = 0;
  12c750:	e3a03000 	mov	r3, #0
  12c754:	e54b301e 	strb	r3, [fp, #-30]	; 0xffffffe2
    int decode_idx = -1;
  12c758:	e3e03000 	mvn	r3, #0
  12c75c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    u16_t val_offset = offset + 2;
  12c760:	e15b30ba 	ldrh	r3, [fp, #-10]
  12c764:	e2833002 	add	r3, r3, #2
  12c768:	e14b32b6 	strh	r3, [fp, #-38]	; 0xffffffda
    /* len byte might be in the next pbuf */
    if ((offset + 1) < q->len) {
  12c76c:	e15b30ba 	ldrh	r3, [fp, #-10]
  12c770:	e2833001 	add	r3, r3, #1
  12c774:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  12c778:	e1d220ba 	ldrh	r2, [r2, #10]
  12c77c:	e1530002 	cmp	r3, r2
  12c780:	aa000006 	bge	12c7a0 <dhcp_parse_reply+0x16c>
      len = options[offset + 1];
  12c784:	e15b30ba 	ldrh	r3, [fp, #-10]
  12c788:	e2833001 	add	r3, r3, #1
  12c78c:	e51b2008 	ldr	r2, [fp, #-8]
  12c790:	e0823003 	add	r3, r2, r3
  12c794:	e5d33000 	ldrb	r3, [r3]
  12c798:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
  12c79c:	ea00000a 	b	12c7cc <dhcp_parse_reply+0x198>
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
  12c7a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c7a4:	e5933000 	ldr	r3, [r3]
  12c7a8:	e3530000 	cmp	r3, #0
  12c7ac:	0a000004 	beq	12c7c4 <dhcp_parse_reply+0x190>
  12c7b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12c7b4:	e5933000 	ldr	r3, [r3]
  12c7b8:	e5933004 	ldr	r3, [r3, #4]
  12c7bc:	e5d33000 	ldrb	r3, [r3]
  12c7c0:	ea000000 	b	12c7c8 <dhcp_parse_reply+0x194>
  12c7c4:	e3a03000 	mov	r3, #0
  12c7c8:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
  12c7cc:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12c7d0:	e54b301e 	strb	r3, [fp, #-30]	; 0xffffffe2
    switch(op) {
  12c7d4:	e55b3027 	ldrb	r3, [fp, #-39]	; 0xffffffd9
  12c7d8:	e353003b 	cmp	r3, #59	; 0x3b
  12c7dc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  12c7e0:	ea0000ed 	b	12cb9c <dhcp_parse_reply+0x568>
  12c7e4:	0012c8d4 	.word	0x0012c8d4
  12c7e8:	0012c8f4 	.word	0x0012c8f4
  12c7ec:	0012cb9c 	.word	0x0012cb9c
  12c7f0:	0012c930 	.word	0x0012c930
  12c7f4:	0012cb9c 	.word	0x0012cb9c
  12c7f8:	0012cb9c 	.word	0x0012cb9c
  12c7fc:	0012c978 	.word	0x0012c978
  12c800:	0012cb9c 	.word	0x0012cb9c
  12c804:	0012cb9c 	.word	0x0012cb9c
  12c808:	0012cb9c 	.word	0x0012cb9c
  12c80c:	0012cb9c 	.word	0x0012cb9c
  12c810:	0012cb9c 	.word	0x0012cb9c
  12c814:	0012cb9c 	.word	0x0012cb9c
  12c818:	0012cb9c 	.word	0x0012cb9c
  12c81c:	0012cb9c 	.word	0x0012cb9c
  12c820:	0012cb9c 	.word	0x0012cb9c
  12c824:	0012cb9c 	.word	0x0012cb9c
  12c828:	0012cb9c 	.word	0x0012cb9c
  12c82c:	0012cb9c 	.word	0x0012cb9c
  12c830:	0012cb9c 	.word	0x0012cb9c
  12c834:	0012cb9c 	.word	0x0012cb9c
  12c838:	0012cb9c 	.word	0x0012cb9c
  12c83c:	0012cb9c 	.word	0x0012cb9c
  12c840:	0012cb9c 	.word	0x0012cb9c
  12c844:	0012cb9c 	.word	0x0012cb9c
  12c848:	0012cb9c 	.word	0x0012cb9c
  12c84c:	0012cb9c 	.word	0x0012cb9c
  12c850:	0012cb9c 	.word	0x0012cb9c
  12c854:	0012cb9c 	.word	0x0012cb9c
  12c858:	0012cb9c 	.word	0x0012cb9c
  12c85c:	0012cb9c 	.word	0x0012cb9c
  12c860:	0012cb9c 	.word	0x0012cb9c
  12c864:	0012cb9c 	.word	0x0012cb9c
  12c868:	0012cb9c 	.word	0x0012cb9c
  12c86c:	0012cb9c 	.word	0x0012cb9c
  12c870:	0012cb9c 	.word	0x0012cb9c
  12c874:	0012cb9c 	.word	0x0012cb9c
  12c878:	0012cb9c 	.word	0x0012cb9c
  12c87c:	0012cb9c 	.word	0x0012cb9c
  12c880:	0012cb9c 	.word	0x0012cb9c
  12c884:	0012cb9c 	.word	0x0012cb9c
  12c888:	0012cb9c 	.word	0x0012cb9c
  12c88c:	0012cb9c 	.word	0x0012cb9c
  12c890:	0012cb9c 	.word	0x0012cb9c
  12c894:	0012cb9c 	.word	0x0012cb9c
  12c898:	0012cb9c 	.word	0x0012cb9c
  12c89c:	0012cb9c 	.word	0x0012cb9c
  12c8a0:	0012cb9c 	.word	0x0012cb9c
  12c8a4:	0012cb9c 	.word	0x0012cb9c
  12c8a8:	0012cb9c 	.word	0x0012cb9c
  12c8ac:	0012cb9c 	.word	0x0012cb9c
  12c8b0:	0012ca04 	.word	0x0012ca04
  12c8b4:	0012ca40 	.word	0x0012ca40
  12c8b8:	0012caac 	.word	0x0012caac
  12c8bc:	0012cae8 	.word	0x0012cae8
  12c8c0:	0012cb9c 	.word	0x0012cb9c
  12c8c4:	0012cb9c 	.word	0x0012cb9c
  12c8c8:	0012cb9c 	.word	0x0012cb9c
  12c8cc:	0012cb24 	.word	0x0012cb24
  12c8d0:	0012cb60 	.word	0x0012cb60
      /* case(DHCP_OPTION_END): handled above */
      case(DHCP_OPTION_PAD):
        /* special option: no len encoded */
        decode_len = len = 0;
  12c8d4:	e3a03000 	mov	r3, #0
  12c8d8:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
  12c8dc:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12c8e0:	e54b301e 	strb	r3, [fp, #-30]	; 0xffffffe2
        /* will be increased below */
        offset--;
  12c8e4:	e15b30ba 	ldrh	r3, [fp, #-10]
  12c8e8:	e2433001 	sub	r3, r3, #1
  12c8ec:	e14b30ba 	strh	r3, [fp, #-10]
        break;
  12c8f0:	ea0000ac 	b	12cba8 <dhcp_parse_reply+0x574>
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
  12c8f4:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12c8f8:	e3530004 	cmp	r3, #4
  12c8fc:	0a000008 	beq	12c924 <dhcp_parse_reply+0x2f0>
  12c900:	e30901ec 	movw	r0, #37356	; 0x91ec
  12c904:	e3400014 	movt	r0, #20
  12c908:	ebff5a01 	bl	103114 <rt_kprintf>
  12c90c:	e30015f7 	movw	r1, #1527	; 0x5f7
  12c910:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c914:	e3400014 	movt	r0, #20
  12c918:	ebff79d7 	bl	10b07c <sys_arch_assert>
  12c91c:	e3e03005 	mvn	r3, #5
  12c920:	ea000186 	b	12cf40 <dhcp_parse_reply+0x90c>
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
  12c924:	e3a03006 	mov	r3, #6
  12c928:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        break;
  12c92c:	ea00009d 	b	12cba8 <dhcp_parse_reply+0x574>
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
  12c930:	e3a03004 	mov	r3, #4
  12c934:	e54b301e 	strb	r3, [fp, #-30]	; 0xffffffe2
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
  12c938:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
  12c93c:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
  12c940:	e1520003 	cmp	r2, r3
  12c944:	2a000008 	bcs	12c96c <dhcp_parse_reply+0x338>
  12c948:	e30901f8 	movw	r0, #37368	; 0x91f8
  12c94c:	e3400014 	movt	r0, #20
  12c950:	ebff59ef 	bl	103114 <rt_kprintf>
  12c954:	e30015fc 	movw	r1, #1532	; 0x5fc
  12c958:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c95c:	e3400014 	movt	r0, #20
  12c960:	ebff79c5 	bl	10b07c <sys_arch_assert>
  12c964:	e3e03005 	mvn	r3, #5
  12c968:	ea000174 	b	12cf40 <dhcp_parse_reply+0x90c>
        decode_idx = DHCP_OPTION_IDX_ROUTER;
  12c96c:	e3a03007 	mov	r3, #7
  12c970:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        break;
  12c974:	ea00008b 	b	12cba8 <dhcp_parse_reply+0x574>
#if LWIP_DHCP_PROVIDE_DNS_SERVERS
      case(DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len %% 4 == 0", len % 4 == 0, return ERR_VAL;);
  12c978:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12c97c:	e2033003 	and	r3, r3, #3
  12c980:	e6ef3073 	uxtb	r3, r3
  12c984:	e3530000 	cmp	r3, #0
  12c988:	0a000008 	beq	12c9b0 <dhcp_parse_reply+0x37c>
  12c98c:	e309020c 	movw	r0, #37388	; 0x920c
  12c990:	e3400014 	movt	r0, #20
  12c994:	ebff59de 	bl	103114 <rt_kprintf>
  12c998:	e3001602 	movw	r1, #1538	; 0x602
  12c99c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c9a0:	e3400014 	movt	r0, #20
  12c9a4:	ebff79b4 	bl	10b07c <sys_arch_assert>
  12c9a8:	e3e03005 	mvn	r3, #5
  12c9ac:	ea000163 	b	12cf40 <dhcp_parse_reply+0x90c>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
  12c9b0:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12c9b4:	e3530008 	cmp	r3, #8
  12c9b8:	31a03003 	movcc	r3, r3
  12c9bc:	23a03008 	movcs	r3, #8
  12c9c0:	e54b301e 	strb	r3, [fp, #-30]	; 0xffffffe2
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
  12c9c4:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
  12c9c8:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
  12c9cc:	e1520003 	cmp	r2, r3
  12c9d0:	2a000008 	bcs	12c9f8 <dhcp_parse_reply+0x3c4>
  12c9d4:	e30901f8 	movw	r0, #37368	; 0x91f8
  12c9d8:	e3400014 	movt	r0, #20
  12c9dc:	ebff59cc 	bl	103114 <rt_kprintf>
  12c9e0:	e3001605 	movw	r1, #1541	; 0x605
  12c9e4:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12c9e8:	e3400014 	movt	r0, #20
  12c9ec:	ebff79a2 	bl	10b07c <sys_arch_assert>
  12c9f0:	e3e03005 	mvn	r3, #5
  12c9f4:	ea000151 	b	12cf40 <dhcp_parse_reply+0x90c>
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
  12c9f8:	e3a03008 	mov	r3, #8
  12c9fc:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        break;
  12ca00:	ea000068 	b	12cba8 <dhcp_parse_reply+0x574>
#endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
  12ca04:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12ca08:	e3530004 	cmp	r3, #4
  12ca0c:	0a000008 	beq	12ca34 <dhcp_parse_reply+0x400>
  12ca10:	e30901ec 	movw	r0, #37356	; 0x91ec
  12ca14:	e3400014 	movt	r0, #20
  12ca18:	ebff59bd 	bl	103114 <rt_kprintf>
  12ca1c:	e300160a 	movw	r1, #1546	; 0x60a
  12ca20:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12ca24:	e3400014 	movt	r0, #20
  12ca28:	ebff7993 	bl	10b07c <sys_arch_assert>
  12ca2c:	e3e03005 	mvn	r3, #5
  12ca30:	ea000142 	b	12cf40 <dhcp_parse_reply+0x90c>
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
  12ca34:	e3a03003 	mov	r3, #3
  12ca38:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        break;
  12ca3c:	ea000059 	b	12cba8 <dhcp_parse_reply+0x574>
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_NTP_SERVER;
        break;
#endif /* LWIP_DHCP_GET_NTP_SRV*/
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
  12ca40:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12ca44:	e3530001 	cmp	r3, #1
  12ca48:	0a000008 	beq	12ca70 <dhcp_parse_reply+0x43c>
  12ca4c:	e309021c 	movw	r0, #37404	; 0x921c
  12ca50:	e3400014 	movt	r0, #20
  12ca54:	ebff59ae 	bl	103114 <rt_kprintf>
  12ca58:	e3001618 	movw	r1, #1560	; 0x618
  12ca5c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12ca60:	e3400014 	movt	r0, #20
  12ca64:	ebff7984 	bl	10b07c <sys_arch_assert>
  12ca68:	e3e03005 	mvn	r3, #5
  12ca6c:	ea000133 	b	12cf40 <dhcp_parse_reply+0x90c>
        /* decode overload only in options, not in file/sname: invalid packet */
        LWIP_ERROR("overload in file/sname", options_idx == DHCP_OPTIONS_OFS, return ERR_VAL;);
  12ca70:	e15b30be 	ldrh	r3, [fp, #-14]
  12ca74:	e35300f0 	cmp	r3, #240	; 0xf0
  12ca78:	0a000008 	beq	12caa0 <dhcp_parse_reply+0x46c>
  12ca7c:	e3090228 	movw	r0, #37416	; 0x9228
  12ca80:	e3400014 	movt	r0, #20
  12ca84:	ebff59a2 	bl	103114 <rt_kprintf>
  12ca88:	e300161a 	movw	r1, #1562	; 0x61a
  12ca8c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12ca90:	e3400014 	movt	r0, #20
  12ca94:	ebff7978 	bl	10b07c <sys_arch_assert>
  12ca98:	e3e03005 	mvn	r3, #5
  12ca9c:	ea000127 	b	12cf40 <dhcp_parse_reply+0x90c>
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
  12caa0:	e3a03000 	mov	r3, #0
  12caa4:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        break;
  12caa8:	ea00003e 	b	12cba8 <dhcp_parse_reply+0x574>
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
  12caac:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12cab0:	e3530001 	cmp	r3, #1
  12cab4:	0a000008 	beq	12cadc <dhcp_parse_reply+0x4a8>
  12cab8:	e309021c 	movw	r0, #37404	; 0x921c
  12cabc:	e3400014 	movt	r0, #20
  12cac0:	ebff5993 	bl	103114 <rt_kprintf>
  12cac4:	e300161e 	movw	r1, #1566	; 0x61e
  12cac8:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12cacc:	e3400014 	movt	r0, #20
  12cad0:	ebff7969 	bl	10b07c <sys_arch_assert>
  12cad4:	e3e03005 	mvn	r3, #5
  12cad8:	ea000118 	b	12cf40 <dhcp_parse_reply+0x90c>
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
  12cadc:	e3a03001 	mov	r3, #1
  12cae0:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        break;
  12cae4:	ea00002f 	b	12cba8 <dhcp_parse_reply+0x574>
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
  12cae8:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12caec:	e3530004 	cmp	r3, #4
  12caf0:	0a000008 	beq	12cb18 <dhcp_parse_reply+0x4e4>
  12caf4:	e30901ec 	movw	r0, #37356	; 0x91ec
  12caf8:	e3400014 	movt	r0, #20
  12cafc:	ebff5984 	bl	103114 <rt_kprintf>
  12cb00:	e3001622 	movw	r1, #1570	; 0x622
  12cb04:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12cb08:	e3400014 	movt	r0, #20
  12cb0c:	ebff795a 	bl	10b07c <sys_arch_assert>
  12cb10:	e3e03005 	mvn	r3, #5
  12cb14:	ea000109 	b	12cf40 <dhcp_parse_reply+0x90c>
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
  12cb18:	e3a03002 	mov	r3, #2
  12cb1c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        break;
  12cb20:	ea000020 	b	12cba8 <dhcp_parse_reply+0x574>
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
  12cb24:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12cb28:	e3530004 	cmp	r3, #4
  12cb2c:	0a000008 	beq	12cb54 <dhcp_parse_reply+0x520>
  12cb30:	e30901ec 	movw	r0, #37356	; 0x91ec
  12cb34:	e3400014 	movt	r0, #20
  12cb38:	ebff5975 	bl	103114 <rt_kprintf>
  12cb3c:	e3001626 	movw	r1, #1574	; 0x626
  12cb40:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12cb44:	e3400014 	movt	r0, #20
  12cb48:	ebff794b 	bl	10b07c <sys_arch_assert>
  12cb4c:	e3e03005 	mvn	r3, #5
  12cb50:	ea0000fa 	b	12cf40 <dhcp_parse_reply+0x90c>
        decode_idx = DHCP_OPTION_IDX_T1;
  12cb54:	e3a03004 	mov	r3, #4
  12cb58:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        break;
  12cb5c:	ea000011 	b	12cba8 <dhcp_parse_reply+0x574>
      case(DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
  12cb60:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12cb64:	e3530004 	cmp	r3, #4
  12cb68:	0a000008 	beq	12cb90 <dhcp_parse_reply+0x55c>
  12cb6c:	e30901ec 	movw	r0, #37356	; 0x91ec
  12cb70:	e3400014 	movt	r0, #20
  12cb74:	ebff5966 	bl	103114 <rt_kprintf>
  12cb78:	e300162a 	movw	r1, #1578	; 0x62a
  12cb7c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12cb80:	e3400014 	movt	r0, #20
  12cb84:	ebff793c 	bl	10b07c <sys_arch_assert>
  12cb88:	e3e03005 	mvn	r3, #5
  12cb8c:	ea0000eb 	b	12cf40 <dhcp_parse_reply+0x90c>
        decode_idx = DHCP_OPTION_IDX_T2;
  12cb90:	e3a03005 	mov	r3, #5
  12cb94:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        break;
  12cb98:	ea000002 	b	12cba8 <dhcp_parse_reply+0x574>
      default:
        decode_len = 0;
  12cb9c:	e3a03000 	mov	r3, #0
  12cba0:	e54b301e 	strb	r3, [fp, #-30]	; 0xffffffe2
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", (u16_t)op));
        break;
  12cba4:	e320f000 	nop	{0}
    }
    offset += len + 2;
  12cba8:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12cbac:	e6ff2073 	uxth	r2, r3
  12cbb0:	e15b30ba 	ldrh	r3, [fp, #-10]
  12cbb4:	e0823003 	add	r3, r2, r3
  12cbb8:	e6ff3073 	uxth	r3, r3
  12cbbc:	e2833002 	add	r3, r3, #2
  12cbc0:	e14b30ba 	strh	r3, [fp, #-10]
    if (decode_len > 0) {
  12cbc4:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
  12cbc8:	e3530000 	cmp	r3, #0
  12cbcc:	0a000073 	beq	12cda0 <dhcp_parse_reply+0x76c>
      u32_t value = 0;
  12cbd0:	e3a03000 	mov	r3, #0
  12cbd4:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
  12cbd8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  12cbdc:	e3530000 	cmp	r3, #0
  12cbe0:	ba000002 	blt	12cbf0 <dhcp_parse_reply+0x5bc>
  12cbe4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  12cbe8:	e3530009 	cmp	r3, #9
  12cbec:	da000006 	ble	12cc0c <dhcp_parse_reply+0x5d8>
  12cbf0:	e3090240 	movw	r0, #37440	; 0x9240
  12cbf4:	e3400014 	movt	r0, #20
  12cbf8:	ebff5945 	bl	103114 <rt_kprintf>
  12cbfc:	e3001637 	movw	r1, #1591	; 0x637
  12cc00:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12cc04:	e3400014 	movt	r0, #20
  12cc08:	ebff791b 	bl	10b07c <sys_arch_assert>
      if (!dhcp_option_given(dhcp, decode_idx)) {
  12cc0c:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12cc10:	e3403057 	movt	r3, #87	; 0x57
  12cc14:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  12cc18:	e0833002 	add	r3, r3, r2
  12cc1c:	e5d33000 	ldrb	r3, [r3]
  12cc20:	e3530000 	cmp	r3, #0
  12cc24:	1a00005d 	bne	12cda0 <dhcp_parse_reply+0x76c>
        copy_len = LWIP_MIN(decode_len, 4);
  12cc28:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
  12cc2c:	e3530004 	cmp	r3, #4
  12cc30:	31a03003 	movcc	r3, r3
  12cc34:	23a03004 	movcs	r3, #4
  12cc38:	e6ef3073 	uxtb	r3, r3
  12cc3c:	e14b32ba 	strh	r3, [fp, #-42]	; 0xffffffd6
        if (pbuf_copy_partial(q, &value, copy_len, val_offset) != copy_len) {
  12cc40:	e15b32b6 	ldrh	r3, [fp, #-38]	; 0xffffffda
  12cc44:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
  12cc48:	e24b1034 	sub	r1, fp, #52	; 0x34
  12cc4c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  12cc50:	ebffbb22 	bl	11b8e0 <pbuf_copy_partial>
  12cc54:	e1a03000 	mov	r3, r0
  12cc58:	e1a02003 	mov	r2, r3
  12cc5c:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
  12cc60:	e1530002 	cmp	r3, r2
  12cc64:	0a000001 	beq	12cc70 <dhcp_parse_reply+0x63c>
          return ERR_BUF;
  12cc68:	e3e03001 	mvn	r3, #1
  12cc6c:	ea0000b3 	b	12cf40 <dhcp_parse_reply+0x90c>
        }
        if (decode_len > 4) {
  12cc70:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
  12cc74:	e3530004 	cmp	r3, #4
  12cc78:	9a000025 	bls	12cd14 <dhcp_parse_reply+0x6e0>
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len %% 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
  12cc7c:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
  12cc80:	e2033003 	and	r3, r3, #3
  12cc84:	e6ef3073 	uxtb	r3, r3
  12cc88:	e3530000 	cmp	r3, #0
  12cc8c:	0a000008 	beq	12ccb4 <dhcp_parse_reply+0x680>
  12cc90:	e3090254 	movw	r0, #37460	; 0x9254
  12cc94:	e3400014 	movt	r0, #20
  12cc98:	ebff591d 	bl	103114 <rt_kprintf>
  12cc9c:	e300163f 	movw	r1, #1599	; 0x63f
  12cca0:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12cca4:	e3400014 	movt	r0, #20
  12cca8:	ebff78f3 	bl	10b07c <sys_arch_assert>
  12ccac:	e3e03005 	mvn	r3, #5
  12ccb0:	ea0000a2 	b	12cf40 <dhcp_parse_reply+0x90c>
          dhcp_got_option(dhcp, decode_idx);
  12ccb4:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12ccb8:	e3403057 	movt	r3, #87	; 0x57
  12ccbc:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  12ccc0:	e0833002 	add	r3, r3, r2
  12ccc4:	e3a02001 	mov	r2, #1
  12ccc8:	e5c32000 	strb	r2, [r3]
          dhcp_set_option_value(dhcp, decode_idx, lwip_htonl(value));
  12cccc:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  12ccd0:	e1a00003 	mov	r0, r3
  12ccd4:	ebffa6cb 	bl	116808 <lwip_htonl>
  12ccd8:	e1a01000 	mov	r1, r0
  12ccdc:	e3063a58 	movw	r3, #27224	; 0x6a58
  12cce0:	e3403057 	movt	r3, #87	; 0x57
  12cce4:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  12cce8:	e7831102 	str	r1, [r3, r2, lsl #2]
          decode_len -= 4;
  12ccec:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
  12ccf0:	e2433004 	sub	r3, r3, #4
  12ccf4:	e54b301e 	strb	r3, [fp, #-30]	; 0xffffffe2
          val_offset += 4;
  12ccf8:	e15b32b6 	ldrh	r3, [fp, #-38]	; 0xffffffda
  12ccfc:	e2833004 	add	r3, r3, #4
  12cd00:	e14b32b6 	strh	r3, [fp, #-38]	; 0xffffffda
          decode_idx++;
  12cd04:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  12cd08:	e2833001 	add	r3, r3, #1
  12cd0c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
          goto decode_next;
  12cd10:	eaffffb0 	b	12cbd8 <dhcp_parse_reply+0x5a4>
        } else if (decode_len == 4) {
  12cd14:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
  12cd18:	e3530004 	cmp	r3, #4
  12cd1c:	1a000005 	bne	12cd38 <dhcp_parse_reply+0x704>
          value = lwip_ntohl(value);
  12cd20:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  12cd24:	e1a00003 	mov	r0, r3
  12cd28:	ebffa6b6 	bl	116808 <lwip_htonl>
  12cd2c:	e1a03000 	mov	r3, r0
  12cd30:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
  12cd34:	ea00000e 	b	12cd74 <dhcp_parse_reply+0x740>
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
  12cd38:	e55b301e 	ldrb	r3, [fp, #-30]	; 0xffffffe2
  12cd3c:	e3530001 	cmp	r3, #1
  12cd40:	0a000008 	beq	12cd68 <dhcp_parse_reply+0x734>
  12cd44:	e309026c 	movw	r0, #37484	; 0x926c
  12cd48:	e3400014 	movt	r0, #20
  12cd4c:	ebff58f0 	bl	103114 <rt_kprintf>
  12cd50:	e3001649 	movw	r1, #1609	; 0x649
  12cd54:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12cd58:	e3400014 	movt	r0, #20
  12cd5c:	ebff78c6 	bl	10b07c <sys_arch_assert>
  12cd60:	e3e03005 	mvn	r3, #5
  12cd64:	ea000075 	b	12cf40 <dhcp_parse_reply+0x90c>
          value = ((u8_t*)&value)[0];
  12cd68:	e24b3034 	sub	r3, fp, #52	; 0x34
  12cd6c:	e5d33000 	ldrb	r3, [r3]
  12cd70:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
        }
        dhcp_got_option(dhcp, decode_idx);
  12cd74:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12cd78:	e3403057 	movt	r3, #87	; 0x57
  12cd7c:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  12cd80:	e0833002 	add	r3, r3, r2
  12cd84:	e3a02001 	mov	r2, #1
  12cd88:	e5c32000 	strb	r2, [r3]
        dhcp_set_option_value(dhcp, decode_idx, value);
  12cd8c:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  12cd90:	e3063a58 	movw	r3, #27224	; 0x6a58
  12cd94:	e3403057 	movt	r3, #87	; 0x57
  12cd98:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  12cd9c:	e7831102 	str	r1, [r3, r2, lsl #2]
      }
    }
    if (offset >= q->len) {
  12cda0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12cda4:	e1d330ba 	ldrh	r3, [r3, #10]
  12cda8:	e15b20ba 	ldrh	r2, [fp, #-10]
  12cdac:	e1520003 	cmp	r2, r3
  12cdb0:	3a000020 	bcc	12ce38 <dhcp_parse_reply+0x804>
      offset -= q->len;
  12cdb4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12cdb8:	e1d330ba 	ldrh	r3, [r3, #10]
  12cdbc:	e15b20ba 	ldrh	r2, [fp, #-10]
  12cdc0:	e0423003 	sub	r3, r2, r3
  12cdc4:	e14b30ba 	strh	r3, [fp, #-10]
      offset_max -= q->len;
  12cdc8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12cdcc:	e1d330ba 	ldrh	r3, [r3, #10]
  12cdd0:	e15b20bc 	ldrh	r2, [fp, #-12]
  12cdd4:	e0423003 	sub	r3, r2, r3
  12cdd8:	e14b30bc 	strh	r3, [fp, #-12]
      if ((offset < offset_max) && offset_max) {
  12cddc:	e15b20ba 	ldrh	r2, [fp, #-10]
  12cde0:	e15b30bc 	ldrh	r3, [fp, #-12]
  12cde4:	e1520003 	cmp	r2, r3
  12cde8:	2a00001f 	bcs	12ce6c <dhcp_parse_reply+0x838>
  12cdec:	e15b30bc 	ldrh	r3, [fp, #-12]
  12cdf0:	e3530000 	cmp	r3, #0
  12cdf4:	0a00001c 	beq	12ce6c <dhcp_parse_reply+0x838>
        q = q->next;
  12cdf8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12cdfc:	e5933000 	ldr	r3, [r3]
  12ce00:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        LWIP_ASSERT("next pbuf was null", q);
  12ce04:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12ce08:	e3530000 	cmp	r3, #0
  12ce0c:	1a000006 	bne	12ce2c <dhcp_parse_reply+0x7f8>
  12ce10:	e3090280 	movw	r0, #37504	; 0x9280
  12ce14:	e3400014 	movt	r0, #20
  12ce18:	ebff58bd 	bl	103114 <rt_kprintf>
  12ce1c:	e3001655 	movw	r1, #1621	; 0x655
  12ce20:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12ce24:	e3400014 	movt	r0, #20
  12ce28:	ebff7893 	bl	10b07c <sys_arch_assert>
        options = (u8_t*)q->payload;
  12ce2c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12ce30:	e5933004 	ldr	r3, [r3, #4]
  12ce34:	e50b3008 	str	r3, [fp, #-8]
  while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
  12ce38:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12ce3c:	e3530000 	cmp	r3, #0
  12ce40:	0a000009 	beq	12ce6c <dhcp_parse_reply+0x838>
  12ce44:	e15b30ba 	ldrh	r3, [fp, #-10]
  12ce48:	e51b2008 	ldr	r2, [fp, #-8]
  12ce4c:	e0823003 	add	r3, r2, r3
  12ce50:	e5d33000 	ldrb	r3, [r3]
  12ce54:	e35300ff 	cmp	r3, #255	; 0xff
  12ce58:	0a000003 	beq	12ce6c <dhcp_parse_reply+0x838>
  12ce5c:	e15b20ba 	ldrh	r2, [fp, #-10]
  12ce60:	e15b30bc 	ldrh	r3, [fp, #-12]
  12ce64:	e1520003 	cmp	r2, r3
  12ce68:	3afffe33 	bcc	12c73c <dhcp_parse_reply+0x108>
        break;
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
  12ce6c:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12ce70:	e3403057 	movt	r3, #87	; 0x57
  12ce74:	e5d33000 	ldrb	r3, [r3]
  12ce78:	e3530000 	cmp	r3, #0
  12ce7c:	0a00001a 	beq	12ceec <dhcp_parse_reply+0x8b8>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
  12ce80:	e3063a58 	movw	r3, #27224	; 0x6a58
  12ce84:	e3403057 	movt	r3, #87	; 0x57
  12ce88:	e5933000 	ldr	r3, [r3]
  12ce8c:	e50b3030 	str	r3, [fp, #-48]	; 0xffffffd0
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
  12ce90:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12ce94:	e3403057 	movt	r3, #87	; 0x57
  12ce98:	e3a02000 	mov	r2, #0
  12ce9c:	e5c32000 	strb	r2, [r3]
    if (overload == DHCP_OVERLOAD_FILE) {
  12cea0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12cea4:	e3530001 	cmp	r3, #1
  12cea8:	1a000002 	bne	12ceb8 <dhcp_parse_reply+0x884>
      parse_file_as_options = 1;
  12ceac:	e3a03001 	mov	r3, #1
  12ceb0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  12ceb4:	ea00000c 	b	12ceec <dhcp_parse_reply+0x8b8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
  12ceb8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12cebc:	e3530002 	cmp	r3, #2
  12cec0:	1a000002 	bne	12ced0 <dhcp_parse_reply+0x89c>
      parse_sname_as_options = 1;
  12cec4:	e3a03001 	mov	r3, #1
  12cec8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  12cecc:	ea000006 	b	12ceec <dhcp_parse_reply+0x8b8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
  12ced0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12ced4:	e3530003 	cmp	r3, #3
  12ced8:	1a000003 	bne	12ceec <dhcp_parse_reply+0x8b8>
      parse_sname_as_options = 1;
  12cedc:	e3a03001 	mov	r3, #1
  12cee0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
      parse_file_as_options = 1;
  12cee4:	e3a03001 	mov	r3, #1
  12cee8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
      /* make sure the string is really NULL-terminated */
      dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
    }
#endif /* LWIP_DHCP_BOOTP_FILE */
  }
  if (parse_file_as_options) {
  12ceec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12cef0:	e3530000 	cmp	r3, #0
  12cef4:	0a000006 	beq	12cf14 <dhcp_parse_reply+0x8e0>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
  12cef8:	e3a03000 	mov	r3, #0
  12cefc:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    options_idx = DHCP_FILE_OFS;
  12cf00:	e3a0306c 	mov	r3, #108	; 0x6c
  12cf04:	e14b30be 	strh	r3, [fp, #-14]
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
  12cf08:	e3a030ec 	mov	r3, #236	; 0xec
  12cf0c:	e14b31b0 	strh	r3, [fp, #-16]
    goto again;
  12cf10:	eafffde4 	b	12c6a8 <dhcp_parse_reply+0x74>
  } else if (parse_sname_as_options) {
  12cf14:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12cf18:	e3530000 	cmp	r3, #0
  12cf1c:	0a000006 	beq	12cf3c <dhcp_parse_reply+0x908>
    parse_sname_as_options = 0;
  12cf20:	e3a03000 	mov	r3, #0
  12cf24:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    options_idx = DHCP_SNAME_OFS;
  12cf28:	e3a0302c 	mov	r3, #44	; 0x2c
  12cf2c:	e14b30be 	strh	r3, [fp, #-14]
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
  12cf30:	e3a0306c 	mov	r3, #108	; 0x6c
  12cf34:	e14b31b0 	strh	r3, [fp, #-16]
    goto again;
  12cf38:	eafffdda 	b	12c6a8 <dhcp_parse_reply+0x74>
  }
  return ERR_OK;
  12cf3c:	e3a03000 	mov	r3, #0
}
  12cf40:	e1a00003 	mov	r0, r3
  12cf44:	e24bd004 	sub	sp, fp, #4
  12cf48:	e8bd8800 	pop	{fp, pc}

0012cf4c <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
  12cf4c:	e92d4800 	push	{fp, lr}
  12cf50:	e28db004 	add	fp, sp, #4
  12cf54:	e24dd028 	sub	sp, sp, #40	; 0x28
  12cf58:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  12cf5c:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  12cf60:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  12cf64:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
  struct netif *netif = ip_current_input_netif();
  12cf68:	e30035e8 	movw	r3, #1512	; 0x5e8
  12cf6c:	e3403015 	movt	r3, #21
  12cf70:	e5933004 	ldr	r3, [r3, #4]
  12cf74:	e50b300c 	str	r3, [fp, #-12]
  struct dhcp *dhcp = netif_dhcp_data(netif);
  12cf78:	e51b300c 	ldr	r3, [fp, #-12]
  12cf7c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12cf80:	e50b3010 	str	r3, [fp, #-16]
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  12cf84:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12cf88:	e5933004 	ldr	r3, [r3, #4]
  12cf8c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  u8_t i;

  LWIP_UNUSED_ARG(arg);

  /* Caught DHCP message from netif that does not have DHCP enabled? -> not interested */
  if ((dhcp == NULL) || (dhcp->pcb_allocated == 0)) {
  12cf90:	e51b3010 	ldr	r3, [fp, #-16]
  12cf94:	e3530000 	cmp	r3, #0
  12cf98:	0a000091 	beq	12d1e4 <dhcp_recv+0x298>
  12cf9c:	e51b3010 	ldr	r3, [fp, #-16]
  12cfa0:	e5d33008 	ldrb	r3, [r3, #8]
  12cfa4:	e3530000 	cmp	r3, #0
  12cfa8:	0a00008d 	beq	12d1e4 <dhcp_recv+0x298>
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
  12cfac:	e51b3010 	ldr	r3, [fp, #-16]
  12cfb0:	e5933004 	ldr	r3, [r3, #4]
  12cfb4:	e3530000 	cmp	r3, #0
  12cfb8:	0a000006 	beq	12cfd8 <dhcp_recv+0x8c>
  12cfbc:	e3090064 	movw	r0, #36964	; 0x9064
  12cfc0:	e3400014 	movt	r0, #20
  12cfc4:	ebff5852 	bl	103114 <rt_kprintf>
  12cfc8:	e30016a9 	movw	r1, #1705	; 0x6a9
  12cfcc:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12cfd0:	e3400014 	movt	r0, #20
  12cfd4:	ebff7828 	bl	10b07c <sys_arch_assert>

  if (p->len < DHCP_MIN_REPLY_LEN) {
  12cfd8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12cfdc:	e1d330ba 	ldrh	r3, [r3, #10]
  12cfe0:	e353002b 	cmp	r3, #43	; 0x2b
  12cfe4:	9a000080 	bls	12d1ec <dhcp_recv+0x2a0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
  12cfe8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12cfec:	e5d33000 	ldrb	r3, [r3]
  12cff0:	e3530002 	cmp	r3, #2
  12cff4:	1a00007e 	bne	12d1f4 <dhcp_recv+0x2a8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len && i < NETIF_MAX_HWADDR_LEN && i < DHCP_CHADDR_LEN; i++) {
  12cff8:	e3a03000 	mov	r3, #0
  12cffc:	e54b3005 	strb	r3, [fp, #-5]
  12d000:	ea00000c 	b	12d038 <dhcp_recv+0xec>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  12d004:	e55b3005 	ldrb	r3, [fp, #-5]
  12d008:	e51b200c 	ldr	r2, [fp, #-12]
  12d00c:	e0823003 	add	r3, r2, r3
  12d010:	e5d3203b 	ldrb	r2, [r3, #59]	; 0x3b
  12d014:	e55b3005 	ldrb	r3, [fp, #-5]
  12d018:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  12d01c:	e0813003 	add	r3, r1, r3
  12d020:	e5d3301c 	ldrb	r3, [r3, #28]
  12d024:	e1520003 	cmp	r2, r3
  12d028:	1a000073 	bne	12d1fc <dhcp_recv+0x2b0>
  for (i = 0; i < netif->hwaddr_len && i < NETIF_MAX_HWADDR_LEN && i < DHCP_CHADDR_LEN; i++) {
  12d02c:	e55b3005 	ldrb	r3, [fp, #-5]
  12d030:	e2833001 	add	r3, r3, #1
  12d034:	e54b3005 	strb	r3, [fp, #-5]
  12d038:	e51b300c 	ldr	r3, [fp, #-12]
  12d03c:	e5d3303a 	ldrb	r3, [r3, #58]	; 0x3a
  12d040:	e55b2005 	ldrb	r2, [fp, #-5]
  12d044:	e1520003 	cmp	r2, r3
  12d048:	2a000005 	bcs	12d064 <dhcp_recv+0x118>
  12d04c:	e55b3005 	ldrb	r3, [fp, #-5]
  12d050:	e3530005 	cmp	r3, #5
  12d054:	8a000002 	bhi	12d064 <dhcp_recv+0x118>
  12d058:	e55b3005 	ldrb	r3, [fp, #-5]
  12d05c:	e353000f 	cmp	r3, #15
  12d060:	9affffe7 	bls	12d004 <dhcp_recv+0xb8>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (lwip_ntohl(reply_msg->xid) != dhcp->xid) {
  12d064:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12d068:	e5933004 	ldr	r3, [r3, #4]
  12d06c:	e1a00003 	mov	r0, r3
  12d070:	ebffa5e4 	bl	116808 <lwip_htonl>
  12d074:	e1a02000 	mov	r2, r0
  12d078:	e51b3010 	ldr	r3, [fp, #-16]
  12d07c:	e5933000 	ldr	r3, [r3]
  12d080:	e1520003 	cmp	r2, r3
  12d084:	1a00005e 	bne	12d204 <dhcp_recv+0x2b8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",lwip_ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
  12d088:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
  12d08c:	e51b0010 	ldr	r0, [fp, #-16]
  12d090:	ebfffd67 	bl	12c634 <dhcp_parse_reply>
  12d094:	e1a03000 	mov	r3, r0
  12d098:	e3530000 	cmp	r3, #0
  12d09c:	1a00005a 	bne	12d20c <dhcp_recv+0x2c0>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
  12d0a0:	e3063a4c 	movw	r3, #27212	; 0x6a4c
  12d0a4:	e3403057 	movt	r3, #87	; 0x57
  12d0a8:	e5d33001 	ldrb	r3, [r3, #1]
  12d0ac:	e3530000 	cmp	r3, #0
  12d0b0:	0a000057 	beq	12d214 <dhcp_recv+0x2c8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
  12d0b4:	e3063a58 	movw	r3, #27224	; 0x6a58
  12d0b8:	e3403057 	movt	r3, #87	; 0x57
  12d0bc:	e5933004 	ldr	r3, [r3, #4]
  12d0c0:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  12d0c4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  12d0c8:	e3530005 	cmp	r3, #5
  12d0cc:	1a000021 	bne	12d158 <dhcp_recv+0x20c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_STATE_REQUESTING) {
  12d0d0:	e51b3010 	ldr	r3, [fp, #-16]
  12d0d4:	e5d33009 	ldrb	r3, [r3, #9]
  12d0d8:	e3530001 	cmp	r3, #1
  12d0dc:	1a00000c 	bne	12d114 <dhcp_recv+0x1c8>
      dhcp_handle_ack(netif);
  12d0e0:	e51b000c 	ldr	r0, [fp, #-12]
  12d0e4:	ebfff6b6 	bl	12abc4 <dhcp_handle_ack>
#if DHCP_DOES_ARP_CHECK
      if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
  12d0e8:	e51b300c 	ldr	r3, [fp, #-12]
  12d0ec:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  12d0f0:	e2033008 	and	r3, r3, #8
  12d0f4:	e3530000 	cmp	r3, #0
  12d0f8:	0a000002 	beq	12d108 <dhcp_recv+0x1bc>
        /* check if the acknowledged lease address is already in use */
        dhcp_check(netif);
  12d0fc:	e51b000c 	ldr	r0, [fp, #-12]
  12d100:	ebfff4c0 	bl	12a408 <dhcp_check>
  12d104:	ea000043 	b	12d218 <dhcp_recv+0x2cc>
      } else {
        /* bind interface to the acknowledged lease address */
        dhcp_bind(netif);
  12d108:	e51b000c 	ldr	r0, [fp, #-12]
  12d10c:	ebfff952 	bl	12b65c <dhcp_bind>
  12d110:	ea000040 	b	12d218 <dhcp_recv+0x2cc>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REBINDING) ||
  12d114:	e51b3010 	ldr	r3, [fp, #-16]
  12d118:	e5d33009 	ldrb	r3, [r3, #9]
  12d11c:	e3530003 	cmp	r3, #3
  12d120:	0a000007 	beq	12d144 <dhcp_recv+0x1f8>
  12d124:	e51b3010 	ldr	r3, [fp, #-16]
  12d128:	e5d33009 	ldrb	r3, [r3, #9]
  12d12c:	e3530004 	cmp	r3, #4
  12d130:	0a000003 	beq	12d144 <dhcp_recv+0x1f8>
             (dhcp->state == DHCP_STATE_RENEWING)) {
  12d134:	e51b3010 	ldr	r3, [fp, #-16]
  12d138:	e5d33009 	ldrb	r3, [r3, #9]
    else if ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REBINDING) ||
  12d13c:	e3530005 	cmp	r3, #5
  12d140:	1a000034 	bne	12d218 <dhcp_recv+0x2cc>
      dhcp_handle_ack(netif);
  12d144:	e51b000c 	ldr	r0, [fp, #-12]
  12d148:	ebfff69d 	bl	12abc4 <dhcp_handle_ack>
      dhcp_bind(netif);
  12d14c:	e51b000c 	ldr	r0, [fp, #-12]
  12d150:	ebfff941 	bl	12b65c <dhcp_bind>
  12d154:	ea00002f 	b	12d218 <dhcp_recv+0x2cc>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  12d158:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  12d15c:	e3530006 	cmp	r3, #6
  12d160:	1a000012 	bne	12d1b0 <dhcp_recv+0x264>
    ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
  12d164:	e51b3010 	ldr	r3, [fp, #-16]
  12d168:	e5d33009 	ldrb	r3, [r3, #9]
  else if ((msg_type == DHCP_NAK) &&
  12d16c:	e3530003 	cmp	r3, #3
  12d170:	0a00000b 	beq	12d1a4 <dhcp_recv+0x258>
    ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
  12d174:	e51b3010 	ldr	r3, [fp, #-16]
  12d178:	e5d33009 	ldrb	r3, [r3, #9]
  12d17c:	e3530001 	cmp	r3, #1
  12d180:	0a000007 	beq	12d1a4 <dhcp_recv+0x258>
     (dhcp->state == DHCP_STATE_REBINDING) || (dhcp->state == DHCP_STATE_RENEWING  ))) {
  12d184:	e51b3010 	ldr	r3, [fp, #-16]
  12d188:	e5d33009 	ldrb	r3, [r3, #9]
    ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
  12d18c:	e3530004 	cmp	r3, #4
  12d190:	0a000003 	beq	12d1a4 <dhcp_recv+0x258>
     (dhcp->state == DHCP_STATE_REBINDING) || (dhcp->state == DHCP_STATE_RENEWING  ))) {
  12d194:	e51b3010 	ldr	r3, [fp, #-16]
  12d198:	e5d33009 	ldrb	r3, [r3, #9]
  12d19c:	e3530005 	cmp	r3, #5
  12d1a0:	1a000002 	bne	12d1b0 <dhcp_recv+0x264>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
  12d1a4:	e51b000c 	ldr	r0, [fp, #-12]
  12d1a8:	ebfff47f 	bl	12a3ac <dhcp_handle_nak>
  12d1ac:	ea000019 	b	12d218 <dhcp_recv+0x2cc>
  }
  /* received a DHCP_OFFER in DHCP_STATE_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_STATE_SELECTING)) {
  12d1b0:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  12d1b4:	e3530002 	cmp	r3, #2
  12d1b8:	1a000009 	bne	12d1e4 <dhcp_recv+0x298>
  12d1bc:	e51b3010 	ldr	r3, [fp, #-16]
  12d1c0:	e5d33009 	ldrb	r3, [r3, #9]
  12d1c4:	e3530006 	cmp	r3, #6
  12d1c8:	1a000005 	bne	12d1e4 <dhcp_recv+0x298>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_STATE_SELECTING state\n"));
    dhcp->request_timeout = 0;
  12d1cc:	e51b3010 	ldr	r3, [fp, #-16]
  12d1d0:	e3a02000 	mov	r2, #0
  12d1d4:	e1c321b6 	strh	r2, [r3, #22]
    /* remember offered lease */
    dhcp_handle_offer(netif);
  12d1d8:	e51b000c 	ldr	r0, [fp, #-12]
  12d1dc:	ebfff4b6 	bl	12a4bc <dhcp_handle_offer>
  12d1e0:	ea00000c 	b	12d218 <dhcp_recv+0x2cc>
  }

free_pbuf_and_return:
  12d1e4:	e320f000 	nop	{0}
  12d1e8:	ea00000a 	b	12d218 <dhcp_recv+0x2cc>
    goto free_pbuf_and_return;
  12d1ec:	e320f000 	nop	{0}
  12d1f0:	ea000008 	b	12d218 <dhcp_recv+0x2cc>
    goto free_pbuf_and_return;
  12d1f4:	e320f000 	nop	{0}
  12d1f8:	ea000006 	b	12d218 <dhcp_recv+0x2cc>
      goto free_pbuf_and_return;
  12d1fc:	e320f000 	nop	{0}
  12d200:	ea000004 	b	12d218 <dhcp_recv+0x2cc>
    goto free_pbuf_and_return;
  12d204:	e320f000 	nop	{0}
  12d208:	ea000002 	b	12d218 <dhcp_recv+0x2cc>
    goto free_pbuf_and_return;
  12d20c:	e320f000 	nop	{0}
  12d210:	ea000000 	b	12d218 <dhcp_recv+0x2cc>
    goto free_pbuf_and_return;
  12d214:	e320f000 	nop	{0}
  if (dhcp != NULL) {
  12d218:	e51b3010 	ldr	r3, [fp, #-16]
  12d21c:	e3530000 	cmp	r3, #0
  12d220:	0a000002 	beq	12d230 <dhcp_recv+0x2e4>
    dhcp->msg_in = NULL;
  12d224:	e51b3010 	ldr	r3, [fp, #-16]
  12d228:	e3a02000 	mov	r2, #0
  12d22c:	e5832004 	str	r2, [r3, #4]
  }
  pbuf_free(p);
  12d230:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12d234:	ebffb79e 	bl	11b0b4 <pbuf_free>
}
  12d238:	e320f000 	nop	{0}
  12d23c:	e24bd004 	sub	sp, fp, #4
  12d240:	e8bd8800 	pop	{fp, pc}

0012d244 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
{
  12d244:	e92d4810 	push	{r4, fp, lr}
  12d248:	e28db008 	add	fp, sp, #8
  12d24c:	e24dd01c 	sub	sp, sp, #28
  12d250:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12d254:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  12d258:	e1a03002 	mov	r3, r2
  12d25c:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
  12d260:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12d264:	e3530000 	cmp	r3, #0
  12d268:	1a000008 	bne	12d290 <dhcp_create_msg+0x4c>
  12d26c:	e3090294 	movw	r0, #37524	; 0x9294
  12d270:	e3400014 	movt	r0, #20
  12d274:	ebff57a6 	bl	103114 <rt_kprintf>
  12d278:	e300171e 	movw	r1, #1822	; 0x71e
  12d27c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d280:	e3400014 	movt	r0, #20
  12d284:	ebff777c 	bl	10b07c <sys_arch_assert>
  12d288:	e3e0300f 	mvn	r3, #15
  12d28c:	ea000121 	b	12d718 <dhcp_create_msg+0x4d4>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  12d290:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d294:	e3530000 	cmp	r3, #0
  12d298:	1a000008 	bne	12d2c0 <dhcp_create_msg+0x7c>
  12d29c:	e30902b4 	movw	r0, #37556	; 0x92b4
  12d2a0:	e3400014 	movt	r0, #20
  12d2a4:	ebff579a 	bl	103114 <rt_kprintf>
  12d2a8:	e300171f 	movw	r1, #1823	; 0x71f
  12d2ac:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d2b0:	e3400014 	movt	r0, #20
  12d2b4:	ebff7770 	bl	10b07c <sys_arch_assert>
  12d2b8:	e3e03005 	mvn	r3, #5
  12d2bc:	ea000115 	b	12d718 <dhcp_create_msg+0x4d4>
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  12d2c0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d2c4:	e593300c 	ldr	r3, [r3, #12]
  12d2c8:	e3530000 	cmp	r3, #0
  12d2cc:	0a000006 	beq	12d2ec <dhcp_create_msg+0xa8>
  12d2d0:	e30902d4 	movw	r0, #37588	; 0x92d4
  12d2d4:	e3400014 	movt	r0, #20
  12d2d8:	ebff578d 	bl	103114 <rt_kprintf>
  12d2dc:	e3a01e72 	mov	r1, #1824	; 0x720
  12d2e0:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d2e4:	e3400014 	movt	r0, #20
  12d2e8:	ebff7763 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  12d2ec:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d2f0:	e5933010 	ldr	r3, [r3, #16]
  12d2f4:	e3530000 	cmp	r3, #0
  12d2f8:	0a000006 	beq	12d318 <dhcp_create_msg+0xd4>
  12d2fc:	e30902fc 	movw	r0, #37628	; 0x92fc
  12d300:	e3400014 	movt	r0, #20
  12d304:	ebff5782 	bl	103114 <rt_kprintf>
  12d308:	e3001721 	movw	r1, #1825	; 0x721
  12d30c:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d310:	e3400014 	movt	r0, #20
  12d314:	ebff7758 	bl	10b07c <sys_arch_assert>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  12d318:	e3a02000 	mov	r2, #0
  12d31c:	e3a01f4d 	mov	r1, #308	; 0x134
  12d320:	e3a00000 	mov	r0, #0
  12d324:	ebffb45b 	bl	11a498 <pbuf_alloc>
  12d328:	e1a02000 	mov	r2, r0
  12d32c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d330:	e583200c 	str	r2, [r3, #12]
  if (dhcp->p_out == NULL) {
  12d334:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d338:	e593300c 	ldr	r3, [r3, #12]
  12d33c:	e3530000 	cmp	r3, #0
  12d340:	1a000001 	bne	12d34c <dhcp_create_msg+0x108>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
  12d344:	e3e03000 	mvn	r3, #0
  12d348:	ea0000f2 	b	12d718 <dhcp_create_msg+0x4d4>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
  12d34c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d350:	e593300c 	ldr	r3, [r3, #12]
  12d354:	e1d330ba 	ldrh	r3, [r3, #10]
  12d358:	e3530f4d 	cmp	r3, #308	; 0x134
  12d35c:	2a000006 	bcs	12d37c <dhcp_create_msg+0x138>
  12d360:	e3090324 	movw	r0, #37668	; 0x9324
  12d364:	e3400014 	movt	r0, #20
  12d368:	ebff5769 	bl	103114 <rt_kprintf>
  12d36c:	e3001729 	movw	r1, #1833	; 0x729
  12d370:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d374:	e3400014 	movt	r0, #20
  12d378:	ebff773f 	bl	10b07c <sys_arch_assert>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* DHCP_REQUEST should reuse 'xid' from DHCPOFFER */
  if (message_type != DHCP_REQUEST) {
  12d37c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12d380:	e3530003 	cmp	r3, #3
  12d384:	0a00000e 	beq	12d3c4 <dhcp_create_msg+0x180>
    /* reuse transaction identifier in retransmissions */
    if (dhcp->tries == 0) {
  12d388:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d38c:	e5d3300a 	ldrb	r3, [r3, #10]
  12d390:	e3530000 	cmp	r3, #0
  12d394:	1a000005 	bne	12d3b0 <dhcp_create_msg+0x16c>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
      xid = LWIP_RAND();
  12d398:	eb0043fb 	bl	13e38c <rand>
  12d39c:	e1a03000 	mov	r3, r0
  12d3a0:	e1a02003 	mov	r2, r3
  12d3a4:	e30f3ad0 	movw	r3, #64208	; 0xfad0
  12d3a8:	e3403014 	movt	r3, #20
  12d3ac:	e5832000 	str	r2, [r3]
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
      xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    }
    dhcp->xid = xid;
  12d3b0:	e30f3ad0 	movw	r3, #64208	; 0xfad0
  12d3b4:	e3403014 	movt	r3, #20
  12d3b8:	e5932000 	ldr	r2, [r3]
  12d3bc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d3c0:	e5832000 	str	r2, [r3]
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  12d3c4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d3c8:	e593300c 	ldr	r3, [r3, #12]
  12d3cc:	e5932004 	ldr	r2, [r3, #4]
  12d3d0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d3d4:	e5832010 	str	r2, [r3, #16]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  12d3d8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d3dc:	e5933010 	ldr	r3, [r3, #16]
  12d3e0:	e3a02001 	mov	r2, #1
  12d3e4:	e5c32000 	strb	r2, [r3]
  /* @todo: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  12d3e8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d3ec:	e5933010 	ldr	r3, [r3, #16]
  12d3f0:	e3a02001 	mov	r2, #1
  12d3f4:	e5c32001 	strb	r2, [r3, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
  12d3f8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d3fc:	e5933010 	ldr	r3, [r3, #16]
  12d400:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  12d404:	e5d2203a 	ldrb	r2, [r2, #58]	; 0x3a
  12d408:	e5c32002 	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
  12d40c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d410:	e5933010 	ldr	r3, [r3, #16]
  12d414:	e3a02000 	mov	r2, #0
  12d418:	e5c32003 	strb	r2, [r3, #3]
  dhcp->msg_out->xid = lwip_htonl(dhcp->xid);
  12d41c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d420:	e5932000 	ldr	r2, [r3]
  12d424:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d428:	e5934010 	ldr	r4, [r3, #16]
  12d42c:	e1a00002 	mov	r0, r2
  12d430:	ebffa4f4 	bl	116808 <lwip_htonl>
  12d434:	e1a03000 	mov	r3, r0
  12d438:	e5843004 	str	r3, [r4, #4]
  dhcp->msg_out->secs = 0;
  12d43c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d440:	e5933010 	ldr	r3, [r3, #16]
  12d444:	e3a02000 	mov	r2, #0
  12d448:	e5c32008 	strb	r2, [r3, #8]
  12d44c:	e3a02000 	mov	r2, #0
  12d450:	e5c32009 	strb	r2, [r3, #9]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  12d454:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d458:	e5933010 	ldr	r3, [r3, #16]
  12d45c:	e3a02000 	mov	r2, #0
  12d460:	e5c3200a 	strb	r2, [r3, #10]
  12d464:	e3a02000 	mov	r2, #0
  12d468:	e5c3200b 	strb	r2, [r3, #11]
  ip4_addr_set_zero(&dhcp->msg_out->ciaddr);
  12d46c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d470:	e5933010 	ldr	r3, [r3, #16]
  12d474:	e3a02000 	mov	r2, #0
  12d478:	e5c3200c 	strb	r2, [r3, #12]
  12d47c:	e3a02000 	mov	r2, #0
  12d480:	e5c3200d 	strb	r2, [r3, #13]
  12d484:	e3a02000 	mov	r2, #0
  12d488:	e5c3200e 	strb	r2, [r3, #14]
  12d48c:	e3a02000 	mov	r2, #0
  12d490:	e5c3200f 	strb	r2, [r3, #15]
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
  12d494:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12d498:	e3530008 	cmp	r3, #8
  12d49c:	0a000010 	beq	12d4e4 <dhcp_create_msg+0x2a0>
  12d4a0:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12d4a4:	e3530004 	cmp	r3, #4
  12d4a8:	0a00000d 	beq	12d4e4 <dhcp_create_msg+0x2a0>
  12d4ac:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12d4b0:	e3530007 	cmp	r3, #7
  12d4b4:	0a00000a 	beq	12d4e4 <dhcp_create_msg+0x2a0>
  12d4b8:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12d4bc:	e3530003 	cmp	r3, #3
  12d4c0:	1a00000d 	bne	12d4fc <dhcp_create_msg+0x2b8>
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
       ((dhcp->state== DHCP_STATE_RENEWING) || dhcp->state== DHCP_STATE_REBINDING))) {
  12d4c4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d4c8:	e5d33009 	ldrb	r3, [r3, #9]
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
  12d4cc:	e3530005 	cmp	r3, #5
  12d4d0:	0a000003 	beq	12d4e4 <dhcp_create_msg+0x2a0>
       ((dhcp->state== DHCP_STATE_RENEWING) || dhcp->state== DHCP_STATE_REBINDING))) {
  12d4d4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d4d8:	e5d33009 	ldrb	r3, [r3, #9]
  12d4dc:	e3530004 	cmp	r3, #4
  12d4e0:	1a000005 	bne	12d4fc <dhcp_create_msg+0x2b8>
    ip4_addr_copy(dhcp->msg_out->ciaddr, *netif_ip4_addr(netif));
  12d4e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12d4e8:	e2832004 	add	r2, r3, #4
  12d4ec:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d4f0:	e5933010 	ldr	r3, [r3, #16]
  12d4f4:	e5922000 	ldr	r2, [r2]
  12d4f8:	e583200c 	str	r2, [r3, #12]
  }
  ip4_addr_set_zero(&dhcp->msg_out->yiaddr);
  12d4fc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d500:	e5933010 	ldr	r3, [r3, #16]
  12d504:	e3a02000 	mov	r2, #0
  12d508:	e5c32010 	strb	r2, [r3, #16]
  12d50c:	e3a02000 	mov	r2, #0
  12d510:	e5c32011 	strb	r2, [r3, #17]
  12d514:	e3a02000 	mov	r2, #0
  12d518:	e5c32012 	strb	r2, [r3, #18]
  12d51c:	e3a02000 	mov	r2, #0
  12d520:	e5c32013 	strb	r2, [r3, #19]
  ip4_addr_set_zero(&dhcp->msg_out->siaddr);
  12d524:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d528:	e5933010 	ldr	r3, [r3, #16]
  12d52c:	e3a02000 	mov	r2, #0
  12d530:	e5c32014 	strb	r2, [r3, #20]
  12d534:	e3a02000 	mov	r2, #0
  12d538:	e5c32015 	strb	r2, [r3, #21]
  12d53c:	e3a02000 	mov	r2, #0
  12d540:	e5c32016 	strb	r2, [r3, #22]
  12d544:	e3a02000 	mov	r2, #0
  12d548:	e5c32017 	strb	r2, [r3, #23]
  ip4_addr_set_zero(&dhcp->msg_out->giaddr);
  12d54c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d550:	e5933010 	ldr	r3, [r3, #16]
  12d554:	e3a02000 	mov	r2, #0
  12d558:	e5c32018 	strb	r2, [r3, #24]
  12d55c:	e3a02000 	mov	r2, #0
  12d560:	e5c32019 	strb	r2, [r3, #25]
  12d564:	e3a02000 	mov	r2, #0
  12d568:	e5c3201a 	strb	r2, [r3, #26]
  12d56c:	e3a02000 	mov	r2, #0
  12d570:	e5c3201b 	strb	r2, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  12d574:	e3a03000 	mov	r3, #0
  12d578:	e14b30be 	strh	r3, [fp, #-14]
  12d57c:	ea000017 	b	12d5e0 <dhcp_create_msg+0x39c>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len && i < NETIF_MAX_HWADDR_LEN) ? netif->hwaddr[i] : 0/* pad byte*/;
  12d580:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12d584:	e5d3303a 	ldrb	r3, [r3, #58]	; 0x3a
  12d588:	e6ff3073 	uxth	r3, r3
  12d58c:	e15b20be 	ldrh	r2, [fp, #-14]
  12d590:	e1520003 	cmp	r2, r3
  12d594:	2a000007 	bcs	12d5b8 <dhcp_create_msg+0x374>
  12d598:	e15b30be 	ldrh	r3, [fp, #-14]
  12d59c:	e3530005 	cmp	r3, #5
  12d5a0:	8a000004 	bhi	12d5b8 <dhcp_create_msg+0x374>
  12d5a4:	e15b30be 	ldrh	r3, [fp, #-14]
  12d5a8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  12d5ac:	e0823003 	add	r3, r2, r3
  12d5b0:	e5d3103b 	ldrb	r1, [r3, #59]	; 0x3b
  12d5b4:	ea000000 	b	12d5bc <dhcp_create_msg+0x378>
  12d5b8:	e3a01000 	mov	r1, #0
  12d5bc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d5c0:	e5932010 	ldr	r2, [r3, #16]
  12d5c4:	e15b30be 	ldrh	r3, [fp, #-14]
  12d5c8:	e0823003 	add	r3, r2, r3
  12d5cc:	e1a02001 	mov	r2, r1
  12d5d0:	e5c3201c 	strb	r2, [r3, #28]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  12d5d4:	e15b30be 	ldrh	r3, [fp, #-14]
  12d5d8:	e2833001 	add	r3, r3, #1
  12d5dc:	e14b30be 	strh	r3, [fp, #-14]
  12d5e0:	e15b30be 	ldrh	r3, [fp, #-14]
  12d5e4:	e353000f 	cmp	r3, #15
  12d5e8:	9affffe4 	bls	12d580 <dhcp_create_msg+0x33c>
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  12d5ec:	e3a03000 	mov	r3, #0
  12d5f0:	e14b30be 	strh	r3, [fp, #-14]
  12d5f4:	ea000008 	b	12d61c <dhcp_create_msg+0x3d8>
    dhcp->msg_out->sname[i] = 0;
  12d5f8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d5fc:	e5932010 	ldr	r2, [r3, #16]
  12d600:	e15b30be 	ldrh	r3, [fp, #-14]
  12d604:	e0823003 	add	r3, r2, r3
  12d608:	e3a02000 	mov	r2, #0
  12d60c:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  12d610:	e15b30be 	ldrh	r3, [fp, #-14]
  12d614:	e2833001 	add	r3, r3, #1
  12d618:	e14b30be 	strh	r3, [fp, #-14]
  12d61c:	e15b30be 	ldrh	r3, [fp, #-14]
  12d620:	e353003f 	cmp	r3, #63	; 0x3f
  12d624:	9afffff3 	bls	12d5f8 <dhcp_create_msg+0x3b4>
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  12d628:	e3a03000 	mov	r3, #0
  12d62c:	e14b30be 	strh	r3, [fp, #-14]
  12d630:	ea000008 	b	12d658 <dhcp_create_msg+0x414>
    dhcp->msg_out->file[i] = 0;
  12d634:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d638:	e5932010 	ldr	r2, [r3, #16]
  12d63c:	e15b30be 	ldrh	r3, [fp, #-14]
  12d640:	e0823003 	add	r3, r2, r3
  12d644:	e3a02000 	mov	r2, #0
  12d648:	e5c3206c 	strb	r2, [r3, #108]	; 0x6c
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  12d64c:	e15b30be 	ldrh	r3, [fp, #-14]
  12d650:	e2833001 	add	r3, r3, #1
  12d654:	e14b30be 	strh	r3, [fp, #-14]
  12d658:	e15b30be 	ldrh	r3, [fp, #-14]
  12d65c:	e353007f 	cmp	r3, #127	; 0x7f
  12d660:	9afffff3 	bls	12d634 <dhcp_create_msg+0x3f0>
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  12d664:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d668:	e5932010 	ldr	r2, [r3, #16]
  12d66c:	e3a03000 	mov	r3, #0
  12d670:	e3833063 	orr	r3, r3, #99	; 0x63
  12d674:	e5c230ec 	strb	r3, [r2, #236]	; 0xec
  12d678:	e3a03000 	mov	r3, #0
  12d67c:	e1e03003 	mvn	r3, r3
  12d680:	e203307d 	and	r3, r3, #125	; 0x7d
  12d684:	e1e03003 	mvn	r3, r3
  12d688:	e5c230ed 	strb	r3, [r2, #237]	; 0xed
  12d68c:	e3a03000 	mov	r3, #0
  12d690:	e3833053 	orr	r3, r3, #83	; 0x53
  12d694:	e5c230ee 	strb	r3, [r2, #238]	; 0xee
  12d698:	e3a03000 	mov	r3, #0
  12d69c:	e3833063 	orr	r3, r3, #99	; 0x63
  12d6a0:	e5c230ef 	strb	r3, [r2, #239]	; 0xef
  dhcp->options_out_len = 0;
  12d6a4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d6a8:	e3a02000 	mov	r2, #0
  12d6ac:	e1c321b4 	strh	r2, [r3, #20]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  12d6b0:	e3a03000 	mov	r3, #0
  12d6b4:	e14b30be 	strh	r3, [fp, #-14]
  12d6b8:	ea00000a 	b	12d6e8 <dhcp_create_msg+0x4a4>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  12d6bc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12d6c0:	e5932010 	ldr	r2, [r3, #16]
  12d6c4:	e15b30be 	ldrh	r3, [fp, #-14]
  12d6c8:	e15b10be 	ldrh	r1, [fp, #-14]
  12d6cc:	e6ef1071 	uxtb	r1, r1
  12d6d0:	e0823003 	add	r3, r2, r3
  12d6d4:	e1a02001 	mov	r2, r1
  12d6d8:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  12d6dc:	e15b30be 	ldrh	r3, [fp, #-14]
  12d6e0:	e2833001 	add	r3, r3, #1
  12d6e4:	e14b30be 	strh	r3, [fp, #-14]
  12d6e8:	e15b30be 	ldrh	r3, [fp, #-14]
  12d6ec:	e3530043 	cmp	r3, #67	; 0x43
  12d6f0:	9afffff1 	bls	12d6bc <dhcp_create_msg+0x478>
  }
  /* Add option MESSAGE_TYPE */
  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  12d6f4:	e3a02001 	mov	r2, #1
  12d6f8:	e3a01035 	mov	r1, #53	; 0x35
  12d6fc:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  12d700:	ebfffab7 	bl	12c1e4 <dhcp_option>
  dhcp_option_byte(dhcp, message_type);
  12d704:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  12d708:	e1a01003 	mov	r1, r3
  12d70c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  12d710:	ebfffae3 	bl	12c2a4 <dhcp_option_byte>
  return ERR_OK;
  12d714:	e3a03000 	mov	r3, #0
}
  12d718:	e1a00003 	mov	r0, r3
  12d71c:	e24bd008 	sub	sp, fp, #8
  12d720:	e8bd8810 	pop	{r4, fp, pc}

0012d724 <dhcp_delete_msg>:
 *
 * @param dhcp the dhcp struct to free the request from
 */
static void
dhcp_delete_msg(struct dhcp *dhcp)
{
  12d724:	e92d4800 	push	{fp, lr}
  12d728:	e28db004 	add	fp, sp, #4
  12d72c:	e24dd008 	sub	sp, sp, #8
  12d730:	e50b0008 	str	r0, [fp, #-8]
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
  12d734:	e51b3008 	ldr	r3, [fp, #-8]
  12d738:	e3530000 	cmp	r3, #0
  12d73c:	1a000007 	bne	12d760 <dhcp_delete_msg+0x3c>
  12d740:	e3090364 	movw	r0, #37732	; 0x9364
  12d744:	e3400014 	movt	r0, #20
  12d748:	ebff5671 	bl	103114 <rt_kprintf>
  12d74c:	e300176e 	movw	r1, #1902	; 0x76e
  12d750:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d754:	e3400014 	movt	r0, #20
  12d758:	ebff7647 	bl	10b07c <sys_arch_assert>
  12d75c:	ea000023 	b	12d7f0 <dhcp_delete_msg+0xcc>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  12d760:	e51b3008 	ldr	r3, [fp, #-8]
  12d764:	e593300c 	ldr	r3, [r3, #12]
  12d768:	e3530000 	cmp	r3, #0
  12d76c:	1a000006 	bne	12d78c <dhcp_delete_msg+0x68>
  12d770:	e3090384 	movw	r0, #37764	; 0x9384
  12d774:	e3400014 	movt	r0, #20
  12d778:	ebff5665 	bl	103114 <rt_kprintf>
  12d77c:	e300176f 	movw	r1, #1903	; 0x76f
  12d780:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d784:	e3400014 	movt	r0, #20
  12d788:	ebff763b 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  12d78c:	e51b3008 	ldr	r3, [fp, #-8]
  12d790:	e5933010 	ldr	r3, [r3, #16]
  12d794:	e3530000 	cmp	r3, #0
  12d798:	1a000006 	bne	12d7b8 <dhcp_delete_msg+0x94>
  12d79c:	e30903ac 	movw	r0, #37804	; 0x93ac
  12d7a0:	e3400014 	movt	r0, #20
  12d7a4:	ebff565a 	bl	103114 <rt_kprintf>
  12d7a8:	e3a01e77 	mov	r1, #1904	; 0x770
  12d7ac:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d7b0:	e3400014 	movt	r0, #20
  12d7b4:	ebff7630 	bl	10b07c <sys_arch_assert>
  if (dhcp->p_out != NULL) {
  12d7b8:	e51b3008 	ldr	r3, [fp, #-8]
  12d7bc:	e593300c 	ldr	r3, [r3, #12]
  12d7c0:	e3530000 	cmp	r3, #0
  12d7c4:	0a000003 	beq	12d7d8 <dhcp_delete_msg+0xb4>
    pbuf_free(dhcp->p_out);
  12d7c8:	e51b3008 	ldr	r3, [fp, #-8]
  12d7cc:	e593300c 	ldr	r3, [r3, #12]
  12d7d0:	e1a00003 	mov	r0, r3
  12d7d4:	ebffb636 	bl	11b0b4 <pbuf_free>
  }
  dhcp->p_out = NULL;
  12d7d8:	e51b3008 	ldr	r3, [fp, #-8]
  12d7dc:	e3a02000 	mov	r2, #0
  12d7e0:	e583200c 	str	r2, [r3, #12]
  dhcp->msg_out = NULL;
  12d7e4:	e51b3008 	ldr	r3, [fp, #-8]
  12d7e8:	e3a02000 	mov	r2, #0
  12d7ec:	e5832010 	str	r2, [r3, #16]
}
  12d7f0:	e24bd004 	sub	sp, fp, #4
  12d7f4:	e8bd8800 	pop	{fp, pc}

0012d7f8 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  12d7f8:	e92d4800 	push	{fp, lr}
  12d7fc:	e28db004 	add	fp, sp, #4
  12d800:	e24dd008 	sub	sp, sp, #8
  12d804:	e50b0008 	str	r0, [fp, #-8]
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  12d808:	e51b3008 	ldr	r3, [fp, #-8]
  12d80c:	e3530000 	cmp	r3, #0
  12d810:	1a000007 	bne	12d834 <dhcp_option_trailer+0x3c>
  12d814:	e30903d4 	movw	r0, #37844	; 0x93d4
  12d818:	e3400014 	movt	r0, #20
  12d81c:	ebff563c 	bl	103114 <rt_kprintf>
  12d820:	e3001783 	movw	r1, #1923	; 0x783
  12d824:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d828:	e3400014 	movt	r0, #20
  12d82c:	ebff7612 	bl	10b07c <sys_arch_assert>
  12d830:	ea000039 	b	12d91c <dhcp_option_trailer+0x124>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  12d834:	e51b3008 	ldr	r3, [fp, #-8]
  12d838:	e5933010 	ldr	r3, [r3, #16]
  12d83c:	e3530000 	cmp	r3, #0
  12d840:	1a000006 	bne	12d860 <dhcp_option_trailer+0x68>
  12d844:	e30903f8 	movw	r0, #37880	; 0x93f8
  12d848:	e3400014 	movt	r0, #20
  12d84c:	ebff5630 	bl	103114 <rt_kprintf>
  12d850:	e3001784 	movw	r1, #1924	; 0x784
  12d854:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d858:	e3400014 	movt	r0, #20
  12d85c:	ebff7606 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  12d860:	e51b3008 	ldr	r3, [fp, #-8]
  12d864:	e1d331b4 	ldrh	r3, [r3, #20]
  12d868:	e3530043 	cmp	r3, #67	; 0x43
  12d86c:	9a000006 	bls	12d88c <dhcp_option_trailer+0x94>
  12d870:	e3090424 	movw	r0, #37924	; 0x9424
  12d874:	e3400014 	movt	r0, #20
  12d878:	ebff5625 	bl	103114 <rt_kprintf>
  12d87c:	e3001785 	movw	r1, #1925	; 0x785
  12d880:	e3080f8c 	movw	r0, #36748	; 0x8f8c
  12d884:	e3400014 	movt	r0, #20
  12d888:	ebff75fb 	bl	10b07c <sys_arch_assert>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  12d88c:	e51b3008 	ldr	r3, [fp, #-8]
  12d890:	e5932010 	ldr	r2, [r3, #16]
  12d894:	e51b3008 	ldr	r3, [fp, #-8]
  12d898:	e1d331b4 	ldrh	r3, [r3, #20]
  12d89c:	e2831001 	add	r1, r3, #1
  12d8a0:	e6ff0071 	uxth	r0, r1
  12d8a4:	e51b1008 	ldr	r1, [fp, #-8]
  12d8a8:	e1c101b4 	strh	r0, [r1, #20]
  12d8ac:	e0823003 	add	r3, r2, r3
  12d8b0:	e3e02000 	mvn	r2, #0
  12d8b4:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
  12d8b8:	ea00000a 	b	12d8e8 <dhcp_option_trailer+0xf0>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  12d8bc:	e51b3008 	ldr	r3, [fp, #-8]
  12d8c0:	e5932010 	ldr	r2, [r3, #16]
  12d8c4:	e51b3008 	ldr	r3, [fp, #-8]
  12d8c8:	e1d331b4 	ldrh	r3, [r3, #20]
  12d8cc:	e2831001 	add	r1, r3, #1
  12d8d0:	e6ff0071 	uxth	r0, r1
  12d8d4:	e51b1008 	ldr	r1, [fp, #-8]
  12d8d8:	e1c101b4 	strh	r0, [r1, #20]
  12d8dc:	e0823003 	add	r3, r2, r3
  12d8e0:	e3a02000 	mov	r2, #0
  12d8e4:	e5c320f0 	strb	r2, [r3, #240]	; 0xf0
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
  12d8e8:	e51b3008 	ldr	r3, [fp, #-8]
  12d8ec:	e1d331b4 	ldrh	r3, [r3, #20]
  12d8f0:	e3530043 	cmp	r3, #67	; 0x43
  12d8f4:	9a000004 	bls	12d90c <dhcp_option_trailer+0x114>
  12d8f8:	e51b3008 	ldr	r3, [fp, #-8]
  12d8fc:	e1d331b4 	ldrh	r3, [r3, #20]
  12d900:	e2033003 	and	r3, r3, #3
  12d904:	e3530000 	cmp	r3, #0
  12d908:	0a000003 	beq	12d91c <dhcp_option_trailer+0x124>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
  12d90c:	e51b3008 	ldr	r3, [fp, #-8]
  12d910:	e1d331b4 	ldrh	r3, [r3, #20]
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
  12d914:	e3530043 	cmp	r3, #67	; 0x43
  12d918:	9affffe7 	bls	12d8bc <dhcp_option_trailer+0xc4>
  }
}
  12d91c:	e24bd004 	sub	sp, fp, #4
  12d920:	e8bd8800 	pop	{fp, pc}

0012d924 <dhcp_supplied_address>:
 * @return 1 if DHCP supplied netif->ip_addr (states BOUND or RENEWING),
 *         0 otherwise
 */
u8_t
dhcp_supplied_address(const struct netif *netif)
{
  12d924:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  12d928:	e28db000 	add	fp, sp, #0
  12d92c:	e24dd014 	sub	sp, sp, #20
  12d930:	e50b0010 	str	r0, [fp, #-16]
  if ((netif != NULL) && (netif_dhcp_data(netif) != NULL)) {
  12d934:	e51b3010 	ldr	r3, [fp, #-16]
  12d938:	e3530000 	cmp	r3, #0
  12d93c:	0a000013 	beq	12d990 <dhcp_supplied_address+0x6c>
  12d940:	e51b3010 	ldr	r3, [fp, #-16]
  12d944:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12d948:	e3530000 	cmp	r3, #0
  12d94c:	0a00000f 	beq	12d990 <dhcp_supplied_address+0x6c>
    struct dhcp* dhcp = netif_dhcp_data(netif);
  12d950:	e51b3010 	ldr	r3, [fp, #-16]
  12d954:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  12d958:	e50b3008 	str	r3, [fp, #-8]
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING);
  12d95c:	e51b3008 	ldr	r3, [fp, #-8]
  12d960:	e5d33009 	ldrb	r3, [r3, #9]
  12d964:	e353000a 	cmp	r3, #10
  12d968:	0a000003 	beq	12d97c <dhcp_supplied_address+0x58>
  12d96c:	e51b3008 	ldr	r3, [fp, #-8]
  12d970:	e5d33009 	ldrb	r3, [r3, #9]
  12d974:	e3530005 	cmp	r3, #5
  12d978:	1a000001 	bne	12d984 <dhcp_supplied_address+0x60>
  12d97c:	e3a03001 	mov	r3, #1
  12d980:	ea000000 	b	12d988 <dhcp_supplied_address+0x64>
  12d984:	e3a03000 	mov	r3, #0
  12d988:	e6ef3073 	uxtb	r3, r3
  12d98c:	ea000000 	b	12d994 <dhcp_supplied_address+0x70>
  }
  return 0;
  12d990:	e3a03000 	mov	r3, #0
}
  12d994:	e1a00003 	mov	r0, r3
  12d998:	e28bd000 	add	sp, fp, #0
  12d99c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  12d9a0:	e12fff1e 	bx	lr

0012d9a4 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  12d9a4:	e92d4800 	push	{fp, lr}
  12d9a8:	e28db004 	add	fp, sp, #4
  12d9ac:	e24dd010 	sub	sp, sp, #16
  12d9b0:	e50b0010 	str	r0, [fp, #-16]
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  12d9b4:	e51b3010 	ldr	r3, [fp, #-16]
  12d9b8:	e3530000 	cmp	r3, #0
  12d9bc:	1a000006 	bne	12d9dc <free_etharp_q+0x38>
  12d9c0:	e3090464 	movw	r0, #37988	; 0x9464
  12d9c4:	e3400014 	movt	r0, #20
  12d9c8:	ebff55d1 	bl	103114 <rt_kprintf>
  12d9cc:	e3a01097 	mov	r1, #151	; 0x97
  12d9d0:	e3090470 	movw	r0, #38000	; 0x9470
  12d9d4:	e3400014 	movt	r0, #20
  12d9d8:	ebff75a7 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  12d9dc:	e51b3010 	ldr	r3, [fp, #-16]
  12d9e0:	e5933004 	ldr	r3, [r3, #4]
  12d9e4:	e3530000 	cmp	r3, #0
  12d9e8:	1a00001e 	bne	12da68 <free_etharp_q+0xc4>
  12d9ec:	e30904a4 	movw	r0, #38052	; 0x94a4
  12d9f0:	e3400014 	movt	r0, #20
  12d9f4:	ebff55c6 	bl	103114 <rt_kprintf>
  12d9f8:	e3a01098 	mov	r1, #152	; 0x98
  12d9fc:	e3090470 	movw	r0, #38000	; 0x9470
  12da00:	e3400014 	movt	r0, #20
  12da04:	ebff759c 	bl	10b07c <sys_arch_assert>
  while (q) {
  12da08:	ea000016 	b	12da68 <free_etharp_q+0xc4>
    r = q;
  12da0c:	e51b3010 	ldr	r3, [fp, #-16]
  12da10:	e50b3008 	str	r3, [fp, #-8]
    q = q->next;
  12da14:	e51b3010 	ldr	r3, [fp, #-16]
  12da18:	e5933000 	ldr	r3, [r3]
  12da1c:	e50b3010 	str	r3, [fp, #-16]
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  12da20:	e51b3008 	ldr	r3, [fp, #-8]
  12da24:	e5933004 	ldr	r3, [r3, #4]
  12da28:	e3530000 	cmp	r3, #0
  12da2c:	1a000006 	bne	12da4c <free_etharp_q+0xa8>
  12da30:	e30904b4 	movw	r0, #38068	; 0x94b4
  12da34:	e3400014 	movt	r0, #20
  12da38:	ebff55b5 	bl	103114 <rt_kprintf>
  12da3c:	e3a0109c 	mov	r1, #156	; 0x9c
  12da40:	e3090470 	movw	r0, #38000	; 0x9470
  12da44:	e3400014 	movt	r0, #20
  12da48:	ebff758b 	bl	10b07c <sys_arch_assert>
    pbuf_free(r->p);
  12da4c:	e51b3008 	ldr	r3, [fp, #-8]
  12da50:	e5933004 	ldr	r3, [r3, #4]
  12da54:	e1a00003 	mov	r0, r3
  12da58:	ebffb595 	bl	11b0b4 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  12da5c:	e51b1008 	ldr	r1, [fp, #-8]
  12da60:	e3a0000b 	mov	r0, #11
  12da64:	ebffae84 	bl	11947c <memp_free>
  while (q) {
  12da68:	e51b3010 	ldr	r3, [fp, #-16]
  12da6c:	e3530000 	cmp	r3, #0
  12da70:	1affffe5 	bne	12da0c <free_etharp_q+0x68>
  }
}
  12da74:	e320f000 	nop	{0}
  12da78:	e24bd004 	sub	sp, fp, #4
  12da7c:	e8bd8800 	pop	{fp, pc}

0012da80 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
  12da80:	e92d4800 	push	{fp, lr}
  12da84:	e28db004 	add	fp, sp, #4
  12da88:	e24dd008 	sub	sp, sp, #8
  12da8c:	e50b0008 	str	r0, [fp, #-8]
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
  12da90:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12da94:	e3403014 	movt	r3, #20
  12da98:	e51b2008 	ldr	r2, [fp, #-8]
  12da9c:	e3a01018 	mov	r1, #24
  12daa0:	e0020291 	mul	r2, r1, r2
  12daa4:	e0833002 	add	r3, r3, r2
  12daa8:	e5933000 	ldr	r3, [r3]
  12daac:	e3530000 	cmp	r3, #0
  12dab0:	0a000010 	beq	12daf8 <etharp_free_entry+0x78>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  12dab4:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dab8:	e3403014 	movt	r3, #20
  12dabc:	e51b2008 	ldr	r2, [fp, #-8]
  12dac0:	e3a01018 	mov	r1, #24
  12dac4:	e0020291 	mul	r2, r1, r2
  12dac8:	e0833002 	add	r3, r3, r2
  12dacc:	e5933000 	ldr	r3, [r3]
  12dad0:	e1a00003 	mov	r0, r3
  12dad4:	ebffffb2 	bl	12d9a4 <free_etharp_q>
    arp_table[i].q = NULL;
  12dad8:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dadc:	e3403014 	movt	r3, #20
  12dae0:	e51b2008 	ldr	r2, [fp, #-8]
  12dae4:	e3a01018 	mov	r1, #24
  12dae8:	e0020291 	mul	r2, r1, r2
  12daec:	e0833002 	add	r3, r3, r2
  12daf0:	e3a02000 	mov	r2, #0
  12daf4:	e5832000 	str	r2, [r3]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  12daf8:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dafc:	e3403014 	movt	r3, #20
  12db00:	e51b2008 	ldr	r2, [fp, #-8]
  12db04:	e3a01018 	mov	r1, #24
  12db08:	e0020291 	mul	r2, r1, r2
  12db0c:	e0833002 	add	r3, r3, r2
  12db10:	e2833014 	add	r3, r3, #20
  12db14:	e3a02000 	mov	r2, #0
  12db18:	e5c32000 	strb	r2, [r3]
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip4_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
  12db1c:	e320f000 	nop	{0}
  12db20:	e24bd004 	sub	sp, fp, #4
  12db24:	e8bd8800 	pop	{fp, pc}

0012db28 <etharp_tmr>:
 * This function should be called every ARP_TMR_INTERVAL milliseconds (1 second),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  12db28:	e92d4800 	push	{fp, lr}
  12db2c:	e28db004 	add	fp, sp, #4
  12db30:	e24dd008 	sub	sp, sp, #8
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  12db34:	e3a03000 	mov	r3, #0
  12db38:	e54b3005 	strb	r3, [fp, #-5]
  12db3c:	ea000084 	b	12dd54 <etharp_tmr+0x22c>
    u8_t state = arp_table[i].state;
  12db40:	e55b2005 	ldrb	r2, [fp, #-5]
  12db44:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12db48:	e3403014 	movt	r3, #20
  12db4c:	e3a01018 	mov	r1, #24
  12db50:	e0020291 	mul	r2, r1, r2
  12db54:	e0833002 	add	r3, r3, r2
  12db58:	e2833014 	add	r3, r3, #20
  12db5c:	e5d33000 	ldrb	r3, [r3]
  12db60:	e54b3006 	strb	r3, [fp, #-6]
    if (state != ETHARP_STATE_EMPTY
  12db64:	e55b3006 	ldrb	r3, [fp, #-6]
  12db68:	e3530000 	cmp	r3, #0
  12db6c:	0a000075 	beq	12dd48 <etharp_tmr+0x220>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
  12db70:	e55b2005 	ldrb	r2, [fp, #-5]
  12db74:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12db78:	e3403014 	movt	r3, #20
  12db7c:	e3a01018 	mov	r1, #24
  12db80:	e0010291 	mul	r1, r1, r2
  12db84:	e0833001 	add	r3, r3, r1
  12db88:	e2833012 	add	r3, r3, #18
  12db8c:	e1d330b0 	ldrh	r3, [r3]
  12db90:	e2833001 	add	r3, r3, #1
  12db94:	e6ff1073 	uxth	r1, r3
  12db98:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12db9c:	e3403014 	movt	r3, #20
  12dba0:	e3a00018 	mov	r0, #24
  12dba4:	e0020290 	mul	r2, r0, r2
  12dba8:	e0833002 	add	r3, r3, r2
  12dbac:	e2833012 	add	r3, r3, #18
  12dbb0:	e1c310b0 	strh	r1, [r3]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
  12dbb4:	e55b2005 	ldrb	r2, [fp, #-5]
  12dbb8:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dbbc:	e3403014 	movt	r3, #20
  12dbc0:	e3a01018 	mov	r1, #24
  12dbc4:	e0020291 	mul	r2, r1, r2
  12dbc8:	e0833002 	add	r3, r3, r2
  12dbcc:	e2833012 	add	r3, r3, #18
  12dbd0:	e1d330b0 	ldrh	r3, [r3]
  12dbd4:	e3530f4b 	cmp	r3, #300	; 0x12c
  12dbd8:	2a000013 	bcs	12dc2c <etharp_tmr+0x104>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  12dbdc:	e55b2005 	ldrb	r2, [fp, #-5]
  12dbe0:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dbe4:	e3403014 	movt	r3, #20
  12dbe8:	e3a01018 	mov	r1, #24
  12dbec:	e0020291 	mul	r2, r1, r2
  12dbf0:	e0833002 	add	r3, r3, r2
  12dbf4:	e2833014 	add	r3, r3, #20
  12dbf8:	e5d33000 	ldrb	r3, [r3]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
  12dbfc:	e3530001 	cmp	r3, #1
  12dc00:	1a00000d 	bne	12dc3c <etharp_tmr+0x114>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
  12dc04:	e55b2005 	ldrb	r2, [fp, #-5]
  12dc08:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dc0c:	e3403014 	movt	r3, #20
  12dc10:	e3a01018 	mov	r1, #24
  12dc14:	e0020291 	mul	r2, r1, r2
  12dc18:	e0833002 	add	r3, r3, r2
  12dc1c:	e2833012 	add	r3, r3, #18
  12dc20:	e1d330b0 	ldrh	r3, [r3]
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  12dc24:	e3530004 	cmp	r3, #4
  12dc28:	9a000003 	bls	12dc3c <etharp_tmr+0x114>
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
  12dc2c:	e55b3005 	ldrb	r3, [fp, #-5]
  12dc30:	e1a00003 	mov	r0, r3
  12dc34:	ebffff91 	bl	12da80 <etharp_free_entry>
  12dc38:	ea000042 	b	12dd48 <etharp_tmr+0x220>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
  12dc3c:	e55b2005 	ldrb	r2, [fp, #-5]
  12dc40:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dc44:	e3403014 	movt	r3, #20
  12dc48:	e3a01018 	mov	r1, #24
  12dc4c:	e0020291 	mul	r2, r1, r2
  12dc50:	e0833002 	add	r3, r3, r2
  12dc54:	e2833014 	add	r3, r3, #20
  12dc58:	e5d33000 	ldrb	r3, [r3]
  12dc5c:	e3530003 	cmp	r3, #3
  12dc60:	1a000009 	bne	12dc8c <etharp_tmr+0x164>
        /* Don't send more than one request every 2 seconds. */
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
  12dc64:	e55b2005 	ldrb	r2, [fp, #-5]
  12dc68:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dc6c:	e3403014 	movt	r3, #20
  12dc70:	e3a01018 	mov	r1, #24
  12dc74:	e0020291 	mul	r2, r1, r2
  12dc78:	e0833002 	add	r3, r3, r2
  12dc7c:	e2833014 	add	r3, r3, #20
  12dc80:	e3a02004 	mov	r2, #4
  12dc84:	e5c32000 	strb	r2, [r3]
  12dc88:	ea00002e 	b	12dd48 <etharp_tmr+0x220>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
  12dc8c:	e55b2005 	ldrb	r2, [fp, #-5]
  12dc90:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dc94:	e3403014 	movt	r3, #20
  12dc98:	e3a01018 	mov	r1, #24
  12dc9c:	e0020291 	mul	r2, r1, r2
  12dca0:	e0833002 	add	r3, r3, r2
  12dca4:	e2833014 	add	r3, r3, #20
  12dca8:	e5d33000 	ldrb	r3, [r3]
  12dcac:	e3530004 	cmp	r3, #4
  12dcb0:	1a000009 	bne	12dcdc <etharp_tmr+0x1b4>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
  12dcb4:	e55b2005 	ldrb	r2, [fp, #-5]
  12dcb8:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dcbc:	e3403014 	movt	r3, #20
  12dcc0:	e3a01018 	mov	r1, #24
  12dcc4:	e0020291 	mul	r2, r1, r2
  12dcc8:	e0833002 	add	r3, r3, r2
  12dccc:	e2833014 	add	r3, r3, #20
  12dcd0:	e3a02002 	mov	r2, #2
  12dcd4:	e5c32000 	strb	r2, [r3]
  12dcd8:	ea00001a 	b	12dd48 <etharp_tmr+0x220>
      } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  12dcdc:	e55b2005 	ldrb	r2, [fp, #-5]
  12dce0:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dce4:	e3403014 	movt	r3, #20
  12dce8:	e3a01018 	mov	r1, #24
  12dcec:	e0020291 	mul	r2, r1, r2
  12dcf0:	e0833002 	add	r3, r3, r2
  12dcf4:	e2833014 	add	r3, r3, #20
  12dcf8:	e5d33000 	ldrb	r3, [r3]
  12dcfc:	e3530001 	cmp	r3, #1
  12dd00:	1a000010 	bne	12dd48 <etharp_tmr+0x220>
        /* still pending, resend an ARP query */
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
  12dd04:	e55b2005 	ldrb	r2, [fp, #-5]
  12dd08:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dd0c:	e3403014 	movt	r3, #20
  12dd10:	e3a01018 	mov	r1, #24
  12dd14:	e0020291 	mul	r2, r1, r2
  12dd18:	e0833002 	add	r3, r3, r2
  12dd1c:	e2833008 	add	r3, r3, #8
  12dd20:	e5930000 	ldr	r0, [r3]
  12dd24:	e55b3005 	ldrb	r3, [fp, #-5]
  12dd28:	e3a02018 	mov	r2, #24
  12dd2c:	e0020392 	mul	r2, r2, r3
  12dd30:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dd34:	e3403014 	movt	r3, #20
  12dd38:	e0823003 	add	r3, r2, r3
  12dd3c:	e2833004 	add	r3, r3, #4
  12dd40:	e1a01003 	mov	r1, r3
  12dd44:	eb00066b 	bl	12f6f8 <etharp_request>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  12dd48:	e55b3005 	ldrb	r3, [fp, #-5]
  12dd4c:	e2833001 	add	r3, r3, #1
  12dd50:	e54b3005 	strb	r3, [fp, #-5]
  12dd54:	e55b3005 	ldrb	r3, [fp, #-5]
  12dd58:	e3530009 	cmp	r3, #9
  12dd5c:	9affff77 	bls	12db40 <etharp_tmr+0x18>
      }
    }
  }
}
  12dd60:	e320f000 	nop	{0}
  12dd64:	e24bd004 	sub	sp, fp, #4
  12dd68:	e8bd8800 	pop	{fp, pc}

0012dd6c <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif* netif)
{
  12dd6c:	e92d4800 	push	{fp, lr}
  12dd70:	e28db004 	add	fp, sp, #4
  12dd74:	e24dd020 	sub	sp, sp, #32
  12dd78:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12dd7c:	e1a03001 	mov	r3, r1
  12dd80:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  12dd84:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  12dd88:	e3a0300a 	mov	r3, #10
  12dd8c:	e54b3005 	strb	r3, [fp, #-5]
  12dd90:	e3a0300a 	mov	r3, #10
  12dd94:	e54b3006 	strb	r3, [fp, #-6]
  s8_t empty = ARP_TABLE_SIZE;
  12dd98:	e3a0300a 	mov	r3, #10
  12dd9c:	e54b3007 	strb	r3, [fp, #-7]
  u8_t i = 0;
  12dda0:	e3a03000 	mov	r3, #0
  12dda4:	e54b3008 	strb	r3, [fp, #-8]
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  12dda8:	e3a0300a 	mov	r3, #10
  12ddac:	e54b3009 	strb	r3, [fp, #-9]
  /* its age */
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
  12ddb0:	e3a03000 	mov	r3, #0
  12ddb4:	e14b30bc 	strh	r3, [fp, #-12]
  12ddb8:	e3a03000 	mov	r3, #0
  12ddbc:	e14b30be 	strh	r3, [fp, #-14]
  12ddc0:	e3a03000 	mov	r3, #0
  12ddc4:	e14b31b0 	strh	r3, [fp, #-16]
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  12ddc8:	e3a03000 	mov	r3, #0
  12ddcc:	e54b3008 	strb	r3, [fp, #-8]
  12ddd0:	ea000088 	b	12dff8 <etharp_find_entry+0x28c>
    u8_t state = arp_table[i].state;
  12ddd4:	e55b2008 	ldrb	r2, [fp, #-8]
  12ddd8:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dddc:	e3403014 	movt	r3, #20
  12dde0:	e3a01018 	mov	r1, #24
  12dde4:	e0020291 	mul	r2, r1, r2
  12dde8:	e0833002 	add	r3, r3, r2
  12ddec:	e2833014 	add	r3, r3, #20
  12ddf0:	e5d33000 	ldrb	r3, [r3]
  12ddf4:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
  12ddf8:	e15b30d7 	ldrsb	r3, [fp, #-7]
  12ddfc:	e353000a 	cmp	r3, #10
  12de00:	1a000005 	bne	12de1c <etharp_find_entry+0xb0>
  12de04:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  12de08:	e3530000 	cmp	r3, #0
  12de0c:	1a000002 	bne	12de1c <etharp_find_entry+0xb0>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  12de10:	e55b3008 	ldrb	r3, [fp, #-8]
  12de14:	e54b3007 	strb	r3, [fp, #-7]
  12de18:	ea000073 	b	12dfec <etharp_find_entry+0x280>
    } else if (state != ETHARP_STATE_EMPTY) {
  12de1c:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  12de20:	e3530000 	cmp	r3, #0
  12de24:	0a000070 	beq	12dfec <etharp_find_entry+0x280>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
  12de28:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  12de2c:	e3530001 	cmp	r3, #1
  12de30:	0a000009 	beq	12de5c <etharp_find_entry+0xf0>
  12de34:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  12de38:	e3530001 	cmp	r3, #1
  12de3c:	8a000006 	bhi	12de5c <etharp_find_entry+0xf0>
  12de40:	e30904c4 	movw	r0, #38084	; 0x94c4
  12de44:	e3400014 	movt	r0, #20
  12de48:	ebff54b1 	bl	103114 <rt_kprintf>
  12de4c:	e3001126 	movw	r1, #294	; 0x126
  12de50:	e3090470 	movw	r0, #38000	; 0x9470
  12de54:	e3400014 	movt	r0, #20
  12de58:	ebff7487 	bl	10b07c <sys_arch_assert>
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
  12de5c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12de60:	e3530000 	cmp	r3, #0
  12de64:	0a00000d 	beq	12dea0 <etharp_find_entry+0x134>
  12de68:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12de6c:	e5932000 	ldr	r2, [r3]
  12de70:	e55b1008 	ldrb	r1, [fp, #-8]
  12de74:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12de78:	e3403014 	movt	r3, #20
  12de7c:	e3a00018 	mov	r0, #24
  12de80:	e0010190 	mul	r1, r0, r1
  12de84:	e0833001 	add	r3, r3, r1
  12de88:	e2833004 	add	r3, r3, #4
  12de8c:	e5933000 	ldr	r3, [r3]
  12de90:	e1520003 	cmp	r2, r3
  12de94:	1a000001 	bne	12dea0 <etharp_find_entry+0x134>
          && ((netif == NULL) || (netif == arp_table[i].netif))
#endif /* ETHARP_TABLE_MATCH_NETIF */
        ) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
  12de98:	e15b30d8 	ldrsb	r3, [fp, #-8]
  12de9c:	ea0000ce 	b	12e1dc <etharp_find_entry+0x470>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
  12dea0:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  12dea4:	e3530001 	cmp	r3, #1
  12dea8:	1a000036 	bne	12df88 <etharp_find_entry+0x21c>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
  12deac:	e55b2008 	ldrb	r2, [fp, #-8]
  12deb0:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12deb4:	e3403014 	movt	r3, #20
  12deb8:	e3a01018 	mov	r1, #24
  12debc:	e0020291 	mul	r2, r1, r2
  12dec0:	e0833002 	add	r3, r3, r2
  12dec4:	e5933000 	ldr	r3, [r3]
  12dec8:	e3530000 	cmp	r3, #0
  12decc:	0a000016 	beq	12df2c <etharp_find_entry+0x1c0>
          if (arp_table[i].ctime >= age_queue) {
  12ded0:	e55b2008 	ldrb	r2, [fp, #-8]
  12ded4:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ded8:	e3403014 	movt	r3, #20
  12dedc:	e3a01018 	mov	r1, #24
  12dee0:	e0020291 	mul	r2, r1, r2
  12dee4:	e0833002 	add	r3, r3, r2
  12dee8:	e2833012 	add	r3, r3, #18
  12deec:	e1d330b0 	ldrh	r3, [r3]
  12def0:	e15b20bc 	ldrh	r2, [fp, #-12]
  12def4:	e1520003 	cmp	r2, r3
  12def8:	8a00003b 	bhi	12dfec <etharp_find_entry+0x280>
            old_queue = i;
  12defc:	e55b3008 	ldrb	r3, [fp, #-8]
  12df00:	e54b3009 	strb	r3, [fp, #-9]
            age_queue = arp_table[i].ctime;
  12df04:	e55b2008 	ldrb	r2, [fp, #-8]
  12df08:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12df0c:	e3403014 	movt	r3, #20
  12df10:	e3a01018 	mov	r1, #24
  12df14:	e0020291 	mul	r2, r1, r2
  12df18:	e0833002 	add	r3, r3, r2
  12df1c:	e2833012 	add	r3, r3, #18
  12df20:	e1d330b0 	ldrh	r3, [r3]
  12df24:	e14b30bc 	strh	r3, [fp, #-12]
  12df28:	ea00002f 	b	12dfec <etharp_find_entry+0x280>
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
  12df2c:	e55b2008 	ldrb	r2, [fp, #-8]
  12df30:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12df34:	e3403014 	movt	r3, #20
  12df38:	e3a01018 	mov	r1, #24
  12df3c:	e0020291 	mul	r2, r1, r2
  12df40:	e0833002 	add	r3, r3, r2
  12df44:	e2833012 	add	r3, r3, #18
  12df48:	e1d330b0 	ldrh	r3, [r3]
  12df4c:	e15b20be 	ldrh	r2, [fp, #-14]
  12df50:	e1520003 	cmp	r2, r3
  12df54:	8a000024 	bhi	12dfec <etharp_find_entry+0x280>
            old_pending = i;
  12df58:	e55b3008 	ldrb	r3, [fp, #-8]
  12df5c:	e54b3005 	strb	r3, [fp, #-5]
            age_pending = arp_table[i].ctime;
  12df60:	e55b2008 	ldrb	r2, [fp, #-8]
  12df64:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12df68:	e3403014 	movt	r3, #20
  12df6c:	e3a01018 	mov	r1, #24
  12df70:	e0020291 	mul	r2, r1, r2
  12df74:	e0833002 	add	r3, r3, r2
  12df78:	e2833012 	add	r3, r3, #18
  12df7c:	e1d330b0 	ldrh	r3, [r3]
  12df80:	e14b30be 	strh	r3, [fp, #-14]
  12df84:	ea000018 	b	12dfec <etharp_find_entry+0x280>
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
  12df88:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  12df8c:	e3530001 	cmp	r3, #1
  12df90:	9a000015 	bls	12dfec <etharp_find_entry+0x280>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
  12df94:	e55b2008 	ldrb	r2, [fp, #-8]
  12df98:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12df9c:	e3403014 	movt	r3, #20
  12dfa0:	e3a01018 	mov	r1, #24
  12dfa4:	e0020291 	mul	r2, r1, r2
  12dfa8:	e0833002 	add	r3, r3, r2
  12dfac:	e2833012 	add	r3, r3, #18
  12dfb0:	e1d330b0 	ldrh	r3, [r3]
  12dfb4:	e15b21b0 	ldrh	r2, [fp, #-16]
  12dfb8:	e1520003 	cmp	r2, r3
  12dfbc:	8a00000a 	bhi	12dfec <etharp_find_entry+0x280>
            old_stable = i;
  12dfc0:	e55b3008 	ldrb	r3, [fp, #-8]
  12dfc4:	e54b3006 	strb	r3, [fp, #-6]
            age_stable = arp_table[i].ctime;
  12dfc8:	e55b2008 	ldrb	r2, [fp, #-8]
  12dfcc:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12dfd0:	e3403014 	movt	r3, #20
  12dfd4:	e3a01018 	mov	r1, #24
  12dfd8:	e0020291 	mul	r2, r1, r2
  12dfdc:	e0833002 	add	r3, r3, r2
  12dfe0:	e2833012 	add	r3, r3, #18
  12dfe4:	e1d330b0 	ldrh	r3, [r3]
  12dfe8:	e14b31b0 	strh	r3, [fp, #-16]
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  12dfec:	e55b3008 	ldrb	r3, [fp, #-8]
  12dff0:	e2833001 	add	r3, r3, #1
  12dff4:	e54b3008 	strb	r3, [fp, #-8]
  12dff8:	e55b3008 	ldrb	r3, [fp, #-8]
  12dffc:	e3530009 	cmp	r3, #9
  12e000:	9affff73 	bls	12ddd4 <etharp_find_entry+0x68>
    }
  }
  /* { we have no match } => try to create a new entry */

  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
  12e004:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
  12e008:	e2033002 	and	r3, r3, #2
  12e00c:	e3530000 	cmp	r3, #0
  12e010:	1a000006 	bne	12e030 <etharp_find_entry+0x2c4>
  12e014:	e15b30d7 	ldrsb	r3, [fp, #-7]
  12e018:	e353000a 	cmp	r3, #10
  12e01c:	1a000005 	bne	12e038 <etharp_find_entry+0x2cc>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
  12e020:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
  12e024:	e2033001 	and	r3, r3, #1
  12e028:	e3530000 	cmp	r3, #0
  12e02c:	1a000001 	bne	12e038 <etharp_find_entry+0x2cc>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  12e030:	e3e03000 	mvn	r3, #0
  12e034:	ea000068 	b	12e1dc <etharp_find_entry+0x470>
   *
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  12e038:	e15b30d7 	ldrsb	r3, [fp, #-7]
  12e03c:	e3530009 	cmp	r3, #9
  12e040:	ca000002 	bgt	12e050 <etharp_find_entry+0x2e4>
    i = empty;
  12e044:	e55b3007 	ldrb	r3, [fp, #-7]
  12e048:	e54b3008 	strb	r3, [fp, #-8]
  12e04c:	ea000030 	b	12e114 <etharp_find_entry+0x3a8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
  12e050:	e15b30d6 	ldrsb	r3, [fp, #-6]
  12e054:	e3530009 	cmp	r3, #9
  12e058:	ca000012 	bgt	12e0a8 <etharp_find_entry+0x33c>
      /* recycle oldest stable*/
      i = old_stable;
  12e05c:	e55b3006 	ldrb	r3, [fp, #-6]
  12e060:	e54b3008 	strb	r3, [fp, #-8]
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  12e064:	e55b2008 	ldrb	r2, [fp, #-8]
  12e068:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e06c:	e3403014 	movt	r3, #20
  12e070:	e3a01018 	mov	r1, #24
  12e074:	e0020291 	mul	r2, r1, r2
  12e078:	e0833002 	add	r3, r3, r2
  12e07c:	e5933000 	ldr	r3, [r3]
  12e080:	e3530000 	cmp	r3, #0
  12e084:	0a000015 	beq	12e0e0 <etharp_find_entry+0x374>
  12e088:	e3090504 	movw	r0, #38148	; 0x9504
  12e08c:	e3400014 	movt	r0, #20
  12e090:	ebff541f 	bl	103114 <rt_kprintf>
  12e094:	e300116f 	movw	r1, #367	; 0x16f
  12e098:	e3090470 	movw	r0, #38000	; 0x9470
  12e09c:	e3400014 	movt	r0, #20
  12e0a0:	ebff73f5 	bl	10b07c <sys_arch_assert>
  12e0a4:	ea00000d 	b	12e0e0 <etharp_find_entry+0x374>
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
  12e0a8:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12e0ac:	e3530009 	cmp	r3, #9
  12e0b0:	ca000002 	bgt	12e0c0 <etharp_find_entry+0x354>
      /* recycle oldest pending */
      i = old_pending;
  12e0b4:	e55b3005 	ldrb	r3, [fp, #-5]
  12e0b8:	e54b3008 	strb	r3, [fp, #-8]
  12e0bc:	ea000007 	b	12e0e0 <etharp_find_entry+0x374>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
  12e0c0:	e15b30d9 	ldrsb	r3, [fp, #-9]
  12e0c4:	e3530009 	cmp	r3, #9
  12e0c8:	ca000002 	bgt	12e0d8 <etharp_find_entry+0x36c>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
  12e0cc:	e55b3009 	ldrb	r3, [fp, #-9]
  12e0d0:	e54b3008 	strb	r3, [fp, #-8]
  12e0d4:	ea000001 	b	12e0e0 <etharp_find_entry+0x374>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
  12e0d8:	e3e03000 	mvn	r3, #0
  12e0dc:	ea00003e 	b	12e1dc <etharp_find_entry+0x470>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  12e0e0:	e55b3008 	ldrb	r3, [fp, #-8]
  12e0e4:	e3530009 	cmp	r3, #9
  12e0e8:	9a000006 	bls	12e108 <etharp_find_entry+0x39c>
  12e0ec:	e309051c 	movw	r0, #38172	; 0x951c
  12e0f0:	e3400014 	movt	r0, #20
  12e0f4:	ebff5406 	bl	103114 <rt_kprintf>
  12e0f8:	e3001181 	movw	r1, #385	; 0x181
  12e0fc:	e3090470 	movw	r0, #38000	; 0x9470
  12e100:	e3400014 	movt	r0, #20
  12e104:	ebff73dc 	bl	10b07c <sys_arch_assert>
    etharp_free_entry(i);
  12e108:	e55b3008 	ldrb	r3, [fp, #-8]
  12e10c:	e1a00003 	mov	r0, r3
  12e110:	ebfffe5a 	bl	12da80 <etharp_free_entry>
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  12e114:	e55b3008 	ldrb	r3, [fp, #-8]
  12e118:	e3530009 	cmp	r3, #9
  12e11c:	9a000006 	bls	12e13c <etharp_find_entry+0x3d0>
  12e120:	e309051c 	movw	r0, #38172	; 0x951c
  12e124:	e3400014 	movt	r0, #20
  12e128:	ebff53f9 	bl	103114 <rt_kprintf>
  12e12c:	e3001185 	movw	r1, #389	; 0x185
  12e130:	e3090470 	movw	r0, #38000	; 0x9470
  12e134:	e3400014 	movt	r0, #20
  12e138:	ebff73cf 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
  12e13c:	e55b2008 	ldrb	r2, [fp, #-8]
  12e140:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e144:	e3403014 	movt	r3, #20
  12e148:	e3a01018 	mov	r1, #24
  12e14c:	e0020291 	mul	r2, r1, r2
  12e150:	e0833002 	add	r3, r3, r2
  12e154:	e2833014 	add	r3, r3, #20
  12e158:	e5d33000 	ldrb	r3, [r3]
  12e15c:	e3530000 	cmp	r3, #0
  12e160:	0a000006 	beq	12e180 <etharp_find_entry+0x414>
  12e164:	e3090530 	movw	r0, #38192	; 0x9530
  12e168:	e3400014 	movt	r0, #20
  12e16c:	ebff53e8 	bl	103114 <rt_kprintf>
  12e170:	e3001187 	movw	r1, #391	; 0x187
  12e174:	e3090470 	movw	r0, #38000	; 0x9470
  12e178:	e3400014 	movt	r0, #20
  12e17c:	ebff73be 	bl	10b07c <sys_arch_assert>
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
  12e180:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12e184:	e3530000 	cmp	r3, #0
  12e188:	0a000009 	beq	12e1b4 <etharp_find_entry+0x448>
    /* set IP address */
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
  12e18c:	e55b1008 	ldrb	r1, [fp, #-8]
  12e190:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12e194:	e5932000 	ldr	r2, [r3]
  12e198:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e19c:	e3403014 	movt	r3, #20
  12e1a0:	e3a00018 	mov	r0, #24
  12e1a4:	e0010190 	mul	r1, r0, r1
  12e1a8:	e0833001 	add	r3, r3, r1
  12e1ac:	e2833004 	add	r3, r3, #4
  12e1b0:	e5832000 	str	r2, [r3]
  }
  arp_table[i].ctime = 0;
  12e1b4:	e55b2008 	ldrb	r2, [fp, #-8]
  12e1b8:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e1bc:	e3403014 	movt	r3, #20
  12e1c0:	e3a01018 	mov	r1, #24
  12e1c4:	e0020291 	mul	r2, r1, r2
  12e1c8:	e0833002 	add	r3, r3, r2
  12e1cc:	e2833012 	add	r3, r3, #18
  12e1d0:	e3a02000 	mov	r2, #0
  12e1d4:	e1c320b0 	strh	r2, [r3]
#if ETHARP_TABLE_MATCH_NETIF
  arp_table[i].netif = netif;
#endif /* ETHARP_TABLE_MATCH_NETIF*/
  return (err_t)i;
  12e1d8:	e15b30d8 	ldrsb	r3, [fp, #-8]
}
  12e1dc:	e1a00003 	mov	r0, r3
  12e1e0:	e24bd004 	sub	sp, fp, #4
  12e1e4:	e8bd8800 	pop	{fp, pc}

0012e1e8 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  12e1e8:	e92d4800 	push	{fp, lr}
  12e1ec:	e28db004 	add	fp, sp, #4
  12e1f0:	e24dd028 	sub	sp, sp, #40	; 0x28
  12e1f4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12e1f8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  12e1fc:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  12e200:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
  12e204:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12e208:	e5d3303a 	ldrb	r3, [r3, #58]	; 0x3a
  12e20c:	e3530006 	cmp	r3, #6
  12e210:	0a000006 	beq	12e230 <etharp_update_arp_entry+0x48>
  12e214:	e309055c 	movw	r0, #38236	; 0x955c
  12e218:	e3400014 	movt	r0, #20
  12e21c:	ebff53bc 	bl	103114 <rt_kprintf>
  12e220:	e30011ab 	movw	r1, #427	; 0x1ab
  12e224:	e3090470 	movw	r0, #38000	; 0x9470
  12e228:	e3400014 	movt	r0, #20
  12e22c:	ebff7392 	bl	10b07c <sys_arch_assert>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
    (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
  12e230:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e234:	e3530000 	cmp	r3, #0
  12e238:	0a000010 	beq	12e280 <etharp_update_arp_entry+0x98>
  12e23c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e240:	e5933000 	ldr	r3, [r3]
  12e244:	e3530000 	cmp	r3, #0
  12e248:	0a00000c 	beq	12e280 <etharp_update_arp_entry+0x98>
      ip4_addr_isbroadcast(ipaddr, netif) ||
  12e24c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e250:	e5933000 	ldr	r3, [r3]
  12e254:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  12e258:	e1a00003 	mov	r0, r3
  12e25c:	eb00112a 	bl	13270c <ip4_addr_isbroadcast_u32>
  12e260:	e1a03000 	mov	r3, r0
  if (ip4_addr_isany(ipaddr) ||
  12e264:	e3530000 	cmp	r3, #0
  12e268:	1a000004 	bne	12e280 <etharp_update_arp_entry+0x98>
      ip4_addr_ismulticast(ipaddr)) {
  12e26c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e270:	e5933000 	ldr	r3, [r3]
  12e274:	e20330f0 	and	r3, r3, #240	; 0xf0
      ip4_addr_isbroadcast(ipaddr, netif) ||
  12e278:	e35300e0 	cmp	r3, #224	; 0xe0
  12e27c:	1a000001 	bne	12e288 <etharp_update_arp_entry+0xa0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  12e280:	e3e0300f 	mvn	r3, #15
  12e284:	ea00005e 	b	12e404 <etharp_update_arp_entry+0x21c>
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags, netif);
  12e288:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
  12e28c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  12e290:	e1a01003 	mov	r1, r3
  12e294:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  12e298:	ebfffeb3 	bl	12dd6c <etharp_find_entry>
  12e29c:	e1a03000 	mov	r3, r0
  12e2a0:	e54b3005 	strb	r3, [fp, #-5]
  /* bail out if no entry could be found */
  if (i < 0) {
  12e2a4:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12e2a8:	e3530000 	cmp	r3, #0
  12e2ac:	aa000001 	bge	12e2b8 <etharp_update_arp_entry+0xd0>
    return (err_t)i;
  12e2b0:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12e2b4:	ea000052 	b	12e404 <etharp_update_arp_entry+0x21c>
    return ERR_VAL;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
  12e2b8:	e15b20d5 	ldrsb	r2, [fp, #-5]
  12e2bc:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e2c0:	e3403014 	movt	r3, #20
  12e2c4:	e3a01018 	mov	r1, #24
  12e2c8:	e0020291 	mul	r2, r1, r2
  12e2cc:	e0833002 	add	r3, r3, r2
  12e2d0:	e2833014 	add	r3, r3, #20
  12e2d4:	e3a02002 	mov	r2, #2
  12e2d8:	e5c32000 	strb	r2, [r3]
  }

  /* record network interface */
  arp_table[i].netif = netif;
  12e2dc:	e15b20d5 	ldrsb	r2, [fp, #-5]
  12e2e0:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e2e4:	e3403014 	movt	r3, #20
  12e2e8:	e3a01018 	mov	r1, #24
  12e2ec:	e0020291 	mul	r2, r1, r2
  12e2f0:	e0833002 	add	r3, r3, r2
  12e2f4:	e2833008 	add	r3, r3, #8
  12e2f8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  12e2fc:	e5832000 	str	r2, [r3]
  /* insert in SNMP ARP index tree */
  mib2_add_arp_entry(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  12e300:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12e304:	e3a02018 	mov	r2, #24
  12e308:	e0030392 	mul	r3, r2, r3
  12e30c:	e2832008 	add	r2, r3, #8
  12e310:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e314:	e3403014 	movt	r3, #20
  12e318:	e0823003 	add	r3, r2, r3
  12e31c:	e2833004 	add	r3, r3, #4
  12e320:	e3a02006 	mov	r2, #6
  12e324:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  12e328:	e1a00003 	mov	r0, r3
  12e32c:	eb004b18 	bl	140f94 <memcpy>
  /* reset time stamp */
  arp_table[i].ctime = 0;
  12e330:	e15b20d5 	ldrsb	r2, [fp, #-5]
  12e334:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e338:	e3403014 	movt	r3, #20
  12e33c:	e3a01018 	mov	r1, #24
  12e340:	e0020291 	mul	r2, r1, r2
  12e344:	e0833002 	add	r3, r3, r2
  12e348:	e2833012 	add	r3, r3, #18
  12e34c:	e3a02000 	mov	r2, #0
  12e350:	e1c320b0 	strh	r2, [r3]
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
  12e354:	ea000020 	b	12e3dc <etharp_update_arp_entry+0x1f4>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
  12e358:	e15b20d5 	ldrsb	r2, [fp, #-5]
  12e35c:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e360:	e3403014 	movt	r3, #20
  12e364:	e3a01018 	mov	r1, #24
  12e368:	e0020291 	mul	r2, r1, r2
  12e36c:	e0833002 	add	r3, r3, r2
  12e370:	e5933000 	ldr	r3, [r3]
  12e374:	e50b300c 	str	r3, [fp, #-12]
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  12e378:	e15b10d5 	ldrsb	r1, [fp, #-5]
  12e37c:	e51b300c 	ldr	r3, [fp, #-12]
  12e380:	e5932000 	ldr	r2, [r3]
  12e384:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e388:	e3403014 	movt	r3, #20
  12e38c:	e3a00018 	mov	r0, #24
  12e390:	e0010190 	mul	r1, r0, r1
  12e394:	e0833001 	add	r3, r3, r1
  12e398:	e5832000 	str	r2, [r3]
    /* get the packet pointer */
    p = q->p;
  12e39c:	e51b300c 	ldr	r3, [fp, #-12]
  12e3a0:	e5933004 	ldr	r3, [r3, #4]
  12e3a4:	e50b3010 	str	r3, [fp, #-16]
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  12e3a8:	e51b100c 	ldr	r1, [fp, #-12]
  12e3ac:	e3a0000b 	mov	r0, #11
  12e3b0:	ebffac31 	bl	11947c <memp_free>
  if (arp_table[i].q != NULL) {
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    ethernet_output(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr, ETHTYPE_IP);
  12e3b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12e3b8:	e283203b 	add	r2, r3, #59	; 0x3b
  12e3bc:	e3a03b02 	mov	r3, #2048	; 0x800
  12e3c0:	e58d3000 	str	r3, [sp]
  12e3c4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12e3c8:	e51b1010 	ldr	r1, [fp, #-16]
  12e3cc:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12e3d0:	ebffeb48 	bl	1290f8 <ethernet_output>
    /* free the queued IP packet */
    pbuf_free(p);
  12e3d4:	e51b0010 	ldr	r0, [fp, #-16]
  12e3d8:	ebffb335 	bl	11b0b4 <pbuf_free>
  while (arp_table[i].q != NULL) {
  12e3dc:	e15b20d5 	ldrsb	r2, [fp, #-5]
  12e3e0:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e3e4:	e3403014 	movt	r3, #20
  12e3e8:	e3a01018 	mov	r1, #24
  12e3ec:	e0020291 	mul	r2, r1, r2
  12e3f0:	e0833002 	add	r3, r3, r2
  12e3f4:	e5933000 	ldr	r3, [r3]
  12e3f8:	e3530000 	cmp	r3, #0
  12e3fc:	1affffd5 	bne	12e358 <etharp_update_arp_entry+0x170>
  }
  return ERR_OK;
  12e400:	e3a03000 	mov	r3, #0
}
  12e404:	e1a00003 	mov	r0, r3
  12e408:	e24bd004 	sub	sp, fp, #4
  12e40c:	e8bd8800 	pop	{fp, pc}

0012e410 <etharp_cleanup_netif>:
 *
 * @param netif points to a network interface
 */
void
etharp_cleanup_netif(struct netif *netif)
{
  12e410:	e92d4800 	push	{fp, lr}
  12e414:	e28db004 	add	fp, sp, #4
  12e418:	e24dd010 	sub	sp, sp, #16
  12e41c:	e50b0010 	str	r0, [fp, #-16]
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  12e420:	e3a03000 	mov	r3, #0
  12e424:	e54b3005 	strb	r3, [fp, #-5]
  12e428:	ea00001c 	b	12e4a0 <etharp_cleanup_netif+0x90>
    u8_t state = arp_table[i].state;
  12e42c:	e55b2005 	ldrb	r2, [fp, #-5]
  12e430:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e434:	e3403014 	movt	r3, #20
  12e438:	e3a01018 	mov	r1, #24
  12e43c:	e0020291 	mul	r2, r1, r2
  12e440:	e0833002 	add	r3, r3, r2
  12e444:	e2833014 	add	r3, r3, #20
  12e448:	e5d33000 	ldrb	r3, [r3]
  12e44c:	e54b3006 	strb	r3, [fp, #-6]
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
  12e450:	e55b3006 	ldrb	r3, [fp, #-6]
  12e454:	e3530000 	cmp	r3, #0
  12e458:	0a00000d 	beq	12e494 <etharp_cleanup_netif+0x84>
  12e45c:	e55b2005 	ldrb	r2, [fp, #-5]
  12e460:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e464:	e3403014 	movt	r3, #20
  12e468:	e3a01018 	mov	r1, #24
  12e46c:	e0020291 	mul	r2, r1, r2
  12e470:	e0833002 	add	r3, r3, r2
  12e474:	e2833008 	add	r3, r3, #8
  12e478:	e5933000 	ldr	r3, [r3]
  12e47c:	e51b2010 	ldr	r2, [fp, #-16]
  12e480:	e1520003 	cmp	r2, r3
  12e484:	1a000002 	bne	12e494 <etharp_cleanup_netif+0x84>
      etharp_free_entry(i);
  12e488:	e55b3005 	ldrb	r3, [fp, #-5]
  12e48c:	e1a00003 	mov	r0, r3
  12e490:	ebfffd7a 	bl	12da80 <etharp_free_entry>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  12e494:	e55b3005 	ldrb	r3, [fp, #-5]
  12e498:	e2833001 	add	r3, r3, #1
  12e49c:	e54b3005 	strb	r3, [fp, #-5]
  12e4a0:	e55b3005 	ldrb	r3, [fp, #-5]
  12e4a4:	e3530009 	cmp	r3, #9
  12e4a8:	9affffdf 	bls	12e42c <etharp_cleanup_netif+0x1c>
    }
  }
}
  12e4ac:	e320f000 	nop	{0}
  12e4b0:	e24bd004 	sub	sp, fp, #4
  12e4b4:	e8bd8800 	pop	{fp, pc}

0012e4b8 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, const ip4_addr_t *ipaddr,
         struct eth_addr **eth_ret, const ip4_addr_t **ip_ret)
{
  12e4b8:	e92d4800 	push	{fp, lr}
  12e4bc:	e28db004 	add	fp, sp, #4
  12e4c0:	e24dd018 	sub	sp, sp, #24
  12e4c4:	e50b0010 	str	r0, [fp, #-16]
  12e4c8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  12e4cc:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  12e4d0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  s8_t i;

  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
  12e4d4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12e4d8:	e3530000 	cmp	r3, #0
  12e4dc:	0a000002 	beq	12e4ec <etharp_find_addr+0x34>
  12e4e0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e4e4:	e3530000 	cmp	r3, #0
  12e4e8:	1a000006 	bne	12e508 <etharp_find_addr+0x50>
  12e4ec:	e3090580 	movw	r0, #38272	; 0x9580
  12e4f0:	e3400014 	movt	r0, #20
  12e4f4:	ebff5306 	bl	103114 <rt_kprintf>
  12e4f8:	e300124d 	movw	r1, #589	; 0x24d
  12e4fc:	e3090470 	movw	r0, #38000	; 0x9470
  12e500:	e3400014 	movt	r0, #20
  12e504:	ebff72dc 	bl	10b07c <sys_arch_assert>
    eth_ret != NULL && ip_ret != NULL);

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY, netif);
  12e508:	e51b2010 	ldr	r2, [fp, #-16]
  12e50c:	e3a01002 	mov	r1, #2
  12e510:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  12e514:	ebfffe14 	bl	12dd6c <etharp_find_entry>
  12e518:	e1a03000 	mov	r3, r0
  12e51c:	e54b3005 	strb	r3, [fp, #-5]
  if ((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
  12e520:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12e524:	e3530000 	cmp	r3, #0
  12e528:	ba00001e 	blt	12e5a8 <etharp_find_addr+0xf0>
  12e52c:	e15b20d5 	ldrsb	r2, [fp, #-5]
  12e530:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e534:	e3403014 	movt	r3, #20
  12e538:	e3a01018 	mov	r1, #24
  12e53c:	e0020291 	mul	r2, r1, r2
  12e540:	e0833002 	add	r3, r3, r2
  12e544:	e2833014 	add	r3, r3, #20
  12e548:	e5d33000 	ldrb	r3, [r3]
  12e54c:	e3530001 	cmp	r3, #1
  12e550:	9a000014 	bls	12e5a8 <etharp_find_addr+0xf0>
      *eth_ret = &arp_table[i].ethaddr;
  12e554:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12e558:	e3a02018 	mov	r2, #24
  12e55c:	e0030392 	mul	r3, r2, r3
  12e560:	e2832008 	add	r2, r3, #8
  12e564:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e568:	e3403014 	movt	r3, #20
  12e56c:	e0823003 	add	r3, r2, r3
  12e570:	e2832004 	add	r2, r3, #4
  12e574:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12e578:	e5832000 	str	r2, [r3]
      *ip_ret = &arp_table[i].ipaddr;
  12e57c:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12e580:	e3a02018 	mov	r2, #24
  12e584:	e0020392 	mul	r2, r2, r3
  12e588:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e58c:	e3403014 	movt	r3, #20
  12e590:	e0823003 	add	r3, r2, r3
  12e594:	e2832004 	add	r2, r3, #4
  12e598:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e59c:	e5832000 	str	r2, [r3]
      return i;
  12e5a0:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12e5a4:	ea000000 	b	12e5ac <etharp_find_addr+0xf4>
  }
  return -1;
  12e5a8:	e3e03000 	mvn	r3, #0
}
  12e5ac:	e1a00003 	mov	r0, r3
  12e5b0:	e24bd004 	sub	sp, fp, #4
  12e5b4:	e8bd8800 	pop	{fp, pc}

0012e5b8 <etharp_get_entry>:
 * @param eth_ret return value: ETH address
 * @return 1 on valid index, 0 otherwise
 */
u8_t
etharp_get_entry(u8_t i, ip4_addr_t **ipaddr, struct netif **netif, struct eth_addr **eth_ret)
{
  12e5b8:	e92d4800 	push	{fp, lr}
  12e5bc:	e28db004 	add	fp, sp, #4
  12e5c0:	e24dd010 	sub	sp, sp, #16
  12e5c4:	e50b100c 	str	r1, [fp, #-12]
  12e5c8:	e50b2010 	str	r2, [fp, #-16]
  12e5cc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  12e5d0:	e1a03000 	mov	r3, r0
  12e5d4:	e54b3005 	strb	r3, [fp, #-5]
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
  12e5d8:	e51b300c 	ldr	r3, [fp, #-12]
  12e5dc:	e3530000 	cmp	r3, #0
  12e5e0:	1a000006 	bne	12e600 <etharp_get_entry+0x48>
  12e5e4:	e30905a4 	movw	r0, #38308	; 0x95a4
  12e5e8:	e3400014 	movt	r0, #20
  12e5ec:	ebff52c8 	bl	103114 <rt_kprintf>
  12e5f0:	e3001266 	movw	r1, #614	; 0x266
  12e5f4:	e3090470 	movw	r0, #38000	; 0x9470
  12e5f8:	e3400014 	movt	r0, #20
  12e5fc:	ebff729e 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("netif != NULL", netif != NULL);
  12e600:	e51b3010 	ldr	r3, [fp, #-16]
  12e604:	e3530000 	cmp	r3, #0
  12e608:	1a000006 	bne	12e628 <etharp_get_entry+0x70>
  12e60c:	e30905b4 	movw	r0, #38324	; 0x95b4
  12e610:	e3400014 	movt	r0, #20
  12e614:	ebff52be 	bl	103114 <rt_kprintf>
  12e618:	e3001267 	movw	r1, #615	; 0x267
  12e61c:	e3090470 	movw	r0, #38000	; 0x9470
  12e620:	e3400014 	movt	r0, #20
  12e624:	ebff7294 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
  12e628:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12e62c:	e3530000 	cmp	r3, #0
  12e630:	1a000006 	bne	12e650 <etharp_get_entry+0x98>
  12e634:	e30905c4 	movw	r0, #38340	; 0x95c4
  12e638:	e3400014 	movt	r0, #20
  12e63c:	ebff52b4 	bl	103114 <rt_kprintf>
  12e640:	e3a01f9a 	mov	r1, #616	; 0x268
  12e644:	e3090470 	movw	r0, #38000	; 0x9470
  12e648:	e3400014 	movt	r0, #20
  12e64c:	ebff728a 	bl	10b07c <sys_arch_assert>

  if((i < ARP_TABLE_SIZE) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
  12e650:	e55b3005 	ldrb	r3, [fp, #-5]
  12e654:	e3530009 	cmp	r3, #9
  12e658:	8a000028 	bhi	12e700 <etharp_get_entry+0x148>
  12e65c:	e55b2005 	ldrb	r2, [fp, #-5]
  12e660:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e664:	e3403014 	movt	r3, #20
  12e668:	e3a01018 	mov	r1, #24
  12e66c:	e0020291 	mul	r2, r1, r2
  12e670:	e0833002 	add	r3, r3, r2
  12e674:	e2833014 	add	r3, r3, #20
  12e678:	e5d33000 	ldrb	r3, [r3]
  12e67c:	e3530001 	cmp	r3, #1
  12e680:	9a00001e 	bls	12e700 <etharp_get_entry+0x148>
    *ipaddr  = &arp_table[i].ipaddr;
  12e684:	e55b3005 	ldrb	r3, [fp, #-5]
  12e688:	e3a02018 	mov	r2, #24
  12e68c:	e0020392 	mul	r2, r2, r3
  12e690:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e694:	e3403014 	movt	r3, #20
  12e698:	e0823003 	add	r3, r2, r3
  12e69c:	e2832004 	add	r2, r3, #4
  12e6a0:	e51b300c 	ldr	r3, [fp, #-12]
  12e6a4:	e5832000 	str	r2, [r3]
    *netif   = arp_table[i].netif;
  12e6a8:	e55b2005 	ldrb	r2, [fp, #-5]
  12e6ac:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e6b0:	e3403014 	movt	r3, #20
  12e6b4:	e3a01018 	mov	r1, #24
  12e6b8:	e0020291 	mul	r2, r1, r2
  12e6bc:	e0833002 	add	r3, r3, r2
  12e6c0:	e2833008 	add	r3, r3, #8
  12e6c4:	e5932000 	ldr	r2, [r3]
  12e6c8:	e51b3010 	ldr	r3, [fp, #-16]
  12e6cc:	e5832000 	str	r2, [r3]
    *eth_ret = &arp_table[i].ethaddr;
  12e6d0:	e55b3005 	ldrb	r3, [fp, #-5]
  12e6d4:	e3a02018 	mov	r2, #24
  12e6d8:	e0030392 	mul	r3, r2, r3
  12e6dc:	e2832008 	add	r2, r3, #8
  12e6e0:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e6e4:	e3403014 	movt	r3, #20
  12e6e8:	e0823003 	add	r3, r2, r3
  12e6ec:	e2832004 	add	r2, r3, #4
  12e6f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12e6f4:	e5832000 	str	r2, [r3]
    return 1;
  12e6f8:	e3a03001 	mov	r3, #1
  12e6fc:	ea000000 	b	12e704 <etharp_get_entry+0x14c>
  } else {
    return 0;
  12e700:	e3a03000 	mov	r3, #0
  }
}
  12e704:	e1a00003 	mov	r0, r3
  12e708:	e24bd004 	sub	sp, fp, #4
  12e70c:	e8bd8800 	pop	{fp, pc}

0012e710 <etharp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_input(struct pbuf *p, struct netif *netif)
{
  12e710:	e92d4800 	push	{fp, lr}
  12e714:	e28db004 	add	fp, sp, #4
  12e718:	e24dd028 	sub	sp, sp, #40	; 0x28
  12e71c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12e720:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  struct etharp_hdr *hdr;
  /* these are aligned properly, whereas the ARP header fields might not be */
  ip4_addr_t sipaddr, dipaddr;
  u8_t for_us;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  12e724:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e728:	e3530000 	cmp	r3, #0
  12e72c:	1a000007 	bne	12e750 <etharp_input+0x40>
  12e730:	e30905b4 	movw	r0, #38324	; 0x95b4
  12e734:	e3400014 	movt	r0, #20
  12e738:	ebff5275 	bl	103114 <rt_kprintf>
  12e73c:	e3a01fa2 	mov	r1, #648	; 0x288
  12e740:	e3090470 	movw	r0, #38000	; 0x9470
  12e744:	e3400014 	movt	r0, #20
  12e748:	ebff724b 	bl	10b07c <sys_arch_assert>
  12e74c:	ea000085 	b	12e968 <etharp_input+0x258>

  hdr = (struct etharp_hdr *)p->payload;
  12e750:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12e754:	e5933004 	ldr	r3, [r3, #4]
  12e758:	e50b300c 	str	r3, [fp, #-12]

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
  12e75c:	e51b300c 	ldr	r3, [fp, #-12]
  12e760:	e1d330b0 	ldrh	r3, [r3]
  12e764:	e6ff3073 	uxth	r3, r3
  12e768:	e3530c01 	cmp	r3, #256	; 0x100
  12e76c:	1a00000c 	bne	12e7a4 <etharp_input+0x94>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
  12e770:	e51b300c 	ldr	r3, [fp, #-12]
  12e774:	e5d33004 	ldrb	r3, [r3, #4]
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
  12e778:	e3530006 	cmp	r3, #6
  12e77c:	1a000008 	bne	12e7a4 <etharp_input+0x94>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
  12e780:	e51b300c 	ldr	r3, [fp, #-12]
  12e784:	e5d33005 	ldrb	r3, [r3, #5]
      (hdr->hwlen != ETH_HWADDR_LEN) ||
  12e788:	e3530004 	cmp	r3, #4
  12e78c:	1a000004 	bne	12e7a4 <etharp_input+0x94>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
  12e790:	e51b300c 	ldr	r3, [fp, #-12]
  12e794:	e1d330b2 	ldrh	r3, [r3, #2]
  12e798:	e6ff3073 	uxth	r3, r3
      (hdr->protolen != sizeof(ip4_addr_t)) ||
  12e79c:	e3530008 	cmp	r3, #8
  12e7a0:	0a000012 	beq	12e7f0 <etharp_input+0xe0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, (u16_t)hdr->hwlen, hdr->proto, (u16_t)hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
  12e7a4:	e3063840 	movw	r3, #26688	; 0x6840
  12e7a8:	e3403057 	movt	r3, #87	; 0x57
  12e7ac:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
  12e7b0:	e2833001 	add	r3, r3, #1
  12e7b4:	e6ff2073 	uxth	r2, r3
  12e7b8:	e3063840 	movw	r3, #26688	; 0x6840
  12e7bc:	e3403057 	movt	r3, #87	; 0x57
  12e7c0:	e1c322b8 	strh	r2, [r3, #40]	; 0x28
    ETHARP_STATS_INC(etharp.drop);
  12e7c4:	e3063840 	movw	r3, #26688	; 0x6840
  12e7c8:	e3403057 	movt	r3, #87	; 0x57
  12e7cc:	e1d331be 	ldrh	r3, [r3, #30]
  12e7d0:	e2833001 	add	r3, r3, #1
  12e7d4:	e6ff2073 	uxth	r2, r3
  12e7d8:	e3063840 	movw	r3, #26688	; 0x6840
  12e7dc:	e3403057 	movt	r3, #87	; 0x57
  12e7e0:	e1c321be 	strh	r2, [r3, #30]
    pbuf_free(p);
  12e7e4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12e7e8:	ebffb231 	bl	11b0b4 <pbuf_free>
    return;
  12e7ec:	ea00005d 	b	12e968 <etharp_input+0x258>
  }
  ETHARP_STATS_INC(etharp.recv);
  12e7f0:	e3063840 	movw	r3, #26688	; 0x6840
  12e7f4:	e3403057 	movt	r3, #87	; 0x57
  12e7f8:	e1d331ba 	ldrh	r3, [r3, #26]
  12e7fc:	e2833001 	add	r3, r3, #1
  12e800:	e6ff2073 	uxth	r2, r3
  12e804:	e3063840 	movw	r3, #26688	; 0x6840
  12e808:	e3403057 	movt	r3, #87	; 0x57
  12e80c:	e1c321ba 	strh	r2, [r3, #26]
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip4_addr2 to aligned ip4_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
  12e810:	e51b300c 	ldr	r3, [fp, #-12]
  12e814:	e283300e 	add	r3, r3, #14
  12e818:	e5933000 	ldr	r3, [r3]
  12e81c:	e50b3010 	str	r3, [fp, #-16]
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
  12e820:	e51b300c 	ldr	r3, [fp, #-12]
  12e824:	e2833018 	add	r3, r3, #24
  12e828:	e5933000 	ldr	r3, [r3]
  12e82c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

  /* this interface is not configured? */
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
  12e830:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e834:	e2833004 	add	r3, r3, #4
  12e838:	e5933000 	ldr	r3, [r3]
  12e83c:	e3530000 	cmp	r3, #0
  12e840:	1a000002 	bne	12e850 <etharp_input+0x140>
    for_us = 0;
  12e844:	e3a03000 	mov	r3, #0
  12e848:	e54b3005 	strb	r3, [fp, #-5]
  12e84c:	ea000008 	b	12e874 <etharp_input+0x164>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
  12e850:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  12e854:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e858:	e2833004 	add	r3, r3, #4
  12e85c:	e5933000 	ldr	r3, [r3]
  12e860:	e1520003 	cmp	r2, r3
  12e864:	03a03001 	moveq	r3, #1
  12e868:	13a03000 	movne	r3, #0
  12e86c:	e6ef3073 	uxtb	r3, r3
  12e870:	e54b3005 	strb	r3, [fp, #-5]
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
  12e874:	e51b300c 	ldr	r3, [fp, #-12]
  12e878:	e2832008 	add	r2, r3, #8
  12e87c:	e55b3005 	ldrb	r3, [fp, #-5]
  12e880:	e3530000 	cmp	r3, #0
  12e884:	0a000001 	beq	12e890 <etharp_input+0x180>
  12e888:	e3a03001 	mov	r3, #1
  12e88c:	ea000000 	b	12e894 <etharp_input+0x184>
  12e890:	e3a03002 	mov	r3, #2
  12e894:	e24b1010 	sub	r1, fp, #16
  12e898:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  12e89c:	ebfffe51 	bl	12e1e8 <etharp_update_arp_entry>
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
  12e8a0:	e51b300c 	ldr	r3, [fp, #-12]
  12e8a4:	e1d330b6 	ldrh	r3, [r3, #6]
  12e8a8:	e6ff3073 	uxth	r3, r3
  12e8ac:	e3530c01 	cmp	r3, #256	; 0x100
  12e8b0:	0a000002 	beq	12e8c0 <etharp_input+0x1b0>
  12e8b4:	e3530c02 	cmp	r3, #512	; 0x200
  12e8b8:	0a000019 	beq	12e924 <etharp_input+0x214>
  12e8bc:	ea00001d 	b	12e938 <etharp_input+0x228>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possibly send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  12e8c0:	e55b3005 	ldrb	r3, [fp, #-5]
  12e8c4:	e3530000 	cmp	r3, #0
  12e8c8:	0a000023 	beq	12e95c <etharp_input+0x24c>
      /* send ARP response */
      etharp_raw(netif,
                 (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
  12e8cc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e8d0:	e283003b 	add	r0, r3, #59	; 0x3b
  12e8d4:	e51b300c 	ldr	r3, [fp, #-12]
  12e8d8:	e283c008 	add	ip, r3, #8
                 (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
  12e8dc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e8e0:	e283e03b 	add	lr, r3, #59	; 0x3b
  12e8e4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12e8e8:	e2833004 	add	r3, r3, #4
                 &hdr->shwaddr, &sipaddr,
  12e8ec:	e51b200c 	ldr	r2, [fp, #-12]
  12e8f0:	e2822008 	add	r2, r2, #8
      etharp_raw(netif,
  12e8f4:	e3a01002 	mov	r1, #2
  12e8f8:	e58d100c 	str	r1, [sp, #12]
  12e8fc:	e24b1010 	sub	r1, fp, #16
  12e900:	e58d1008 	str	r1, [sp, #8]
  12e904:	e58d2004 	str	r2, [sp, #4]
  12e908:	e58d3000 	str	r3, [sp]
  12e90c:	e1a0300e 	mov	r3, lr
  12e910:	e1a0200c 	mov	r2, ip
  12e914:	e1a01000 	mov	r1, r0
  12e918:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  12e91c:	eb0002d5 	bl	12f478 <etharp_raw>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP request was not for us.\n"));
    }
    break;
  12e920:	ea00000d 	b	12e95c <etharp_input+0x24c>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  12e924:	e24b3010 	sub	r3, fp, #16
  12e928:	e1a01003 	mov	r1, r3
  12e92c:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  12e930:	ebfff256 	bl	12b290 <dhcp_arp_reply>
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
  12e934:	ea000009 	b	12e960 <etharp_input+0x250>
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP unknown opcode type %"S16_F"\n", lwip_htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
  12e938:	e3063840 	movw	r3, #26688	; 0x6840
  12e93c:	e3403057 	movt	r3, #87	; 0x57
  12e940:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
  12e944:	e2833001 	add	r3, r3, #1
  12e948:	e6ff2073 	uxth	r2, r3
  12e94c:	e3063840 	movw	r3, #26688	; 0x6840
  12e950:	e3403057 	movt	r3, #87	; 0x57
  12e954:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
    break;
  12e958:	ea000000 	b	12e960 <etharp_input+0x250>
    break;
  12e95c:	e320f000 	nop	{0}
  }
  /* free ARP packet */
  pbuf_free(p);
  12e960:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12e964:	ebffb1d2 	bl	11b0b4 <pbuf_free>
}
  12e968:	e24bd004 	sub	sp, fp, #4
  12e96c:	e8bd8800 	pop	{fp, pc}

0012e970 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
  12e970:	e92d4800 	push	{fp, lr}
  12e974:	e28db004 	add	fp, sp, #4
  12e978:	e24dd018 	sub	sp, sp, #24
  12e97c:	e50b0008 	str	r0, [fp, #-8]
  12e980:	e50b100c 	str	r1, [fp, #-12]
  12e984:	e1a03002 	mov	r3, r2
  12e988:	e54b300d 	strb	r3, [fp, #-13]
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
  12e98c:	e55b200d 	ldrb	r2, [fp, #-13]
  12e990:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e994:	e3403014 	movt	r3, #20
  12e998:	e3a01018 	mov	r1, #24
  12e99c:	e0020291 	mul	r2, r1, r2
  12e9a0:	e0833002 	add	r3, r3, r2
  12e9a4:	e2833014 	add	r3, r3, #20
  12e9a8:	e5d33000 	ldrb	r3, [r3]
  12e9ac:	e3530001 	cmp	r3, #1
  12e9b0:	8a000006 	bhi	12e9d0 <etharp_output_to_arp_index+0x60>
  12e9b4:	e30905d4 	movw	r0, #38356	; 0x95d4
  12e9b8:	e3400014 	movt	r0, #20
  12e9bc:	ebff51d4 	bl	103114 <rt_kprintf>
  12e9c0:	e30012ed 	movw	r1, #749	; 0x2ed
  12e9c4:	e3090470 	movw	r0, #38000	; 0x9470
  12e9c8:	e3400014 	movt	r0, #20
  12e9cc:	ebff71aa 	bl	10b07c <sys_arch_assert>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
  12e9d0:	e55b200d 	ldrb	r2, [fp, #-13]
  12e9d4:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12e9d8:	e3403014 	movt	r3, #20
  12e9dc:	e3a01018 	mov	r1, #24
  12e9e0:	e0020291 	mul	r2, r1, r2
  12e9e4:	e0833002 	add	r3, r3, r2
  12e9e8:	e2833014 	add	r3, r3, #20
  12e9ec:	e5d33000 	ldrb	r3, [r3]
  12e9f0:	e3530002 	cmp	r3, #2
  12e9f4:	1a000049 	bne	12eb20 <etharp_output_to_arp_index+0x1b0>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
  12e9f8:	e55b200d 	ldrb	r2, [fp, #-13]
  12e9fc:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ea00:	e3403014 	movt	r3, #20
  12ea04:	e3a01018 	mov	r1, #24
  12ea08:	e0020291 	mul	r2, r1, r2
  12ea0c:	e0833002 	add	r3, r3, r2
  12ea10:	e2833012 	add	r3, r3, #18
  12ea14:	e1d330b0 	ldrh	r3, [r3]
  12ea18:	e3530f47 	cmp	r3, #284	; 0x11c
  12ea1c:	9a000016 	bls	12ea7c <etharp_output_to_arp_index+0x10c>
      /* issue a standard request using broadcast */
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
  12ea20:	e55b300d 	ldrb	r3, [fp, #-13]
  12ea24:	e3a02018 	mov	r2, #24
  12ea28:	e0020392 	mul	r2, r2, r3
  12ea2c:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ea30:	e3403014 	movt	r3, #20
  12ea34:	e0823003 	add	r3, r2, r3
  12ea38:	e2833004 	add	r3, r3, #4
  12ea3c:	e1a01003 	mov	r1, r3
  12ea40:	e51b0008 	ldr	r0, [fp, #-8]
  12ea44:	eb00032b 	bl	12f6f8 <etharp_request>
  12ea48:	e1a03000 	mov	r3, r0
  12ea4c:	e3530000 	cmp	r3, #0
  12ea50:	1a000032 	bne	12eb20 <etharp_output_to_arp_index+0x1b0>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
  12ea54:	e55b200d 	ldrb	r2, [fp, #-13]
  12ea58:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ea5c:	e3403014 	movt	r3, #20
  12ea60:	e3a01018 	mov	r1, #24
  12ea64:	e0020291 	mul	r2, r1, r2
  12ea68:	e0833002 	add	r3, r3, r2
  12ea6c:	e2833014 	add	r3, r3, #20
  12ea70:	e3a02003 	mov	r2, #3
  12ea74:	e5c32000 	strb	r2, [r3]
  12ea78:	ea000028 	b	12eb20 <etharp_output_to_arp_index+0x1b0>
      }
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
  12ea7c:	e55b200d 	ldrb	r2, [fp, #-13]
  12ea80:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ea84:	e3403014 	movt	r3, #20
  12ea88:	e3a01018 	mov	r1, #24
  12ea8c:	e0020291 	mul	r2, r1, r2
  12ea90:	e0833002 	add	r3, r3, r2
  12ea94:	e2833012 	add	r3, r3, #18
  12ea98:	e1d330b0 	ldrh	r3, [r3]
  12ea9c:	e300210d 	movw	r2, #269	; 0x10d
  12eaa0:	e1530002 	cmp	r3, r2
  12eaa4:	9a00001d 	bls	12eb20 <etharp_output_to_arp_index+0x1b0>
      /* issue a unicast request (for 15 seconds) to prevent unnecessary broadcast */
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
  12eaa8:	e55b300d 	ldrb	r3, [fp, #-13]
  12eaac:	e3a02018 	mov	r2, #24
  12eab0:	e0020392 	mul	r2, r2, r3
  12eab4:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12eab8:	e3403014 	movt	r3, #20
  12eabc:	e0823003 	add	r3, r2, r3
  12eac0:	e2831004 	add	r1, r3, #4
  12eac4:	e55b300d 	ldrb	r3, [fp, #-13]
  12eac8:	e3a02018 	mov	r2, #24
  12eacc:	e0030392 	mul	r3, r2, r3
  12ead0:	e2832008 	add	r2, r3, #8
  12ead4:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ead8:	e3403014 	movt	r3, #20
  12eadc:	e0823003 	add	r3, r2, r3
  12eae0:	e2833004 	add	r3, r3, #4
  12eae4:	e1a02003 	mov	r2, r3
  12eae8:	e51b0008 	ldr	r0, [fp, #-8]
  12eaec:	eb0002e5 	bl	12f688 <etharp_request_dst>
  12eaf0:	e1a03000 	mov	r3, r0
  12eaf4:	e3530000 	cmp	r3, #0
  12eaf8:	1a000008 	bne	12eb20 <etharp_output_to_arp_index+0x1b0>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
  12eafc:	e55b200d 	ldrb	r2, [fp, #-13]
  12eb00:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12eb04:	e3403014 	movt	r3, #20
  12eb08:	e3a01018 	mov	r1, #24
  12eb0c:	e0020291 	mul	r2, r1, r2
  12eb10:	e0833002 	add	r3, r3, r2
  12eb14:	e2833014 	add	r3, r3, #20
  12eb18:	e3a02003 	mov	r2, #3
  12eb1c:	e5c32000 	strb	r2, [r3]
      }
    }
  }

  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
  12eb20:	e51b3008 	ldr	r3, [fp, #-8]
  12eb24:	e283103b 	add	r1, r3, #59	; 0x3b
  12eb28:	e55b300d 	ldrb	r3, [fp, #-13]
  12eb2c:	e3a02018 	mov	r2, #24
  12eb30:	e0030392 	mul	r3, r2, r3
  12eb34:	e2832008 	add	r2, r3, #8
  12eb38:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12eb3c:	e3403014 	movt	r3, #20
  12eb40:	e0823003 	add	r3, r2, r3
  12eb44:	e2832004 	add	r2, r3, #4
  12eb48:	e3a03b02 	mov	r3, #2048	; 0x800
  12eb4c:	e58d3000 	str	r3, [sp]
  12eb50:	e1a03002 	mov	r3, r2
  12eb54:	e1a02001 	mov	r2, r1
  12eb58:	e51b100c 	ldr	r1, [fp, #-12]
  12eb5c:	e51b0008 	ldr	r0, [fp, #-8]
  12eb60:	ebffe964 	bl	1290f8 <ethernet_output>
  12eb64:	e1a03000 	mov	r3, r0
}
  12eb68:	e1a00003 	mov	r0, r3
  12eb6c:	e24bd004 	sub	sp, fp, #4
  12eb70:	e8bd8800 	pop	{fp, pc}

0012eb74 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or ethernet_output().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr)
{
  12eb74:	e92d4800 	push	{fp, lr}
  12eb78:	e28db004 	add	fp, sp, #4
  12eb7c:	e24dd028 	sub	sp, sp, #40	; 0x28
  12eb80:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12eb84:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  12eb88:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  const struct eth_addr *dest;
  struct eth_addr mcastaddr;
  const ip4_addr_t *dst_addr = ipaddr;
  12eb8c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12eb90:	e50b300c 	str	r3, [fp, #-12]

  LWIP_ASSERT("netif != NULL", netif != NULL);
  12eb94:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12eb98:	e3530000 	cmp	r3, #0
  12eb9c:	1a000006 	bne	12ebbc <etharp_output+0x48>
  12eba0:	e30905b4 	movw	r0, #38324	; 0x95b4
  12eba4:	e3400014 	movt	r0, #20
  12eba8:	ebff5159 	bl	103114 <rt_kprintf>
  12ebac:	e300131b 	movw	r1, #795	; 0x31b
  12ebb0:	e3090470 	movw	r0, #38000	; 0x9470
  12ebb4:	e3400014 	movt	r0, #20
  12ebb8:	ebff712f 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("q != NULL", q != NULL);
  12ebbc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12ebc0:	e3530000 	cmp	r3, #0
  12ebc4:	1a000006 	bne	12ebe4 <etharp_output+0x70>
  12ebc8:	e3090464 	movw	r0, #37988	; 0x9464
  12ebcc:	e3400014 	movt	r0, #20
  12ebd0:	ebff514f 	bl	103114 <rt_kprintf>
  12ebd4:	e3a01fc7 	mov	r1, #796	; 0x31c
  12ebd8:	e3090470 	movw	r0, #38000	; 0x9470
  12ebdc:	e3400014 	movt	r0, #20
  12ebe0:	ebff7125 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
  12ebe4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12ebe8:	e3530000 	cmp	r3, #0
  12ebec:	1a000006 	bne	12ec0c <etharp_output+0x98>
  12ebf0:	e30905a4 	movw	r0, #38308	; 0x95a4
  12ebf4:	e3400014 	movt	r0, #20
  12ebf8:	ebff5145 	bl	103114 <rt_kprintf>
  12ebfc:	e300131d 	movw	r1, #797	; 0x31d
  12ec00:	e3090470 	movw	r0, #38000	; 0x9470
  12ec04:	e3400014 	movt	r0, #20
  12ec08:	ebff711b 	bl	10b07c <sys_arch_assert>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
  12ec0c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12ec10:	e5933000 	ldr	r3, [r3]
  12ec14:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  12ec18:	e1a00003 	mov	r0, r3
  12ec1c:	eb000eba 	bl	13270c <ip4_addr_isbroadcast_u32>
  12ec20:	e1a03000 	mov	r3, r0
  12ec24:	e3530000 	cmp	r3, #0
  12ec28:	0a000003 	beq	12ec3c <etharp_output+0xc8>
    /* broadcast on Ethernet also */
    dest = (const struct eth_addr *)&ethbroadcast;
  12ec2c:	e3083d4c 	movw	r3, #36172	; 0x8d4c
  12ec30:	e3403014 	movt	r3, #20
  12ec34:	e50b3008 	str	r3, [fp, #-8]
  12ec38:	ea000097 	b	12ee9c <etharp_output+0x328>
  /* multicast destination IP address? */
  } else if (ip4_addr_ismulticast(ipaddr)) {
  12ec3c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12ec40:	e5933000 	ldr	r3, [r3]
  12ec44:	e20330f0 	and	r3, r3, #240	; 0xf0
  12ec48:	e35300e0 	cmp	r3, #224	; 0xe0
  12ec4c:	1a000016 	bne	12ecac <etharp_output+0x138>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
  12ec50:	e3a03001 	mov	r3, #1
  12ec54:	e54b3014 	strb	r3, [fp, #-20]	; 0xffffffec
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
  12ec58:	e3a03000 	mov	r3, #0
  12ec5c:	e54b3013 	strb	r3, [fp, #-19]	; 0xffffffed
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
  12ec60:	e3a0305e 	mov	r3, #94	; 0x5e
  12ec64:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  12ec68:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12ec6c:	e2833001 	add	r3, r3, #1
  12ec70:	e5d33000 	ldrb	r3, [r3]
  12ec74:	e203307f 	and	r3, r3, #127	; 0x7f
  12ec78:	e6ef3073 	uxtb	r3, r3
  12ec7c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  12ec80:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12ec84:	e2833002 	add	r3, r3, #2
  12ec88:	e5d33000 	ldrb	r3, [r3]
  12ec8c:	e54b3010 	strb	r3, [fp, #-16]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  12ec90:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12ec94:	e2833003 	add	r3, r3, #3
  12ec98:	e5d33000 	ldrb	r3, [r3]
  12ec9c:	e54b300f 	strb	r3, [fp, #-15]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  12eca0:	e24b3014 	sub	r3, fp, #20
  12eca4:	e50b3008 	str	r3, [fp, #-8]
  12eca8:	ea00007b 	b	12ee9c <etharp_output+0x328>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
  12ecac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12ecb0:	e5932000 	ldr	r2, [r3]
  12ecb4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12ecb8:	e2833004 	add	r3, r3, #4
  12ecbc:	e5933000 	ldr	r3, [r3]
  12ecc0:	e0222003 	eor	r2, r2, r3
  12ecc4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12ecc8:	e2833008 	add	r3, r3, #8
  12eccc:	e5933000 	ldr	r3, [r3]
  12ecd0:	e0033002 	and	r3, r3, r2
  12ecd4:	e3530000 	cmp	r3, #0
  12ecd8:	0a000010 	beq	12ed20 <etharp_output+0x1ac>
        !ip4_addr_islinklocal(ipaddr)) {
  12ecdc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12ece0:	e5933000 	ldr	r3, [r3]
  12ece4:	e6ff3073 	uxth	r3, r3
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
  12ece8:	e30f2ea9 	movw	r2, #65193	; 0xfea9
  12ecec:	e1530002 	cmp	r3, r2
  12ecf0:	0a00000a 	beq	12ed20 <etharp_output+0x1ac>
        dst_addr = LWIP_HOOK_ETHARP_GET_GW(netif, ipaddr);
        if (dst_addr == NULL)
#endif /* LWIP_HOOK_ETHARP_GET_GW */
        {
          /* interface has default gateway? */
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
  12ecf4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12ecf8:	e283300c 	add	r3, r3, #12
  12ecfc:	e5933000 	ldr	r3, [r3]
  12ed00:	e3530000 	cmp	r3, #0
  12ed04:	0a000003 	beq	12ed18 <etharp_output+0x1a4>
            /* send to hardware address of default gateway IP address */
            dst_addr = netif_ip4_gw(netif);
  12ed08:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12ed0c:	e283300c 	add	r3, r3, #12
  12ed10:	e50b300c 	str	r3, [fp, #-12]
  12ed14:	ea000001 	b	12ed20 <etharp_output+0x1ac>
          /* no default gateway available */
          } else {
            /* no route to destination error (default gateway missing) */
            return ERR_RTE;
  12ed18:	e3e03003 	mvn	r3, #3
  12ed1c:	ea000067 	b	12eec0 <etharp_output+0x34c>
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
  12ed20:	e30f3bc4 	movw	r3, #64452	; 0xfbc4
  12ed24:	e3403014 	movt	r3, #20
  12ed28:	e5d33000 	ldrb	r3, [r3]
  12ed2c:	e1a01003 	mov	r1, r3
  12ed30:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ed34:	e3403014 	movt	r3, #20
  12ed38:	e3a02018 	mov	r2, #24
  12ed3c:	e0020192 	mul	r2, r2, r1
  12ed40:	e0833002 	add	r3, r3, r2
  12ed44:	e2833014 	add	r3, r3, #20
  12ed48:	e5d33000 	ldrb	r3, [r3]
  12ed4c:	e3530001 	cmp	r3, #1
  12ed50:	9a00001f 	bls	12edd4 <etharp_output+0x260>
#if ETHARP_TABLE_MATCH_NETIF
            (arp_table[etharp_cached_entry].netif == netif) &&
#endif
            (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
  12ed54:	e51b300c 	ldr	r3, [fp, #-12]
  12ed58:	e5932000 	ldr	r2, [r3]
  12ed5c:	e30f3bc4 	movw	r3, #64452	; 0xfbc4
  12ed60:	e3403014 	movt	r3, #20
  12ed64:	e5d33000 	ldrb	r3, [r3]
  12ed68:	e1a00003 	mov	r0, r3
  12ed6c:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ed70:	e3403014 	movt	r3, #20
  12ed74:	e3a01018 	mov	r1, #24
  12ed78:	e0010091 	mul	r1, r1, r0
  12ed7c:	e0833001 	add	r3, r3, r1
  12ed80:	e2833004 	add	r3, r3, #4
  12ed84:	e5933000 	ldr	r3, [r3]
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
  12ed88:	e1520003 	cmp	r2, r3
  12ed8c:	1a000010 	bne	12edd4 <etharp_output+0x260>
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
  12ed90:	e3063840 	movw	r3, #26688	; 0x6840
  12ed94:	e3403057 	movt	r3, #87	; 0x57
  12ed98:	e1d332be 	ldrh	r3, [r3, #46]	; 0x2e
  12ed9c:	e2833001 	add	r3, r3, #1
  12eda0:	e6ff2073 	uxth	r2, r3
  12eda4:	e3063840 	movw	r3, #26688	; 0x6840
  12eda8:	e3403057 	movt	r3, #87	; 0x57
  12edac:	e1c322be 	strh	r2, [r3, #46]	; 0x2e
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
  12edb0:	e30f3bc4 	movw	r3, #64452	; 0xfbc4
  12edb4:	e3403014 	movt	r3, #20
  12edb8:	e5d33000 	ldrb	r3, [r3]
  12edbc:	e1a02003 	mov	r2, r3
  12edc0:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  12edc4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12edc8:	ebfffee8 	bl	12e970 <etharp_output_to_arp_index>
  12edcc:	e1a03000 	mov	r3, r0
  12edd0:	ea00003a 	b	12eec0 <etharp_output+0x34c>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
  12edd4:	e3a03000 	mov	r3, #0
  12edd8:	e54b300d 	strb	r3, [fp, #-13]
  12eddc:	ea000025 	b	12ee78 <etharp_output+0x304>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
  12ede0:	e15b20dd 	ldrsb	r2, [fp, #-13]
  12ede4:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ede8:	e3403014 	movt	r3, #20
  12edec:	e3a01018 	mov	r1, #24
  12edf0:	e0020291 	mul	r2, r1, r2
  12edf4:	e0833002 	add	r3, r3, r2
  12edf8:	e2833014 	add	r3, r3, #20
  12edfc:	e5d33000 	ldrb	r3, [r3]
  12ee00:	e3530001 	cmp	r3, #1
  12ee04:	9a000016 	bls	12ee64 <etharp_output+0x2f0>
#if ETHARP_TABLE_MATCH_NETIF
          (arp_table[i].netif == netif) &&
#endif
          (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
  12ee08:	e51b300c 	ldr	r3, [fp, #-12]
  12ee0c:	e5932000 	ldr	r2, [r3]
  12ee10:	e15b10dd 	ldrsb	r1, [fp, #-13]
  12ee14:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12ee18:	e3403014 	movt	r3, #20
  12ee1c:	e3a00018 	mov	r0, #24
  12ee20:	e0010190 	mul	r1, r0, r1
  12ee24:	e0833001 	add	r3, r3, r1
  12ee28:	e2833004 	add	r3, r3, #4
  12ee2c:	e5933000 	ldr	r3, [r3]
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
  12ee30:	e1520003 	cmp	r2, r3
  12ee34:	1a00000a 	bne	12ee64 <etharp_output+0x2f0>
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
  12ee38:	e55b200d 	ldrb	r2, [fp, #-13]
  12ee3c:	e30f3bc4 	movw	r3, #64452	; 0xfbc4
  12ee40:	e3403014 	movt	r3, #20
  12ee44:	e5c32000 	strb	r2, [r3]
        return etharp_output_to_arp_index(netif, q, i);
  12ee48:	e55b300d 	ldrb	r3, [fp, #-13]
  12ee4c:	e1a02003 	mov	r2, r3
  12ee50:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  12ee54:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12ee58:	ebfffec4 	bl	12e970 <etharp_output_to_arp_index>
  12ee5c:	e1a03000 	mov	r3, r0
  12ee60:	ea000016 	b	12eec0 <etharp_output+0x34c>
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
  12ee64:	e15b30dd 	ldrsb	r3, [fp, #-13]
  12ee68:	e6ef3073 	uxtb	r3, r3
  12ee6c:	e2833001 	add	r3, r3, #1
  12ee70:	e6ef3073 	uxtb	r3, r3
  12ee74:	e54b300d 	strb	r3, [fp, #-13]
  12ee78:	e15b30dd 	ldrsb	r3, [fp, #-13]
  12ee7c:	e3530009 	cmp	r3, #9
  12ee80:	daffffd6 	ble	12ede0 <etharp_output+0x26c>
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
  12ee84:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  12ee88:	e51b100c 	ldr	r1, [fp, #-12]
  12ee8c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12ee90:	eb00000d 	bl	12eecc <etharp_query>
  12ee94:	e1a03000 	mov	r3, r0
  12ee98:	ea000008 	b	12eec0 <etharp_output+0x34c>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), dest, ETHTYPE_IP);
  12ee9c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12eea0:	e283203b 	add	r2, r3, #59	; 0x3b
  12eea4:	e3a03b02 	mov	r3, #2048	; 0x800
  12eea8:	e58d3000 	str	r3, [sp]
  12eeac:	e51b3008 	ldr	r3, [fp, #-8]
  12eeb0:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  12eeb4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12eeb8:	ebffe88e 	bl	1290f8 <ethernet_output>
  12eebc:	e1a03000 	mov	r3, r0
}
  12eec0:	e1a00003 	mov	r0, r3
  12eec4:	e24bd004 	sub	sp, fp, #4
  12eec8:	e8bd8800 	pop	{fp, pc}

0012eecc <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
{
  12eecc:	e92d4800 	push	{fp, lr}
  12eed0:	e28db004 	add	fp, sp, #4
  12eed4:	e24dd040 	sub	sp, sp, #64	; 0x40
  12eed8:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
  12eedc:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
  12eee0:	e50b2038 	str	r2, [fp, #-56]	; 0xffffffc8
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  12eee4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  12eee8:	e283303b 	add	r3, r3, #59	; 0x3b
  12eeec:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
  err_t result = ERR_MEM;
  12eef0:	e3e03000 	mvn	r3, #0
  12eef4:	e54b3005 	strb	r3, [fp, #-5]
  int is_new_entry = 0;
  12eef8:	e3a03000 	mov	r3, #0
  12eefc:	e50b300c 	str	r3, [fp, #-12]
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
  12ef00:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  12ef04:	e5933000 	ldr	r3, [r3]
  12ef08:	e51b1030 	ldr	r1, [fp, #-48]	; 0xffffffd0
  12ef0c:	e1a00003 	mov	r0, r3
  12ef10:	eb000dfd 	bl	13270c <ip4_addr_isbroadcast_u32>
  12ef14:	e1a03000 	mov	r3, r0
  12ef18:	e3530000 	cmp	r3, #0
  12ef1c:	1a00000b 	bne	12ef50 <etharp_query+0x84>
      ip4_addr_ismulticast(ipaddr) ||
  12ef20:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  12ef24:	e5933000 	ldr	r3, [r3]
  12ef28:	e20330f0 	and	r3, r3, #240	; 0xf0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
  12ef2c:	e35300e0 	cmp	r3, #224	; 0xe0
  12ef30:	0a000006 	beq	12ef50 <etharp_query+0x84>
      ip4_addr_ismulticast(ipaddr) ||
  12ef34:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  12ef38:	e3530000 	cmp	r3, #0
  12ef3c:	0a000003 	beq	12ef50 <etharp_query+0x84>
      ip4_addr_isany(ipaddr)) {
  12ef40:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  12ef44:	e5933000 	ldr	r3, [r3]
  12ef48:	e3530000 	cmp	r3, #0
  12ef4c:	1a000001 	bne	12ef58 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  12ef50:	e3e0300f 	mvn	r3, #15
  12ef54:	ea000144 	b	12f46c <etharp_query+0x5a0>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
  12ef58:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  12ef5c:	e3a01001 	mov	r1, #1
  12ef60:	e51b0034 	ldr	r0, [fp, #-52]	; 0xffffffcc
  12ef64:	ebfffb80 	bl	12dd6c <etharp_find_entry>
  12ef68:	e1a03000 	mov	r3, r0
  12ef6c:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf

  /* could not find or create entry? */
  if (i < 0) {
  12ef70:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
  12ef74:	e3530000 	cmp	r3, #0
  12ef78:	aa00000c 	bge	12efb0 <etharp_query+0xe4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
  12ef7c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  12ef80:	e3530000 	cmp	r3, #0
  12ef84:	0a000007 	beq	12efa8 <etharp_query+0xdc>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
  12ef88:	e3063840 	movw	r3, #26688	; 0x6840
  12ef8c:	e3403057 	movt	r3, #87	; 0x57
  12ef90:	e1d332b4 	ldrh	r3, [r3, #36]	; 0x24
  12ef94:	e2833001 	add	r3, r3, #1
  12ef98:	e6ff2073 	uxth	r2, r3
  12ef9c:	e3063840 	movw	r3, #26688	; 0x6840
  12efa0:	e3403057 	movt	r3, #87	; 0x57
  12efa4:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
    }
    return (err_t)i;
  12efa8:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
  12efac:	ea00012e 	b	12f46c <etharp_query+0x5a0>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  12efb0:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12efb4:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12efb8:	e3403014 	movt	r3, #20
  12efbc:	e3a01018 	mov	r1, #24
  12efc0:	e0020291 	mul	r2, r1, r2
  12efc4:	e0833002 	add	r3, r3, r2
  12efc8:	e2833014 	add	r3, r3, #20
  12efcc:	e5d33000 	ldrb	r3, [r3]
  12efd0:	e3530000 	cmp	r3, #0
  12efd4:	1a000013 	bne	12f028 <etharp_query+0x15c>
    is_new_entry = 1;
  12efd8:	e3a03001 	mov	r3, #1
  12efdc:	e50b300c 	str	r3, [fp, #-12]
    arp_table[i].state = ETHARP_STATE_PENDING;
  12efe0:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12efe4:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12efe8:	e3403014 	movt	r3, #20
  12efec:	e3a01018 	mov	r1, #24
  12eff0:	e0020291 	mul	r2, r1, r2
  12eff4:	e0833002 	add	r3, r3, r2
  12eff8:	e2833014 	add	r3, r3, #20
  12effc:	e3a02001 	mov	r2, #1
  12f000:	e5c32000 	strb	r2, [r3]
    /* record network interface for re-sending arp request in etharp_tmr */
    arp_table[i].netif = netif;
  12f004:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f008:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f00c:	e3403014 	movt	r3, #20
  12f010:	e3a01018 	mov	r1, #24
  12f014:	e0020291 	mul	r2, r1, r2
  12f018:	e0833002 	add	r3, r3, r2
  12f01c:	e2833008 	add	r3, r3, #8
  12f020:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  12f024:	e5832000 	str	r2, [r3]
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  12f028:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f02c:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f030:	e3403014 	movt	r3, #20
  12f034:	e3a01018 	mov	r1, #24
  12f038:	e0020291 	mul	r2, r1, r2
  12f03c:	e0833002 	add	r3, r3, r2
  12f040:	e2833014 	add	r3, r3, #20
  12f044:	e5d33000 	ldrb	r3, [r3]
  12f048:	e3530001 	cmp	r3, #1
  12f04c:	0a000010 	beq	12f094 <etharp_query+0x1c8>
  12f050:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f054:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f058:	e3403014 	movt	r3, #20
  12f05c:	e3a01018 	mov	r1, #24
  12f060:	e0020291 	mul	r2, r1, r2
  12f064:	e0833002 	add	r3, r3, r2
  12f068:	e2833014 	add	r3, r3, #20
  12f06c:	e5d33000 	ldrb	r3, [r3]
  12f070:	e3530001 	cmp	r3, #1
  12f074:	8a000006 	bhi	12f094 <etharp_query+0x1c8>
  12f078:	e3090604 	movw	r0, #38404	; 0x9604
  12f07c:	e3400014 	movt	r0, #20
  12f080:	ebff5023 	bl	103114 <rt_kprintf>
  12f084:	e30013c9 	movw	r1, #969	; 0x3c9
  12f088:	e3090470 	movw	r0, #38000	; 0x9470
  12f08c:	e3400014 	movt	r0, #20
  12f090:	ebff6ff9 	bl	10b07c <sys_arch_assert>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a new entry? or an implicit query request? */
  if (is_new_entry || (q == NULL)) {
  12f094:	e51b300c 	ldr	r3, [fp, #-12]
  12f098:	e3530000 	cmp	r3, #0
  12f09c:	1a000002 	bne	12f0ac <etharp_query+0x1e0>
  12f0a0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  12f0a4:	e3530000 	cmp	r3, #0
  12f0a8:	1a000009 	bne	12f0d4 <etharp_query+0x208>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  12f0ac:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  12f0b0:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  12f0b4:	eb00018f 	bl	12f6f8 <etharp_request>
  12f0b8:	e1a03000 	mov	r3, r0
  12f0bc:	e54b3005 	strb	r3, [fp, #-5]
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
  12f0c0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  12f0c4:	e3530000 	cmp	r3, #0
  12f0c8:	1a000001 	bne	12f0d4 <etharp_query+0x208>
      return result;
  12f0cc:	e15b30d5 	ldrsb	r3, [fp, #-5]
  12f0d0:	ea0000e5 	b	12f46c <etharp_query+0x5a0>
    }
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  12f0d4:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  12f0d8:	e3530000 	cmp	r3, #0
  12f0dc:	1a000006 	bne	12f0fc <etharp_query+0x230>
  12f0e0:	e3090464 	movw	r0, #37988	; 0x9464
  12f0e4:	e3400014 	movt	r0, #20
  12f0e8:	ebff5009 	bl	103114 <rt_kprintf>
  12f0ec:	e30013db 	movw	r1, #987	; 0x3db
  12f0f0:	e3090470 	movw	r0, #38000	; 0x9470
  12f0f4:	e3400014 	movt	r0, #20
  12f0f8:	ebff6fdf 	bl	10b07c <sys_arch_assert>
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
  12f0fc:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f100:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f104:	e3403014 	movt	r3, #20
  12f108:	e3a01018 	mov	r1, #24
  12f10c:	e0020291 	mul	r2, r1, r2
  12f110:	e0833002 	add	r3, r3, r2
  12f114:	e2833014 	add	r3, r3, #20
  12f118:	e5d33000 	ldrb	r3, [r3]
  12f11c:	e3530001 	cmp	r3, #1
  12f120:	9a000015 	bls	12f17c <etharp_query+0x2b0>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
  12f124:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
  12f128:	e30f3bc4 	movw	r3, #64452	; 0xfbc4
  12f12c:	e3403014 	movt	r3, #20
  12f130:	e5c32000 	strb	r2, [r3]
    /* send the packet */
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
  12f134:	e15b32d1 	ldrsb	r3, [fp, #-33]	; 0xffffffdf
  12f138:	e3a02018 	mov	r2, #24
  12f13c:	e0030392 	mul	r3, r2, r3
  12f140:	e2832008 	add	r2, r3, #8
  12f144:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f148:	e3403014 	movt	r3, #20
  12f14c:	e0823003 	add	r3, r2, r3
  12f150:	e2832004 	add	r2, r3, #4
  12f154:	e3a03b02 	mov	r3, #2048	; 0x800
  12f158:	e58d3000 	str	r3, [sp]
  12f15c:	e1a03002 	mov	r3, r2
  12f160:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  12f164:	e51b1038 	ldr	r1, [fp, #-56]	; 0xffffffc8
  12f168:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  12f16c:	ebffe7e1 	bl	1290f8 <ethernet_output>
  12f170:	e1a03000 	mov	r3, r0
  12f174:	e54b3005 	strb	r3, [fp, #-5]
  12f178:	ea0000ba 	b	12f468 <etharp_query+0x59c>
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  12f17c:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f180:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f184:	e3403014 	movt	r3, #20
  12f188:	e3a01018 	mov	r1, #24
  12f18c:	e0020291 	mul	r2, r1, r2
  12f190:	e0833002 	add	r3, r3, r2
  12f194:	e2833014 	add	r3, r3, #20
  12f198:	e5d33000 	ldrb	r3, [r3]
  12f19c:	e3530001 	cmp	r3, #1
  12f1a0:	1a0000b0 	bne	12f468 <etharp_query+0x59c>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
  12f1a4:	e3a03000 	mov	r3, #0
  12f1a8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400)
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
  12f1ac:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  12f1b0:	e50b3010 	str	r3, [fp, #-16]
    while (p) {
  12f1b4:	ea00001a 	b	12f224 <etharp_query+0x358>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  12f1b8:	e51b3010 	ldr	r3, [fp, #-16]
  12f1bc:	e1d320ba 	ldrh	r2, [r3, #10]
  12f1c0:	e51b3010 	ldr	r3, [fp, #-16]
  12f1c4:	e1d330b8 	ldrh	r3, [r3, #8]
  12f1c8:	e1520003 	cmp	r2, r3
  12f1cc:	1a00000a 	bne	12f1fc <etharp_query+0x330>
  12f1d0:	e51b3010 	ldr	r3, [fp, #-16]
  12f1d4:	e5933000 	ldr	r3, [r3]
  12f1d8:	e3530000 	cmp	r3, #0
  12f1dc:	0a000006 	beq	12f1fc <etharp_query+0x330>
  12f1e0:	e309062c 	movw	r0, #38444	; 0x962c
  12f1e4:	e3400014 	movt	r0, #20
  12f1e8:	ebff4fc9 	bl	103114 <rt_kprintf>
  12f1ec:	e3a01ffb 	mov	r1, #1004	; 0x3ec
  12f1f0:	e3090470 	movw	r0, #38000	; 0x9470
  12f1f4:	e3400014 	movt	r0, #20
  12f1f8:	ebff6f9f 	bl	10b07c <sys_arch_assert>
      if (p->type != PBUF_ROM) {
  12f1fc:	e51b3010 	ldr	r3, [fp, #-16]
  12f200:	e5d3300c 	ldrb	r3, [r3, #12]
  12f204:	e3530001 	cmp	r3, #1
  12f208:	0a000002 	beq	12f218 <etharp_query+0x34c>
        copy_needed = 1;
  12f20c:	e3a03001 	mov	r3, #1
  12f210:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        break;
  12f214:	ea000005 	b	12f230 <etharp_query+0x364>
      }
      p = p->next;
  12f218:	e51b3010 	ldr	r3, [fp, #-16]
  12f21c:	e5933000 	ldr	r3, [r3]
  12f220:	e50b3010 	str	r3, [fp, #-16]
    while (p) {
  12f224:	e51b3010 	ldr	r3, [fp, #-16]
  12f228:	e3530000 	cmp	r3, #0
  12f22c:	1affffe1 	bne	12f1b8 <etharp_query+0x2ec>
    }
    if (copy_needed) {
  12f230:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12f234:	e3530000 	cmp	r3, #0
  12f238:	0a000014 	beq	12f290 <etharp_query+0x3c4>
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  12f23c:	e51b3010 	ldr	r3, [fp, #-16]
  12f240:	e1d330b8 	ldrh	r3, [r3, #8]
  12f244:	e3a02000 	mov	r2, #0
  12f248:	e1a01003 	mov	r1, r3
  12f24c:	e3a00002 	mov	r0, #2
  12f250:	ebffac90 	bl	11a498 <pbuf_alloc>
  12f254:	e50b0010 	str	r0, [fp, #-16]
      if (p != NULL) {
  12f258:	e51b3010 	ldr	r3, [fp, #-16]
  12f25c:	e3530000 	cmp	r3, #0
  12f260:	0a00000e 	beq	12f2a0 <etharp_query+0x3d4>
        if (pbuf_copy(p, q) != ERR_OK) {
  12f264:	e51b1038 	ldr	r1, [fp, #-56]	; 0xffffffc8
  12f268:	e51b0010 	ldr	r0, [fp, #-16]
  12f26c:	ebffb0e5 	bl	11b608 <pbuf_copy>
  12f270:	e1a03000 	mov	r3, r0
  12f274:	e3530000 	cmp	r3, #0
  12f278:	0a000008 	beq	12f2a0 <etharp_query+0x3d4>
          pbuf_free(p);
  12f27c:	e51b0010 	ldr	r0, [fp, #-16]
  12f280:	ebffaf8b 	bl	11b0b4 <pbuf_free>
          p = NULL;
  12f284:	e3a03000 	mov	r3, #0
  12f288:	e50b3010 	str	r3, [fp, #-16]
  12f28c:	ea000003 	b	12f2a0 <etharp_query+0x3d4>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
  12f290:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  12f294:	e50b3010 	str	r3, [fp, #-16]
      pbuf_ref(p);
  12f298:	e51b0010 	ldr	r0, [fp, #-16]
  12f29c:	ebffb01e 	bl	11b31c <pbuf_ref>
    }
    /* packet could be taken over? */
    if (p != NULL) {
  12f2a0:	e51b3010 	ldr	r3, [fp, #-16]
  12f2a4:	e3530000 	cmp	r3, #0
  12f2a8:	0a000064 	beq	12f440 <etharp_query+0x574>
      /* queue packet ... */
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
  12f2ac:	e3002407 	movw	r2, #1031	; 0x407
  12f2b0:	e3091470 	movw	r1, #38000	; 0x9470
  12f2b4:	e3401014 	movt	r1, #20
  12f2b8:	e3a0000b 	mov	r0, #11
  12f2bc:	ebffa806 	bl	1192dc <memp_malloc_fn>
  12f2c0:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
      if (new_entry != NULL) {
  12f2c4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12f2c8:	e3530000 	cmp	r3, #0
  12f2cc:	0a000056 	beq	12f42c <etharp_query+0x560>
        unsigned int qlen = 0;
  12f2d0:	e3a03000 	mov	r3, #0
  12f2d4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
        new_entry->next = 0;
  12f2d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12f2dc:	e3a02000 	mov	r2, #0
  12f2e0:	e5832000 	str	r2, [r3]
        new_entry->p = p;
  12f2e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12f2e8:	e51b2010 	ldr	r2, [fp, #-16]
  12f2ec:	e5832004 	str	r2, [r3, #4]
        if (arp_table[i].q != NULL) {
  12f2f0:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f2f4:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f2f8:	e3403014 	movt	r3, #20
  12f2fc:	e3a01018 	mov	r1, #24
  12f300:	e0020291 	mul	r2, r1, r2
  12f304:	e0833002 	add	r3, r3, r2
  12f308:	e5933000 	ldr	r3, [r3]
  12f30c:	e3530000 	cmp	r3, #0
  12f310:	0a000019 	beq	12f37c <etharp_query+0x4b0>
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
  12f314:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f318:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f31c:	e3403014 	movt	r3, #20
  12f320:	e3a01018 	mov	r1, #24
  12f324:	e0020291 	mul	r2, r1, r2
  12f328:	e0833002 	add	r3, r3, r2
  12f32c:	e5933000 	ldr	r3, [r3]
  12f330:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
          qlen++;
  12f334:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12f338:	e2833001 	add	r3, r3, #1
  12f33c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
          while (r->next != NULL) {
  12f340:	ea000005 	b	12f35c <etharp_query+0x490>
            r = r->next;
  12f344:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12f348:	e5933000 	ldr	r3, [r3]
  12f34c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
            qlen++;
  12f350:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12f354:	e2833001 	add	r3, r3, #1
  12f358:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
          while (r->next != NULL) {
  12f35c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12f360:	e5933000 	ldr	r3, [r3]
  12f364:	e3530000 	cmp	r3, #0
  12f368:	1afffff5 	bne	12f344 <etharp_query+0x478>
          }
          r->next = new_entry;
  12f36c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12f370:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  12f374:	e5832000 	str	r2, [r3]
  12f378:	ea000007 	b	12f39c <etharp_query+0x4d0>
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
  12f37c:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f380:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f384:	e3403014 	movt	r3, #20
  12f388:	e3a01018 	mov	r1, #24
  12f38c:	e0020291 	mul	r2, r1, r2
  12f390:	e0833002 	add	r3, r3, r2
  12f394:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  12f398:	e5832000 	str	r2, [r3]
        }
#if ARP_QUEUE_LEN
        if (qlen >= ARP_QUEUE_LEN) {
  12f39c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12f3a0:	e3530002 	cmp	r3, #2
  12f3a4:	9a00001d 	bls	12f420 <etharp_query+0x554>
          struct etharp_q_entry *old;
          old = arp_table[i].q;
  12f3a8:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f3ac:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f3b0:	e3403014 	movt	r3, #20
  12f3b4:	e3a01018 	mov	r1, #24
  12f3b8:	e0020291 	mul	r2, r1, r2
  12f3bc:	e0833002 	add	r3, r3, r2
  12f3c0:	e5933000 	ldr	r3, [r3]
  12f3c4:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
          arp_table[i].q = arp_table[i].q->next;
  12f3c8:	e15b22d1 	ldrsb	r2, [fp, #-33]	; 0xffffffdf
  12f3cc:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f3d0:	e3403014 	movt	r3, #20
  12f3d4:	e3a01018 	mov	r1, #24
  12f3d8:	e0020291 	mul	r2, r1, r2
  12f3dc:	e0833002 	add	r3, r3, r2
  12f3e0:	e5933000 	ldr	r3, [r3]
  12f3e4:	e15b12d1 	ldrsb	r1, [fp, #-33]	; 0xffffffdf
  12f3e8:	e5932000 	ldr	r2, [r3]
  12f3ec:	e30f3ad4 	movw	r3, #64212	; 0xfad4
  12f3f0:	e3403014 	movt	r3, #20
  12f3f4:	e3a00018 	mov	r0, #24
  12f3f8:	e0010190 	mul	r1, r0, r1
  12f3fc:	e0833001 	add	r3, r3, r1
  12f400:	e5832000 	str	r2, [r3]
          pbuf_free(old->p);
  12f404:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  12f408:	e5933004 	ldr	r3, [r3, #4]
  12f40c:	e1a00003 	mov	r0, r3
  12f410:	ebffaf27 	bl	11b0b4 <pbuf_free>
          memp_free(MEMP_ARP_QUEUE, old);
  12f414:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  12f418:	e3a0000b 	mov	r0, #11
  12f41c:	ebffa816 	bl	11947c <memp_free>
        }
#endif
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
  12f420:	e3a03000 	mov	r3, #0
  12f424:	e54b3005 	strb	r3, [fp, #-5]
  12f428:	ea00000e 	b	12f468 <etharp_query+0x59c>
      } else {
        /* the pool MEMP_ARP_QUEUE is empty */
        pbuf_free(p);
  12f42c:	e51b0010 	ldr	r0, [fp, #-16]
  12f430:	ebffaf1f 	bl	11b0b4 <pbuf_free>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
  12f434:	e3e03000 	mvn	r3, #0
  12f438:	e54b3005 	strb	r3, [fp, #-5]
  12f43c:	ea000009 	b	12f468 <etharp_query+0x59c>
      arp_table[i].q = p;
      result = ERR_OK;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
  12f440:	e3063840 	movw	r3, #26688	; 0x6840
  12f444:	e3403057 	movt	r3, #87	; 0x57
  12f448:	e1d332b4 	ldrh	r3, [r3, #36]	; 0x24
  12f44c:	e2833001 	add	r3, r3, #1
  12f450:	e6ff2073 	uxth	r2, r3
  12f454:	e3063840 	movw	r3, #26688	; 0x6840
  12f458:	e3403057 	movt	r3, #87	; 0x57
  12f45c:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
  12f460:	e3e03000 	mvn	r3, #0
  12f464:	e54b3005 	strb	r3, [fp, #-5]
    }
  }
  return result;
  12f468:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  12f46c:	e1a00003 	mov	r0, r3
  12f470:	e24bd004 	sub	sp, fp, #4
  12f474:	e8bd8800 	pop	{fp, pc}

0012f478 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
  12f478:	e92d4800 	push	{fp, lr}
  12f47c:	e28db004 	add	fp, sp, #4
  12f480:	e24dd028 	sub	sp, sp, #40	; 0x28
  12f484:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  12f488:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  12f48c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  12f490:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
  struct pbuf *p;
  err_t result = ERR_OK;
  12f494:	e3a03000 	mov	r3, #0
  12f498:	e54b3005 	strb	r3, [fp, #-5]
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
  12f49c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12f4a0:	e3530000 	cmp	r3, #0
  12f4a4:	1a000006 	bne	12f4c4 <etharp_raw+0x4c>
  12f4a8:	e30905b4 	movw	r0, #38324	; 0x95b4
  12f4ac:	e3400014 	movt	r0, #20
  12f4b0:	ebff4f17 	bl	103114 <rt_kprintf>
  12f4b4:	e3001458 	movw	r1, #1112	; 0x458
  12f4b8:	e3090470 	movw	r0, #38000	; 0x9470
  12f4bc:	e3400014 	movt	r0, #20
  12f4c0:	ebff6eed 	bl	10b07c <sys_arch_assert>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
  12f4c4:	e3a02000 	mov	r2, #0
  12f4c8:	e3a0101c 	mov	r1, #28
  12f4cc:	e3a00002 	mov	r0, #2
  12f4d0:	ebffabf0 	bl	11a498 <pbuf_alloc>
  12f4d4:	e50b000c 	str	r0, [fp, #-12]
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  12f4d8:	e51b300c 	ldr	r3, [fp, #-12]
  12f4dc:	e3530000 	cmp	r3, #0
  12f4e0:	1a000009 	bne	12f50c <etharp_raw+0x94>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
  12f4e4:	e3063840 	movw	r3, #26688	; 0x6840
  12f4e8:	e3403057 	movt	r3, #87	; 0x57
  12f4ec:	e1d332b4 	ldrh	r3, [r3, #36]	; 0x24
  12f4f0:	e2833001 	add	r3, r3, #1
  12f4f4:	e6ff2073 	uxth	r2, r3
  12f4f8:	e3063840 	movw	r3, #26688	; 0x6840
  12f4fc:	e3403057 	movt	r3, #87	; 0x57
  12f500:	e1c322b4 	strh	r2, [r3, #36]	; 0x24
    return ERR_MEM;
  12f504:	e3e03000 	mvn	r3, #0
  12f508:	ea00005b 	b	12f67c <etharp_raw+0x204>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  12f50c:	e51b300c 	ldr	r3, [fp, #-12]
  12f510:	e1d330ba 	ldrh	r3, [r3, #10]
  12f514:	e353001b 	cmp	r3, #27
  12f518:	8a000006 	bhi	12f538 <etharp_raw+0xc0>
  12f51c:	e3090648 	movw	r0, #38472	; 0x9648
  12f520:	e3400014 	movt	r0, #20
  12f524:	ebff4efa 	bl	103114 <rt_kprintf>
  12f528:	e3001464 	movw	r1, #1124	; 0x464
  12f52c:	e3090470 	movw	r0, #38000	; 0x9470
  12f530:	e3400014 	movt	r0, #20
  12f534:	ebff6ed0 	bl	10b07c <sys_arch_assert>
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
  12f538:	e51b300c 	ldr	r3, [fp, #-12]
  12f53c:	e5933004 	ldr	r3, [r3, #4]
  12f540:	e50b3010 	str	r3, [fp, #-16]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
  12f544:	e1db31b0 	ldrh	r3, [fp, #16]
  12f548:	e1a00003 	mov	r0, r3
  12f54c:	ebff9ca1 	bl	1167d8 <lwip_htons>
  12f550:	e1a03000 	mov	r3, r0
  12f554:	e1a02003 	mov	r2, r3
  12f558:	e51b3010 	ldr	r3, [fp, #-16]
  12f55c:	e1c320b6 	strh	r2, [r3, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
  12f560:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12f564:	e5d3303a 	ldrb	r3, [r3, #58]	; 0x3a
  12f568:	e3530006 	cmp	r3, #6
  12f56c:	0a000006 	beq	12f58c <etharp_raw+0x114>
  12f570:	e309067c 	movw	r0, #38524	; 0x967c
  12f574:	e3400014 	movt	r0, #20
  12f578:	ebff4ee5 	bl	103114 <rt_kprintf>
  12f57c:	e300146b 	movw	r1, #1131	; 0x46b
  12f580:	e3090470 	movw	r0, #38000	; 0x9470
  12f584:	e3400014 	movt	r0, #20
  12f588:	ebff6ebb 	bl	10b07c <sys_arch_assert>
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
  12f58c:	e51b3010 	ldr	r3, [fp, #-16]
  12f590:	e2833008 	add	r3, r3, #8
  12f594:	e3a02006 	mov	r2, #6
  12f598:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  12f59c:	e1a00003 	mov	r0, r3
  12f5a0:	eb00467b 	bl	140f94 <memcpy>
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
  12f5a4:	e51b3010 	ldr	r3, [fp, #-16]
  12f5a8:	e2833012 	add	r3, r3, #18
  12f5ac:	e3a02006 	mov	r2, #6
  12f5b0:	e59b1008 	ldr	r1, [fp, #8]
  12f5b4:	e1a00003 	mov	r0, r3
  12f5b8:	eb004675 	bl	140f94 <memcpy>
  /* Copy struct ip4_addr2 to aligned ip4_addr, to support compilers without
   * structure packing. */
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  12f5bc:	e51b3010 	ldr	r3, [fp, #-16]
  12f5c0:	e283300e 	add	r3, r3, #14
  12f5c4:	e59b2004 	ldr	r2, [fp, #4]
  12f5c8:	e5922000 	ldr	r2, [r2]
  12f5cc:	e5832000 	str	r2, [r3]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
  12f5d0:	e51b3010 	ldr	r3, [fp, #-16]
  12f5d4:	e2833018 	add	r3, r3, #24
  12f5d8:	e59b200c 	ldr	r2, [fp, #12]
  12f5dc:	e5922000 	ldr	r2, [r2]
  12f5e0:	e5832000 	str	r2, [r3]

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  12f5e4:	e51b3010 	ldr	r3, [fp, #-16]
  12f5e8:	e3a02000 	mov	r2, #0
  12f5ec:	e5c32000 	strb	r2, [r3]
  12f5f0:	e3a02000 	mov	r2, #0
  12f5f4:	e3822001 	orr	r2, r2, #1
  12f5f8:	e5c32001 	strb	r2, [r3, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  12f5fc:	e51b3010 	ldr	r3, [fp, #-16]
  12f600:	e3a02000 	mov	r2, #0
  12f604:	e3822008 	orr	r2, r2, #8
  12f608:	e5c32002 	strb	r2, [r3, #2]
  12f60c:	e3a02000 	mov	r2, #0
  12f610:	e5c32003 	strb	r2, [r3, #3]
  /* set hwlen and protolen */
  hdr->hwlen = ETH_HWADDR_LEN;
  12f614:	e51b3010 	ldr	r3, [fp, #-16]
  12f618:	e3a02006 	mov	r2, #6
  12f61c:	e5c32004 	strb	r2, [r3, #4]
  hdr->protolen = sizeof(ip4_addr_t);
  12f620:	e51b3010 	ldr	r3, [fp, #-16]
  12f624:	e3a02004 	mov	r2, #4
  12f628:	e5c32005 	strb	r2, [r3, #5]
  if(ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
  12f62c:	e3003806 	movw	r3, #2054	; 0x806
  12f630:	e58d3000 	str	r3, [sp]
  12f634:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12f638:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  12f63c:	e51b100c 	ldr	r1, [fp, #-12]
  12f640:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  12f644:	ebffe6ab 	bl	1290f8 <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
  12f648:	e3063840 	movw	r3, #26688	; 0x6840
  12f64c:	e3403057 	movt	r3, #87	; 0x57
  12f650:	e1d331b8 	ldrh	r3, [r3, #24]
  12f654:	e2833001 	add	r3, r3, #1
  12f658:	e6ff2073 	uxth	r2, r3
  12f65c:	e3063840 	movw	r3, #26688	; 0x6840
  12f660:	e3403057 	movt	r3, #87	; 0x57
  12f664:	e1c321b8 	strh	r2, [r3, #24]
  /* free ARP query packet */
  pbuf_free(p);
  12f668:	e51b000c 	ldr	r0, [fp, #-12]
  12f66c:	ebffae90 	bl	11b0b4 <pbuf_free>
  p = NULL;
  12f670:	e3a03000 	mov	r3, #0
  12f674:	e50b300c 	str	r3, [fp, #-12]
  /* could not allocate pbuf for ARP request */

  return result;
  12f678:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  12f67c:	e1a00003 	mov	r0, r3
  12f680:	e24bd004 	sub	sp, fp, #4
  12f684:	e8bd8800 	pop	{fp, pc}

0012f688 <etharp_request_dst>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
static err_t
etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr* hw_dst_addr)
{
  12f688:	e92d4800 	push	{fp, lr}
  12f68c:	e28db004 	add	fp, sp, #4
  12f690:	e24dd020 	sub	sp, sp, #32
  12f694:	e50b0008 	str	r0, [fp, #-8]
  12f698:	e50b100c 	str	r1, [fp, #-12]
  12f69c:	e50b2010 	str	r2, [fp, #-16]
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
  12f6a0:	e51b3008 	ldr	r3, [fp, #-8]
  12f6a4:	e283103b 	add	r1, r3, #59	; 0x3b
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
  12f6a8:	e51b3008 	ldr	r3, [fp, #-8]
  12f6ac:	e283003b 	add	r0, r3, #59	; 0x3b
  12f6b0:	e51b3008 	ldr	r3, [fp, #-8]
  12f6b4:	e2832004 	add	r2, r3, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
  12f6b8:	e3a03001 	mov	r3, #1
  12f6bc:	e58d300c 	str	r3, [sp, #12]
  12f6c0:	e51b300c 	ldr	r3, [fp, #-12]
  12f6c4:	e58d3008 	str	r3, [sp, #8]
  12f6c8:	e3083d54 	movw	r3, #36180	; 0x8d54
  12f6cc:	e3403014 	movt	r3, #20
  12f6d0:	e58d3004 	str	r3, [sp, #4]
  12f6d4:	e58d2000 	str	r2, [sp]
  12f6d8:	e1a03000 	mov	r3, r0
  12f6dc:	e51b2010 	ldr	r2, [fp, #-16]
  12f6e0:	e51b0008 	ldr	r0, [fp, #-8]
  12f6e4:	ebffff63 	bl	12f478 <etharp_raw>
  12f6e8:	e1a03000 	mov	r3, r0
                    ipaddr, ARP_REQUEST);
}
  12f6ec:	e1a00003 	mov	r0, r3
  12f6f0:	e24bd004 	sub	sp, fp, #4
  12f6f4:	e8bd8800 	pop	{fp, pc}

0012f6f8 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
  12f6f8:	e92d4800 	push	{fp, lr}
  12f6fc:	e28db004 	add	fp, sp, #4
  12f700:	e24dd008 	sub	sp, sp, #8
  12f704:	e50b0008 	str	r0, [fp, #-8]
  12f708:	e50b100c 	str	r1, [fp, #-12]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
  12f70c:	e3082d4c 	movw	r2, #36172	; 0x8d4c
  12f710:	e3402014 	movt	r2, #20
  12f714:	e51b100c 	ldr	r1, [fp, #-12]
  12f718:	e51b0008 	ldr	r0, [fp, #-8]
  12f71c:	ebffffd9 	bl	12f688 <etharp_request_dst>
  12f720:	e1a03000 	mov	r3, r0
}
  12f724:	e1a00003 	mov	r0, r3
  12f728:	e24bd004 	sub	sp, fp, #4
  12f72c:	e8bd8800 	pop	{fp, pc}

0012f730 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the icmp header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  12f730:	e92d4800 	push	{fp, lr}
  12f734:	e28db004 	add	fp, sp, #4
  12f738:	e24dd038 	sub	sp, sp, #56	; 0x38
  12f73c:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  12f740:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  struct icmp_echo_hdr *iecho;
  const struct ip_hdr *iphdr_in;
  u16_t hlen;
  const ip4_addr_t* src;

  ICMP_STATS_INC(icmp.recv);
  12f744:	e3063840 	movw	r3, #26688	; 0x6840
  12f748:	e3403057 	movt	r3, #87	; 0x57
  12f74c:	e1d336b2 	ldrh	r3, [r3, #98]	; 0x62
  12f750:	e2833001 	add	r3, r3, #1
  12f754:	e6ff2073 	uxth	r2, r3
  12f758:	e3063840 	movw	r3, #26688	; 0x6840
  12f75c:	e3403057 	movt	r3, #87	; 0x57
  12f760:	e1c326b2 	strh	r2, [r3, #98]	; 0x62
  MIB2_STATS_INC(mib2.icmpinmsgs);
  12f764:	e3063840 	movw	r3, #26688	; 0x6840
  12f768:	e3403057 	movt	r3, #87	; 0x57
  12f76c:	e59331a0 	ldr	r3, [r3, #416]	; 0x1a0
  12f770:	e2832001 	add	r2, r3, #1
  12f774:	e3063840 	movw	r3, #26688	; 0x6840
  12f778:	e3403057 	movt	r3, #87	; 0x57
  12f77c:	e58321a0 	str	r2, [r3, #416]	; 0x1a0

  iphdr_in = ip4_current_header();
  12f780:	e30035e8 	movw	r3, #1512	; 0x5e8
  12f784:	e3403015 	movt	r3, #21
  12f788:	e5933008 	ldr	r3, [r3, #8]
  12f78c:	e50b3008 	str	r3, [fp, #-8]
  hlen = IPH_HL(iphdr_in) * 4;
  12f790:	e51b3008 	ldr	r3, [fp, #-8]
  12f794:	e5d33000 	ldrb	r3, [r3]
  12f798:	e6ff3073 	uxth	r3, r3
  12f79c:	e203300f 	and	r3, r3, #15
  12f7a0:	e6ff3073 	uxth	r3, r3
  12f7a4:	e1a03103 	lsl	r3, r3, #2
  12f7a8:	e14b30ba 	strh	r3, [fp, #-10]
  if (hlen < IP_HLEN) {
  12f7ac:	e15b30ba 	ldrh	r3, [fp, #-10]
  12f7b0:	e3530013 	cmp	r3, #19
  12f7b4:	9a000182 	bls	12fdc4 <icmp_input+0x694>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
    goto lenerr;
  }
  if (p->len < sizeof(u16_t)*2) {
  12f7b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12f7bc:	e1d330ba 	ldrh	r3, [r3, #10]
  12f7c0:	e3530003 	cmp	r3, #3
  12f7c4:	9a000180 	bls	12fdcc <icmp_input+0x69c>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  12f7c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12f7cc:	e5933004 	ldr	r3, [r3, #4]
  12f7d0:	e5d33000 	ldrb	r3, [r3]
  12f7d4:	e54b300b 	strb	r3, [fp, #-11]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  12f7d8:	e55b300b 	ldrb	r3, [fp, #-11]
  12f7dc:	e3530000 	cmp	r3, #0
  12f7e0:	0a000002 	beq	12f7f0 <icmp_input+0xc0>
  12f7e4:	e3530008 	cmp	r3, #8
  12f7e8:	0a000008 	beq	12f810 <icmp_input+0xe0>
  12f7ec:	ea0000fd 	b	12fbe8 <icmp_input+0x4b8>
  case ICMP_ER:
    /* This is OK, echo reply might have been parsed by a raw PCB
       (as obviously, an echo request has been sent, too). */
    MIB2_STATS_INC(mib2.icmpinechoreps);
  12f7f0:	e3063840 	movw	r3, #26688	; 0x6840
  12f7f4:	e3403057 	movt	r3, #87	; 0x57
  12f7f8:	e59331c0 	ldr	r3, [r3, #448]	; 0x1c0
  12f7fc:	e2832001 	add	r2, r3, #1
  12f800:	e3063840 	movw	r3, #26688	; 0x6840
  12f804:	e3403057 	movt	r3, #87	; 0x57
  12f808:	e58321c0 	str	r2, [r3, #448]	; 0x1c0
    break;
  12f80c:	ea000169 	b	12fdb8 <icmp_input+0x688>
  case ICMP_ECHO:
    MIB2_STATS_INC(mib2.icmpinechos);
  12f810:	e3063840 	movw	r3, #26688	; 0x6840
  12f814:	e3403057 	movt	r3, #87	; 0x57
  12f818:	e59331bc 	ldr	r3, [r3, #444]	; 0x1bc
  12f81c:	e2832001 	add	r2, r3, #1
  12f820:	e3063840 	movw	r3, #26688	; 0x6840
  12f824:	e3403057 	movt	r3, #87	; 0x57
  12f828:	e58321bc 	str	r2, [r3, #444]	; 0x1bc
    src = ip4_current_dest_addr();
  12f82c:	e59f3650 	ldr	r3, [pc, #1616]	; 12fe84 <icmp_input+0x754>
  12f830:	e50b3010 	str	r3, [fp, #-16]
    /* multicast destination address? */
    if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
  12f834:	e30035e8 	movw	r3, #1512	; 0x5e8
  12f838:	e3403015 	movt	r3, #21
  12f83c:	e5933014 	ldr	r3, [r3, #20]
  12f840:	e20330f0 	and	r3, r3, #240	; 0xf0
  12f844:	e35300e0 	cmp	r3, #224	; 0xe0
  12f848:	0a000174 	beq	12fe20 <icmp_input+0x6f0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
      goto icmperr;
#endif /* LWIP_MULTICAST_PING */
    }
    /* broadcast destination address? */
    if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
  12f84c:	e30035e8 	movw	r3, #1512	; 0x5e8
  12f850:	e3403015 	movt	r3, #21
  12f854:	e5932014 	ldr	r2, [r3, #20]
  12f858:	e30035e8 	movw	r3, #1512	; 0x5e8
  12f85c:	e3403015 	movt	r3, #21
  12f860:	e5933000 	ldr	r3, [r3]
  12f864:	e1a01003 	mov	r1, r3
  12f868:	e1a00002 	mov	r0, r2
  12f86c:	eb000ba6 	bl	13270c <ip4_addr_isbroadcast_u32>
  12f870:	e1a03000 	mov	r3, r0
  12f874:	e3530000 	cmp	r3, #0
  12f878:	1a00016a 	bne	12fe28 <icmp_input+0x6f8>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
      goto icmperr;
#endif /* LWIP_BROADCAST_PING */
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  12f87c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12f880:	e1d330b8 	ldrh	r3, [r3, #8]
  12f884:	e3530007 	cmp	r3, #7
  12f888:	9a000151 	bls	12fdd4 <icmp_input+0x6a4>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
#if CHECKSUM_CHECK_ICMP
    IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
      if (inet_chksum_pbuf(p) != 0) {
  12f88c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12f890:	ebffa4ef 	bl	118c54 <inet_chksum_pbuf>
  12f894:	e1a03000 	mov	r3, r0
  12f898:	e3530000 	cmp	r3, #0
  12f89c:	0a000011 	beq	12f8e8 <icmp_input+0x1b8>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
        pbuf_free(p);
  12f8a0:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12f8a4:	ebffae02 	bl	11b0b4 <pbuf_free>
        ICMP_STATS_INC(icmp.chkerr);
  12f8a8:	e3063840 	movw	r3, #26688	; 0x6840
  12f8ac:	e3403057 	movt	r3, #87	; 0x57
  12f8b0:	e1d336b8 	ldrh	r3, [r3, #104]	; 0x68
  12f8b4:	e2833001 	add	r3, r3, #1
  12f8b8:	e6ff2073 	uxth	r2, r3
  12f8bc:	e3063840 	movw	r3, #26688	; 0x6840
  12f8c0:	e3403057 	movt	r3, #87	; 0x57
  12f8c4:	e1c326b8 	strh	r2, [r3, #104]	; 0x68
        MIB2_STATS_INC(mib2.icmpinerrors);
  12f8c8:	e3063840 	movw	r3, #26688	; 0x6840
  12f8cc:	e3403057 	movt	r3, #87	; 0x57
  12f8d0:	e59331a4 	ldr	r3, [r3, #420]	; 0x1a4
  12f8d4:	e2832001 	add	r2, r3, #1
  12f8d8:	e3063840 	movw	r3, #26688	; 0x6840
  12f8dc:	e3403057 	movt	r3, #87	; 0x57
  12f8e0:	e58321a4 	str	r2, [r3, #420]	; 0x1a4
        return;
  12f8e4:	ea000164 	b	12fe7c <icmp_input+0x74c>
      }
    }
#endif
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
  12f8e8:	e15b30ba 	ldrh	r3, [fp, #-10]
  12f8ec:	e2833010 	add	r3, r3, #16
  12f8f0:	e6ff3073 	uxth	r3, r3
  12f8f4:	e6bf3073 	sxth	r3, r3
  12f8f8:	e1a01003 	mov	r1, r3
  12f8fc:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12f900:	ebffadcd 	bl	11b03c <pbuf_header>
  12f904:	e1a03000 	mov	r3, r0
  12f908:	e3530000 	cmp	r3, #0
  12f90c:	0a00003e 	beq	12fa0c <icmp_input+0x2dc>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len + hlen, PBUF_RAM);
  12f910:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12f914:	e1d320b8 	ldrh	r2, [r3, #8]
  12f918:	e15b30ba 	ldrh	r3, [fp, #-10]
  12f91c:	e0823003 	add	r3, r2, r3
  12f920:	e6ff3073 	uxth	r3, r3
  12f924:	e3a02000 	mov	r2, #0
  12f928:	e1a01003 	mov	r1, r3
  12f92c:	e3a00002 	mov	r0, #2
  12f930:	ebffaad8 	bl	11a498 <pbuf_alloc>
  12f934:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
      if (r == NULL) {
  12f938:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12f93c:	e3530000 	cmp	r3, #0
  12f940:	0a00013a 	beq	12fe30 <icmp_input+0x700>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto icmperr;
      }
      if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
  12f944:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12f948:	e1d330ba 	ldrh	r3, [r3, #10]
  12f94c:	e1a02003 	mov	r2, r3
  12f950:	e15b30ba 	ldrh	r3, [fp, #-10]
  12f954:	e2833008 	add	r3, r3, #8
  12f958:	e1520003 	cmp	r2, r3
  12f95c:	2a000002 	bcs	12f96c <icmp_input+0x23c>
        LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
        pbuf_free(r);
  12f960:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  12f964:	ebffadd2 	bl	11b0b4 <pbuf_free>
        goto icmperr;
  12f968:	ea000131 	b	12fe34 <icmp_input+0x704>
      }
      /* copy the ip header */
      MEMCPY(r->payload, iphdr_in, hlen);
  12f96c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12f970:	e5933004 	ldr	r3, [r3, #4]
  12f974:	e15b20ba 	ldrh	r2, [fp, #-10]
  12f978:	e51b1008 	ldr	r1, [fp, #-8]
  12f97c:	e1a00003 	mov	r0, r3
  12f980:	eb004583 	bl	140f94 <memcpy>
      /* switch r->payload back to icmp header (cannot fail) */
      if (pbuf_header(r, (s16_t)-hlen)) {
  12f984:	e15b30ba 	ldrh	r3, [fp, #-10]
  12f988:	e2633000 	rsb	r3, r3, #0
  12f98c:	e6ff3073 	uxth	r3, r3
  12f990:	e6bf3073 	sxth	r3, r3
  12f994:	e1a01003 	mov	r1, r3
  12f998:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  12f99c:	ebffada6 	bl	11b03c <pbuf_header>
  12f9a0:	e1a03000 	mov	r3, r0
  12f9a4:	e3530000 	cmp	r3, #0
  12f9a8:	0a000009 	beq	12f9d4 <icmp_input+0x2a4>
        LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
  12f9ac:	e30906c0 	movw	r0, #38592	; 0x96c0
  12f9b0:	e3400014 	movt	r0, #20
  12f9b4:	ebff4dd6 	bl	103114 <rt_kprintf>
  12f9b8:	e3a010af 	mov	r1, #175	; 0xaf
  12f9bc:	e30906f8 	movw	r0, #38648	; 0x96f8
  12f9c0:	e3400014 	movt	r0, #20
  12f9c4:	ebff6dac 	bl	10b07c <sys_arch_assert>
        pbuf_free(r);
  12f9c8:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  12f9cc:	ebffadb8 	bl	11b0b4 <pbuf_free>
        goto icmperr;
  12f9d0:	ea000117 	b	12fe34 <icmp_input+0x704>
      }
      /* copy the rest of the packet without ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  12f9d4:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
  12f9d8:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  12f9dc:	ebffaf09 	bl	11b608 <pbuf_copy>
  12f9e0:	e1a03000 	mov	r3, r0
  12f9e4:	e3530000 	cmp	r3, #0
  12f9e8:	0a000002 	beq	12f9f8 <icmp_input+0x2c8>
        LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
        pbuf_free(r);
  12f9ec:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  12f9f0:	ebffadaf 	bl	11b0b4 <pbuf_free>
        goto icmperr;
  12f9f4:	ea00010e 	b	12fe34 <icmp_input+0x704>
      }
      /* free the original p */
      pbuf_free(p);
  12f9f8:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12f9fc:	ebffadac 	bl	11b0b4 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  12fa00:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  12fa04:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  12fa08:	ea000014 	b	12fa60 <icmp_input+0x330>
    } else {
      /* restore p->payload to point to icmp header (cannot fail) */
      if (pbuf_header(p, -(s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
  12fa0c:	e15b30ba 	ldrh	r3, [fp, #-10]
  12fa10:	e26334ff 	rsb	r3, r3, #-16777216	; 0xff000000
  12fa14:	e28338ff 	add	r3, r3, #16711680	; 0xff0000
  12fa18:	e2833cff 	add	r3, r3, #65280	; 0xff00
  12fa1c:	e28330f0 	add	r3, r3, #240	; 0xf0
  12fa20:	e6ff3073 	uxth	r3, r3
  12fa24:	e6bf3073 	sxth	r3, r3
  12fa28:	e1a01003 	mov	r1, r3
  12fa2c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12fa30:	ebffad81 	bl	11b03c <pbuf_header>
  12fa34:	e1a03000 	mov	r3, r0
  12fa38:	e3530000 	cmp	r3, #0
  12fa3c:	0a000007 	beq	12fa60 <icmp_input+0x330>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  12fa40:	e309072c 	movw	r0, #38700	; 0x972c
  12fa44:	e3400014 	movt	r0, #20
  12fa48:	ebff4db1 	bl	103114 <rt_kprintf>
  12fa4c:	e3a010c0 	mov	r1, #192	; 0xc0
  12fa50:	e30906f8 	movw	r0, #38648	; 0x96f8
  12fa54:	e3400014 	movt	r0, #20
  12fa58:	ebff6d87 	bl	10b07c <sys_arch_assert>
        goto icmperr;
  12fa5c:	ea0000f4 	b	12fe34 <icmp_input+0x704>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
  12fa60:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12fa64:	e5933004 	ldr	r3, [r3, #4]
  12fa68:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    if (pbuf_header(p, (s16_t)hlen)) {
  12fa6c:	e15b30fa 	ldrsh	r3, [fp, #-10]
  12fa70:	e1a01003 	mov	r1, r3
  12fa74:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12fa78:	ebffad6f 	bl	11b03c <pbuf_header>
  12fa7c:	e1a03000 	mov	r3, r0
  12fa80:	e3530000 	cmp	r3, #0
  12fa84:	1a0000ca 	bne	12fdb4 <icmp_input+0x684>
      LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
    } else {
      err_t ret;
      struct ip_hdr *iphdr = (struct ip_hdr*)p->payload;
  12fa88:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  12fa8c:	e5933004 	ldr	r3, [r3, #4]
  12fa90:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
      ip4_addr_copy(iphdr->src, *src);
  12fa94:	e51b3010 	ldr	r3, [fp, #-16]
  12fa98:	e5932000 	ldr	r2, [r3]
  12fa9c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12faa0:	e583200c 	str	r2, [r3, #12]
      ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
  12faa4:	e30035e8 	movw	r3, #1512	; 0x5e8
  12faa8:	e3403015 	movt	r3, #21
  12faac:	e5932010 	ldr	r2, [r3, #16]
  12fab0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12fab4:	e5832010 	str	r2, [r3, #16]
      ICMPH_TYPE_SET(iecho, ICMP_ER);
  12fab8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12fabc:	e3a02000 	mov	r2, #0
  12fac0:	e5c32000 	strb	r2, [r3]
#if CHECKSUM_GEN_ICMP
      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
        /* adjust the checksum */
        if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
  12fac4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12fac8:	e1d330b2 	ldrh	r3, [r3, #2]
  12facc:	e6ff3073 	uxth	r3, r3
  12fad0:	e30f2ff7 	movw	r2, #65527	; 0xfff7
  12fad4:	e1530002 	cmp	r3, r2
  12fad8:	9a000007 	bls	12fafc <icmp_input+0x3cc>
          iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
  12fadc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12fae0:	e1d330b2 	ldrh	r3, [r3, #2]
  12fae4:	e6ff3073 	uxth	r3, r3
  12fae8:	e2833009 	add	r3, r3, #9
  12faec:	e6ff2073 	uxth	r2, r3
  12faf0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12faf4:	e1c320b2 	strh	r2, [r3, #2]
  12faf8:	ea000006 	b	12fb18 <icmp_input+0x3e8>
        } else {
          iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
  12fafc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12fb00:	e1d330b2 	ldrh	r3, [r3, #2]
  12fb04:	e6ff3073 	uxth	r3, r3
  12fb08:	e2833008 	add	r3, r3, #8
  12fb0c:	e6ff2073 	uxth	r2, r3
  12fb10:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  12fb14:	e1c320b2 	strh	r2, [r3, #2]
#else /* CHECKSUM_GEN_ICMP */
      iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

      /* Set the correct TTL and recalculate the header checksum. */
      IPH_TTL_SET(iphdr, ICMP_TTL);
  12fb18:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12fb1c:	e3e02000 	mvn	r2, #0
  12fb20:	e5c32008 	strb	r2, [r3, #8]
      IPH_CHKSUM_SET(iphdr, 0);
  12fb24:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12fb28:	e3a02000 	mov	r2, #0
  12fb2c:	e5c3200a 	strb	r2, [r3, #10]
  12fb30:	e3a02000 	mov	r2, #0
  12fb34:	e5c3200b 	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_IP) {
        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, hlen));
  12fb38:	e15b30ba 	ldrh	r3, [fp, #-10]
  12fb3c:	e1a01003 	mov	r1, r3
  12fb40:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  12fb44:	ebffa432 	bl	118c14 <inet_chksum>
  12fb48:	e1a03000 	mov	r3, r0
  12fb4c:	e1a02003 	mov	r2, r3
  12fb50:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  12fb54:	e1c320ba 	strh	r2, [r3, #10]
      }
#endif /* CHECKSUM_GEN_IP */

      ICMP_STATS_INC(icmp.xmit);
  12fb58:	e3063840 	movw	r3, #26688	; 0x6840
  12fb5c:	e3403057 	movt	r3, #87	; 0x57
  12fb60:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  12fb64:	e2833001 	add	r3, r3, #1
  12fb68:	e6ff2073 	uxth	r2, r3
  12fb6c:	e3063840 	movw	r3, #26688	; 0x6840
  12fb70:	e3403057 	movt	r3, #87	; 0x57
  12fb74:	e1c326b0 	strh	r2, [r3, #96]	; 0x60
      /* increase number of messages attempted to send */
      MIB2_STATS_INC(mib2.icmpoutmsgs);
  12fb78:	e3063840 	movw	r3, #26688	; 0x6840
  12fb7c:	e3403057 	movt	r3, #87	; 0x57
  12fb80:	e59331d4 	ldr	r3, [r3, #468]	; 0x1d4
  12fb84:	e2832001 	add	r2, r3, #1
  12fb88:	e3063840 	movw	r3, #26688	; 0x6840
  12fb8c:	e3403057 	movt	r3, #87	; 0x57
  12fb90:	e58321d4 	str	r2, [r3, #468]	; 0x1d4
      /* increase number of echo replies attempted to send */
      MIB2_STATS_INC(mib2.icmpoutechoreps);
  12fb94:	e3063840 	movw	r3, #26688	; 0x6840
  12fb98:	e3403057 	movt	r3, #87	; 0x57
  12fb9c:	e59331e8 	ldr	r3, [r3, #488]	; 0x1e8
  12fba0:	e2832001 	add	r2, r3, #1
  12fba4:	e3063840 	movw	r3, #26688	; 0x6840
  12fba8:	e3403057 	movt	r3, #87	; 0x57
  12fbac:	e58321e8 	str	r2, [r3, #488]	; 0x1e8

      /* send an ICMP packet */
      ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
  12fbb0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  12fbb4:	e58d3008 	str	r3, [sp, #8]
  12fbb8:	e3a03001 	mov	r3, #1
  12fbbc:	e58d3004 	str	r3, [sp, #4]
  12fbc0:	e3a03000 	mov	r3, #0
  12fbc4:	e58d3000 	str	r3, [sp]
  12fbc8:	e3a030ff 	mov	r3, #255	; 0xff
  12fbcc:	e3a02000 	mov	r2, #0
  12fbd0:	e51b1010 	ldr	r1, [fp, #-16]
  12fbd4:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12fbd8:	eb0008c5 	bl	131ef4 <ip4_output_if>
  12fbdc:	e1a03000 	mov	r3, r0
  12fbe0:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
      }
    }
    break;
  12fbe4:	ea000072 	b	12fdb4 <icmp_input+0x684>
  default:
    if (type == ICMP_DUR) {
  12fbe8:	e55b300b 	ldrb	r3, [fp, #-11]
  12fbec:	e3530003 	cmp	r3, #3
  12fbf0:	1a000007 	bne	12fc14 <icmp_input+0x4e4>
      MIB2_STATS_INC(mib2.icmpindestunreachs);
  12fbf4:	e3063840 	movw	r3, #26688	; 0x6840
  12fbf8:	e3403057 	movt	r3, #87	; 0x57
  12fbfc:	e59331a8 	ldr	r3, [r3, #424]	; 0x1a8
  12fc00:	e2832001 	add	r2, r3, #1
  12fc04:	e3063840 	movw	r3, #26688	; 0x6840
  12fc08:	e3403057 	movt	r3, #87	; 0x57
  12fc0c:	e58321a8 	str	r2, [r3, #424]	; 0x1a8
  12fc10:	ea000056 	b	12fd70 <icmp_input+0x640>
    } else if (type == ICMP_TE) {
  12fc14:	e55b300b 	ldrb	r3, [fp, #-11]
  12fc18:	e353000b 	cmp	r3, #11
  12fc1c:	1a000007 	bne	12fc40 <icmp_input+0x510>
      MIB2_STATS_INC(mib2.icmpintimeexcds);
  12fc20:	e3063840 	movw	r3, #26688	; 0x6840
  12fc24:	e3403057 	movt	r3, #87	; 0x57
  12fc28:	e59331ac 	ldr	r3, [r3, #428]	; 0x1ac
  12fc2c:	e2832001 	add	r2, r3, #1
  12fc30:	e3063840 	movw	r3, #26688	; 0x6840
  12fc34:	e3403057 	movt	r3, #87	; 0x57
  12fc38:	e58321ac 	str	r2, [r3, #428]	; 0x1ac
  12fc3c:	ea00004b 	b	12fd70 <icmp_input+0x640>
    } else if (type == ICMP_PP) {
  12fc40:	e55b300b 	ldrb	r3, [fp, #-11]
  12fc44:	e353000c 	cmp	r3, #12
  12fc48:	1a000007 	bne	12fc6c <icmp_input+0x53c>
      MIB2_STATS_INC(mib2.icmpinparmprobs);
  12fc4c:	e3063840 	movw	r3, #26688	; 0x6840
  12fc50:	e3403057 	movt	r3, #87	; 0x57
  12fc54:	e59331b0 	ldr	r3, [r3, #432]	; 0x1b0
  12fc58:	e2832001 	add	r2, r3, #1
  12fc5c:	e3063840 	movw	r3, #26688	; 0x6840
  12fc60:	e3403057 	movt	r3, #87	; 0x57
  12fc64:	e58321b0 	str	r2, [r3, #432]	; 0x1b0
  12fc68:	ea000040 	b	12fd70 <icmp_input+0x640>
    } else if (type == ICMP_SQ) {
  12fc6c:	e55b300b 	ldrb	r3, [fp, #-11]
  12fc70:	e3530004 	cmp	r3, #4
  12fc74:	1a000007 	bne	12fc98 <icmp_input+0x568>
      MIB2_STATS_INC(mib2.icmpinsrcquenchs);
  12fc78:	e3063840 	movw	r3, #26688	; 0x6840
  12fc7c:	e3403057 	movt	r3, #87	; 0x57
  12fc80:	e59331b4 	ldr	r3, [r3, #436]	; 0x1b4
  12fc84:	e2832001 	add	r2, r3, #1
  12fc88:	e3063840 	movw	r3, #26688	; 0x6840
  12fc8c:	e3403057 	movt	r3, #87	; 0x57
  12fc90:	e58321b4 	str	r2, [r3, #436]	; 0x1b4
  12fc94:	ea000035 	b	12fd70 <icmp_input+0x640>
    } else if (type == ICMP_RD) {
  12fc98:	e55b300b 	ldrb	r3, [fp, #-11]
  12fc9c:	e3530005 	cmp	r3, #5
  12fca0:	1a000007 	bne	12fcc4 <icmp_input+0x594>
      MIB2_STATS_INC(mib2.icmpinredirects);
  12fca4:	e3063840 	movw	r3, #26688	; 0x6840
  12fca8:	e3403057 	movt	r3, #87	; 0x57
  12fcac:	e59331b8 	ldr	r3, [r3, #440]	; 0x1b8
  12fcb0:	e2832001 	add	r2, r3, #1
  12fcb4:	e3063840 	movw	r3, #26688	; 0x6840
  12fcb8:	e3403057 	movt	r3, #87	; 0x57
  12fcbc:	e58321b8 	str	r2, [r3, #440]	; 0x1b8
  12fcc0:	ea00002a 	b	12fd70 <icmp_input+0x640>
    } else if (type == ICMP_TS) {
  12fcc4:	e55b300b 	ldrb	r3, [fp, #-11]
  12fcc8:	e353000d 	cmp	r3, #13
  12fccc:	1a000007 	bne	12fcf0 <icmp_input+0x5c0>
      MIB2_STATS_INC(mib2.icmpintimestamps);
  12fcd0:	e3063840 	movw	r3, #26688	; 0x6840
  12fcd4:	e3403057 	movt	r3, #87	; 0x57
  12fcd8:	e59331c4 	ldr	r3, [r3, #452]	; 0x1c4
  12fcdc:	e2832001 	add	r2, r3, #1
  12fce0:	e3063840 	movw	r3, #26688	; 0x6840
  12fce4:	e3403057 	movt	r3, #87	; 0x57
  12fce8:	e58321c4 	str	r2, [r3, #452]	; 0x1c4
  12fcec:	ea00001f 	b	12fd70 <icmp_input+0x640>
    } else if (type == ICMP_TSR) {
  12fcf0:	e55b300b 	ldrb	r3, [fp, #-11]
  12fcf4:	e353000e 	cmp	r3, #14
  12fcf8:	1a000007 	bne	12fd1c <icmp_input+0x5ec>
      MIB2_STATS_INC(mib2.icmpintimestampreps);
  12fcfc:	e3063840 	movw	r3, #26688	; 0x6840
  12fd00:	e3403057 	movt	r3, #87	; 0x57
  12fd04:	e59331c8 	ldr	r3, [r3, #456]	; 0x1c8
  12fd08:	e2832001 	add	r2, r3, #1
  12fd0c:	e3063840 	movw	r3, #26688	; 0x6840
  12fd10:	e3403057 	movt	r3, #87	; 0x57
  12fd14:	e58321c8 	str	r2, [r3, #456]	; 0x1c8
  12fd18:	ea000014 	b	12fd70 <icmp_input+0x640>
    } else if (type == ICMP_AM) {
  12fd1c:	e55b300b 	ldrb	r3, [fp, #-11]
  12fd20:	e3530011 	cmp	r3, #17
  12fd24:	1a000007 	bne	12fd48 <icmp_input+0x618>
      MIB2_STATS_INC(mib2.icmpinaddrmasks);
  12fd28:	e3063840 	movw	r3, #26688	; 0x6840
  12fd2c:	e3403057 	movt	r3, #87	; 0x57
  12fd30:	e59331cc 	ldr	r3, [r3, #460]	; 0x1cc
  12fd34:	e2832001 	add	r2, r3, #1
  12fd38:	e3063840 	movw	r3, #26688	; 0x6840
  12fd3c:	e3403057 	movt	r3, #87	; 0x57
  12fd40:	e58321cc 	str	r2, [r3, #460]	; 0x1cc
  12fd44:	ea000009 	b	12fd70 <icmp_input+0x640>
    } else if (type == ICMP_AMR) {
  12fd48:	e55b300b 	ldrb	r3, [fp, #-11]
  12fd4c:	e3530012 	cmp	r3, #18
  12fd50:	1a000006 	bne	12fd70 <icmp_input+0x640>
      MIB2_STATS_INC(mib2.icmpinaddrmaskreps);
  12fd54:	e3063840 	movw	r3, #26688	; 0x6840
  12fd58:	e3403057 	movt	r3, #87	; 0x57
  12fd5c:	e59331d0 	ldr	r3, [r3, #464]	; 0x1d0
  12fd60:	e2832001 	add	r2, r3, #1
  12fd64:	e3063840 	movw	r3, #26688	; 0x6840
  12fd68:	e3403057 	movt	r3, #87	; 0x57
  12fd6c:	e58321d0 	str	r2, [r3, #464]	; 0x1d0
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
  12fd70:	e3063840 	movw	r3, #26688	; 0x6840
  12fd74:	e3403057 	movt	r3, #87	; 0x57
  12fd78:	e1d337b0 	ldrh	r3, [r3, #112]	; 0x70
  12fd7c:	e2833001 	add	r3, r3, #1
  12fd80:	e6ff2073 	uxth	r2, r3
  12fd84:	e3063840 	movw	r3, #26688	; 0x6840
  12fd88:	e3403057 	movt	r3, #87	; 0x57
  12fd8c:	e1c327b0 	strh	r2, [r3, #112]	; 0x70
    ICMP_STATS_INC(icmp.drop);
  12fd90:	e3063840 	movw	r3, #26688	; 0x6840
  12fd94:	e3403057 	movt	r3, #87	; 0x57
  12fd98:	e1d336b6 	ldrh	r3, [r3, #102]	; 0x66
  12fd9c:	e2833001 	add	r3, r3, #1
  12fda0:	e6ff2073 	uxth	r2, r3
  12fda4:	e3063840 	movw	r3, #26688	; 0x6840
  12fda8:	e3403057 	movt	r3, #87	; 0x57
  12fdac:	e1c326b6 	strh	r2, [r3, #102]	; 0x66
  12fdb0:	ea000000 	b	12fdb8 <icmp_input+0x688>
    break;
  12fdb4:	e320f000 	nop	{0}
  }
  pbuf_free(p);
  12fdb8:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12fdbc:	ebffacbc 	bl	11b0b4 <pbuf_free>
  return;
  12fdc0:	ea00002d 	b	12fe7c <icmp_input+0x74c>
    goto lenerr;
  12fdc4:	e320f000 	nop	{0}
  12fdc8:	ea000002 	b	12fdd8 <icmp_input+0x6a8>
    goto lenerr;
  12fdcc:	e320f000 	nop	{0}
  12fdd0:	ea000000 	b	12fdd8 <icmp_input+0x6a8>
      goto lenerr;
  12fdd4:	e320f000 	nop	{0}
lenerr:
  pbuf_free(p);
  12fdd8:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12fddc:	ebffacb4 	bl	11b0b4 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  12fde0:	e3063840 	movw	r3, #26688	; 0x6840
  12fde4:	e3403057 	movt	r3, #87	; 0x57
  12fde8:	e1d336ba 	ldrh	r3, [r3, #106]	; 0x6a
  12fdec:	e2833001 	add	r3, r3, #1
  12fdf0:	e6ff2073 	uxth	r2, r3
  12fdf4:	e3063840 	movw	r3, #26688	; 0x6840
  12fdf8:	e3403057 	movt	r3, #87	; 0x57
  12fdfc:	e1c326ba 	strh	r2, [r3, #106]	; 0x6a
  MIB2_STATS_INC(mib2.icmpinerrors);
  12fe00:	e3063840 	movw	r3, #26688	; 0x6840
  12fe04:	e3403057 	movt	r3, #87	; 0x57
  12fe08:	e59331a4 	ldr	r3, [r3, #420]	; 0x1a4
  12fe0c:	e2832001 	add	r2, r3, #1
  12fe10:	e3063840 	movw	r3, #26688	; 0x6840
  12fe14:	e3403057 	movt	r3, #87	; 0x57
  12fe18:	e58321a4 	str	r2, [r3, #420]	; 0x1a4
  return;
  12fe1c:	ea000016 	b	12fe7c <icmp_input+0x74c>
      goto icmperr;
  12fe20:	e320f000 	nop	{0}
  12fe24:	ea000002 	b	12fe34 <icmp_input+0x704>
      goto icmperr;
  12fe28:	e320f000 	nop	{0}
  12fe2c:	ea000000 	b	12fe34 <icmp_input+0x704>
        goto icmperr;
  12fe30:	e320f000 	nop	{0}
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
icmperr:
  pbuf_free(p);
  12fe34:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  12fe38:	ebffac9d 	bl	11b0b4 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  12fe3c:	e3063840 	movw	r3, #26688	; 0x6840
  12fe40:	e3403057 	movt	r3, #87	; 0x57
  12fe44:	e1d337b4 	ldrh	r3, [r3, #116]	; 0x74
  12fe48:	e2833001 	add	r3, r3, #1
  12fe4c:	e6ff2073 	uxth	r2, r3
  12fe50:	e3063840 	movw	r3, #26688	; 0x6840
  12fe54:	e3403057 	movt	r3, #87	; 0x57
  12fe58:	e1c327b4 	strh	r2, [r3, #116]	; 0x74
  MIB2_STATS_INC(mib2.icmpinerrors);
  12fe5c:	e3063840 	movw	r3, #26688	; 0x6840
  12fe60:	e3403057 	movt	r3, #87	; 0x57
  12fe64:	e59331a4 	ldr	r3, [r3, #420]	; 0x1a4
  12fe68:	e2832001 	add	r2, r3, #1
  12fe6c:	e3063840 	movw	r3, #26688	; 0x6840
  12fe70:	e3403057 	movt	r3, #87	; 0x57
  12fe74:	e58321a4 	str	r2, [r3, #420]	; 0x1a4
  return;
  12fe78:	e320f000 	nop	{0}
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
}
  12fe7c:	e24bd004 	sub	sp, fp, #4
  12fe80:	e8bd8800 	pop	{fp, pc}
  12fe84:	001505fc 	.word	0x001505fc

0012fe88 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  12fe88:	e92d4800 	push	{fp, lr}
  12fe8c:	e28db004 	add	fp, sp, #4
  12fe90:	e24dd008 	sub	sp, sp, #8
  12fe94:	e50b0008 	str	r0, [fp, #-8]
  12fe98:	e50b100c 	str	r1, [fp, #-12]
  MIB2_STATS_INC(mib2.icmpoutdestunreachs);
  12fe9c:	e3063840 	movw	r3, #26688	; 0x6840
  12fea0:	e3403057 	movt	r3, #87	; 0x57
  12fea4:	e59331dc 	ldr	r3, [r3, #476]	; 0x1dc
  12fea8:	e2832001 	add	r2, r3, #1
  12feac:	e3063840 	movw	r3, #26688	; 0x6840
  12feb0:	e3403057 	movt	r3, #87	; 0x57
  12feb4:	e58321dc 	str	r2, [r3, #476]	; 0x1dc
  icmp_send_response(p, ICMP_DUR, t);
  12feb8:	e51b300c 	ldr	r3, [fp, #-12]
  12febc:	e6ef3073 	uxtb	r3, r3
  12fec0:	e1a02003 	mov	r2, r3
  12fec4:	e3a01003 	mov	r1, #3
  12fec8:	e51b0008 	ldr	r0, [fp, #-8]
  12fecc:	eb000017 	bl	12ff30 <icmp_send_response>
}
  12fed0:	e320f000 	nop	{0}
  12fed4:	e24bd004 	sub	sp, fp, #4
  12fed8:	e8bd8800 	pop	{fp, pc}

0012fedc <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  12fedc:	e92d4800 	push	{fp, lr}
  12fee0:	e28db004 	add	fp, sp, #4
  12fee4:	e24dd008 	sub	sp, sp, #8
  12fee8:	e50b0008 	str	r0, [fp, #-8]
  12feec:	e50b100c 	str	r1, [fp, #-12]
  MIB2_STATS_INC(mib2.icmpouttimeexcds);
  12fef0:	e3063840 	movw	r3, #26688	; 0x6840
  12fef4:	e3403057 	movt	r3, #87	; 0x57
  12fef8:	e59331e0 	ldr	r3, [r3, #480]	; 0x1e0
  12fefc:	e2832001 	add	r2, r3, #1
  12ff00:	e3063840 	movw	r3, #26688	; 0x6840
  12ff04:	e3403057 	movt	r3, #87	; 0x57
  12ff08:	e58321e0 	str	r2, [r3, #480]	; 0x1e0
  icmp_send_response(p, ICMP_TE, t);
  12ff0c:	e51b300c 	ldr	r3, [fp, #-12]
  12ff10:	e6ef3073 	uxtb	r3, r3
  12ff14:	e1a02003 	mov	r2, r3
  12ff18:	e3a0100b 	mov	r1, #11
  12ff1c:	e51b0008 	ldr	r0, [fp, #-8]
  12ff20:	eb000002 	bl	12ff30 <icmp_send_response>
}
  12ff24:	e320f000 	nop	{0}
  12ff28:	e24bd004 	sub	sp, fp, #4
  12ff2c:	e8bd8800 	pop	{fp, pc}

0012ff30 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
  12ff30:	e92d4800 	push	{fp, lr}
  12ff34:	e28db004 	add	fp, sp, #4
  12ff38:	e24dd030 	sub	sp, sp, #48	; 0x30
  12ff3c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  12ff40:	e1a03001 	mov	r3, r1
  12ff44:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
  12ff48:	e1a03002 	mov	r3, r2
  12ff4c:	e54b3022 	strb	r3, [fp, #-34]	; 0xffffffde
  struct icmp_echo_hdr *icmphdr;
  ip4_addr_t iphdr_src;
  struct netif *netif;

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);
  12ff50:	e3063840 	movw	r3, #26688	; 0x6840
  12ff54:	e3403057 	movt	r3, #87	; 0x57
  12ff58:	e59331d4 	ldr	r3, [r3, #468]	; 0x1d4
  12ff5c:	e2832001 	add	r2, r3, #1
  12ff60:	e3063840 	movw	r3, #26688	; 0x6840
  12ff64:	e3403057 	movt	r3, #87	; 0x57
  12ff68:	e58321d4 	str	r2, [r3, #468]	; 0x1d4

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  12ff6c:	e3a02000 	mov	r2, #0
  12ff70:	e3a01024 	mov	r1, #36	; 0x24
  12ff74:	e3a00001 	mov	r0, #1
  12ff78:	ebffa946 	bl	11a498 <pbuf_alloc>
  12ff7c:	e50b0008 	str	r0, [fp, #-8]
                 PBUF_RAM);
  if (q == NULL) {
  12ff80:	e51b3008 	ldr	r3, [fp, #-8]
  12ff84:	e3530000 	cmp	r3, #0
  12ff88:	1a000007 	bne	12ffac <icmp_send_response+0x7c>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
  12ff8c:	e3063840 	movw	r3, #26688	; 0x6840
  12ff90:	e3403057 	movt	r3, #87	; 0x57
  12ff94:	e59331d8 	ldr	r3, [r3, #472]	; 0x1d8
  12ff98:	e2832001 	add	r2, r3, #1
  12ff9c:	e3063840 	movw	r3, #26688	; 0x6840
  12ffa0:	e3403057 	movt	r3, #87	; 0x57
  12ffa4:	e58321d8 	str	r2, [r3, #472]	; 0x1d8
  12ffa8:	ea000055 	b	130104 <icmp_send_response+0x1d4>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  12ffac:	e51b3008 	ldr	r3, [fp, #-8]
  12ffb0:	e1d330ba 	ldrh	r3, [r3, #10]
  12ffb4:	e3530023 	cmp	r3, #35	; 0x23
  12ffb8:	8a000006 	bhi	12ffd8 <icmp_send_response+0xa8>
  12ffbc:	e3090760 	movw	r0, #38752	; 0x9760
  12ffc0:	e3400014 	movt	r0, #20
  12ffc4:	ebff4c52 	bl	103114 <rt_kprintf>
  12ffc8:	e3001162 	movw	r1, #354	; 0x162
  12ffcc:	e30906f8 	movw	r0, #38648	; 0x96f8
  12ffd0:	e3400014 	movt	r0, #20
  12ffd4:	ebff6c28 	bl	10b07c <sys_arch_assert>
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
  12ffd8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  12ffdc:	e5933004 	ldr	r3, [r3, #4]
  12ffe0:	e50b300c 	str	r3, [fp, #-12]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  12ffe4:	e51b3008 	ldr	r3, [fp, #-8]
  12ffe8:	e5933004 	ldr	r3, [r3, #4]
  12ffec:	e50b3010 	str	r3, [fp, #-16]
  icmphdr->type = type;
  12fff0:	e51b3010 	ldr	r3, [fp, #-16]
  12fff4:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
  12fff8:	e5c32000 	strb	r2, [r3]
  icmphdr->code = code;
  12fffc:	e51b3010 	ldr	r3, [fp, #-16]
  130000:	e55b2022 	ldrb	r2, [fp, #-34]	; 0xffffffde
  130004:	e5c32001 	strb	r2, [r3, #1]
  icmphdr->id = 0;
  130008:	e51b3010 	ldr	r3, [fp, #-16]
  13000c:	e3a02000 	mov	r2, #0
  130010:	e5c32004 	strb	r2, [r3, #4]
  130014:	e3a02000 	mov	r2, #0
  130018:	e5c32005 	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
  13001c:	e51b3010 	ldr	r3, [fp, #-16]
  130020:	e3a02000 	mov	r2, #0
  130024:	e5c32006 	strb	r2, [r3, #6]
  130028:	e3a02000 	mov	r2, #0
  13002c:	e5c32007 	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
  130030:	e51b3008 	ldr	r3, [fp, #-8]
  130034:	e5933004 	ldr	r3, [r3, #4]
  130038:	e2830008 	add	r0, r3, #8
  13003c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  130040:	e5933004 	ldr	r3, [r3, #4]
  130044:	e3a0201c 	mov	r2, #28
  130048:	e1a01003 	mov	r1, r3
  13004c:	eb0043d0 	bl	140f94 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
  130050:	e51b300c 	ldr	r3, [fp, #-12]
  130054:	e593300c 	ldr	r3, [r3, #12]
  130058:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_src, &iphdr_dst);
  }
#else
  netif = ip4_route(&iphdr_src);
  13005c:	e24b3018 	sub	r3, fp, #24
  130060:	e1a00003 	mov	r0, r3
  130064:	eb0004c9 	bl	131390 <ip4_route>
  130068:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
#endif
  if (netif != NULL) {
  13006c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130070:	e3530000 	cmp	r3, #0
  130074:	0a000020 	beq	1300fc <icmp_send_response+0x1cc>
    /* calculate checksum */
    icmphdr->chksum = 0;
  130078:	e51b3010 	ldr	r3, [fp, #-16]
  13007c:	e3a02000 	mov	r2, #0
  130080:	e5c32002 	strb	r2, [r3, #2]
  130084:	e3a02000 	mov	r2, #0
  130088:	e5c32003 	strb	r2, [r3, #3]
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
  13008c:	e51b3008 	ldr	r3, [fp, #-8]
  130090:	e1d330ba 	ldrh	r3, [r3, #10]
  130094:	e1a01003 	mov	r1, r3
  130098:	e51b0010 	ldr	r0, [fp, #-16]
  13009c:	ebffa2dc 	bl	118c14 <inet_chksum>
  1300a0:	e1a03000 	mov	r3, r0
  1300a4:	e1a02003 	mov	r2, r3
  1300a8:	e51b3010 	ldr	r3, [fp, #-16]
  1300ac:	e1c320b2 	strh	r2, [r3, #2]
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
  1300b0:	e3063840 	movw	r3, #26688	; 0x6840
  1300b4:	e3403057 	movt	r3, #87	; 0x57
  1300b8:	e1d336b0 	ldrh	r3, [r3, #96]	; 0x60
  1300bc:	e2833001 	add	r3, r3, #1
  1300c0:	e6ff2073 	uxth	r2, r3
  1300c4:	e3063840 	movw	r3, #26688	; 0x6840
  1300c8:	e3403057 	movt	r3, #87	; 0x57
  1300cc:	e1c326b0 	strh	r2, [r3, #96]	; 0x60
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
  1300d0:	e24b2018 	sub	r2, fp, #24
  1300d4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1300d8:	e58d3008 	str	r3, [sp, #8]
  1300dc:	e3a03001 	mov	r3, #1
  1300e0:	e58d3004 	str	r3, [sp, #4]
  1300e4:	e3a03000 	mov	r3, #0
  1300e8:	e58d3000 	str	r3, [sp]
  1300ec:	e3a030ff 	mov	r3, #255	; 0xff
  1300f0:	e3a01000 	mov	r1, #0
  1300f4:	e51b0008 	ldr	r0, [fp, #-8]
  1300f8:	eb00077d 	bl	131ef4 <ip4_output_if>
  }
  pbuf_free(q);
  1300fc:	e51b0008 	ldr	r0, [fp, #-8]
  130100:	ebffabeb 	bl	11b0b4 <pbuf_free>
}
  130104:	e24bd004 	sub	sp, fp, #4
  130108:	e8bd8800 	pop	{fp, pc}

0013010c <igmp_init>:
/**
 * Initialize the IGMP module
 */
void
igmp_init(void)
{
  13010c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  130110:	e28db000 	add	fp, sp, #0
  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_init: initializing\n"));

  IP4_ADDR(&allsystems, 224, 0, 0, 1);
  130114:	e30f2bc8 	movw	r2, #64456	; 0xfbc8
  130118:	e3402014 	movt	r2, #20
  13011c:	e3a030e0 	mov	r3, #224	; 0xe0
  130120:	e3403100 	movt	r3, #256	; 0x100
  130124:	e5823000 	str	r3, [r2]
  IP4_ADDR(&allrouters, 224, 0, 0, 2);
  130128:	e30f2bcc 	movw	r2, #64460	; 0xfbcc
  13012c:	e3402014 	movt	r2, #20
  130130:	e3a030e0 	mov	r3, #224	; 0xe0
  130134:	e3403200 	movt	r3, #512	; 0x200
  130138:	e5823000 	str	r3, [r2]
}
  13013c:	e320f000 	nop	{0}
  130140:	e28bd000 	add	sp, fp, #0
  130144:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  130148:	e12fff1e 	bx	lr

0013014c <igmp_start>:
 *
 * @param netif network interface on which start IGMP processing
 */
err_t
igmp_start(struct netif *netif)
{
  13014c:	e92d4800 	push	{fp, lr}
  130150:	e28db004 	add	fp, sp, #4
  130154:	e24dd010 	sub	sp, sp, #16
  130158:	e50b0010 	str	r0, [fp, #-16]
  struct igmp_group* group;

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_start: starting IGMP processing on if %p\n", (void*)netif));

  group = igmp_lookup_group(netif, &allsystems);
  13015c:	e30f1bc8 	movw	r1, #64456	; 0xfbc8
  130160:	e3401014 	movt	r1, #20
  130164:	e51b0010 	ldr	r0, [fp, #-16]
  130168:	eb000078 	bl	130350 <igmp_lookup_group>
  13016c:	e50b0008 	str	r0, [fp, #-8]

  if (group != NULL) {
  130170:	e51b3008 	ldr	r3, [fp, #-8]
  130174:	e3530000 	cmp	r3, #0
  130178:	0a000015 	beq	1301d4 <igmp_start+0x88>
    group->group_state = IGMP_GROUP_IDLE_MEMBER;
  13017c:	e51b3008 	ldr	r3, [fp, #-8]
  130180:	e3a02002 	mov	r2, #2
  130184:	e5c32009 	strb	r2, [r3, #9]
    group->use++;
  130188:	e51b3008 	ldr	r3, [fp, #-8]
  13018c:	e5d3300c 	ldrb	r3, [r3, #12]
  130190:	e2833001 	add	r3, r3, #1
  130194:	e6ef2073 	uxtb	r2, r3
  130198:	e51b3008 	ldr	r3, [fp, #-8]
  13019c:	e5c3200c 	strb	r2, [r3, #12]

    /* Allow the igmp messages at the MAC level */
    if (netif->igmp_mac_filter != NULL) {
  1301a0:	e51b3010 	ldr	r3, [fp, #-16]
  1301a4:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  1301a8:	e3530000 	cmp	r3, #0
  1301ac:	0a000006 	beq	1301cc <igmp_start+0x80>
      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_start: igmp_mac_filter(ADD "));
      ip4_addr_debug_print_val(IGMP_DEBUG, allsystems);
      LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", (void*)netif));
      netif->igmp_mac_filter(netif, &allsystems, NETIF_ADD_MAC_FILTER);
  1301b0:	e51b3010 	ldr	r3, [fp, #-16]
  1301b4:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  1301b8:	e3a02001 	mov	r2, #1
  1301bc:	e30f1bc8 	movw	r1, #64456	; 0xfbc8
  1301c0:	e3401014 	movt	r1, #20
  1301c4:	e51b0010 	ldr	r0, [fp, #-16]
  1301c8:	e12fff33 	blx	r3
    }

    return ERR_OK;
  1301cc:	e3a03000 	mov	r3, #0
  1301d0:	ea000000 	b	1301d8 <igmp_start+0x8c>
  }

  return ERR_MEM;
  1301d4:	e3e03000 	mvn	r3, #0
}
  1301d8:	e1a00003 	mov	r0, r3
  1301dc:	e24bd004 	sub	sp, fp, #4
  1301e0:	e8bd8800 	pop	{fp, pc}

001301e4 <igmp_stop>:
 *
 * @param netif network interface on which stop IGMP processing
 */
err_t
igmp_stop(struct netif *netif)
{
  1301e4:	e92d4800 	push	{fp, lr}
  1301e8:	e28db004 	add	fp, sp, #4
  1301ec:	e24dd010 	sub	sp, sp, #16
  1301f0:	e50b0010 	str	r0, [fp, #-16]
  struct igmp_group *group = netif_igmp_data(netif);
  1301f4:	e51b3010 	ldr	r3, [fp, #-16]
  1301f8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  1301fc:	e50b3008 	str	r3, [fp, #-8]

  netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_IGMP, NULL);
  130200:	e51b3010 	ldr	r3, [fp, #-16]
  130204:	e3a02000 	mov	r2, #0
  130208:	e583202c 	str	r2, [r3, #44]	; 0x2c

  while (group != NULL) {
  13020c:	ea000012 	b	13025c <igmp_stop+0x78>
    struct igmp_group *next = group->next; /* avoid use-after-free below */
  130210:	e51b3008 	ldr	r3, [fp, #-8]
  130214:	e5933000 	ldr	r3, [r3]
  130218:	e50b300c 	str	r3, [fp, #-12]

    /* disable the group at the MAC level */
    if (netif->igmp_mac_filter != NULL) {
  13021c:	e51b3010 	ldr	r3, [fp, #-16]
  130220:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  130224:	e3530000 	cmp	r3, #0
  130228:	0a000006 	beq	130248 <igmp_stop+0x64>
      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_stop: igmp_mac_filter(DEL "));
      ip4_addr_debug_print(IGMP_DEBUG, &group->group_address);
      LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", (void*)netif));
      netif->igmp_mac_filter(netif, &(group->group_address), NETIF_DEL_MAC_FILTER);
  13022c:	e51b3010 	ldr	r3, [fp, #-16]
  130230:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  130234:	e51b2008 	ldr	r2, [fp, #-8]
  130238:	e2821004 	add	r1, r2, #4
  13023c:	e3a02000 	mov	r2, #0
  130240:	e51b0010 	ldr	r0, [fp, #-16]
  130244:	e12fff33 	blx	r3
    }

    /* free group */
    memp_free(MEMP_IGMP_GROUP, group);
  130248:	e51b1008 	ldr	r1, [fp, #-8]
  13024c:	e3a0000c 	mov	r0, #12
  130250:	ebffa489 	bl	11947c <memp_free>

    /* move to "next" */
    group = next;
  130254:	e51b300c 	ldr	r3, [fp, #-12]
  130258:	e50b3008 	str	r3, [fp, #-8]
  while (group != NULL) {
  13025c:	e51b3008 	ldr	r3, [fp, #-8]
  130260:	e3530000 	cmp	r3, #0
  130264:	1affffe9 	bne	130210 <igmp_stop+0x2c>
  }
  return ERR_OK;
  130268:	e3a03000 	mov	r3, #0
}
  13026c:	e1a00003 	mov	r0, r3
  130270:	e24bd004 	sub	sp, fp, #4
  130274:	e8bd8800 	pop	{fp, pc}

00130278 <igmp_report_groups>:
 *
 * @param netif network interface on which report IGMP memberships
 */
void
igmp_report_groups(struct netif *netif)
{
  130278:	e92d4800 	push	{fp, lr}
  13027c:	e28db004 	add	fp, sp, #4
  130280:	e24dd010 	sub	sp, sp, #16
  130284:	e50b0010 	str	r0, [fp, #-16]
  struct igmp_group *group = netif_igmp_data(netif);
  130288:	e51b3010 	ldr	r3, [fp, #-16]
  13028c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  130290:	e50b3008 	str	r3, [fp, #-8]

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_report_groups: sending IGMP reports on if %p\n", (void*)netif));

  /* Skip the first group in the list, it is always the allsystems group added in igmp_start() */
  if(group != NULL) {
  130294:	e51b3008 	ldr	r3, [fp, #-8]
  130298:	e3530000 	cmp	r3, #0
  13029c:	0a000009 	beq	1302c8 <igmp_report_groups+0x50>
    group = group->next;
  1302a0:	e51b3008 	ldr	r3, [fp, #-8]
  1302a4:	e5933000 	ldr	r3, [r3]
  1302a8:	e50b3008 	str	r3, [fp, #-8]
  }
  
  while (group != NULL) {
  1302ac:	ea000005 	b	1302c8 <igmp_report_groups+0x50>
    igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
  1302b0:	e3a01005 	mov	r1, #5
  1302b4:	e51b0008 	ldr	r0, [fp, #-8]
  1302b8:	eb000372 	bl	131088 <igmp_delaying_member>
    group = group->next;
  1302bc:	e51b3008 	ldr	r3, [fp, #-8]
  1302c0:	e5933000 	ldr	r3, [r3]
  1302c4:	e50b3008 	str	r3, [fp, #-8]
  while (group != NULL) {
  1302c8:	e51b3008 	ldr	r3, [fp, #-8]
  1302cc:	e3530000 	cmp	r3, #0
  1302d0:	1afffff6 	bne	1302b0 <igmp_report_groups+0x38>
  }
}
  1302d4:	e320f000 	nop	{0}
  1302d8:	e24bd004 	sub	sp, fp, #4
  1302dc:	e8bd8800 	pop	{fp, pc}

001302e0 <igmp_lookfor_group>:
 * @return a struct igmp_group* if the group has been found,
 *         NULL if the group wasn't found.
 */
struct igmp_group *
igmp_lookfor_group(struct netif *ifp, const ip4_addr_t *addr)
{
  1302e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1302e4:	e28db000 	add	fp, sp, #0
  1302e8:	e24dd014 	sub	sp, sp, #20
  1302ec:	e50b0010 	str	r0, [fp, #-16]
  1302f0:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct igmp_group *group = netif_igmp_data(ifp);
  1302f4:	e51b3010 	ldr	r3, [fp, #-16]
  1302f8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  1302fc:	e50b3008 	str	r3, [fp, #-8]

  while (group != NULL) {
  130300:	ea00000a 	b	130330 <igmp_lookfor_group+0x50>
    if (ip4_addr_cmp(&(group->group_address), addr)) {
  130304:	e51b3008 	ldr	r3, [fp, #-8]
  130308:	e5932004 	ldr	r2, [r3, #4]
  13030c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130310:	e5933000 	ldr	r3, [r3]
  130314:	e1520003 	cmp	r2, r3
  130318:	1a000001 	bne	130324 <igmp_lookfor_group+0x44>
      return group;
  13031c:	e51b3008 	ldr	r3, [fp, #-8]
  130320:	ea000006 	b	130340 <igmp_lookfor_group+0x60>
    }
    group = group->next;
  130324:	e51b3008 	ldr	r3, [fp, #-8]
  130328:	e5933000 	ldr	r3, [r3]
  13032c:	e50b3008 	str	r3, [fp, #-8]
  while (group != NULL) {
  130330:	e51b3008 	ldr	r3, [fp, #-8]
  130334:	e3530000 	cmp	r3, #0
  130338:	1afffff1 	bne	130304 <igmp_lookfor_group+0x24>
  }

  /* to be clearer, we return NULL here instead of
   * 'group' (which is also NULL at this point).
   */
  return NULL;
  13033c:	e3a03000 	mov	r3, #0
}
  130340:	e1a00003 	mov	r0, r3
  130344:	e28bd000 	add	sp, fp, #0
  130348:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  13034c:	e12fff1e 	bx	lr

00130350 <igmp_lookup_group>:
 * @return a struct igmp_group*,
 *         NULL on memory error.
 */
static struct igmp_group *
igmp_lookup_group(struct netif *ifp, const ip4_addr_t *addr)
{
  130350:	e92d4800 	push	{fp, lr}
  130354:	e28db004 	add	fp, sp, #4
  130358:	e24dd010 	sub	sp, sp, #16
  13035c:	e50b0010 	str	r0, [fp, #-16]
  130360:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct igmp_group *group;
  struct igmp_group *list_head = netif_igmp_data(ifp);
  130364:	e51b3010 	ldr	r3, [fp, #-16]
  130368:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  13036c:	e50b3008 	str	r3, [fp, #-8]

  /* Search if the group already exists */
  group = igmp_lookfor_group(ifp, addr);
  130370:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  130374:	e51b0010 	ldr	r0, [fp, #-16]
  130378:	ebffffd8 	bl	1302e0 <igmp_lookfor_group>
  13037c:	e50b000c 	str	r0, [fp, #-12]
  if (group != NULL) {
  130380:	e51b300c 	ldr	r3, [fp, #-12]
  130384:	e3530000 	cmp	r3, #0
  130388:	0a000001 	beq	130394 <igmp_lookup_group+0x44>
    /* Group already exists. */
    return group;
  13038c:	e51b300c 	ldr	r3, [fp, #-12]
  130390:	ea00004b 	b	1304c4 <igmp_lookup_group+0x174>
  }
  
  /* Group doesn't exist yet, create a new one */
  group = (struct igmp_group *)memp_malloc(MEMP_IGMP_GROUP);
  130394:	e3002101 	movw	r2, #257	; 0x101
  130398:	e309178c 	movw	r1, #38796	; 0x978c
  13039c:	e3401014 	movt	r1, #20
  1303a0:	e3a0000c 	mov	r0, #12
  1303a4:	ebffa3cc 	bl	1192dc <memp_malloc_fn>
  1303a8:	e50b000c 	str	r0, [fp, #-12]
  if (group != NULL) {
  1303ac:	e51b300c 	ldr	r3, [fp, #-12]
  1303b0:	e3530000 	cmp	r3, #0
  1303b4:	0a000041 	beq	1304c0 <igmp_lookup_group+0x170>
    ip4_addr_set(&(group->group_address), addr);
  1303b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1303bc:	e3530000 	cmp	r3, #0
  1303c0:	0a000002 	beq	1303d0 <igmp_lookup_group+0x80>
  1303c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1303c8:	e5933000 	ldr	r3, [r3]
  1303cc:	ea000000 	b	1303d4 <igmp_lookup_group+0x84>
  1303d0:	e3a03000 	mov	r3, #0
  1303d4:	e51b200c 	ldr	r2, [fp, #-12]
  1303d8:	e5823004 	str	r3, [r2, #4]
    group->timer              = 0; /* Not running */
  1303dc:	e51b300c 	ldr	r3, [fp, #-12]
  1303e0:	e3a02000 	mov	r2, #0
  1303e4:	e1c320ba 	strh	r2, [r3, #10]
    group->group_state        = IGMP_GROUP_NON_MEMBER;
  1303e8:	e51b300c 	ldr	r3, [fp, #-12]
  1303ec:	e3a02000 	mov	r2, #0
  1303f0:	e5c32009 	strb	r2, [r3, #9]
    group->last_reporter_flag = 0;
  1303f4:	e51b300c 	ldr	r3, [fp, #-12]
  1303f8:	e3a02000 	mov	r2, #0
  1303fc:	e5c32008 	strb	r2, [r3, #8]
    group->use                = 0;
  130400:	e51b300c 	ldr	r3, [fp, #-12]
  130404:	e3a02000 	mov	r2, #0
  130408:	e5c3200c 	strb	r2, [r3, #12]

    /* Ensure allsystems group is always first in list */    
    if (list_head == NULL) {
  13040c:	e51b3008 	ldr	r3, [fp, #-8]
  130410:	e3530000 	cmp	r3, #0
  130414:	1a000014 	bne	13046c <igmp_lookup_group+0x11c>
      /* this is the first entry in linked list */
      LWIP_ASSERT("igmp_lookup_group: first group must be allsystems",
  130418:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13041c:	e5932000 	ldr	r2, [r3]
  130420:	e30f3bc8 	movw	r3, #64456	; 0xfbc8
  130424:	e3403014 	movt	r3, #20
  130428:	e5933000 	ldr	r3, [r3]
  13042c:	e1520003 	cmp	r2, r3
  130430:	0a000006 	beq	130450 <igmp_lookup_group+0x100>
  130434:	e30907c0 	movw	r0, #38848	; 0x97c0
  130438:	e3400014 	movt	r0, #20
  13043c:	ebff4b34 	bl	103114 <rt_kprintf>
  130440:	e300110d 	movw	r1, #269	; 0x10d
  130444:	e309078c 	movw	r0, #38796	; 0x978c
  130448:	e3400014 	movt	r0, #20
  13044c:	ebff6b0a 	bl	10b07c <sys_arch_assert>
        (ip4_addr_cmp(addr, &allsystems) != 0));
      group->next = NULL;
  130450:	e51b300c 	ldr	r3, [fp, #-12]
  130454:	e3a02000 	mov	r2, #0
  130458:	e5832000 	str	r2, [r3]
      netif_set_client_data(ifp, LWIP_NETIF_CLIENT_DATA_INDEX_IGMP, group);
  13045c:	e51b3010 	ldr	r3, [fp, #-16]
  130460:	e51b200c 	ldr	r2, [fp, #-12]
  130464:	e583202c 	str	r2, [r3, #44]	; 0x2c
  130468:	ea000014 	b	1304c0 <igmp_lookup_group+0x170>
    } else {
      /* append _after_ first entry */
      LWIP_ASSERT("igmp_lookup_group: all except first group must not be allsystems",
  13046c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130470:	e5932000 	ldr	r2, [r3]
  130474:	e30f3bc8 	movw	r3, #64456	; 0xfbc8
  130478:	e3403014 	movt	r3, #20
  13047c:	e5933000 	ldr	r3, [r3]
  130480:	e1520003 	cmp	r2, r3
  130484:	1a000006 	bne	1304a4 <igmp_lookup_group+0x154>
  130488:	e30907f4 	movw	r0, #38900	; 0x97f4
  13048c:	e3400014 	movt	r0, #20
  130490:	ebff4b1f 	bl	103114 <rt_kprintf>
  130494:	e3001113 	movw	r1, #275	; 0x113
  130498:	e309078c 	movw	r0, #38796	; 0x978c
  13049c:	e3400014 	movt	r0, #20
  1304a0:	ebff6af5 	bl	10b07c <sys_arch_assert>
        (ip4_addr_cmp(addr, &allsystems) == 0));
      group->next = list_head->next;
  1304a4:	e51b3008 	ldr	r3, [fp, #-8]
  1304a8:	e5932000 	ldr	r2, [r3]
  1304ac:	e51b300c 	ldr	r3, [fp, #-12]
  1304b0:	e5832000 	str	r2, [r3]
      list_head->next = group;
  1304b4:	e51b3008 	ldr	r3, [fp, #-8]
  1304b8:	e51b200c 	ldr	r2, [fp, #-12]
  1304bc:	e5832000 	str	r2, [r3]

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_lookup_group: %sallocated a new group with address ", (group?"":"impossible to ")));
  ip4_addr_debug_print(IGMP_DEBUG, addr);
  LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", (void*)ifp));

  return group;
  1304c0:	e51b300c 	ldr	r3, [fp, #-12]
}
  1304c4:	e1a00003 	mov	r0, r3
  1304c8:	e24bd004 	sub	sp, fp, #4
  1304cc:	e8bd8800 	pop	{fp, pc}

001304d0 <igmp_remove_group>:
 * @param group the group to remove from the global igmp_group_list
 * @return ERR_OK if group was removed from the list, an err_t otherwise
 */
static err_t
igmp_remove_group(struct netif* netif, struct igmp_group *group)
{
  1304d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1304d4:	e28db000 	add	fp, sp, #0
  1304d8:	e24dd014 	sub	sp, sp, #20
  1304dc:	e50b0010 	str	r0, [fp, #-16]
  1304e0:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  err_t err = ERR_OK;
  1304e4:	e3a03000 	mov	r3, #0
  1304e8:	e54b3005 	strb	r3, [fp, #-5]
  struct igmp_group *tmp_group;

  /* Skip the first group in the list, it is always the allsystems group added in igmp_start() */
  for (tmp_group = netif_igmp_data(netif); tmp_group != NULL; tmp_group = tmp_group->next) {
  1304ec:	e51b3010 	ldr	r3, [fp, #-16]
  1304f0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  1304f4:	e50b300c 	str	r3, [fp, #-12]
  1304f8:	ea00000c 	b	130530 <igmp_remove_group+0x60>
    if (tmp_group->next == group) {
  1304fc:	e51b300c 	ldr	r3, [fp, #-12]
  130500:	e5933000 	ldr	r3, [r3]
  130504:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  130508:	e1520003 	cmp	r2, r3
  13050c:	1a000004 	bne	130524 <igmp_remove_group+0x54>
      tmp_group->next = group->next;
  130510:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130514:	e5932000 	ldr	r2, [r3]
  130518:	e51b300c 	ldr	r3, [fp, #-12]
  13051c:	e5832000 	str	r2, [r3]
      break;
  130520:	ea000005 	b	13053c <igmp_remove_group+0x6c>
  for (tmp_group = netif_igmp_data(netif); tmp_group != NULL; tmp_group = tmp_group->next) {
  130524:	e51b300c 	ldr	r3, [fp, #-12]
  130528:	e5933000 	ldr	r3, [r3]
  13052c:	e50b300c 	str	r3, [fp, #-12]
  130530:	e51b300c 	ldr	r3, [fp, #-12]
  130534:	e3530000 	cmp	r3, #0
  130538:	1affffef 	bne	1304fc <igmp_remove_group+0x2c>
    }
  }
  /* Group not found in the global igmp_group_list */
  if (tmp_group == NULL) {
  13053c:	e51b300c 	ldr	r3, [fp, #-12]
  130540:	e3530000 	cmp	r3, #0
  130544:	1a000001 	bne	130550 <igmp_remove_group+0x80>
    err = ERR_ARG;
  130548:	e3e0300f 	mvn	r3, #15
  13054c:	e54b3005 	strb	r3, [fp, #-5]
  }

  return err;
  130550:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  130554:	e1a00003 	mov	r0, r3
  130558:	e28bd000 	add	sp, fp, #0
  13055c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  130560:	e12fff1e 	bx	lr

00130564 <igmp_input>:
 * @param inp network interface on which the packet was received
 * @param dest destination ip address of the igmp packet
 */
void
igmp_input(struct pbuf *p, struct netif *inp, const ip4_addr_t *dest)
{
  130564:	e92d4800 	push	{fp, lr}
  130568:	e28db004 	add	fp, sp, #4
  13056c:	e24dd020 	sub	sp, sp, #32
  130570:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  130574:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  130578:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  struct igmp_msg*   igmp;
  struct igmp_group* group;
  struct igmp_group* groupref;

  IGMP_STATS_INC(igmp.recv);
  13057c:	e3063840 	movw	r3, #26688	; 0x6840
  130580:	e3403057 	movt	r3, #87	; 0x57
  130584:	e1d337ba 	ldrh	r3, [r3, #122]	; 0x7a
  130588:	e2833001 	add	r3, r3, #1
  13058c:	e6ff2073 	uxth	r2, r3
  130590:	e3063840 	movw	r3, #26688	; 0x6840
  130594:	e3403057 	movt	r3, #87	; 0x57
  130598:	e1c327ba 	strh	r2, [r3, #122]	; 0x7a

  /* Note that the length CAN be greater than 8 but only 8 are used - All are included in the checksum */
  if (p->len < IGMP_MINLEN) {
  13059c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1305a0:	e1d330ba 	ldrh	r3, [r3, #10]
  1305a4:	e3530007 	cmp	r3, #7
  1305a8:	8a00000a 	bhi	1305d8 <igmp_input+0x74>
    pbuf_free(p);
  1305ac:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1305b0:	ebffaabf 	bl	11b0b4 <pbuf_free>
    IGMP_STATS_INC(igmp.lenerr);
  1305b4:	e3063840 	movw	r3, #26688	; 0x6840
  1305b8:	e3403057 	movt	r3, #87	; 0x57
  1305bc:	e1d338b0 	ldrh	r3, [r3, #128]	; 0x80
  1305c0:	e2833001 	add	r3, r3, #1
  1305c4:	e6ff2073 	uxth	r2, r3
  1305c8:	e3063840 	movw	r3, #26688	; 0x6840
  1305cc:	e3403057 	movt	r3, #87	; 0x57
  1305d0:	e1c328b0 	strh	r2, [r3, #128]	; 0x80
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: length error\n"));
    return;
  1305d4:	ea0000c9 	b	130900 <igmp_input+0x39c>
  LWIP_DEBUGF(IGMP_DEBUG, (" to address "));
  ip4_addr_debug_print(IGMP_DEBUG, &(ip4_current_header()->dest));
  LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", (void*)inp));

  /* Now calculate and check the checksum */
  igmp = (struct igmp_msg *)p->payload;
  1305d8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1305dc:	e5933004 	ldr	r3, [r3, #4]
  1305e0:	e50b3010 	str	r3, [fp, #-16]
  if (inet_chksum(igmp, p->len)) {
  1305e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1305e8:	e1d330ba 	ldrh	r3, [r3, #10]
  1305ec:	e1a01003 	mov	r1, r3
  1305f0:	e51b0010 	ldr	r0, [fp, #-16]
  1305f4:	ebffa186 	bl	118c14 <inet_chksum>
  1305f8:	e1a03000 	mov	r3, r0
  1305fc:	e3530000 	cmp	r3, #0
  130600:	0a00000a 	beq	130630 <igmp_input+0xcc>
    pbuf_free(p);
  130604:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  130608:	ebffaaa9 	bl	11b0b4 <pbuf_free>
    IGMP_STATS_INC(igmp.chkerr);
  13060c:	e3063840 	movw	r3, #26688	; 0x6840
  130610:	e3403057 	movt	r3, #87	; 0x57
  130614:	e1d337be 	ldrh	r3, [r3, #126]	; 0x7e
  130618:	e2833001 	add	r3, r3, #1
  13061c:	e6ff2073 	uxth	r2, r3
  130620:	e3063840 	movw	r3, #26688	; 0x6840
  130624:	e3403057 	movt	r3, #87	; 0x57
  130628:	e1c327be 	strh	r2, [r3, #126]	; 0x7e
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: checksum error\n"));
    return;
  13062c:	ea0000b3 	b	130900 <igmp_input+0x39c>
  }

  /* Packet is ok so find an existing group */
  group = igmp_lookfor_group(inp, dest); /* use the destination IP address of incoming packet */
  130630:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  130634:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  130638:	ebffff28 	bl	1302e0 <igmp_lookfor_group>
  13063c:	e50b0008 	str	r0, [fp, #-8]

  /* If group can be found or create... */
  if (!group) {
  130640:	e51b3008 	ldr	r3, [fp, #-8]
  130644:	e3530000 	cmp	r3, #0
  130648:	1a00000a 	bne	130678 <igmp_input+0x114>
    pbuf_free(p);
  13064c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  130650:	ebffaa97 	bl	11b0b4 <pbuf_free>
    IGMP_STATS_INC(igmp.drop);
  130654:	e3063840 	movw	r3, #26688	; 0x6840
  130658:	e3403057 	movt	r3, #87	; 0x57
  13065c:	e1d337bc 	ldrh	r3, [r3, #124]	; 0x7c
  130660:	e2833001 	add	r3, r3, #1
  130664:	e6ff2073 	uxth	r2, r3
  130668:	e3063840 	movw	r3, #26688	; 0x6840
  13066c:	e3403057 	movt	r3, #87	; 0x57
  130670:	e1c327bc 	strh	r2, [r3, #124]	; 0x7c
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP frame not for us\n"));
    return;
  130674:	ea0000a1 	b	130900 <igmp_input+0x39c>
  }

  /* NOW ACT ON THE INCOMING MESSAGE TYPE... */
  switch (igmp->igmp_msgtype) {
  130678:	e51b3010 	ldr	r3, [fp, #-16]
  13067c:	e5d33000 	ldrb	r3, [r3]
  130680:	e3530011 	cmp	r3, #17
  130684:	0a000002 	beq	130694 <igmp_input+0x130>
  130688:	e3530016 	cmp	r3, #22
  13068c:	0a000078 	beq	130874 <igmp_input+0x310>
  130690:	ea00008d 	b	1308cc <igmp_input+0x368>
  case IGMP_MEMB_QUERY:
    /* IGMP_MEMB_QUERY to the "all systems" address ? */
    if ((ip4_addr_cmp(dest, &allsystems)) && ip4_addr_isany(&igmp->igmp_group_address)) {
  130694:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  130698:	e5932000 	ldr	r2, [r3]
  13069c:	e30f3bc8 	movw	r3, #64456	; 0xfbc8
  1306a0:	e3403014 	movt	r3, #20
  1306a4:	e5933000 	ldr	r3, [r3]
  1306a8:	e1520003 	cmp	r2, r3
  1306ac:	1a000035 	bne	130788 <igmp_input+0x224>
  1306b0:	e51b3010 	ldr	r3, [fp, #-16]
  1306b4:	e2833004 	add	r3, r3, #4
  1306b8:	e3530000 	cmp	r3, #0
  1306bc:	0a000003 	beq	1306d0 <igmp_input+0x16c>
  1306c0:	e51b3010 	ldr	r3, [fp, #-16]
  1306c4:	e5933004 	ldr	r3, [r3, #4]
  1306c8:	e3530000 	cmp	r3, #0
  1306cc:	1a00002d 	bne	130788 <igmp_input+0x224>
      /* THIS IS THE GENERAL QUERY */
      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: General IGMP_MEMB_QUERY on \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));

      if (igmp->igmp_maxresp == 0) {
  1306d0:	e51b3010 	ldr	r3, [fp, #-16]
  1306d4:	e5d33001 	ldrb	r3, [r3, #1]
  1306d8:	e3530000 	cmp	r3, #0
  1306dc:	1a00000b 	bne	130710 <igmp_input+0x1ac>
        IGMP_STATS_INC(igmp.rx_v1);
  1306e0:	e3063840 	movw	r3, #26688	; 0x6840
  1306e4:	e3403057 	movt	r3, #87	; 0x57
  1306e8:	e1d338b6 	ldrh	r3, [r3, #134]	; 0x86
  1306ec:	e2833001 	add	r3, r3, #1
  1306f0:	e6ff2073 	uxth	r2, r3
  1306f4:	e3063840 	movw	r3, #26688	; 0x6840
  1306f8:	e3403057 	movt	r3, #87	; 0x57
  1306fc:	e1c328b6 	strh	r2, [r3, #134]	; 0x86
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: got an all hosts query with time== 0 - this is V1 and not implemented - treat as v2\n"));
        igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;
  130700:	e51b3010 	ldr	r3, [fp, #-16]
  130704:	e3a0200a 	mov	r2, #10
  130708:	e5c32001 	strb	r2, [r3, #1]
  13070c:	ea000007 	b	130730 <igmp_input+0x1cc>
      } else {
        IGMP_STATS_INC(igmp.rx_general);
  130710:	e3063840 	movw	r3, #26688	; 0x6840
  130714:	e3403057 	movt	r3, #87	; 0x57
  130718:	e1d338ba 	ldrh	r3, [r3, #138]	; 0x8a
  13071c:	e2833001 	add	r3, r3, #1
  130720:	e6ff2073 	uxth	r2, r3
  130724:	e3063840 	movw	r3, #26688	; 0x6840
  130728:	e3403057 	movt	r3, #87	; 0x57
  13072c:	e1c328ba 	strh	r2, [r3, #138]	; 0x8a
      }

      groupref = netif_igmp_data(inp);
  130730:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  130734:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  130738:	e50b300c 	str	r3, [fp, #-12]
      
      /* Do not send messages on the all systems group address! */
      /* Skip the first group in the list, it is always the allsystems group added in igmp_start() */
      if(groupref != NULL) {
  13073c:	e51b300c 	ldr	r3, [fp, #-12]
  130740:	e3530000 	cmp	r3, #0
  130744:	0a00000b 	beq	130778 <igmp_input+0x214>
        groupref = groupref->next;
  130748:	e51b300c 	ldr	r3, [fp, #-12]
  13074c:	e5933000 	ldr	r3, [r3]
  130750:	e50b300c 	str	r3, [fp, #-12]
      }

      while (groupref) {
  130754:	ea000007 	b	130778 <igmp_input+0x214>
        igmp_delaying_member(groupref, igmp->igmp_maxresp);
  130758:	e51b3010 	ldr	r3, [fp, #-16]
  13075c:	e5d33001 	ldrb	r3, [r3, #1]
  130760:	e1a01003 	mov	r1, r3
  130764:	e51b000c 	ldr	r0, [fp, #-12]
  130768:	eb000246 	bl	131088 <igmp_delaying_member>
        groupref = groupref->next;
  13076c:	e51b300c 	ldr	r3, [fp, #-12]
  130770:	e5933000 	ldr	r3, [r3]
  130774:	e50b300c 	str	r3, [fp, #-12]
      while (groupref) {
  130778:	e51b300c 	ldr	r3, [fp, #-12]
  13077c:	e3530000 	cmp	r3, #0
  130780:	1afffff4 	bne	130758 <igmp_input+0x1f4>
    if ((ip4_addr_cmp(dest, &allsystems)) && ip4_addr_isany(&igmp->igmp_group_address)) {
  130784:	ea000039 	b	130870 <igmp_input+0x30c>
      }
    } else {
      /* IGMP_MEMB_QUERY to a specific group ? */
      if (!ip4_addr_isany(&igmp->igmp_group_address)) {
  130788:	e51b3010 	ldr	r3, [fp, #-16]
  13078c:	e2833004 	add	r3, r3, #4
  130790:	e3530000 	cmp	r3, #0
  130794:	0a00002c 	beq	13084c <igmp_input+0x2e8>
  130798:	e51b3010 	ldr	r3, [fp, #-16]
  13079c:	e5933004 	ldr	r3, [r3, #4]
  1307a0:	e3530000 	cmp	r3, #0
  1307a4:	0a000028 	beq	13084c <igmp_input+0x2e8>
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP_MEMB_QUERY to a specific group "));
        ip4_addr_debug_print(IGMP_DEBUG, &igmp->igmp_group_address);
        if (ip4_addr_cmp(dest, &allsystems)) {
  1307a8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1307ac:	e5932000 	ldr	r2, [r3]
  1307b0:	e30f3bc8 	movw	r3, #64456	; 0xfbc8
  1307b4:	e3403014 	movt	r3, #20
  1307b8:	e5933000 	ldr	r3, [r3]
  1307bc:	e1520003 	cmp	r2, r3
  1307c0:	1a000007 	bne	1307e4 <igmp_input+0x280>
          ip4_addr_t groupaddr;
          LWIP_DEBUGF(IGMP_DEBUG, (" using \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));
          /* we first need to re-look for the group since we used dest last time */
          ip4_addr_copy(groupaddr, igmp->igmp_group_address);
  1307c4:	e51b3010 	ldr	r3, [fp, #-16]
  1307c8:	e5933004 	ldr	r3, [r3, #4]
  1307cc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
          group = igmp_lookfor_group(inp, &groupaddr);
  1307d0:	e24b3014 	sub	r3, fp, #20
  1307d4:	e1a01003 	mov	r1, r3
  1307d8:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  1307dc:	ebfffebf 	bl	1302e0 <igmp_lookfor_group>
  1307e0:	e50b0008 	str	r0, [fp, #-8]
        } else {
          LWIP_DEBUGF(IGMP_DEBUG, (" with the group address as destination [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));
        }

        if (group != NULL) {
  1307e4:	e51b3008 	ldr	r3, [fp, #-8]
  1307e8:	e3530000 	cmp	r3, #0
  1307ec:	0a00000d 	beq	130828 <igmp_input+0x2c4>
          IGMP_STATS_INC(igmp.rx_group);
  1307f0:	e3063840 	movw	r3, #26688	; 0x6840
  1307f4:	e3403057 	movt	r3, #87	; 0x57
  1307f8:	e1d338b8 	ldrh	r3, [r3, #136]	; 0x88
  1307fc:	e2833001 	add	r3, r3, #1
  130800:	e6ff2073 	uxth	r2, r3
  130804:	e3063840 	movw	r3, #26688	; 0x6840
  130808:	e3403057 	movt	r3, #87	; 0x57
  13080c:	e1c328b8 	strh	r2, [r3, #136]	; 0x88
          igmp_delaying_member(group, igmp->igmp_maxresp);
  130810:	e51b3010 	ldr	r3, [fp, #-16]
  130814:	e5d33001 	ldrb	r3, [r3, #1]
  130818:	e1a01003 	mov	r1, r3
  13081c:	e51b0008 	ldr	r0, [fp, #-8]
  130820:	eb000218 	bl	131088 <igmp_delaying_member>
        if (group != NULL) {
  130824:	ea000011 	b	130870 <igmp_input+0x30c>
        } else {
          IGMP_STATS_INC(igmp.drop);
  130828:	e3063840 	movw	r3, #26688	; 0x6840
  13082c:	e3403057 	movt	r3, #87	; 0x57
  130830:	e1d337bc 	ldrh	r3, [r3, #124]	; 0x7c
  130834:	e2833001 	add	r3, r3, #1
  130838:	e6ff2073 	uxth	r2, r3
  13083c:	e3063840 	movw	r3, #26688	; 0x6840
  130840:	e3403057 	movt	r3, #87	; 0x57
  130844:	e1c327bc 	strh	r2, [r3, #124]	; 0x7c
        if (group != NULL) {
  130848:	ea000008 	b	130870 <igmp_input+0x30c>
        }
      } else {
        IGMP_STATS_INC(igmp.proterr);
  13084c:	e3063840 	movw	r3, #26688	; 0x6840
  130850:	e3403057 	movt	r3, #87	; 0x57
  130854:	e1d338b4 	ldrh	r3, [r3, #132]	; 0x84
  130858:	e2833001 	add	r3, r3, #1
  13085c:	e6ff2073 	uxth	r2, r3
  130860:	e3063840 	movw	r3, #26688	; 0x6840
  130864:	e3403057 	movt	r3, #87	; 0x57
  130868:	e1c328b4 	strh	r2, [r3, #132]	; 0x84
      }
    }
    break;
  13086c:	ea000020 	b	1308f4 <igmp_input+0x390>
  130870:	ea00001f 	b	1308f4 <igmp_input+0x390>
  case IGMP_V2_MEMB_REPORT:
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP_V2_MEMB_REPORT\n"));
    IGMP_STATS_INC(igmp.rx_report);
  130874:	e3063840 	movw	r3, #26688	; 0x6840
  130878:	e3403057 	movt	r3, #87	; 0x57
  13087c:	e1d338bc 	ldrh	r3, [r3, #140]	; 0x8c
  130880:	e2833001 	add	r3, r3, #1
  130884:	e6ff2073 	uxth	r2, r3
  130888:	e3063840 	movw	r3, #26688	; 0x6840
  13088c:	e3403057 	movt	r3, #87	; 0x57
  130890:	e1c328bc 	strh	r2, [r3, #140]	; 0x8c
    if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {
  130894:	e51b3008 	ldr	r3, [fp, #-8]
  130898:	e5d33009 	ldrb	r3, [r3, #9]
  13089c:	e3530001 	cmp	r3, #1
  1308a0:	1a000012 	bne	1308f0 <igmp_input+0x38c>
      /* This is on a specific group we have already looked up */
      group->timer = 0; /* stopped */
  1308a4:	e51b3008 	ldr	r3, [fp, #-8]
  1308a8:	e3a02000 	mov	r2, #0
  1308ac:	e1c320ba 	strh	r2, [r3, #10]
      group->group_state = IGMP_GROUP_IDLE_MEMBER;
  1308b0:	e51b3008 	ldr	r3, [fp, #-8]
  1308b4:	e3a02002 	mov	r2, #2
  1308b8:	e5c32009 	strb	r2, [r3, #9]
      group->last_reporter_flag = 0;
  1308bc:	e51b3008 	ldr	r3, [fp, #-8]
  1308c0:	e3a02000 	mov	r2, #0
  1308c4:	e5c32008 	strb	r2, [r3, #8]
    }
    break;
  1308c8:	ea000008 	b	1308f0 <igmp_input+0x38c>
  default:
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: unexpected msg %d in state %d on group %p on if %p\n",
      igmp->igmp_msgtype, group->group_state, (void*)&group, (void*)inp));
    IGMP_STATS_INC(igmp.proterr);
  1308cc:	e3063840 	movw	r3, #26688	; 0x6840
  1308d0:	e3403057 	movt	r3, #87	; 0x57
  1308d4:	e1d338b4 	ldrh	r3, [r3, #132]	; 0x84
  1308d8:	e2833001 	add	r3, r3, #1
  1308dc:	e6ff2073 	uxth	r2, r3
  1308e0:	e3063840 	movw	r3, #26688	; 0x6840
  1308e4:	e3403057 	movt	r3, #87	; 0x57
  1308e8:	e1c328b4 	strh	r2, [r3, #132]	; 0x84
    break;
  1308ec:	ea000000 	b	1308f4 <igmp_input+0x390>
    break;
  1308f0:	e320f000 	nop	{0}
  }

  pbuf_free(p);
  1308f4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1308f8:	ebffa9ed 	bl	11b0b4 <pbuf_free>
  return;
  1308fc:	e320f000 	nop	{0}
}
  130900:	e24bd004 	sub	sp, fp, #4
  130904:	e8bd8800 	pop	{fp, pc}

00130908 <igmp_joingroup>:
 * @param groupaddr the ip address of the group which to join
 * @return ERR_OK if group was joined on the netif(s), an err_t otherwise
 */
err_t
igmp_joingroup(const ip4_addr_t *ifaddr, const ip4_addr_t *groupaddr)
{
  130908:	e92d4800 	push	{fp, lr}
  13090c:	e28db004 	add	fp, sp, #4
  130910:	e24dd010 	sub	sp, sp, #16
  130914:	e50b0010 	str	r0, [fp, #-16]
  130918:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  err_t err = ERR_VAL; /* no matching interface */
  13091c:	e3e03005 	mvn	r3, #5
  130920:	e54b3005 	strb	r3, [fp, #-5]
  struct netif *netif;

  /* make sure it is multicast address */
  LWIP_ERROR("igmp_joingroup: attempt to join non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
  130924:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130928:	e5933000 	ldr	r3, [r3]
  13092c:	e20330f0 	and	r3, r3, #240	; 0xf0
  130930:	e35300e0 	cmp	r3, #224	; 0xe0
  130934:	0a000008 	beq	13095c <igmp_joingroup+0x54>
  130938:	e3090838 	movw	r0, #38968	; 0x9838
  13093c:	e3400014 	movt	r0, #20
  130940:	ebff49f3 	bl	103114 <rt_kprintf>
  130944:	e30011c7 	movw	r1, #455	; 0x1c7
  130948:	e309078c 	movw	r0, #38796	; 0x978c
  13094c:	e3400014 	movt	r0, #20
  130950:	ebff69c9 	bl	10b07c <sys_arch_assert>
  130954:	e3e03005 	mvn	r3, #5
  130958:	ea000038 	b	130a40 <igmp_joingroup+0x138>
  LWIP_ERROR("igmp_joingroup: attempt to join allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
  13095c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130960:	e5932000 	ldr	r2, [r3]
  130964:	e30f3bc8 	movw	r3, #64456	; 0xfbc8
  130968:	e3403014 	movt	r3, #20
  13096c:	e5933000 	ldr	r3, [r3]
  130970:	e1520003 	cmp	r2, r3
  130974:	1a000008 	bne	13099c <igmp_joingroup+0x94>
  130978:	e3090870 	movw	r0, #39024	; 0x9870
  13097c:	e3400014 	movt	r0, #20
  130980:	ebff49e3 	bl	103114 <rt_kprintf>
  130984:	e3a01f72 	mov	r1, #456	; 0x1c8
  130988:	e309078c 	movw	r0, #38796	; 0x978c
  13098c:	e3400014 	movt	r0, #20
  130990:	ebff69b9 	bl	10b07c <sys_arch_assert>
  130994:	e3e03005 	mvn	r3, #5
  130998:	ea000028 	b	130a40 <igmp_joingroup+0x138>

  /* loop through netif's */
  netif = netif_list;
  13099c:	e3063834 	movw	r3, #26676	; 0x6834
  1309a0:	e3403057 	movt	r3, #87	; 0x57
  1309a4:	e5933000 	ldr	r3, [r3]
  1309a8:	e50b300c 	str	r3, [fp, #-12]
  while (netif != NULL) {
  1309ac:	ea00001f 	b	130a30 <igmp_joingroup+0x128>
    /* Should we join this interface ? */
    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip4_addr_isany(ifaddr) || ip4_addr_cmp(netif_ip4_addr(netif), ifaddr)))) {
  1309b0:	e51b300c 	ldr	r3, [fp, #-12]
  1309b4:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  1309b8:	e2033020 	and	r3, r3, #32
  1309bc:	e3530000 	cmp	r3, #0
  1309c0:	0a000017 	beq	130a24 <igmp_joingroup+0x11c>
  1309c4:	e51b3010 	ldr	r3, [fp, #-16]
  1309c8:	e3530000 	cmp	r3, #0
  1309cc:	0a00000a 	beq	1309fc <igmp_joingroup+0xf4>
  1309d0:	e51b3010 	ldr	r3, [fp, #-16]
  1309d4:	e5933000 	ldr	r3, [r3]
  1309d8:	e3530000 	cmp	r3, #0
  1309dc:	0a000006 	beq	1309fc <igmp_joingroup+0xf4>
  1309e0:	e51b300c 	ldr	r3, [fp, #-12]
  1309e4:	e2833004 	add	r3, r3, #4
  1309e8:	e5932000 	ldr	r2, [r3]
  1309ec:	e51b3010 	ldr	r3, [fp, #-16]
  1309f0:	e5933000 	ldr	r3, [r3]
  1309f4:	e1520003 	cmp	r2, r3
  1309f8:	1a000009 	bne	130a24 <igmp_joingroup+0x11c>
      err = igmp_joingroup_netif(netif, groupaddr);
  1309fc:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  130a00:	e51b000c 	ldr	r0, [fp, #-12]
  130a04:	eb000010 	bl	130a4c <igmp_joingroup_netif>
  130a08:	e1a03000 	mov	r3, r0
  130a0c:	e54b3005 	strb	r3, [fp, #-5]
      if (err != ERR_OK) {
  130a10:	e15b30d5 	ldrsb	r3, [fp, #-5]
  130a14:	e3530000 	cmp	r3, #0
  130a18:	0a000001 	beq	130a24 <igmp_joingroup+0x11c>
        /* Return an error even if some network interfaces are joined */
        /** @todo undo any other netif already joined */
        return err;
  130a1c:	e15b30d5 	ldrsb	r3, [fp, #-5]
  130a20:	ea000006 	b	130a40 <igmp_joingroup+0x138>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  130a24:	e51b300c 	ldr	r3, [fp, #-12]
  130a28:	e5933000 	ldr	r3, [r3]
  130a2c:	e50b300c 	str	r3, [fp, #-12]
  while (netif != NULL) {
  130a30:	e51b300c 	ldr	r3, [fp, #-12]
  130a34:	e3530000 	cmp	r3, #0
  130a38:	1affffdc 	bne	1309b0 <igmp_joingroup+0xa8>
  }

  return err;
  130a3c:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  130a40:	e1a00003 	mov	r0, r3
  130a44:	e24bd004 	sub	sp, fp, #4
  130a48:	e8bd8800 	pop	{fp, pc}

00130a4c <igmp_joingroup_netif>:
 * @param groupaddr the ip address of the group which to join
 * @return ERR_OK if group was joined on the netif, an err_t otherwise
 */
err_t
igmp_joingroup_netif(struct netif *netif, const ip4_addr_t *groupaddr)
{
  130a4c:	e92d4800 	push	{fp, lr}
  130a50:	e28db004 	add	fp, sp, #4
  130a54:	e24dd010 	sub	sp, sp, #16
  130a58:	e50b0010 	str	r0, [fp, #-16]
  130a5c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct igmp_group *group;

  /* make sure it is multicast address */
  LWIP_ERROR("igmp_joingroup_netif: attempt to join non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
  130a60:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130a64:	e5933000 	ldr	r3, [r3]
  130a68:	e20330f0 	and	r3, r3, #240	; 0xf0
  130a6c:	e35300e0 	cmp	r3, #224	; 0xe0
  130a70:	0a000008 	beq	130a98 <igmp_joingroup_netif+0x4c>
  130a74:	e30908a4 	movw	r0, #39076	; 0x98a4
  130a78:	e3400014 	movt	r0, #20
  130a7c:	ebff49a4 	bl	103114 <rt_kprintf>
  130a80:	e30011eb 	movw	r1, #491	; 0x1eb
  130a84:	e309078c 	movw	r0, #38796	; 0x978c
  130a88:	e3400014 	movt	r0, #20
  130a8c:	ebff697a 	bl	10b07c <sys_arch_assert>
  130a90:	e3e03005 	mvn	r3, #5
  130a94:	ea000051 	b	130be0 <igmp_joingroup_netif+0x194>
  LWIP_ERROR("igmp_joingroup_netif: attempt to join allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
  130a98:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130a9c:	e5932000 	ldr	r2, [r3]
  130aa0:	e30f3bc8 	movw	r3, #64456	; 0xfbc8
  130aa4:	e3403014 	movt	r3, #20
  130aa8:	e5933000 	ldr	r3, [r3]
  130aac:	e1520003 	cmp	r2, r3
  130ab0:	1a000008 	bne	130ad8 <igmp_joingroup_netif+0x8c>
  130ab4:	e30908e0 	movw	r0, #39136	; 0x98e0
  130ab8:	e3400014 	movt	r0, #20
  130abc:	ebff4994 	bl	103114 <rt_kprintf>
  130ac0:	e3a01f7b 	mov	r1, #492	; 0x1ec
  130ac4:	e309078c 	movw	r0, #38796	; 0x978c
  130ac8:	e3400014 	movt	r0, #20
  130acc:	ebff696a 	bl	10b07c <sys_arch_assert>
  130ad0:	e3e03005 	mvn	r3, #5
  130ad4:	ea000041 	b	130be0 <igmp_joingroup_netif+0x194>

  /* make sure it is an igmp-enabled netif */
  LWIP_ERROR("igmp_joingroup_netif: attempt to join on non-IGMP netif", netif->flags & NETIF_FLAG_IGMP, return ERR_VAL;);
  130ad8:	e51b3010 	ldr	r3, [fp, #-16]
  130adc:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  130ae0:	e2033020 	and	r3, r3, #32
  130ae4:	e3530000 	cmp	r3, #0
  130ae8:	1a000008 	bne	130b10 <igmp_joingroup_netif+0xc4>
  130aec:	e309091c 	movw	r0, #39196	; 0x991c
  130af0:	e3400014 	movt	r0, #20
  130af4:	ebff4986 	bl	103114 <rt_kprintf>
  130af8:	e30011ef 	movw	r1, #495	; 0x1ef
  130afc:	e309078c 	movw	r0, #38796	; 0x978c
  130b00:	e3400014 	movt	r0, #20
  130b04:	ebff695c 	bl	10b07c <sys_arch_assert>
  130b08:	e3e03005 	mvn	r3, #5
  130b0c:	ea000033 	b	130be0 <igmp_joingroup_netif+0x194>

  /* find group or create a new one if not found */
  group = igmp_lookup_group(netif, groupaddr);
  130b10:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  130b14:	e51b0010 	ldr	r0, [fp, #-16]
  130b18:	ebfffe0c 	bl	130350 <igmp_lookup_group>
  130b1c:	e50b0008 	str	r0, [fp, #-8]

  if (group != NULL) {
  130b20:	e51b3008 	ldr	r3, [fp, #-8]
  130b24:	e3530000 	cmp	r3, #0
  130b28:	0a00002b 	beq	130bdc <igmp_joingroup_netif+0x190>
    /* This should create a new group, check the state to make sure */
    if (group->group_state != IGMP_GROUP_NON_MEMBER) {
  130b2c:	e51b3008 	ldr	r3, [fp, #-8]
  130b30:	e5d33009 	ldrb	r3, [r3, #9]
  130b34:	e3530000 	cmp	r3, #0
  130b38:	1a00001f 	bne	130bbc <igmp_joingroup_netif+0x170>
      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup_netif: join to new group: "));
      ip4_addr_debug_print(IGMP_DEBUG, groupaddr);
      LWIP_DEBUGF(IGMP_DEBUG, ("\n"));

      /* If first use of the group, allow the group at the MAC level */
      if ((group->use==0) && (netif->igmp_mac_filter != NULL)) {
  130b3c:	e51b3008 	ldr	r3, [fp, #-8]
  130b40:	e5d3300c 	ldrb	r3, [r3, #12]
  130b44:	e3530000 	cmp	r3, #0
  130b48:	1a000009 	bne	130b74 <igmp_joingroup_netif+0x128>
  130b4c:	e51b3010 	ldr	r3, [fp, #-16]
  130b50:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  130b54:	e3530000 	cmp	r3, #0
  130b58:	0a000005 	beq	130b74 <igmp_joingroup_netif+0x128>
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup_netif: igmp_mac_filter(ADD "));
        ip4_addr_debug_print(IGMP_DEBUG, groupaddr);
        LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", (void*)netif));
        netif->igmp_mac_filter(netif, groupaddr, NETIF_ADD_MAC_FILTER);
  130b5c:	e51b3010 	ldr	r3, [fp, #-16]
  130b60:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  130b64:	e3a02001 	mov	r2, #1
  130b68:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  130b6c:	e51b0010 	ldr	r0, [fp, #-16]
  130b70:	e12fff33 	blx	r3
      }

      IGMP_STATS_INC(igmp.tx_join);
  130b74:	e3063840 	movw	r3, #26688	; 0x6840
  130b78:	e3403057 	movt	r3, #87	; 0x57
  130b7c:	e1d338be 	ldrh	r3, [r3, #142]	; 0x8e
  130b80:	e2833001 	add	r3, r3, #1
  130b84:	e6ff2073 	uxth	r2, r3
  130b88:	e3063840 	movw	r3, #26688	; 0x6840
  130b8c:	e3403057 	movt	r3, #87	; 0x57
  130b90:	e1c328be 	strh	r2, [r3, #142]	; 0x8e
      igmp_send(netif, group, IGMP_V2_MEMB_REPORT);
  130b94:	e3a02016 	mov	r2, #22
  130b98:	e51b1008 	ldr	r1, [fp, #-8]
  130b9c:	e51b0010 	ldr	r0, [fp, #-16]
  130ba0:	eb000180 	bl	1311a8 <igmp_send>

      igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
  130ba4:	e3a01005 	mov	r1, #5
  130ba8:	e51b0008 	ldr	r0, [fp, #-8]
  130bac:	eb000116 	bl	13100c <igmp_start_timer>

      /* Need to work out where this timer comes from */
      group->group_state = IGMP_GROUP_DELAYING_MEMBER;
  130bb0:	e51b3008 	ldr	r3, [fp, #-8]
  130bb4:	e3a02001 	mov	r2, #1
  130bb8:	e5c32009 	strb	r2, [r3, #9]
    }
    /* Increment group use */
    group->use++;
  130bbc:	e51b3008 	ldr	r3, [fp, #-8]
  130bc0:	e5d3300c 	ldrb	r3, [r3, #12]
  130bc4:	e2833001 	add	r3, r3, #1
  130bc8:	e6ef2073 	uxtb	r2, r3
  130bcc:	e51b3008 	ldr	r3, [fp, #-8]
  130bd0:	e5c3200c 	strb	r2, [r3, #12]
    /* Join on this interface */
    return ERR_OK;
  130bd4:	e3a03000 	mov	r3, #0
  130bd8:	ea000000 	b	130be0 <igmp_joingroup_netif+0x194>
  } else {
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup_netif: Not enough memory to join to group\n"));
    return ERR_MEM;
  130bdc:	e3e03000 	mvn	r3, #0
  }
}
  130be0:	e1a00003 	mov	r0, r3
  130be4:	e24bd004 	sub	sp, fp, #4
  130be8:	e8bd8800 	pop	{fp, pc}

00130bec <igmp_leavegroup>:
 * @param groupaddr the ip address of the group which to leave
 * @return ERR_OK if group was left on the netif(s), an err_t otherwise
 */
err_t
igmp_leavegroup(const ip4_addr_t *ifaddr, const ip4_addr_t *groupaddr)
{
  130bec:	e92d4800 	push	{fp, lr}
  130bf0:	e28db004 	add	fp, sp, #4
  130bf4:	e24dd018 	sub	sp, sp, #24
  130bf8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  130bfc:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  err_t err = ERR_VAL; /* no matching interface */
  130c00:	e3e03005 	mvn	r3, #5
  130c04:	e54b3005 	strb	r3, [fp, #-5]
  struct netif *netif;

  /* make sure it is multicast address */
  LWIP_ERROR("igmp_leavegroup: attempt to leave non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
  130c08:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  130c0c:	e5933000 	ldr	r3, [r3]
  130c10:	e20330f0 	and	r3, r3, #240	; 0xf0
  130c14:	e35300e0 	cmp	r3, #224	; 0xe0
  130c18:	0a000008 	beq	130c40 <igmp_leavegroup+0x54>
  130c1c:	e3090954 	movw	r0, #39252	; 0x9954
  130c20:	e3400014 	movt	r0, #20
  130c24:	ebff493a 	bl	103114 <rt_kprintf>
  130c28:	e3001227 	movw	r1, #551	; 0x227
  130c2c:	e309078c 	movw	r0, #38796	; 0x978c
  130c30:	e3400014 	movt	r0, #20
  130c34:	ebff6910 	bl	10b07c <sys_arch_assert>
  130c38:	e3e03005 	mvn	r3, #5
  130c3c:	ea000038 	b	130d24 <igmp_leavegroup+0x138>
  LWIP_ERROR("igmp_leavegroup: attempt to leave allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
  130c40:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  130c44:	e5932000 	ldr	r2, [r3]
  130c48:	e30f3bc8 	movw	r3, #64456	; 0xfbc8
  130c4c:	e3403014 	movt	r3, #20
  130c50:	e5933000 	ldr	r3, [r3]
  130c54:	e1520003 	cmp	r2, r3
  130c58:	1a000008 	bne	130c80 <igmp_leavegroup+0x94>
  130c5c:	e309098c 	movw	r0, #39308	; 0x998c
  130c60:	e3400014 	movt	r0, #20
  130c64:	ebff492a 	bl	103114 <rt_kprintf>
  130c68:	e3a01f8a 	mov	r1, #552	; 0x228
  130c6c:	e309078c 	movw	r0, #38796	; 0x978c
  130c70:	e3400014 	movt	r0, #20
  130c74:	ebff6900 	bl	10b07c <sys_arch_assert>
  130c78:	e3e03005 	mvn	r3, #5
  130c7c:	ea000028 	b	130d24 <igmp_leavegroup+0x138>

  /* loop through netif's */
  netif = netif_list;
  130c80:	e3063834 	movw	r3, #26676	; 0x6834
  130c84:	e3403057 	movt	r3, #87	; 0x57
  130c88:	e5933000 	ldr	r3, [r3]
  130c8c:	e50b300c 	str	r3, [fp, #-12]
  while (netif != NULL) {
  130c90:	ea00001f 	b	130d14 <igmp_leavegroup+0x128>
    /* Should we leave this interface ? */
    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip4_addr_isany(ifaddr) || ip4_addr_cmp(netif_ip4_addr(netif), ifaddr)))) {
  130c94:	e51b300c 	ldr	r3, [fp, #-12]
  130c98:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  130c9c:	e2033020 	and	r3, r3, #32
  130ca0:	e3530000 	cmp	r3, #0
  130ca4:	0a000017 	beq	130d08 <igmp_leavegroup+0x11c>
  130ca8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  130cac:	e3530000 	cmp	r3, #0
  130cb0:	0a00000a 	beq	130ce0 <igmp_leavegroup+0xf4>
  130cb4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  130cb8:	e5933000 	ldr	r3, [r3]
  130cbc:	e3530000 	cmp	r3, #0
  130cc0:	0a000006 	beq	130ce0 <igmp_leavegroup+0xf4>
  130cc4:	e51b300c 	ldr	r3, [fp, #-12]
  130cc8:	e2833004 	add	r3, r3, #4
  130ccc:	e5932000 	ldr	r2, [r3]
  130cd0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  130cd4:	e5933000 	ldr	r3, [r3]
  130cd8:	e1520003 	cmp	r2, r3
  130cdc:	1a000009 	bne	130d08 <igmp_leavegroup+0x11c>
      err_t res = igmp_leavegroup_netif(netif, groupaddr);
  130ce0:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  130ce4:	e51b000c 	ldr	r0, [fp, #-12]
  130ce8:	eb000010 	bl	130d30 <igmp_leavegroup_netif>
  130cec:	e1a03000 	mov	r3, r0
  130cf0:	e54b300d 	strb	r3, [fp, #-13]
      if (err != ERR_OK) {
  130cf4:	e15b30d5 	ldrsb	r3, [fp, #-5]
  130cf8:	e3530000 	cmp	r3, #0
  130cfc:	0a000001 	beq	130d08 <igmp_leavegroup+0x11c>
        /* Store this result if we have not yet gotten a success */
        err = res;
  130d00:	e55b300d 	ldrb	r3, [fp, #-13]
  130d04:	e54b3005 	strb	r3, [fp, #-5]
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  130d08:	e51b300c 	ldr	r3, [fp, #-12]
  130d0c:	e5933000 	ldr	r3, [r3]
  130d10:	e50b300c 	str	r3, [fp, #-12]
  while (netif != NULL) {
  130d14:	e51b300c 	ldr	r3, [fp, #-12]
  130d18:	e3530000 	cmp	r3, #0
  130d1c:	1affffdc 	bne	130c94 <igmp_leavegroup+0xa8>
  }

  return err;
  130d20:	e15b30d5 	ldrsb	r3, [fp, #-5]
}
  130d24:	e1a00003 	mov	r0, r3
  130d28:	e24bd004 	sub	sp, fp, #4
  130d2c:	e8bd8800 	pop	{fp, pc}

00130d30 <igmp_leavegroup_netif>:
 * @param groupaddr the ip address of the group which to leave
 * @return ERR_OK if group was left on the netif, an err_t otherwise
 */
err_t
igmp_leavegroup_netif(struct netif *netif, const ip4_addr_t *groupaddr)
{
  130d30:	e92d4800 	push	{fp, lr}
  130d34:	e28db004 	add	fp, sp, #4
  130d38:	e24dd010 	sub	sp, sp, #16
  130d3c:	e50b0010 	str	r0, [fp, #-16]
  130d40:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  struct igmp_group *group;

  /* make sure it is multicast address */
  LWIP_ERROR("igmp_leavegroup_netif: attempt to leave non-multicast address", ip4_addr_ismulticast(groupaddr), return ERR_VAL;);
  130d44:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130d48:	e5933000 	ldr	r3, [r3]
  130d4c:	e20330f0 	and	r3, r3, #240	; 0xf0
  130d50:	e35300e0 	cmp	r3, #224	; 0xe0
  130d54:	0a000008 	beq	130d7c <igmp_leavegroup_netif+0x4c>
  130d58:	e30909c4 	movw	r0, #39364	; 0x99c4
  130d5c:	e3400014 	movt	r0, #20
  130d60:	ebff48eb 	bl	103114 <rt_kprintf>
  130d64:	e300124a 	movw	r1, #586	; 0x24a
  130d68:	e309078c 	movw	r0, #38796	; 0x978c
  130d6c:	e3400014 	movt	r0, #20
  130d70:	ebff68c1 	bl	10b07c <sys_arch_assert>
  130d74:	e3e03005 	mvn	r3, #5
  130d78:	ea000052 	b	130ec8 <igmp_leavegroup_netif+0x198>
  LWIP_ERROR("igmp_leavegroup_netif: attempt to leave allsystems address", (!ip4_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
  130d7c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  130d80:	e5932000 	ldr	r2, [r3]
  130d84:	e30f3bc8 	movw	r3, #64456	; 0xfbc8
  130d88:	e3403014 	movt	r3, #20
  130d8c:	e5933000 	ldr	r3, [r3]
  130d90:	e1520003 	cmp	r2, r3
  130d94:	1a000008 	bne	130dbc <igmp_leavegroup_netif+0x8c>
  130d98:	e3090a04 	movw	r0, #39428	; 0x9a04
  130d9c:	e3400014 	movt	r0, #20
  130da0:	ebff48db 	bl	103114 <rt_kprintf>
  130da4:	e300124b 	movw	r1, #587	; 0x24b
  130da8:	e309078c 	movw	r0, #38796	; 0x978c
  130dac:	e3400014 	movt	r0, #20
  130db0:	ebff68b1 	bl	10b07c <sys_arch_assert>
  130db4:	e3e03005 	mvn	r3, #5
  130db8:	ea000042 	b	130ec8 <igmp_leavegroup_netif+0x198>

  /* make sure it is an igmp-enabled netif */
  LWIP_ERROR("igmp_leavegroup_netif: attempt to leave on non-IGMP netif", netif->flags & NETIF_FLAG_IGMP, return ERR_VAL;);
  130dbc:	e51b3010 	ldr	r3, [fp, #-16]
  130dc0:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  130dc4:	e2033020 	and	r3, r3, #32
  130dc8:	e3530000 	cmp	r3, #0
  130dcc:	1a000008 	bne	130df4 <igmp_leavegroup_netif+0xc4>
  130dd0:	e3090a40 	movw	r0, #39488	; 0x9a40
  130dd4:	e3400014 	movt	r0, #20
  130dd8:	ebff48cd 	bl	103114 <rt_kprintf>
  130ddc:	e300124e 	movw	r1, #590	; 0x24e
  130de0:	e309078c 	movw	r0, #38796	; 0x978c
  130de4:	e3400014 	movt	r0, #20
  130de8:	ebff68a3 	bl	10b07c <sys_arch_assert>
  130dec:	e3e03005 	mvn	r3, #5
  130df0:	ea000034 	b	130ec8 <igmp_leavegroup_netif+0x198>

  /* find group */
  group = igmp_lookfor_group(netif, groupaddr);
  130df4:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  130df8:	e51b0010 	ldr	r0, [fp, #-16]
  130dfc:	ebfffd37 	bl	1302e0 <igmp_lookfor_group>
  130e00:	e50b0008 	str	r0, [fp, #-8]

  if (group != NULL) {
  130e04:	e51b3008 	ldr	r3, [fp, #-8]
  130e08:	e3530000 	cmp	r3, #0
  130e0c:	0a00002c 	beq	130ec4 <igmp_leavegroup_netif+0x194>
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup_netif: Leaving group: "));
    ip4_addr_debug_print(IGMP_DEBUG, groupaddr);
    LWIP_DEBUGF(IGMP_DEBUG, ("\n"));

    /* If there is no other use of the group */
    if (group->use <= 1) {
  130e10:	e51b3008 	ldr	r3, [fp, #-8]
  130e14:	e5d3300c 	ldrb	r3, [r3, #12]
  130e18:	e3530001 	cmp	r3, #1
  130e1c:	8a000020 	bhi	130ea4 <igmp_leavegroup_netif+0x174>
      /* Remove the group from the list */
      igmp_remove_group(netif, group);
  130e20:	e51b1008 	ldr	r1, [fp, #-8]
  130e24:	e51b0010 	ldr	r0, [fp, #-16]
  130e28:	ebfffda8 	bl	1304d0 <igmp_remove_group>

      /* If we are the last reporter for this group */
      if (group->last_reporter_flag) {
  130e2c:	e51b3008 	ldr	r3, [fp, #-8]
  130e30:	e5d33008 	ldrb	r3, [r3, #8]
  130e34:	e3530000 	cmp	r3, #0
  130e38:	0a00000b 	beq	130e6c <igmp_leavegroup_netif+0x13c>
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup_netif: sending leaving group\n"));
        IGMP_STATS_INC(igmp.tx_leave);
  130e3c:	e3063840 	movw	r3, #26688	; 0x6840
  130e40:	e3403057 	movt	r3, #87	; 0x57
  130e44:	e1d339b0 	ldrh	r3, [r3, #144]	; 0x90
  130e48:	e2833001 	add	r3, r3, #1
  130e4c:	e6ff2073 	uxth	r2, r3
  130e50:	e3063840 	movw	r3, #26688	; 0x6840
  130e54:	e3403057 	movt	r3, #87	; 0x57
  130e58:	e1c329b0 	strh	r2, [r3, #144]	; 0x90
        igmp_send(netif, group, IGMP_LEAVE_GROUP);
  130e5c:	e3a02017 	mov	r2, #23
  130e60:	e51b1008 	ldr	r1, [fp, #-8]
  130e64:	e51b0010 	ldr	r0, [fp, #-16]
  130e68:	eb0000ce 	bl	1311a8 <igmp_send>
      }

      /* Disable the group at the MAC level */
      if (netif->igmp_mac_filter != NULL) {
  130e6c:	e51b3010 	ldr	r3, [fp, #-16]
  130e70:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  130e74:	e3530000 	cmp	r3, #0
  130e78:	0a000005 	beq	130e94 <igmp_leavegroup_netif+0x164>
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup_netif: igmp_mac_filter(DEL "));
        ip4_addr_debug_print(IGMP_DEBUG, groupaddr);
        LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", (void*)netif));
        netif->igmp_mac_filter(netif, groupaddr, NETIF_DEL_MAC_FILTER);
  130e7c:	e51b3010 	ldr	r3, [fp, #-16]
  130e80:	e593307c 	ldr	r3, [r3, #124]	; 0x7c
  130e84:	e3a02000 	mov	r2, #0
  130e88:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  130e8c:	e51b0010 	ldr	r0, [fp, #-16]
  130e90:	e12fff33 	blx	r3
      }

      /* Free group struct */
      memp_free(MEMP_IGMP_GROUP, group);
  130e94:	e51b1008 	ldr	r1, [fp, #-8]
  130e98:	e3a0000c 	mov	r0, #12
  130e9c:	ebffa176 	bl	11947c <memp_free>
  130ea0:	ea000005 	b	130ebc <igmp_leavegroup_netif+0x18c>
    } else {
      /* Decrement group use */
      group->use--;
  130ea4:	e51b3008 	ldr	r3, [fp, #-8]
  130ea8:	e5d3300c 	ldrb	r3, [r3, #12]
  130eac:	e2433001 	sub	r3, r3, #1
  130eb0:	e6ef2073 	uxtb	r2, r3
  130eb4:	e51b3008 	ldr	r3, [fp, #-8]
  130eb8:	e5c3200c 	strb	r2, [r3, #12]
    }
    return ERR_OK;
  130ebc:	e3a03000 	mov	r3, #0
  130ec0:	ea000000 	b	130ec8 <igmp_leavegroup_netif+0x198>
  } else {
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup_netif: not member of group\n"));
    return ERR_VAL;
  130ec4:	e3e03005 	mvn	r3, #5
  }
}
  130ec8:	e1a00003 	mov	r0, r3
  130ecc:	e24bd004 	sub	sp, fp, #4
  130ed0:	e8bd8800 	pop	{fp, pc}

00130ed4 <igmp_tmr>:
 * The igmp timer function (both for NO_SYS=1 and =0)
 * Should be called every IGMP_TMR_INTERVAL milliseconds (100 ms is default).
 */
void
igmp_tmr(void)
{
  130ed4:	e92d4800 	push	{fp, lr}
  130ed8:	e28db004 	add	fp, sp, #4
  130edc:	e24dd008 	sub	sp, sp, #8
  struct netif *netif = netif_list;
  130ee0:	e3063834 	movw	r3, #26676	; 0x6834
  130ee4:	e3403057 	movt	r3, #87	; 0x57
  130ee8:	e5933000 	ldr	r3, [r3]
  130eec:	e50b3008 	str	r3, [fp, #-8]

  while (netif != NULL) {
  130ef0:	ea00001d 	b	130f6c <igmp_tmr+0x98>
    struct igmp_group *group = netif_igmp_data(netif);
  130ef4:	e51b3008 	ldr	r3, [fp, #-8]
  130ef8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  130efc:	e50b300c 	str	r3, [fp, #-12]

    while (group != NULL) {
  130f00:	ea000013 	b	130f54 <igmp_tmr+0x80>
      if (group->timer > 0) {
  130f04:	e51b300c 	ldr	r3, [fp, #-12]
  130f08:	e1d330ba 	ldrh	r3, [r3, #10]
  130f0c:	e3530000 	cmp	r3, #0
  130f10:	0a00000c 	beq	130f48 <igmp_tmr+0x74>
        group->timer--;
  130f14:	e51b300c 	ldr	r3, [fp, #-12]
  130f18:	e1d330ba 	ldrh	r3, [r3, #10]
  130f1c:	e2433001 	sub	r3, r3, #1
  130f20:	e6ff2073 	uxth	r2, r3
  130f24:	e51b300c 	ldr	r3, [fp, #-12]
  130f28:	e1c320ba 	strh	r2, [r3, #10]
        if (group->timer == 0) {
  130f2c:	e51b300c 	ldr	r3, [fp, #-12]
  130f30:	e1d330ba 	ldrh	r3, [r3, #10]
  130f34:	e3530000 	cmp	r3, #0
  130f38:	1a000002 	bne	130f48 <igmp_tmr+0x74>
          igmp_timeout(netif, group);
  130f3c:	e51b100c 	ldr	r1, [fp, #-12]
  130f40:	e51b0008 	ldr	r0, [fp, #-8]
  130f44:	eb00000e 	bl	130f84 <igmp_timeout>
        }
      }
      group = group->next;
  130f48:	e51b300c 	ldr	r3, [fp, #-12]
  130f4c:	e5933000 	ldr	r3, [r3]
  130f50:	e50b300c 	str	r3, [fp, #-12]
    while (group != NULL) {
  130f54:	e51b300c 	ldr	r3, [fp, #-12]
  130f58:	e3530000 	cmp	r3, #0
  130f5c:	1affffe8 	bne	130f04 <igmp_tmr+0x30>
    }
    netif = netif->next;
  130f60:	e51b3008 	ldr	r3, [fp, #-8]
  130f64:	e5933000 	ldr	r3, [r3]
  130f68:	e50b3008 	str	r3, [fp, #-8]
  while (netif != NULL) {
  130f6c:	e51b3008 	ldr	r3, [fp, #-8]
  130f70:	e3530000 	cmp	r3, #0
  130f74:	1affffde 	bne	130ef4 <igmp_tmr+0x20>
  }
}
  130f78:	e320f000 	nop	{0}
  130f7c:	e24bd004 	sub	sp, fp, #4
  130f80:	e8bd8800 	pop	{fp, pc}

00130f84 <igmp_timeout>:
 *
 * @param group an igmp_group for which a timeout is reached
 */
static void
igmp_timeout(struct netif *netif, struct igmp_group *group)
{
  130f84:	e92d4800 	push	{fp, lr}
  130f88:	e28db004 	add	fp, sp, #4
  130f8c:	e24dd008 	sub	sp, sp, #8
  130f90:	e50b0008 	str	r0, [fp, #-8]
  130f94:	e50b100c 	str	r1, [fp, #-12]
  /* If the state is IGMP_GROUP_DELAYING_MEMBER then we send a report for this group
     (unless it is the allsystems group) */
  if ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
  130f98:	e51b300c 	ldr	r3, [fp, #-12]
  130f9c:	e5d33009 	ldrb	r3, [r3, #9]
  130fa0:	e3530001 	cmp	r3, #1
  130fa4:	1a000015 	bne	131000 <igmp_timeout+0x7c>
      (!(ip4_addr_cmp(&(group->group_address), &allsystems)))) {
  130fa8:	e51b300c 	ldr	r3, [fp, #-12]
  130fac:	e5932004 	ldr	r2, [r3, #4]
  130fb0:	e30f3bc8 	movw	r3, #64456	; 0xfbc8
  130fb4:	e3403014 	movt	r3, #20
  130fb8:	e5933000 	ldr	r3, [r3]
  if ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
  130fbc:	e1520003 	cmp	r2, r3
  130fc0:	0a00000e 	beq	131000 <igmp_timeout+0x7c>
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_timeout: report membership for group with address "));
    ip4_addr_debug_print(IGMP_DEBUG, &(group->group_address));
    LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", (void*)netif));

    group->group_state = IGMP_GROUP_IDLE_MEMBER;
  130fc4:	e51b300c 	ldr	r3, [fp, #-12]
  130fc8:	e3a02002 	mov	r2, #2
  130fcc:	e5c32009 	strb	r2, [r3, #9]
    
    IGMP_STATS_INC(igmp.tx_report);
  130fd0:	e3063840 	movw	r3, #26688	; 0x6840
  130fd4:	e3403057 	movt	r3, #87	; 0x57
  130fd8:	e1d339b2 	ldrh	r3, [r3, #146]	; 0x92
  130fdc:	e2833001 	add	r3, r3, #1
  130fe0:	e6ff2073 	uxth	r2, r3
  130fe4:	e3063840 	movw	r3, #26688	; 0x6840
  130fe8:	e3403057 	movt	r3, #87	; 0x57
  130fec:	e1c329b2 	strh	r2, [r3, #146]	; 0x92
    igmp_send(netif, group, IGMP_V2_MEMB_REPORT);
  130ff0:	e3a02016 	mov	r2, #22
  130ff4:	e51b100c 	ldr	r1, [fp, #-12]
  130ff8:	e51b0008 	ldr	r0, [fp, #-8]
  130ffc:	eb000069 	bl	1311a8 <igmp_send>
  }
}
  131000:	e320f000 	nop	{0}
  131004:	e24bd004 	sub	sp, fp, #4
  131008:	e8bd8800 	pop	{fp, pc}

0013100c <igmp_start_timer>:
 * @param max_time the time in multiples of IGMP_TMR_INTERVAL (decrease with
 *        every call to igmp_tmr())
 */
static void
igmp_start_timer(struct igmp_group *group, u8_t max_time)
{
  13100c:	e92d4800 	push	{fp, lr}
  131010:	e28db004 	add	fp, sp, #4
  131014:	e24dd008 	sub	sp, sp, #8
  131018:	e50b0008 	str	r0, [fp, #-8]
  13101c:	e1a03001 	mov	r3, r1
  131020:	e54b3009 	strb	r3, [fp, #-9]
#ifdef LWIP_RAND
  group->timer = max_time > 2 ? (LWIP_RAND() % max_time) : 1;
  131024:	e55b3009 	ldrb	r3, [fp, #-9]
  131028:	e3530002 	cmp	r3, #2
  13102c:	9a000008 	bls	131054 <igmp_start_timer+0x48>
  131030:	eb0034d5 	bl	13e38c <rand>
  131034:	e1a02000 	mov	r2, r0
  131038:	e55b3009 	ldrb	r3, [fp, #-9]
  13103c:	e1a01003 	mov	r1, r3
  131040:	e1a00002 	mov	r0, r2
  131044:	eb001f95 	bl	138ea0 <__aeabi_idivmod>
  131048:	e1a03001 	mov	r3, r1
  13104c:	e6ff3073 	uxth	r3, r3
  131050:	ea000000 	b	131058 <igmp_start_timer+0x4c>
  131054:	e3a03001 	mov	r3, #1
  131058:	e51b2008 	ldr	r2, [fp, #-8]
  13105c:	e1c230ba 	strh	r3, [r2, #10]
#else /* LWIP_RAND */
  /* ATTENTION: use this only if absolutely necessary! */
  group->timer = max_time / 2;
#endif /* LWIP_RAND */

  if (group->timer == 0) {
  131060:	e51b3008 	ldr	r3, [fp, #-8]
  131064:	e1d330ba 	ldrh	r3, [r3, #10]
  131068:	e3530000 	cmp	r3, #0
  13106c:	1a000002 	bne	13107c <igmp_start_timer+0x70>
    group->timer = 1;
  131070:	e51b3008 	ldr	r3, [fp, #-8]
  131074:	e3a02001 	mov	r2, #1
  131078:	e1c320ba 	strh	r2, [r3, #10]
  }
}
  13107c:	e320f000 	nop	{0}
  131080:	e24bd004 	sub	sp, fp, #4
  131084:	e8bd8800 	pop	{fp, pc}

00131088 <igmp_delaying_member>:
 * @param group the igmp_group for which "delaying" membership report
 * @param maxresp query delay
 */
static void
igmp_delaying_member(struct igmp_group *group, u8_t maxresp)
{
  131088:	e92d4800 	push	{fp, lr}
  13108c:	e28db004 	add	fp, sp, #4
  131090:	e24dd008 	sub	sp, sp, #8
  131094:	e50b0008 	str	r0, [fp, #-8]
  131098:	e1a03001 	mov	r3, r1
  13109c:	e54b3009 	strb	r3, [fp, #-9]
  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
  1310a0:	e51b3008 	ldr	r3, [fp, #-8]
  1310a4:	e5d33009 	ldrb	r3, [r3, #9]
  1310a8:	e3530002 	cmp	r3, #2
  1310ac:	0a00000d 	beq	1310e8 <igmp_delaying_member+0x60>
     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
  1310b0:	e51b3008 	ldr	r3, [fp, #-8]
  1310b4:	e5d33009 	ldrb	r3, [r3, #9]
  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
  1310b8:	e3530001 	cmp	r3, #1
  1310bc:	1a000010 	bne	131104 <igmp_delaying_member+0x7c>
      ((group->timer == 0) || (maxresp < group->timer)))) {
  1310c0:	e51b3008 	ldr	r3, [fp, #-8]
  1310c4:	e1d330ba 	ldrh	r3, [r3, #10]
     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
  1310c8:	e3530000 	cmp	r3, #0
  1310cc:	0a000005 	beq	1310e8 <igmp_delaying_member+0x60>
      ((group->timer == 0) || (maxresp < group->timer)))) {
  1310d0:	e55b3009 	ldrb	r3, [fp, #-9]
  1310d4:	e6ff2073 	uxth	r2, r3
  1310d8:	e51b3008 	ldr	r3, [fp, #-8]
  1310dc:	e1d330ba 	ldrh	r3, [r3, #10]
  1310e0:	e1520003 	cmp	r2, r3
  1310e4:	2a000006 	bcs	131104 <igmp_delaying_member+0x7c>
    igmp_start_timer(group, maxresp);
  1310e8:	e55b3009 	ldrb	r3, [fp, #-9]
  1310ec:	e1a01003 	mov	r1, r3
  1310f0:	e51b0008 	ldr	r0, [fp, #-8]
  1310f4:	ebffffc4 	bl	13100c <igmp_start_timer>
    group->group_state = IGMP_GROUP_DELAYING_MEMBER;
  1310f8:	e51b3008 	ldr	r3, [fp, #-8]
  1310fc:	e3a02001 	mov	r2, #1
  131100:	e5c32009 	strb	r2, [r3, #9]
  }
}
  131104:	e320f000 	nop	{0}
  131108:	e24bd004 	sub	sp, fp, #4
  13110c:	e8bd8800 	pop	{fp, pc}

00131110 <igmp_ip_output_if>:
 *         ERR_BUF if p doesn't have enough space for IP/LINK headers
 *         returns errors returned by netif->output
 */
static err_t
igmp_ip_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest, struct netif *netif)
{
  131110:	e92d4800 	push	{fp, lr}
  131114:	e28db004 	add	fp, sp, #4
  131118:	e24dd030 	sub	sp, sp, #48	; 0x30
  13111c:	e50b0010 	str	r0, [fp, #-16]
  131120:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  131124:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  131128:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  /* This is the "router alert" option */
  u16_t ra[2];
  ra[0] = PP_HTONS(ROUTER_ALERT);
  13112c:	e3003494 	movw	r3, #1172	; 0x494
  131130:	e14b30b8 	strh	r3, [fp, #-8]
  ra[1] = 0x0000; /* Router shall examine packet */
  131134:	e3a03000 	mov	r3, #0
  131138:	e14b30b6 	strh	r3, [fp, #-6]
  IGMP_STATS_INC(igmp.xmit);
  13113c:	e3063840 	movw	r3, #26688	; 0x6840
  131140:	e3403057 	movt	r3, #87	; 0x57
  131144:	e1d337b8 	ldrh	r3, [r3, #120]	; 0x78
  131148:	e2833001 	add	r3, r3, #1
  13114c:	e6ff2073 	uxth	r2, r3
  131150:	e3063840 	movw	r3, #26688	; 0x6840
  131154:	e3403057 	movt	r3, #87	; 0x57
  131158:	e1c327b8 	strh	r2, [r3, #120]	; 0x78
  return ip4_output_if_opt(p, src, dest, IGMP_TTL, 0, IP_PROTO_IGMP, netif, ra, ROUTER_ALERTLEN);
  13115c:	e3a03004 	mov	r3, #4
  131160:	e58d3010 	str	r3, [sp, #16]
  131164:	e24b3008 	sub	r3, fp, #8
  131168:	e58d300c 	str	r3, [sp, #12]
  13116c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  131170:	e58d3008 	str	r3, [sp, #8]
  131174:	e3a03002 	mov	r3, #2
  131178:	e58d3004 	str	r3, [sp, #4]
  13117c:	e3a03000 	mov	r3, #0
  131180:	e58d3000 	str	r3, [sp]
  131184:	e3a03001 	mov	r3, #1
  131188:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  13118c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  131190:	e51b0010 	ldr	r0, [fp, #-16]
  131194:	eb000371 	bl	131f60 <ip4_output_if_opt>
  131198:	e1a03000 	mov	r3, r0
}
  13119c:	e1a00003 	mov	r0, r3
  1311a0:	e24bd004 	sub	sp, fp, #4
  1311a4:	e8bd8800 	pop	{fp, pc}

001311a8 <igmp_send>:
 * @param group the group to which to send the packet
 * @param type the type of igmp packet to send
 */
static void
igmp_send(struct netif *netif, struct igmp_group *group, u8_t type)
{
  1311a8:	e92d4800 	push	{fp, lr}
  1311ac:	e28db004 	add	fp, sp, #4
  1311b0:	e24dd020 	sub	sp, sp, #32
  1311b4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1311b8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  1311bc:	e1a03002 	mov	r3, r2
  1311c0:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
  struct pbuf*     p    = NULL;
  1311c4:	e3a03000 	mov	r3, #0
  1311c8:	e50b300c 	str	r3, [fp, #-12]
  struct igmp_msg* igmp = NULL;
  1311cc:	e3a03000 	mov	r3, #0
  1311d0:	e50b3010 	str	r3, [fp, #-16]
  ip4_addr_t   src  = *IP4_ADDR_ANY4;
  1311d4:	e3093b24 	movw	r3, #39716	; 0x9b24
  1311d8:	e3403014 	movt	r3, #20
  1311dc:	e5933000 	ldr	r3, [r3]
  1311e0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  ip4_addr_t*  dest = NULL;
  1311e4:	e3a03000 	mov	r3, #0
  1311e8:	e50b3008 	str	r3, [fp, #-8]

  /* IP header + "router alert" option + IGMP header */
  p = pbuf_alloc(PBUF_TRANSPORT, IGMP_MINLEN, PBUF_RAM);
  1311ec:	e3a02000 	mov	r2, #0
  1311f0:	e3a01008 	mov	r1, #8
  1311f4:	e3a00000 	mov	r0, #0
  1311f8:	ebffa4a6 	bl	11a498 <pbuf_alloc>
  1311fc:	e50b000c 	str	r0, [fp, #-12]

  if (p) {
  131200:	e51b300c 	ldr	r3, [fp, #-12]
  131204:	e3530000 	cmp	r3, #0
  131208:	0a000049 	beq	131334 <igmp_send+0x18c>
    igmp = (struct igmp_msg *)p->payload;
  13120c:	e51b300c 	ldr	r3, [fp, #-12]
  131210:	e5933004 	ldr	r3, [r3, #4]
  131214:	e50b3010 	str	r3, [fp, #-16]
    LWIP_ASSERT("igmp_send: check that first pbuf can hold struct igmp_msg",
  131218:	e51b300c 	ldr	r3, [fp, #-12]
  13121c:	e1d330ba 	ldrh	r3, [r3, #10]
  131220:	e3530007 	cmp	r3, #7
  131224:	8a000006 	bhi	131244 <igmp_send+0x9c>
  131228:	e3090a7c 	movw	r0, #39548	; 0x9a7c
  13122c:	e3400014 	movt	r0, #20
  131230:	ebff47b7 	bl	103114 <rt_kprintf>
  131234:	e3001302 	movw	r1, #770	; 0x302
  131238:	e309078c 	movw	r0, #38796	; 0x978c
  13123c:	e3400014 	movt	r0, #20
  131240:	ebff678d 	bl	10b07c <sys_arch_assert>
               (p->len >= sizeof(struct igmp_msg)));
    ip4_addr_copy(src, *netif_ip4_addr(netif));
  131244:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  131248:	e2833004 	add	r3, r3, #4
  13124c:	e5933000 	ldr	r3, [r3]
  131250:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

    if (type == IGMP_V2_MEMB_REPORT) {
  131254:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  131258:	e3530016 	cmp	r3, #22
  13125c:	1a00000a 	bne	13128c <igmp_send+0xe4>
      dest = &(group->group_address);
  131260:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  131264:	e2833004 	add	r3, r3, #4
  131268:	e50b3008 	str	r3, [fp, #-8]
      ip4_addr_copy(igmp->igmp_group_address, group->group_address);
  13126c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  131270:	e5932004 	ldr	r2, [r3, #4]
  131274:	e51b3010 	ldr	r3, [fp, #-16]
  131278:	e5832004 	str	r2, [r3, #4]
      group->last_reporter_flag = 1; /* Remember we were the last to report */
  13127c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  131280:	e3a02001 	mov	r2, #1
  131284:	e5c32008 	strb	r2, [r3, #8]
  131288:	ea000009 	b	1312b4 <igmp_send+0x10c>
    } else {
      if (type == IGMP_LEAVE_GROUP) {
  13128c:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  131290:	e3530017 	cmp	r3, #23
  131294:	1a000006 	bne	1312b4 <igmp_send+0x10c>
        dest = &allrouters;
  131298:	e30f3bcc 	movw	r3, #64460	; 0xfbcc
  13129c:	e3403014 	movt	r3, #20
  1312a0:	e50b3008 	str	r3, [fp, #-8]
        ip4_addr_copy(igmp->igmp_group_address, group->group_address);
  1312a4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1312a8:	e5932004 	ldr	r2, [r3, #4]
  1312ac:	e51b3010 	ldr	r3, [fp, #-16]
  1312b0:	e5832004 	str	r2, [r3, #4]
      }
    }

    if ((type == IGMP_V2_MEMB_REPORT) || (type == IGMP_LEAVE_GROUP)) {
  1312b4:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  1312b8:	e3530016 	cmp	r3, #22
  1312bc:	0a000002 	beq	1312cc <igmp_send+0x124>
  1312c0:	e55b301d 	ldrb	r3, [fp, #-29]	; 0xffffffe3
  1312c4:	e3530017 	cmp	r3, #23
  1312c8:	1a000016 	bne	131328 <igmp_send+0x180>
      igmp->igmp_msgtype  = type;
  1312cc:	e51b3010 	ldr	r3, [fp, #-16]
  1312d0:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
  1312d4:	e5c32000 	strb	r2, [r3]
      igmp->igmp_maxresp  = 0;
  1312d8:	e51b3010 	ldr	r3, [fp, #-16]
  1312dc:	e3a02000 	mov	r2, #0
  1312e0:	e5c32001 	strb	r2, [r3, #1]
      igmp->igmp_checksum = 0;
  1312e4:	e51b3010 	ldr	r3, [fp, #-16]
  1312e8:	e3a02000 	mov	r2, #0
  1312ec:	e5c32002 	strb	r2, [r3, #2]
  1312f0:	e3a02000 	mov	r2, #0
  1312f4:	e5c32003 	strb	r2, [r3, #3]
      igmp->igmp_checksum = inet_chksum(igmp, IGMP_MINLEN);
  1312f8:	e3a01008 	mov	r1, #8
  1312fc:	e51b0010 	ldr	r0, [fp, #-16]
  131300:	ebff9e43 	bl	118c14 <inet_chksum>
  131304:	e1a03000 	mov	r3, r0
  131308:	e1a02003 	mov	r2, r3
  13130c:	e51b3010 	ldr	r3, [fp, #-16]
  131310:	e1c320b2 	strh	r2, [r3, #2]

      igmp_ip_output_if(p, &src, dest, netif);
  131314:	e24b1014 	sub	r1, fp, #20
  131318:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  13131c:	e51b2008 	ldr	r2, [fp, #-8]
  131320:	e51b000c 	ldr	r0, [fp, #-12]
  131324:	ebffff79 	bl	131110 <igmp_ip_output_if>
    }

    pbuf_free(p);
  131328:	e51b000c 	ldr	r0, [fp, #-12]
  13132c:	ebffa760 	bl	11b0b4 <pbuf_free>
  } else {
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_send: not enough memory for igmp_send\n"));
    IGMP_STATS_INC(igmp.memerr);
  }
}
  131330:	ea000007 	b	131354 <igmp_send+0x1ac>
    IGMP_STATS_INC(igmp.memerr);
  131334:	e3063840 	movw	r3, #26688	; 0x6840
  131338:	e3403057 	movt	r3, #87	; 0x57
  13133c:	e1d338b2 	ldrh	r3, [r3, #130]	; 0x82
  131340:	e2833001 	add	r3, r3, #1
  131344:	e6ff2073 	uxth	r2, r3
  131348:	e3063840 	movw	r3, #26688	; 0x6840
  13134c:	e3403057 	movt	r3, #87	; 0x57
  131350:	e1c328b2 	strh	r2, [r3, #130]	; 0x82
}
  131354:	e320f000 	nop	{0}
  131358:	e24bd004 	sub	sp, fp, #4
  13135c:	e8bd8800 	pop	{fp, pc}

00131360 <ip4_set_default_multicast_netif>:
/**
 * @ingroup ip4
 * Set a default netif for IPv4 multicast. */
void
ip4_set_default_multicast_netif(struct netif* default_multicast_netif)
{
  131360:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  131364:	e28db000 	add	fp, sp, #0
  131368:	e24dd00c 	sub	sp, sp, #12
  13136c:	e50b0008 	str	r0, [fp, #-8]
  ip4_default_multicast_netif = default_multicast_netif;
  131370:	e30f3bd4 	movw	r3, #64468	; 0xfbd4
  131374:	e3403014 	movt	r3, #20
  131378:	e51b2008 	ldr	r2, [fp, #-8]
  13137c:	e5832000 	str	r2, [r3]
}
  131380:	e320f000 	nop	{0}
  131384:	e28bd000 	add	sp, fp, #0
  131388:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  13138c:	e12fff1e 	bx	lr

00131390 <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
  131390:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  131394:	e28db000 	add	fp, sp, #0
  131398:	e24dd014 	sub	sp, sp, #20
  13139c:	e50b0010 	str	r0, [fp, #-16]
  struct netif *netif;

#if LWIP_MULTICAST_TX_OPTIONS
  /* Use administratively selected interface for multicast by default */
  if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif) {
  1313a0:	e51b3010 	ldr	r3, [fp, #-16]
  1313a4:	e5933000 	ldr	r3, [r3]
  1313a8:	e20330f0 	and	r3, r3, #240	; 0xf0
  1313ac:	e35300e0 	cmp	r3, #224	; 0xe0
  1313b0:	1a000008 	bne	1313d8 <ip4_route+0x48>
  1313b4:	e30f3bd4 	movw	r3, #64468	; 0xfbd4
  1313b8:	e3403014 	movt	r3, #20
  1313bc:	e5933000 	ldr	r3, [r3]
  1313c0:	e3530000 	cmp	r3, #0
  1313c4:	0a000003 	beq	1313d8 <ip4_route+0x48>
    return ip4_default_multicast_netif;
  1313c8:	e30f3bd4 	movw	r3, #64468	; 0xfbd4
  1313cc:	e3403014 	movt	r3, #20
  1313d0:	e5933000 	ldr	r3, [r3]
  1313d4:	ea000091 	b	131620 <ip4_route+0x290>
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
  1313d8:	e3063834 	movw	r3, #26676	; 0x6834
  1313dc:	e3403057 	movt	r3, #87	; 0x57
  1313e0:	e5933000 	ldr	r3, [r3]
  1313e4:	e50b3008 	str	r3, [fp, #-8]
  1313e8:	ea000030 	b	1314b0 <ip4_route+0x120>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
  1313ec:	e51b3008 	ldr	r3, [fp, #-8]
  1313f0:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  1313f4:	e2033001 	and	r3, r3, #1
  1313f8:	e6ef3073 	uxtb	r3, r3
  1313fc:	e3530000 	cmp	r3, #0
  131400:	0a000027 	beq	1314a4 <ip4_route+0x114>
  131404:	e51b3008 	ldr	r3, [fp, #-8]
  131408:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  13140c:	e1a03123 	lsr	r3, r3, #2
  131410:	e2033001 	and	r3, r3, #1
  131414:	e6ef3073 	uxtb	r3, r3
  131418:	e3530000 	cmp	r3, #0
  13141c:	0a000020 	beq	1314a4 <ip4_route+0x114>
  131420:	e51b3008 	ldr	r3, [fp, #-8]
  131424:	e2833004 	add	r3, r3, #4
  131428:	e5933000 	ldr	r3, [r3]
  13142c:	e3530000 	cmp	r3, #0
  131430:	0a00001b 	beq	1314a4 <ip4_route+0x114>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
  131434:	e51b3010 	ldr	r3, [fp, #-16]
  131438:	e5932000 	ldr	r2, [r3]
  13143c:	e51b3008 	ldr	r3, [fp, #-8]
  131440:	e2833004 	add	r3, r3, #4
  131444:	e5933000 	ldr	r3, [r3]
  131448:	e0222003 	eor	r2, r2, r3
  13144c:	e51b3008 	ldr	r3, [fp, #-8]
  131450:	e2833008 	add	r3, r3, #8
  131454:	e5933000 	ldr	r3, [r3]
  131458:	e0033002 	and	r3, r3, r2
  13145c:	e3530000 	cmp	r3, #0
  131460:	1a000001 	bne	13146c <ip4_route+0xdc>
        /* return netif on which to forward IP packet */
        return netif;
  131464:	e51b3008 	ldr	r3, [fp, #-8]
  131468:	ea00006c 	b	131620 <ip4_route+0x290>
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
  13146c:	e51b3008 	ldr	r3, [fp, #-8]
  131470:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  131474:	e2033002 	and	r3, r3, #2
  131478:	e3530000 	cmp	r3, #0
  13147c:	1a000008 	bne	1314a4 <ip4_route+0x114>
  131480:	e51b3010 	ldr	r3, [fp, #-16]
  131484:	e5932000 	ldr	r2, [r3]
  131488:	e51b3008 	ldr	r3, [fp, #-8]
  13148c:	e283300c 	add	r3, r3, #12
  131490:	e5933000 	ldr	r3, [r3]
  131494:	e1520003 	cmp	r2, r3
  131498:	1a000001 	bne	1314a4 <ip4_route+0x114>
        /* return netif on which to forward IP packet */
        return netif;
  13149c:	e51b3008 	ldr	r3, [fp, #-8]
  1314a0:	ea00005e 	b	131620 <ip4_route+0x290>
  for (netif = netif_list; netif != NULL; netif = netif->next) {
  1314a4:	e51b3008 	ldr	r3, [fp, #-8]
  1314a8:	e5933000 	ldr	r3, [r3]
  1314ac:	e50b3008 	str	r3, [fp, #-8]
  1314b0:	e51b3008 	ldr	r3, [fp, #-8]
  1314b4:	e3530000 	cmp	r3, #0
  1314b8:	1affffcb 	bne	1313ec <ip4_route+0x5c>
    }
  }

#if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
  /* loopif is disabled, looopback traffic is passed through any netif */
  if (ip4_addr_isloopback(dest)) {
  1314bc:	e51b3010 	ldr	r3, [fp, #-16]
  1314c0:	e5933000 	ldr	r3, [r3]
  1314c4:	e6ef3073 	uxtb	r3, r3
  1314c8:	e353007f 	cmp	r3, #127	; 0x7f
  1314cc:	1a000025 	bne	131568 <ip4_route+0x1d8>
    /* don't check for link on loopback traffic */
    if (netif_default != NULL && netif_is_up(netif_default)) {
  1314d0:	e3063838 	movw	r3, #26680	; 0x6838
  1314d4:	e3403057 	movt	r3, #87	; 0x57
  1314d8:	e5933000 	ldr	r3, [r3]
  1314dc:	e3530000 	cmp	r3, #0
  1314e0:	0a00000b 	beq	131514 <ip4_route+0x184>
  1314e4:	e3063838 	movw	r3, #26680	; 0x6838
  1314e8:	e3403057 	movt	r3, #87	; 0x57
  1314ec:	e5933000 	ldr	r3, [r3]
  1314f0:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  1314f4:	e2033001 	and	r3, r3, #1
  1314f8:	e6ef3073 	uxtb	r3, r3
  1314fc:	e3530000 	cmp	r3, #0
  131500:	0a000003 	beq	131514 <ip4_route+0x184>
      return netif_default;
  131504:	e3063838 	movw	r3, #26680	; 0x6838
  131508:	e3403057 	movt	r3, #87	; 0x57
  13150c:	e5933000 	ldr	r3, [r3]
  131510:	ea000042 	b	131620 <ip4_route+0x290>
    }
    /* default netif is not up, just use any netif for loopback traffic */
    for (netif = netif_list; netif != NULL; netif = netif->next) {
  131514:	e3063834 	movw	r3, #26676	; 0x6834
  131518:	e3403057 	movt	r3, #87	; 0x57
  13151c:	e5933000 	ldr	r3, [r3]
  131520:	e50b3008 	str	r3, [fp, #-8]
  131524:	ea00000a 	b	131554 <ip4_route+0x1c4>
      if (netif_is_up(netif)) {
  131528:	e51b3008 	ldr	r3, [fp, #-8]
  13152c:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  131530:	e2033001 	and	r3, r3, #1
  131534:	e6ef3073 	uxtb	r3, r3
  131538:	e3530000 	cmp	r3, #0
  13153c:	0a000001 	beq	131548 <ip4_route+0x1b8>
        return netif;
  131540:	e51b3008 	ldr	r3, [fp, #-8]
  131544:	ea000035 	b	131620 <ip4_route+0x290>
    for (netif = netif_list; netif != NULL; netif = netif->next) {
  131548:	e51b3008 	ldr	r3, [fp, #-8]
  13154c:	e5933000 	ldr	r3, [r3]
  131550:	e50b3008 	str	r3, [fp, #-8]
  131554:	e51b3008 	ldr	r3, [fp, #-8]
  131558:	e3530000 	cmp	r3, #0
  13155c:	1afffff1 	bne	131528 <ip4_route+0x198>
      }
    }
    return NULL;
  131560:	e3a03000 	mov	r3, #0
  131564:	ea00002d 	b	131620 <ip4_route+0x290>
  if (netif != NULL) {
    return netif;
  }
#endif

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
  131568:	e3063838 	movw	r3, #26680	; 0x6838
  13156c:	e3403057 	movt	r3, #87	; 0x57
  131570:	e5933000 	ldr	r3, [r3]
  131574:	e3530000 	cmp	r3, #0
  131578:	0a000014 	beq	1315d0 <ip4_route+0x240>
  13157c:	e3063838 	movw	r3, #26680	; 0x6838
  131580:	e3403057 	movt	r3, #87	; 0x57
  131584:	e5933000 	ldr	r3, [r3]
  131588:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  13158c:	e2033001 	and	r3, r3, #1
  131590:	e3530000 	cmp	r3, #0
  131594:	0a00000d 	beq	1315d0 <ip4_route+0x240>
  131598:	e3063838 	movw	r3, #26680	; 0x6838
  13159c:	e3403057 	movt	r3, #87	; 0x57
  1315a0:	e5933000 	ldr	r3, [r3]
  1315a4:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  1315a8:	e2033004 	and	r3, r3, #4
  1315ac:	e3530000 	cmp	r3, #0
  1315b0:	0a000006 	beq	1315d0 <ip4_route+0x240>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default))) {
  1315b4:	e3063838 	movw	r3, #26680	; 0x6838
  1315b8:	e3403057 	movt	r3, #87	; 0x57
  1315bc:	e5933000 	ldr	r3, [r3]
  1315c0:	e2833004 	add	r3, r3, #4
  1315c4:	e5933000 	ldr	r3, [r3]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
  1315c8:	e3530000 	cmp	r3, #0
  1315cc:	1a000010 	bne	131614 <ip4_route+0x284>
    /* No matching netif found and default netif is not usable.
       If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
  1315d0:	e3063840 	movw	r3, #26688	; 0x6840
  1315d4:	e3403057 	movt	r3, #87	; 0x57
  1315d8:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
  1315dc:	e2833001 	add	r3, r3, #1
  1315e0:	e6ff2073 	uxth	r2, r3
  1315e4:	e3063840 	movw	r3, #26688	; 0x6840
  1315e8:	e3403057 	movt	r3, #87	; 0x57
  1315ec:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    MIB2_STATS_INC(mib2.ipoutnoroutes);
  1315f0:	e3063840 	movw	r3, #26688	; 0x6840
  1315f4:	e3403057 	movt	r3, #87	; 0x57
  1315f8:	e5933148 	ldr	r3, [r3, #328]	; 0x148
  1315fc:	e2832001 	add	r2, r3, #1
  131600:	e3063840 	movw	r3, #26688	; 0x6840
  131604:	e3403057 	movt	r3, #87	; 0x57
  131608:	e5832148 	str	r2, [r3, #328]	; 0x148
    return NULL;
  13160c:	e3a03000 	mov	r3, #0
  131610:	ea000002 	b	131620 <ip4_route+0x290>
  }

  return netif_default;
  131614:	e3063838 	movw	r3, #26680	; 0x6838
  131618:	e3403057 	movt	r3, #87	; 0x57
  13161c:	e5933000 	ldr	r3, [r3]
}
  131620:	e1a00003 	mov	r0, r3
  131624:	e28bd000 	add	sp, fp, #0
  131628:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  13162c:	e12fff1e 	bx	lr

00131630 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
  131630:	e92d4800 	push	{fp, lr}
  131634:	e28db004 	add	fp, sp, #4
  131638:	e24dd028 	sub	sp, sp, #40	; 0x28
  13163c:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  131640:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP
  int check_ip_src = 1;
  131644:	e3a03001 	mov	r3, #1
  131648:	e50b3010 	str	r3, [fp, #-16]
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP */

  IP_STATS_INC(ip.recv);
  13164c:	e3063840 	movw	r3, #26688	; 0x6840
  131650:	e3403057 	movt	r3, #87	; 0x57
  131654:	e1d334ba 	ldrh	r3, [r3, #74]	; 0x4a
  131658:	e2833001 	add	r3, r3, #1
  13165c:	e6ff2073 	uxth	r2, r3
  131660:	e3063840 	movw	r3, #26688	; 0x6840
  131664:	e3403057 	movt	r3, #87	; 0x57
  131668:	e1c324ba 	strh	r2, [r3, #74]	; 0x4a
  MIB2_STATS_INC(mib2.ipinreceives);
  13166c:	e3063840 	movw	r3, #26688	; 0x6840
  131670:	e3403057 	movt	r3, #87	; 0x57
  131674:	e5933168 	ldr	r3, [r3, #360]	; 0x168
  131678:	e2832001 	add	r2, r3, #1
  13167c:	e3063840 	movw	r3, #26688	; 0x6840
  131680:	e3403057 	movt	r3, #87	; 0x57
  131684:	e5832168 	str	r2, [r3, #360]	; 0x168

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  131688:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13168c:	e5933004 	ldr	r3, [r3, #4]
  131690:	e50b3008 	str	r3, [fp, #-8]
  if (IPH_V(iphdr) != 4) {
  131694:	e51b3008 	ldr	r3, [fp, #-8]
  131698:	e5d33000 	ldrb	r3, [r3]
  13169c:	e1a03223 	lsr	r3, r3, #4
  1316a0:	e6ef3073 	uxtb	r3, r3
  1316a4:	e3530004 	cmp	r3, #4
  1316a8:	0a00001a 	beq	131718 <ip4_input+0xe8>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
  1316ac:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  1316b0:	ebffa67f 	bl	11b0b4 <pbuf_free>
    IP_STATS_INC(ip.err);
  1316b4:	e3063840 	movw	r3, #26688	; 0x6840
  1316b8:	e3403057 	movt	r3, #87	; 0x57
  1316bc:	e1d335bc 	ldrh	r3, [r3, #92]	; 0x5c
  1316c0:	e2833001 	add	r3, r3, #1
  1316c4:	e6ff2073 	uxth	r2, r3
  1316c8:	e3063840 	movw	r3, #26688	; 0x6840
  1316cc:	e3403057 	movt	r3, #87	; 0x57
  1316d0:	e1c325bc 	strh	r2, [r3, #92]	; 0x5c
    IP_STATS_INC(ip.drop);
  1316d4:	e3063840 	movw	r3, #26688	; 0x6840
  1316d8:	e3403057 	movt	r3, #87	; 0x57
  1316dc:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
  1316e0:	e2833001 	add	r3, r3, #1
  1316e4:	e6ff2073 	uxth	r2, r3
  1316e8:	e3063840 	movw	r3, #26688	; 0x6840
  1316ec:	e3403057 	movt	r3, #87	; 0x57
  1316f0:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
    MIB2_STATS_INC(mib2.ipinhdrerrors);
  1316f4:	e3063840 	movw	r3, #26688	; 0x6840
  1316f8:	e3403057 	movt	r3, #87	; 0x57
  1316fc:	e593312c 	ldr	r3, [r3, #300]	; 0x12c
  131700:	e2832001 	add	r2, r3, #1
  131704:	e3063840 	movw	r3, #26688	; 0x6840
  131708:	e3403057 	movt	r3, #87	; 0x57
  13170c:	e583212c 	str	r2, [r3, #300]	; 0x12c
    return ERR_OK;
  131710:	e3a03000 	mov	r3, #0
  131714:	ea0001f2 	b	131ee4 <ip4_input+0x8b4>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  131718:	e51b3008 	ldr	r3, [fp, #-8]
  13171c:	e5d33000 	ldrb	r3, [r3]
  131720:	e6ff3073 	uxth	r3, r3
  131724:	e203300f 	and	r3, r3, #15
  131728:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  13172c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  131730:	e1a03103 	lsl	r3, r3, #2
  131734:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  /* obtain ip length in bytes */
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
  131738:	e51b3008 	ldr	r3, [fp, #-8]
  13173c:	e1d330b2 	ldrh	r3, [r3, #2]
  131740:	e6ff3073 	uxth	r3, r3
  131744:	e1a00003 	mov	r0, r3
  131748:	ebff9422 	bl	1167d8 <lwip_htons>
  13174c:	e1a03000 	mov	r3, r0
  131750:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8

  /* Trim pbuf. This is especially required for packets < 60 bytes. */
  if (iphdr_len < p->tot_len) {
  131754:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  131758:	e1d330b8 	ldrh	r3, [r3, #8]
  13175c:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
  131760:	e1520003 	cmp	r2, r3
  131764:	2a000003 	bcs	131778 <ip4_input+0x148>
    pbuf_realloc(p, iphdr_len);
  131768:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
  13176c:	e1a01003 	mov	r1, r3
  131770:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131774:	ebffa505 	bl	11ab90 <pbuf_realloc>
  }

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
  131778:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13177c:	e1d330ba 	ldrh	r3, [r3, #10]
  131780:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  131784:	e1520003 	cmp	r2, r3
  131788:	8a000007 	bhi	1317ac <ip4_input+0x17c>
  13178c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  131790:	e1d330b8 	ldrh	r3, [r3, #8]
  131794:	e15b21b8 	ldrh	r2, [fp, #-24]	; 0xffffffe8
  131798:	e1520003 	cmp	r2, r3
  13179c:	8a000002 	bhi	1317ac <ip4_input+0x17c>
  1317a0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  1317a4:	e3530013 	cmp	r3, #19
  1317a8:	8a00001a 	bhi	131818 <ip4_input+0x1e8>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
  1317ac:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  1317b0:	ebffa63f 	bl	11b0b4 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
  1317b4:	e3063840 	movw	r3, #26688	; 0x6840
  1317b8:	e3403057 	movt	r3, #87	; 0x57
  1317bc:	e1d335b2 	ldrh	r3, [r3, #82]	; 0x52
  1317c0:	e2833001 	add	r3, r3, #1
  1317c4:	e6ff2073 	uxth	r2, r3
  1317c8:	e3063840 	movw	r3, #26688	; 0x6840
  1317cc:	e3403057 	movt	r3, #87	; 0x57
  1317d0:	e1c325b2 	strh	r2, [r3, #82]	; 0x52
    IP_STATS_INC(ip.drop);
  1317d4:	e3063840 	movw	r3, #26688	; 0x6840
  1317d8:	e3403057 	movt	r3, #87	; 0x57
  1317dc:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
  1317e0:	e2833001 	add	r3, r3, #1
  1317e4:	e6ff2073 	uxth	r2, r3
  1317e8:	e3063840 	movw	r3, #26688	; 0x6840
  1317ec:	e3403057 	movt	r3, #87	; 0x57
  1317f0:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
    MIB2_STATS_INC(mib2.ipindiscards);
  1317f4:	e3063840 	movw	r3, #26688	; 0x6840
  1317f8:	e3403057 	movt	r3, #87	; 0x57
  1317fc:	e5933138 	ldr	r3, [r3, #312]	; 0x138
  131800:	e2832001 	add	r2, r3, #1
  131804:	e3063840 	movw	r3, #26688	; 0x6840
  131808:	e3403057 	movt	r3, #87	; 0x57
  13180c:	e5832138 	str	r2, [r3, #312]	; 0x138
    return ERR_OK;
  131810:	e3a03000 	mov	r3, #0
  131814:	ea0001b2 	b	131ee4 <ip4_input+0x8b4>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
    if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  131818:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  13181c:	e1a01003 	mov	r1, r3
  131820:	e51b0008 	ldr	r0, [fp, #-8]
  131824:	ebff9cfa 	bl	118c14 <inet_chksum>
  131828:	e1a03000 	mov	r3, r0
  13182c:	e3530000 	cmp	r3, #0
  131830:	0a00001a 	beq	1318a0 <ip4_input+0x270>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
      ip4_debug_print(p);
      pbuf_free(p);
  131834:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131838:	ebffa61d 	bl	11b0b4 <pbuf_free>
      IP_STATS_INC(ip.chkerr);
  13183c:	e3063840 	movw	r3, #26688	; 0x6840
  131840:	e3403057 	movt	r3, #87	; 0x57
  131844:	e1d335b0 	ldrh	r3, [r3, #80]	; 0x50
  131848:	e2833001 	add	r3, r3, #1
  13184c:	e6ff2073 	uxth	r2, r3
  131850:	e3063840 	movw	r3, #26688	; 0x6840
  131854:	e3403057 	movt	r3, #87	; 0x57
  131858:	e1c325b0 	strh	r2, [r3, #80]	; 0x50
      IP_STATS_INC(ip.drop);
  13185c:	e3063840 	movw	r3, #26688	; 0x6840
  131860:	e3403057 	movt	r3, #87	; 0x57
  131864:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
  131868:	e2833001 	add	r3, r3, #1
  13186c:	e6ff2073 	uxth	r2, r3
  131870:	e3063840 	movw	r3, #26688	; 0x6840
  131874:	e3403057 	movt	r3, #87	; 0x57
  131878:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
      MIB2_STATS_INC(mib2.ipinhdrerrors);
  13187c:	e3063840 	movw	r3, #26688	; 0x6840
  131880:	e3403057 	movt	r3, #87	; 0x57
  131884:	e593312c 	ldr	r3, [r3, #300]	; 0x12c
  131888:	e2832001 	add	r2, r3, #1
  13188c:	e3063840 	movw	r3, #26688	; 0x6840
  131890:	e3403057 	movt	r3, #87	; 0x57
  131894:	e583212c 	str	r2, [r3, #300]	; 0x12c
      return ERR_OK;
  131898:	e3a03000 	mov	r3, #0
  13189c:	ea000190 	b	131ee4 <ip4_input+0x8b4>
    }
  }
#endif

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
  1318a0:	e51b3008 	ldr	r3, [fp, #-8]
  1318a4:	e5932010 	ldr	r2, [r3, #16]
  1318a8:	e30035e8 	movw	r3, #1512	; 0x5e8
  1318ac:	e3403015 	movt	r3, #21
  1318b0:	e5832014 	str	r2, [r3, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
  1318b4:	e51b3008 	ldr	r3, [fp, #-8]
  1318b8:	e593200c 	ldr	r2, [r3, #12]
  1318bc:	e30035e8 	movw	r3, #1512	; 0x5e8
  1318c0:	e3403015 	movt	r3, #21
  1318c4:	e5832010 	str	r2, [r3, #16]

  /* match packet against an interface, i.e. is this packet for us? */
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
  1318c8:	e30035e8 	movw	r3, #1512	; 0x5e8
  1318cc:	e3403015 	movt	r3, #21
  1318d0:	e5933014 	ldr	r3, [r3, #20]
  1318d4:	e20330f0 	and	r3, r3, #240	; 0xf0
  1318d8:	e35300e0 	cmp	r3, #224	; 0xe0
  1318dc:	1a000020 	bne	131964 <ip4_input+0x334>
#if LWIP_IGMP
    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
  1318e0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1318e4:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  1318e8:	e2033020 	and	r3, r3, #32
  1318ec:	e3530000 	cmp	r3, #0
  1318f0:	0a000018 	beq	131958 <ip4_input+0x328>
  1318f4:	e59f15f4 	ldr	r1, [pc, #1524]	; 131ef0 <ip4_input+0x8c0>
  1318f8:	e51b002c 	ldr	r0, [fp, #-44]	; 0xffffffd4
  1318fc:	ebfffa77 	bl	1302e0 <igmp_lookfor_group>
  131900:	e1a03000 	mov	r3, r0
  131904:	e3530000 	cmp	r3, #0
  131908:	0a000012 	beq	131958 <ip4_input+0x328>
      /* IGMP snooping switches need 0.0.0.0 to be allowed as source address (RFC 4541) */
      ip4_addr_t allsystems;
      IP4_ADDR(&allsystems, 224, 0, 0, 1);
  13190c:	e3a030e0 	mov	r3, #224	; 0xe0
  131910:	e3403100 	movt	r3, #256	; 0x100
  131914:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
      if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
  131918:	e30035e8 	movw	r3, #1512	; 0x5e8
  13191c:	e3403015 	movt	r3, #21
  131920:	e5932014 	ldr	r2, [r3, #20]
  131924:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  131928:	e1520003 	cmp	r2, r3
  13192c:	1a000006 	bne	13194c <ip4_input+0x31c>
          ip4_addr_isany(ip4_current_src_addr())) {
  131930:	e30035e8 	movw	r3, #1512	; 0x5e8
  131934:	e3403015 	movt	r3, #21
  131938:	e5933010 	ldr	r3, [r3, #16]
      if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
  13193c:	e3530000 	cmp	r3, #0
  131940:	1a000001 	bne	13194c <ip4_input+0x31c>
        check_ip_src = 0;
  131944:	e3a03000 	mov	r3, #0
  131948:	e50b3010 	str	r3, [fp, #-16]
      }
      netif = inp;
  13194c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  131950:	e50b300c 	str	r3, [fp, #-12]
    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
  131954:	ea000040 	b	131a5c <ip4_input+0x42c>
    } else {
      netif = NULL;
  131958:	e3a03000 	mov	r3, #0
  13195c:	e50b300c 	str	r3, [fp, #-12]
  131960:	ea00003d 	b	131a5c <ip4_input+0x42c>
#endif /* LWIP_IGMP */
  } else {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  131964:	e3a03001 	mov	r3, #1
  131968:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    netif = inp;
  13196c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  131970:	e50b300c 	str	r3, [fp, #-12]
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
          ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
  131974:	e51b300c 	ldr	r3, [fp, #-12]
  131978:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  13197c:	e2033001 	and	r3, r3, #1
  131980:	e6ef3073 	uxtb	r3, r3
  131984:	e3530000 	cmp	r3, #0
  131988:	0a00001c 	beq	131a00 <ip4_input+0x3d0>
  13198c:	e51b300c 	ldr	r3, [fp, #-12]
  131990:	e2833004 	add	r3, r3, #4
  131994:	e5933000 	ldr	r3, [r3]
  131998:	e3530000 	cmp	r3, #0
  13199c:	0a000017 	beq	131a00 <ip4_input+0x3d0>
        /* unicast to this interface address? */
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
  1319a0:	e30035e8 	movw	r3, #1512	; 0x5e8
  1319a4:	e3403015 	movt	r3, #21
  1319a8:	e5932014 	ldr	r2, [r3, #20]
  1319ac:	e51b300c 	ldr	r3, [fp, #-12]
  1319b0:	e2833004 	add	r3, r3, #4
  1319b4:	e5933000 	ldr	r3, [r3]
  1319b8:	e1520003 	cmp	r2, r3
  1319bc:	0a000026 	beq	131a5c <ip4_input+0x42c>
            /* or broadcast on this interface network address? */
            ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
  1319c0:	e30035e8 	movw	r3, #1512	; 0x5e8
  1319c4:	e3403015 	movt	r3, #21
  1319c8:	e5933014 	ldr	r3, [r3, #20]
  1319cc:	e51b100c 	ldr	r1, [fp, #-12]
  1319d0:	e1a00003 	mov	r0, r3
  1319d4:	eb00034c 	bl	13270c <ip4_addr_isbroadcast_u32>
  1319d8:	e1a03000 	mov	r3, r0
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
  1319dc:	e3530000 	cmp	r3, #0
  1319e0:	1a00001d 	bne	131a5c <ip4_input+0x42c>
#if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
            || (ip4_addr_get_u32(ip4_current_dest_addr()) == PP_HTONL(IPADDR_LOOPBACK))
  1319e4:	e30035e8 	movw	r3, #1512	; 0x5e8
  1319e8:	e3403015 	movt	r3, #21
  1319ec:	e5932014 	ldr	r2, [r3, #20]
  1319f0:	e3a0307f 	mov	r3, #127	; 0x7f
  1319f4:	e3403100 	movt	r3, #256	; 0x100
  1319f8:	e1520003 	cmp	r2, r3
  1319fc:	0a000016 	beq	131a5c <ip4_input+0x42c>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
  131a00:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  131a04:	e3530000 	cmp	r3, #0
  131a08:	0a000006 	beq	131a28 <ip4_input+0x3f8>
        if (ip4_addr_isloopback(ip4_current_dest_addr())) {
          netif = NULL;
          break;
        }
#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
        first = 0;
  131a0c:	e3a03000 	mov	r3, #0
  131a10:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        netif = netif_list;
  131a14:	e3063834 	movw	r3, #26676	; 0x6834
  131a18:	e3403057 	movt	r3, #87	; 0x57
  131a1c:	e5933000 	ldr	r3, [r3]
  131a20:	e50b300c 	str	r3, [fp, #-12]
  131a24:	ea000002 	b	131a34 <ip4_input+0x404>
      } else {
        netif = netif->next;
  131a28:	e51b300c 	ldr	r3, [fp, #-12]
  131a2c:	e5933000 	ldr	r3, [r3]
  131a30:	e50b300c 	str	r3, [fp, #-12]
      }
      if (netif == inp) {
  131a34:	e51b200c 	ldr	r2, [fp, #-12]
  131a38:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  131a3c:	e1520003 	cmp	r2, r3
  131a40:	1a000002 	bne	131a50 <ip4_input+0x420>
        netif = netif->next;
  131a44:	e51b300c 	ldr	r3, [fp, #-12]
  131a48:	e5933000 	ldr	r3, [r3]
  131a4c:	e50b300c 	str	r3, [fp, #-12]
      }
    } while (netif != NULL);
  131a50:	e51b300c 	ldr	r3, [fp, #-12]
  131a54:	e3530000 	cmp	r3, #0
  131a58:	1affffc5 	bne	131974 <ip4_input+0x344>
   * If you want to accept private broadcast communication while a netif is down,
   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
  131a5c:	e51b300c 	ldr	r3, [fp, #-12]
  131a60:	e3530000 	cmp	r3, #0
  131a64:	1a000010 	bne	131aac <ip4_input+0x47c>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  131a68:	e51b3008 	ldr	r3, [fp, #-8]
  131a6c:	e5d33009 	ldrb	r3, [r3, #9]
  131a70:	e3530011 	cmp	r3, #17
  131a74:	1a00000c 	bne	131aac <ip4_input+0x47c>
      struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
  131a78:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  131a7c:	e51b2008 	ldr	r2, [fp, #-8]
  131a80:	e0823003 	add	r3, r2, r3
  131a84:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: UDP packet to DHCP client port %"U16_F"\n",
        lwip_ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
  131a88:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  131a8c:	e1d330b2 	ldrh	r3, [r3, #2]
  131a90:	e6ff3073 	uxth	r3, r3
  131a94:	e3530b11 	cmp	r3, #17408	; 0x4400
  131a98:	1a000003 	bne	131aac <ip4_input+0x47c>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: DHCP packet accepted.\n"));
        netif = inp;
  131a9c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  131aa0:	e50b300c 	str	r3, [fp, #-12]
        check_ip_src = 0;
  131aa4:	e3a03000 	mov	r3, #0
  131aa8:	e50b3010 	str	r3, [fp, #-16]
  }
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING
  if (check_ip_src
  131aac:	e51b3010 	ldr	r3, [fp, #-16]
  131ab0:	e3530000 	cmp	r3, #0
  131ab4:	0a00002d 	beq	131b70 <ip4_input+0x540>
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
      && !ip4_addr_isany_val(*ip4_current_src_addr())
  131ab8:	e30035e8 	movw	r3, #1512	; 0x5e8
  131abc:	e3403015 	movt	r3, #21
  131ac0:	e5933010 	ldr	r3, [r3, #16]
  131ac4:	e3530000 	cmp	r3, #0
  131ac8:	0a000028 	beq	131b70 <ip4_input+0x540>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
     )
#endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
  131acc:	e30035e8 	movw	r3, #1512	; 0x5e8
  131ad0:	e3403015 	movt	r3, #21
  131ad4:	e5933010 	ldr	r3, [r3, #16]
  131ad8:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  131adc:	e1a00003 	mov	r0, r3
  131ae0:	eb000309 	bl	13270c <ip4_addr_isbroadcast_u32>
  131ae4:	e1a03000 	mov	r3, r0
  131ae8:	e3530000 	cmp	r3, #0
  131aec:	1a000005 	bne	131b08 <ip4_input+0x4d8>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
  131af0:	e30035e8 	movw	r3, #1512	; 0x5e8
  131af4:	e3403015 	movt	r3, #21
  131af8:	e5933010 	ldr	r3, [r3, #16]
  131afc:	e20330f0 	and	r3, r3, #240	; 0xf0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
  131b00:	e35300e0 	cmp	r3, #224	; 0xe0
  131b04:	1a000019 	bne	131b70 <ip4_input+0x540>
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  131b08:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131b0c:	ebffa568 	bl	11b0b4 <pbuf_free>
      IP_STATS_INC(ip.drop);
  131b10:	e3063840 	movw	r3, #26688	; 0x6840
  131b14:	e3403057 	movt	r3, #87	; 0x57
  131b18:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
  131b1c:	e2833001 	add	r3, r3, #1
  131b20:	e6ff2073 	uxth	r2, r3
  131b24:	e3063840 	movw	r3, #26688	; 0x6840
  131b28:	e3403057 	movt	r3, #87	; 0x57
  131b2c:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
      MIB2_STATS_INC(mib2.ipinaddrerrors);
  131b30:	e3063840 	movw	r3, #26688	; 0x6840
  131b34:	e3403057 	movt	r3, #87	; 0x57
  131b38:	e5933130 	ldr	r3, [r3, #304]	; 0x130
  131b3c:	e2832001 	add	r2, r3, #1
  131b40:	e3063840 	movw	r3, #26688	; 0x6840
  131b44:	e3403057 	movt	r3, #87	; 0x57
  131b48:	e5832130 	str	r2, [r3, #304]	; 0x130
      MIB2_STATS_INC(mib2.ipindiscards);
  131b4c:	e3063840 	movw	r3, #26688	; 0x6840
  131b50:	e3403057 	movt	r3, #87	; 0x57
  131b54:	e5933138 	ldr	r3, [r3, #312]	; 0x138
  131b58:	e2832001 	add	r2, r3, #1
  131b5c:	e3063840 	movw	r3, #26688	; 0x6840
  131b60:	e3403057 	movt	r3, #87	; 0x57
  131b64:	e5832138 	str	r2, [r3, #312]	; 0x138
      return ERR_OK;
  131b68:	e3a03000 	mov	r3, #0
  131b6c:	ea0000dc 	b	131ee4 <ip4_input+0x8b4>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  131b70:	e51b300c 	ldr	r3, [fp, #-12]
  131b74:	e3530000 	cmp	r3, #0
  131b78:	1a000019 	bne	131be4 <ip4_input+0x5b4>
      /* try to forward IP packet on (other) interfaces */
      ip4_forward(p, iphdr, inp);
    } else
#endif /* IP_FORWARD */
    {
      IP_STATS_INC(ip.drop);
  131b7c:	e3063840 	movw	r3, #26688	; 0x6840
  131b80:	e3403057 	movt	r3, #87	; 0x57
  131b84:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
  131b88:	e2833001 	add	r3, r3, #1
  131b8c:	e6ff2073 	uxth	r2, r3
  131b90:	e3063840 	movw	r3, #26688	; 0x6840
  131b94:	e3403057 	movt	r3, #87	; 0x57
  131b98:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
      MIB2_STATS_INC(mib2.ipinaddrerrors);
  131b9c:	e3063840 	movw	r3, #26688	; 0x6840
  131ba0:	e3403057 	movt	r3, #87	; 0x57
  131ba4:	e5933130 	ldr	r3, [r3, #304]	; 0x130
  131ba8:	e2832001 	add	r2, r3, #1
  131bac:	e3063840 	movw	r3, #26688	; 0x6840
  131bb0:	e3403057 	movt	r3, #87	; 0x57
  131bb4:	e5832130 	str	r2, [r3, #304]	; 0x130
      MIB2_STATS_INC(mib2.ipindiscards);
  131bb8:	e3063840 	movw	r3, #26688	; 0x6840
  131bbc:	e3403057 	movt	r3, #87	; 0x57
  131bc0:	e5933138 	ldr	r3, [r3, #312]	; 0x138
  131bc4:	e2832001 	add	r2, r3, #1
  131bc8:	e3063840 	movw	r3, #26688	; 0x6840
  131bcc:	e3403057 	movt	r3, #87	; 0x57
  131bd0:	e5832138 	str	r2, [r3, #312]	; 0x138
    }
    pbuf_free(p);
  131bd4:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131bd8:	ebffa535 	bl	11b0b4 <pbuf_free>
    return ERR_OK;
  131bdc:	e3a03000 	mov	r3, #0
  131be0:	ea0000bf 	b	131ee4 <ip4_input+0x8b4>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
  131be4:	e51b3008 	ldr	r3, [fp, #-8]
  131be8:	e1d330b6 	ldrh	r3, [r3, #6]
  131bec:	e6ff3073 	uxth	r3, r3
  131bf0:	e1a02003 	mov	r2, r3
  131bf4:	e30f3f3f 	movw	r3, #65343	; 0xff3f
  131bf8:	e0033002 	and	r3, r3, r2
  131bfc:	e3530000 	cmp	r3, #0
  131c00:	0a00000a 	beq	131c30 <ip4_input+0x600>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip4_reass()\n",
      lwip_ntohs(IPH_ID(iphdr)), p->tot_len, lwip_ntohs(IPH_LEN(iphdr)), (u16_t)!!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (u16_t)((lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8)));
    /* reassemble the packet*/
    p = ip4_reass(p);
  131c04:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131c08:	eb000778 	bl	1339f0 <ip4_reass>
  131c0c:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  131c10:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  131c14:	e3530000 	cmp	r3, #0
  131c18:	1a000001 	bne	131c24 <ip4_input+0x5f4>
      return ERR_OK;
  131c1c:	e3a03000 	mov	r3, #0
  131c20:	ea0000af 	b	131ee4 <ip4_input+0x8b4>
    }
    iphdr = (struct ip_hdr *)p->payload;
  131c24:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  131c28:	e5933004 	ldr	r3, [r3, #4]
  131c2c:	e50b3008 	str	r3, [fp, #-8]
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
  ip4_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  ip_data.current_netif = netif;
  131c30:	e30035e8 	movw	r3, #1512	; 0x5e8
  131c34:	e3403015 	movt	r3, #21
  131c38:	e51b200c 	ldr	r2, [fp, #-12]
  131c3c:	e5832000 	str	r2, [r3]
  ip_data.current_input_netif = inp;
  131c40:	e30035e8 	movw	r3, #1512	; 0x5e8
  131c44:	e3403015 	movt	r3, #21
  131c48:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  131c4c:	e5832004 	str	r2, [r3, #4]
  ip_data.current_ip4_header = iphdr;
  131c50:	e30035e8 	movw	r3, #1512	; 0x5e8
  131c54:	e3403015 	movt	r3, #21
  131c58:	e51b2008 	ldr	r2, [fp, #-8]
  131c5c:	e5832008 	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * 4;
  131c60:	e51b3008 	ldr	r3, [fp, #-8]
  131c64:	e5d33000 	ldrb	r3, [r3]
  131c68:	e6ff3073 	uxth	r3, r3
  131c6c:	e203300f 	and	r3, r3, #15
  131c70:	e6ff3073 	uxth	r3, r3
  131c74:	e1a03103 	lsl	r3, r3, #2
  131c78:	e6ff2073 	uxth	r2, r3
  131c7c:	e30035e8 	movw	r3, #1512	; 0x5e8
  131c80:	e3403015 	movt	r3, #21
  131c84:	e1c320bc 	strh	r2, [r3, #12]

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  131c88:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  131c8c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131c90:	ebffa9d1 	bl	11c3dc <raw_input>
  131c94:	e1a03000 	mov	r3, r0
  131c98:	e3530000 	cmp	r3, #0
  131c9c:	1a000076 	bne	131e7c <ip4_input+0x84c>
#endif /* LWIP_RAW */
  {
    pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
  131ca0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  131ca4:	e2633000 	rsb	r3, r3, #0
  131ca8:	e6ff3073 	uxth	r3, r3
  131cac:	e6bf3073 	sxth	r3, r3
  131cb0:	e1a01003 	mov	r1, r3
  131cb4:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131cb8:	ebffa4df 	bl	11b03c <pbuf_header>

    switch (IPH_PROTO(iphdr)) {
  131cbc:	e51b3008 	ldr	r3, [fp, #-8]
  131cc0:	e5d33009 	ldrb	r3, [r3, #9]
  131cc4:	e2433001 	sub	r3, r3, #1
  131cc8:	e3530010 	cmp	r3, #16
  131ccc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  131cd0:	ea000036 	b	131db0 <ip4_input+0x780>
  131cd4:	00131d70 	.word	0x00131d70
  131cd8:	00131d9c 	.word	0x00131d9c
  131cdc:	00131db0 	.word	0x00131db0
  131ce0:	00131db0 	.word	0x00131db0
  131ce4:	00131db0 	.word	0x00131db0
  131ce8:	00131d44 	.word	0x00131d44
  131cec:	00131db0 	.word	0x00131db0
  131cf0:	00131db0 	.word	0x00131db0
  131cf4:	00131db0 	.word	0x00131db0
  131cf8:	00131db0 	.word	0x00131db0
  131cfc:	00131db0 	.word	0x00131db0
  131d00:	00131db0 	.word	0x00131db0
  131d04:	00131db0 	.word	0x00131db0
  131d08:	00131db0 	.word	0x00131db0
  131d0c:	00131db0 	.word	0x00131db0
  131d10:	00131db0 	.word	0x00131db0
  131d14:	00131d18 	.word	0x00131d18
#if LWIP_UDP
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      MIB2_STATS_INC(mib2.ipindelivers);
  131d18:	e3063840 	movw	r3, #26688	; 0x6840
  131d1c:	e3403057 	movt	r3, #87	; 0x57
  131d20:	e593313c 	ldr	r3, [r3, #316]	; 0x13c
  131d24:	e2832001 	add	r2, r3, #1
  131d28:	e3063840 	movw	r3, #26688	; 0x6840
  131d2c:	e3403057 	movt	r3, #87	; 0x57
  131d30:	e583213c 	str	r2, [r3, #316]	; 0x13c
      udp_input(p, inp);
  131d34:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  131d38:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131d3c:	ebffd80c 	bl	127d74 <udp_input>
      break;
  131d40:	ea00004e 	b	131e80 <ip4_input+0x850>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      MIB2_STATS_INC(mib2.ipindelivers);
  131d44:	e3063840 	movw	r3, #26688	; 0x6840
  131d48:	e3403057 	movt	r3, #87	; 0x57
  131d4c:	e593313c 	ldr	r3, [r3, #316]	; 0x13c
  131d50:	e2832001 	add	r2, r3, #1
  131d54:	e3063840 	movw	r3, #26688	; 0x6840
  131d58:	e3403057 	movt	r3, #87	; 0x57
  131d5c:	e583213c 	str	r2, [r3, #316]	; 0x13c
      tcp_input(p, inp);
  131d60:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  131d64:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131d68:	ebffb9c8 	bl	120490 <tcp_input>
      break;
  131d6c:	ea000043 	b	131e80 <ip4_input+0x850>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      MIB2_STATS_INC(mib2.ipindelivers);
  131d70:	e3063840 	movw	r3, #26688	; 0x6840
  131d74:	e3403057 	movt	r3, #87	; 0x57
  131d78:	e593313c 	ldr	r3, [r3, #316]	; 0x13c
  131d7c:	e2832001 	add	r2, r3, #1
  131d80:	e3063840 	movw	r3, #26688	; 0x6840
  131d84:	e3403057 	movt	r3, #87	; 0x57
  131d88:	e583213c 	str	r2, [r3, #316]	; 0x13c
      icmp_input(p, inp);
  131d8c:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  131d90:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131d94:	ebfff665 	bl	12f730 <icmp_input>
      break;
  131d98:	ea000038 	b	131e80 <ip4_input+0x850>
#endif /* LWIP_ICMP */
#if LWIP_IGMP
    case IP_PROTO_IGMP:
      igmp_input(p, inp, ip4_current_dest_addr());
  131d9c:	e59f214c 	ldr	r2, [pc, #332]	; 131ef0 <ip4_input+0x8c0>
  131da0:	e51b102c 	ldr	r1, [fp, #-44]	; 0xffffffd4
  131da4:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131da8:	ebfff9ed 	bl	130564 <igmp_input>
      break;
  131dac:	ea000033 	b	131e80 <ip4_input+0x850>
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
  131db0:	e30035e8 	movw	r3, #1512	; 0x5e8
  131db4:	e3403015 	movt	r3, #21
  131db8:	e5933014 	ldr	r3, [r3, #20]
  131dbc:	e51b100c 	ldr	r1, [fp, #-12]
  131dc0:	e1a00003 	mov	r0, r3
  131dc4:	eb000250 	bl	13270c <ip4_addr_isbroadcast_u32>
  131dc8:	e1a03000 	mov	r3, r0
  131dcc:	e3530000 	cmp	r3, #0
  131dd0:	1a00000f 	bne	131e14 <ip4_input+0x7e4>
          !ip4_addr_ismulticast(ip4_current_dest_addr())) {
  131dd4:	e30035e8 	movw	r3, #1512	; 0x5e8
  131dd8:	e3403015 	movt	r3, #21
  131ddc:	e5933014 	ldr	r3, [r3, #20]
  131de0:	e20330f0 	and	r3, r3, #240	; 0xf0
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
  131de4:	e35300e0 	cmp	r3, #224	; 0xe0
  131de8:	0a000009 	beq	131e14 <ip4_input+0x7e4>
        pbuf_header_force(p, iphdr_hlen); /* Move to ip header, no check necessary. */
  131dec:	e15b31f6 	ldrsh	r3, [fp, #-22]	; 0xffffffea
  131df0:	e1a01003 	mov	r1, r3
  131df4:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131df8:	ebffa49e 	bl	11b078 <pbuf_header_force>
        p->payload = iphdr;
  131dfc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  131e00:	e51b2008 	ldr	r2, [fp, #-8]
  131e04:	e5832004 	str	r2, [r3, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  131e08:	e3a01002 	mov	r1, #2
  131e0c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131e10:	ebfff81c 	bl	12fe88 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  131e14:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  131e18:	ebffa4a5 	bl	11b0b4 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", (u16_t)IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
  131e1c:	e3063840 	movw	r3, #26688	; 0x6840
  131e20:	e3403057 	movt	r3, #87	; 0x57
  131e24:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
  131e28:	e2833001 	add	r3, r3, #1
  131e2c:	e6ff2073 	uxth	r2, r3
  131e30:	e3063840 	movw	r3, #26688	; 0x6840
  131e34:	e3403057 	movt	r3, #87	; 0x57
  131e38:	e1c325b8 	strh	r2, [r3, #88]	; 0x58
      IP_STATS_INC(ip.drop);
  131e3c:	e3063840 	movw	r3, #26688	; 0x6840
  131e40:	e3403057 	movt	r3, #87	; 0x57
  131e44:	e1d334be 	ldrh	r3, [r3, #78]	; 0x4e
  131e48:	e2833001 	add	r3, r3, #1
  131e4c:	e6ff2073 	uxth	r2, r3
  131e50:	e3063840 	movw	r3, #26688	; 0x6840
  131e54:	e3403057 	movt	r3, #87	; 0x57
  131e58:	e1c324be 	strh	r2, [r3, #78]	; 0x4e
      MIB2_STATS_INC(mib2.ipinunknownprotos);
  131e5c:	e3063840 	movw	r3, #26688	; 0x6840
  131e60:	e3403057 	movt	r3, #87	; 0x57
  131e64:	e5933134 	ldr	r3, [r3, #308]	; 0x134
  131e68:	e2832001 	add	r2, r3, #1
  131e6c:	e3063840 	movw	r3, #26688	; 0x6840
  131e70:	e3403057 	movt	r3, #87	; 0x57
  131e74:	e5832134 	str	r2, [r3, #308]	; 0x134
  131e78:	ea000000 	b	131e80 <ip4_input+0x850>
    }
  }
  131e7c:	e320f000 	nop	{0}

  /* @todo: this is not really necessary... */
  ip_data.current_netif = NULL;
  131e80:	e30035e8 	movw	r3, #1512	; 0x5e8
  131e84:	e3403015 	movt	r3, #21
  131e88:	e3a02000 	mov	r2, #0
  131e8c:	e5832000 	str	r2, [r3]
  ip_data.current_input_netif = NULL;
  131e90:	e30035e8 	movw	r3, #1512	; 0x5e8
  131e94:	e3403015 	movt	r3, #21
  131e98:	e3a02000 	mov	r2, #0
  131e9c:	e5832004 	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
  131ea0:	e30035e8 	movw	r3, #1512	; 0x5e8
  131ea4:	e3403015 	movt	r3, #21
  131ea8:	e3a02000 	mov	r2, #0
  131eac:	e5832008 	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
  131eb0:	e30035e8 	movw	r3, #1512	; 0x5e8
  131eb4:	e3403015 	movt	r3, #21
  131eb8:	e3a02000 	mov	r2, #0
  131ebc:	e1c320bc 	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
  131ec0:	e30035e8 	movw	r3, #1512	; 0x5e8
  131ec4:	e3403015 	movt	r3, #21
  131ec8:	e3a02000 	mov	r2, #0
  131ecc:	e5832010 	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
  131ed0:	e30035e8 	movw	r3, #1512	; 0x5e8
  131ed4:	e3403015 	movt	r3, #21
  131ed8:	e3a02000 	mov	r2, #0
  131edc:	e5832014 	str	r2, [r3, #20]

  return ERR_OK;
  131ee0:	e3a03000 	mov	r3, #0
}
  131ee4:	e1a00003 	mov	r0, r3
  131ee8:	e24bd004 	sub	sp, fp, #4
  131eec:	e8bd8800 	pop	{fp, pc}
  131ef0:	001505fc 	.word	0x001505fc

00131ef4 <ip4_output_if>:
 */
err_t
ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  131ef4:	e92d4800 	push	{fp, lr}
  131ef8:	e28db004 	add	fp, sp, #4
  131efc:	e24dd028 	sub	sp, sp, #40	; 0x28
  131f00:	e50b0008 	str	r0, [fp, #-8]
  131f04:	e50b100c 	str	r1, [fp, #-12]
  131f08:	e50b2010 	str	r2, [fp, #-16]
  131f0c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
#if IP_OPTIONS_SEND
  return ip4_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
  131f10:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  131f14:	e3a03000 	mov	r3, #0
  131f18:	e58d3010 	str	r3, [sp, #16]
  131f1c:	e3a03000 	mov	r3, #0
  131f20:	e58d300c 	str	r3, [sp, #12]
  131f24:	e59b300c 	ldr	r3, [fp, #12]
  131f28:	e58d3008 	str	r3, [sp, #8]
  131f2c:	e5db3008 	ldrb	r3, [fp, #8]
  131f30:	e58d3004 	str	r3, [sp, #4]
  131f34:	e5db3004 	ldrb	r3, [fp, #4]
  131f38:	e58d3000 	str	r3, [sp]
  131f3c:	e1a03002 	mov	r3, r2
  131f40:	e51b2010 	ldr	r2, [fp, #-16]
  131f44:	e51b100c 	ldr	r1, [fp, #-12]
  131f48:	e51b0008 	ldr	r0, [fp, #-8]
  131f4c:	eb000003 	bl	131f60 <ip4_output_if_opt>
  131f50:	e1a03000 	mov	r3, r0
}
  131f54:	e1a00003 	mov	r0, r3
  131f58:	e24bd004 	sub	sp, fp, #4
  131f5c:	e8bd8800 	pop	{fp, pc}

00131f60 <ip4_output_if_opt>:
 */
err_t
ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
       u16_t optlen)
{
  131f60:	e92d4800 	push	{fp, lr}
  131f64:	e28db004 	add	fp, sp, #4
  131f68:	e24dd030 	sub	sp, sp, #48	; 0x30
  131f6c:	e50b0010 	str	r0, [fp, #-16]
  131f70:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  131f74:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  131f78:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
#endif /* IP_OPTIONS_SEND */
  const ip4_addr_t *src_used = src;
  131f7c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  131f80:	e50b3008 	str	r3, [fp, #-8]
  if (dest != LWIP_IP_HDRINCL) {
  131f84:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  131f88:	e3530000 	cmp	r3, #0
  131f8c:	0a000009 	beq	131fb8 <ip4_output_if_opt+0x58>
    if (ip4_addr_isany(src)) {
  131f90:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  131f94:	e3530000 	cmp	r3, #0
  131f98:	0a000003 	beq	131fac <ip4_output_if_opt+0x4c>
  131f9c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  131fa0:	e5933000 	ldr	r3, [r3]
  131fa4:	e3530000 	cmp	r3, #0
  131fa8:	1a000002 	bne	131fb8 <ip4_output_if_opt+0x58>
      src_used = netif_ip4_addr(netif);
  131fac:	e59b300c 	ldr	r3, [fp, #12]
  131fb0:	e2833004 	add	r3, r3, #4
  131fb4:	e50b3008 	str	r3, [fp, #-8]
    }
  }

#if IP_OPTIONS_SEND
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
  131fb8:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
  131fbc:	e1db31b4 	ldrh	r3, [fp, #20]
  131fc0:	e58d3010 	str	r3, [sp, #16]
  131fc4:	e59b3010 	ldr	r3, [fp, #16]
  131fc8:	e58d300c 	str	r3, [sp, #12]
  131fcc:	e59b300c 	ldr	r3, [fp, #12]
  131fd0:	e58d3008 	str	r3, [sp, #8]
  131fd4:	e5db3008 	ldrb	r3, [fp, #8]
  131fd8:	e58d3004 	str	r3, [sp, #4]
  131fdc:	e5db3004 	ldrb	r3, [fp, #4]
  131fe0:	e58d3000 	str	r3, [sp]
  131fe4:	e1a03002 	mov	r3, r2
  131fe8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  131fec:	e51b1008 	ldr	r1, [fp, #-8]
  131ff0:	e51b0010 	ldr	r0, [fp, #-16]
  131ff4:	eb00001e 	bl	132074 <ip4_output_if_opt_src>
  131ff8:	e1a03000 	mov	r3, r0
    ip_options, optlen);
#else /* IP_OPTIONS_SEND */
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
#endif /* IP_OPTIONS_SEND */
}
  131ffc:	e1a00003 	mov	r0, r3
  132000:	e24bd004 	sub	sp, fp, #4
  132004:	e8bd8800 	pop	{fp, pc}

00132008 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  132008:	e92d4800 	push	{fp, lr}
  13200c:	e28db004 	add	fp, sp, #4
  132010:	e24dd028 	sub	sp, sp, #40	; 0x28
  132014:	e50b0008 	str	r0, [fp, #-8]
  132018:	e50b100c 	str	r1, [fp, #-12]
  13201c:	e50b2010 	str	r2, [fp, #-16]
  132020:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
#if IP_OPTIONS_SEND
  return ip4_output_if_opt_src(p, src, dest, ttl, tos, proto, netif, NULL, 0);
  132024:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  132028:	e3a03000 	mov	r3, #0
  13202c:	e58d3010 	str	r3, [sp, #16]
  132030:	e3a03000 	mov	r3, #0
  132034:	e58d300c 	str	r3, [sp, #12]
  132038:	e59b300c 	ldr	r3, [fp, #12]
  13203c:	e58d3008 	str	r3, [sp, #8]
  132040:	e5db3008 	ldrb	r3, [fp, #8]
  132044:	e58d3004 	str	r3, [sp, #4]
  132048:	e5db3004 	ldrb	r3, [fp, #4]
  13204c:	e58d3000 	str	r3, [sp]
  132050:	e1a03002 	mov	r3, r2
  132054:	e51b2010 	ldr	r2, [fp, #-16]
  132058:	e51b100c 	ldr	r1, [fp, #-12]
  13205c:	e51b0008 	ldr	r0, [fp, #-8]
  132060:	eb000003 	bl	132074 <ip4_output_if_opt_src>
  132064:	e1a03000 	mov	r3, r0
}
  132068:	e1a00003 	mov	r0, r3
  13206c:	e24bd004 	sub	sp, fp, #4
  132070:	e8bd8800 	pop	{fp, pc}

00132074 <ip4_output_if_opt_src>:
 */
err_t
ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
       u16_t optlen)
{
  132074:	e92d4800 	push	{fp, lr}
  132078:	e28db004 	add	fp, sp, #4
  13207c:	e24dd028 	sub	sp, sp, #40	; 0x28
  132080:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  132084:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  132088:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
  13208c:	e54b3029 	strb	r3, [fp, #-41]	; 0xffffffd7
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
  132090:	e3a03000 	mov	r3, #0
  132094:	e50b3008 	str	r3, [fp, #-8]
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
  132098:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  13209c:	e1d330be 	ldrh	r3, [r3, #14]
  1320a0:	e3530001 	cmp	r3, #1
  1320a4:	0a000006 	beq	1320c4 <ip4_output_if_opt_src+0x50>
  1320a8:	e3090ab8 	movw	r0, #39608	; 0x9ab8
  1320ac:	e3400014 	movt	r0, #20
  1320b0:	ebff4417 	bl	103114 <rt_kprintf>
  1320b4:	e3001333 	movw	r1, #819	; 0x333
  1320b8:	e3090ac4 	movw	r0, #39620	; 0x9ac4
  1320bc:	e3400014 	movt	r0, #20
  1320c0:	ebff63ed 	bl	10b07c <sys_arch_assert>

  MIB2_STATS_INC(mib2.ipoutrequests);
  1320c4:	e3063840 	movw	r3, #26688	; 0x6840
  1320c8:	e3403057 	movt	r3, #87	; 0x57
  1320cc:	e5933140 	ldr	r3, [r3, #320]	; 0x140
  1320d0:	e2832001 	add	r2, r3, #1
  1320d4:	e3063840 	movw	r3, #26688	; 0x6840
  1320d8:	e3403057 	movt	r3, #87	; 0x57
  1320dc:	e5832140 	str	r2, [r3, #320]	; 0x140

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
  1320e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1320e4:	e3530000 	cmp	r3, #0
  1320e8:	0a000112 	beq	132538 <ip4_output_if_opt_src+0x4c4>
    u16_t ip_hlen = IP_HLEN;
  1320ec:	e3a03014 	mov	r3, #20
  1320f0:	e14b30ba 	strh	r3, [fp, #-10]
#if IP_OPTIONS_SEND
    u16_t optlen_aligned = 0;
  1320f4:	e3a03000 	mov	r3, #0
  1320f8:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
    if (optlen != 0) {
  1320fc:	e1db31b4 	ldrh	r3, [fp, #20]
  132100:	e3530000 	cmp	r3, #0
  132104:	0a00004b 	beq	132238 <ip4_output_if_opt_src+0x1c4>
#if CHECKSUM_GEN_IP_INLINE
      int i;
#endif /* CHECKSUM_GEN_IP_INLINE */
      /* round up to a multiple of 4 */
      optlen_aligned = ((optlen + 3) & ~3);
  132108:	e1db31b4 	ldrh	r3, [fp, #20]
  13210c:	e2833003 	add	r3, r3, #3
  132110:	e6ff3073 	uxth	r3, r3
  132114:	e3c33003 	bic	r3, r3, #3
  132118:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
      ip_hlen += optlen_aligned;
  13211c:	e15b20ba 	ldrh	r2, [fp, #-10]
  132120:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  132124:	e0823003 	add	r3, r2, r3
  132128:	e14b30ba 	strh	r3, [fp, #-10]
      /* First write in the IP options */
      if (pbuf_header(p, optlen_aligned)) {
  13212c:	e15b31f6 	ldrsh	r3, [fp, #-22]	; 0xffffffea
  132130:	e1a01003 	mov	r1, r3
  132134:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  132138:	ebffa3bf 	bl	11b03c <pbuf_header>
  13213c:	e1a03000 	mov	r3, r0
  132140:	e3530000 	cmp	r3, #0
  132144:	0a000010 	beq	13218c <ip4_output_if_opt_src+0x118>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: not enough room for IP options in pbuf\n"));
        IP_STATS_INC(ip.err);
  132148:	e3063840 	movw	r3, #26688	; 0x6840
  13214c:	e3403057 	movt	r3, #87	; 0x57
  132150:	e1d335bc 	ldrh	r3, [r3, #92]	; 0x5c
  132154:	e2833001 	add	r3, r3, #1
  132158:	e6ff2073 	uxth	r2, r3
  13215c:	e3063840 	movw	r3, #26688	; 0x6840
  132160:	e3403057 	movt	r3, #87	; 0x57
  132164:	e1c325bc 	strh	r2, [r3, #92]	; 0x5c
        MIB2_STATS_INC(mib2.ipoutdiscards);
  132168:	e3063840 	movw	r3, #26688	; 0x6840
  13216c:	e3403057 	movt	r3, #87	; 0x57
  132170:	e5933144 	ldr	r3, [r3, #324]	; 0x144
  132174:	e2832001 	add	r2, r3, #1
  132178:	e3063840 	movw	r3, #26688	; 0x6840
  13217c:	e3403057 	movt	r3, #87	; 0x57
  132180:	e5832144 	str	r2, [r3, #324]	; 0x144
        return ERR_BUF;
  132184:	e3e03001 	mvn	r3, #1
  132188:	ea00012a 	b	132638 <ip4_output_if_opt_src+0x5c4>
      }
      MEMCPY(p->payload, ip_options, optlen);
  13218c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  132190:	e5933004 	ldr	r3, [r3, #4]
  132194:	e1db21b4 	ldrh	r2, [fp, #20]
  132198:	e59b1010 	ldr	r1, [fp, #16]
  13219c:	e1a00003 	mov	r0, r3
  1321a0:	eb003b7b 	bl	140f94 <memcpy>
      if (optlen < optlen_aligned) {
  1321a4:	e1db21b4 	ldrh	r2, [fp, #20]
  1321a8:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  1321ac:	e1520003 	cmp	r2, r3
  1321b0:	2a000009 	bcs	1321dc <ip4_output_if_opt_src+0x168>
        /* zero the remaining bytes */
        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
  1321b4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1321b8:	e5932004 	ldr	r2, [r3, #4]
  1321bc:	e1db31b4 	ldrh	r3, [fp, #20]
  1321c0:	e0820003 	add	r0, r2, r3
  1321c4:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  1321c8:	e1db31b4 	ldrh	r3, [fp, #20]
  1321cc:	e0423003 	sub	r3, r2, r3
  1321d0:	e1a02003 	mov	r2, r3
  1321d4:	e3a01000 	mov	r1, #0
  1321d8:	eb003ca5 	bl	141474 <memset>
      }
#if CHECKSUM_GEN_IP_INLINE
      for (i = 0; i < optlen_aligned/2; i++) {
  1321dc:	e3a03000 	mov	r3, #0
  1321e0:	e50b3010 	str	r3, [fp, #-16]
  1321e4:	ea00000c 	b	13221c <ip4_output_if_opt_src+0x1a8>
        chk_sum += ((u16_t*)p->payload)[i];
  1321e8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1321ec:	e5932004 	ldr	r2, [r3, #4]
  1321f0:	e51b3010 	ldr	r3, [fp, #-16]
  1321f4:	e1a03083 	lsl	r3, r3, #1
  1321f8:	e0823003 	add	r3, r2, r3
  1321fc:	e1d330b0 	ldrh	r3, [r3]
  132200:	e1a02003 	mov	r2, r3
  132204:	e51b3008 	ldr	r3, [fp, #-8]
  132208:	e0833002 	add	r3, r3, r2
  13220c:	e50b3008 	str	r3, [fp, #-8]
      for (i = 0; i < optlen_aligned/2; i++) {
  132210:	e51b3010 	ldr	r3, [fp, #-16]
  132214:	e2833001 	add	r3, r3, #1
  132218:	e50b3010 	str	r3, [fp, #-16]
  13221c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
  132220:	e1a030a3 	lsr	r3, r3, #1
  132224:	e6ff3073 	uxth	r3, r3
  132228:	e1a02003 	mov	r2, r3
  13222c:	e51b3010 	ldr	r3, [fp, #-16]
  132230:	e1530002 	cmp	r3, r2
  132234:	baffffeb 	blt	1321e8 <ip4_output_if_opt_src+0x174>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  132238:	e3a01014 	mov	r1, #20
  13223c:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  132240:	ebffa37d 	bl	11b03c <pbuf_header>
  132244:	e1a03000 	mov	r3, r0
  132248:	e3530000 	cmp	r3, #0
  13224c:	0a000010 	beq	132294 <ip4_output_if_opt_src+0x220>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
  132250:	e3063840 	movw	r3, #26688	; 0x6840
  132254:	e3403057 	movt	r3, #87	; 0x57
  132258:	e1d335bc 	ldrh	r3, [r3, #92]	; 0x5c
  13225c:	e2833001 	add	r3, r3, #1
  132260:	e6ff2073 	uxth	r2, r3
  132264:	e3063840 	movw	r3, #26688	; 0x6840
  132268:	e3403057 	movt	r3, #87	; 0x57
  13226c:	e1c325bc 	strh	r2, [r3, #92]	; 0x5c
      MIB2_STATS_INC(mib2.ipoutdiscards);
  132270:	e3063840 	movw	r3, #26688	; 0x6840
  132274:	e3403057 	movt	r3, #87	; 0x57
  132278:	e5933144 	ldr	r3, [r3, #324]	; 0x144
  13227c:	e2832001 	add	r2, r3, #1
  132280:	e3063840 	movw	r3, #26688	; 0x6840
  132284:	e3403057 	movt	r3, #87	; 0x57
  132288:	e5832144 	str	r2, [r3, #324]	; 0x144
      return ERR_BUF;
  13228c:	e3e03001 	mvn	r3, #1
  132290:	ea0000e8 	b	132638 <ip4_output_if_opt_src+0x5c4>
    }

    iphdr = (struct ip_hdr *)p->payload;
  132294:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  132298:	e5933004 	ldr	r3, [r3, #4]
  13229c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  1322a0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1322a4:	e1d330ba 	ldrh	r3, [r3, #10]
  1322a8:	e3530013 	cmp	r3, #19
  1322ac:	8a000006 	bhi	1322cc <ip4_output_if_opt_src+0x258>
  1322b0:	e3090af4 	movw	r0, #39668	; 0x9af4
  1322b4:	e3400014 	movt	r0, #20
  1322b8:	ebff4395 	bl	103114 <rt_kprintf>
  1322bc:	e3001361 	movw	r1, #865	; 0x361
  1322c0:	e3090ac4 	movw	r0, #39620	; 0x9ac4
  1322c4:	e3400014 	movt	r0, #20
  1322c8:	ebff636b 	bl	10b07c <sys_arch_assert>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  1322cc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1322d0:	e55b2029 	ldrb	r2, [fp, #-41]	; 0xffffffd7
  1322d4:	e5c32008 	strb	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
  1322d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1322dc:	e5db2008 	ldrb	r2, [fp, #8]
  1322e0:	e5c32009 	strb	r2, [r3, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
  1322e4:	e5db2008 	ldrb	r2, [fp, #8]
  1322e8:	e55b3029 	ldrb	r3, [fp, #-41]	; 0xffffffd7
  1322ec:	e1a03403 	lsl	r3, r3, #8
  1322f0:	e1823003 	orr	r3, r2, r3
  1322f4:	e1a03403 	lsl	r3, r3, #8
  1322f8:	e6ff2073 	uxth	r2, r3
  1322fc:	e5db1008 	ldrb	r1, [fp, #8]
  132300:	e55b3029 	ldrb	r3, [fp, #-41]	; 0xffffffd7
  132304:	e1a03403 	lsl	r3, r3, #8
  132308:	e1813003 	orr	r3, r1, r3
  13230c:	e1a03423 	lsr	r3, r3, #8
  132310:	e6ef3073 	uxtb	r3, r3
  132314:	e1823003 	orr	r3, r2, r3
  132318:	e51b2008 	ldr	r2, [fp, #-8]
  13231c:	e0823003 	add	r3, r2, r3
  132320:	e50b3008 	str	r3, [fp, #-8]
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
  132324:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132328:	e5932000 	ldr	r2, [r3]
  13232c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132330:	e5832010 	str	r2, [r3, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
  132334:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132338:	e5933010 	ldr	r3, [r3, #16]
  13233c:	e6ff3073 	uxth	r3, r3
  132340:	e51b2008 	ldr	r2, [fp, #-8]
  132344:	e0823003 	add	r3, r2, r3
  132348:	e50b3008 	str	r3, [fp, #-8]
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
  13234c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132350:	e5933010 	ldr	r3, [r3, #16]
  132354:	e1a03823 	lsr	r3, r3, #16
  132358:	e51b2008 	ldr	r2, [fp, #-8]
  13235c:	e0823003 	add	r3, r2, r3
  132360:	e50b3008 	str	r3, [fp, #-8]
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
  132364:	e15b30ba 	ldrh	r3, [fp, #-10]
  132368:	e1a03123 	lsr	r3, r3, #2
  13236c:	e6ff3073 	uxth	r3, r3
  132370:	e6ef3073 	uxtb	r3, r3
  132374:	e3833040 	orr	r3, r3, #64	; 0x40
  132378:	e6ef2073 	uxtb	r2, r3
  13237c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132380:	e5c32000 	strb	r2, [r3]
    IPH_TOS_SET(iphdr, tos);
  132384:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132388:	e5db2004 	ldrb	r2, [fp, #4]
  13238c:	e5c32001 	strb	r2, [r3, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
  132390:	e5db2004 	ldrb	r2, [fp, #4]
  132394:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132398:	e5d33000 	ldrb	r3, [r3]
  13239c:	e1a03403 	lsl	r3, r3, #8
  1323a0:	e1823003 	orr	r3, r2, r3
  1323a4:	e1a03403 	lsl	r3, r3, #8
  1323a8:	e6ff2073 	uxth	r2, r3
  1323ac:	e5db1004 	ldrb	r1, [fp, #4]
  1323b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1323b4:	e5d33000 	ldrb	r3, [r3]
  1323b8:	e1a03403 	lsl	r3, r3, #8
  1323bc:	e1813003 	orr	r3, r1, r3
  1323c0:	e1a03423 	lsr	r3, r3, #8
  1323c4:	e6ef3073 	uxtb	r3, r3
  1323c8:	e1823003 	orr	r3, r2, r3
  1323cc:	e51b2008 	ldr	r2, [fp, #-8]
  1323d0:	e0823003 	add	r3, r2, r3
  1323d4:	e50b3008 	str	r3, [fp, #-8]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
  1323d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1323dc:	e1d330b8 	ldrh	r3, [r3, #8]
  1323e0:	e1a00003 	mov	r0, r3
  1323e4:	ebff90fb 	bl	1167d8 <lwip_htons>
  1323e8:	e1a03000 	mov	r3, r0
  1323ec:	e1a02003 	mov	r2, r3
  1323f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1323f4:	e1c320b2 	strh	r2, [r3, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
  1323f8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1323fc:	e1d330b2 	ldrh	r3, [r3, #2]
  132400:	e6ff3073 	uxth	r3, r3
  132404:	e1a02003 	mov	r2, r3
  132408:	e51b3008 	ldr	r3, [fp, #-8]
  13240c:	e0833002 	add	r3, r3, r2
  132410:	e50b3008 	str	r3, [fp, #-8]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
  132414:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132418:	e3a02000 	mov	r2, #0
  13241c:	e5c32006 	strb	r2, [r3, #6]
  132420:	e3a02000 	mov	r2, #0
  132424:	e5c32007 	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
  132428:	e30f3bd0 	movw	r3, #64464	; 0xfbd0
  13242c:	e3403014 	movt	r3, #20
  132430:	e1d330b0 	ldrh	r3, [r3]
  132434:	e1a00003 	mov	r0, r3
  132438:	ebff90e6 	bl	1167d8 <lwip_htons>
  13243c:	e1a03000 	mov	r3, r0
  132440:	e1a02003 	mov	r2, r3
  132444:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132448:	e1c320b4 	strh	r2, [r3, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
  13244c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132450:	e1d330b4 	ldrh	r3, [r3, #4]
  132454:	e6ff3073 	uxth	r3, r3
  132458:	e1a02003 	mov	r2, r3
  13245c:	e51b3008 	ldr	r3, [fp, #-8]
  132460:	e0833002 	add	r3, r3, r2
  132464:	e50b3008 	str	r3, [fp, #-8]
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
  132468:	e30f3bd0 	movw	r3, #64464	; 0xfbd0
  13246c:	e3403014 	movt	r3, #20
  132470:	e1d330b0 	ldrh	r3, [r3]
  132474:	e2833001 	add	r3, r3, #1
  132478:	e6ff2073 	uxth	r2, r3
  13247c:	e30f3bd0 	movw	r3, #64464	; 0xfbd0
  132480:	e3403014 	movt	r3, #20
  132484:	e1c320b0 	strh	r2, [r3]

    if (src == NULL) {
  132488:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  13248c:	e3530000 	cmp	r3, #0
  132490:	1a000005 	bne	1324ac <ip4_output_if_opt_src+0x438>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
  132494:	e3093b24 	movw	r3, #39716	; 0x9b24
  132498:	e3403014 	movt	r3, #20
  13249c:	e5932000 	ldr	r2, [r3]
  1324a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1324a4:	e583200c 	str	r2, [r3, #12]
  1324a8:	ea000003 	b	1324bc <ip4_output_if_opt_src+0x448>
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
  1324ac:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1324b0:	e5932000 	ldr	r2, [r3]
  1324b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1324b8:	e583200c 	str	r2, [r3, #12]
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
  1324bc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1324c0:	e593300c 	ldr	r3, [r3, #12]
  1324c4:	e6ff3073 	uxth	r3, r3
  1324c8:	e51b2008 	ldr	r2, [fp, #-8]
  1324cc:	e0823003 	add	r3, r2, r3
  1324d0:	e50b3008 	str	r3, [fp, #-8]
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
  1324d4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1324d8:	e593300c 	ldr	r3, [r3, #12]
  1324dc:	e1a03823 	lsr	r3, r3, #16
  1324e0:	e51b2008 	ldr	r2, [fp, #-8]
  1324e4:	e0823003 	add	r3, r2, r3
  1324e8:	e50b3008 	str	r3, [fp, #-8]
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
  1324ec:	e51b3008 	ldr	r3, [fp, #-8]
  1324f0:	e1a02823 	lsr	r2, r3, #16
  1324f4:	e51b3008 	ldr	r3, [fp, #-8]
  1324f8:	e6ff3073 	uxth	r3, r3
  1324fc:	e0823003 	add	r3, r2, r3
  132500:	e50b3008 	str	r3, [fp, #-8]
    chk_sum = (chk_sum >> 16) + chk_sum;
  132504:	e51b3008 	ldr	r3, [fp, #-8]
  132508:	e1a03823 	lsr	r3, r3, #16
  13250c:	e51b2008 	ldr	r2, [fp, #-8]
  132510:	e0823003 	add	r3, r2, r3
  132514:	e50b3008 	str	r3, [fp, #-8]
    chk_sum = ~chk_sum;
  132518:	e51b3008 	ldr	r3, [fp, #-8]
  13251c:	e1e03003 	mvn	r3, r3
  132520:	e50b3008 	str	r3, [fp, #-8]
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      iphdr->_chksum = (u16_t)chk_sum; /* network order */
  132524:	e51b3008 	ldr	r3, [fp, #-8]
  132528:	e6ff2073 	uxth	r2, r3
  13252c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132530:	e1c320ba 	strh	r2, [r3, #10]
  132534:	ea000007 	b	132558 <ip4_output_if_opt_src+0x4e4>
    }
#endif /* CHECKSUM_GEN_IP */
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
  132538:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  13253c:	e5933004 	ldr	r3, [r3, #4]
  132540:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    ip4_addr_copy(dest_addr, iphdr->dest);
  132544:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132548:	e5933010 	ldr	r3, [r3, #16]
  13254c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    dest = &dest_addr;
  132550:	e24b301c 	sub	r3, fp, #28
  132554:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  }

  IP_STATS_INC(ip.xmit);
  132558:	e3063840 	movw	r3, #26688	; 0x6840
  13255c:	e3403057 	movt	r3, #87	; 0x57
  132560:	e1d334b8 	ldrh	r3, [r3, #72]	; 0x48
  132564:	e2833001 	add	r3, r3, #1
  132568:	e6ff2073 	uxth	r2, r3
  13256c:	e3063840 	movw	r3, #26688	; 0x6840
  132570:	e3403057 	movt	r3, #87	; 0x57
  132574:	e1c324b8 	strh	r2, [r3, #72]	; 0x48

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], (u16_t)netif->num));
  ip4_debug_print(p);

#if ENABLE_LOOPBACK
  if (ip4_addr_cmp(dest, netif_ip4_addr(netif))
  132578:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13257c:	e5932000 	ldr	r2, [r3]
  132580:	e59b300c 	ldr	r3, [fp, #12]
  132584:	e2833004 	add	r3, r3, #4
  132588:	e5933000 	ldr	r3, [r3]
  13258c:	e1520003 	cmp	r2, r3
  132590:	0a000004 	beq	1325a8 <ip4_output_if_opt_src+0x534>
#if !LWIP_HAVE_LOOPIF
      || ip4_addr_isloopback(dest)
  132594:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132598:	e5933000 	ldr	r3, [r3]
  13259c:	e6ef3073 	uxtb	r3, r3
  1325a0:	e353007f 	cmp	r3, #127	; 0x7f
  1325a4:	1a000004 	bne	1325bc <ip4_output_if_opt_src+0x548>
#endif /* !LWIP_HAVE_LOOPIF */
      ) {
    /* Packet to self, enqueue it for loopback */
    LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
    return netif_loop_output(netif, p);
  1325a8:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  1325ac:	e59b000c 	ldr	r0, [fp, #12]
  1325b0:	ebff9e77 	bl	119f94 <netif_loop_output>
  1325b4:	e1a03000 	mov	r3, r0
  1325b8:	ea00001e 	b	132638 <ip4_output_if_opt_src+0x5c4>
  }
#if LWIP_MULTICAST_TX_OPTIONS
  if ((p->flags & PBUF_FLAG_MCASTLOOP) != 0) {
  1325bc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1325c0:	e5d3300d 	ldrb	r3, [r3, #13]
  1325c4:	e2033004 	and	r3, r3, #4
  1325c8:	e3530000 	cmp	r3, #0
  1325cc:	0a000002 	beq	1325dc <ip4_output_if_opt_src+0x568>
    netif_loop_output(netif, p);
  1325d0:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  1325d4:	e59b000c 	ldr	r0, [fp, #12]
  1325d8:	ebff9e6d 	bl	119f94 <netif_loop_output>
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
  1325dc:	e59b300c 	ldr	r3, [fp, #12]
  1325e0:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  1325e4:	e3530000 	cmp	r3, #0
  1325e8:	0a00000b 	beq	13261c <ip4_output_if_opt_src+0x5a8>
  1325ec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1325f0:	e1d320b8 	ldrh	r2, [r3, #8]
  1325f4:	e59b300c 	ldr	r3, [fp, #12]
  1325f8:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  1325fc:	e1520003 	cmp	r2, r3
  132600:	9a000005 	bls	13261c <ip4_output_if_opt_src+0x5a8>
    return ip4_frag(p, netif, dest);
  132604:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  132608:	e59b100c 	ldr	r1, [fp, #12]
  13260c:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  132610:	eb00068e 	bl	134050 <ip4_frag>
  132614:	e1a03000 	mov	r3, r0
  132618:	ea000006 	b	132638 <ip4_output_if_opt_src+0x5c4>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
  13261c:	e59b300c 	ldr	r3, [fp, #12]
  132620:	e5933014 	ldr	r3, [r3, #20]
  132624:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  132628:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  13262c:	e59b000c 	ldr	r0, [fp, #12]
  132630:	e12fff33 	blx	r3
  132634:	e1a03000 	mov	r3, r0
}
  132638:	e1a00003 	mov	r0, r3
  13263c:	e24bd004 	sub	sp, fp, #4
  132640:	e8bd8800 	pop	{fp, pc}

00132644 <ip4_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  132644:	e92d4800 	push	{fp, lr}
  132648:	e28db004 	add	fp, sp, #4
  13264c:	e24dd028 	sub	sp, sp, #40	; 0x28
  132650:	e50b0010 	str	r0, [fp, #-16]
  132654:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  132658:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  13265c:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
  struct netif *netif;

  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
  132660:	e51b3010 	ldr	r3, [fp, #-16]
  132664:	e1d330be 	ldrh	r3, [r3, #14]
  132668:	e3530001 	cmp	r3, #1
  13266c:	0a000006 	beq	13268c <ip4_output+0x48>
  132670:	e3090ab8 	movw	r0, #39608	; 0x9ab8
  132674:	e3400014 	movt	r0, #20
  132678:	ebff42a5 	bl	103114 <rt_kprintf>
  13267c:	e30013db 	movw	r1, #987	; 0x3db
  132680:	e3090ac4 	movw	r0, #39620	; 0x9ac4
  132684:	e3400014 	movt	r0, #20
  132688:	ebff627b 	bl	10b07c <sys_arch_assert>

  if ((netif = ip4_route_src(dest, src)) == NULL) {
  13268c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  132690:	ebfffb3e 	bl	131390 <ip4_route>
  132694:	e50b0008 	str	r0, [fp, #-8]
  132698:	e51b3008 	ldr	r3, [fp, #-8]
  13269c:	e3530000 	cmp	r3, #0
  1326a0:	1a000009 	bne	1326cc <ip4_output+0x88>
    LWIP_DEBUGF(IP_DEBUG, ("ip4_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
  1326a4:	e3063840 	movw	r3, #26688	; 0x6840
  1326a8:	e3403057 	movt	r3, #87	; 0x57
  1326ac:	e1d335b6 	ldrh	r3, [r3, #86]	; 0x56
  1326b0:	e2833001 	add	r3, r3, #1
  1326b4:	e6ff2073 	uxth	r2, r3
  1326b8:	e3063840 	movw	r3, #26688	; 0x6840
  1326bc:	e3403057 	movt	r3, #87	; 0x57
  1326c0:	e1c325b6 	strh	r2, [r3, #86]	; 0x56
    return ERR_RTE;
  1326c4:	e3e03003 	mvn	r3, #3
  1326c8:	ea00000c 	b	132700 <ip4_output+0xbc>
  }

  return ip4_output_if(p, src, dest, ttl, tos, proto, netif);
  1326cc:	e55b2019 	ldrb	r2, [fp, #-25]	; 0xffffffe7
  1326d0:	e51b3008 	ldr	r3, [fp, #-8]
  1326d4:	e58d3008 	str	r3, [sp, #8]
  1326d8:	e5db3008 	ldrb	r3, [fp, #8]
  1326dc:	e58d3004 	str	r3, [sp, #4]
  1326e0:	e5db3004 	ldrb	r3, [fp, #4]
  1326e4:	e58d3000 	str	r3, [sp]
  1326e8:	e1a03002 	mov	r3, r2
  1326ec:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1326f0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1326f4:	e51b0010 	ldr	r0, [fp, #-16]
  1326f8:	ebfffdfd 	bl	131ef4 <ip4_output_if>
  1326fc:	e1a03000 	mov	r3, r0
}
  132700:	e1a00003 	mov	r0, r3
  132704:	e24bd004 	sub	sp, fp, #4
  132708:	e8bd8800 	pop	{fp, pc}

0013270c <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
  13270c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  132710:	e28db000 	add	fp, sp, #0
  132714:	e24dd014 	sub	sp, sp, #20
  132718:	e50b0010 	str	r0, [fp, #-16]
  13271c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
  132720:	e51b3010 	ldr	r3, [fp, #-16]
  132724:	e50b3008 	str	r3, [fp, #-8]

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
  132728:	e51b3010 	ldr	r3, [fp, #-16]
  13272c:	e3730001 	cmn	r3, #1
  132730:	0a000002 	beq	132740 <ip4_addr_isbroadcast_u32+0x34>
  132734:	e51b3010 	ldr	r3, [fp, #-16]
  132738:	e3530000 	cmp	r3, #0
  13273c:	1a000001 	bne	132748 <ip4_addr_isbroadcast_u32+0x3c>
      (addr == IPADDR_ANY)) {
    return 1;
  132740:	e3a03001 	mov	r3, #1
  132744:	ea000028 	b	1327ec <ip4_addr_isbroadcast_u32+0xe0>
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
  132748:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13274c:	e5d33041 	ldrb	r3, [r3, #65]	; 0x41
  132750:	e2033002 	and	r3, r3, #2
  132754:	e3530000 	cmp	r3, #0
  132758:	1a000001 	bne	132764 <ip4_addr_isbroadcast_u32+0x58>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  13275c:	e3a03000 	mov	r3, #0
  132760:	ea000021 	b	1327ec <ip4_addr_isbroadcast_u32+0xe0>
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
  132764:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132768:	e2833004 	add	r3, r3, #4
  13276c:	e5933000 	ldr	r3, [r3]
  132770:	e51b2010 	ldr	r2, [fp, #-16]
  132774:	e1520003 	cmp	r2, r3
  132778:	1a000001 	bne	132784 <ip4_addr_isbroadcast_u32+0x78>
    return 0;
  13277c:	e3a03000 	mov	r3, #0
  132780:	ea000019 	b	1327ec <ip4_addr_isbroadcast_u32+0xe0>
  /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
  132784:	e51b2008 	ldr	r2, [fp, #-8]
  132788:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13278c:	e2833004 	add	r3, r3, #4
  132790:	e5933000 	ldr	r3, [r3]
  132794:	e0222003 	eor	r2, r2, r3
  132798:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13279c:	e2833008 	add	r3, r3, #8
  1327a0:	e5933000 	ldr	r3, [r3]
  1327a4:	e0033002 	and	r3, r3, r2
  1327a8:	e3530000 	cmp	r3, #0
  1327ac:	1a00000d 	bne	1327e8 <ip4_addr_isbroadcast_u32+0xdc>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
  1327b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1327b4:	e2833008 	add	r3, r3, #8
  1327b8:	e5933000 	ldr	r3, [r3]
  1327bc:	e1e02003 	mvn	r2, r3
  1327c0:	e51b3010 	ldr	r3, [fp, #-16]
  1327c4:	e0022003 	and	r2, r2, r3
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
  1327c8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1327cc:	e2833008 	add	r3, r3, #8
  1327d0:	e5933000 	ldr	r3, [r3]
  1327d4:	e1e03003 	mvn	r3, r3
          && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
  1327d8:	e1520003 	cmp	r2, r3
  1327dc:	1a000001 	bne	1327e8 <ip4_addr_isbroadcast_u32+0xdc>
    /* => network broadcast address */
    return 1;
  1327e0:	e3a03001 	mov	r3, #1
  1327e4:	ea000000 	b	1327ec <ip4_addr_isbroadcast_u32+0xe0>
  } else {
    return 0;
  1327e8:	e3a03000 	mov	r3, #0
  }
}
  1327ec:	e1a00003 	mov	r0, r3
  1327f0:	e28bd000 	add	sp, fp, #0
  1327f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1327f8:	e12fff1e 	bx	lr

001327fc <ip4_addr_netmask_valid>:
 * @param netmask the IPv4 netmask to check (in network byte order!)
 * @return 1 if the netmask is valid, 0 if it is not
 */
u8_t
ip4_addr_netmask_valid(u32_t netmask)
{
  1327fc:	e92d4800 	push	{fp, lr}
  132800:	e28db004 	add	fp, sp, #4
  132804:	e24dd010 	sub	sp, sp, #16
  132808:	e50b0010 	str	r0, [fp, #-16]
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);
  13280c:	e51b0010 	ldr	r0, [fp, #-16]
  132810:	ebff8ffc 	bl	116808 <lwip_htonl>
  132814:	e50b000c 	str	r0, [fp, #-12]

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
  132818:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  13281c:	e50b3008 	str	r3, [fp, #-8]
  132820:	ea000007 	b	132844 <ip4_addr_netmask_valid+0x48>
    if ((nm_hostorder & mask) == 0) {
  132824:	e51b200c 	ldr	r2, [fp, #-12]
  132828:	e51b3008 	ldr	r3, [fp, #-8]
  13282c:	e0033002 	and	r3, r3, r2
  132830:	e3530000 	cmp	r3, #0
  132834:	0a000006 	beq	132854 <ip4_addr_netmask_valid+0x58>
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
  132838:	e51b3008 	ldr	r3, [fp, #-8]
  13283c:	e1a030a3 	lsr	r3, r3, #1
  132840:	e50b3008 	str	r3, [fp, #-8]
  132844:	e51b3008 	ldr	r3, [fp, #-8]
  132848:	e3530000 	cmp	r3, #0
  13284c:	1afffff4 	bne	132824 <ip4_addr_netmask_valid+0x28>
  132850:	ea00000b 	b	132884 <ip4_addr_netmask_valid+0x88>
      break;
  132854:	e320f000 	nop	{0}
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
  132858:	ea000009 	b	132884 <ip4_addr_netmask_valid+0x88>
    if ((nm_hostorder & mask) != 0) {
  13285c:	e51b200c 	ldr	r2, [fp, #-12]
  132860:	e51b3008 	ldr	r3, [fp, #-8]
  132864:	e0033002 	and	r3, r3, r2
  132868:	e3530000 	cmp	r3, #0
  13286c:	0a000001 	beq	132878 <ip4_addr_netmask_valid+0x7c>
      /* there is a one after the first zero -> invalid */
      return 0;
  132870:	e3a03000 	mov	r3, #0
  132874:	ea000006 	b	132894 <ip4_addr_netmask_valid+0x98>
  for (; mask != 0; mask >>= 1) {
  132878:	e51b3008 	ldr	r3, [fp, #-8]
  13287c:	e1a030a3 	lsr	r3, r3, #1
  132880:	e50b3008 	str	r3, [fp, #-8]
  132884:	e51b3008 	ldr	r3, [fp, #-8]
  132888:	e3530000 	cmp	r3, #0
  13288c:	1afffff2 	bne	13285c <ip4_addr_netmask_valid+0x60>
    }
  }
  /* no one after the first zero -> valid */
  return 1;
  132890:	e3a03001 	mov	r3, #1
}
  132894:	e1a00003 	mov	r0, r3
  132898:	e24bd004 	sub	sp, fp, #4
  13289c:	e8bd8800 	pop	{fp, pc}

001328a0 <ipaddr_addr>:
 * @param cp IP address in ascii representation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
  1328a0:	e92d4800 	push	{fp, lr}
  1328a4:	e28db004 	add	fp, sp, #4
  1328a8:	e24dd010 	sub	sp, sp, #16
  1328ac:	e50b0010 	str	r0, [fp, #-16]
  ip4_addr_t val;

  if (ip4addr_aton(cp, &val)) {
  1328b0:	e24b3008 	sub	r3, fp, #8
  1328b4:	e1a01003 	mov	r1, r3
  1328b8:	e51b0010 	ldr	r0, [fp, #-16]
  1328bc:	eb000008 	bl	1328e4 <ip4addr_aton>
  1328c0:	e1a03000 	mov	r3, r0
  1328c4:	e3530000 	cmp	r3, #0
  1328c8:	0a000001 	beq	1328d4 <ipaddr_addr+0x34>
    return ip4_addr_get_u32(&val);
  1328cc:	e51b3008 	ldr	r3, [fp, #-8]
  1328d0:	ea000000 	b	1328d8 <ipaddr_addr+0x38>
  }
  return (IPADDR_NONE);
  1328d4:	e3e03000 	mvn	r3, #0
}
  1328d8:	e1a00003 	mov	r0, r3
  1328dc:	e24bd004 	sub	sp, fp, #4
  1328e0:	e8bd8800 	pop	{fp, pc}

001328e4 <ip4addr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
  1328e4:	e92d4800 	push	{fp, lr}
  1328e8:	e28db004 	add	fp, sp, #4
  1328ec:	e24dd028 	sub	sp, sp, #40	; 0x28
  1328f0:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  1328f4:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
  1328f8:	e24b3020 	sub	r3, fp, #32
  1328fc:	e50b3010 	str	r3, [fp, #-16]

  c = *cp;
  132900:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132904:	e5d33000 	ldrb	r3, [r3]
  132908:	e54b300a 	strb	r3, [fp, #-10]
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c)) {
  13290c:	e55b300a 	ldrb	r3, [fp, #-10]
  132910:	e353002f 	cmp	r3, #47	; 0x2f
  132914:	9a000002 	bls	132924 <ip4addr_aton+0x40>
  132918:	e55b300a 	ldrb	r3, [fp, #-10]
  13291c:	e3530039 	cmp	r3, #57	; 0x39
  132920:	9a000001 	bls	13292c <ip4addr_aton+0x48>
      return 0;
  132924:	e3a03000 	mov	r3, #0
  132928:	ea0000ee 	b	132ce8 <ip4addr_aton+0x404>
    }
    val = 0;
  13292c:	e3a03000 	mov	r3, #0
  132930:	e50b3008 	str	r3, [fp, #-8]
    base = 10;
  132934:	e3a0300a 	mov	r3, #10
  132938:	e54b3009 	strb	r3, [fp, #-9]
    if (c == '0') {
  13293c:	e55b300a 	ldrb	r3, [fp, #-10]
  132940:	e3530030 	cmp	r3, #48	; 0x30
  132944:	1a000016 	bne	1329a4 <ip4addr_aton+0xc0>
      c = *++cp;
  132948:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13294c:	e2833001 	add	r3, r3, #1
  132950:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  132954:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132958:	e5d33000 	ldrb	r3, [r3]
  13295c:	e54b300a 	strb	r3, [fp, #-10]
      if (c == 'x' || c == 'X') {
  132960:	e55b300a 	ldrb	r3, [fp, #-10]
  132964:	e3530078 	cmp	r3, #120	; 0x78
  132968:	0a000002 	beq	132978 <ip4addr_aton+0x94>
  13296c:	e55b300a 	ldrb	r3, [fp, #-10]
  132970:	e3530058 	cmp	r3, #88	; 0x58
  132974:	1a000008 	bne	13299c <ip4addr_aton+0xb8>
        base = 16;
  132978:	e3a03010 	mov	r3, #16
  13297c:	e54b3009 	strb	r3, [fp, #-9]
        c = *++cp;
  132980:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132984:	e2833001 	add	r3, r3, #1
  132988:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  13298c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132990:	e5d33000 	ldrb	r3, [r3]
  132994:	e54b300a 	strb	r3, [fp, #-10]
  132998:	ea000001 	b	1329a4 <ip4addr_aton+0xc0>
      } else {
        base = 8;
  13299c:	e3a03008 	mov	r3, #8
  1329a0:	e54b3009 	strb	r3, [fp, #-9]
      }
    }
    for (;;) {
      if (isdigit(c)) {
  1329a4:	e55b300a 	ldrb	r3, [fp, #-10]
  1329a8:	e353002f 	cmp	r3, #47	; 0x2f
  1329ac:	9a000010 	bls	1329f4 <ip4addr_aton+0x110>
  1329b0:	e55b300a 	ldrb	r3, [fp, #-10]
  1329b4:	e3530039 	cmp	r3, #57	; 0x39
  1329b8:	8a00000d 	bhi	1329f4 <ip4addr_aton+0x110>
        val = (val * base) + (u32_t)(c - '0');
  1329bc:	e55b3009 	ldrb	r3, [fp, #-9]
  1329c0:	e51b2008 	ldr	r2, [fp, #-8]
  1329c4:	e0020392 	mul	r2, r2, r3
  1329c8:	e55b300a 	ldrb	r3, [fp, #-10]
  1329cc:	e0823003 	add	r3, r2, r3
  1329d0:	e2433030 	sub	r3, r3, #48	; 0x30
  1329d4:	e50b3008 	str	r3, [fp, #-8]
        c = *++cp;
  1329d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1329dc:	e2833001 	add	r3, r3, #1
  1329e0:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  1329e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1329e8:	e5d33000 	ldrb	r3, [r3]
  1329ec:	e54b300a 	strb	r3, [fp, #-10]
  1329f0:	ea00002a 	b	132aa0 <ip4addr_aton+0x1bc>
      } else if (base == 16 && isxdigit(c)) {
  1329f4:	e55b3009 	ldrb	r3, [fp, #-9]
  1329f8:	e3530010 	cmp	r3, #16
  1329fc:	1a000028 	bne	132aa4 <ip4addr_aton+0x1c0>
  132a00:	e55b300a 	ldrb	r3, [fp, #-10]
  132a04:	e353002f 	cmp	r3, #47	; 0x2f
  132a08:	9a000002 	bls	132a18 <ip4addr_aton+0x134>
  132a0c:	e55b300a 	ldrb	r3, [fp, #-10]
  132a10:	e3530039 	cmp	r3, #57	; 0x39
  132a14:	9a00000b 	bls	132a48 <ip4addr_aton+0x164>
  132a18:	e55b300a 	ldrb	r3, [fp, #-10]
  132a1c:	e3530060 	cmp	r3, #96	; 0x60
  132a20:	9a000002 	bls	132a30 <ip4addr_aton+0x14c>
  132a24:	e55b300a 	ldrb	r3, [fp, #-10]
  132a28:	e3530066 	cmp	r3, #102	; 0x66
  132a2c:	9a000005 	bls	132a48 <ip4addr_aton+0x164>
  132a30:	e55b300a 	ldrb	r3, [fp, #-10]
  132a34:	e3530040 	cmp	r3, #64	; 0x40
  132a38:	9a000019 	bls	132aa4 <ip4addr_aton+0x1c0>
  132a3c:	e55b300a 	ldrb	r3, [fp, #-10]
  132a40:	e3530046 	cmp	r3, #70	; 0x46
  132a44:	8a000016 	bhi	132aa4 <ip4addr_aton+0x1c0>
        val = (val << 4) | (u32_t)(c + 10 - (islower(c) ? 'a' : 'A'));
  132a48:	e51b3008 	ldr	r3, [fp, #-8]
  132a4c:	e1a03203 	lsl	r3, r3, #4
  132a50:	e55b200a 	ldrb	r2, [fp, #-10]
  132a54:	e282100a 	add	r1, r2, #10
  132a58:	e55b200a 	ldrb	r2, [fp, #-10]
  132a5c:	e3520060 	cmp	r2, #96	; 0x60
  132a60:	9a000004 	bls	132a78 <ip4addr_aton+0x194>
  132a64:	e55b200a 	ldrb	r2, [fp, #-10]
  132a68:	e352007a 	cmp	r2, #122	; 0x7a
  132a6c:	8a000001 	bhi	132a78 <ip4addr_aton+0x194>
  132a70:	e3a02061 	mov	r2, #97	; 0x61
  132a74:	ea000000 	b	132a7c <ip4addr_aton+0x198>
  132a78:	e3a02041 	mov	r2, #65	; 0x41
  132a7c:	e0412002 	sub	r2, r1, r2
  132a80:	e1833002 	orr	r3, r3, r2
  132a84:	e50b3008 	str	r3, [fp, #-8]
        c = *++cp;
  132a88:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132a8c:	e2833001 	add	r3, r3, #1
  132a90:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  132a94:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132a98:	e5d33000 	ldrb	r3, [r3]
  132a9c:	e54b300a 	strb	r3, [fp, #-10]
      if (isdigit(c)) {
  132aa0:	eaffffbf 	b	1329a4 <ip4addr_aton+0xc0>
      } else {
        break;
      }
    }
    if (c == '.') {
  132aa4:	e55b300a 	ldrb	r3, [fp, #-10]
  132aa8:	e353002e 	cmp	r3, #46	; 0x2e
  132aac:	1a000012 	bne	132afc <ip4addr_aton+0x218>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
  132ab0:	e24b3020 	sub	r3, fp, #32
  132ab4:	e283300c 	add	r3, r3, #12
  132ab8:	e51b2010 	ldr	r2, [fp, #-16]
  132abc:	e1520003 	cmp	r2, r3
  132ac0:	3a000001 	bcc	132acc <ip4addr_aton+0x1e8>
        return 0;
  132ac4:	e3a03000 	mov	r3, #0
  132ac8:	ea000086 	b	132ce8 <ip4addr_aton+0x404>
      }
      *pp++ = val;
  132acc:	e51b3010 	ldr	r3, [fp, #-16]
  132ad0:	e2832004 	add	r2, r3, #4
  132ad4:	e50b2010 	str	r2, [fp, #-16]
  132ad8:	e51b2008 	ldr	r2, [fp, #-8]
  132adc:	e5832000 	str	r2, [r3]
      c = *++cp;
  132ae0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132ae4:	e2833001 	add	r3, r3, #1
  132ae8:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
  132aec:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132af0:	e5d33000 	ldrb	r3, [r3]
  132af4:	e54b300a 	strb	r3, [fp, #-10]
    if (!isdigit(c)) {
  132af8:	eaffff83 	b	13290c <ip4addr_aton+0x28>
    } else {
      break;
  132afc:	e320f000 	nop	{0}
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
  132b00:	e55b300a 	ldrb	r3, [fp, #-10]
  132b04:	e3530000 	cmp	r3, #0
  132b08:	0a000013 	beq	132b5c <ip4addr_aton+0x278>
  132b0c:	e55b300a 	ldrb	r3, [fp, #-10]
  132b10:	e3530020 	cmp	r3, #32
  132b14:	0a000010 	beq	132b5c <ip4addr_aton+0x278>
  132b18:	e55b300a 	ldrb	r3, [fp, #-10]
  132b1c:	e353000c 	cmp	r3, #12
  132b20:	0a00000d 	beq	132b5c <ip4addr_aton+0x278>
  132b24:	e55b300a 	ldrb	r3, [fp, #-10]
  132b28:	e353000a 	cmp	r3, #10
  132b2c:	0a00000a 	beq	132b5c <ip4addr_aton+0x278>
  132b30:	e55b300a 	ldrb	r3, [fp, #-10]
  132b34:	e353000d 	cmp	r3, #13
  132b38:	0a000007 	beq	132b5c <ip4addr_aton+0x278>
  132b3c:	e55b300a 	ldrb	r3, [fp, #-10]
  132b40:	e3530009 	cmp	r3, #9
  132b44:	0a000004 	beq	132b5c <ip4addr_aton+0x278>
  132b48:	e55b300a 	ldrb	r3, [fp, #-10]
  132b4c:	e353000b 	cmp	r3, #11
  132b50:	0a000001 	beq	132b5c <ip4addr_aton+0x278>
    return 0;
  132b54:	e3a03000 	mov	r3, #0
  132b58:	ea000062 	b	132ce8 <ip4addr_aton+0x404>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
  132b5c:	e51b2010 	ldr	r2, [fp, #-16]
  132b60:	e24b3020 	sub	r3, fp, #32
  132b64:	e0423003 	sub	r3, r2, r3
  132b68:	e1a03143 	asr	r3, r3, #2
  132b6c:	e2833001 	add	r3, r3, #1
  132b70:	e3530004 	cmp	r3, #4
  132b74:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  132b78:	ea000048 	b	132ca0 <ip4addr_aton+0x3bc>
  132b7c:	00132b90 	.word	0x00132b90
  132b80:	00132cc0 	.word	0x00132cc0
  132b84:	00132b98 	.word	0x00132b98
  132b88:	00132bd8 	.word	0x00132bd8
  132b8c:	00132c30 	.word	0x00132c30

  case 0:
    return 0;       /* initial nondigit */
  132b90:	e3a03000 	mov	r3, #0
  132b94:	ea000053 	b	132ce8 <ip4addr_aton+0x404>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
  132b98:	e51b3008 	ldr	r3, [fp, #-8]
  132b9c:	e3530401 	cmp	r3, #16777216	; 0x1000000
  132ba0:	3a000001 	bcc	132bac <ip4addr_aton+0x2c8>
      return 0;
  132ba4:	e3a03000 	mov	r3, #0
  132ba8:	ea00004e 	b	132ce8 <ip4addr_aton+0x404>
    }
    if (parts[0] > 0xff) {
  132bac:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  132bb0:	e35300ff 	cmp	r3, #255	; 0xff
  132bb4:	9a000001 	bls	132bc0 <ip4addr_aton+0x2dc>
      return 0;
  132bb8:	e3a03000 	mov	r3, #0
  132bbc:	ea000049 	b	132ce8 <ip4addr_aton+0x404>
    }
    val |= parts[0] << 24;
  132bc0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  132bc4:	e1a03c03 	lsl	r3, r3, #24
  132bc8:	e51b2008 	ldr	r2, [fp, #-8]
  132bcc:	e1823003 	orr	r3, r2, r3
  132bd0:	e50b3008 	str	r3, [fp, #-8]
    break;
  132bd4:	ea00003a 	b	132cc4 <ip4addr_aton+0x3e0>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff) {
  132bd8:	e51b3008 	ldr	r3, [fp, #-8]
  132bdc:	e3530801 	cmp	r3, #65536	; 0x10000
  132be0:	3a000001 	bcc	132bec <ip4addr_aton+0x308>
      return 0;
  132be4:	e3a03000 	mov	r3, #0
  132be8:	ea00003e 	b	132ce8 <ip4addr_aton+0x404>
    }
    if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
  132bec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  132bf0:	e35300ff 	cmp	r3, #255	; 0xff
  132bf4:	8a000002 	bhi	132c04 <ip4addr_aton+0x320>
  132bf8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  132bfc:	e35300ff 	cmp	r3, #255	; 0xff
  132c00:	9a000001 	bls	132c0c <ip4addr_aton+0x328>
      return 0;
  132c04:	e3a03000 	mov	r3, #0
  132c08:	ea000036 	b	132ce8 <ip4addr_aton+0x404>
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
  132c0c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  132c10:	e1a02c03 	lsl	r2, r3, #24
  132c14:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  132c18:	e1a03803 	lsl	r3, r3, #16
  132c1c:	e1823003 	orr	r3, r2, r3
  132c20:	e51b2008 	ldr	r2, [fp, #-8]
  132c24:	e1823003 	orr	r3, r2, r3
  132c28:	e50b3008 	str	r3, [fp, #-8]
    break;
  132c2c:	ea000024 	b	132cc4 <ip4addr_aton+0x3e0>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff) {
  132c30:	e51b3008 	ldr	r3, [fp, #-8]
  132c34:	e35300ff 	cmp	r3, #255	; 0xff
  132c38:	9a000001 	bls	132c44 <ip4addr_aton+0x360>
      return 0;
  132c3c:	e3a03000 	mov	r3, #0
  132c40:	ea000028 	b	132ce8 <ip4addr_aton+0x404>
    }
    if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
  132c44:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  132c48:	e35300ff 	cmp	r3, #255	; 0xff
  132c4c:	8a000005 	bhi	132c68 <ip4addr_aton+0x384>
  132c50:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  132c54:	e35300ff 	cmp	r3, #255	; 0xff
  132c58:	8a000002 	bhi	132c68 <ip4addr_aton+0x384>
  132c5c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  132c60:	e35300ff 	cmp	r3, #255	; 0xff
  132c64:	9a000001 	bls	132c70 <ip4addr_aton+0x38c>
      return 0;
  132c68:	e3a03000 	mov	r3, #0
  132c6c:	ea00001d 	b	132ce8 <ip4addr_aton+0x404>
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  132c70:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  132c74:	e1a02c03 	lsl	r2, r3, #24
  132c78:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  132c7c:	e1a03803 	lsl	r3, r3, #16
  132c80:	e1822003 	orr	r2, r2, r3
  132c84:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  132c88:	e1a03403 	lsl	r3, r3, #8
  132c8c:	e1823003 	orr	r3, r2, r3
  132c90:	e51b2008 	ldr	r2, [fp, #-8]
  132c94:	e1823003 	orr	r3, r2, r3
  132c98:	e50b3008 	str	r3, [fp, #-8]
    break;
  132c9c:	ea000008 	b	132cc4 <ip4addr_aton+0x3e0>
  default:
    LWIP_ASSERT("unhandled", 0);
  132ca0:	e3090b2c 	movw	r0, #39724	; 0x9b2c
  132ca4:	e3400014 	movt	r0, #20
  132ca8:	ebff4119 	bl	103114 <rt_kprintf>
  132cac:	e3001103 	movw	r1, #259	; 0x103
  132cb0:	e3090b38 	movw	r0, #39736	; 0x9b38
  132cb4:	e3400014 	movt	r0, #20
  132cb8:	ebff60ef 	bl	10b07c <sys_arch_assert>
    break;
  132cbc:	ea000000 	b	132cc4 <ip4addr_aton+0x3e0>
    break;
  132cc0:	e320f000 	nop	{0}
  }
  if (addr) {
  132cc4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  132cc8:	e3530000 	cmp	r3, #0
  132ccc:	0a000004 	beq	132ce4 <ip4addr_aton+0x400>
    ip4_addr_set_u32(addr, lwip_htonl(val));
  132cd0:	e51b0008 	ldr	r0, [fp, #-8]
  132cd4:	ebff8ecb 	bl	116808 <lwip_htonl>
  132cd8:	e1a02000 	mov	r2, r0
  132cdc:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  132ce0:	e5832000 	str	r2, [r3]
  }
  return 1;
  132ce4:	e3a03001 	mov	r3, #1
}
  132ce8:	e1a00003 	mov	r0, r3
  132cec:	e24bd004 	sub	sp, fp, #4
  132cf0:	e8bd8800 	pop	{fp, pc}

00132cf4 <ip4addr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         representation of addr
 */
char*
ip4addr_ntoa(const ip4_addr_t *addr)
{
  132cf4:	e92d4800 	push	{fp, lr}
  132cf8:	e28db004 	add	fp, sp, #4
  132cfc:	e24dd008 	sub	sp, sp, #8
  132d00:	e50b0008 	str	r0, [fp, #-8]
  static char str[IP4ADDR_STRLEN_MAX];
  return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
  132d04:	e3a02010 	mov	r2, #16
  132d08:	e30f1bd8 	movw	r1, #64472	; 0xfbd8
  132d0c:	e3401014 	movt	r1, #20
  132d10:	e51b0008 	ldr	r0, [fp, #-8]
  132d14:	eb000003 	bl	132d28 <ip4addr_ntoa_r>
  132d18:	e1a03000 	mov	r3, r0
}
  132d1c:	e1a00003 	mov	r0, r3
  132d20:	e24bd004 	sub	sp, fp, #4
  132d24:	e8bd8800 	pop	{fp, pc}

00132d28 <ip4addr_ntoa_r>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char*
ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
{
  132d28:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  132d2c:	e28db000 	add	fp, sp, #0
  132d30:	e24dd034 	sub	sp, sp, #52	; 0x34
  132d34:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  132d38:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  132d3c:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
  132d40:	e3a03000 	mov	r3, #0
  132d44:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

  s_addr = ip4_addr_get_u32(addr);
  132d48:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  132d4c:	e5933000 	ldr	r3, [r3]
  132d50:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

  rp = buf;
  132d54:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  132d58:	e50b3008 	str	r3, [fp, #-8]
  ap = (u8_t *)&s_addr;
  132d5c:	e24b301c 	sub	r3, fp, #28
  132d60:	e50b300c 	str	r3, [fp, #-12]
  for (n = 0; n < 4; n++) {
  132d64:	e3a03000 	mov	r3, #0
  132d68:	e54b300d 	strb	r3, [fp, #-13]
  132d6c:	ea00004b 	b	132ea0 <ip4addr_ntoa_r+0x178>
    i = 0;
  132d70:	e3a03000 	mov	r3, #0
  132d74:	e54b300e 	strb	r3, [fp, #-14]
    do {
      rem = *ap % (u8_t)10;
  132d78:	e51b300c 	ldr	r3, [fp, #-12]
  132d7c:	e5d31000 	ldrb	r1, [r3]
  132d80:	e30c3ccd 	movw	r3, #52429	; 0xcccd
  132d84:	e34c3ccc 	movt	r3, #52428	; 0xcccc
  132d88:	e0832391 	umull	r2, r3, r1, r3
  132d8c:	e1a031a3 	lsr	r3, r3, #3
  132d90:	e3a0200a 	mov	r2, #10
  132d94:	e0030392 	mul	r3, r2, r3
  132d98:	e0413003 	sub	r3, r1, r3
  132d9c:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
      *ap /= (u8_t)10;
  132da0:	e51b300c 	ldr	r3, [fp, #-12]
  132da4:	e5d32000 	ldrb	r2, [r3]
  132da8:	e30c3ccd 	movw	r3, #52429	; 0xcccd
  132dac:	e34c3ccc 	movt	r3, #52428	; 0xcccc
  132db0:	e0832392 	umull	r2, r3, r2, r3
  132db4:	e1a031a3 	lsr	r3, r3, #3
  132db8:	e6ef2073 	uxtb	r2, r3
  132dbc:	e51b300c 	ldr	r3, [fp, #-12]
  132dc0:	e5c32000 	strb	r2, [r3]
      inv[i++] = (char)('0' + rem);
  132dc4:	e55b300e 	ldrb	r3, [fp, #-14]
  132dc8:	e2832001 	add	r2, r3, #1
  132dcc:	e54b200e 	strb	r2, [fp, #-14]
  132dd0:	e1a01003 	mov	r1, r3
  132dd4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
  132dd8:	e2833030 	add	r3, r3, #48	; 0x30
  132ddc:	e6ef2073 	uxtb	r2, r3
  132de0:	e24b3004 	sub	r3, fp, #4
  132de4:	e0833001 	add	r3, r3, r1
  132de8:	e543201c 	strb	r2, [r3, #-28]	; 0xffffffe4
    } while (*ap);
  132dec:	e51b300c 	ldr	r3, [fp, #-12]
  132df0:	e5d33000 	ldrb	r3, [r3]
  132df4:	e3530000 	cmp	r3, #0
  132df8:	1affffde 	bne	132d78 <ip4addr_ntoa_r+0x50>
    while (i--) {
  132dfc:	ea00000f 	b	132e40 <ip4addr_ntoa_r+0x118>
      if (len++ >= buflen) {
  132e00:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132e04:	e2832001 	add	r2, r3, #1
  132e08:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
  132e0c:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  132e10:	e1520003 	cmp	r2, r3
  132e14:	ca000001 	bgt	132e20 <ip4addr_ntoa_r+0xf8>
        return NULL;
  132e18:	e3a03000 	mov	r3, #0
  132e1c:	ea000029 	b	132ec8 <ip4addr_ntoa_r+0x1a0>
      }
      *rp++ = inv[i];
  132e20:	e55b200e 	ldrb	r2, [fp, #-14]
  132e24:	e51b3008 	ldr	r3, [fp, #-8]
  132e28:	e2831001 	add	r1, r3, #1
  132e2c:	e50b1008 	str	r1, [fp, #-8]
  132e30:	e24b1004 	sub	r1, fp, #4
  132e34:	e0812002 	add	r2, r1, r2
  132e38:	e552201c 	ldrb	r2, [r2, #-28]	; 0xffffffe4
  132e3c:	e5c32000 	strb	r2, [r3]
    while (i--) {
  132e40:	e55b300e 	ldrb	r3, [fp, #-14]
  132e44:	e2432001 	sub	r2, r3, #1
  132e48:	e54b200e 	strb	r2, [fp, #-14]
  132e4c:	e3530000 	cmp	r3, #0
  132e50:	1affffea 	bne	132e00 <ip4addr_ntoa_r+0xd8>
    }
    if (len++ >= buflen) {
  132e54:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  132e58:	e2832001 	add	r2, r3, #1
  132e5c:	e50b2014 	str	r2, [fp, #-20]	; 0xffffffec
  132e60:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  132e64:	e1520003 	cmp	r2, r3
  132e68:	ca000001 	bgt	132e74 <ip4addr_ntoa_r+0x14c>
      return NULL;
  132e6c:	e3a03000 	mov	r3, #0
  132e70:	ea000014 	b	132ec8 <ip4addr_ntoa_r+0x1a0>
    }
    *rp++ = '.';
  132e74:	e51b3008 	ldr	r3, [fp, #-8]
  132e78:	e2832001 	add	r2, r3, #1
  132e7c:	e50b2008 	str	r2, [fp, #-8]
  132e80:	e3a0202e 	mov	r2, #46	; 0x2e
  132e84:	e5c32000 	strb	r2, [r3]
    ap++;
  132e88:	e51b300c 	ldr	r3, [fp, #-12]
  132e8c:	e2833001 	add	r3, r3, #1
  132e90:	e50b300c 	str	r3, [fp, #-12]
  for (n = 0; n < 4; n++) {
  132e94:	e55b300d 	ldrb	r3, [fp, #-13]
  132e98:	e2833001 	add	r3, r3, #1
  132e9c:	e54b300d 	strb	r3, [fp, #-13]
  132ea0:	e55b300d 	ldrb	r3, [fp, #-13]
  132ea4:	e3530003 	cmp	r3, #3
  132ea8:	9affffb0 	bls	132d70 <ip4addr_ntoa_r+0x48>
  }
  *--rp = 0;
  132eac:	e51b3008 	ldr	r3, [fp, #-8]
  132eb0:	e2433001 	sub	r3, r3, #1
  132eb4:	e50b3008 	str	r3, [fp, #-8]
  132eb8:	e51b3008 	ldr	r3, [fp, #-8]
  132ebc:	e3a02000 	mov	r2, #0
  132ec0:	e5c32000 	strb	r2, [r3]
  return buf;
  132ec4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
}
  132ec8:	e1a00003 	mov	r0, r3
  132ecc:	e28bd000 	add	sp, fp, #0
  132ed0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  132ed4:	e12fff1e 	bx	lr

00132ed8 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  132ed8:	e92d4800 	push	{fp, lr}
  132edc:	e28db004 	add	fp, sp, #4
  132ee0:	e24dd010 	sub	sp, sp, #16
  struct ip_reassdata *r, *prev = NULL;
  132ee4:	e3a03000 	mov	r3, #0
  132ee8:	e50b300c 	str	r3, [fp, #-12]

  r = reassdatagrams;
  132eec:	e30f3be8 	movw	r3, #64488	; 0xfbe8
  132ef0:	e3403014 	movt	r3, #20
  132ef4:	e5933000 	ldr	r3, [r3]
  132ef8:	e50b3008 	str	r3, [fp, #-8]
  while (r != NULL) {
  132efc:	ea000017 	b	132f60 <ip_reass_tmr+0x88>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  132f00:	e51b3008 	ldr	r3, [fp, #-8]
  132f04:	e5d3301f 	ldrb	r3, [r3, #31]
  132f08:	e3530000 	cmp	r3, #0
  132f0c:	0a00000b 	beq	132f40 <ip_reass_tmr+0x68>
      r->timer--;
  132f10:	e51b3008 	ldr	r3, [fp, #-8]
  132f14:	e5d3301f 	ldrb	r3, [r3, #31]
  132f18:	e2433001 	sub	r3, r3, #1
  132f1c:	e6ef2073 	uxtb	r2, r3
  132f20:	e51b3008 	ldr	r3, [fp, #-8]
  132f24:	e5c3201f 	strb	r2, [r3, #31]
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  132f28:	e51b3008 	ldr	r3, [fp, #-8]
  132f2c:	e50b300c 	str	r3, [fp, #-12]
      r = r->next;
  132f30:	e51b3008 	ldr	r3, [fp, #-8]
  132f34:	e5933000 	ldr	r3, [r3]
  132f38:	e50b3008 	str	r3, [fp, #-8]
  132f3c:	ea000007 	b	132f60 <ip_reass_tmr+0x88>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  132f40:	e51b3008 	ldr	r3, [fp, #-8]
  132f44:	e50b3010 	str	r3, [fp, #-16]
      /* get the next pointer before freeing */
      r = r->next;
  132f48:	e51b3008 	ldr	r3, [fp, #-8]
  132f4c:	e5933000 	ldr	r3, [r3]
  132f50:	e50b3008 	str	r3, [fp, #-8]
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  132f54:	e51b100c 	ldr	r1, [fp, #-12]
  132f58:	e51b0010 	ldr	r0, [fp, #-16]
  132f5c:	eb000005 	bl	132f78 <ip_reass_free_complete_datagram>
  while (r != NULL) {
  132f60:	e51b3008 	ldr	r3, [fp, #-8]
  132f64:	e3530000 	cmp	r3, #0
  132f68:	1affffe4 	bne	132f00 <ip_reass_tmr+0x28>
     }
   }
}
  132f6c:	e320f000 	nop	{0}
  132f70:	e24bd004 	sub	sp, fp, #4
  132f74:	e8bd8800 	pop	{fp, pc}

00132f78 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  132f78:	e92d4800 	push	{fp, lr}
  132f7c:	e28db004 	add	fp, sp, #4
  132f80:	e24dd020 	sub	sp, sp, #32
  132f84:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  132f88:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  u16_t pbufs_freed = 0;
  132f8c:	e3a03000 	mov	r3, #0
  132f90:	e14b30b6 	strh	r3, [fp, #-6]
  u16_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  132f94:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  132f98:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  132f9c:	e1520003 	cmp	r2, r3
  132fa0:	1a000006 	bne	132fc0 <ip_reass_free_complete_datagram+0x48>
  132fa4:	e3090b70 	movw	r0, #39792	; 0x9b70
  132fa8:	e3400014 	movt	r0, #20
  132fac:	ebff4058 	bl	103114 <rt_kprintf>
  132fb0:	e3a010a7 	mov	r1, #167	; 0xa7
  132fb4:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  132fb8:	e3400014 	movt	r0, #20
  132fbc:	ebff602e 	bl	10b07c <sys_arch_assert>
  if (prev != NULL) {
  132fc0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  132fc4:	e3530000 	cmp	r3, #0
  132fc8:	0a00000b 	beq	132ffc <ip_reass_free_complete_datagram+0x84>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  132fcc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  132fd0:	e5933000 	ldr	r3, [r3]
  132fd4:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  132fd8:	e1520003 	cmp	r2, r3
  132fdc:	0a000006 	beq	132ffc <ip_reass_free_complete_datagram+0x84>
  132fe0:	e3090bb4 	movw	r0, #39860	; 0x9bb4
  132fe4:	e3400014 	movt	r0, #20
  132fe8:	ebff4049 	bl	103114 <rt_kprintf>
  132fec:	e3a010a9 	mov	r1, #169	; 0xa9
  132ff0:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  132ff4:	e3400014 	movt	r0, #20
  132ff8:	ebff601f 	bl	10b07c <sys_arch_assert>
  }

  MIB2_STATS_INC(mib2.ipreasmfails);
  132ffc:	e3063840 	movw	r3, #26688	; 0x6840
  133000:	e3403057 	movt	r3, #87	; 0x57
  133004:	e5933150 	ldr	r3, [r3, #336]	; 0x150
  133008:	e2832001 	add	r2, r3, #1
  13300c:	e3063840 	movw	r3, #26688	; 0x6840
  133010:	e3403057 	movt	r3, #87	; 0x57
  133014:	e5832150 	str	r2, [r3, #336]	; 0x150
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  133018:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  13301c:	e5933004 	ldr	r3, [r3, #4]
  133020:	e5933004 	ldr	r3, [r3, #4]
  133024:	e50b3010 	str	r3, [fp, #-16]
  if (iprh->start == 0) {
  133028:	e51b3010 	ldr	r3, [fp, #-16]
  13302c:	e1d330b4 	ldrh	r3, [r3, #4]
  133030:	e6ff3073 	uxth	r3, r3
  133034:	e3530000 	cmp	r3, #0
  133038:	1a000026 	bne	1330d8 <ip_reass_free_complete_datagram+0x160>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  13303c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  133040:	e5933004 	ldr	r3, [r3, #4]
  133044:	e50b300c 	str	r3, [fp, #-12]
    ipr->p = iprh->next_pbuf;
  133048:	e51b3010 	ldr	r3, [fp, #-16]
  13304c:	e5932000 	ldr	r2, [r3]
  133050:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  133054:	e5832004 	str	r2, [r3, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  133058:	e51b300c 	ldr	r3, [fp, #-12]
  13305c:	e5930004 	ldr	r0, [r3, #4]
  133060:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  133064:	e2833008 	add	r3, r3, #8
  133068:	e3a02014 	mov	r2, #20
  13306c:	e1a01003 	mov	r1, r3
  133070:	eb0037c7 	bl	140f94 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  133074:	e3a01001 	mov	r1, #1
  133078:	e51b000c 	ldr	r0, [fp, #-12]
  13307c:	ebfff396 	bl	12fedc <icmp_time_exceeded>
    clen = pbuf_clen(p);
  133080:	e51b000c 	ldr	r0, [fp, #-12]
  133084:	ebffa08f 	bl	11b2c8 <pbuf_clen>
  133088:	e1a03000 	mov	r3, r0
  13308c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
  133090:	e15b20b6 	ldrh	r2, [fp, #-6]
  133094:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  133098:	e0823003 	add	r3, r2, r3
  13309c:	e3530801 	cmp	r3, #65536	; 0x10000
  1330a0:	ba000006 	blt	1330c0 <ip_reass_free_complete_datagram+0x148>
  1330a4:	e3090bc8 	movw	r0, #39880	; 0x9bc8
  1330a8:	e3400014 	movt	r0, #20
  1330ac:	ebff4018 	bl	103114 <rt_kprintf>
  1330b0:	e3a010b8 	mov	r1, #184	; 0xb8
  1330b4:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  1330b8:	e3400014 	movt	r0, #20
  1330bc:	ebff5fee 	bl	10b07c <sys_arch_assert>
    pbufs_freed += clen;
  1330c0:	e15b20b6 	ldrh	r2, [fp, #-6]
  1330c4:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  1330c8:	e0823003 	add	r3, r2, r3
  1330cc:	e14b30b6 	strh	r3, [fp, #-6]
    pbuf_free(p);
  1330d0:	e51b000c 	ldr	r0, [fp, #-12]
  1330d4:	ebff9ff6 	bl	11b0b4 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released
     separately as they have not yet been chained */
  p = ipr->p;
  1330d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1330dc:	e5933004 	ldr	r3, [r3, #4]
  1330e0:	e50b300c 	str	r3, [fp, #-12]
  while (p != NULL) {
  1330e4:	ea00001d 	b	133160 <ip_reass_free_complete_datagram+0x1e8>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  1330e8:	e51b300c 	ldr	r3, [fp, #-12]
  1330ec:	e5933004 	ldr	r3, [r3, #4]
  1330f0:	e50b3010 	str	r3, [fp, #-16]
    pcur = p;
  1330f4:	e51b300c 	ldr	r3, [fp, #-12]
  1330f8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  1330fc:	e51b3010 	ldr	r3, [fp, #-16]
  133100:	e5933000 	ldr	r3, [r3]
  133104:	e50b300c 	str	r3, [fp, #-12]
    clen = pbuf_clen(pcur);
  133108:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  13310c:	ebffa06d 	bl	11b2c8 <pbuf_clen>
  133110:	e1a03000 	mov	r3, r0
  133114:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
  133118:	e15b20b6 	ldrh	r2, [fp, #-6]
  13311c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  133120:	e0823003 	add	r3, r2, r3
  133124:	e3530801 	cmp	r3, #65536	; 0x10000
  133128:	ba000006 	blt	133148 <ip_reass_free_complete_datagram+0x1d0>
  13312c:	e3090bc8 	movw	r0, #39880	; 0x9bc8
  133130:	e3400014 	movt	r0, #20
  133134:	ebff3ff6 	bl	103114 <rt_kprintf>
  133138:	e3a010c8 	mov	r1, #200	; 0xc8
  13313c:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  133140:	e3400014 	movt	r0, #20
  133144:	ebff5fcc 	bl	10b07c <sys_arch_assert>
    pbufs_freed += clen;
  133148:	e15b20b6 	ldrh	r2, [fp, #-6]
  13314c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  133150:	e0823003 	add	r3, r2, r3
  133154:	e14b30b6 	strh	r3, [fp, #-6]
    pbuf_free(pcur);
  133158:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  13315c:	ebff9fd4 	bl	11b0b4 <pbuf_free>
  while (p != NULL) {
  133160:	e51b300c 	ldr	r3, [fp, #-12]
  133164:	e3530000 	cmp	r3, #0
  133168:	1affffde 	bne	1330e8 <ip_reass_free_complete_datagram+0x170>
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  13316c:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  133170:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
  133174:	eb0000b9 	bl	133460 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  133178:	e30f3bec 	movw	r3, #64492	; 0xfbec
  13317c:	e3403014 	movt	r3, #20
  133180:	e1d330b0 	ldrh	r3, [r3]
  133184:	e15b20b6 	ldrh	r2, [fp, #-6]
  133188:	e1520003 	cmp	r2, r3
  13318c:	9a000006 	bls	1331ac <ip_reass_free_complete_datagram+0x234>
  133190:	e3090be8 	movw	r0, #39912	; 0x9be8
  133194:	e3400014 	movt	r0, #20
  133198:	ebff3fdd 	bl	103114 <rt_kprintf>
  13319c:	e3a010ce 	mov	r1, #206	; 0xce
  1331a0:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  1331a4:	e3400014 	movt	r0, #20
  1331a8:	ebff5fb3 	bl	10b07c <sys_arch_assert>
  ip_reass_pbufcount -= pbufs_freed;
  1331ac:	e30f3bec 	movw	r3, #64492	; 0xfbec
  1331b0:	e3403014 	movt	r3, #20
  1331b4:	e1d320b0 	ldrh	r2, [r3]
  1331b8:	e15b30b6 	ldrh	r3, [fp, #-6]
  1331bc:	e0423003 	sub	r3, r2, r3
  1331c0:	e6ff2073 	uxth	r2, r3
  1331c4:	e30f3bec 	movw	r3, #64492	; 0xfbec
  1331c8:	e3403014 	movt	r3, #20
  1331cc:	e1c320b0 	strh	r2, [r3]

  return pbufs_freed;
  1331d0:	e15b30b6 	ldrh	r3, [fp, #-6]
}
  1331d4:	e1a00003 	mov	r0, r3
  1331d8:	e24bd004 	sub	sp, fp, #4
  1331dc:	e8bd8800 	pop	{fp, pc}

001331e0 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  1331e0:	e92d4800 	push	{fp, lr}
  1331e4:	e28db004 	add	fp, sp, #4
  1331e8:	e24dd028 	sub	sp, sp, #40	; 0x28
  1331ec:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  1331f0:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev, *oldest_prev;
  int pbufs_freed = 0, pbufs_freed_current;
  1331f4:	e3a03000 	mov	r3, #0
  1331f8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  1331fc:	e3a03000 	mov	r3, #0
  133200:	e50b300c 	str	r3, [fp, #-12]
    prev = NULL;
  133204:	e3a03000 	mov	r3, #0
  133208:	e50b3010 	str	r3, [fp, #-16]
    oldest_prev = NULL;
  13320c:	e3a03000 	mov	r3, #0
  133210:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    other_datagrams = 0;
  133214:	e3a03000 	mov	r3, #0
  133218:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    r = reassdatagrams;
  13321c:	e30f3be8 	movw	r3, #64488	; 0xfbe8
  133220:	e3403014 	movt	r3, #20
  133224:	e5933000 	ldr	r3, [r3]
  133228:	e50b3008 	str	r3, [fp, #-8]
    while (r != NULL) {
  13322c:	ea000030 	b	1332f4 <ip_reass_remove_oldest_datagram+0x114>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  133230:	e51b3008 	ldr	r3, [fp, #-8]
  133234:	e5932014 	ldr	r2, [r3, #20]
  133238:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13323c:	e593300c 	ldr	r3, [r3, #12]
  133240:	e1520003 	cmp	r2, r3
  133244:	1a00000c 	bne	13327c <ip_reass_remove_oldest_datagram+0x9c>
  133248:	e51b3008 	ldr	r3, [fp, #-8]
  13324c:	e5932018 	ldr	r2, [r3, #24]
  133250:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  133254:	e5933010 	ldr	r3, [r3, #16]
  133258:	e1520003 	cmp	r2, r3
  13325c:	1a000006 	bne	13327c <ip_reass_remove_oldest_datagram+0x9c>
  133260:	e51b3008 	ldr	r3, [fp, #-8]
  133264:	e1d320bc 	ldrh	r2, [r3, #12]
  133268:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13326c:	e1d330b4 	ldrh	r3, [r3, #4]
  133270:	e6ff3073 	uxth	r3, r3
  133274:	e1520003 	cmp	r2, r3
  133278:	0a000014 	beq	1332d0 <ip_reass_remove_oldest_datagram+0xf0>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  13327c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  133280:	e2833001 	add	r3, r3, #1
  133284:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
        if (oldest == NULL) {
  133288:	e51b300c 	ldr	r3, [fp, #-12]
  13328c:	e3530000 	cmp	r3, #0
  133290:	1a000004 	bne	1332a8 <ip_reass_remove_oldest_datagram+0xc8>
          oldest = r;
  133294:	e51b3008 	ldr	r3, [fp, #-8]
  133298:	e50b300c 	str	r3, [fp, #-12]
          oldest_prev = prev;
  13329c:	e51b3010 	ldr	r3, [fp, #-16]
  1332a0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1332a4:	ea000009 	b	1332d0 <ip_reass_remove_oldest_datagram+0xf0>
        } else if (r->timer <= oldest->timer) {
  1332a8:	e51b3008 	ldr	r3, [fp, #-8]
  1332ac:	e5d3201f 	ldrb	r2, [r3, #31]
  1332b0:	e51b300c 	ldr	r3, [fp, #-12]
  1332b4:	e5d3301f 	ldrb	r3, [r3, #31]
  1332b8:	e1520003 	cmp	r2, r3
  1332bc:	8a000003 	bhi	1332d0 <ip_reass_remove_oldest_datagram+0xf0>
          /* older than the previous oldest */
          oldest = r;
  1332c0:	e51b3008 	ldr	r3, [fp, #-8]
  1332c4:	e50b300c 	str	r3, [fp, #-12]
          oldest_prev = prev;
  1332c8:	e51b3010 	ldr	r3, [fp, #-16]
  1332cc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        }
      }
      if (r->next != NULL) {
  1332d0:	e51b3008 	ldr	r3, [fp, #-8]
  1332d4:	e5933000 	ldr	r3, [r3]
  1332d8:	e3530000 	cmp	r3, #0
  1332dc:	0a000001 	beq	1332e8 <ip_reass_remove_oldest_datagram+0x108>
        prev = r;
  1332e0:	e51b3008 	ldr	r3, [fp, #-8]
  1332e4:	e50b3010 	str	r3, [fp, #-16]
      }
      r = r->next;
  1332e8:	e51b3008 	ldr	r3, [fp, #-8]
  1332ec:	e5933000 	ldr	r3, [r3]
  1332f0:	e50b3008 	str	r3, [fp, #-8]
    while (r != NULL) {
  1332f4:	e51b3008 	ldr	r3, [fp, #-8]
  1332f8:	e3530000 	cmp	r3, #0
  1332fc:	1affffcb 	bne	133230 <ip_reass_remove_oldest_datagram+0x50>
    }
    if (oldest != NULL) {
  133300:	e51b300c 	ldr	r3, [fp, #-12]
  133304:	e3530000 	cmp	r3, #0
  133308:	0a000007 	beq	13332c <ip_reass_remove_oldest_datagram+0x14c>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
  13330c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  133310:	e51b000c 	ldr	r0, [fp, #-12]
  133314:	ebffff17 	bl	132f78 <ip_reass_free_complete_datagram>
  133318:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
      pbufs_freed += pbufs_freed_current;
  13331c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  133320:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  133324:	e0823003 	add	r3, r2, r3
  133328:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  13332c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  133330:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  133334:	e1520003 	cmp	r2, r3
  133338:	aa000002 	bge	133348 <ip_reass_remove_oldest_datagram+0x168>
  13333c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  133340:	e3530001 	cmp	r3, #1
  133344:	caffffac 	bgt	1331fc <ip_reass_remove_oldest_datagram+0x1c>
  return pbufs_freed;
  133348:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
}
  13334c:	e1a00003 	mov	r0, r3
  133350:	e24bd004 	sub	sp, fp, #4
  133354:	e8bd8800 	pop	{fp, pc}

00133358 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  133358:	e92d4800 	push	{fp, lr}
  13335c:	e28db004 	add	fp, sp, #4
  133360:	e24dd010 	sub	sp, sp, #16
  133364:	e50b0010 	str	r0, [fp, #-16]
  133368:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
#if ! IP_REASS_FREE_OLDEST
  LWIP_UNUSED_ARG(clen);
#endif

  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
  13336c:	e300211a 	movw	r2, #282	; 0x11a
  133370:	e3091b7c 	movw	r1, #39804	; 0x9b7c
  133374:	e3401014 	movt	r1, #20
  133378:	e3a00005 	mov	r0, #5
  13337c:	ebff97d6 	bl	1192dc <memp_malloc_fn>
  133380:	e50b0008 	str	r0, [fp, #-8]
  if (ipr == NULL) {
  133384:	e51b3008 	ldr	r3, [fp, #-8]
  133388:	e3530000 	cmp	r3, #0
  13338c:	1a000019 	bne	1333f8 <ip_reass_enqueue_new_datagram+0xa0>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  133390:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  133394:	e51b0010 	ldr	r0, [fp, #-16]
  133398:	ebffff90 	bl	1331e0 <ip_reass_remove_oldest_datagram>
  13339c:	e1a02000 	mov	r2, r0
  1333a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1333a4:	e1530002 	cmp	r3, r2
  1333a8:	ca000005 	bgt	1333c4 <ip_reass_enqueue_new_datagram+0x6c>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
  1333ac:	e300211e 	movw	r2, #286	; 0x11e
  1333b0:	e3091b7c 	movw	r1, #39804	; 0x9b7c
  1333b4:	e3401014 	movt	r1, #20
  1333b8:	e3a00005 	mov	r0, #5
  1333bc:	ebff97c6 	bl	1192dc <memp_malloc_fn>
  1333c0:	e50b0008 	str	r0, [fp, #-8]
    }
    if (ipr == NULL)
  1333c4:	e51b3008 	ldr	r3, [fp, #-8]
  1333c8:	e3530000 	cmp	r3, #0
  1333cc:	1a000009 	bne	1333f8 <ip_reass_enqueue_new_datagram+0xa0>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
  1333d0:	e3063840 	movw	r3, #26688	; 0x6840
  1333d4:	e3403057 	movt	r3, #87	; 0x57
  1333d8:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
  1333dc:	e2833001 	add	r3, r3, #1
  1333e0:	e6ff2073 	uxth	r2, r3
  1333e4:	e3063840 	movw	r3, #26688	; 0x6840
  1333e8:	e3403057 	movt	r3, #87	; 0x57
  1333ec:	e1c323bc 	strh	r2, [r3, #60]	; 0x3c
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  1333f0:	e3a03000 	mov	r3, #0
  1333f4:	ea000016 	b	133454 <ip_reass_enqueue_new_datagram+0xfc>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  1333f8:	e3a02020 	mov	r2, #32
  1333fc:	e3a01000 	mov	r1, #0
  133400:	e51b0008 	ldr	r0, [fp, #-8]
  133404:	eb00381a 	bl	141474 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  133408:	e51b3008 	ldr	r3, [fp, #-8]
  13340c:	e3a02003 	mov	r2, #3
  133410:	e5c3201f 	strb	r2, [r3, #31]

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  133414:	e30f3be8 	movw	r3, #64488	; 0xfbe8
  133418:	e3403014 	movt	r3, #20
  13341c:	e5932000 	ldr	r2, [r3]
  133420:	e51b3008 	ldr	r3, [fp, #-8]
  133424:	e5832000 	str	r2, [r3]
  reassdatagrams = ipr;
  133428:	e30f3be8 	movw	r3, #64488	; 0xfbe8
  13342c:	e3403014 	movt	r3, #20
  133430:	e51b2008 	ldr	r2, [fp, #-8]
  133434:	e5832000 	str	r2, [r3]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  133438:	e51b3008 	ldr	r3, [fp, #-8]
  13343c:	e2833008 	add	r3, r3, #8
  133440:	e3a02014 	mov	r2, #20
  133444:	e51b1010 	ldr	r1, [fp, #-16]
  133448:	e1a00003 	mov	r0, r3
  13344c:	eb0036d0 	bl	140f94 <memcpy>
  return ipr;
  133450:	e51b3008 	ldr	r3, [fp, #-8]
}
  133454:	e1a00003 	mov	r0, r3
  133458:	e24bd004 	sub	sp, fp, #4
  13345c:	e8bd8800 	pop	{fp, pc}

00133460 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  133460:	e92d4800 	push	{fp, lr}
  133464:	e28db004 	add	fp, sp, #4
  133468:	e24dd008 	sub	sp, sp, #8
  13346c:	e50b0008 	str	r0, [fp, #-8]
  133470:	e50b100c 	str	r1, [fp, #-12]
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  133474:	e30f3be8 	movw	r3, #64488	; 0xfbe8
  133478:	e3403014 	movt	r3, #20
  13347c:	e5933000 	ldr	r3, [r3]
  133480:	e51b2008 	ldr	r2, [fp, #-8]
  133484:	e1520003 	cmp	r2, r3
  133488:	1a000005 	bne	1334a4 <ip_reass_dequeue_datagram+0x44>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  13348c:	e51b3008 	ldr	r3, [fp, #-8]
  133490:	e5932000 	ldr	r2, [r3]
  133494:	e30f3be8 	movw	r3, #64488	; 0xfbe8
  133498:	e3403014 	movt	r3, #20
  13349c:	e5832000 	str	r2, [r3]
  1334a0:	ea00000d 	b	1334dc <ip_reass_dequeue_datagram+0x7c>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  1334a4:	e51b300c 	ldr	r3, [fp, #-12]
  1334a8:	e3530000 	cmp	r3, #0
  1334ac:	1a000006 	bne	1334cc <ip_reass_dequeue_datagram+0x6c>
  1334b0:	e3090c04 	movw	r0, #39940	; 0x9c04
  1334b4:	e3400014 	movt	r0, #20
  1334b8:	ebff3f15 	bl	103114 <rt_kprintf>
  1334bc:	e3001141 	movw	r1, #321	; 0x141
  1334c0:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  1334c4:	e3400014 	movt	r0, #20
  1334c8:	ebff5eeb 	bl	10b07c <sys_arch_assert>
    prev->next = ipr->next;
  1334cc:	e51b3008 	ldr	r3, [fp, #-8]
  1334d0:	e5932000 	ldr	r2, [r3]
  1334d4:	e51b300c 	ldr	r3, [fp, #-12]
  1334d8:	e5832000 	str	r2, [r3]
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
  1334dc:	e51b1008 	ldr	r1, [fp, #-8]
  1334e0:	e3a00005 	mov	r0, #5
  1334e4:	ebff97e4 	bl	11947c <memp_free>
}
  1334e8:	e320f000 	nop	{0}
  1334ec:	e24bd004 	sub	sp, fp, #4
  1334f0:	e8bd8800 	pop	{fp, pc}

001334f4 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  1334f4:	e92d4800 	push	{fp, lr}
  1334f8:	e28db004 	add	fp, sp, #4
  1334fc:	e24dd028 	sub	sp, sp, #40	; 0x28
  133500:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  133504:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  133508:	e3a03000 	mov	r3, #0
  13350c:	e50b300c 	str	r3, [fp, #-12]
  struct pbuf *q;
  u16_t offset, len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  133510:	e3a03001 	mov	r3, #1
  133514:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload;
  133518:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  13351c:	e5933004 	ldr	r3, [r3, #4]
  133520:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  133524:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  133528:	e1d330b2 	ldrh	r3, [r3, #2]
  13352c:	e6ff3073 	uxth	r3, r3
  133530:	e1a00003 	mov	r0, r3
  133534:	ebff8ca7 	bl	1167d8 <lwip_htons>
  133538:	e1a03000 	mov	r3, r0
  13353c:	e1a02003 	mov	r2, r3
  133540:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  133544:	e5d33000 	ldrb	r3, [r3]
  133548:	e6ff3073 	uxth	r3, r3
  13354c:	e203300f 	and	r3, r3, #15
  133550:	e6ff3073 	uxth	r3, r3
  133554:	e1a03103 	lsl	r3, r3, #2
  133558:	e6ff3073 	uxth	r3, r3
  13355c:	e0423003 	sub	r3, r2, r3
  133560:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  133564:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  133568:	e1d330b6 	ldrh	r3, [r3, #6]
  13356c:	e6ff3073 	uxth	r3, r3
  133570:	e1a00003 	mov	r0, r3
  133574:	ebff8c97 	bl	1167d8 <lwip_htons>
  133578:	e1a03000 	mov	r3, r0
  13357c:	e7ec3053 	ubfx	r3, r3, #0, #13
  133580:	e6ff3073 	uxth	r3, r3
  133584:	e1a03183 	lsl	r3, r3, #3
  133588:	e14b31bc 	strh	r3, [fp, #-28]	; 0xffffffe4
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  13358c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  133590:	e5933004 	ldr	r3, [r3, #4]
  133594:	e50b3008 	str	r3, [fp, #-8]
  iprh->next_pbuf = NULL;
  133598:	e51b3008 	ldr	r3, [fp, #-8]
  13359c:	e3a02000 	mov	r2, #0
  1335a0:	e5c32000 	strb	r2, [r3]
  1335a4:	e3a02000 	mov	r2, #0
  1335a8:	e5c32001 	strb	r2, [r3, #1]
  1335ac:	e3a02000 	mov	r2, #0
  1335b0:	e5c32002 	strb	r2, [r3, #2]
  1335b4:	e3a02000 	mov	r2, #0
  1335b8:	e5c32003 	strb	r2, [r3, #3]
  iprh->start = offset;
  1335bc:	e51b3008 	ldr	r3, [fp, #-8]
  1335c0:	e15b21bc 	ldrh	r2, [fp, #-28]	; 0xffffffe4
  1335c4:	e1c320b4 	strh	r2, [r3, #4]
  iprh->end = offset + len;
  1335c8:	e15b21bc 	ldrh	r2, [fp, #-28]	; 0xffffffe4
  1335cc:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  1335d0:	e0823003 	add	r3, r2, r3
  1335d4:	e6ff2073 	uxth	r2, r3
  1335d8:	e51b3008 	ldr	r3, [fp, #-8]
  1335dc:	e1c320b6 	strh	r2, [r3, #6]

  /* Iterate through until we either get to the end of the list (append),
   * or we find one with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  1335e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1335e4:	e5933004 	ldr	r3, [r3, #4]
  1335e8:	e50b3010 	str	r3, [fp, #-16]
  1335ec:	ea00004a 	b	13371c <ip_reass_chain_frag_into_datagram_and_validate+0x228>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  1335f0:	e51b3010 	ldr	r3, [fp, #-16]
  1335f4:	e5933004 	ldr	r3, [r3, #4]
  1335f8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    if (iprh->start < iprh_tmp->start) {
  1335fc:	e51b3008 	ldr	r3, [fp, #-8]
  133600:	e1d330b4 	ldrh	r3, [r3, #4]
  133604:	e6ff2073 	uxth	r2, r3
  133608:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  13360c:	e1d330b4 	ldrh	r3, [r3, #4]
  133610:	e6ff3073 	uxth	r3, r3
  133614:	e1520003 	cmp	r2, r3
  133618:	2a00001d 	bcs	133694 <ip_reass_chain_frag_into_datagram_and_validate+0x1a0>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  13361c:	e51b3008 	ldr	r3, [fp, #-8]
  133620:	e51b2010 	ldr	r2, [fp, #-16]
  133624:	e5832000 	str	r2, [r3]
      if (iprh_prev != NULL) {
  133628:	e51b300c 	ldr	r3, [fp, #-12]
  13362c:	e3530000 	cmp	r3, #0
  133630:	0a000013 	beq	133684 <ip_reass_chain_frag_into_datagram_and_validate+0x190>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  133634:	e51b3008 	ldr	r3, [fp, #-8]
  133638:	e1d330b4 	ldrh	r3, [r3, #4]
  13363c:	e6ff2073 	uxth	r2, r3
  133640:	e51b300c 	ldr	r3, [fp, #-12]
  133644:	e1d330b6 	ldrh	r3, [r3, #6]
  133648:	e6ff3073 	uxth	r3, r3
  13364c:	e1520003 	cmp	r2, r3
  133650:	3a0000cf 	bcc	133994 <ip_reass_chain_frag_into_datagram_and_validate+0x4a0>
  133654:	e51b3008 	ldr	r3, [fp, #-8]
  133658:	e1d330b6 	ldrh	r3, [r3, #6]
  13365c:	e6ff2073 	uxth	r2, r3
  133660:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  133664:	e1d330b4 	ldrh	r3, [r3, #4]
  133668:	e6ff3073 	uxth	r3, r3
  13366c:	e1520003 	cmp	r2, r3
  133670:	8a0000c7 	bhi	133994 <ip_reass_chain_frag_into_datagram_and_validate+0x4a0>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  133674:	e51b300c 	ldr	r3, [fp, #-12]
  133678:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  13367c:	e5832000 	str	r2, [r3]
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
  133680:	ea000028 	b	133728 <ip_reass_chain_frag_into_datagram_and_validate+0x234>
        ipr->p = new_p;
  133684:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  133688:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  13368c:	e5832004 	str	r2, [r3, #4]
      break;
  133690:	ea000024 	b	133728 <ip_reass_chain_frag_into_datagram_and_validate+0x234>
    } else if (iprh->start == iprh_tmp->start) {
  133694:	e51b3008 	ldr	r3, [fp, #-8]
  133698:	e1d330b4 	ldrh	r3, [r3, #4]
  13369c:	e6ff2073 	uxth	r2, r3
  1336a0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1336a4:	e1d330b4 	ldrh	r3, [r3, #4]
  1336a8:	e6ff3073 	uxth	r3, r3
  1336ac:	e1520003 	cmp	r2, r3
  1336b0:	0a0000b9 	beq	13399c <ip_reass_chain_frag_into_datagram_and_validate+0x4a8>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if (iprh->start < iprh_tmp->end) {
  1336b4:	e51b3008 	ldr	r3, [fp, #-8]
  1336b8:	e1d330b4 	ldrh	r3, [r3, #4]
  1336bc:	e6ff2073 	uxth	r2, r3
  1336c0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1336c4:	e1d330b6 	ldrh	r3, [r3, #6]
  1336c8:	e6ff3073 	uxth	r3, r3
  1336cc:	e1520003 	cmp	r2, r3
  1336d0:	3a0000b3 	bcc	1339a4 <ip_reass_chain_frag_into_datagram_and_validate+0x4b0>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no holes. */
      if (iprh_prev != NULL) {
  1336d4:	e51b300c 	ldr	r3, [fp, #-12]
  1336d8:	e3530000 	cmp	r3, #0
  1336dc:	0a000009 	beq	133708 <ip_reass_chain_frag_into_datagram_and_validate+0x214>
        if (iprh_prev->end != iprh_tmp->start) {
  1336e0:	e51b300c 	ldr	r3, [fp, #-12]
  1336e4:	e1d330b6 	ldrh	r3, [r3, #6]
  1336e8:	e6ff2073 	uxth	r2, r3
  1336ec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1336f0:	e1d330b4 	ldrh	r3, [r3, #4]
  1336f4:	e6ff3073 	uxth	r3, r3
  1336f8:	e1520003 	cmp	r2, r3
  1336fc:	0a000001 	beq	133708 <ip_reass_chain_frag_into_datagram_and_validate+0x214>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  133700:	e3a03000 	mov	r3, #0
  133704:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  133708:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  13370c:	e5933000 	ldr	r3, [r3]
  133710:	e50b3010 	str	r3, [fp, #-16]
    iprh_prev = iprh_tmp;
  133714:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  133718:	e50b300c 	str	r3, [fp, #-12]
  for (q = ipr->p; q != NULL;) {
  13371c:	e51b3010 	ldr	r3, [fp, #-16]
  133720:	e3530000 	cmp	r3, #0
  133724:	1affffb1 	bne	1335f0 <ip_reass_chain_frag_into_datagram_and_validate+0xfc>
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  133728:	e51b3010 	ldr	r3, [fp, #-16]
  13372c:	e3530000 	cmp	r3, #0
  133730:	1a00002d 	bne	1337ec <ip_reass_chain_frag_into_datagram_and_validate+0x2f8>
    if (iprh_prev != NULL) {
  133734:	e51b300c 	ldr	r3, [fp, #-12]
  133738:	e3530000 	cmp	r3, #0
  13373c:	0a00001c 	beq	1337b4 <ip_reass_chain_frag_into_datagram_and_validate+0x2c0>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  133740:	e51b300c 	ldr	r3, [fp, #-12]
  133744:	e1d330b6 	ldrh	r3, [r3, #6]
  133748:	e6ff2073 	uxth	r2, r3
  13374c:	e51b3008 	ldr	r3, [fp, #-8]
  133750:	e1d330b4 	ldrh	r3, [r3, #4]
  133754:	e6ff3073 	uxth	r3, r3
  133758:	e1520003 	cmp	r2, r3
  13375c:	9a000006 	bls	13377c <ip_reass_chain_frag_into_datagram_and_validate+0x288>
  133760:	e3090c20 	movw	r0, #39968	; 0x9c20
  133764:	e3400014 	movt	r0, #20
  133768:	ebff3e69 	bl	103114 <rt_kprintf>
  13376c:	e300119b 	movw	r1, #411	; 0x19b
  133770:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  133774:	e3400014 	movt	r0, #20
  133778:	ebff5e3f 	bl	10b07c <sys_arch_assert>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  13377c:	e51b300c 	ldr	r3, [fp, #-12]
  133780:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  133784:	e5832000 	str	r2, [r3]
      if (iprh_prev->end != iprh->start) {
  133788:	e51b300c 	ldr	r3, [fp, #-12]
  13378c:	e1d330b6 	ldrh	r3, [r3, #6]
  133790:	e6ff2073 	uxth	r2, r3
  133794:	e51b3008 	ldr	r3, [fp, #-8]
  133798:	e1d330b4 	ldrh	r3, [r3, #4]
  13379c:	e6ff3073 	uxth	r3, r3
  1337a0:	e1520003 	cmp	r2, r3
  1337a4:	0a000010 	beq	1337ec <ip_reass_chain_frag_into_datagram_and_validate+0x2f8>
        valid = 0;
  1337a8:	e3a03000 	mov	r3, #0
  1337ac:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  1337b0:	ea00000d 	b	1337ec <ip_reass_chain_frag_into_datagram_and_validate+0x2f8>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  1337b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1337b8:	e5933004 	ldr	r3, [r3, #4]
  1337bc:	e3530000 	cmp	r3, #0
  1337c0:	0a000006 	beq	1337e0 <ip_reass_chain_frag_into_datagram_and_validate+0x2ec>
  1337c4:	e3090c40 	movw	r0, #40000	; 0x9c40
  1337c8:	e3400014 	movt	r0, #20
  1337cc:	ebff3e50 	bl	103114 <rt_kprintf>
  1337d0:	e3a01f69 	mov	r1, #420	; 0x1a4
  1337d4:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  1337d8:	e3400014 	movt	r0, #20
  1337dc:	ebff5e26 	bl	10b07c <sys_arch_assert>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  1337e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1337e4:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  1337e8:	e5832004 	str	r2, [r3, #4]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  1337ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1337f0:	e5d3301e 	ldrb	r3, [r3, #30]
  1337f4:	e2033001 	and	r3, r3, #1
  1337f8:	e3530000 	cmp	r3, #0
  1337fc:	0a000062 	beq	13398c <ip_reass_chain_frag_into_datagram_and_validate+0x498>
    /* and had no holes so far */
    if (valid) {
  133800:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133804:	e3530000 	cmp	r3, #0
  133808:	0a00005d 	beq	133984 <ip_reass_chain_frag_into_datagram_and_validate+0x490>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if ((ipr->p == NULL) || (((struct ip_reass_helper*)ipr->p->payload)->start != 0)) {
  13380c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  133810:	e5933004 	ldr	r3, [r3, #4]
  133814:	e3530000 	cmp	r3, #0
  133818:	0a000006 	beq	133838 <ip_reass_chain_frag_into_datagram_and_validate+0x344>
  13381c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  133820:	e5933004 	ldr	r3, [r3, #4]
  133824:	e5933004 	ldr	r3, [r3, #4]
  133828:	e1d330b4 	ldrh	r3, [r3, #4]
  13382c:	e6ff3073 	uxth	r3, r3
  133830:	e3530000 	cmp	r3, #0
  133834:	0a000002 	beq	133844 <ip_reass_chain_frag_into_datagram_and_validate+0x350>
        valid = 0;
  133838:	e3a03000 	mov	r3, #0
  13383c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  133840:	ea00004f 	b	133984 <ip_reass_chain_frag_into_datagram_and_validate+0x490>
      } else {
        /* and check that there are no holes after this datagram */
        iprh_prev = iprh;
  133844:	e51b3008 	ldr	r3, [fp, #-8]
  133848:	e50b300c 	str	r3, [fp, #-12]
        q = iprh->next_pbuf;
  13384c:	e51b3008 	ldr	r3, [fp, #-8]
  133850:	e5933000 	ldr	r3, [r3]
  133854:	e50b3010 	str	r3, [fp, #-16]
        while (q != NULL) {
  133858:	ea000012 	b	1338a8 <ip_reass_chain_frag_into_datagram_and_validate+0x3b4>
          iprh = (struct ip_reass_helper*)q->payload;
  13385c:	e51b3010 	ldr	r3, [fp, #-16]
  133860:	e5933004 	ldr	r3, [r3, #4]
  133864:	e50b3008 	str	r3, [fp, #-8]
          if (iprh_prev->end != iprh->start) {
  133868:	e51b300c 	ldr	r3, [fp, #-12]
  13386c:	e1d330b6 	ldrh	r3, [r3, #6]
  133870:	e6ff2073 	uxth	r2, r3
  133874:	e51b3008 	ldr	r3, [fp, #-8]
  133878:	e1d330b4 	ldrh	r3, [r3, #4]
  13387c:	e6ff3073 	uxth	r3, r3
  133880:	e1520003 	cmp	r2, r3
  133884:	0a000002 	beq	133894 <ip_reass_chain_frag_into_datagram_and_validate+0x3a0>
            valid = 0;
  133888:	e3a03000 	mov	r3, #0
  13388c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
            break;
  133890:	ea000007 	b	1338b4 <ip_reass_chain_frag_into_datagram_and_validate+0x3c0>
          }
          iprh_prev = iprh;
  133894:	e51b3008 	ldr	r3, [fp, #-8]
  133898:	e50b300c 	str	r3, [fp, #-12]
          q = iprh->next_pbuf;
  13389c:	e51b3008 	ldr	r3, [fp, #-8]
  1338a0:	e5933000 	ldr	r3, [r3]
  1338a4:	e50b3010 	str	r3, [fp, #-16]
        while (q != NULL) {
  1338a8:	e51b3010 	ldr	r3, [fp, #-16]
  1338ac:	e3530000 	cmp	r3, #0
  1338b0:	1affffe9 	bne	13385c <ip_reass_chain_frag_into_datagram_and_validate+0x368>
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
  1338b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1338b8:	e3530000 	cmp	r3, #0
  1338bc:	0a000030 	beq	133984 <ip_reass_chain_frag_into_datagram_and_validate+0x490>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  1338c0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1338c4:	e5933004 	ldr	r3, [r3, #4]
  1338c8:	e3530000 	cmp	r3, #0
  1338cc:	1a000006 	bne	1338ec <ip_reass_chain_frag_into_datagram_and_validate+0x3f8>
  1338d0:	e3090c78 	movw	r0, #40056	; 0x9c78
  1338d4:	e3400014 	movt	r0, #20
  1338d8:	ebff3e0d 	bl	103114 <rt_kprintf>
  1338dc:	e3a01f71 	mov	r1, #452	; 0x1c4
  1338e0:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  1338e4:	e3400014 	movt	r0, #20
  1338e8:	ebff5de3 	bl	10b07c <sys_arch_assert>
          LWIP_ASSERT("sanity check",
  1338ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1338f0:	e5933004 	ldr	r3, [r3, #4]
  1338f4:	e5933004 	ldr	r3, [r3, #4]
  1338f8:	e51b2008 	ldr	r2, [fp, #-8]
  1338fc:	e1520003 	cmp	r2, r3
  133900:	1a000006 	bne	133920 <ip_reass_chain_frag_into_datagram_and_validate+0x42c>
  133904:	e3090c78 	movw	r0, #40056	; 0x9c78
  133908:	e3400014 	movt	r0, #20
  13390c:	ebff3e00 	bl	103114 <rt_kprintf>
  133910:	e30011c6 	movw	r1, #454	; 0x1c6
  133914:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  133918:	e3400014 	movt	r0, #20
  13391c:	ebff5dd6 	bl	10b07c <sys_arch_assert>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  133920:	e51b3008 	ldr	r3, [fp, #-8]
  133924:	e5933000 	ldr	r3, [r3]
  133928:	e3530000 	cmp	r3, #0
  13392c:	0a000006 	beq	13394c <ip_reass_chain_frag_into_datagram_and_validate+0x458>
  133930:	e3090c88 	movw	r0, #40072	; 0x9c88
  133934:	e3400014 	movt	r0, #20
  133938:	ebff3df5 	bl	103114 <rt_kprintf>
  13393c:	e3a01f72 	mov	r1, #456	; 0x1c8
  133940:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  133944:	e3400014 	movt	r0, #20
  133948:	ebff5dcb 	bl	10b07c <sys_arch_assert>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  13394c:	e51b3008 	ldr	r3, [fp, #-8]
  133950:	e1d330b6 	ldrh	r3, [r3, #6]
  133954:	e6ff2073 	uxth	r2, r3
  133958:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13395c:	e1d331bc 	ldrh	r3, [r3, #28]
  133960:	e1520003 	cmp	r2, r3
  133964:	0a000006 	beq	133984 <ip_reass_chain_frag_into_datagram_and_validate+0x490>
  133968:	e3090cac 	movw	r0, #40108	; 0x9cac
  13396c:	e3400014 	movt	r0, #20
  133970:	ebff3de7 	bl	103114 <rt_kprintf>
  133974:	e30011ca 	movw	r1, #458	; 0x1ca
  133978:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  13397c:	e3400014 	movt	r0, #20
  133980:	ebff5dbd 	bl	10b07c <sys_arch_assert>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  133984:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133988:	ea000015 	b	1339e4 <ip_reass_chain_frag_into_datagram_and_validate+0x4f0>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  13398c:	e3a03000 	mov	r3, #0
  133990:	ea000013 	b	1339e4 <ip_reass_chain_frag_into_datagram_and_validate+0x4f0>
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  133994:	e320f000 	nop	{0}
  133998:	ea000002 	b	1339a8 <ip_reass_chain_frag_into_datagram_and_validate+0x4b4>
      goto freepbuf;
  13399c:	e320f000 	nop	{0}
  1339a0:	ea000000 	b	1339a8 <ip_reass_chain_frag_into_datagram_and_validate+0x4b4>
      goto freepbuf;
  1339a4:	e320f000 	nop	{0}
  ip_reass_pbufcount -= pbuf_clen(new_p);
  1339a8:	e51b002c 	ldr	r0, [fp, #-44]	; 0xffffffd4
  1339ac:	ebff9e45 	bl	11b2c8 <pbuf_clen>
  1339b0:	e1a03000 	mov	r3, r0
  1339b4:	e1a02003 	mov	r2, r3
  1339b8:	e30f3bec 	movw	r3, #64492	; 0xfbec
  1339bc:	e3403014 	movt	r3, #20
  1339c0:	e1d330b0 	ldrh	r3, [r3]
  1339c4:	e0433002 	sub	r3, r3, r2
  1339c8:	e6ff2073 	uxth	r2, r3
  1339cc:	e30f3bec 	movw	r3, #64492	; 0xfbec
  1339d0:	e3403014 	movt	r3, #20
  1339d4:	e1c320b0 	strh	r2, [r3]
  pbuf_free(new_p);
  1339d8:	e51b002c 	ldr	r0, [fp, #-44]	; 0xffffffd4
  1339dc:	ebff9db4 	bl	11b0b4 <pbuf_free>
  return 0;
  1339e0:	e3a03000 	mov	r3, #0
#endif /* IP_REASS_CHECK_OVERLAP */
}
  1339e4:	e1a00003 	mov	r0, r3
  1339e8:	e24bd004 	sub	sp, fp, #4
  1339ec:	e8bd8800 	pop	{fp, pc}

001339f0 <ip4_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip4_reass(struct pbuf *p)
{
  1339f0:	e92d4800 	push	{fp, lr}
  1339f4:	e28db004 	add	fp, sp, #4
  1339f8:	e24dd028 	sub	sp, sp, #40	; 0x28
  1339fc:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len, clen;

  IPFRAG_STATS_INC(ip_frag.recv);
  133a00:	e3063840 	movw	r3, #26688	; 0x6840
  133a04:	e3403057 	movt	r3, #87	; 0x57
  133a08:	e1d333b2 	ldrh	r3, [r3, #50]	; 0x32
  133a0c:	e2833001 	add	r3, r3, #1
  133a10:	e6ff2073 	uxth	r2, r3
  133a14:	e3063840 	movw	r3, #26688	; 0x6840
  133a18:	e3403057 	movt	r3, #87	; 0x57
  133a1c:	e1c323b2 	strh	r2, [r3, #50]	; 0x32
  MIB2_STATS_INC(mib2.ipreasmreqds);
  133a20:	e3063840 	movw	r3, #26688	; 0x6840
  133a24:	e3403057 	movt	r3, #87	; 0x57
  133a28:	e5933160 	ldr	r3, [r3, #352]	; 0x160
  133a2c:	e2832001 	add	r2, r3, #1
  133a30:	e3063840 	movw	r3, #26688	; 0x6840
  133a34:	e3403057 	movt	r3, #87	; 0x57
  133a38:	e5832160 	str	r2, [r3, #352]	; 0x160

  fraghdr = (struct ip_hdr*)p->payload;
  133a3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  133a40:	e5933004 	ldr	r3, [r3, #4]
  133a44:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  133a48:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133a4c:	e5d33000 	ldrb	r3, [r3]
  133a50:	e203300f 	and	r3, r3, #15
  133a54:	e1a03103 	lsl	r3, r3, #2
  133a58:	e3530014 	cmp	r3, #20
  133a5c:	0a000008 	beq	133a84 <ip4_reass+0x94>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip4_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
  133a60:	e3063840 	movw	r3, #26688	; 0x6840
  133a64:	e3403057 	movt	r3, #87	; 0x57
  133a68:	e1d334b4 	ldrh	r3, [r3, #68]	; 0x44
  133a6c:	e2833001 	add	r3, r3, #1
  133a70:	e6ff2073 	uxth	r2, r3
  133a74:	e3063840 	movw	r3, #26688	; 0x6840
  133a78:	e3403057 	movt	r3, #87	; 0x57
  133a7c:	e1c324b4 	strh	r2, [r3, #68]	; 0x44
    goto nullreturn;
  133a80:	ea00011e 	b	133f00 <ip4_reass+0x510>
  }

  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  133a84:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133a88:	e1d330b6 	ldrh	r3, [r3, #6]
  133a8c:	e6ff3073 	uxth	r3, r3
  133a90:	e1a00003 	mov	r0, r3
  133a94:	ebff8b4f 	bl	1167d8 <lwip_htons>
  133a98:	e1a03000 	mov	r3, r0
  133a9c:	e7ec3053 	ubfx	r3, r3, #0, #13
  133aa0:	e6ff3073 	uxth	r3, r3
  133aa4:	e1a03183 	lsl	r3, r3, #3
  133aa8:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  133aac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133ab0:	e1d330b2 	ldrh	r3, [r3, #2]
  133ab4:	e6ff3073 	uxth	r3, r3
  133ab8:	e1a00003 	mov	r0, r3
  133abc:	ebff8b45 	bl	1167d8 <lwip_htons>
  133ac0:	e1a03000 	mov	r3, r0
  133ac4:	e1a02003 	mov	r2, r3
  133ac8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133acc:	e5d33000 	ldrb	r3, [r3]
  133ad0:	e6ff3073 	uxth	r3, r3
  133ad4:	e203300f 	and	r3, r3, #15
  133ad8:	e6ff3073 	uxth	r3, r3
  133adc:	e1a03103 	lsl	r3, r3, #2
  133ae0:	e6ff3073 	uxth	r3, r3
  133ae4:	e0423003 	sub	r3, r2, r3
  133ae8:	e14b31b8 	strh	r3, [fp, #-24]	; 0xffffffe8

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  133aec:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  133af0:	ebff9df4 	bl	11b2c8 <pbuf_clen>
  133af4:	e1a03000 	mov	r3, r0
  133af8:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  133afc:	e30f3bec 	movw	r3, #64492	; 0xfbec
  133b00:	e3403014 	movt	r3, #20
  133b04:	e1d330b0 	ldrh	r3, [r3]
  133b08:	e1a02003 	mov	r2, r3
  133b0c:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  133b10:	e0823003 	add	r3, r2, r3
  133b14:	e353000a 	cmp	r3, #10
  133b18:	da000017 	ble	133b7c <ip4_reass+0x18c>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  133b1c:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  133b20:	e1a01003 	mov	r1, r3
  133b24:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  133b28:	ebfffdac 	bl	1331e0 <ip_reass_remove_oldest_datagram>
  133b2c:	e1a03000 	mov	r3, r0
  133b30:	e3530000 	cmp	r3, #0
  133b34:	0a000007 	beq	133b58 <ip4_reass+0x168>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  133b38:	e30f3bec 	movw	r3, #64492	; 0xfbec
  133b3c:	e3403014 	movt	r3, #20
  133b40:	e1d330b0 	ldrh	r3, [r3]
  133b44:	e1a02003 	mov	r2, r3
  133b48:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  133b4c:	e0823003 	add	r3, r2, r3
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  133b50:	e353000a 	cmp	r3, #10
  133b54:	da000008 	ble	133b7c <ip4_reass+0x18c>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip4_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
  133b58:	e3063840 	movw	r3, #26688	; 0x6840
  133b5c:	e3403057 	movt	r3, #87	; 0x57
  133b60:	e1d333bc 	ldrh	r3, [r3, #60]	; 0x3c
  133b64:	e2833001 	add	r3, r3, #1
  133b68:	e6ff2073 	uxth	r2, r3
  133b6c:	e3063840 	movw	r3, #26688	; 0x6840
  133b70:	e3403057 	movt	r3, #87	; 0x57
  133b74:	e1c323bc 	strh	r2, [r3, #60]	; 0x3c
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
  133b78:	ea0000e0 	b	133f00 <ip4_reass+0x510>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  133b7c:	e30f3be8 	movw	r3, #64488	; 0xfbe8
  133b80:	e3403014 	movt	r3, #20
  133b84:	e5933000 	ldr	r3, [r3]
  133b88:	e50b300c 	str	r3, [fp, #-12]
  133b8c:	ea00001e 	b	133c0c <ip4_reass+0x21c>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  133b90:	e51b300c 	ldr	r3, [fp, #-12]
  133b94:	e5932014 	ldr	r2, [r3, #20]
  133b98:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133b9c:	e593300c 	ldr	r3, [r3, #12]
  133ba0:	e1520003 	cmp	r2, r3
  133ba4:	1a000015 	bne	133c00 <ip4_reass+0x210>
  133ba8:	e51b300c 	ldr	r3, [fp, #-12]
  133bac:	e5932018 	ldr	r2, [r3, #24]
  133bb0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133bb4:	e5933010 	ldr	r3, [r3, #16]
  133bb8:	e1520003 	cmp	r2, r3
  133bbc:	1a00000f 	bne	133c00 <ip4_reass+0x210>
  133bc0:	e51b300c 	ldr	r3, [fp, #-12]
  133bc4:	e1d320bc 	ldrh	r2, [r3, #12]
  133bc8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133bcc:	e1d330b4 	ldrh	r3, [r3, #4]
  133bd0:	e6ff3073 	uxth	r3, r3
  133bd4:	e1520003 	cmp	r2, r3
  133bd8:	1a000008 	bne	133c00 <ip4_reass+0x210>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
        lwip_ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
  133bdc:	e3063840 	movw	r3, #26688	; 0x6840
  133be0:	e3403057 	movt	r3, #87	; 0x57
  133be4:	e1d334b6 	ldrh	r3, [r3, #70]	; 0x46
  133be8:	e2833001 	add	r3, r3, #1
  133bec:	e6ff2073 	uxth	r2, r3
  133bf0:	e3063840 	movw	r3, #26688	; 0x6840
  133bf4:	e3403057 	movt	r3, #87	; 0x57
  133bf8:	e1c324b6 	strh	r2, [r3, #70]	; 0x46
      break;
  133bfc:	ea000005 	b	133c18 <ip4_reass+0x228>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  133c00:	e51b300c 	ldr	r3, [fp, #-12]
  133c04:	e5933000 	ldr	r3, [r3]
  133c08:	e50b300c 	str	r3, [fp, #-12]
  133c0c:	e51b300c 	ldr	r3, [fp, #-12]
  133c10:	e3530000 	cmp	r3, #0
  133c14:	1affffdd 	bne	133b90 <ip4_reass+0x1a0>
    }
  }

  if (ipr == NULL) {
  133c18:	e51b300c 	ldr	r3, [fp, #-12]
  133c1c:	e3530000 	cmp	r3, #0
  133c20:	1a000008 	bne	133c48 <ip4_reass+0x258>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  133c24:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  133c28:	e1a01003 	mov	r1, r3
  133c2c:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  133c30:	ebfffdc8 	bl	133358 <ip_reass_enqueue_new_datagram>
  133c34:	e50b000c 	str	r0, [fp, #-12]
    /* Bail if unable to enqueue */
    if (ipr == NULL) {
  133c38:	e51b300c 	ldr	r3, [fp, #-12]
  133c3c:	e3530000 	cmp	r3, #0
  133c40:	1a000017 	bne	133ca4 <ip4_reass+0x2b4>
      goto nullreturn;
  133c44:	ea0000ad 	b	133f00 <ip4_reass+0x510>
    }
  } else {
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
  133c48:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133c4c:	e1d330b6 	ldrh	r3, [r3, #6]
  133c50:	e6ff3073 	uxth	r3, r3
  133c54:	e1a00003 	mov	r0, r3
  133c58:	ebff8ade 	bl	1167d8 <lwip_htons>
  133c5c:	e1a03000 	mov	r3, r0
  133c60:	e7ec3053 	ubfx	r3, r3, #0, #13
  133c64:	e3530000 	cmp	r3, #0
  133c68:	1a00000d 	bne	133ca4 <ip4_reass+0x2b4>
      ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  133c6c:	e51b300c 	ldr	r3, [fp, #-12]
  133c70:	e1d330be 	ldrh	r3, [r3, #14]
  133c74:	e1a00003 	mov	r0, r3
  133c78:	ebff8ad6 	bl	1167d8 <lwip_htons>
  133c7c:	e1a03000 	mov	r3, r0
  133c80:	e7ec3053 	ubfx	r3, r3, #0, #13
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
  133c84:	e3530000 	cmp	r3, #0
  133c88:	0a000005 	beq	133ca4 <ip4_reass+0x2b4>
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  133c8c:	e51b300c 	ldr	r3, [fp, #-12]
  133c90:	e2833008 	add	r3, r3, #8
  133c94:	e3a02014 	mov	r2, #20
  133c98:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  133c9c:	e1a00003 	mov	r0, r3
  133ca0:	eb0034bb 	bl	140f94 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  133ca4:	e30f3bec 	movw	r3, #64492	; 0xfbec
  133ca8:	e3403014 	movt	r3, #20
  133cac:	e1d320b0 	ldrh	r2, [r3]
  133cb0:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  133cb4:	e0823003 	add	r3, r2, r3
  133cb8:	e6ff2073 	uxth	r2, r3
  133cbc:	e30f3bec 	movw	r3, #64492	; 0xfbec
  133cc0:	e3403014 	movt	r3, #20
  133cc4:	e1c320b0 	strh	r2, [r3]

  /* At this point, we have either created a new entry or pointing
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
  133cc8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133ccc:	e1d330b6 	ldrh	r3, [r3, #6]
  133cd0:	e6ff3073 	uxth	r3, r3
  133cd4:	e2033020 	and	r3, r3, #32
  133cd8:	e3530000 	cmp	r3, #0
  133cdc:	1a00000b 	bne	133d10 <ip4_reass+0x320>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  133ce0:	e51b300c 	ldr	r3, [fp, #-12]
  133ce4:	e5d3301e 	ldrb	r3, [r3, #30]
  133ce8:	e3833001 	orr	r3, r3, #1
  133cec:	e6ef2073 	uxtb	r2, r3
  133cf0:	e51b300c 	ldr	r3, [fp, #-12]
  133cf4:	e5c3201e 	strb	r2, [r3, #30]
    ipr->datagram_len = offset + len;
  133cf8:	e15b21b6 	ldrh	r2, [fp, #-22]	; 0xffffffea
  133cfc:	e15b31b8 	ldrh	r3, [fp, #-24]	; 0xffffffe8
  133d00:	e0823003 	add	r3, r2, r3
  133d04:	e6ff2073 	uxth	r2, r3
  133d08:	e51b300c 	ldr	r3, [fp, #-12]
  133d0c:	e1c321bc 	strh	r2, [r3, #28]
     ("ip4_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  133d10:	e51b1028 	ldr	r1, [fp, #-40]	; 0xffffffd8
  133d14:	e51b000c 	ldr	r0, [fp, #-12]
  133d18:	ebfffdf5 	bl	1334f4 <ip_reass_chain_frag_into_datagram_and_validate>
  133d1c:	e1a03000 	mov	r3, r0
  133d20:	e3530000 	cmp	r3, #0
  133d24:	0a000073 	beq	133ef8 <ip4_reass+0x508>
    struct ip_reassdata *ipr_prev;
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  133d28:	e51b300c 	ldr	r3, [fp, #-12]
  133d2c:	e1d331bc 	ldrh	r3, [r3, #28]
  133d30:	e2833014 	add	r3, r3, #20
  133d34:	e6ff2073 	uxth	r2, r3
  133d38:	e51b300c 	ldr	r3, [fp, #-12]
  133d3c:	e1c321bc 	strh	r2, [r3, #28]

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  133d40:	e51b300c 	ldr	r3, [fp, #-12]
  133d44:	e5933004 	ldr	r3, [r3, #4]
  133d48:	e5933004 	ldr	r3, [r3, #4]
  133d4c:	e5933000 	ldr	r3, [r3]
  133d50:	e50b3008 	str	r3, [fp, #-8]

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
  133d54:	e51b300c 	ldr	r3, [fp, #-12]
  133d58:	e5933004 	ldr	r3, [r3, #4]
  133d5c:	e5933004 	ldr	r3, [r3, #4]
  133d60:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  133d64:	e51b300c 	ldr	r3, [fp, #-12]
  133d68:	e2833008 	add	r3, r3, #8
  133d6c:	e3a02014 	mov	r2, #20
  133d70:	e1a01003 	mov	r1, r3
  133d74:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  133d78:	eb003485 	bl	140f94 <memcpy>
    IPH_LEN_SET(fraghdr, lwip_htons(ipr->datagram_len));
  133d7c:	e51b300c 	ldr	r3, [fp, #-12]
  133d80:	e1d331bc 	ldrh	r3, [r3, #28]
  133d84:	e1a00003 	mov	r0, r3
  133d88:	ebff8a92 	bl	1167d8 <lwip_htons>
  133d8c:	e1a03000 	mov	r3, r0
  133d90:	e1a02003 	mov	r2, r3
  133d94:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133d98:	e1c320b2 	strh	r2, [r3, #2]
    IPH_OFFSET_SET(fraghdr, 0);
  133d9c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133da0:	e3a02000 	mov	r2, #0
  133da4:	e5c32006 	strb	r2, [r3, #6]
  133da8:	e3a02000 	mov	r2, #0
  133dac:	e5c32007 	strb	r2, [r3, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
  133db0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133db4:	e3a02000 	mov	r2, #0
  133db8:	e5c3200a 	strb	r2, [r3, #10]
  133dbc:	e3a02000 	mov	r2, #0
  133dc0:	e5c3200b 	strb	r2, [r3, #11]
    /* @todo: do we need to set/calculate the correct checksum? */
#if CHECKSUM_GEN_IP
    IF__NETIF_CHECKSUM_ENABLED(ip_current_input_netif(), NETIF_CHECKSUM_GEN_IP) {
      IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  133dc4:	e3a01014 	mov	r1, #20
  133dc8:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  133dcc:	ebff9390 	bl	118c14 <inet_chksum>
  133dd0:	e1a03000 	mov	r3, r0
  133dd4:	e1a02003 	mov	r2, r3
  133dd8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  133ddc:	e1c320ba 	strh	r2, [r3, #10]
    }
#endif /* CHECKSUM_GEN_IP */

    p = ipr->p;
  133de0:	e51b300c 	ldr	r3, [fp, #-12]
  133de4:	e5933004 	ldr	r3, [r3, #4]
  133de8:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8

    /* chain together the pbufs contained within the reass_data list. */
    while (r != NULL) {
  133dec:	ea00000b 	b	133e20 <ip4_reass+0x430>
      iprh = (struct ip_reass_helper*)r->payload;
  133df0:	e51b3008 	ldr	r3, [fp, #-8]
  133df4:	e5933004 	ldr	r3, [r3, #4]
  133df8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

      /* hide the ip header for every succeeding fragment */
      pbuf_header(r, -IP_HLEN);
  133dfc:	e3e01013 	mvn	r1, #19
  133e00:	e51b0008 	ldr	r0, [fp, #-8]
  133e04:	ebff9c8c 	bl	11b03c <pbuf_header>
      pbuf_cat(p, r);
  133e08:	e51b1008 	ldr	r1, [fp, #-8]
  133e0c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  133e10:	ebff9d5e 	bl	11b390 <pbuf_cat>
      r = iprh->next_pbuf;
  133e14:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  133e18:	e5933000 	ldr	r3, [r3]
  133e1c:	e50b3008 	str	r3, [fp, #-8]
    while (r != NULL) {
  133e20:	e51b3008 	ldr	r3, [fp, #-8]
  133e24:	e3530000 	cmp	r3, #0
  133e28:	1afffff0 	bne	133df0 <ip4_reass+0x400>
    }

    /* find the previous entry in the linked list */
    if (ipr == reassdatagrams) {
  133e2c:	e30f3be8 	movw	r3, #64488	; 0xfbe8
  133e30:	e3403014 	movt	r3, #20
  133e34:	e5933000 	ldr	r3, [r3]
  133e38:	e51b200c 	ldr	r2, [fp, #-12]
  133e3c:	e1520003 	cmp	r2, r3
  133e40:	1a000002 	bne	133e50 <ip4_reass+0x460>
      ipr_prev = NULL;
  133e44:	e3a03000 	mov	r3, #0
  133e48:	e50b3010 	str	r3, [fp, #-16]
  133e4c:	ea000011 	b	133e98 <ip4_reass+0x4a8>
    } else {
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
  133e50:	e30f3be8 	movw	r3, #64488	; 0xfbe8
  133e54:	e3403014 	movt	r3, #20
  133e58:	e5933000 	ldr	r3, [r3]
  133e5c:	e50b3010 	str	r3, [fp, #-16]
  133e60:	ea000007 	b	133e84 <ip4_reass+0x494>
        if (ipr_prev->next == ipr) {
  133e64:	e51b3010 	ldr	r3, [fp, #-16]
  133e68:	e5933000 	ldr	r3, [r3]
  133e6c:	e51b200c 	ldr	r2, [fp, #-12]
  133e70:	e1520003 	cmp	r2, r3
  133e74:	0a000006 	beq	133e94 <ip4_reass+0x4a4>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
  133e78:	e51b3010 	ldr	r3, [fp, #-16]
  133e7c:	e5933000 	ldr	r3, [r3]
  133e80:	e50b3010 	str	r3, [fp, #-16]
  133e84:	e51b3010 	ldr	r3, [fp, #-16]
  133e88:	e3530000 	cmp	r3, #0
  133e8c:	1afffff4 	bne	133e64 <ip4_reass+0x474>
  133e90:	ea000000 	b	133e98 <ip4_reass+0x4a8>
          break;
  133e94:	e320f000 	nop	{0}
        }
      }
    }

    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  133e98:	e51b1010 	ldr	r1, [fp, #-16]
  133e9c:	e51b000c 	ldr	r0, [fp, #-12]
  133ea0:	ebfffd6e 	bl	133460 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  133ea4:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  133ea8:	ebff9d06 	bl	11b2c8 <pbuf_clen>
  133eac:	e1a03000 	mov	r3, r0
  133eb0:	e1a02003 	mov	r2, r3
  133eb4:	e30f3bec 	movw	r3, #64492	; 0xfbec
  133eb8:	e3403014 	movt	r3, #20
  133ebc:	e1d330b0 	ldrh	r3, [r3]
  133ec0:	e0433002 	sub	r3, r3, r2
  133ec4:	e6ff2073 	uxth	r2, r3
  133ec8:	e30f3bec 	movw	r3, #64492	; 0xfbec
  133ecc:	e3403014 	movt	r3, #20
  133ed0:	e1c320b0 	strh	r2, [r3]

    MIB2_STATS_INC(mib2.ipreasmoks);
  133ed4:	e3063840 	movw	r3, #26688	; 0x6840
  133ed8:	e3403057 	movt	r3, #87	; 0x57
  133edc:	e593314c 	ldr	r3, [r3, #332]	; 0x14c
  133ee0:	e2832001 	add	r2, r3, #1
  133ee4:	e3063840 	movw	r3, #26688	; 0x6840
  133ee8:	e3403057 	movt	r3, #87	; 0x57
  133eec:	e583214c 	str	r2, [r3, #332]	; 0x14c

    /* Return the pbuf chain */
    return p;
  133ef0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  133ef4:	ea00000c 	b	133f2c <ip4_reass+0x53c>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  133ef8:	e3a03000 	mov	r3, #0
  133efc:	ea00000a 	b	133f2c <ip4_reass+0x53c>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip4_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  133f00:	e3063840 	movw	r3, #26688	; 0x6840
  133f04:	e3403057 	movt	r3, #87	; 0x57
  133f08:	e1d333b6 	ldrh	r3, [r3, #54]	; 0x36
  133f0c:	e2833001 	add	r3, r3, #1
  133f10:	e6ff2073 	uxth	r2, r3
  133f14:	e3063840 	movw	r3, #26688	; 0x6840
  133f18:	e3403057 	movt	r3, #87	; 0x57
  133f1c:	e1c323b6 	strh	r2, [r3, #54]	; 0x36
  pbuf_free(p);
  133f20:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  133f24:	ebff9c62 	bl	11b0b4 <pbuf_free>
  return NULL;
  133f28:	e3a03000 	mov	r3, #0
}
  133f2c:	e1a00003 	mov	r0, r3
  133f30:	e24bd004 	sub	sp, fp, #4
  133f34:	e8bd8800 	pop	{fp, pc}

00133f38 <ip_frag_alloc_pbuf_custom_ref>:
#if IP_FRAG
#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref*
ip_frag_alloc_pbuf_custom_ref(void)
{
  133f38:	e92d4800 	push	{fp, lr}
  133f3c:	e28db004 	add	fp, sp, #4
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
  133f40:	e3002286 	movw	r2, #646	; 0x286
  133f44:	e3091b7c 	movw	r1, #39804	; 0x9b7c
  133f48:	e3401014 	movt	r1, #20
  133f4c:	e3a00006 	mov	r0, #6
  133f50:	ebff94e1 	bl	1192dc <memp_malloc_fn>
  133f54:	e1a03000 	mov	r3, r0
}
  133f58:	e1a00003 	mov	r0, r3
  133f5c:	e8bd8800 	pop	{fp, pc}

00133f60 <ip_frag_free_pbuf_custom_ref>:

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
  133f60:	e92d4800 	push	{fp, lr}
  133f64:	e28db004 	add	fp, sp, #4
  133f68:	e24dd008 	sub	sp, sp, #8
  133f6c:	e50b0008 	str	r0, [fp, #-8]
  LWIP_ASSERT("p != NULL", p != NULL);
  133f70:	e51b3008 	ldr	r3, [fp, #-8]
  133f74:	e3530000 	cmp	r3, #0
  133f78:	1a000006 	bne	133f98 <ip_frag_free_pbuf_custom_ref+0x38>
  133f7c:	e3090cdc 	movw	r0, #40156	; 0x9cdc
  133f80:	e3400014 	movt	r0, #20
  133f84:	ebff3c62 	bl	103114 <rt_kprintf>
  133f88:	e300128d 	movw	r1, #653	; 0x28d
  133f8c:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  133f90:	e3400014 	movt	r0, #20
  133f94:	ebff5c38 	bl	10b07c <sys_arch_assert>
  memp_free(MEMP_FRAG_PBUF, p);
  133f98:	e51b1008 	ldr	r1, [fp, #-8]
  133f9c:	e3a00006 	mov	r0, #6
  133fa0:	ebff9535 	bl	11947c <memp_free>
}
  133fa4:	e320f000 	nop	{0}
  133fa8:	e24bd004 	sub	sp, fp, #4
  133fac:	e8bd8800 	pop	{fp, pc}

00133fb0 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
  133fb0:	e92d4800 	push	{fp, lr}
  133fb4:	e28db004 	add	fp, sp, #4
  133fb8:	e24dd010 	sub	sp, sp, #16
  133fbc:	e50b0010 	str	r0, [fp, #-16]
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  133fc0:	e51b3010 	ldr	r3, [fp, #-16]
  133fc4:	e50b3008 	str	r3, [fp, #-8]
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  133fc8:	e51b3008 	ldr	r3, [fp, #-8]
  133fcc:	e3530000 	cmp	r3, #0
  133fd0:	1a000006 	bne	133ff0 <ipfrag_free_pbuf_custom+0x40>
  133fd4:	e3090ce8 	movw	r0, #40168	; 0x9ce8
  133fd8:	e3400014 	movt	r0, #20
  133fdc:	ebff3c4c 	bl	103114 <rt_kprintf>
  133fe0:	e3001297 	movw	r1, #663	; 0x297
  133fe4:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  133fe8:	e3400014 	movt	r0, #20
  133fec:	ebff5c22 	bl	10b07c <sys_arch_assert>
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  133ff0:	e51b2008 	ldr	r2, [fp, #-8]
  133ff4:	e51b3010 	ldr	r3, [fp, #-16]
  133ff8:	e1520003 	cmp	r2, r3
  133ffc:	0a000006 	beq	13401c <ipfrag_free_pbuf_custom+0x6c>
  134000:	e3090cf4 	movw	r0, #40180	; 0x9cf4
  134004:	e3400014 	movt	r0, #20
  134008:	ebff3c41 	bl	103114 <rt_kprintf>
  13400c:	e3a01fa6 	mov	r1, #664	; 0x298
  134010:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  134014:	e3400014 	movt	r0, #20
  134018:	ebff5c17 	bl	10b07c <sys_arch_assert>
  if (pcr->original != NULL) {
  13401c:	e51b3008 	ldr	r3, [fp, #-8]
  134020:	e5933014 	ldr	r3, [r3, #20]
  134024:	e3530000 	cmp	r3, #0
  134028:	0a000003 	beq	13403c <ipfrag_free_pbuf_custom+0x8c>
    pbuf_free(pcr->original);
  13402c:	e51b3008 	ldr	r3, [fp, #-8]
  134030:	e5933014 	ldr	r3, [r3, #20]
  134034:	e1a00003 	mov	r0, r3
  134038:	ebff9c1d 	bl	11b0b4 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
  13403c:	e51b0008 	ldr	r0, [fp, #-8]
  134040:	ebffffc6 	bl	133f60 <ip_frag_free_pbuf_custom_ref>
}
  134044:	e320f000 	nop	{0}
  134048:	e24bd004 	sub	sp, fp, #4
  13404c:	e8bd8800 	pop	{fp, pc}

00134050 <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
  134050:	e92d4800 	push	{fp, lr}
  134054:	e28db004 	add	fp, sp, #4
  134058:	e24dd048 	sub	sp, sp, #72	; 0x48
  13405c:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
  134060:	e50b103c 	str	r1, [fp, #-60]	; 0xffffffc4
  134064:	e50b2040 	str	r2, [fp, #-64]	; 0xffffffc0
  struct pbuf *rambuf;
#if !LWIP_NETIF_TX_SINGLE_PBUF
  struct pbuf *newpbuf;
  u16_t newpbuflen = 0;
  134068:	e3a03000 	mov	r3, #0
  13406c:	e14b30b6 	strh	r3, [fp, #-6]
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
  134070:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  134074:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  134078:	e2433014 	sub	r3, r3, #20
  13407c:	e2832007 	add	r2, r3, #7
  134080:	e3530000 	cmp	r3, #0
  134084:	b1a03002 	movlt	r3, r2
  134088:	a1a03003 	movge	r3, r3
  13408c:	e1a031c3 	asr	r3, r3, #3
  134090:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
  u16_t left, fragsize;
  u16_t ofo;
  int last;
  u16_t poff = IP_HLEN;
  134094:	e3a03014 	mov	r3, #20
  134098:	e14b30be 	strh	r3, [fp, #-14]
  u16_t tmp;

  original_iphdr = (struct ip_hdr *)p->payload;
  13409c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1340a0:	e5933004 	ldr	r3, [r3, #4]
  1340a4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
  iphdr = original_iphdr;
  1340a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1340ac:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
  1340b0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1340b4:	e5d33000 	ldrb	r3, [r3]
  1340b8:	e203300f 	and	r3, r3, #15
  1340bc:	e1a03103 	lsl	r3, r3, #2
  1340c0:	e3530014 	cmp	r3, #20
  1340c4:	0a000008 	beq	1340ec <ip4_frag+0x9c>
  1340c8:	e3090d00 	movw	r0, #40192	; 0x9d00
  1340cc:	e3400014 	movt	r0, #20
  1340d0:	ebff3c0f 	bl	103114 <rt_kprintf>
  1340d4:	e3a01d0b 	mov	r1, #704	; 0x2c0
  1340d8:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  1340dc:	e3400014 	movt	r0, #20
  1340e0:	ebff5be5 	bl	10b07c <sys_arch_assert>
  1340e4:	e3e03005 	mvn	r3, #5
  1340e8:	ea0000ed 	b	1344a4 <ip4_frag+0x454>

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
  1340ec:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1340f0:	e1d330b6 	ldrh	r3, [r3, #6]
  1340f4:	e6ff3073 	uxth	r3, r3
  1340f8:	e1a00003 	mov	r0, r3
  1340fc:	ebff89b5 	bl	1167d8 <lwip_htons>
  134100:	e1a03000 	mov	r3, r0
  134104:	e14b31b0 	strh	r3, [fp, #-16]
  ofo = tmp & IP_OFFMASK;
  134108:	e15b31b0 	ldrh	r3, [fp, #-16]
  13410c:	e7ec3053 	ubfx	r3, r3, #0, #13
  134110:	e14b30bc 	strh	r3, [fp, #-12]
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
  134114:	e15b31b0 	ldrh	r3, [fp, #-16]
  134118:	e2033a02 	and	r3, r3, #8192	; 0x2000
  13411c:	e3530000 	cmp	r3, #0
  134120:	0a000008 	beq	134148 <ip4_frag+0xf8>
  134124:	e3090d28 	movw	r0, #40232	; 0x9d28
  134128:	e3400014 	movt	r0, #20
  13412c:	ebff3bf8 	bl	103114 <rt_kprintf>
  134130:	e30012c5 	movw	r1, #709	; 0x2c5
  134134:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  134138:	e3400014 	movt	r0, #20
  13413c:	ebff5bce 	bl	10b07c <sys_arch_assert>
  134140:	e3e03005 	mvn	r3, #5
  134144:	ea0000d6 	b	1344a4 <ip4_frag+0x454>

  left = p->tot_len - IP_HLEN;
  134148:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  13414c:	e1d330b8 	ldrh	r3, [r3, #8]
  134150:	e2433014 	sub	r3, r3, #20
  134154:	e14b30ba 	strh	r3, [fp, #-10]

  while (left) {
  134158:	ea0000bc 	b	134450 <ip4_frag+0x400>
    /* Fill this fragment */
    fragsize = LWIP_MIN(left, nfb * 8);
  13415c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  134160:	e1a02183 	lsl	r2, r3, #3
  134164:	e15b30ba 	ldrh	r3, [fp, #-10]
  134168:	e1520003 	cmp	r2, r3
  13416c:	b1a03002 	movlt	r3, r2
  134170:	a1a03003 	movge	r3, r3
  134174:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
  134178:	e3a02000 	mov	r2, #0
  13417c:	e3a01014 	mov	r1, #20
  134180:	e3a00002 	mov	r0, #2
  134184:	ebff98c3 	bl	11a498 <pbuf_alloc>
  134188:	e50b0024 	str	r0, [fp, #-36]	; 0xffffffdc
    if (rambuf == NULL) {
  13418c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  134190:	e3530000 	cmp	r3, #0
  134194:	0a0000b9 	beq	134480 <ip4_frag+0x430>
      goto memerr;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
  134198:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  13419c:	e1d330ba 	ldrh	r3, [r3, #10]
  1341a0:	e3530013 	cmp	r3, #19
  1341a4:	8a000006 	bhi	1341c4 <ip4_frag+0x174>
  1341a8:	e3090d44 	movw	r0, #40260	; 0x9d44
  1341ac:	e3400014 	movt	r0, #20
  1341b0:	ebff3bd7 	bl	103114 <rt_kprintf>
  1341b4:	e3a01fba 	mov	r1, #744	; 0x2e8
  1341b8:	e3090b7c 	movw	r0, #39804	; 0x9b7c
  1341bc:	e3400014 	movt	r0, #20
  1341c0:	ebff5bad 	bl	10b07c <sys_arch_assert>
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
  1341c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1341c8:	e5933004 	ldr	r3, [r3, #4]
  1341cc:	e3a02014 	mov	r2, #20
  1341d0:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  1341d4:	e1a00003 	mov	r0, r3
  1341d8:	eb00336d 	bl	140f94 <memcpy>
    iphdr = (struct ip_hdr *)rambuf->payload;
  1341dc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1341e0:	e5933004 	ldr	r3, [r3, #4]
  1341e4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    left_to_copy = fragsize;
  1341e8:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  1341ec:	e14b30b8 	strh	r3, [fp, #-8]
    while (left_to_copy) {
  1341f0:	ea000049 	b	13431c <ip4_frag+0x2cc>
      struct pbuf_custom_ref *pcr;
      u16_t plen = p->len - poff;
  1341f4:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  1341f8:	e1d320ba 	ldrh	r2, [r3, #10]
  1341fc:	e15b30be 	ldrh	r3, [fp, #-14]
  134200:	e0423003 	sub	r3, r2, r3
  134204:	e14b32ba 	strh	r3, [fp, #-42]	; 0xffffffd6
      newpbuflen = LWIP_MIN(left_to_copy, plen);
  134208:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
  13420c:	e15b30b8 	ldrh	r3, [fp, #-8]
  134210:	e1520003 	cmp	r2, r3
  134214:	31a03002 	movcc	r3, r2
  134218:	21a03003 	movcs	r3, r3
  13421c:	e14b30b6 	strh	r3, [fp, #-6]
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
  134220:	e15b30b6 	ldrh	r3, [fp, #-6]
  134224:	e3530000 	cmp	r3, #0
  134228:	1a000005 	bne	134244 <ip4_frag+0x1f4>
        poff = 0;
  13422c:	e3a03000 	mov	r3, #0
  134230:	e14b30be 	strh	r3, [fp, #-14]
        p = p->next;
  134234:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  134238:	e5933000 	ldr	r3, [r3]
  13423c:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
        continue;
  134240:	ea000035 	b	13431c <ip4_frag+0x2cc>
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
  134244:	ebffff3b 	bl	133f38 <ip_frag_alloc_pbuf_custom_ref>
  134248:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
      if (pcr == NULL) {
  13424c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134250:	e3530000 	cmp	r3, #0
  134254:	1a000002 	bne	134264 <ip4_frag+0x214>
        pbuf_free(rambuf);
  134258:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  13425c:	ebff9b94 	bl	11b0b4 <pbuf_free>
        goto memerr;
  134260:	ea000087 	b	134484 <ip4_frag+0x434>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
  134264:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
        (u8_t*)p->payload + poff, newpbuflen);
  134268:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  13426c:	e5932004 	ldr	r2, [r3, #4]
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
  134270:	e15b30be 	ldrh	r3, [fp, #-14]
  134274:	e0823003 	add	r3, r2, r3
  134278:	e15b10b6 	ldrh	r1, [fp, #-6]
  13427c:	e15b20b6 	ldrh	r2, [fp, #-6]
  134280:	e58d2004 	str	r2, [sp, #4]
  134284:	e58d3000 	str	r3, [sp]
  134288:	e1a03000 	mov	r3, r0
  13428c:	e3a02002 	mov	r2, #2
  134290:	e3a00004 	mov	r0, #4
  134294:	ebff99e4 	bl	11aa2c <pbuf_alloced_custom>
  134298:	e50b0034 	str	r0, [fp, #-52]	; 0xffffffcc
      if (newpbuf == NULL) {
  13429c:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  1342a0:	e3530000 	cmp	r3, #0
  1342a4:	1a000004 	bne	1342bc <ip4_frag+0x26c>
        ip_frag_free_pbuf_custom_ref(pcr);
  1342a8:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
  1342ac:	ebffff2b 	bl	133f60 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
  1342b0:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  1342b4:	ebff9b7e 	bl	11b0b4 <pbuf_free>
        goto memerr;
  1342b8:	ea000071 	b	134484 <ip4_frag+0x434>
      }
      pbuf_ref(p);
  1342bc:	e51b0038 	ldr	r0, [fp, #-56]	; 0xffffffc8
  1342c0:	ebff9c15 	bl	11b31c <pbuf_ref>
      pcr->original = p;
  1342c4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1342c8:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
  1342cc:	e5832014 	str	r2, [r3, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
  1342d0:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  1342d4:	e3033fb0 	movw	r3, #16304	; 0x3fb0
  1342d8:	e3403013 	movt	r3, #19
  1342dc:	e5823010 	str	r3, [r2, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
  1342e0:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  1342e4:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  1342e8:	ebff9c28 	bl	11b390 <pbuf_cat>
      left_to_copy -= newpbuflen;
  1342ec:	e15b20b8 	ldrh	r2, [fp, #-8]
  1342f0:	e15b30b6 	ldrh	r3, [fp, #-6]
  1342f4:	e0423003 	sub	r3, r2, r3
  1342f8:	e14b30b8 	strh	r3, [fp, #-8]
      if (left_to_copy) {
  1342fc:	e15b30b8 	ldrh	r3, [fp, #-8]
  134300:	e3530000 	cmp	r3, #0
  134304:	0a000004 	beq	13431c <ip4_frag+0x2cc>
        poff = 0;
  134308:	e3a03000 	mov	r3, #0
  13430c:	e14b30be 	strh	r3, [fp, #-14]
        p = p->next;
  134310:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
  134314:	e5933000 	ldr	r3, [r3]
  134318:	e50b3038 	str	r3, [fp, #-56]	; 0xffffffc8
    while (left_to_copy) {
  13431c:	e15b30b8 	ldrh	r3, [fp, #-8]
  134320:	e3530000 	cmp	r3, #0
  134324:	1affffb2 	bne	1341f4 <ip4_frag+0x1a4>
      }
    }
    poff += newpbuflen;
  134328:	e15b20be 	ldrh	r2, [fp, #-14]
  13432c:	e15b30b6 	ldrh	r3, [fp, #-6]
  134330:	e0823003 	add	r3, r2, r3
  134334:	e14b30be 	strh	r3, [fp, #-14]
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

    /* Correct header */
    last = (left <= netif->mtu - IP_HLEN);
  134338:	e15b20ba 	ldrh	r2, [fp, #-10]
  13433c:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  134340:	e1d333b8 	ldrh	r3, [r3, #56]	; 0x38
  134344:	e2433014 	sub	r3, r3, #20
  134348:	e1520003 	cmp	r2, r3
  13434c:	d3a03001 	movle	r3, #1
  134350:	c3a03000 	movgt	r3, #0
  134354:	e6ef3073 	uxtb	r3, r3
  134358:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8

    /* Set new offset and MF flag */
    tmp = (IP_OFFMASK & (ofo));
  13435c:	e15b30bc 	ldrh	r3, [fp, #-12]
  134360:	e7ec3053 	ubfx	r3, r3, #0, #13
  134364:	e14b31b0 	strh	r3, [fp, #-16]
    if (!last) {
  134368:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13436c:	e3530000 	cmp	r3, #0
  134370:	1a000002 	bne	134380 <ip4_frag+0x330>
      tmp = tmp | IP_MF;
  134374:	e15b31b0 	ldrh	r3, [fp, #-16]
  134378:	e3833a02 	orr	r3, r3, #8192	; 0x2000
  13437c:	e14b31b0 	strh	r3, [fp, #-16]
    }
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
  134380:	e15b31b0 	ldrh	r3, [fp, #-16]
  134384:	e1a00003 	mov	r0, r3
  134388:	ebff8912 	bl	1167d8 <lwip_htons>
  13438c:	e1a03000 	mov	r3, r0
  134390:	e1a02003 	mov	r2, r3
  134394:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  134398:	e1c320b6 	strh	r2, [r3, #6]
    IPH_LEN_SET(iphdr, lwip_htons(fragsize + IP_HLEN));
  13439c:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  1343a0:	e2833014 	add	r3, r3, #20
  1343a4:	e6ff3073 	uxth	r3, r3
  1343a8:	e1a00003 	mov	r0, r3
  1343ac:	ebff8909 	bl	1167d8 <lwip_htons>
  1343b0:	e1a03000 	mov	r3, r0
  1343b4:	e1a02003 	mov	r2, r3
  1343b8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1343bc:	e1c320b2 	strh	r2, [r3, #2]
    IPH_CHKSUM_SET(iphdr, 0);
  1343c0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1343c4:	e3a02000 	mov	r2, #0
  1343c8:	e5c3200a 	strb	r2, [r3, #10]
  1343cc:	e3a02000 	mov	r2, #0
  1343d0:	e5c3200b 	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  1343d4:	e3a01014 	mov	r1, #20
  1343d8:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  1343dc:	ebff920c 	bl	118c14 <inet_chksum>
  1343e0:	e1a03000 	mov	r3, r0
  1343e4:	e1a02003 	mov	r2, r3
  1343e8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1343ec:	e1c320ba 	strh	r2, [r3, #10]
#endif /* CHECKSUM_GEN_IP */

    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
  1343f0:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
  1343f4:	e5933014 	ldr	r3, [r3, #20]
  1343f8:	e51b2040 	ldr	r2, [fp, #-64]	; 0xffffffc0
  1343fc:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  134400:	e51b003c 	ldr	r0, [fp, #-60]	; 0xffffffc4
  134404:	e12fff33 	blx	r3
    IPFRAG_STATS_INC(ip_frag.xmit);
  134408:	e3063840 	movw	r3, #26688	; 0x6840
  13440c:	e3403057 	movt	r3, #87	; 0x57
  134410:	e1d333b0 	ldrh	r3, [r3, #48]	; 0x30
  134414:	e2833001 	add	r3, r3, #1
  134418:	e6ff2073 	uxth	r2, r3
  13441c:	e3063840 	movw	r3, #26688	; 0x6840
  134420:	e3403057 	movt	r3, #87	; 0x57
  134424:	e1c323b0 	strh	r2, [r3, #48]	; 0x30
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */

    pbuf_free(rambuf);
  134428:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
  13442c:	ebff9b20 	bl	11b0b4 <pbuf_free>
    left -= fragsize;
  134430:	e15b20ba 	ldrh	r2, [fp, #-10]
  134434:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
  134438:	e0423003 	sub	r3, r2, r3
  13443c:	e14b30ba 	strh	r3, [fp, #-10]
    ofo += nfb;
  134440:	e15b20bc 	ldrh	r2, [fp, #-12]
  134444:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  134448:	e0823003 	add	r3, r2, r3
  13444c:	e14b30bc 	strh	r3, [fp, #-12]
  while (left) {
  134450:	e15b30ba 	ldrh	r3, [fp, #-10]
  134454:	e3530000 	cmp	r3, #0
  134458:	1affff3f 	bne	13415c <ip4_frag+0x10c>
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  13445c:	e3063840 	movw	r3, #26688	; 0x6840
  134460:	e3403057 	movt	r3, #87	; 0x57
  134464:	e5933154 	ldr	r3, [r3, #340]	; 0x154
  134468:	e2832001 	add	r2, r3, #1
  13446c:	e3063840 	movw	r3, #26688	; 0x6840
  134470:	e3403057 	movt	r3, #87	; 0x57
  134474:	e5832154 	str	r2, [r3, #340]	; 0x154
  return ERR_OK;
  134478:	e3a03000 	mov	r3, #0
  13447c:	ea000008 	b	1344a4 <ip4_frag+0x454>
      goto memerr;
  134480:	e320f000 	nop	{0}
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  134484:	e3063840 	movw	r3, #26688	; 0x6840
  134488:	e3403057 	movt	r3, #87	; 0x57
  13448c:	e5933158 	ldr	r3, [r3, #344]	; 0x158
  134490:	e2832001 	add	r2, r3, #1
  134494:	e3063840 	movw	r3, #26688	; 0x6840
  134498:	e3403057 	movt	r3, #87	; 0x57
  13449c:	e5832158 	str	r2, [r3, #344]	; 0x158
  return ERR_MEM;
  1344a0:	e3e03000 	mvn	r3, #0
}
  1344a4:	e1a00003 	mov	r0, r3
  1344a8:	e24bd004 	sub	sp, fp, #4
  1344ac:	e8bd8800 	pop	{fp, pc}

001344b0 <ping_prepare_echo>:
    rt_uint8_t addr0, addr1, addr2, addr3;
};

/** Prepare a echo ICMP request */
static void ping_prepare_echo( struct icmp_echo_hdr *iecho, u16_t len)
{
  1344b0:	e92d4800 	push	{fp, lr}
  1344b4:	e28db004 	add	fp, sp, #4
  1344b8:	e24dd010 	sub	sp, sp, #16
  1344bc:	e50b0010 	str	r0, [fp, #-16]
  1344c0:	e1a03001 	mov	r3, r1
  1344c4:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    size_t i;
    size_t data_len = len - sizeof(struct icmp_echo_hdr);
  1344c8:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  1344cc:	e2433008 	sub	r3, r3, #8
  1344d0:	e50b300c 	str	r3, [fp, #-12]

    ICMPH_TYPE_SET(iecho, ICMP_ECHO);
  1344d4:	e51b3010 	ldr	r3, [fp, #-16]
  1344d8:	e3a02008 	mov	r2, #8
  1344dc:	e5c32000 	strb	r2, [r3]
    ICMPH_CODE_SET(iecho, 0);
  1344e0:	e51b3010 	ldr	r3, [fp, #-16]
  1344e4:	e3a02000 	mov	r2, #0
  1344e8:	e5c32001 	strb	r2, [r3, #1]
    iecho->chksum = 0;
  1344ec:	e51b3010 	ldr	r3, [fp, #-16]
  1344f0:	e3a02000 	mov	r2, #0
  1344f4:	e5c32002 	strb	r2, [r3, #2]
  1344f8:	e3a02000 	mov	r2, #0
  1344fc:	e5c32003 	strb	r2, [r3, #3]
    iecho->id     = PING_ID;
  134500:	e51b2010 	ldr	r2, [fp, #-16]
  134504:	e3a03000 	mov	r3, #0
  134508:	e1e03003 	mvn	r3, r3
  13450c:	e2033050 	and	r3, r3, #80	; 0x50
  134510:	e1e03003 	mvn	r3, r3
  134514:	e5c23004 	strb	r3, [r2, #4]
  134518:	e3a03000 	mov	r3, #0
  13451c:	e1e03003 	mvn	r3, r3
  134520:	e2033050 	and	r3, r3, #80	; 0x50
  134524:	e1e03003 	mvn	r3, r3
  134528:	e5c23005 	strb	r3, [r2, #5]
    iecho->seqno  = htons(++ping_seq_num);
  13452c:	e30f3bee 	movw	r3, #64494	; 0xfbee
  134530:	e3403014 	movt	r3, #20
  134534:	e1d330b0 	ldrh	r3, [r3]
  134538:	e2833001 	add	r3, r3, #1
  13453c:	e6ff2073 	uxth	r2, r3
  134540:	e30f3bee 	movw	r3, #64494	; 0xfbee
  134544:	e3403014 	movt	r3, #20
  134548:	e1c320b0 	strh	r2, [r3]
  13454c:	e30f3bee 	movw	r3, #64494	; 0xfbee
  134550:	e3403014 	movt	r3, #20
  134554:	e1d330b0 	ldrh	r3, [r3]
  134558:	e1a00003 	mov	r0, r3
  13455c:	ebff889d 	bl	1167d8 <lwip_htons>
  134560:	e1a03000 	mov	r3, r0
  134564:	e1a02003 	mov	r2, r3
  134568:	e51b3010 	ldr	r3, [fp, #-16]
  13456c:	e1c320b6 	strh	r2, [r3, #6]

    /* fill the additional data buffer with some data */
    for (i = 0; i < data_len; i++)
  134570:	e3a03000 	mov	r3, #0
  134574:	e50b3008 	str	r3, [fp, #-8]
  134578:	ea000009 	b	1345a4 <ping_prepare_echo+0xf4>
    {
        ((char*) iecho)[sizeof(struct icmp_echo_hdr) + i] = (char) i;
  13457c:	e51b3008 	ldr	r3, [fp, #-8]
  134580:	e2833008 	add	r3, r3, #8
  134584:	e51b2010 	ldr	r2, [fp, #-16]
  134588:	e0823003 	add	r3, r2, r3
  13458c:	e51b2008 	ldr	r2, [fp, #-8]
  134590:	e6ef2072 	uxtb	r2, r2
  134594:	e5c32000 	strb	r2, [r3]
    for (i = 0; i < data_len; i++)
  134598:	e51b3008 	ldr	r3, [fp, #-8]
  13459c:	e2833001 	add	r3, r3, #1
  1345a0:	e50b3008 	str	r3, [fp, #-8]
  1345a4:	e51b2008 	ldr	r2, [fp, #-8]
  1345a8:	e51b300c 	ldr	r3, [fp, #-12]
  1345ac:	e1520003 	cmp	r2, r3
  1345b0:	3afffff1 	bcc	13457c <ping_prepare_echo+0xcc>
    }

#ifdef RT_LWIP_USING_HW_CHECKSUM
      iecho->chksum = 0;
#else
      iecho->chksum = inet_chksum(iecho, len);
  1345b4:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
  1345b8:	e1a01003 	mov	r1, r3
  1345bc:	e51b0010 	ldr	r0, [fp, #-16]
  1345c0:	ebff9193 	bl	118c14 <inet_chksum>
  1345c4:	e1a03000 	mov	r3, r0
  1345c8:	e1a02003 	mov	r2, r3
  1345cc:	e51b3010 	ldr	r3, [fp, #-16]
  1345d0:	e1c320b2 	strh	r2, [r3, #2]
#endif

}
  1345d4:	e320f000 	nop	{0}
  1345d8:	e24bd004 	sub	sp, fp, #4
  1345dc:	e8bd8800 	pop	{fp, pc}

001345e0 <lwip_ping_send>:

#include <stdio.h>

/* Ping using the socket ip */
err_t lwip_ping_send(int s, ip_addr_t *addr, int size)
{
  1345e0:	e92d4800 	push	{fp, lr}
  1345e4:	e28db004 	add	fp, sp, #4
  1345e8:	e24dd038 	sub	sp, sp, #56	; 0x38
  1345ec:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  1345f0:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  1345f4:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
    int err;
    struct icmp_echo_hdr *iecho;
    struct sockaddr_in to;
    int ping_size = sizeof(struct icmp_echo_hdr) + size;
  1345f8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1345fc:	e2833008 	add	r3, r3, #8
  134600:	e50b3008 	str	r3, [fp, #-8]
    LWIP_ASSERT("ping_size is too big", ping_size <= 0xffff);
  134604:	e51b3008 	ldr	r3, [fp, #-8]
  134608:	e3530801 	cmp	r3, #65536	; 0x10000
  13460c:	ba000006 	blt	13462c <lwip_ping_send+0x4c>
  134610:	e3090d64 	movw	r0, #40292	; 0x9d64
  134614:	e3400014 	movt	r0, #20
  134618:	ebff3abd 	bl	103114 <rt_kprintf>
  13461c:	e3a01054 	mov	r1, #84	; 0x54
  134620:	e3090d7c 	movw	r0, #40316	; 0x9d7c
  134624:	e3400014 	movt	r0, #20
  134628:	ebff5a93 	bl	10b07c <sys_arch_assert>

    iecho = rt_malloc(ping_size);
  13462c:	e51b3008 	ldr	r3, [fp, #-8]
  134630:	e1a00003 	mov	r0, r3
  134634:	ebff3a56 	bl	102f94 <rt_malloc>
  134638:	e50b000c 	str	r0, [fp, #-12]
    if (iecho == RT_NULL)
  13463c:	e51b300c 	ldr	r3, [fp, #-12]
  134640:	e3530000 	cmp	r3, #0
  134644:	1a000001 	bne	134650 <lwip_ping_send+0x70>
    {
        return ERR_MEM;
  134648:	e3e03000 	mvn	r3, #0
  13464c:	ea00001e 	b	1346cc <lwip_ping_send+0xec>
    }

    ping_prepare_echo(iecho, (u16_t) ping_size);
  134650:	e51b3008 	ldr	r3, [fp, #-8]
  134654:	e6ff3073 	uxth	r3, r3
  134658:	e1a01003 	mov	r1, r3
  13465c:	e51b000c 	ldr	r0, [fp, #-12]
  134660:	ebffff92 	bl	1344b0 <ping_prepare_echo>

    to.sin_len = sizeof(to);
  134664:	e3a03010 	mov	r3, #16
  134668:	e54b3020 	strb	r3, [fp, #-32]	; 0xffffffe0
    to.sin_family = AF_INET;
  13466c:	e3a03002 	mov	r3, #2
  134670:	e54b301f 	strb	r3, [fp, #-31]	; 0xffffffe1
#if LWIP_IPV4 && LWIP_IPV6
    to.sin_addr.s_addr = addr->u_addr.ip4.addr;
#elif LWIP_IPV4
    to.sin_addr.s_addr = addr->addr;
  134674:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  134678:	e5933000 	ldr	r3, [r3]
  13467c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
#elif LWIP_IPV6
#error Not supported IPv6.
#endif

    err = lwip_sendto(s, iecho, ping_size, 0, (struct sockaddr*) &to, sizeof(to));
  134680:	e51b2008 	ldr	r2, [fp, #-8]
  134684:	e3a03010 	mov	r3, #16
  134688:	e58d3004 	str	r3, [sp, #4]
  13468c:	e24b3020 	sub	r3, fp, #32
  134690:	e58d3000 	str	r3, [sp]
  134694:	e3a03000 	mov	r3, #0
  134698:	e51b100c 	ldr	r1, [fp, #-12]
  13469c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  1346a0:	ebff797c 	bl	112c98 <lwip_sendto>
  1346a4:	e50b0010 	str	r0, [fp, #-16]
    rt_free(iecho);
  1346a8:	e51b000c 	ldr	r0, [fp, #-12]
  1346ac:	ebff3a42 	bl	102fbc <rt_free>

    return (err == ping_size ? ERR_OK : ERR_VAL);
  1346b0:	e51b2010 	ldr	r2, [fp, #-16]
  1346b4:	e51b3008 	ldr	r3, [fp, #-8]
  1346b8:	e1520003 	cmp	r2, r3
  1346bc:	1a000001 	bne	1346c8 <lwip_ping_send+0xe8>
  1346c0:	e3a03000 	mov	r3, #0
  1346c4:	ea000000 	b	1346cc <lwip_ping_send+0xec>
  1346c8:	e3e03005 	mvn	r3, #5
}
  1346cc:	e1a00003 	mov	r0, r3
  1346d0:	e24bd004 	sub	sp, fp, #4
  1346d4:	e8bd8800 	pop	{fp, pc}

001346d8 <lwip_ping_recv>:

int lwip_ping_recv(int s, int *ttl)
{
  1346d8:	e92d4810 	push	{r4, fp, lr}
  1346dc:	e28db008 	add	fp, sp, #8
  1346e0:	e24dd074 	sub	sp, sp, #116	; 0x74
  1346e4:	e50b0070 	str	r0, [fp, #-112]	; 0xffffff90
  1346e8:	e50b1074 	str	r1, [fp, #-116]	; 0xffffff8c
    char buf[64];
    int fromlen = sizeof(struct sockaddr_in), len;
  1346ec:	e3a03010 	mov	r3, #16
  1346f0:	e50b305c 	str	r3, [fp, #-92]	; 0xffffffa4
    struct sockaddr_in from;
    struct ip_hdr *iphdr;
    struct icmp_echo_hdr *iecho;

    while ((len = lwip_recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*) &from, (socklen_t*) &fromlen)) > 0)
  1346f4:	ea000024 	b	13478c <lwip_ping_recv+0xb4>
    {
        if (len >= (int)(sizeof(struct ip_hdr) + sizeof(struct icmp_echo_hdr)))
  1346f8:	e51b3010 	ldr	r3, [fp, #-16]
  1346fc:	e353001b 	cmp	r3, #27
  134700:	da000021 	ble	13478c <lwip_ping_recv+0xb4>
        {
            iphdr = (struct ip_hdr *) buf;
  134704:	e24b3058 	sub	r3, fp, #88	; 0x58
  134708:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
            iecho = (struct icmp_echo_hdr *) (buf + (IPH_HL(iphdr) * 4));
  13470c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  134710:	e5d33000 	ldrb	r3, [r3]
  134714:	e203300f 	and	r3, r3, #15
  134718:	e1a03103 	lsl	r3, r3, #2
  13471c:	e1a02003 	mov	r2, r3
  134720:	e24b3058 	sub	r3, fp, #88	; 0x58
  134724:	e0833002 	add	r3, r3, r2
  134728:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
            if ((iecho->id == PING_ID) && (iecho->seqno == htons(ping_seq_num)))
  13472c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  134730:	e1d330b4 	ldrh	r3, [r3, #4]
  134734:	e6ff3073 	uxth	r3, r3
  134738:	e30a2faf 	movw	r2, #44975	; 0xafaf
  13473c:	e1530002 	cmp	r3, r2
  134740:	1a000011 	bne	13478c <lwip_ping_recv+0xb4>
  134744:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  134748:	e1d330b6 	ldrh	r3, [r3, #6]
  13474c:	e6ff4073 	uxth	r4, r3
  134750:	e30f3bee 	movw	r3, #64494	; 0xfbee
  134754:	e3403014 	movt	r3, #20
  134758:	e1d330b0 	ldrh	r3, [r3]
  13475c:	e1a00003 	mov	r0, r3
  134760:	ebff881c 	bl	1167d8 <lwip_htons>
  134764:	e1a03000 	mov	r3, r0
  134768:	e1540003 	cmp	r4, r3
  13476c:	1a000006 	bne	13478c <lwip_ping_recv+0xb4>
            {
                *ttl = iphdr->_ttl;
  134770:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  134774:	e5d33008 	ldrb	r3, [r3, #8]
  134778:	e1a02003 	mov	r2, r3
  13477c:	e51b3074 	ldr	r3, [fp, #-116]	; 0xffffff8c
  134780:	e5832000 	str	r2, [r3]
                return len;
  134784:	e51b3010 	ldr	r3, [fp, #-16]
  134788:	ea00000d 	b	1347c4 <lwip_ping_recv+0xec>
    while ((len = lwip_recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*) &from, (socklen_t*) &fromlen)) > 0)
  13478c:	e24b1058 	sub	r1, fp, #88	; 0x58
  134790:	e24b305c 	sub	r3, fp, #92	; 0x5c
  134794:	e58d3004 	str	r3, [sp, #4]
  134798:	e24b306c 	sub	r3, fp, #108	; 0x6c
  13479c:	e58d3000 	str	r3, [sp]
  1347a0:	e3a03000 	mov	r3, #0
  1347a4:	e3a02040 	mov	r2, #64	; 0x40
  1347a8:	e51b0070 	ldr	r0, [fp, #-112]	; 0xffffff90
  1347ac:	ebff75ce 	bl	111eec <lwip_recvfrom>
  1347b0:	e50b0010 	str	r0, [fp, #-16]
  1347b4:	e51b3010 	ldr	r3, [fp, #-16]
  1347b8:	e3530000 	cmp	r3, #0
  1347bc:	caffffcd 	bgt	1346f8 <lwip_ping_recv+0x20>
            }
        }
    }

    return len;
  1347c0:	e51b3010 	ldr	r3, [fp, #-16]
}
  1347c4:	e1a00003 	mov	r0, r3
  1347c8:	e24bd008 	sub	sp, fp, #8
  1347cc:	e8bd8810 	pop	{r4, fp, pc}

001347d0 <ENET_ActiveRead>:
 * @note This must be called after the MAC configuration and
 * state are ready. It must be called after the ENET_Init() and
 * ENET_Ptp1588Configure(). This should be called when the ENET receive required.
 */
static inline void ENET_ActiveRead(ENET_Type *base)
{
  1347d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1347d4:	e28db000 	add	fp, sp, #0
  1347d8:	e24dd00c 	sub	sp, sp, #12
  1347dc:	e50b0008 	str	r0, [fp, #-8]
    base->RDAR = ENET_RDAR_RDAR_MASK;
  1347e0:	e51b3008 	ldr	r3, [fp, #-8]
  1347e4:	e3a02401 	mov	r2, #16777216	; 0x1000000
  1347e8:	e5832010 	str	r2, [r3, #16]
}
  1347ec:	e320f000 	nop	{0}
  1347f0:	e28bd000 	add	sp, fp, #0
  1347f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1347f8:	e12fff1e 	bx	lr

001347fc <ENET_EnableInterrupts>:
 * @param base  ENET peripheral base address.
 * @param mask  ENET interrupts to enable. This is a logical OR of the
 *             enumeration :: enet_interrupt_enable_t.
 */
static inline void ENET_EnableInterrupts(ENET_Type *base, uint32_t mask)
{
  1347fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  134800:	e28db000 	add	fp, sp, #0
  134804:	e24dd00c 	sub	sp, sp, #12
  134808:	e50b0008 	str	r0, [fp, #-8]
  13480c:	e50b100c 	str	r1, [fp, #-12]
    base->EIMR |= mask;
  134810:	e51b3008 	ldr	r3, [fp, #-8]
  134814:	e5932008 	ldr	r2, [r3, #8]
  134818:	e51b300c 	ldr	r3, [fp, #-12]
  13481c:	e1822003 	orr	r2, r2, r3
  134820:	e51b3008 	ldr	r3, [fp, #-8]
  134824:	e5832008 	str	r2, [r3, #8]
}
  134828:	e320f000 	nop	{0}
  13482c:	e28bd000 	add	sp, fp, #0
  134830:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  134834:	e12fff1e 	bx	lr

00134838 <ENET_DisableInterrupts>:
 * @param base  ENET peripheral base address.
 * @param mask  ENET interrupts to disable. This is a logical OR of the
 *             enumeration :: enet_interrupt_enable_t.
 */
static inline void ENET_DisableInterrupts(ENET_Type *base, uint32_t mask)
{
  134838:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  13483c:	e28db000 	add	fp, sp, #0
  134840:	e24dd00c 	sub	sp, sp, #12
  134844:	e50b0008 	str	r0, [fp, #-8]
  134848:	e50b100c 	str	r1, [fp, #-12]
    base->EIMR &= ~mask;
  13484c:	e51b3008 	ldr	r3, [fp, #-8]
  134850:	e5932008 	ldr	r2, [r3, #8]
  134854:	e51b300c 	ldr	r3, [fp, #-12]
  134858:	e1e03003 	mvn	r3, r3
  13485c:	e0022003 	and	r2, r2, r3
  134860:	e51b3008 	ldr	r3, [fp, #-8]
  134864:	e5832008 	str	r2, [r3, #8]
}
  134868:	e320f000 	nop	{0}
  13486c:	e28bd000 	add	sp, fp, #0
  134870:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  134874:	e12fff1e 	bx	lr

00134878 <imx6ul_eth_link_change>:
#else
#define eth_device_linkchange(x, y)
#endif

void imx6ul_eth_link_change(struct rt_imx6ul_ethps *imx6ul_device,rt_bool_t up)
{
  134878:	e92d4800 	push	{fp, lr}
  13487c:	e28db004 	add	fp, sp, #4
  134880:	e24dd008 	sub	sp, sp, #8
  134884:	e50b0008 	str	r0, [fp, #-8]
  134888:	e50b100c 	str	r1, [fp, #-12]
    if(up)
  13488c:	e51b300c 	ldr	r3, [fp, #-12]
  134890:	e3530000 	cmp	r3, #0
  134894:	0a000013 	beq	1348e8 <imx6ul_eth_link_change+0x70>
    {
        LOG_D("enet%d link up",imx6ul_device->mac_num);
  134898:	e3090dc0 	movw	r0, #40384	; 0x9dc0
  13489c:	e3400014 	movt	r0, #20
  1348a0:	ebff3a1b 	bl	103114 <rt_kprintf>
  1348a4:	e51b3008 	ldr	r3, [fp, #-8]
  1348a8:	e59330a4 	ldr	r3, [r3, #164]	; 0xa4
  1348ac:	e1a01003 	mov	r1, r3
  1348b0:	e3090dd4 	movw	r0, #40404	; 0x9dd4
  1348b4:	e3400014 	movt	r0, #20
  1348b8:	ebff3a15 	bl	103114 <rt_kprintf>
  1348bc:	e3090de4 	movw	r0, #40420	; 0x9de4
  1348c0:	e3400014 	movt	r0, #20
  1348c4:	ebff3a12 	bl	103114 <rt_kprintf>
        eth_device_linkchange(&imx6ul_device->parent, RT_TRUE);
  1348c8:	e51b3008 	ldr	r3, [fp, #-8]
  1348cc:	e3a01001 	mov	r1, #1
  1348d0:	e1a00003 	mov	r0, r3
  1348d4:	ebffd532 	bl	129da4 <eth_device_linkchange>
        imx6ul_device->phy_link_status = RT_TRUE;
  1348d8:	e51b3008 	ldr	r3, [fp, #-8]
  1348dc:	e3a02001 	mov	r2, #1
  1348e0:	e5832088 	str	r2, [r3, #136]	; 0x88
    {
        LOG_D("enet%d link down",imx6ul_device->mac_num);
        eth_device_linkchange(&imx6ul_device->parent, RT_FALSE);
        imx6ul_device->phy_link_status = RT_FALSE;
    }
}
  1348e4:	ea000012 	b	134934 <imx6ul_eth_link_change+0xbc>
        LOG_D("enet%d link down",imx6ul_device->mac_num);
  1348e8:	e3090dc0 	movw	r0, #40384	; 0x9dc0
  1348ec:	e3400014 	movt	r0, #20
  1348f0:	ebff3a07 	bl	103114 <rt_kprintf>
  1348f4:	e51b3008 	ldr	r3, [fp, #-8]
  1348f8:	e59330a4 	ldr	r3, [r3, #164]	; 0xa4
  1348fc:	e1a01003 	mov	r1, r3
  134900:	e3090dec 	movw	r0, #40428	; 0x9dec
  134904:	e3400014 	movt	r0, #20
  134908:	ebff3a01 	bl	103114 <rt_kprintf>
  13490c:	e3090de4 	movw	r0, #40420	; 0x9de4
  134910:	e3400014 	movt	r0, #20
  134914:	ebff39fe 	bl	103114 <rt_kprintf>
        eth_device_linkchange(&imx6ul_device->parent, RT_FALSE);
  134918:	e51b3008 	ldr	r3, [fp, #-8]
  13491c:	e3a01000 	mov	r1, #0
  134920:	e1a00003 	mov	r0, r3
  134924:	ebffd51e 	bl	129da4 <eth_device_linkchange>
        imx6ul_device->phy_link_status = RT_FALSE;
  134928:	e51b3008 	ldr	r3, [fp, #-8]
  13492c:	e3a02000 	mov	r2, #0
  134930:	e5832088 	str	r2, [r3, #136]	; 0x88
}
  134934:	e320f000 	nop	{0}
  134938:	e24bd004 	sub	sp, fp, #4
  13493c:	e8bd8800 	pop	{fp, pc}

00134940 <page_alloc>:

void page_alloc(size_t memsize, void **addr)
{
  134940:	e92d4800 	push	{fp, lr}
  134944:	e28db004 	add	fp, sp, #4
  134948:	e24dd018 	sub	sp, sp, #24
  13494c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  134950:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    size_t alloc_size = memsize + SYS_PAGE_SIZE * 2;
  134954:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  134958:	e2833a02 	add	r3, r3, #8192	; 0x2000
  13495c:	e50b3008 	str	r3, [fp, #-8]
    void * addr_start = malloc(alloc_size);
  134960:	e51b0008 	ldr	r0, [fp, #-8]
  134964:	eb0022f9 	bl	13d550 <malloc>
  134968:	e1a03000 	mov	r3, r0
  13496c:	e50b300c 	str	r3, [fp, #-12]
    rt_memset(addr_start, 0, alloc_size);
  134970:	e51b2008 	ldr	r2, [fp, #-8]
  134974:	e3a01000 	mov	r1, #0
  134978:	e51b000c 	ldr	r0, [fp, #-12]
  13497c:	ebff3a51 	bl	1032c8 <rt_memset>

    long mask = SYS_PAGE_SIZE - 1;
  134980:	e3003fff 	movw	r3, #4095	; 0xfff
  134984:	e50b3010 	str	r3, [fp, #-16]
    *addr = (void*)((long)(addr_start + SYS_PAGE_SIZE) & ~mask);
  134988:	e51b300c 	ldr	r3, [fp, #-12]
  13498c:	e2833a01 	add	r3, r3, #4096	; 0x1000
  134990:	e1a02003 	mov	r2, r3
  134994:	e51b3010 	ldr	r3, [fp, #-16]
  134998:	e1e03003 	mvn	r3, r3
  13499c:	e0033002 	and	r3, r3, r2
  1349a0:	e1a02003 	mov	r2, r3
  1349a4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1349a8:	e5832000 	str	r2, [r3]

    return;
  1349ac:	e320f000 	nop	{0}
}
  1349b0:	e24bd004 	sub	sp, fp, #4
  1349b4:	e8bd8800 	pop	{fp, pc}

001349b8 <enet_buffer_init>:

rt_err_t enet_buffer_init(enet_buffer_config_t *buffConfig)
{
  1349b8:	e92d4800 	push	{fp, lr}
  1349bc:	e28db004 	add	fp, sp, #4
  1349c0:	e24dd030 	sub	sp, sp, #48	; 0x30
  1349c4:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
    void *tx_buff_addr = RT_NULL;
  1349c8:	e3a03000 	mov	r3, #0
  1349cc:	e50b3008 	str	r3, [fp, #-8]
    void *rx_buff_addr = RT_NULL;
  1349d0:	e3a03000 	mov	r3, #0
  1349d4:	e50b300c 	str	r3, [fp, #-12]
    void *tx_bd_addr = RT_NULL;
  1349d8:	e3a03000 	mov	r3, #0
  1349dc:	e50b3010 	str	r3, [fp, #-16]
    void *rx_bd_addr = RT_NULL;
  1349e0:	e3a03000 	mov	r3, #0
  1349e4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

    if(((SYS_PAGE_SIZE<<RX_BUFFER_INDEX_NUM)<buffConfig->rxBufferTotalSize)||
  1349e8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1349ec:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
  1349f0:	e3530701 	cmp	r3, #262144	; 0x40000
  1349f4:	8a000003 	bhi	134a08 <enet_buffer_init+0x50>
       ((SYS_PAGE_SIZE<<TX_BUFFER_INDEX_NUM)<buffConfig->txBufferTotalSize))
  1349f8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1349fc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
    if(((SYS_PAGE_SIZE<<RX_BUFFER_INDEX_NUM)<buffConfig->rxBufferTotalSize)||
  134a00:	e3530701 	cmp	r3, #262144	; 0x40000
  134a04:	9a00000a 	bls	134a34 <enet_buffer_init+0x7c>
    {
        LOG_E("ERROR: alloc mem not enough for enet driver");
  134a08:	e3090e00 	movw	r0, #40448	; 0x9e00
  134a0c:	e3400014 	movt	r0, #20
  134a10:	ebff39bf 	bl	103114 <rt_kprintf>
  134a14:	e3090e14 	movw	r0, #40468	; 0x9e14
  134a18:	e3400014 	movt	r0, #20
  134a1c:	ebff39bc 	bl	103114 <rt_kprintf>
  134a20:	e3090de4 	movw	r0, #40420	; 0x9de4
  134a24:	e3400014 	movt	r0, #20
  134a28:	ebff39b9 	bl	103114 <rt_kprintf>
        return RT_ERROR;
  134a2c:	e3a03001 	mov	r3, #1
  134a30:	ea000093 	b	134c84 <enet_buffer_init+0x2cc>
    }

    size_t rx_buff_memsize = SYS_PAGE_SIZE<<RX_BUFFER_INDEX_NUM;
  134a34:	e3a03701 	mov	r3, #262144	; 0x40000
  134a38:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    size_t tx_buff_memsize = SYS_PAGE_SIZE<<TX_BUFFER_INDEX_NUM;
  134a3c:	e3a03701 	mov	r3, #262144	; 0x40000
  134a40:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    size_t rx_bd_memsize = SYS_PAGE_SIZE<<RX_BD_INDEX_NUM;
  134a44:	e3a03a01 	mov	r3, #4096	; 0x1000
  134a48:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    size_t tx_bd_memsize = SYS_PAGE_SIZE<<TX_BD_INDEX_NUM;
  134a4c:	e3a03a01 	mov	r3, #4096	; 0x1000
  134a50:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    size_t total_memsize = rx_buff_memsize + tx_buff_memsize + rx_bd_memsize + tx_bd_memsize;
  134a54:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  134a58:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  134a5c:	e0822003 	add	r2, r2, r3
  134a60:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  134a64:	e0823003 	add	r3, r2, r3
  134a68:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  134a6c:	e0823003 	add	r3, r2, r3
  134a70:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8

    void *mem_align= RT_NULL;
  134a74:	e3a03000 	mov	r3, #0
  134a78:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
    page_alloc(total_memsize, &mem_align);
  134a7c:	e24b302c 	sub	r3, fp, #44	; 0x2c
  134a80:	e1a01003 	mov	r1, r3
  134a84:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  134a88:	ebffffac 	bl	134940 <page_alloc>
    if (!mem_align)
  134a8c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  134a90:	e3530000 	cmp	r3, #0
  134a94:	1a000001 	bne	134aa0 <enet_buffer_init+0xe8>
    {
        return RT_ERROR;
  134a98:	e3a03001 	mov	r3, #1
  134a9c:	ea000078 	b	134c84 <enet_buffer_init+0x2cc>
    }
    
    rx_buff_addr = mem_align;
  134aa0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  134aa4:	e50b300c 	str	r3, [fp, #-12]
    mem_align += rx_buff_memsize;
  134aa8:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  134aac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  134ab0:	e0823003 	add	r3, r2, r3
  134ab4:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
    if(!rx_buff_addr)
  134ab8:	e51b300c 	ldr	r3, [fp, #-12]
  134abc:	e3530000 	cmp	r3, #0
  134ac0:	1a00000a 	bne	134af0 <enet_buffer_init+0x138>
    {
        LOG_E("ERROR: rx buff page alloc failed");
  134ac4:	e3090e00 	movw	r0, #40448	; 0x9e00
  134ac8:	e3400014 	movt	r0, #20
  134acc:	ebff3990 	bl	103114 <rt_kprintf>
  134ad0:	e3090e40 	movw	r0, #40512	; 0x9e40
  134ad4:	e3400014 	movt	r0, #20
  134ad8:	ebff398d 	bl	103114 <rt_kprintf>
  134adc:	e3090de4 	movw	r0, #40420	; 0x9de4
  134ae0:	e3400014 	movt	r0, #20
  134ae4:	ebff398a 	bl	103114 <rt_kprintf>
        return RT_ERROR;
  134ae8:	e3a03001 	mov	r3, #1
  134aec:	ea000064 	b	134c84 <enet_buffer_init+0x2cc>
    }
    // buffConfig->rxBufferAlign = (void *)rt_ioremap_nocache(virtual_to_physical(rx_buff_addr), (SYS_PAGE_SIZE<<RX_BUFFER_INDEX_NUM));
    // buffConfig->rxBufferAlign = ueth_remap(ueth_v2p(rx_buff_addr), UETH_REMAP_NOCACHE, rx_buff_memsize);
    buffConfig->rxBufferAlign = rx_buff_addr;
  134af0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134af4:	e51b200c 	ldr	r2, [fp, #-12]
  134af8:	e5832014 	str	r2, [r3, #20]
    buffConfig->rxPhyBufferAlign = ueth_v2p(rx_buff_addr);
  134afc:	e51b000c 	ldr	r0, [fp, #-12]
  134b00:	ebff3e44 	bl	104418 <ueth_v2p>
  134b04:	e1a02000 	mov	r2, r0
  134b08:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134b0c:	e5832024 	str	r2, [r3, #36]	; 0x24
    
    // tx_buff_addr = (void*)rt_pages_alloc(TX_BUFFER_INDEX_NUM);
    tx_buff_addr = mem_align;
  134b10:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  134b14:	e50b3008 	str	r3, [fp, #-8]
    mem_align += tx_buff_memsize;
  134b18:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  134b1c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  134b20:	e0823003 	add	r3, r2, r3
  134b24:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
    if(!tx_buff_addr)
  134b28:	e51b3008 	ldr	r3, [fp, #-8]
  134b2c:	e3530000 	cmp	r3, #0
  134b30:	1a00000a 	bne	134b60 <enet_buffer_init+0x1a8>
    {
        LOG_E("ERROR: tx buff page alloc failed");
  134b34:	e3090e00 	movw	r0, #40448	; 0x9e00
  134b38:	e3400014 	movt	r0, #20
  134b3c:	ebff3974 	bl	103114 <rt_kprintf>
  134b40:	e3090e64 	movw	r0, #40548	; 0x9e64
  134b44:	e3400014 	movt	r0, #20
  134b48:	ebff3971 	bl	103114 <rt_kprintf>
  134b4c:	e3090de4 	movw	r0, #40420	; 0x9de4
  134b50:	e3400014 	movt	r0, #20
  134b54:	ebff396e 	bl	103114 <rt_kprintf>
        return RT_ERROR;
  134b58:	e3a03001 	mov	r3, #1
  134b5c:	ea000048 	b	134c84 <enet_buffer_init+0x2cc>
    }
    // buffConfig->txBufferAlign = (void *)rt_ioremap_nocache(virtual_to_physical(tx_buff_addr), (SYS_PAGE_SIZE<<TX_BUFFER_INDEX_NUM));
    // buffConfig->txBufferAlign = ueth_remap(ueth_v2p(tx_buff_addr), UETH_REMAP_NOCACHE, tx_buff_memsize);
    buffConfig->txBufferAlign = tx_buff_addr;
  134b60:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134b64:	e51b2008 	ldr	r2, [fp, #-8]
  134b68:	e5832018 	str	r2, [r3, #24]
    buffConfig->txPhyBufferAlign = ueth_v2p(tx_buff_addr);
  134b6c:	e51b0008 	ldr	r0, [fp, #-8]
  134b70:	ebff3e28 	bl	104418 <ueth_v2p>
  134b74:	e1a02000 	mov	r2, r0
  134b78:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134b7c:	e5832028 	str	r2, [r3, #40]	; 0x28
    
    // rx_bd_addr = (void*)rt_pages_alloc(RX_BD_INDEX_NUM);
    rx_bd_addr = mem_align;
  134b80:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  134b84:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    mem_align += rx_bd_memsize;
  134b88:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  134b8c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  134b90:	e0823003 	add	r3, r2, r3
  134b94:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4
    if(!rx_bd_addr)
  134b98:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  134b9c:	e3530000 	cmp	r3, #0
  134ba0:	1a00000a 	bne	134bd0 <enet_buffer_init+0x218>
    {
        LOG_E("ERROR: rx bd page alloc failed");
  134ba4:	e3090e00 	movw	r0, #40448	; 0x9e00
  134ba8:	e3400014 	movt	r0, #20
  134bac:	ebff3958 	bl	103114 <rt_kprintf>
  134bb0:	e3090e88 	movw	r0, #40584	; 0x9e88
  134bb4:	e3400014 	movt	r0, #20
  134bb8:	ebff3955 	bl	103114 <rt_kprintf>
  134bbc:	e3090de4 	movw	r0, #40420	; 0x9de4
  134bc0:	e3400014 	movt	r0, #20
  134bc4:	ebff3952 	bl	103114 <rt_kprintf>
        return RT_ERROR;
  134bc8:	e3a03001 	mov	r3, #1
  134bcc:	ea00002c 	b	134c84 <enet_buffer_init+0x2cc>
    }
    buffConfig->rxPhyBdStartAddrAlign = ueth_v2p(rx_bd_addr);
  134bd0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  134bd4:	ebff3e0f 	bl	104418 <ueth_v2p>
  134bd8:	e1a02000 	mov	r2, r0
  134bdc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134be0:	e583201c 	str	r2, [r3, #28]
    buffConfig->rxBdStartAddrAlign = ueth_remap(buffConfig->rxPhyBdStartAddrAlign, UETH_REMAP_NOCACHE, rx_bd_memsize);
  134be4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134be8:	e593301c 	ldr	r3, [r3, #28]
  134bec:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  134bf0:	e3a01003 	mov	r1, #3
  134bf4:	e1a00003 	mov	r0, r3
  134bf8:	ebff3e33 	bl	1044cc <ueth_remap>
  134bfc:	e1a02000 	mov	r2, r0
  134c00:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134c04:	e583200c 	str	r2, [r3, #12]
    // buffConfig->rxBdStartAddrAlign = (void *)rt_ioremap_nocache(virtual_to_physical(rx_bd_addr), (SYS_PAGE_SIZE<<RX_BD_INDEX_NUM));
    // buffConfig->rxBdStartAddrAlign = rx_bd_addr;
   
    // tx_bd_addr = (void*)rt_pages_alloc(TX_BD_INDEX_NUM);
    tx_bd_addr = mem_align;
  134c08:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  134c0c:	e50b3010 	str	r3, [fp, #-16]
    if(!tx_bd_addr)
  134c10:	e51b3010 	ldr	r3, [fp, #-16]
  134c14:	e3530000 	cmp	r3, #0
  134c18:	1a00000a 	bne	134c48 <enet_buffer_init+0x290>
    {
        LOG_E("ERROR: tx bd page alloc failed");
  134c1c:	e3090e00 	movw	r0, #40448	; 0x9e00
  134c20:	e3400014 	movt	r0, #20
  134c24:	ebff393a 	bl	103114 <rt_kprintf>
  134c28:	e3090ea8 	movw	r0, #40616	; 0x9ea8
  134c2c:	e3400014 	movt	r0, #20
  134c30:	ebff3937 	bl	103114 <rt_kprintf>
  134c34:	e3090de4 	movw	r0, #40420	; 0x9de4
  134c38:	e3400014 	movt	r0, #20
  134c3c:	ebff3934 	bl	103114 <rt_kprintf>
        return RT_ERROR;
  134c40:	e3a03001 	mov	r3, #1
  134c44:	ea00000e 	b	134c84 <enet_buffer_init+0x2cc>
    }
    // buffConfig->txBdStartAddrAlign = (void *)rt_ioremap_nocache(virtual_to_physical(tx_bd_addr), (SYS_PAGE_SIZE<<TX_BD_INDEX_NUM));
    buffConfig->txPhyBdStartAddrAlign = ueth_v2p(tx_bd_addr);
  134c48:	e51b0010 	ldr	r0, [fp, #-16]
  134c4c:	ebff3df1 	bl	104418 <ueth_v2p>
  134c50:	e1a02000 	mov	r2, r0
  134c54:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134c58:	e5832020 	str	r2, [r3, #32]
    buffConfig->txBdStartAddrAlign = ueth_remap(buffConfig->txPhyBdStartAddrAlign, UETH_REMAP_NOCACHE, tx_bd_memsize);
  134c5c:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134c60:	e5933020 	ldr	r3, [r3, #32]
  134c64:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  134c68:	e3a01003 	mov	r1, #3
  134c6c:	e1a00003 	mov	r0, r3
  134c70:	ebff3e15 	bl	1044cc <ueth_remap>
  134c74:	e1a02000 	mov	r2, r0
  134c78:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134c7c:	e5832010 	str	r2, [r3, #16]
    // buffConfig->txBdStartAddrAlign = tx_bd_addr;
    
    return RT_EOK;
  134c80:	e3a03000 	mov	r3, #0
}
  134c84:	e1a00003 	mov	r0, r3
  134c88:	e24bd004 	sub	sp, fp, #4
  134c8c:	e8bd8800 	pop	{fp, pc}

00134c90 <rt_imx6ul_eth_init>:

/* EMAC initialization function */
static rt_err_t rt_imx6ul_eth_init(rt_device_t dev)
{
  134c90:	e92d4800 	push	{fp, lr}
  134c94:	e28db004 	add	fp, sp, #4
  134c98:	e24dd038 	sub	sp, sp, #56	; 0x38
  134c9c:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
    rt_err_t state;
    struct rt_imx6ul_ethps *imx6ul_device = (struct rt_imx6ul_ethps *)dev;
  134ca0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  134ca4:	e50b300c 	str	r3, [fp, #-12]
    ENET_Type *base_addr = RT_NULL;
  134ca8:	e3a03000 	mov	r3, #0
  134cac:	e50b3010 	str	r3, [fp, #-16]
    enet_handle_t *handle;
    enet_buffer_config_t *buffConfig;
    rt_uint32_t reg_value;

    // imx6ul_device->enet_virtual_base_addr = (ENET_Type *)rt_ioremap((void *)imx6ul_device->enet_phy_base_addr, SYS_PAGE_SIZE);
    imx6ul_device->enet_virtual_base_addr = (ENET_Type *)ueth_remap((void *)imx6ul_device->enet_phy_base_addr, UETH_REMAP, SYS_PAGE_SIZE);
  134cb0:	e51b300c 	ldr	r3, [fp, #-12]
  134cb4:	e593309c 	ldr	r3, [r3, #156]	; 0x9c
  134cb8:	e3a02a01 	mov	r2, #4096	; 0x1000
  134cbc:	e3a01001 	mov	r1, #1
  134cc0:	e1a00003 	mov	r0, r3
  134cc4:	ebff3e00 	bl	1044cc <ueth_remap>
  134cc8:	e1a02000 	mov	r2, r0
  134ccc:	e51b300c 	ldr	r3, [fp, #-12]
  134cd0:	e58320a0 	str	r2, [r3, #160]	; 0xa0
    base_addr = imx6ul_device->enet_virtual_base_addr;
  134cd4:	e51b300c 	ldr	r3, [fp, #-12]
  134cd8:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
  134cdc:	e50b3010 	str	r3, [fp, #-16]
    config = &imx6ul_device->config;
  134ce0:	e51b300c 	ldr	r3, [fp, #-12]
  134ce4:	e28330dc 	add	r3, r3, #220	; 0xdc
  134ce8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    handle = &imx6ul_device->handle;
  134cec:	e51b300c 	ldr	r3, [fp, #-12]
  134cf0:	e2833c01 	add	r3, r3, #256	; 0x100
  134cf4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    buffConfig = &imx6ul_device->buffConfig;
  134cf8:	e51b300c 	ldr	r3, [fp, #-12]
  134cfc:	e28330a8 	add	r3, r3, #168	; 0xa8
  134d00:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    for (int i=0; i<GET_ARRAY_NUM(imx6ul_device->gpio); i++)
  134d04:	e3a03000 	mov	r3, #0
  134d08:	e50b3008 	str	r3, [fp, #-8]
  134d0c:	ea00000b 	b	134d40 <rt_imx6ul_eth_init+0xb0>
    {
        ueth_gpioinit((void *)&imx6ul_device->gpio[i], sizeof(imx6ul_device->gpio[i]));
  134d10:	e51b3008 	ldr	r3, [fp, #-8]
  134d14:	e3a0201c 	mov	r2, #28
  134d18:	e0030392 	mul	r3, r2, r3
  134d1c:	e2833e12 	add	r3, r3, #288	; 0x120
  134d20:	e51b200c 	ldr	r2, [fp, #-12]
  134d24:	e0823003 	add	r3, r2, r3
  134d28:	e3a0101c 	mov	r1, #28
  134d2c:	e1a00003 	mov	r0, r3
  134d30:	ebff3e19 	bl	10459c <ueth_gpioinit>
    for (int i=0; i<GET_ARRAY_NUM(imx6ul_device->gpio); i++)
  134d34:	e51b3008 	ldr	r3, [fp, #-8]
  134d38:	e2833001 	add	r3, r3, #1
  134d3c:	e50b3008 	str	r3, [fp, #-8]
  134d40:	e51b3008 	ldr	r3, [fp, #-8]
  134d44:	e3530008 	cmp	r3, #8
  134d48:	9afffff0 	bls	134d10 <rt_imx6ul_eth_init+0x80>
    }
    
    IOMUXC_GPR_Type *GPR1 = (IOMUXC_GPR_Type *)ueth_remap((void *)IOMUXC_GPR, UETH_REMAP, 0x1000);
  134d4c:	e3a02a01 	mov	r2, #4096	; 0x1000
  134d50:	e3a01001 	mov	r1, #1
  134d54:	e3a00901 	mov	r0, #16384	; 0x4000
  134d58:	e340020e 	movt	r0, #526	; 0x20e
  134d5c:	ebff3dda 	bl	1044cc <ueth_remap>
  134d60:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    if(imx6ul_device->mac_num == 1)
  134d64:	e51b300c 	ldr	r3, [fp, #-12]
  134d68:	e59330a4 	ldr	r3, [r3, #164]	; 0xa4
  134d6c:	e3530001 	cmp	r3, #1
  134d70:	1a00000c 	bne	134da8 <rt_imx6ul_eth_init+0x118>
    {
        reg_value = GPR1->GPR1;
  134d74:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  134d78:	e5933004 	ldr	r3, [r3, #4]
  134d7c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        reg_value &= ~(IOMUXC_GPR_GPR1_ENET1_CLK_SEL_MASK
  134d80:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  134d84:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
  134d88:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
                    | IOMUXC_GPR_GPR1_ENET1_CLK_SEL_MASK);
        reg_value |=  IOMUXC_GPR_GPR1_ENET1_TX_CLK_DIR(1);
  134d8c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  134d90:	e3833802 	orr	r3, r3, #131072	; 0x20000
  134d94:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        reg_value |=  IOMUXC_GPR_GPR1_ENET1_CLK_SEL(0);
        GPR1->GPR1 = reg_value;
  134d98:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  134d9c:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  134da0:	e5832004 	str	r2, [r3, #4]
  134da4:	ea00000f 	b	134de8 <rt_imx6ul_eth_init+0x158>
    }
    else if(imx6ul_device->mac_num == 2)
  134da8:	e51b300c 	ldr	r3, [fp, #-12]
  134dac:	e59330a4 	ldr	r3, [r3, #164]	; 0xa4
  134db0:	e3530002 	cmp	r3, #2
  134db4:	1a00000b 	bne	134de8 <rt_imx6ul_eth_init+0x158>
    {
        reg_value = GPR1->GPR1;
  134db8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  134dbc:	e5933004 	ldr	r3, [r3, #4]
  134dc0:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        reg_value &= ~(IOMUXC_GPR_GPR1_ENET2_CLK_SEL_MASK
  134dc4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  134dc8:	e3c33901 	bic	r3, r3, #16384	; 0x4000
  134dcc:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
                    | IOMUXC_GPR_GPR1_ENET2_CLK_SEL_MASK);
        reg_value |=  IOMUXC_GPR_GPR1_ENET2_TX_CLK_DIR(1);
  134dd0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  134dd4:	e3833701 	orr	r3, r3, #262144	; 0x40000
  134dd8:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
        reg_value |=  IOMUXC_GPR_GPR1_ENET2_CLK_SEL(0);
        GPR1->GPR1 = reg_value;
  134ddc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  134de0:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  134de4:	e5832004 	str	r2, [r3, #4]
    } 

    // ENET_InitModuleClock();
    ueth_init_clock();
  134de8:	ebff3e19 	bl	104654 <ueth_init_clock>
    ENET_GetDefaultConfig(config);
  134dec:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  134df0:	eb00047c 	bl	135fe8 <ENET_GetDefaultConfig>
    config->interrupt |= (ENET_RX_INTERRUPT);
  134df4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  134df8:	e5933004 	ldr	r3, [r3, #4]
  134dfc:	e3832403 	orr	r2, r3, #50331648	; 0x3000000
  134e00:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  134e04:	e5832004 	str	r2, [r3, #4]
    state = enet_buffer_init(buffConfig);
  134e08:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  134e0c:	ebfffee9 	bl	1349b8 <enet_buffer_init>
  134e10:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
    if(state != RT_EOK)
  134e14:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  134e18:	e3530000 	cmp	r3, #0
  134e1c:	0a000001 	beq	134e28 <rt_imx6ul_eth_init+0x198>
    {
        return state;
  134e20:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  134e24:	ea000015 	b	134e80 <rt_imx6ul_eth_init+0x1f0>
    }
    ENET_Init(base_addr, handle, config, buffConfig, imx6ul_device->dev_addr, SYS_CLOCK_HZ);
  134e28:	e51b300c 	ldr	r3, [fp, #-12]
  134e2c:	e2832078 	add	r2, r3, #120	; 0x78
  134e30:	e3a03d52 	mov	r3, #5248	; 0x1480
  134e34:	e34033ef 	movt	r3, #1007	; 0x3ef
  134e38:	e58d3004 	str	r3, [sp, #4]
  134e3c:	e58d2000 	str	r2, [sp]
  134e40:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  134e44:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  134e48:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  134e4c:	e51b0010 	ldr	r0, [fp, #-16]
  134e50:	eb000488 	bl	136078 <ENET_Init>
    ENET_ActiveRead(base_addr);
  134e54:	e51b0010 	ldr	r0, [fp, #-16]
  134e58:	ebfffe5c 	bl	1347d0 <ENET_ActiveRead>

    // ENET_DisableInterrupts(base_addr,ENET_RX_INTERRUPT);
    // rt_hw_interrupt_install(imx6ul_device->irq_num, (rt_isr_handler_t)ENET_DriverIRQHandler, (void *)base_addr,imx6ul_device->irq_name);     
    // rt_hw_interrupt_umask(imx6ul_device->irq_num);
#ifndef POLL_INT
    ueth_hw_interrupt_install(imx6ul_device->irq_num, (void *)imx6ul_device->enet_phy_base_addr);
  134e5c:	e51b300c 	ldr	r3, [fp, #-12]
  134e60:	e5933094 	ldr	r3, [r3, #148]	; 0x94
  134e64:	e1a02003 	mov	r2, r3
  134e68:	e51b300c 	ldr	r3, [fp, #-12]
  134e6c:	e593309c 	ldr	r3, [r3, #156]	; 0x9c
  134e70:	e1a01003 	mov	r1, r3
  134e74:	e1a00002 	mov	r0, r2
  134e78:	ebff3e73 	bl	10484c <ueth_hw_interrupt_install>
#endif

    return RT_EOK;
  134e7c:	e3a03000 	mov	r3, #0
}
  134e80:	e1a00003 	mov	r0, r3
  134e84:	e24bd004 	sub	sp, fp, #4
  134e88:	e8bd8800 	pop	{fp, pc}

00134e8c <rt_imx6ul_eth_control>:

static rt_err_t rt_imx6ul_eth_control(rt_device_t dev, int cmd, void *args)
{
  134e8c:	e92d4800 	push	{fp, lr}
  134e90:	e28db004 	add	fp, sp, #4
  134e94:	e24dd028 	sub	sp, sp, #40	; 0x28
  134e98:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  134e9c:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  134ea0:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
    struct rt_imx6ul_ethps *imx6ul_device = (struct rt_imx6ul_ethps *)dev;
  134ea4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  134ea8:	e50b3008 	str	r3, [fp, #-8]

    
    switch (cmd)
  134eac:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  134eb0:	e3530001 	cmp	r3, #1
  134eb4:	0a000000 	beq	134ebc <rt_imx6ul_eth_control+0x30>
            return -RT_ERROR;
        }
        break;

    default :
        break;
  134eb8:	ea000070 	b	135080 <rt_imx6ul_eth_control+0x1f4>
        if (args)
  134ebc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  134ec0:	e3530000 	cmp	r3, #0
  134ec4:	0a00006b 	beq	135078 <rt_imx6ul_eth_control+0x1ec>
            rt_uint32_t uid_crc = 0;
  134ec8:	e3a03000 	mov	r3, #0
  134ecc:	e50b300c 	str	r3, [fp, #-12]
            ocotp_base = (OCOTP_Type *)ueth_remap((void*)OCOTP_BASE, UETH_REMAP, 0x1000);
  134ed0:	e3a02a01 	mov	r2, #4096	; 0x1000
  134ed4:	e3a01001 	mov	r1, #1
  134ed8:	e3a00903 	mov	r0, #49152	; 0xc000
  134edc:	e340021b 	movt	r0, #539	; 0x21b
  134ee0:	ebff3d79 	bl	1044cc <ueth_remap>
  134ee4:	e50b0010 	str	r0, [fp, #-16]
            uid[0] = ocotp_base->CFG0;
  134ee8:	e51b3010 	ldr	r3, [fp, #-16]
  134eec:	e5933410 	ldr	r3, [r3, #1040]	; 0x410
  134ef0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
            uid[1] = ocotp_base->CFG1;
  134ef4:	e51b3010 	ldr	r3, [fp, #-16]
  134ef8:	e5933420 	ldr	r3, [r3, #1056]	; 0x420
  134efc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
            ueth_remap(ocotp_base, UETH_UNMAP, 0);
  134f00:	e3a02000 	mov	r2, #0
  134f04:	e3a01002 	mov	r1, #2
  134f08:	e51b0010 	ldr	r0, [fp, #-16]
  134f0c:	ebff3d6e 	bl	1044cc <ueth_remap>
            LOG_D("UNIQUE_ID is %x%x",uid[0], uid[1]);
  134f10:	e3090dc0 	movw	r0, #40384	; 0x9dc0
  134f14:	e3400014 	movt	r0, #20
  134f18:	ebff387d 	bl	103114 <rt_kprintf>
  134f1c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  134f20:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  134f24:	e1a01003 	mov	r1, r3
  134f28:	e3090ec8 	movw	r0, #40648	; 0x9ec8
  134f2c:	e3400014 	movt	r0, #20
  134f30:	ebff3877 	bl	103114 <rt_kprintf>
  134f34:	e3090de4 	movw	r0, #40420	; 0x9de4
  134f38:	e3400014 	movt	r0, #20
  134f3c:	ebff3874 	bl	103114 <rt_kprintf>
            uid_crc = uid[0] - uid[1];
  134f40:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  134f44:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  134f48:	e0423003 	sub	r3, r2, r3
  134f4c:	e50b300c 	str	r3, [fp, #-12]
            LOG_D("UNIQUE_ID change to 32 bits %x", uid_crc);
  134f50:	e3090dc0 	movw	r0, #40384	; 0x9dc0
  134f54:	e3400014 	movt	r0, #20
  134f58:	ebff386d 	bl	103114 <rt_kprintf>
  134f5c:	e51b100c 	ldr	r1, [fp, #-12]
  134f60:	e3090edc 	movw	r0, #40668	; 0x9edc
  134f64:	e3400014 	movt	r0, #20
  134f68:	ebff3869 	bl	103114 <rt_kprintf>
  134f6c:	e3090de4 	movw	r0, #40420	; 0x9de4
  134f70:	e3400014 	movt	r0, #20
  134f74:	ebff3866 	bl	103114 <rt_kprintf>
            if (imx6ul_device->enet_phy_base_addr == ENET1)
  134f78:	e51b3008 	ldr	r3, [fp, #-8]
  134f7c:	e593209c 	ldr	r2, [r3, #156]	; 0x9c
  134f80:	e3a03902 	mov	r3, #32768	; 0x8000
  134f84:	e3403218 	movt	r3, #536	; 0x218
  134f88:	e1520003 	cmp	r2, r3
  134f8c:	1a000019 	bne	134ff8 <rt_imx6ul_eth_control+0x16c>
                imx6ul_device->dev_addr[0] = 0xa8;
  134f90:	e51b3008 	ldr	r3, [fp, #-8]
  134f94:	e3e02057 	mvn	r2, #87	; 0x57
  134f98:	e5c32078 	strb	r2, [r3, #120]	; 0x78
                imx6ul_device->dev_addr[1] = 0x5e;
  134f9c:	e51b3008 	ldr	r3, [fp, #-8]
  134fa0:	e3a0205e 	mov	r2, #94	; 0x5e
  134fa4:	e5c32079 	strb	r2, [r3, #121]	; 0x79
                imx6ul_device->dev_addr[2] = 0x45;
  134fa8:	e51b3008 	ldr	r3, [fp, #-8]
  134fac:	e3a02045 	mov	r2, #69	; 0x45
  134fb0:	e5c3207a 	strb	r2, [r3, #122]	; 0x7a
                imx6ul_device->dev_addr[3] = (uid_crc>>16) & 0x7f;
  134fb4:	e51b300c 	ldr	r3, [fp, #-12]
  134fb8:	e1a03823 	lsr	r3, r3, #16
  134fbc:	e6ef3073 	uxtb	r3, r3
  134fc0:	e203307f 	and	r3, r3, #127	; 0x7f
  134fc4:	e6ef2073 	uxtb	r2, r3
  134fc8:	e51b3008 	ldr	r3, [fp, #-8]
  134fcc:	e5c3207b 	strb	r2, [r3, #123]	; 0x7b
                imx6ul_device->dev_addr[4] = (uid_crc>>8) & 0xff;
  134fd0:	e51b300c 	ldr	r3, [fp, #-12]
  134fd4:	e1a03423 	lsr	r3, r3, #8
  134fd8:	e6ef2073 	uxtb	r2, r3
  134fdc:	e51b3008 	ldr	r3, [fp, #-8]
  134fe0:	e5c3207c 	strb	r2, [r3, #124]	; 0x7c
                imx6ul_device->dev_addr[5] = uid_crc & 0xff;
  134fe4:	e51b300c 	ldr	r3, [fp, #-12]
  134fe8:	e6ef2073 	uxtb	r2, r3
  134fec:	e51b3008 	ldr	r3, [fp, #-8]
  134ff0:	e5c3207d 	strb	r2, [r3, #125]	; 0x7d
  134ff4:	ea000018 	b	13505c <rt_imx6ul_eth_control+0x1d0>
                imx6ul_device->dev_addr[0] = 0xa8;
  134ff8:	e51b3008 	ldr	r3, [fp, #-8]
  134ffc:	e3e02057 	mvn	r2, #87	; 0x57
  135000:	e5c32078 	strb	r2, [r3, #120]	; 0x78
                imx6ul_device->dev_addr[1] = 0x5e;
  135004:	e51b3008 	ldr	r3, [fp, #-8]
  135008:	e3a0205e 	mov	r2, #94	; 0x5e
  13500c:	e5c32079 	strb	r2, [r3, #121]	; 0x79
                imx6ul_device->dev_addr[2] = 0x46;
  135010:	e51b3008 	ldr	r3, [fp, #-8]
  135014:	e3a02046 	mov	r2, #70	; 0x46
  135018:	e5c3207a 	strb	r2, [r3, #122]	; 0x7a
                imx6ul_device->dev_addr[3] = (uid_crc >> 16) & 0x7f;
  13501c:	e51b300c 	ldr	r3, [fp, #-12]
  135020:	e1a03823 	lsr	r3, r3, #16
  135024:	e6ef3073 	uxtb	r3, r3
  135028:	e203307f 	and	r3, r3, #127	; 0x7f
  13502c:	e6ef2073 	uxtb	r2, r3
  135030:	e51b3008 	ldr	r3, [fp, #-8]
  135034:	e5c3207b 	strb	r2, [r3, #123]	; 0x7b
                imx6ul_device->dev_addr[4] = (uid_crc >> 8) & 0xff;
  135038:	e51b300c 	ldr	r3, [fp, #-12]
  13503c:	e1a03423 	lsr	r3, r3, #8
  135040:	e6ef2073 	uxtb	r2, r3
  135044:	e51b3008 	ldr	r3, [fp, #-8]
  135048:	e5c3207c 	strb	r2, [r3, #124]	; 0x7c
                imx6ul_device->dev_addr[5] = uid_crc & 0xff;
  13504c:	e51b300c 	ldr	r3, [fp, #-12]
  135050:	e6ef2073 	uxtb	r2, r3
  135054:	e51b3008 	ldr	r3, [fp, #-8]
  135058:	e5c3207d 	strb	r2, [r3, #125]	; 0x7d
            memcpy(args, imx6ul_device->dev_addr, MAX_ADDR_LEN);
  13505c:	e51b3008 	ldr	r3, [fp, #-8]
  135060:	e2833078 	add	r3, r3, #120	; 0x78
  135064:	e3a02006 	mov	r2, #6
  135068:	e1a01003 	mov	r1, r3
  13506c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  135070:	eb002fc7 	bl	140f94 <memcpy>
        break;
  135074:	ea000001 	b	135080 <rt_imx6ul_eth_control+0x1f4>
            return -RT_ERROR;
  135078:	e3e03000 	mvn	r3, #0
  13507c:	ea000000 	b	135084 <rt_imx6ul_eth_control+0x1f8>
    }
    return RT_EOK;
  135080:	e3a03000 	mov	r3, #0
}
  135084:	e1a00003 	mov	r0, r3
  135088:	e24bd004 	sub	sp, fp, #4
  13508c:	e8bd8800 	pop	{fp, pc}

00135090 <read_data_from_eth>:

static status_t read_data_from_eth(rt_device_t dev,void *read_data,uint16_t *read_length)
{
  135090:	e92d4800 	push	{fp, lr}
  135094:	e28db004 	add	fp, sp, #4
  135098:	e24dd038 	sub	sp, sp, #56	; 0x38
  13509c:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  1350a0:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  1350a4:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
    status_t status = 0;
  1350a8:	e3a03000 	mov	r3, #0
  1350ac:	e50b3008 	str	r3, [fp, #-8]
    uint16_t length = 0;
  1350b0:	e3a03000 	mov	r3, #0
  1350b4:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
    ENET_Type *base_addr = RT_NULL;
  1350b8:	e3a03000 	mov	r3, #0
  1350bc:	e50b300c 	str	r3, [fp, #-12]
    enet_config_t *config;
    enet_handle_t *handle;
    enet_buffer_config_t *buffConfig;
    struct rt_imx6ul_ethps *imx6ul_device = (struct rt_imx6ul_ethps *)dev;
  1350c0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1350c4:	e50b3010 	str	r3, [fp, #-16]
    base_addr = imx6ul_device->enet_virtual_base_addr;
  1350c8:	e51b3010 	ldr	r3, [fp, #-16]
  1350cc:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
  1350d0:	e50b300c 	str	r3, [fp, #-12]
    config = &imx6ul_device->config;
  1350d4:	e51b3010 	ldr	r3, [fp, #-16]
  1350d8:	e28330dc 	add	r3, r3, #220	; 0xdc
  1350dc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    handle = &imx6ul_device->handle;
  1350e0:	e51b3010 	ldr	r3, [fp, #-16]
  1350e4:	e2833c01 	add	r3, r3, #256	; 0x100
  1350e8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    buffConfig = &imx6ul_device->buffConfig;
  1350ec:	e51b3010 	ldr	r3, [fp, #-16]
  1350f0:	e28330a8 	add	r3, r3, #168	; 0xa8
  1350f4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    /* Get the Frame size */
    status = ENET_ReadFrame(base_addr,handle,config,read_data,&length);
  1350f8:	e24b301e 	sub	r3, fp, #30
  1350fc:	e58d3000 	str	r3, [sp]
  135100:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  135104:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  135108:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  13510c:	e51b000c 	ldr	r0, [fp, #-12]
  135110:	eb00088e 	bl	137350 <ENET_ReadFrame>
  135114:	e50b0008 	str	r0, [fp, #-8]
    if((status == kStatus_ENET_RxFrameEmpty)||(status == kStatus_ENET_RxFrameError))
  135118:	e51b3008 	ldr	r3, [fp, #-8]
  13511c:	e3002fa2 	movw	r2, #4002	; 0xfa2
  135120:	e1530002 	cmp	r3, r2
  135124:	0a000002 	beq	135134 <read_data_from_eth+0xa4>
  135128:	e51b3008 	ldr	r3, [fp, #-8]
  13512c:	e3530efa 	cmp	r3, #4000	; 0xfa0
  135130:	1a00001a 	bne	1351a0 <read_data_from_eth+0x110>
    {
        ENET_EnableInterrupts(base_addr,ENET_RX_INTERRUPT);
  135134:	e3a01403 	mov	r1, #50331648	; 0x3000000
  135138:	e51b000c 	ldr	r0, [fp, #-12]
  13513c:	ebfffdae 	bl	1347fc <ENET_EnableInterrupts>
        if(status == kStatus_ENET_RxFrameError)
  135140:	e51b3008 	ldr	r3, [fp, #-8]
  135144:	e3530efa 	cmp	r3, #4000	; 0xfa0
  135148:	1a00000e 	bne	135188 <read_data_from_eth+0xf8>
        {
            /*recv error happend reinitialize mac*/
            ENET_Init(base_addr, handle, config, buffConfig, imx6ul_device->dev_addr, SYS_CLOCK_HZ);
  13514c:	e51b3010 	ldr	r3, [fp, #-16]
  135150:	e2832078 	add	r2, r3, #120	; 0x78
  135154:	e3a03d52 	mov	r3, #5248	; 0x1480
  135158:	e34033ef 	movt	r3, #1007	; 0x3ef
  13515c:	e58d3004 	str	r3, [sp, #4]
  135160:	e58d2000 	str	r2, [sp]
  135164:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  135168:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  13516c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  135170:	e51b000c 	ldr	r0, [fp, #-12]
  135174:	eb0003bf 	bl	136078 <ENET_Init>
            ENET_ActiveRead(base_addr);
  135178:	e51b000c 	ldr	r0, [fp, #-12]
  13517c:	ebfffd93 	bl	1347d0 <ENET_ActiveRead>
            return kStatus_ENET_RxFrameError;
  135180:	e3a03efa 	mov	r3, #4000	; 0xfa0
  135184:	ea000009 	b	1351b0 <read_data_from_eth+0x120>
        }
        else if(status == kStatus_ENET_RxFrameEmpty)
  135188:	e51b3008 	ldr	r3, [fp, #-8]
  13518c:	e3002fa2 	movw	r2, #4002	; 0xfa2
  135190:	e1530002 	cmp	r3, r2
  135194:	1a000001 	bne	1351a0 <read_data_from_eth+0x110>
        {
            return kStatus_ENET_RxFrameEmpty;
  135198:	e3003fa2 	movw	r3, #4002	; 0xfa2
  13519c:	ea000003 	b	1351b0 <read_data_from_eth+0x120>
        }
    }
    *read_length = length;
  1351a0:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
  1351a4:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1351a8:	e1c320b0 	strh	r2, [r3]
    return status;
  1351ac:	e51b3008 	ldr	r3, [fp, #-8]
}
  1351b0:	e1a00003 	mov	r0, r3
  1351b4:	e24bd004 	sub	sp, fp, #4
  1351b8:	e8bd8800 	pop	{fp, pc}

001351bc <rt_imx6ul_eth_tx>:

#ifdef RT_USING_LWIP
/* transmit data*/
rt_err_t rt_imx6ul_eth_tx(rt_device_t dev, struct pbuf *p)
{
  1351bc:	e92d4800 	push	{fp, lr}
  1351c0:	e28db004 	add	fp, sp, #4
  1351c4:	e24dd030 	sub	sp, sp, #48	; 0x30
  1351c8:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  1351cc:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
    struct pbuf *q = RT_NULL;
  1351d0:	e3a03000 	mov	r3, #0
  1351d4:	e50b3008 	str	r3, [fp, #-8]
    uint16_t offset = 0;
  1351d8:	e3a03000 	mov	r3, #0
  1351dc:	e14b30ba 	strh	r3, [fp, #-10]
    uint32_t last_flag = 0;
  1351e0:	e3a03000 	mov	r3, #0
  1351e4:	e50b3010 	str	r3, [fp, #-16]
    status_t status;
    ENET_Type *base_addr = RT_NULL;
  1351e8:	e3a03000 	mov	r3, #0
  1351ec:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    enet_handle_t *handle;
    struct rt_imx6ul_ethps *imx6ul_device = (struct rt_imx6ul_ethps *)dev;
  1351f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1351f4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    base_addr = imx6ul_device->enet_virtual_base_addr;
  1351f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1351fc:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
  135200:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    handle = &imx6ul_device->handle;
  135204:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  135208:	e2833c01 	add	r3, r3, #256	; 0x100
  13520c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(p);
  135210:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  135214:	e3530000 	cmp	r3, #0
  135218:	1a000005 	bne	135234 <rt_imx6ul_eth_tx+0x78>
  13521c:	e3a02e1b 	mov	r2, #432	; 0x1b0
  135220:	e30a10a8 	movw	r1, #41128	; 0xa0a8
  135224:	e3401014 	movt	r1, #20
  135228:	e3090efc 	movw	r0, #40700	; 0x9efc
  13522c:	e3400014 	movt	r0, #20
  135230:	ebff38d8 	bl	103598 <rt_assert_handler>

    for(q = p;q != RT_NULL;q=q->next)
  135234:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  135238:	e50b3008 	str	r3, [fp, #-8]
  13523c:	ea000020 	b	1352c4 <rt_imx6ul_eth_tx+0x108>
    {
        if(q->next == RT_NULL)
  135240:	e51b3008 	ldr	r3, [fp, #-8]
  135244:	e5933000 	ldr	r3, [r3]
  135248:	e3530000 	cmp	r3, #0
  13524c:	1a000002 	bne	13525c <rt_imx6ul_eth_tx+0xa0>
        {
            last_flag = 1;
  135250:	e3a03001 	mov	r3, #1
  135254:	e50b3010 	str	r3, [fp, #-16]
  135258:	ea000001 	b	135264 <rt_imx6ul_eth_tx+0xa8>
        }
        else
        {
            last_flag = 0;
  13525c:	e3a03000 	mov	r3, #0
  135260:	e50b3010 	str	r3, [fp, #-16]
        }
        status = ENET_SendFrame(base_addr, handle, q->payload, q->len,last_flag);
  135264:	e51b3008 	ldr	r3, [fp, #-8]
  135268:	e5932004 	ldr	r2, [r3, #4]
  13526c:	e51b3008 	ldr	r3, [fp, #-8]
  135270:	e1d310ba 	ldrh	r1, [r3, #10]
  135274:	e51b3010 	ldr	r3, [fp, #-16]
  135278:	e58d3000 	str	r3, [sp]
  13527c:	e1a03001 	mov	r3, r1
  135280:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  135284:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  135288:	eb0008fb 	bl	13767c <ENET_SendFrame>
  13528c:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0

        offset = offset + q->len;
  135290:	e51b3008 	ldr	r3, [fp, #-8]
  135294:	e1d320ba 	ldrh	r2, [r3, #10]
  135298:	e15b30ba 	ldrh	r3, [fp, #-10]
  13529c:	e0823003 	add	r3, r2, r3
  1352a0:	e14b30ba 	strh	r3, [fp, #-10]
        if(status == kStatus_Success)
  1352a4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1352a8:	e3530000 	cmp	r3, #0
  1352ac:	0a000001 	beq	1352b8 <rt_imx6ul_eth_tx+0xfc>
        {
        }
        else
        {
            return RT_ERROR;
  1352b0:	e3a03001 	mov	r3, #1
  1352b4:	ea000015 	b	135310 <rt_imx6ul_eth_tx+0x154>
    for(q = p;q != RT_NULL;q=q->next)
  1352b8:	e51b3008 	ldr	r3, [fp, #-8]
  1352bc:	e5933000 	ldr	r3, [r3]
  1352c0:	e50b3008 	str	r3, [fp, #-8]
  1352c4:	e51b3008 	ldr	r3, [fp, #-8]
  1352c8:	e3530000 	cmp	r3, #0
  1352cc:	1affffdb 	bne	135240 <rt_imx6ul_eth_tx+0x84>
        }
    }
    if(offset > ENET_FRAME_MAX_FRAMELEN)
  1352d0:	e15b30ba 	ldrh	r3, [fp, #-10]
  1352d4:	e30025ee 	movw	r2, #1518	; 0x5ee
  1352d8:	e1530002 	cmp	r3, r2
  1352dc:	9a00000a 	bls	13530c <rt_imx6ul_eth_tx+0x150>
    {
        LOG_E("net error send length %d exceed max length",offset);
  1352e0:	e3090e00 	movw	r0, #40448	; 0x9e00
  1352e4:	e3400014 	movt	r0, #20
  1352e8:	ebff3789 	bl	103114 <rt_kprintf>
  1352ec:	e15b30ba 	ldrh	r3, [fp, #-10]
  1352f0:	e1a01003 	mov	r1, r3
  1352f4:	e3090f00 	movw	r0, #40704	; 0x9f00
  1352f8:	e3400014 	movt	r0, #20
  1352fc:	ebff3784 	bl	103114 <rt_kprintf>
  135300:	e3090de4 	movw	r0, #40420	; 0x9de4
  135304:	e3400014 	movt	r0, #20
  135308:	ebff3781 	bl	103114 <rt_kprintf>
    }
    return RT_EOK;
  13530c:	e3a03000 	mov	r3, #0
}
  135310:	e1a00003 	mov	r0, r3
  135314:	e24bd004 	sub	sp, fp, #4
  135318:	e8bd8800 	pop	{fp, pc}

0013531c <rt_imx6ul_eth_rx>:

struct pbuf *rt_imx6ul_eth_rx(rt_device_t dev)
{
  13531c:	e92d4800 	push	{fp, lr}
  135320:	e28db004 	add	fp, sp, #4
  135324:	e24dd018 	sub	sp, sp, #24
  135328:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
    static struct pbuf *p_s = RT_NULL;
    struct pbuf *p = RT_NULL;
  13532c:	e3a03000 	mov	r3, #0
  135330:	e50b3008 	str	r3, [fp, #-8]
    status_t status;
    uint16_t length = 0;
  135334:	e3a03000 	mov	r3, #0
  135338:	e14b30be 	strh	r3, [fp, #-14]

    if(p_s == RT_NULL)
  13533c:	e30f3bf4 	movw	r3, #64500	; 0xfbf4
  135340:	e3403014 	movt	r3, #20
  135344:	e5933000 	ldr	r3, [r3]
  135348:	e3530000 	cmp	r3, #0
  13534c:	1a00000e 	bne	13538c <rt_imx6ul_eth_rx+0x70>
    {
        p_s = pbuf_alloc(PBUF_RAW, ENET_FRAME_MAX_FRAMELEN, PBUF_POOL);
  135350:	e3a02003 	mov	r2, #3
  135354:	e30015ee 	movw	r1, #1518	; 0x5ee
  135358:	e3a00004 	mov	r0, #4
  13535c:	ebff944d 	bl	11a498 <pbuf_alloc>
  135360:	e1a02000 	mov	r2, r0
  135364:	e30f3bf4 	movw	r3, #64500	; 0xfbf4
  135368:	e3403014 	movt	r3, #20
  13536c:	e5832000 	str	r2, [r3]
        if(p_s == RT_NULL)
  135370:	e30f3bf4 	movw	r3, #64500	; 0xfbf4
  135374:	e3403014 	movt	r3, #20
  135378:	e5933000 	ldr	r3, [r3]
  13537c:	e3530000 	cmp	r3, #0
  135380:	1a000001 	bne	13538c <rt_imx6ul_eth_rx+0x70>
        {
            return RT_NULL;
  135384:	e3a03000 	mov	r3, #0
  135388:	ea00002f 	b	13544c <rt_imx6ul_eth_rx+0x130>
        }
    }
    p = p_s;
  13538c:	e30f3bf4 	movw	r3, #64500	; 0xfbf4
  135390:	e3403014 	movt	r3, #20
  135394:	e5933000 	ldr	r3, [r3]
  135398:	e50b3008 	str	r3, [fp, #-8]
    status = read_data_from_eth(dev,p->payload,&length);
  13539c:	e51b3008 	ldr	r3, [fp, #-8]
  1353a0:	e5933004 	ldr	r3, [r3, #4]
  1353a4:	e24b200e 	sub	r2, fp, #14
  1353a8:	e1a01003 	mov	r1, r3
  1353ac:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1353b0:	ebffff36 	bl	135090 <read_data_from_eth>
  1353b4:	e50b000c 	str	r0, [fp, #-12]
    if(status == kStatus_ENET_RxFrameEmpty)
  1353b8:	e51b300c 	ldr	r3, [fp, #-12]
  1353bc:	e3002fa2 	movw	r2, #4002	; 0xfa2
  1353c0:	e1530002 	cmp	r3, r2
  1353c4:	1a000001 	bne	1353d0 <rt_imx6ul_eth_rx+0xb4>
    {
        return RT_NULL;
  1353c8:	e3a03000 	mov	r3, #0
  1353cc:	ea00001e 	b	13544c <rt_imx6ul_eth_rx+0x130>
    }
    else if(status == kStatus_ENET_RxFrameError)
  1353d0:	e51b300c 	ldr	r3, [fp, #-12]
  1353d4:	e3530efa 	cmp	r3, #4000	; 0xfa0
  1353d8:	1a000001 	bne	1353e4 <rt_imx6ul_eth_rx+0xc8>
    {
        return RT_NULL;
  1353dc:	e3a03000 	mov	r3, #0
  1353e0:	ea000019 	b	13544c <rt_imx6ul_eth_rx+0x130>
    }
    if(length > ENET_FRAME_MAX_FRAMELEN)
  1353e4:	e15b30be 	ldrh	r3, [fp, #-14]
  1353e8:	e30025ee 	movw	r2, #1518	; 0x5ee
  1353ec:	e1530002 	cmp	r3, r2
  1353f0:	9a00000c 	bls	135428 <rt_imx6ul_eth_rx+0x10c>
    {
        LOG_E("net error recv length %d exceed max length",length);
  1353f4:	e3090e00 	movw	r0, #40448	; 0x9e00
  1353f8:	e3400014 	movt	r0, #20
  1353fc:	ebff3744 	bl	103114 <rt_kprintf>
  135400:	e15b30be 	ldrh	r3, [fp, #-14]
  135404:	e1a01003 	mov	r1, r3
  135408:	e3090f2c 	movw	r0, #40748	; 0x9f2c
  13540c:	e3400014 	movt	r0, #20
  135410:	ebff373f 	bl	103114 <rt_kprintf>
  135414:	e3090de4 	movw	r0, #40420	; 0x9de4
  135418:	e3400014 	movt	r0, #20
  13541c:	ebff373c 	bl	103114 <rt_kprintf>
        return RT_NULL;
  135420:	e3a03000 	mov	r3, #0
  135424:	ea000008 	b	13544c <rt_imx6ul_eth_rx+0x130>
    }
    pbuf_realloc(p, length);
  135428:	e15b30be 	ldrh	r3, [fp, #-14]
  13542c:	e1a01003 	mov	r1, r3
  135430:	e51b0008 	ldr	r0, [fp, #-8]
  135434:	ebff95d5 	bl	11ab90 <pbuf_realloc>
    p_s = RT_NULL;
  135438:	e30f3bf4 	movw	r3, #64500	; 0xfbf4
  13543c:	e3403014 	movt	r3, #20
  135440:	e3a02000 	mov	r2, #0
  135444:	e5832000 	str	r2, [r3]
    return p;
  135448:	e51b3008 	ldr	r3, [fp, #-8]
}
  13544c:	e1a00003 	mov	r0, r3
  135450:	e24bd004 	sub	sp, fp, #4
  135454:	e8bd8800 	pop	{fp, pc}

00135458 <rt_imx6ul_eth_open>:
#endif

static rt_err_t rt_imx6ul_eth_open(rt_device_t dev, rt_uint16_t oflag)
{
  135458:	e92d4800 	push	{fp, lr}
  13545c:	e28db004 	add	fp, sp, #4
  135460:	e24dd010 	sub	sp, sp, #16
  135464:	e50b0010 	str	r0, [fp, #-16]
  135468:	e1a03001 	mov	r3, r1
  13546c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    struct rt_imx6ul_ethps *imx6ul_device = (struct rt_imx6ul_ethps *)dev;
  135470:	e51b3010 	ldr	r3, [fp, #-16]
  135474:	e50b3008 	str	r3, [fp, #-8]
    ENET_Type *base_addr = imx6ul_device->enet_virtual_base_addr;
  135478:	e51b3008 	ldr	r3, [fp, #-8]
  13547c:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
  135480:	e50b300c 	str	r3, [fp, #-12]
    ENET_EnableInterrupts(base_addr,ENET_RX_INTERRUPT);
  135484:	e3a01403 	mov	r1, #50331648	; 0x3000000
  135488:	e51b000c 	ldr	r0, [fp, #-12]
  13548c:	ebfffcda 	bl	1347fc <ENET_EnableInterrupts>

    return RT_EOK;
  135490:	e3a03000 	mov	r3, #0
}
  135494:	e1a00003 	mov	r0, r3
  135498:	e24bd004 	sub	sp, fp, #4
  13549c:	e8bd8800 	pop	{fp, pc}

001354a0 <rt_imx6ul_eth_close>:

static rt_err_t rt_imx6ul_eth_close(rt_device_t dev)
{
  1354a0:	e92d4800 	push	{fp, lr}
  1354a4:	e28db004 	add	fp, sp, #4
  1354a8:	e24dd010 	sub	sp, sp, #16
  1354ac:	e50b0010 	str	r0, [fp, #-16]
    struct rt_imx6ul_ethps *imx6ul_device = (struct rt_imx6ul_ethps *)dev;
  1354b0:	e51b3010 	ldr	r3, [fp, #-16]
  1354b4:	e50b3008 	str	r3, [fp, #-8]
    ENET_DisableInterrupts(imx6ul_device->enet_virtual_base_addr,ENET_RX_INTERRUPT);
  1354b8:	e51b3008 	ldr	r3, [fp, #-8]
  1354bc:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
  1354c0:	e3a01403 	mov	r1, #50331648	; 0x3000000
  1354c4:	e1a00003 	mov	r0, r3
  1354c8:	ebfffcda 	bl	134838 <ENET_DisableInterrupts>
    return RT_EOK;
  1354cc:	e3a03000 	mov	r3, #0
}
  1354d0:	e1a00003 	mov	r0, r3
  1354d4:	e24bd004 	sub	sp, fp, #4
  1354d8:	e8bd8800 	pop	{fp, pc}

001354dc <rt_imx6ul_eth_read>:

static rt_size_t rt_imx6ul_eth_read(rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size)
{
  1354dc:	e92d4800 	push	{fp, lr}
  1354e0:	e28db004 	add	fp, sp, #4
  1354e4:	e24dd018 	sub	sp, sp, #24
  1354e8:	e50b0010 	str	r0, [fp, #-16]
  1354ec:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1354f0:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  1354f4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    uint16_t length = 0;
  1354f8:	e3a03000 	mov	r3, #0
  1354fc:	e14b30ba 	strh	r3, [fp, #-10]
    status_t status;
    if(!buffer) 
  135500:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  135504:	e3530000 	cmp	r3, #0
  135508:	1a00000c 	bne	135540 <rt_imx6ul_eth_read+0x64>
    {
        LOG_E("eth read invalid parameter buffer %p size %d",buffer,size);
  13550c:	e3090e00 	movw	r0, #40448	; 0x9e00
  135510:	e3400014 	movt	r0, #20
  135514:	ebff36fe 	bl	103114 <rt_kprintf>
  135518:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  13551c:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  135520:	e3090f58 	movw	r0, #40792	; 0x9f58
  135524:	e3400014 	movt	r0, #20
  135528:	ebff36f9 	bl	103114 <rt_kprintf>
  13552c:	e3090de4 	movw	r0, #40420	; 0x9de4
  135530:	e3400014 	movt	r0, #20
  135534:	ebff36f6 	bl	103114 <rt_kprintf>
        return 0;
  135538:	e3a03000 	mov	r3, #0
  13553c:	ea00000f 	b	135580 <rt_imx6ul_eth_read+0xa4>
    }
    status = read_data_from_eth(dev,buffer,&length);
  135540:	e24b300a 	sub	r3, fp, #10
  135544:	e1a02003 	mov	r2, r3
  135548:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  13554c:	e51b0010 	ldr	r0, [fp, #-16]
  135550:	ebfffece 	bl	135090 <read_data_from_eth>
  135554:	e50b0008 	str	r0, [fp, #-8]
    if((status == kStatus_ENET_RxFrameEmpty) || (status == kStatus_ENET_RxFrameError))
  135558:	e51b3008 	ldr	r3, [fp, #-8]
  13555c:	e3002fa2 	movw	r2, #4002	; 0xfa2
  135560:	e1530002 	cmp	r3, r2
  135564:	0a000002 	beq	135574 <rt_imx6ul_eth_read+0x98>
  135568:	e51b3008 	ldr	r3, [fp, #-8]
  13556c:	e3530efa 	cmp	r3, #4000	; 0xfa0
  135570:	1a000001 	bne	13557c <rt_imx6ul_eth_read+0xa0>
    {
        return 0;
  135574:	e3a03000 	mov	r3, #0
  135578:	ea000000 	b	135580 <rt_imx6ul_eth_read+0xa4>
    }
    return (rt_size_t)length;
  13557c:	e15b30ba 	ldrh	r3, [fp, #-10]
}
  135580:	e1a00003 	mov	r0, r3
  135584:	e24bd004 	sub	sp, fp, #4
  135588:	e8bd8800 	pop	{fp, pc}

0013558c <rt_imx6ul_eth_write>:

static rt_size_t rt_imx6ul_eth_write(rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size)
{
  13558c:	e92d4800 	push	{fp, lr}
  135590:	e28db004 	add	fp, sp, #4
  135594:	e24dd028 	sub	sp, sp, #40	; 0x28
  135598:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  13559c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  1355a0:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  1355a4:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    status_t status;
    struct rt_imx6ul_ethps *imx6ul_device = (struct rt_imx6ul_ethps *)dev;
  1355a8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1355ac:	e50b3008 	str	r3, [fp, #-8]
    ENET_Type *base_addr = imx6ul_device->enet_virtual_base_addr;
  1355b0:	e51b3008 	ldr	r3, [fp, #-8]
  1355b4:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
  1355b8:	e50b300c 	str	r3, [fp, #-12]
    enet_handle_t *handle = &imx6ul_device->handle;
  1355bc:	e51b3008 	ldr	r3, [fp, #-8]
  1355c0:	e2833c01 	add	r3, r3, #256	; 0x100
  1355c4:	e50b3010 	str	r3, [fp, #-16]

    if((!buffer) || (size > ENET_FRAME_MAX_FRAMELEN))
  1355c8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1355cc:	e3530000 	cmp	r3, #0
  1355d0:	0a000003 	beq	1355e4 <rt_imx6ul_eth_write+0x58>
  1355d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1355d8:	e30025ee 	movw	r2, #1518	; 0x5ee
  1355dc:	e1530002 	cmp	r3, r2
  1355e0:	9a00000a 	bls	135610 <rt_imx6ul_eth_write+0x84>
    {
        LOG_E("eth write invalid parameter buffer %p size %d",buffer,size);
  1355e4:	e3090e00 	movw	r0, #40448	; 0x9e00
  1355e8:	e3400014 	movt	r0, #20
  1355ec:	ebff36c8 	bl	103114 <rt_kprintf>
  1355f0:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  1355f4:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  1355f8:	e3090f88 	movw	r0, #40840	; 0x9f88
  1355fc:	e3400014 	movt	r0, #20
  135600:	ebff36c3 	bl	103114 <rt_kprintf>
  135604:	e3090de4 	movw	r0, #40420	; 0x9de4
  135608:	e3400014 	movt	r0, #20
  13560c:	ebff36c0 	bl	103114 <rt_kprintf>
    }
    status = ENET_SendFrame(base_addr, handle, buffer, size,1);
  135610:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  135614:	e6ff2073 	uxth	r2, r3
  135618:	e3a03001 	mov	r3, #1
  13561c:	e58d3000 	str	r3, [sp]
  135620:	e1a03002 	mov	r3, r2
  135624:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
  135628:	e51b1010 	ldr	r1, [fp, #-16]
  13562c:	e51b000c 	ldr	r0, [fp, #-12]
  135630:	eb000811 	bl	13767c <ENET_SendFrame>
  135634:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
    if(status != kStatus_Success)
  135638:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13563c:	e3530000 	cmp	r3, #0
  135640:	0a000001 	beq	13564c <rt_imx6ul_eth_write+0xc0>
    {
        return RT_ERROR;
  135644:	e3a03001 	mov	r3, #1
  135648:	ea000000 	b	135650 <rt_imx6ul_eth_write+0xc4>
    }

    return RT_EOK;
  13564c:	e3a03000 	mov	r3, #0
}
  135650:	e1a00003 	mov	r0, r3
  135654:	e24bd004 	sub	sp, fp, #4
  135658:	e8bd8800 	pop	{fp, pc}

0013565c <get_instance_by_base>:

int32_t get_instance_by_base(void *base)
{
  13565c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  135660:	e28db000 	add	fp, sp, #0
  135664:	e24dd014 	sub	sp, sp, #20
  135668:	e50b0010 	str	r0, [fp, #-16]
    int32_t i = 0;
  13566c:	e3a03000 	mov	r3, #0
  135670:	e50b3008 	str	r3, [fp, #-8]
    int32_t instance = 0;
  135674:	e3a03000 	mov	r3, #0
  135678:	e50b300c 	str	r3, [fp, #-12]
    for(i = 0; i < DEV_ENET_MAX; i ++)
  13567c:	e3a03000 	mov	r3, #0
  135680:	e50b3008 	str	r3, [fp, #-8]
  135684:	ea00000d 	b	1356c0 <get_instance_by_base+0x64>
    {
        if((void *)_imx6ul_eth_device[i].enet_virtual_base_addr == base)
  135688:	e30e3078 	movw	r3, #57464	; 0xe078
  13568c:	e3403014 	movt	r3, #20
  135690:	e51b2008 	ldr	r2, [fp, #-8]
  135694:	e3a01f8a 	mov	r1, #552	; 0x228
  135698:	e0020291 	mul	r2, r1, r2
  13569c:	e0833002 	add	r3, r3, r2
  1356a0:	e28330a0 	add	r3, r3, #160	; 0xa0
  1356a4:	e5933000 	ldr	r3, [r3]
  1356a8:	e51b2010 	ldr	r2, [fp, #-16]
  1356ac:	e1520003 	cmp	r2, r3
  1356b0:	0a000006 	beq	1356d0 <get_instance_by_base+0x74>
    for(i = 0; i < DEV_ENET_MAX; i ++)
  1356b4:	e51b3008 	ldr	r3, [fp, #-8]
  1356b8:	e2833001 	add	r3, r3, #1
  1356bc:	e50b3008 	str	r3, [fp, #-8]
  1356c0:	e51b3008 	ldr	r3, [fp, #-8]
  1356c4:	e3530000 	cmp	r3, #0
  1356c8:	daffffee 	ble	135688 <get_instance_by_base+0x2c>
  1356cc:	ea000000 	b	1356d4 <get_instance_by_base+0x78>
        {
            break;
  1356d0:	e320f000 	nop	{0}
        }
    }
    if(i == DEV_ENET_MAX)
  1356d4:	e51b3008 	ldr	r3, [fp, #-8]
  1356d8:	e3530001 	cmp	r3, #1
  1356dc:	1a000001 	bne	1356e8 <get_instance_by_base+0x8c>
    {
        return -1;
  1356e0:	e3e03000 	mvn	r3, #0
  1356e4:	ea000000 	b	1356ec <get_instance_by_base+0x90>
    }
    return instance;
  1356e8:	e51b300c 	ldr	r3, [fp, #-12]
    
}
  1356ec:	e1a00003 	mov	r0, r3
  1356f0:	e28bd000 	add	sp, fp, #0
  1356f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1356f8:	e12fff1e 	bx	lr

001356fc <rx_enet_callback>:

void rx_enet_callback(void *base)
{
  1356fc:	e92d4800 	push	{fp, lr}
  135700:	e28db004 	add	fp, sp, #4
  135704:	e24dd010 	sub	sp, sp, #16
  135708:	e50b0010 	str	r0, [fp, #-16]
    int32_t instance = 0;
  13570c:	e3a03000 	mov	r3, #0
  135710:	e50b3008 	str	r3, [fp, #-8]
    instance = get_instance_by_base(base);
  135714:	e51b0010 	ldr	r0, [fp, #-16]
  135718:	ebffffcf 	bl	13565c <get_instance_by_base>
  13571c:	e50b0008 	str	r0, [fp, #-8]
    if(instance == -1)
  135720:	e51b3008 	ldr	r3, [fp, #-8]
  135724:	e3730001 	cmn	r3, #1
  135728:	1a000009 	bne	135754 <rx_enet_callback+0x58>
    {
        LOG_E("interrput match base addr error");
  13572c:	e3090e00 	movw	r0, #40448	; 0x9e00
  135730:	e3400014 	movt	r0, #20
  135734:	ebff3676 	bl	103114 <rt_kprintf>
  135738:	e3090fb8 	movw	r0, #40888	; 0x9fb8
  13573c:	e3400014 	movt	r0, #20
  135740:	ebff3673 	bl	103114 <rt_kprintf>
  135744:	e3090de4 	movw	r0, #40420	; 0x9de4
  135748:	e3400014 	movt	r0, #20
  13574c:	ebff3670 	bl	103114 <rt_kprintf>
        return;
  135750:	ea00000a 	b	135780 <rx_enet_callback+0x84>
    }
    ENET_DisableInterrupts(base,ENET_RX_INTERRUPT);
  135754:	e3a01403 	mov	r1, #50331648	; 0x3000000
  135758:	e51b0010 	ldr	r0, [fp, #-16]
  13575c:	ebfffc35 	bl	134838 <ENET_DisableInterrupts>
    eth_device_ready(&(_imx6ul_eth_device[instance].parent));
  135760:	e51b3008 	ldr	r3, [fp, #-8]
  135764:	e3a02f8a 	mov	r2, #552	; 0x228
  135768:	e0020392 	mul	r2, r2, r3
  13576c:	e30e3078 	movw	r3, #57464	; 0xe078
  135770:	e3403014 	movt	r3, #20
  135774:	e0823003 	add	r3, r2, r3
  135778:	e1a00003 	mov	r0, r3
  13577c:	ebffd175 	bl	129d58 <eth_device_ready>
}
  135780:	e24bd004 	sub	sp, fp, #4
  135784:	e8bd8800 	pop	{fp, pc}

00135788 <tx_enet_callback>:

void tx_enet_callback(void *base)
{
  135788:	e92d4800 	push	{fp, lr}
  13578c:	e28db004 	add	fp, sp, #4
  135790:	e24dd008 	sub	sp, sp, #8
  135794:	e50b0008 	str	r0, [fp, #-8]
    ENET_DisableInterrupts(base,ENET_TX_INTERRUPT);
  135798:	e3a01303 	mov	r1, #201326592	; 0xc000000
  13579c:	e51b0008 	ldr	r0, [fp, #-8]
  1357a0:	ebfffc24 	bl	134838 <ENET_DisableInterrupts>
}
  1357a4:	e320f000 	nop	{0}
  1357a8:	e24bd004 	sub	sp, fp, #4
  1357ac:	e8bd8800 	pop	{fp, pc}

001357b0 <ueth_rx_interrupt_handle>:

static void* ueth_rx_interrupt_handle(ENET_Type *base)
{
  1357b0:	e92d4800 	push	{fp, lr}
  1357b4:	e28db004 	add	fp, sp, #4
  1357b8:	e24dd010 	sub	sp, sp, #16
  1357bc:	e50b0010 	str	r0, [fp, #-16]
    /* Clear the transmit interrupt event. */
    base->EIR = ENET_RX_INTERRUPT;
  1357c0:	e51b3010 	ldr	r3, [fp, #-16]
  1357c4:	e3a02403 	mov	r2, #50331648	; 0x3000000
  1357c8:	e5832004 	str	r2, [r3, #4]
    int32_t instance = 0;
  1357cc:	e3a03000 	mov	r3, #0
  1357d0:	e50b3008 	str	r3, [fp, #-8]
    instance = get_instance_by_base(base);
  1357d4:	e51b0010 	ldr	r0, [fp, #-16]
  1357d8:	ebffff9f 	bl	13565c <get_instance_by_base>
  1357dc:	e50b0008 	str	r0, [fp, #-8]
    if(instance == -1)
  1357e0:	e51b3008 	ldr	r3, [fp, #-8]
  1357e4:	e3730001 	cmn	r3, #1
  1357e8:	1a00000a 	bne	135818 <ueth_rx_interrupt_handle+0x68>
    {
        LOG_E("interrput match base addr error");
  1357ec:	e3090e00 	movw	r0, #40448	; 0x9e00
  1357f0:	e3400014 	movt	r0, #20
  1357f4:	ebff3646 	bl	103114 <rt_kprintf>
  1357f8:	e3090fb8 	movw	r0, #40888	; 0x9fb8
  1357fc:	e3400014 	movt	r0, #20
  135800:	ebff3643 	bl	103114 <rt_kprintf>
  135804:	e3090de4 	movw	r0, #40420	; 0x9de4
  135808:	e3400014 	movt	r0, #20
  13580c:	ebff3640 	bl	103114 <rt_kprintf>
        return RT_NULL;
  135810:	e3a03000 	mov	r3, #0
  135814:	ea000005 	b	135830 <ueth_rx_interrupt_handle+0x80>
    }
    return (void*)&(_imx6ul_eth_device[instance].parent);
  135818:	e51b3008 	ldr	r3, [fp, #-8]
  13581c:	e3a02f8a 	mov	r2, #552	; 0x228
  135820:	e0020392 	mul	r2, r2, r3
  135824:	e30e3078 	movw	r3, #57464	; 0xe078
  135828:	e3403014 	movt	r3, #20
  13582c:	e0823003 	add	r3, r2, r3
}
  135830:	e1a00003 	mov	r0, r3
  135834:	e24bd004 	sub	sp, fp, #4
  135838:	e8bd8800 	pop	{fp, pc}

0013583c <ueth_rx_interrupt_detect>:

int eth_init_done = 0;
void* ueth_rx_interrupt_detect(void) {
  13583c:	e92d4800 	push	{fp, lr}
  135840:	e28db004 	add	fp, sp, #4
  135844:	e24dd008 	sub	sp, sp, #8
    ENET_Type *base = _imx6ul_eth_device[0].enet_virtual_base_addr;
  135848:	e30e3078 	movw	r3, #57464	; 0xe078
  13584c:	e3403014 	movt	r3, #20
  135850:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
  135854:	e50b3008 	str	r3, [fp, #-8]
            ENET_DisableInterrupts(base, ENET_RX_INTERRUPT);
            return ueth_rx_interrupt_handle(base);
        }
    }
#else
    ueth_int_recv();
  135858:	ebff3ae5 	bl	1043f4 <ueth_int_recv>
    return ueth_rx_interrupt_handle(base);
  13585c:	e51b0008 	ldr	r0, [fp, #-8]
  135860:	ebffffd2 	bl	1357b0 <ueth_rx_interrupt_handle>
  135864:	e1a03000 	mov	r3, r0
#endif
}
  135868:	e1a00003 	mov	r0, r3
  13586c:	e24bd004 	sub	sp, fp, #4
  135870:	e8bd8800 	pop	{fp, pc}

00135874 <phy_detect_thread_entry>:

/*phy link detect thread*/
static void phy_detect_thread_entry(void *param)
{
  135874:	e92d4800 	push	{fp, lr}
  135878:	e28db004 	add	fp, sp, #4
  13587c:	e24dd020 	sub	sp, sp, #32
  135880:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
    bool link = false;
  135884:	e3a03000 	mov	r3, #0
  135888:	e54b300d 	strb	r3, [fp, #-13]
    phy_speed_t speed;
    phy_duplex_t duplex;
    ENET_Type *base_addr = RT_NULL;
  13588c:	e3a03000 	mov	r3, #0
  135890:	e50b3008 	str	r3, [fp, #-8]
    struct rt_imx6ul_ethps *imx6ul_device = (struct rt_imx6ul_ethps *)param;
  135894:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  135898:	e50b300c 	str	r3, [fp, #-12]
    base_addr = imx6ul_device->enet_virtual_base_addr;
  13589c:	e51b300c 	ldr	r3, [fp, #-12]
  1358a0:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
  1358a4:	e50b3008 	str	r3, [fp, #-8]

    phy_reset(imx6ul_device->phy_base_addr,imx6ul_device->phy_gpio_pin);
  1358a8:	e51b300c 	ldr	r3, [fp, #-12]
  1358ac:	e593221c 	ldr	r2, [r3, #540]	; 0x21c
  1358b0:	e51b300c 	ldr	r3, [fp, #-12]
  1358b4:	e5933220 	ldr	r3, [r3, #544]	; 0x220
  1358b8:	e1a01003 	mov	r1, r3
  1358bc:	e1a00002 	mov	r0, r2
  1358c0:	eb000a8e 	bl	138300 <phy_reset>
    PHY_Init(base_addr, imx6ul_device->phy_num, SYS_CLOCK_HZ,imx6ul_device->phy_id);
  1358c4:	e51b300c 	ldr	r3, [fp, #-12]
  1358c8:	e5d33098 	ldrb	r3, [r3, #152]	; 0x98
  1358cc:	e1a01003 	mov	r1, r3
  1358d0:	e51b300c 	ldr	r3, [fp, #-12]
  1358d4:	e5933224 	ldr	r3, [r3, #548]	; 0x224
  1358d8:	e3a02d52 	mov	r2, #5248	; 0x1480
  1358dc:	e34023ef 	movt	r2, #1007	; 0x3ef
  1358e0:	e51b0008 	ldr	r0, [fp, #-8]
  1358e4:	eb000af9 	bl	1384d0 <PHY_Init>
    PHY_GetLinkStatus(base_addr, imx6ul_device->phy_num, &link);
  1358e8:	e51b300c 	ldr	r3, [fp, #-12]
  1358ec:	e5d33098 	ldrb	r3, [r3, #152]	; 0x98
  1358f0:	e1a01003 	mov	r1, r3
  1358f4:	e24b300d 	sub	r3, fp, #13
  1358f8:	e1a02003 	mov	r2, r3
  1358fc:	e51b0008 	ldr	r0, [fp, #-8]
  135900:	eb000be5 	bl	13889c <PHY_GetLinkStatus>
    if (link)
  135904:	e55b300d 	ldrb	r3, [fp, #-13]
  135908:	e3530000 	cmp	r3, #0
  13590c:	0a00000d 	beq	135948 <phy_detect_thread_entry+0xd4>
    {
        /* Get the actual PHY link speed. */
        PHY_GetLinkSpeedDuplex(base_addr, imx6ul_device->phy_num, &speed, &duplex);
  135910:	e51b300c 	ldr	r3, [fp, #-12]
  135914:	e5d33098 	ldrb	r3, [r3, #152]	; 0x98
  135918:	e1a01003 	mov	r1, r3
  13591c:	e24b3018 	sub	r3, fp, #24
  135920:	e24b2014 	sub	r2, fp, #20
  135924:	e51b0008 	ldr	r0, [fp, #-8]
  135928:	eb000c04 	bl	138940 <PHY_GetLinkSpeedDuplex>
        /* Change the MII speed and duplex for actual link status. */
        imx6ul_device->config.miiSpeed = (enet_mii_speed_t)speed;
  13592c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  135930:	e51b300c 	ldr	r3, [fp, #-12]
  135934:	e58320ec 	str	r2, [r3, #236]	; 0xec
        imx6ul_device->config.miiDuplex = (enet_mii_duplex_t)duplex;
  135938:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  13593c:	e51b300c 	ldr	r3, [fp, #-12]
  135940:	e58320f0 	str	r2, [r3, #240]	; 0xf0
  135944:	ea000008 	b	13596c <phy_detect_thread_entry+0xf8>
    }
    else
    {
        LOG_W("PHY Link down, please check the cable connection and link partner setting.");
  135948:	e3090fd8 	movw	r0, #40920	; 0x9fd8
  13594c:	e3400014 	movt	r0, #20
  135950:	ebff35ef 	bl	103114 <rt_kprintf>
  135954:	e3090fec 	movw	r0, #40940	; 0x9fec
  135958:	e3400014 	movt	r0, #20
  13595c:	ebff35ec 	bl	103114 <rt_kprintf>
  135960:	e3090de4 	movw	r0, #40420	; 0x9de4
  135964:	e3400014 	movt	r0, #20
  135968:	ebff35e9 	bl	103114 <rt_kprintf>
    }

    while(1)
    {
        PHY_GetLinkStatus(base_addr, imx6ul_device->phy_num, &link);
  13596c:	e51b300c 	ldr	r3, [fp, #-12]
  135970:	e5d33098 	ldrb	r3, [r3, #152]	; 0x98
  135974:	e1a01003 	mov	r1, r3
  135978:	e24b300d 	sub	r3, fp, #13
  13597c:	e1a02003 	mov	r2, r3
  135980:	e51b0008 	ldr	r0, [fp, #-8]
  135984:	eb000bc4 	bl	13889c <PHY_GetLinkStatus>
        if(link != imx6ul_device->phy_link_status)
  135988:	e55b300d 	ldrb	r3, [fp, #-13]
  13598c:	e1a02003 	mov	r2, r3
  135990:	e51b300c 	ldr	r3, [fp, #-12]
  135994:	e5933088 	ldr	r3, [r3, #136]	; 0x88
  135998:	e1520003 	cmp	r2, r3
  13599c:	0a00000b 	beq	1359d0 <phy_detect_thread_entry+0x15c>
        {
            if(link == true)
  1359a0:	e55b300d 	ldrb	r3, [fp, #-13]
  1359a4:	e3530000 	cmp	r3, #0
  1359a8:	0a000004 	beq	1359c0 <phy_detect_thread_entry+0x14c>
            {
                PHY_StartNegotiation(base_addr,imx6ul_device->phy_num);
  1359ac:	e51b300c 	ldr	r3, [fp, #-12]
  1359b0:	e5d33098 	ldrb	r3, [r3, #152]	; 0x98
  1359b4:	e1a01003 	mov	r1, r3
  1359b8:	e51b0008 	ldr	r0, [fp, #-8]
  1359bc:	eb000a74 	bl	138394 <PHY_StartNegotiation>
                
            }            
            imx6ul_eth_link_change(imx6ul_device,link);
  1359c0:	e55b300d 	ldrb	r3, [fp, #-13]
  1359c4:	e1a01003 	mov	r1, r3
  1359c8:	e51b000c 	ldr	r0, [fp, #-12]
  1359cc:	ebfffba9 	bl	134878 <imx6ul_eth_link_change>
        }
        rt_thread_mdelay(DETECT_DELAY_ONE_SECOND);
  1359d0:	e3a00ffa 	mov	r0, #1000	; 0x3e8
  1359d4:	ebff3128 	bl	101e7c <rt_thread_mdelay>
        PHY_GetLinkStatus(base_addr, imx6ul_device->phy_num, &link);
  1359d8:	eaffffe3 	b	13596c <phy_detect_thread_entry+0xf8>

001359dc <imx6ul_eth_init>:
    rt_imx6ul_eth_write,
    rt_imx6ul_eth_control,
};

int imx6ul_eth_init(int eth_select, const char ** eth_name)
{
  1359dc:	e92d4800 	push	{fp, lr}
  1359e0:	e28db004 	add	fp, sp, #4
  1359e4:	e24dd030 	sub	sp, sp, #48	; 0x30
  1359e8:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  1359ec:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
    rt_err_t state = RT_EOK;
  1359f0:	e3a03000 	mov	r3, #0
  1359f4:	e50b3008 	str	r3, [fp, #-8]
    char link_detect[10];
    char mac_addr[MAX_ADDR_LEN];

    if (ipc_service_init() == RT_ERROR)
  1359f8:	ebff3a48 	bl	104320 <ipc_service_init>
  1359fc:	e1a03000 	mov	r3, r0
  135a00:	e3530001 	cmp	r3, #1
  135a04:	1a000001 	bne	135a10 <imx6ul_eth_init+0x34>
    {
        return -RT_ERROR;
  135a08:	e3e03000 	mvn	r3, #0
  135a0c:	ea0000b1 	b	135cd8 <imx6ul_eth_init+0x2fc>
    }


    ueth_gpioinit((void *)&mdio_gpio[0], sizeof(mdio_gpio[0]));
  135a10:	e3a0101c 	mov	r1, #28
  135a14:	e30e0040 	movw	r0, #57408	; 0xe040
  135a18:	e3400014 	movt	r0, #20
  135a1c:	ebff3ade 	bl	10459c <ueth_gpioinit>
    ueth_gpioinit((void *)&mdio_gpio[1], sizeof(mdio_gpio[1]));
  135a20:	e3a0101c 	mov	r1, #28
  135a24:	e59f02b8 	ldr	r0, [pc, #696]	; 135ce4 <imx6ul_eth_init+0x308>
  135a28:	ebff3adb 	bl	10459c <ueth_gpioinit>

    for (int idx=0; idx<GET_ARRAY_NUM(_imx6ul_eth_device); idx++)
  135a2c:	e3a03000 	mov	r3, #0
  135a30:	e50b300c 	str	r3, [fp, #-12]
  135a34:	ea000090 	b	135c7c <imx6ul_eth_init+0x2a0>
    {
        _imx6ul_eth_device[idx].parent.parent.ops = &_k_enet_ops;
  135a38:	e30e3078 	movw	r3, #57464	; 0xe078
  135a3c:	e3403014 	movt	r3, #20
  135a40:	e51b200c 	ldr	r2, [fp, #-12]
  135a44:	e3a01f8a 	mov	r1, #552	; 0x228
  135a48:	e0020291 	mul	r2, r1, r2
  135a4c:	e0833002 	add	r3, r3, r2
  135a50:	e283202c 	add	r2, r3, #44	; 0x2c
  135a54:	e30a3038 	movw	r3, #41016	; 0xa038
  135a58:	e3403014 	movt	r3, #20
  135a5c:	e5823000 	str	r3, [r2]
#ifdef RT_USING_LWIP        
        _imx6ul_eth_device[idx].parent.eth_rx     = rt_imx6ul_eth_rx;
  135a60:	e30e3078 	movw	r3, #57464	; 0xe078
  135a64:	e3403014 	movt	r3, #20
  135a68:	e51b200c 	ldr	r2, [fp, #-12]
  135a6c:	e3a01f8a 	mov	r1, #552	; 0x228
  135a70:	e0020291 	mul	r2, r1, r2
  135a74:	e0833002 	add	r3, r3, r2
  135a78:	e2832070 	add	r2, r3, #112	; 0x70
  135a7c:	e305331c 	movw	r3, #21276	; 0x531c
  135a80:	e3403013 	movt	r3, #19
  135a84:	e5823000 	str	r3, [r2]
        _imx6ul_eth_device[idx].parent.eth_tx     = rt_imx6ul_eth_tx;
  135a88:	e30e3078 	movw	r3, #57464	; 0xe078
  135a8c:	e3403014 	movt	r3, #20
  135a90:	e51b200c 	ldr	r2, [fp, #-12]
  135a94:	e3a01f8a 	mov	r1, #552	; 0x228
  135a98:	e0020291 	mul	r2, r1, r2
  135a9c:	e0833002 	add	r3, r3, r2
  135aa0:	e2832074 	add	r2, r3, #116	; 0x74
  135aa4:	e30531bc 	movw	r3, #20924	; 0x51bc
  135aa8:	e3403013 	movt	r3, #19
  135aac:	e5823000 	str	r3, [r2]
#endif        
        _imx6ul_eth_device[idx].phy_link_status   = RT_FALSE;
  135ab0:	e30e3078 	movw	r3, #57464	; 0xe078
  135ab4:	e3403014 	movt	r3, #20
  135ab8:	e51b200c 	ldr	r2, [fp, #-12]
  135abc:	e3a01f8a 	mov	r1, #552	; 0x228
  135ac0:	e0020291 	mul	r2, r1, r2
  135ac4:	e0833002 	add	r3, r3, r2
  135ac8:	e2833088 	add	r3, r3, #136	; 0x88
  135acc:	e3a02000 	mov	r2, #0
  135ad0:	e5832000 	str	r2, [r3]

#ifdef SAL_USING_UNET
        rt_imx6ul_eth_control((rt_device_t)(&_imx6ul_eth_device[idx]),NIOCTL_GADDR,mac_addr);
  135ad4:	e51b300c 	ldr	r3, [fp, #-12]
  135ad8:	e3a02f8a 	mov	r2, #552	; 0x228
  135adc:	e0020392 	mul	r2, r2, r3
  135ae0:	e30e3078 	movw	r3, #57464	; 0xe078
  135ae4:	e3403014 	movt	r3, #20
  135ae8:	e0823003 	add	r3, r2, r3
  135aec:	e24b2024 	sub	r2, fp, #36	; 0x24
  135af0:	e3a01001 	mov	r1, #1
  135af4:	e1a00003 	mov	r0, r3
  135af8:	ebfffce3 	bl	134e8c <rt_imx6ul_eth_control>
        
        rt_imx6ul_eth_init((rt_device_t)(&(_imx6ul_eth_device[idx].parent)));
  135afc:	e51b300c 	ldr	r3, [fp, #-12]
  135b00:	e3a02f8a 	mov	r2, #552	; 0x228
  135b04:	e0020392 	mul	r2, r2, r3
  135b08:	e30e3078 	movw	r3, #57464	; 0xe078
  135b0c:	e3403014 	movt	r3, #20
  135b10:	e0823003 	add	r3, r2, r3
  135b14:	e1a00003 	mov	r0, r3
  135b18:	ebfffc5c 	bl	134c90 <rt_imx6ul_eth_init>
#endif
        eth_init_done = 1;
  135b1c:	e30f3bf0 	movw	r3, #64496	; 0xfbf0
  135b20:	e3403014 	movt	r3, #20
  135b24:	e3a02001 	mov	r2, #1
  135b28:	e5832000 	str	r2, [r3]
        /* register eth device */
        state = eth_device_init(&(_imx6ul_eth_device[idx].parent), _imx6ul_eth_device[idx].mac_name);
  135b2c:	e51b300c 	ldr	r3, [fp, #-12]
  135b30:	e3a02f8a 	mov	r2, #552	; 0x228
  135b34:	e0020392 	mul	r2, r2, r3
  135b38:	e30e3078 	movw	r3, #57464	; 0xe078
  135b3c:	e3403014 	movt	r3, #20
  135b40:	e0820003 	add	r0, r2, r3
  135b44:	e30e3078 	movw	r3, #57464	; 0xe078
  135b48:	e3403014 	movt	r3, #20
  135b4c:	e51b200c 	ldr	r2, [fp, #-12]
  135b50:	e3a01f8a 	mov	r1, #552	; 0x228
  135b54:	e0020291 	mul	r2, r1, r2
  135b58:	e0833002 	add	r3, r3, r2
  135b5c:	e283308c 	add	r3, r3, #140	; 0x8c
  135b60:	e5933000 	ldr	r3, [r3]
  135b64:	e1a01003 	mov	r1, r3
  135b68:	ebffd047 	bl	129c8c <eth_device_init>
  135b6c:	e50b0008 	str	r0, [fp, #-8]
        if (RT_EOK == state)
  135b70:	e51b3008 	ldr	r3, [fp, #-8]
  135b74:	e3530000 	cmp	r3, #0
  135b78:	1a000009 	bne	135ba4 <imx6ul_eth_init+0x1c8>
        {
            LOG_I("emac device init success");
  135b7c:	e30a0050 	movw	r0, #41040	; 0xa050
  135b80:	e3400014 	movt	r0, #20
  135b84:	ebff3562 	bl	103114 <rt_kprintf>
  135b88:	e30a0064 	movw	r0, #41060	; 0xa064
  135b8c:	e3400014 	movt	r0, #20
  135b90:	ebff355f 	bl	103114 <rt_kprintf>
  135b94:	e3090de4 	movw	r0, #40420	; 0x9de4
  135b98:	e3400014 	movt	r0, #20
  135b9c:	ebff355c 	bl	103114 <rt_kprintf>
  135ba0:	ea00000b 	b	135bd4 <imx6ul_eth_init+0x1f8>
        }
        else
        {
            LOG_E("emac device init faild: %d", state);
  135ba4:	e3090e00 	movw	r0, #40448	; 0x9e00
  135ba8:	e3400014 	movt	r0, #20
  135bac:	ebff3558 	bl	103114 <rt_kprintf>
  135bb0:	e51b1008 	ldr	r1, [fp, #-8]
  135bb4:	e30a0080 	movw	r0, #41088	; 0xa080
  135bb8:	e3400014 	movt	r0, #20
  135bbc:	ebff3554 	bl	103114 <rt_kprintf>
  135bc0:	e3090de4 	movw	r0, #40420	; 0x9de4
  135bc4:	e3400014 	movt	r0, #20
  135bc8:	ebff3551 	bl	103114 <rt_kprintf>
            state = -RT_ERROR;
  135bcc:	e3e03000 	mvn	r3, #0
  135bd0:	e50b3008 	str	r3, [fp, #-8]
        }

        rt_sprintf(link_detect,"link_d%d",_imx6ul_eth_device[idx].mac_num);
  135bd4:	e30e3078 	movw	r3, #57464	; 0xe078
  135bd8:	e3403014 	movt	r3, #20
  135bdc:	e51b200c 	ldr	r2, [fp, #-12]
  135be0:	e3a01f8a 	mov	r1, #552	; 0x228
  135be4:	e0020291 	mul	r2, r1, r2
  135be8:	e0833002 	add	r3, r3, r2
  135bec:	e28330a4 	add	r3, r3, #164	; 0xa4
  135bf0:	e5932000 	ldr	r2, [r3]
  135bf4:	e24b301c 	sub	r3, fp, #28
  135bf8:	e30a109c 	movw	r1, #41116	; 0xa09c
  135bfc:	e3401014 	movt	r1, #20
  135c00:	e1a00003 	mov	r0, r3
  135c04:	ebff3520 	bl	10308c <rt_sprintf>
        /* start phy link detect */
        rt_thread_t phy_link_tid;
        phy_link_tid = rt_thread_create(link_detect,
                                phy_detect_thread_entry,
                                &_imx6ul_eth_device[idx],
  135c08:	e51b300c 	ldr	r3, [fp, #-12]
  135c0c:	e3a02f8a 	mov	r2, #552	; 0x228
  135c10:	e0020392 	mul	r2, r2, r3
  135c14:	e30e3078 	movw	r3, #57464	; 0xe078
  135c18:	e3403014 	movt	r3, #20
  135c1c:	e0822003 	add	r2, r2, r3
        phy_link_tid = rt_thread_create(link_detect,
  135c20:	e24b001c 	sub	r0, fp, #28
  135c24:	e3a03002 	mov	r3, #2
  135c28:	e58d3004 	str	r3, [sp, #4]
  135c2c:	e3a03019 	mov	r3, #25
  135c30:	e58d3000 	str	r3, [sp]
  135c34:	e3a03a01 	mov	r3, #4096	; 0x1000
  135c38:	e3051874 	movw	r1, #22644	; 0x5874
  135c3c:	e3401013 	movt	r1, #19
  135c40:	ebff312b 	bl	1020f4 <rt_thread_create>
  135c44:	e50b0010 	str	r0, [fp, #-16]
                                4096,
                                25,
                                2);
        if (phy_link_tid != RT_NULL)
  135c48:	e51b3010 	ldr	r3, [fp, #-16]
  135c4c:	e3530000 	cmp	r3, #0
  135c50:	0a000001 	beq	135c5c <imx6ul_eth_init+0x280>
        {
            rt_thread_startup(phy_link_tid);
  135c54:	e51b0010 	ldr	r0, [fp, #-16]
  135c58:	ebff315a 	bl	1021c8 <rt_thread_startup>
        }
        memset(link_detect,0,sizeof(link_detect));
  135c5c:	e24b301c 	sub	r3, fp, #28
  135c60:	e3a0200a 	mov	r2, #10
  135c64:	e3a01000 	mov	r1, #0
  135c68:	e1a00003 	mov	r0, r3
  135c6c:	eb002e00 	bl	141474 <memset>
    for (int idx=0; idx<GET_ARRAY_NUM(_imx6ul_eth_device); idx++)
  135c70:	e51b300c 	ldr	r3, [fp, #-12]
  135c74:	e2833001 	add	r3, r3, #1
  135c78:	e50b300c 	str	r3, [fp, #-12]
  135c7c:	e51b300c 	ldr	r3, [fp, #-12]
  135c80:	e3530000 	cmp	r3, #0
  135c84:	0affff6b 	beq	135a38 <imx6ul_eth_init+0x5c>
    }

    if (eth_select > GET_ARRAY_NUM(_imx6ul_eth_device)) 
  135c88:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  135c8c:	e3530001 	cmp	r3, #1
  135c90:	9a000005 	bls	135cac <imx6ul_eth_init+0x2d0>
    {
        *eth_name = RT_NULL;
  135c94:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  135c98:	e3a02000 	mov	r2, #0
  135c9c:	e5832000 	str	r2, [r3]
        state = -RT_ERROR;
  135ca0:	e3e03000 	mvn	r3, #0
  135ca4:	e50b3008 	str	r3, [fp, #-8]
  135ca8:	ea000009 	b	135cd4 <imx6ul_eth_init+0x2f8>
    } 
    else 
    {
        *eth_name = _imx6ul_eth_device[eth_select].mac_name;
  135cac:	e30e3078 	movw	r3, #57464	; 0xe078
  135cb0:	e3403014 	movt	r3, #20
  135cb4:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  135cb8:	e3a01f8a 	mov	r1, #552	; 0x228
  135cbc:	e0020291 	mul	r2, r1, r2
  135cc0:	e0833002 	add	r3, r3, r2
  135cc4:	e283308c 	add	r3, r3, #140	; 0x8c
  135cc8:	e5932000 	ldr	r2, [r3]
  135ccc:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  135cd0:	e5832000 	str	r2, [r3]
    }

    return state;
  135cd4:	e51b3008 	ldr	r3, [fp, #-8]
}
  135cd8:	e1a00003 	mov	r0, r3
  135cdc:	e24bd004 	sub	sp, fp, #4
  135ce0:	e8bd8800 	pop	{fp, pc}
  135ce4:	0014e05c 	.word	0x0014e05c

00135ce8 <__assert_func>:
        __BKPT(0);
    }
}
#elif(defined(__GNUC__))
void __assert_func(const char *file, int line, const char *func, const char *failedExpr)
{
  135ce8:	e92d4800 	push	{fp, lr}
  135cec:	e28db004 	add	fp, sp, #4
  135cf0:	e24dd018 	sub	sp, sp, #24
  135cf4:	e50b0008 	str	r0, [fp, #-8]
  135cf8:	e50b100c 	str	r1, [fp, #-12]
  135cfc:	e50b2010 	str	r2, [fp, #-16]
  135d00:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    PRINTF("ASSERT ERROR \" %s \": file \"%s\" Line \"%d\" function name \"%s\" \n", failedExpr, file, line, func);
  135d04:	e51b3010 	ldr	r3, [fp, #-16]
  135d08:	e58d3000 	str	r3, [sp]
  135d0c:	e51b300c 	ldr	r3, [fp, #-12]
  135d10:	e51b2008 	ldr	r2, [fp, #-8]
  135d14:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  135d18:	e30a00bc 	movw	r0, #41148	; 0xa0bc
  135d1c:	e3400014 	movt	r0, #20
  135d20:	ebff34fb 	bl	103114 <rt_kprintf>
    for (;;)
    {
        __BKPT(0);
  135d24:	e1200070 	bkpt	0x0000
  135d28:	eafffffd 	b	135d24 <__assert_func+0x3c>

00135d2c <SDK_Malloc>:
                           /*   SYSCON->STARTERCLR[index] = 1u << intNumber; */
}
#endif /*CPU_QN908X */

void *SDK_Malloc(size_t size, size_t alignbytes)
{
  135d2c:	e92d4800 	push	{fp, lr}
  135d30:	e28db004 	add	fp, sp, #4
  135d34:	e24dd018 	sub	sp, sp, #24
  135d38:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  135d3c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    mem_align_cb_t *p_cb = NULL;
  135d40:	e3a03000 	mov	r3, #0
  135d44:	e50b3008 	str	r3, [fp, #-8]
    uint32_t alignedsize = SDK_SIZEALIGN(size, alignbytes) + alignbytes + sizeof(mem_align_cb_t);
  135d48:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  135d4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  135d50:	e0823003 	add	r3, r2, r3
  135d54:	e2432001 	sub	r2, r3, #1
  135d58:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  135d5c:	e2633000 	rsb	r3, r3, #0
  135d60:	e0022003 	and	r2, r2, r3
  135d64:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  135d68:	e0823003 	add	r3, r2, r3
  135d6c:	e2833004 	add	r3, r3, #4
  135d70:	e50b300c 	str	r3, [fp, #-12]
    void *p_align_addr, *p_addr = malloc(alignedsize);
  135d74:	e51b000c 	ldr	r0, [fp, #-12]
  135d78:	eb001df4 	bl	13d550 <malloc>
  135d7c:	e1a03000 	mov	r3, r0
  135d80:	e50b3010 	str	r3, [fp, #-16]

    if (!p_addr)
  135d84:	e51b3010 	ldr	r3, [fp, #-16]
  135d88:	e3530000 	cmp	r3, #0
  135d8c:	1a000001 	bne	135d98 <SDK_Malloc+0x6c>
    {
        return NULL;
  135d90:	e3a03000 	mov	r3, #0
  135d94:	ea000014 	b	135dec <SDK_Malloc+0xc0>
    }

    p_align_addr = (void *)SDK_SIZEALIGN((uint32_t)p_addr + sizeof(mem_align_cb_t), alignbytes);
  135d98:	e51b2010 	ldr	r2, [fp, #-16]
  135d9c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  135da0:	e0823003 	add	r3, r2, r3
  135da4:	e2832003 	add	r2, r3, #3
  135da8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  135dac:	e2633000 	rsb	r3, r3, #0
  135db0:	e0033002 	and	r3, r3, r2
  135db4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

    p_cb = (mem_align_cb_t *)((uint32_t)p_align_addr - 4);
  135db8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  135dbc:	e2433004 	sub	r3, r3, #4
  135dc0:	e50b3008 	str	r3, [fp, #-8]
    p_cb->identifier = SDK_MEM_MAGIC_NUMBER;
  135dc4:	e51b3008 	ldr	r3, [fp, #-8]
  135dc8:	e3032039 	movw	r2, #12345	; 0x3039
  135dcc:	e1c320b0 	strh	r2, [r3]
    p_cb->offset = (uint32_t)p_align_addr - (uint32_t)p_addr;
  135dd0:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  135dd4:	e51b3010 	ldr	r3, [fp, #-16]
  135dd8:	e0423003 	sub	r3, r2, r3
  135ddc:	e6ff2073 	uxth	r2, r3
  135de0:	e51b3008 	ldr	r3, [fp, #-8]
  135de4:	e1c320b2 	strh	r2, [r3, #2]

    return (void *)p_align_addr;
  135de8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
  135dec:	e1a00003 	mov	r0, r3
  135df0:	e24bd004 	sub	sp, fp, #4
  135df4:	e8bd8800 	pop	{fp, pc}

00135df8 <SDK_Free>:

void SDK_Free(void *ptr)
{
  135df8:	e92d4800 	push	{fp, lr}
  135dfc:	e28db004 	add	fp, sp, #4
  135e00:	e24dd010 	sub	sp, sp, #16
  135e04:	e50b0010 	str	r0, [fp, #-16]
    mem_align_cb_t *p_cb = (mem_align_cb_t *)((uint32_t)ptr - 4);
  135e08:	e51b3010 	ldr	r3, [fp, #-16]
  135e0c:	e2433004 	sub	r3, r3, #4
  135e10:	e50b3008 	str	r3, [fp, #-8]

    if (p_cb->identifier != SDK_MEM_MAGIC_NUMBER)
  135e14:	e51b3008 	ldr	r3, [fp, #-8]
  135e18:	e1d330b0 	ldrh	r3, [r3]
  135e1c:	e3032039 	movw	r2, #12345	; 0x3039
  135e20:	e1530002 	cmp	r3, r2
  135e24:	1a000006 	bne	135e44 <SDK_Free+0x4c>
    {
        return;
    }

    free((void *)((uint32_t)ptr - p_cb->offset));
  135e28:	e51b3010 	ldr	r3, [fp, #-16]
  135e2c:	e51b2008 	ldr	r2, [fp, #-8]
  135e30:	e1d220b2 	ldrh	r2, [r2, #2]
  135e34:	e0433002 	sub	r3, r3, r2
  135e38:	e1a00003 	mov	r0, r3
  135e3c:	eb001f7f 	bl	13dc40 <free>
  135e40:	ea000000 	b	135e48 <SDK_Free+0x50>
        return;
  135e44:	e320f000 	nop	{0}
}
  135e48:	e24bd004 	sub	sp, fp, #4
  135e4c:	e8bd8800 	pop	{fp, pc}

00135e50 <ENET_Reset>:
{
  135e50:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  135e54:	e28db000 	add	fp, sp, #0
  135e58:	e24dd00c 	sub	sp, sp, #12
  135e5c:	e50b0008 	str	r0, [fp, #-8]
    base->ECR |= ENET_ECR_RESET_MASK;
  135e60:	e51b3008 	ldr	r3, [fp, #-8]
  135e64:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  135e68:	e3832001 	orr	r2, r3, #1
  135e6c:	e51b3008 	ldr	r3, [fp, #-8]
  135e70:	e5832024 	str	r2, [r3, #36]	; 0x24
}
  135e74:	e320f000 	nop	{0}
  135e78:	e28bd000 	add	sp, fp, #0
  135e7c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  135e80:	e12fff1e 	bx	lr

00135e84 <ENET_GetSMI>:
{
  135e84:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  135e88:	e28db000 	add	fp, sp, #0
  135e8c:	e24dd00c 	sub	sp, sp, #12
  135e90:	e50b0008 	str	r0, [fp, #-8]
    return (0 != (base->MSCR & 0x7E));
  135e94:	e51b3008 	ldr	r3, [fp, #-8]
  135e98:	e5933044 	ldr	r3, [r3, #68]	; 0x44
  135e9c:	e203307e 	and	r3, r3, #126	; 0x7e
  135ea0:	e3530000 	cmp	r3, #0
  135ea4:	13a03001 	movne	r3, #1
  135ea8:	03a03000 	moveq	r3, #0
  135eac:	e6ef3073 	uxtb	r3, r3
}
  135eb0:	e1a00003 	mov	r0, r3
  135eb4:	e28bd000 	add	sp, fp, #0
  135eb8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  135ebc:	e12fff1e 	bx	lr

00135ec0 <ENET_EnableSleepMode>:
{
  135ec0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  135ec4:	e28db000 	add	fp, sp, #0
  135ec8:	e24dd00c 	sub	sp, sp, #12
  135ecc:	e50b0008 	str	r0, [fp, #-8]
  135ed0:	e1a03001 	mov	r3, r1
  135ed4:	e54b3009 	strb	r3, [fp, #-9]
    if (enable)
  135ed8:	e55b3009 	ldrb	r3, [fp, #-9]
  135edc:	e3530000 	cmp	r3, #0
  135ee0:	0a000005 	beq	135efc <ENET_EnableSleepMode+0x3c>
        base->ECR |= ENET_ECR_SLEEP_MASK | ENET_ECR_MAGICEN_MASK;
  135ee4:	e51b3008 	ldr	r3, [fp, #-8]
  135ee8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  135eec:	e383200c 	orr	r2, r3, #12
  135ef0:	e51b3008 	ldr	r3, [fp, #-8]
  135ef4:	e5832024 	str	r2, [r3, #36]	; 0x24
}
  135ef8:	ea000004 	b	135f10 <ENET_EnableSleepMode+0x50>
        base->ECR &= ~(ENET_ECR_SLEEP_MASK | ENET_ECR_MAGICEN_MASK);
  135efc:	e51b3008 	ldr	r3, [fp, #-8]
  135f00:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  135f04:	e3c3200c 	bic	r2, r3, #12
  135f08:	e51b3008 	ldr	r3, [fp, #-8]
  135f0c:	e5832024 	str	r2, [r3, #36]	; 0x24
}
  135f10:	e320f000 	nop	{0}
  135f14:	e28bd000 	add	sp, fp, #0
  135f18:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  135f1c:	e12fff1e 	bx	lr

00135f20 <ENET_EnableInterrupts>:
{
  135f20:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  135f24:	e28db000 	add	fp, sp, #0
  135f28:	e24dd00c 	sub	sp, sp, #12
  135f2c:	e50b0008 	str	r0, [fp, #-8]
  135f30:	e50b100c 	str	r1, [fp, #-12]
    base->EIMR |= mask;
  135f34:	e51b3008 	ldr	r3, [fp, #-8]
  135f38:	e5932008 	ldr	r2, [r3, #8]
  135f3c:	e51b300c 	ldr	r3, [fp, #-12]
  135f40:	e1822003 	orr	r2, r2, r3
  135f44:	e51b3008 	ldr	r3, [fp, #-8]
  135f48:	e5832008 	str	r2, [r3, #8]
}
  135f4c:	e320f000 	nop	{0}
  135f50:	e28bd000 	add	sp, fp, #0
  135f54:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  135f58:	e12fff1e 	bx	lr

00135f5c <ENET_GetInstance>:

/*******************************************************************************
 * Code
 ******************************************************************************/
uint32_t ENET_GetInstance(ENET_Type *base)
{
  135f5c:	e92d4800 	push	{fp, lr}
  135f60:	e28db004 	add	fp, sp, #4
  135f64:	e24dd010 	sub	sp, sp, #16
  135f68:	e50b0010 	str	r0, [fp, #-16]
    uint32_t instance;
    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < ARRAY_SIZE(s_enetBases); instance++)
  135f6c:	e3a03000 	mov	r3, #0
  135f70:	e50b3008 	str	r3, [fp, #-8]
  135f74:	ea000009 	b	135fa0 <ENET_GetInstance+0x44>
    {
        if (s_enetBases[instance] == base)
  135f78:	e30a30fc 	movw	r3, #41212	; 0xa0fc
  135f7c:	e3403014 	movt	r3, #20
  135f80:	e51b2008 	ldr	r2, [fp, #-8]
  135f84:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  135f88:	e51b2010 	ldr	r2, [fp, #-16]
  135f8c:	e1520003 	cmp	r2, r3
  135f90:	0a000006 	beq	135fb0 <ENET_GetInstance+0x54>
    for (instance = 0; instance < ARRAY_SIZE(s_enetBases); instance++)
  135f94:	e51b3008 	ldr	r3, [fp, #-8]
  135f98:	e2833001 	add	r3, r3, #1
  135f9c:	e50b3008 	str	r3, [fp, #-8]
  135fa0:	e51b3008 	ldr	r3, [fp, #-8]
  135fa4:	e3530002 	cmp	r3, #2
  135fa8:	9afffff2 	bls	135f78 <ENET_GetInstance+0x1c>
  135fac:	ea000000 	b	135fb4 <ENET_GetInstance+0x58>
        {
            break;
  135fb0:	e320f000 	nop	{0}
        }
    }
    RT_ASSERT(instance < ARRAY_SIZE(s_enetBases));
  135fb4:	e51b3008 	ldr	r3, [fp, #-8]
  135fb8:	e3530002 	cmp	r3, #2
  135fbc:	9a000005 	bls	135fd8 <ENET_GetInstance+0x7c>
  135fc0:	e3a020d7 	mov	r2, #215	; 0xd7
  135fc4:	e30a1478 	movw	r1, #42104	; 0xa478
  135fc8:	e3401014 	movt	r1, #20
  135fcc:	e30a0108 	movw	r0, #41224	; 0xa108
  135fd0:	e3400014 	movt	r0, #20
  135fd4:	ebff356f 	bl	103598 <rt_assert_handler>

    return instance;
  135fd8:	e51b3008 	ldr	r3, [fp, #-8]
}
  135fdc:	e1a00003 	mov	r0, r3
  135fe0:	e24bd004 	sub	sp, fp, #4
  135fe4:	e8bd8800 	pop	{fp, pc}

00135fe8 <ENET_GetDefaultConfig>:
};

#endif

void ENET_GetDefaultConfig(enet_config_t *config)
{
  135fe8:	e92d4800 	push	{fp, lr}
  135fec:	e28db004 	add	fp, sp, #4
  135ff0:	e24dd008 	sub	sp, sp, #8
  135ff4:	e50b0008 	str	r0, [fp, #-8]
    /* Checks input parameter. */
    RT_ASSERT(config);
  135ff8:	e51b3008 	ldr	r3, [fp, #-8]
  135ffc:	e3530000 	cmp	r3, #0
  136000:	1a000005 	bne	13601c <ENET_GetDefaultConfig+0x34>
  136004:	e3a020e9 	mov	r2, #233	; 0xe9
  136008:	e30a148c 	movw	r1, #42124	; 0xa48c
  13600c:	e3401014 	movt	r1, #20
  136010:	e30a012c 	movw	r0, #41260	; 0xa12c
  136014:	e3400014 	movt	r0, #20
  136018:	ebff355e 	bl	103598 <rt_assert_handler>

    /* Initializes the MAC configure structure to zero. */
    memset(config, 0, sizeof(enet_config_t));
  13601c:	e3a02024 	mov	r2, #36	; 0x24
  136020:	e3a01000 	mov	r1, #0
  136024:	e51b0008 	ldr	r0, [fp, #-8]
  136028:	eb002d11 	bl	141474 <memset>

    #if defined (FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE) && FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE
    config->intCoalesceCfg = &intcoalesce_config;
  13602c:	e51b2008 	ldr	r2, [fp, #-8]
  136030:	e30e32a0 	movw	r3, #58016	; 0xe2a0
  136034:	e3403014 	movt	r3, #20
  136038:	e5823020 	str	r3, [r2, #32]
    #endif

    /* Sets MII mode, full duplex, 100Mbps for MAC and PHY data interface. */
    config->miiMode = kENET_RmiiMode;
  13603c:	e51b3008 	ldr	r3, [fp, #-8]
  136040:	e3a02001 	mov	r2, #1
  136044:	e583200c 	str	r2, [r3, #12]
    config->miiSpeed = kENET_MiiSpeed100M;
  136048:	e51b3008 	ldr	r3, [fp, #-8]
  13604c:	e3a02001 	mov	r2, #1
  136050:	e5832010 	str	r2, [r3, #16]
    config->miiDuplex = kENET_MiiFullDuplex;
  136054:	e51b3008 	ldr	r3, [fp, #-8]
  136058:	e3a02001 	mov	r2, #1
  13605c:	e5832014 	str	r2, [r3, #20]

    /* Sets the maximum receive frame length. */
    config->rxMaxFrameLen = ENET_FRAME_MAX_FRAMELEN;
  136060:	e51b3008 	ldr	r3, [fp, #-8]
  136064:	e30025ee 	movw	r2, #1518	; 0x5ee
  136068:	e1c320b8 	strh	r2, [r3, #8]
}
  13606c:	e320f000 	nop	{0}
  136070:	e24bd004 	sub	sp, fp, #4
  136074:	e8bd8800 	pop	{fp, pc}

00136078 <ENET_Init>:
               enet_handle_t *handle,
               const enet_config_t *config,
               const enet_buffer_config_t *bufferConfig,
               uint8_t *macAddr,
               uint32_t srcClock_Hz)
{
  136078:	e92d4800 	push	{fp, lr}
  13607c:	e28db004 	add	fp, sp, #4
  136080:	e24dd018 	sub	sp, sp, #24
  136084:	e50b0008 	str	r0, [fp, #-8]
  136088:	e50b100c 	str	r1, [fp, #-12]
  13608c:	e50b2010 	str	r2, [fp, #-16]
  136090:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    /* Checks input parameters. */
    RT_ASSERT(handle);
  136094:	e51b300c 	ldr	r3, [fp, #-12]
  136098:	e3530000 	cmp	r3, #0
  13609c:	1a000005 	bne	1360b8 <ENET_Init+0x40>
  1360a0:	e3002103 	movw	r2, #259	; 0x103
  1360a4:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  1360a8:	e3401014 	movt	r1, #20
  1360ac:	e30a0134 	movw	r0, #41268	; 0xa134
  1360b0:	e3400014 	movt	r0, #20
  1360b4:	ebff3537 	bl	103598 <rt_assert_handler>
    RT_ASSERT(config);
  1360b8:	e51b3010 	ldr	r3, [fp, #-16]
  1360bc:	e3530000 	cmp	r3, #0
  1360c0:	1a000005 	bne	1360dc <ENET_Init+0x64>
  1360c4:	e3a02f41 	mov	r2, #260	; 0x104
  1360c8:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  1360cc:	e3401014 	movt	r1, #20
  1360d0:	e30a012c 	movw	r0, #41260	; 0xa12c
  1360d4:	e3400014 	movt	r0, #20
  1360d8:	ebff352e 	bl	103598 <rt_assert_handler>
    RT_ASSERT(bufferConfig);
  1360dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1360e0:	e3530000 	cmp	r3, #0
  1360e4:	1a000005 	bne	136100 <ENET_Init+0x88>
  1360e8:	e3002105 	movw	r2, #261	; 0x105
  1360ec:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  1360f0:	e3401014 	movt	r1, #20
  1360f4:	e30a013c 	movw	r0, #41276	; 0xa13c
  1360f8:	e3400014 	movt	r0, #20
  1360fc:	ebff3525 	bl	103598 <rt_assert_handler>
    RT_ASSERT(bufferConfig->rxBdStartAddrAlign);
  136100:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136104:	e593300c 	ldr	r3, [r3, #12]
  136108:	e3530000 	cmp	r3, #0
  13610c:	1a000005 	bne	136128 <ENET_Init+0xb0>
  136110:	e3002106 	movw	r2, #262	; 0x106
  136114:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  136118:	e3401014 	movt	r1, #20
  13611c:	e30a014c 	movw	r0, #41292	; 0xa14c
  136120:	e3400014 	movt	r0, #20
  136124:	ebff351b 	bl	103598 <rt_assert_handler>
    RT_ASSERT(bufferConfig->txBdStartAddrAlign);
  136128:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13612c:	e5933010 	ldr	r3, [r3, #16]
  136130:	e3530000 	cmp	r3, #0
  136134:	1a000005 	bne	136150 <ENET_Init+0xd8>
  136138:	e3002107 	movw	r2, #263	; 0x107
  13613c:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  136140:	e3401014 	movt	r1, #20
  136144:	e30a0170 	movw	r0, #41328	; 0xa170
  136148:	e3400014 	movt	r0, #20
  13614c:	ebff3511 	bl	103598 <rt_assert_handler>
    RT_ASSERT(bufferConfig->rxBufferAlign);
  136150:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136154:	e5933014 	ldr	r3, [r3, #20]
  136158:	e3530000 	cmp	r3, #0
  13615c:	1a000005 	bne	136178 <ENET_Init+0x100>
  136160:	e3a02f42 	mov	r2, #264	; 0x108
  136164:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  136168:	e3401014 	movt	r1, #20
  13616c:	e30a0194 	movw	r0, #41364	; 0xa194
  136170:	e3400014 	movt	r0, #20
  136174:	ebff3507 	bl	103598 <rt_assert_handler>
    RT_ASSERT(bufferConfig->txBufferAlign);
  136178:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13617c:	e5933018 	ldr	r3, [r3, #24]
  136180:	e3530000 	cmp	r3, #0
  136184:	1a000005 	bne	1361a0 <ENET_Init+0x128>
  136188:	e3002109 	movw	r2, #265	; 0x109
  13618c:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  136190:	e3401014 	movt	r1, #20
  136194:	e30a01b0 	movw	r0, #41392	; 0xa1b0
  136198:	e3400014 	movt	r0, #20
  13619c:	ebff34fd 	bl	103598 <rt_assert_handler>
    RT_ASSERT(macAddr);
  1361a0:	e59b3004 	ldr	r3, [fp, #4]
  1361a4:	e3530000 	cmp	r3, #0
  1361a8:	1a000005 	bne	1361c4 <ENET_Init+0x14c>
  1361ac:	e300210a 	movw	r2, #266	; 0x10a
  1361b0:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  1361b4:	e3401014 	movt	r1, #20
  1361b8:	e30a01cc 	movw	r0, #41420	; 0xa1cc
  1361bc:	e3400014 	movt	r0, #20
  1361c0:	ebff34f4 	bl	103598 <rt_assert_handler>
    RT_ASSERT(bufferConfig->rxBuffSizeAlign >= ENET_RX_MIN_BUFFERSIZE);
  1361c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1361c8:	e5933004 	ldr	r3, [r3, #4]
  1361cc:	e35300ff 	cmp	r3, #255	; 0xff
  1361d0:	8a000005 	bhi	1361ec <ENET_Init+0x174>
  1361d4:	e300210b 	movw	r2, #267	; 0x10b
  1361d8:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  1361dc:	e3401014 	movt	r1, #20
  1361e0:	e30a01d4 	movw	r0, #41428	; 0xa1d4
  1361e4:	e3400014 	movt	r0, #20
  1361e8:	ebff34ea 	bl	103598 <rt_assert_handler>
    /* Make sure the buffers should be have the capability of process at least one maximum frame. */
    if (config->macSpecialConfig & kENET_ControlVLANTagEnable)
  1361ec:	e51b3010 	ldr	r3, [fp, #-16]
  1361f0:	e5933000 	ldr	r3, [r3]
  1361f4:	e2033c02 	and	r3, r3, #512	; 0x200
  1361f8:	e3530000 	cmp	r3, #0
  1361fc:	0a00000e 	beq	13623c <ENET_Init+0x1c4>
    {
        RT_ASSERT(bufferConfig->txBuffSizeAlign * bufferConfig->txBdNumber > (ENET_FRAME_MAX_FRAMELEN + ENET_FRAME_VLAN_TAGLEN));
  136200:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136204:	e5933008 	ldr	r3, [r3, #8]
  136208:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  13620c:	e1d220b2 	ldrh	r2, [r2, #2]
  136210:	e0030392 	mul	r3, r2, r3
  136214:	e30025f2 	movw	r2, #1522	; 0x5f2
  136218:	e1530002 	cmp	r3, r2
  13621c:	8a000023 	bhi	1362b0 <ENET_Init+0x238>
  136220:	e300210f 	movw	r2, #271	; 0x10f
  136224:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  136228:	e3401014 	movt	r1, #20
  13622c:	e30a020c 	movw	r0, #41484	; 0xa20c
  136230:	e3400014 	movt	r0, #20
  136234:	ebff34d7 	bl	103598 <rt_assert_handler>
  136238:	ea00001c 	b	1362b0 <ENET_Init+0x238>
    }
    else
    {
        RT_ASSERT(bufferConfig->txBuffSizeAlign * bufferConfig->txBdNumber > ENET_FRAME_MAX_FRAMELEN);
  13623c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136240:	e5933008 	ldr	r3, [r3, #8]
  136244:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  136248:	e1d220b2 	ldrh	r2, [r2, #2]
  13624c:	e0030392 	mul	r3, r2, r3
  136250:	e30025ee 	movw	r2, #1518	; 0x5ee
  136254:	e1530002 	cmp	r3, r2
  136258:	8a000005 	bhi	136274 <ENET_Init+0x1fc>
  13625c:	e3002113 	movw	r2, #275	; 0x113
  136260:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  136264:	e3401014 	movt	r1, #20
  136268:	e30a027c 	movw	r0, #41596	; 0xa27c
  13626c:	e3400014 	movt	r0, #20
  136270:	ebff34c8 	bl	103598 <rt_assert_handler>
        RT_ASSERT(bufferConfig->rxBuffSizeAlign * bufferConfig->rxBdNumber > config->rxMaxFrameLen);
  136274:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136278:	e5933004 	ldr	r3, [r3, #4]
  13627c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  136280:	e1d220b0 	ldrh	r2, [r2]
  136284:	e0030392 	mul	r3, r2, r3
  136288:	e51b2010 	ldr	r2, [fp, #-16]
  13628c:	e1d220b8 	ldrh	r2, [r2, #8]
  136290:	e1530002 	cmp	r3, r2
  136294:	8a000005 	bhi	1362b0 <ENET_Init+0x238>
  136298:	e3a02f45 	mov	r2, #276	; 0x114
  13629c:	e30a14a4 	movw	r1, #42148	; 0xa4a4
  1362a0:	e3401014 	movt	r1, #20
  1362a4:	e30a02d0 	movw	r0, #41680	; 0xa2d0
  1362a8:	e3400014 	movt	r0, #20
  1362ac:	ebff34b9 	bl	103598 <rt_assert_handler>
    }

    /* Reset ENET module. */
    ENET_Reset(base);
  1362b0:	e51b0008 	ldr	r0, [fp, #-8]
  1362b4:	ebfffee5 	bl	135e50 <ENET_Reset>
    /* Initializes the ENET transmit buffer descriptors. */
    ENET_SetTxBufferDescriptors(bufferConfig->txBdStartAddrAlign, bufferConfig->txPhyBufferAlign, bufferConfig->txBufferAlign, 
  1362b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1362bc:	e5930010 	ldr	r0, [r3, #16]
  1362c0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1362c4:	e5931028 	ldr	r1, [r3, #40]	; 0x28
  1362c8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1362cc:	e5932018 	ldr	r2, [r3, #24]
  1362d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1362d4:	e593c008 	ldr	ip, [r3, #8]
                                bufferConfig->txBuffSizeAlign, bufferConfig->txBdNumber);
  1362d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1362dc:	e1d330b2 	ldrh	r3, [r3, #2]
    ENET_SetTxBufferDescriptors(bufferConfig->txBdStartAddrAlign, bufferConfig->txPhyBufferAlign, bufferConfig->txBufferAlign, 
  1362e0:	e58d3000 	str	r3, [sp]
  1362e4:	e1a0300c 	mov	r3, ip
  1362e8:	eb00018b 	bl	13691c <ENET_SetTxBufferDescriptors>
    /* Initializes the ENET receive buffer descriptors. */
    ENET_SetRxBufferDescriptors(bufferConfig->rxBdStartAddrAlign, bufferConfig->rxPhyBufferAlign, bufferConfig->rxBufferAlign, 
  1362ec:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1362f0:	e593000c 	ldr	r0, [r3, #12]
  1362f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1362f8:	e5931024 	ldr	r1, [r3, #36]	; 0x24
  1362fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136300:	e5932014 	ldr	r2, [r3, #20]
  136304:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136308:	e593c004 	ldr	ip, [r3, #4]
                                bufferConfig->rxBuffSizeAlign, bufferConfig->rxBdNumber,
  13630c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136310:	e1d330b0 	ldrh	r3, [r3]
    ENET_SetRxBufferDescriptors(bufferConfig->rxBdStartAddrAlign, bufferConfig->rxPhyBufferAlign, bufferConfig->rxBufferAlign, 
  136314:	e1a0e003 	mov	lr, r3
                                !!(config->interrupt & (kENET_RxFrameInterrupt | kENET_RxBufferInterrupt)));
  136318:	e51b3010 	ldr	r3, [fp, #-16]
  13631c:	e5933004 	ldr	r3, [r3, #4]
  136320:	e2033403 	and	r3, r3, #50331648	; 0x3000000
    ENET_SetRxBufferDescriptors(bufferConfig->rxBdStartAddrAlign, bufferConfig->rxPhyBufferAlign, bufferConfig->rxBufferAlign, 
  136324:	e3530000 	cmp	r3, #0
  136328:	13a03001 	movne	r3, #1
  13632c:	03a03000 	moveq	r3, #0
  136330:	e6ef3073 	uxtb	r3, r3
  136334:	e58d3004 	str	r3, [sp, #4]
  136338:	e58de000 	str	lr, [sp]
  13633c:	e1a0300c 	mov	r3, ip
  136340:	eb0001c7 	bl	136a64 <ENET_SetRxBufferDescriptors>
    /* Initializes the ENET MAC controller. */
    ENET_SetMacController(base, config, bufferConfig, macAddr, srcClock_Hz);
  136344:	e59b3008 	ldr	r3, [fp, #8]
  136348:	e58d3000 	str	r3, [sp]
  13634c:	e59b3004 	ldr	r3, [fp, #4]
  136350:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  136354:	e51b1010 	ldr	r1, [fp, #-16]
  136358:	e51b0008 	ldr	r0, [fp, #-8]
  13635c:	eb00005e 	bl	1364dc <ENET_SetMacController>
    /* Set all buffers or data in handler for data transmit/receive process. */
    ENET_SetHandler(base, handle, config, bufferConfig);
  136360:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136364:	e51b2010 	ldr	r2, [fp, #-16]
  136368:	e51b100c 	ldr	r1, [fp, #-12]
  13636c:	e51b0008 	ldr	r0, [fp, #-8]
  136370:	eb00002a 	bl	136420 <ENET_SetHandler>
}
  136374:	e320f000 	nop	{0}
  136378:	e24bd004 	sub	sp, fp, #4
  13637c:	e8bd8800 	pop	{fp, pc}

00136380 <ENET_Deinit>:

void ENET_Deinit(ENET_Type *base)
{
  136380:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  136384:	e28db000 	add	fp, sp, #0
  136388:	e24dd00c 	sub	sp, sp, #12
  13638c:	e50b0008 	str	r0, [fp, #-8]
    /* Disable interrupt. */
    base->EIMR = 0;
  136390:	e51b3008 	ldr	r3, [fp, #-8]
  136394:	e3a02000 	mov	r2, #0
  136398:	e5832008 	str	r2, [r3, #8]

    /* Disable ENET. */
    base->ECR &= ~ENET_ECR_ETHEREN_MASK;
  13639c:	e51b3008 	ldr	r3, [fp, #-8]
  1363a0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  1363a4:	e3c32002 	bic	r2, r3, #2
  1363a8:	e51b3008 	ldr	r3, [fp, #-8]
  1363ac:	e5832024 	str	r2, [r3, #36]	; 0x24

}
  1363b0:	e320f000 	nop	{0}
  1363b4:	e28bd000 	add	sp, fp, #0
  1363b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1363bc:	e12fff1e 	bx	lr

001363c0 <ENET_SetCallback>:

void ENET_SetCallback(enet_handle_t *handle, enet_callback_t callback, void *userData)
{
  1363c0:	e92d4800 	push	{fp, lr}
  1363c4:	e28db004 	add	fp, sp, #4
  1363c8:	e24dd010 	sub	sp, sp, #16
  1363cc:	e50b0008 	str	r0, [fp, #-8]
  1363d0:	e50b100c 	str	r1, [fp, #-12]
  1363d4:	e50b2010 	str	r2, [fp, #-16]
    RT_ASSERT(handle);
  1363d8:	e51b3008 	ldr	r3, [fp, #-8]
  1363dc:	e3530000 	cmp	r3, #0
  1363e0:	1a000005 	bne	1363fc <ENET_SetCallback+0x3c>
  1363e4:	e3002132 	movw	r2, #306	; 0x132
  1363e8:	e30a14b0 	movw	r1, #42160	; 0xa4b0
  1363ec:	e3401014 	movt	r1, #20
  1363f0:	e30a0134 	movw	r0, #41268	; 0xa134
  1363f4:	e3400014 	movt	r0, #20
  1363f8:	ebff3466 	bl	103598 <rt_assert_handler>

    /* Set callback and userData. */
    handle->callback = callback;
  1363fc:	e51b3008 	ldr	r3, [fp, #-8]
  136400:	e51b200c 	ldr	r2, [fp, #-12]
  136404:	e5832018 	str	r2, [r3, #24]
    handle->userData = userData;
  136408:	e51b3008 	ldr	r3, [fp, #-8]
  13640c:	e51b2010 	ldr	r2, [fp, #-16]
  136410:	e583201c 	str	r2, [r3, #28]
}
  136414:	e320f000 	nop	{0}
  136418:	e24bd004 	sub	sp, fp, #4
  13641c:	e8bd8800 	pop	{fp, pc}

00136420 <ENET_SetHandler>:

static void ENET_SetHandler(ENET_Type *base,
                            enet_handle_t *handle,
                            const enet_config_t *config,
                            const enet_buffer_config_t *bufferConfig)
{
  136420:	e92d4800 	push	{fp, lr}
  136424:	e28db004 	add	fp, sp, #4
  136428:	e24dd018 	sub	sp, sp, #24
  13642c:	e50b0010 	str	r0, [fp, #-16]
  136430:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  136434:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  136438:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    // struct rt_imx6ul_ethps *imx6ul_device = rt_container_of(config,struct rt_imx6ul_ethps,config);
    uint32_t instance = get_instance_by_base(base);
  13643c:	e51b0010 	ldr	r0, [fp, #-16]
  136440:	ebfffc85 	bl	13565c <get_instance_by_base>
  136444:	e1a03000 	mov	r3, r0
  136448:	e50b3008 	str	r3, [fp, #-8]
    memset(handle, 0, sizeof(enet_handle_t));
  13644c:	e3a02020 	mov	r2, #32
  136450:	e3a01000 	mov	r1, #0
  136454:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
  136458:	eb002c05 	bl	141474 <memset>
    handle->rxBdBase = bufferConfig->rxBdStartAddrAlign;
  13645c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  136460:	e593200c 	ldr	r2, [r3, #12]
  136464:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136468:	e5832000 	str	r2, [r3]
    handle->rxBdCurrent = bufferConfig->rxBdStartAddrAlign;
  13646c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  136470:	e593200c 	ldr	r2, [r3, #12]
  136474:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136478:	e5832004 	str	r2, [r3, #4]
    handle->txBdBase = bufferConfig->txBdStartAddrAlign;
  13647c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  136480:	e5932010 	ldr	r2, [r3, #16]
  136484:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136488:	e5832008 	str	r2, [r3, #8]
    handle->txBdCurrent = bufferConfig->txBdStartAddrAlign;
  13648c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  136490:	e5932010 	ldr	r2, [r3, #16]
  136494:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136498:	e583200c 	str	r2, [r3, #12]
    handle->rxBuffSizeAlign = bufferConfig->rxBuffSizeAlign;
  13649c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1364a0:	e5932004 	ldr	r2, [r3, #4]
  1364a4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1364a8:	e5832010 	str	r2, [r3, #16]
    handle->txBuffSizeAlign = bufferConfig->txBuffSizeAlign;
  1364ac:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1364b0:	e5932008 	ldr	r2, [r3, #8]
  1364b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1364b8:	e5832014 	str	r2, [r3, #20]

    /* Save the handle pointer in the global variables. */
    s_ENETHandle[instance] = handle;
  1364bc:	e30f3bf8 	movw	r3, #64504	; 0xfbf8
  1364c0:	e3403014 	movt	r3, #20
  1364c4:	e51b2008 	ldr	r2, [fp, #-8]
  1364c8:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1364cc:	e7831102 	str	r1, [r3, r2, lsl #2]
    // if (config->interrupt & ENET_ERR_INTERRUPT)
    // {
    //     s_enetErrIsr = ENET_ErrorIRQHandler;
    //     EnableIRQ(imx6ul_device->irq_num);
    // }
}
  1364d0:	e320f000 	nop	{0}
  1364d4:	e24bd004 	sub	sp, fp, #4
  1364d8:	e8bd8800 	pop	{fp, pc}

001364dc <ENET_SetMacController>:
static void ENET_SetMacController(ENET_Type *base,
                                  const enet_config_t *config,
                                  const enet_buffer_config_t *bufferConfig,
                                  uint8_t *macAddr,
                                  uint32_t srcClock_Hz)
{
  1364dc:	e92d4800 	push	{fp, lr}
  1364e0:	e28db004 	add	fp, sp, #4
  1364e4:	e24dd030 	sub	sp, sp, #48	; 0x30
  1364e8:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
  1364ec:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
  1364f0:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  1364f4:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
    uint32_t rcr = 0;
  1364f8:	e3a03000 	mov	r3, #0
  1364fc:	e50b3008 	str	r3, [fp, #-8]
    uint32_t tcr = 0;
  136500:	e3a03000 	mov	r3, #0
  136504:	e50b3010 	str	r3, [fp, #-16]
    uint32_t ecr = 0;
  136508:	e3a03000 	mov	r3, #0
  13650c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    uint32_t macSpecialConfig = config->macSpecialConfig;
  136510:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136514:	e5933000 	ldr	r3, [r3]
  136518:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    uint32_t maxFrameLen = config->rxMaxFrameLen;
  13651c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136520:	e1d330b8 	ldrh	r3, [r3, #8]
  136524:	e50b300c 	str	r3, [fp, #-12]

    /* Maximum frame length check. */
    if ((macSpecialConfig & kENET_ControlVLANTagEnable) && (maxFrameLen <= ENET_FRAME_MAX_FRAMELEN))
  136528:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  13652c:	e2033c02 	and	r3, r3, #512	; 0x200
  136530:	e3530000 	cmp	r3, #0
  136534:	0a000005 	beq	136550 <ENET_SetMacController+0x74>
  136538:	e51b300c 	ldr	r3, [fp, #-12]
  13653c:	e30025ee 	movw	r2, #1518	; 0x5ee
  136540:	e1530002 	cmp	r3, r2
  136544:	8a000001 	bhi	136550 <ENET_SetMacController+0x74>
    {
        maxFrameLen = (ENET_FRAME_MAX_FRAMELEN + ENET_FRAME_VLAN_TAGLEN);
  136548:	e30035f2 	movw	r3, #1522	; 0x5f2
  13654c:	e50b300c 	str	r3, [fp, #-12]
    }

    /* Configures MAC receive controller with user configure structure. */
    rcr = ENET_RCR_NLC(!!(macSpecialConfig & kENET_ControlRxPayloadCheckEnable)) |
  136550:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  136554:	e1a03e83 	lsl	r3, r3, #29
  136558:	e2032101 	and	r2, r3, #1073741824	; 0x40000000
          ENET_RCR_CFEN(!!(macSpecialConfig & kENET_ControlFlowControlEnable)) |
  13655c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  136560:	e1a03783 	lsl	r3, r3, #15
  136564:	e6ff3073 	uxth	r3, r3
    rcr = ENET_RCR_NLC(!!(macSpecialConfig & kENET_ControlRxPayloadCheckEnable)) |
  136568:	e1822003 	orr	r2, r2, r3
          ENET_RCR_FCE(!!(macSpecialConfig & kENET_ControlFlowControlEnable)) |
  13656c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  136570:	e1a03283 	lsl	r3, r3, #5
  136574:	e2033020 	and	r3, r3, #32
          ENET_RCR_CFEN(!!(macSpecialConfig & kENET_ControlFlowControlEnable)) |
  136578:	e1822003 	orr	r2, r2, r3
          ENET_RCR_PADEN(!!(macSpecialConfig & kENET_ControlRxPadRemoveEnable)) |
  13657c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  136580:	e1a03503 	lsl	r3, r3, #10
  136584:	e2033a01 	and	r3, r3, #4096	; 0x1000
          ENET_RCR_FCE(!!(macSpecialConfig & kENET_ControlFlowControlEnable)) |
  136588:	e1822003 	orr	r2, r2, r3
          ENET_RCR_BC_REJ(!!(macSpecialConfig & kENET_ControlRxBroadCastRejectEnable)) |
  13658c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  136590:	e1a03083 	lsl	r3, r3, #1
  136594:	e2033010 	and	r3, r3, #16
          ENET_RCR_PADEN(!!(macSpecialConfig & kENET_ControlRxPadRemoveEnable)) |
  136598:	e1822003 	orr	r2, r2, r3
          ENET_RCR_PROM(!!(macSpecialConfig & kENET_ControlPromiscuousEnable)) | ENET_RCR_MII_MODE(1) |
  13659c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1365a0:	e1a03223 	lsr	r3, r3, #4
  1365a4:	e2033008 	and	r3, r3, #8
          ENET_RCR_BC_REJ(!!(macSpecialConfig & kENET_ControlRxBroadCastRejectEnable)) |
  1365a8:	e1822003 	orr	r2, r2, r3
          ENET_RCR_RMII_MODE(config->miiMode) | ENET_RCR_RMII_10T(!config->miiSpeed) |
  1365ac:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1365b0:	e593300c 	ldr	r3, [r3, #12]
  1365b4:	e1a03403 	lsl	r3, r3, #8
  1365b8:	e2033c01 	and	r3, r3, #256	; 0x100
          ENET_RCR_PROM(!!(macSpecialConfig & kENET_ControlPromiscuousEnable)) | ENET_RCR_MII_MODE(1) |
  1365bc:	e1823003 	orr	r3, r2, r3
          ENET_RCR_RMII_MODE(config->miiMode) | ENET_RCR_RMII_10T(!config->miiSpeed) |
  1365c0:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  1365c4:	e5922010 	ldr	r2, [r2, #16]
  1365c8:	e3520000 	cmp	r2, #0
  1365cc:	1a000001 	bne	1365d8 <ENET_SetMacController+0xfc>
  1365d0:	e3a02c02 	mov	r2, #512	; 0x200
  1365d4:	ea000000 	b	1365dc <ENET_SetMacController+0x100>
  1365d8:	e3a02000 	mov	r2, #0
  1365dc:	e1822003 	orr	r2, r2, r3
          ENET_RCR_MAX_FL(maxFrameLen) | ENET_RCR_CRCFWD(1);
  1365e0:	e51b300c 	ldr	r3, [fp, #-12]
  1365e4:	e1a01803 	lsl	r1, r3, #16
  1365e8:	e3a03000 	mov	r3, #0
  1365ec:	e3433fff 	movt	r3, #16383	; 0x3fff
  1365f0:	e0033001 	and	r3, r3, r1
          ENET_RCR_RMII_MODE(config->miiMode) | ENET_RCR_RMII_10T(!config->miiSpeed) |
  1365f4:	e1823003 	orr	r3, r2, r3
    rcr = ENET_RCR_NLC(!!(macSpecialConfig & kENET_ControlRxPayloadCheckEnable)) |
  1365f8:	e3833901 	orr	r3, r3, #16384	; 0x4000
  1365fc:	e3833004 	orr	r3, r3, #4
  136600:	e50b3008 	str	r3, [fp, #-8]
    /* Receive setting for half duplex. */
    if (config->miiDuplex == kENET_MiiHalfDuplex)
  136604:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136608:	e5933014 	ldr	r3, [r3, #20]
  13660c:	e3530000 	cmp	r3, #0
  136610:	1a000002 	bne	136620 <ENET_SetMacController+0x144>
    {
        rcr |= ENET_RCR_DRT_MASK;
  136614:	e51b3008 	ldr	r3, [fp, #-8]
  136618:	e3833002 	orr	r3, r3, #2
  13661c:	e50b3008 	str	r3, [fp, #-8]
    }
    /* Sets internal loop only for MII mode. */
    if ((config->macSpecialConfig & kENET_ControlMIILoopEnable) && (config->miiMode == kENET_MiiMode))
  136620:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136624:	e5933000 	ldr	r3, [r3]
  136628:	e2033c01 	and	r3, r3, #256	; 0x100
  13662c:	e3530000 	cmp	r3, #0
  136630:	0a000009 	beq	13665c <ENET_SetMacController+0x180>
  136634:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136638:	e593300c 	ldr	r3, [r3, #12]
  13663c:	e3530000 	cmp	r3, #0
  136640:	1a000005 	bne	13665c <ENET_SetMacController+0x180>
    {
        rcr |= ENET_RCR_LOOP_MASK;
  136644:	e51b3008 	ldr	r3, [fp, #-8]
  136648:	e3833001 	orr	r3, r3, #1
  13664c:	e50b3008 	str	r3, [fp, #-8]
        rcr &= ~ENET_RCR_DRT_MASK;
  136650:	e51b3008 	ldr	r3, [fp, #-8]
  136654:	e3c33002 	bic	r3, r3, #2
  136658:	e50b3008 	str	r3, [fp, #-8]
    }
    base->RCR = rcr;
  13665c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  136660:	e51b2008 	ldr	r2, [fp, #-8]
  136664:	e5832084 	str	r2, [r3, #132]	; 0x84

    /* Configures MAC transmit controller: duplex mode, mac address insertion. */
    tcr = base->TCR & ~(ENET_TCR_FDEN_MASK | ENET_TCR_ADDINS_MASK);
  136668:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13666c:	e59330c4 	ldr	r3, [r3, #196]	; 0xc4
  136670:	e3c33f41 	bic	r3, r3, #260	; 0x104
  136674:	e50b3010 	str	r3, [fp, #-16]
    tcr |= ENET_TCR_FDEN(config->miiDuplex) | ENET_TCR_ADDINS(!!(macSpecialConfig & kENET_ControlMacAddrInsert));
  136678:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  13667c:	e5933014 	ldr	r3, [r3, #20]
  136680:	e1a03103 	lsl	r3, r3, #2
  136684:	e2032004 	and	r2, r3, #4
  136688:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  13668c:	e1a03203 	lsl	r3, r3, #4
  136690:	e2033c01 	and	r3, r3, #256	; 0x100
  136694:	e1823003 	orr	r3, r2, r3
  136698:	e51b2010 	ldr	r2, [fp, #-16]
  13669c:	e1823003 	orr	r3, r2, r3
  1366a0:	e50b3010 	str	r3, [fp, #-16]
    base->TCR = tcr;
  1366a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1366a8:	e51b2010 	ldr	r2, [fp, #-16]
  1366ac:	e58320c4 	str	r2, [r3, #196]	; 0xc4

    /* Configures receive and transmit accelerator. */
    base->TACC = config->txAccelerConfig;
  1366b0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1366b4:	e5d33019 	ldrb	r3, [r3, #25]
  1366b8:	e1a02003 	mov	r2, r3
  1366bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1366c0:	e58321c0 	str	r2, [r3, #448]	; 0x1c0
    base->RACC = config->rxAccelerConfig;
  1366c4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1366c8:	e5d33018 	ldrb	r3, [r3, #24]
  1366cc:	e1a02003 	mov	r2, r3
  1366d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1366d4:	e58321c4 	str	r2, [r3, #452]	; 0x1c4

    /* Sets the pause duration and FIFO threshold for the flow control enabled case. */
    if (macSpecialConfig & kENET_ControlFlowControlEnable)
  1366d8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1366dc:	e2033001 	and	r3, r3, #1
  1366e0:	e3530000 	cmp	r3, #0
  1366e4:	0a00000a 	beq	136714 <ENET_SetMacController+0x238>
    {
        uint32_t reemReg;
        base->OPD = config->pauseDuration;
  1366e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1366ec:	e1d331ba 	ldrh	r3, [r3, #26]
  1366f0:	e1a02003 	mov	r2, r3
  1366f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1366f8:	e58320ec 	str	r2, [r3, #236]	; 0xec
        reemReg = ENET_RSEM_RX_SECTION_EMPTY(config->rxFifoEmptyThreshold);
  1366fc:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136700:	e5d3301c 	ldrb	r3, [r3, #28]
  136704:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
#if defined (FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD) && FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD
        reemReg |= ENET_RSEM_STAT_SECTION_EMPTY(config->rxFifoStatEmptyThreshold);
#endif /* FSL_FEATURE_ENET_HAS_RECEIVE_STATUS_THRESHOLD */
        base->RSEM = reemReg;
  136708:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13670c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  136710:	e5832194 	str	r2, [r3, #404]	; 0x194
    }

    /* FIFO threshold setting for store and forward enable/disable case. */
    if (macSpecialConfig & kENET_ControlStoreAndFwdDisable)
  136714:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  136718:	e2033020 	and	r3, r3, #32
  13671c:	e3530000 	cmp	r3, #0
  136720:	0a00000a 	beq	136750 <ENET_SetMacController+0x274>
    {
        /* Transmit fifo watermark settings. */
        base->TFWR = config->txFifoWatermark & ENET_TFWR_TFWR_MASK;
  136724:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136728:	e5d3301e 	ldrb	r3, [r3, #30]
  13672c:	e203203f 	and	r2, r3, #63	; 0x3f
  136730:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  136734:	e5832144 	str	r2, [r3, #324]	; 0x144
        /* Receive fifo full threshold settings. */
        base->RSFL = config->rxFifoFullThreshold & ENET_RSFL_RX_SECTION_FULL_MASK;
  136738:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  13673c:	e5d3301d 	ldrb	r3, [r3, #29]
  136740:	e1a02003 	mov	r2, r3
  136744:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  136748:	e5832190 	str	r2, [r3, #400]	; 0x190
  13674c:	ea000005 	b	136768 <ENET_SetMacController+0x28c>
    }
    else
    {
        /* Transmit fifo watermark settings. */
        base->TFWR = ENET_TFWR_STRFWD_MASK;
  136750:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  136754:	e3a02c01 	mov	r2, #256	; 0x100
  136758:	e5832144 	str	r2, [r3, #324]	; 0x144
        base->RSFL = 0;
  13675c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  136760:	e3a02000 	mov	r2, #0
  136764:	e5832190 	str	r2, [r3, #400]	; 0x190
    }

    /* Enable store and forward when accelerator is enabled */
    if (config->txAccelerConfig & (kENET_TxAccelIpCheckEnabled | kENET_TxAccelProtoCheckEnabled))
  136768:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  13676c:	e5d33019 	ldrb	r3, [r3, #25]
  136770:	e2033018 	and	r3, r3, #24
  136774:	e3530000 	cmp	r3, #0
  136778:	0a000002 	beq	136788 <ENET_SetMacController+0x2ac>
    {
        base->TFWR = ENET_TFWR_STRFWD_MASK;
  13677c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  136780:	e3a02c01 	mov	r2, #256	; 0x100
  136784:	e5832144 	str	r2, [r3, #324]	; 0x144
    }
    if (config->rxAccelerConfig & (kENET_RxAccelIpCheckEnabled | kENET_RxAccelProtoCheckEnabled))
  136788:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  13678c:	e5d33018 	ldrb	r3, [r3, #24]
  136790:	e2033006 	and	r3, r3, #6
  136794:	e3530000 	cmp	r3, #0
  136798:	0a000002 	beq	1367a8 <ENET_SetMacController+0x2cc>
    {
        base->RSFL = 0;
  13679c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1367a0:	e3a02000 	mov	r2, #0
  1367a4:	e5832190 	str	r2, [r3, #400]	; 0x190
    }

    /* Initializes transmit buffer descriptor rings start address, two start address should be aligned. */
    base->TDSR = (uint32_t)bufferConfig->txPhyBdStartAddrAlign;
  1367a8:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1367ac:	e5933020 	ldr	r3, [r3, #32]
  1367b0:	e1a02003 	mov	r2, r3
  1367b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1367b8:	e5832184 	str	r2, [r3, #388]	; 0x184
    base->RDSR = (uint32_t)bufferConfig->rxPhyBdStartAddrAlign;
  1367bc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1367c0:	e593301c 	ldr	r3, [r3, #28]
  1367c4:	e1a02003 	mov	r2, r3
  1367c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1367cc:	e5832180 	str	r2, [r3, #384]	; 0x180

    /* Initializes the maximum buffer size, the buffer size should be aligned. */

    base->MRBR = ENET_MRBR_R_BUF_SIZE(bufferConfig->rxBuffSizeAlign);
  1367d0:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
  1367d4:	e5933004 	ldr	r3, [r3, #4]
  1367d8:	e1a02203 	lsl	r2, r3, #4
  1367dc:	e3033ff0 	movw	r3, #16368	; 0x3ff0
  1367e0:	e0033002 	and	r3, r3, r2
  1367e4:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
  1367e8:	e5823188 	str	r3, [r2, #392]	; 0x188

    /* Configures the Mac address. */
    ENET_SetMacAddr(base, macAddr);
  1367ec:	e51b1034 	ldr	r1, [fp, #-52]	; 0xffffffcc
  1367f0:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  1367f4:	eb00011e 	bl	136c74 <ENET_SetMacAddr>

    /* Initialize the SMI if uninitialized. */
    if (!ENET_GetSMI(base))
  1367f8:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  1367fc:	ebfffda0 	bl	135e84 <ENET_GetSMI>
  136800:	e1a03000 	mov	r3, r0
  136804:	e2233001 	eor	r3, r3, #1
  136808:	e6ef3073 	uxtb	r3, r3
  13680c:	e3530000 	cmp	r3, #0
  136810:	0a00000a 	beq	136840 <ENET_SetMacController+0x364>
    {
        ENET_SetSMI(base, srcClock_Hz, !!(config->macSpecialConfig & kENET_ControlSMIPreambleDisable));
  136814:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136818:	e5933000 	ldr	r3, [r3]
  13681c:	e2033040 	and	r3, r3, #64	; 0x40
  136820:	e3530000 	cmp	r3, #0
  136824:	13a03001 	movne	r3, #1
  136828:	03a03000 	moveq	r3, #0
  13682c:	e6ef3073 	uxtb	r3, r3
  136830:	e1a02003 	mov	r2, r3
  136834:	e59b1004 	ldr	r1, [fp, #4]
  136838:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  13683c:	eb000171 	bl	136e08 <ENET_SetSMI>
    }
/* Enables Ethernet interrupt and NVIC. */
#if defined(FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE) && FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE
    if (config->intCoalesceCfg)
  136840:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136844:	e5933020 	ldr	r3, [r3, #32]
  136848:	e3530000 	cmp	r3, #0
  13684c:	0a000020 	beq	1368d4 <ENET_SetMacController+0x3f8>
    {
        uint32_t intMask = (ENET_EIMR_TXB_MASK | ENET_EIMR_RXB_MASK);
  136850:	e3a03405 	mov	r3, #83886080	; 0x5000000
  136854:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

        /* Clear all buffer interrupts. */
        base->EIMR &= ~intMask;
  136858:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  13685c:	e5932008 	ldr	r2, [r3, #8]
  136860:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  136864:	e1e03003 	mvn	r3, r3
  136868:	e0022003 	and	r2, r2, r3
  13686c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  136870:	e5832008 	str	r2, [r3, #8]
        /* Set the interrupt coalescence. */
        base->TXIC = ENET_TXIC_ICFT(config->intCoalesceCfg->txCoalesceFrameCount[0]) |
  136874:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  136878:	e5933020 	ldr	r3, [r3, #32]
  13687c:	e5d33000 	ldrb	r3, [r3]
  136880:	e1a03a03 	lsl	r3, r3, #20
  136884:	e20336ff 	and	r3, r3, #267386880	; 0xff00000
                     config->intCoalesceCfg->txCoalesceTimeCount[0] | ENET_TXIC_ICCS_MASK | ENET_TXIC_ICEN_MASK;
  136888:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  13688c:	e5922020 	ldr	r2, [r2, #32]
  136890:	e1d220b2 	ldrh	r2, [r2, #2]
        base->TXIC = ENET_TXIC_ICFT(config->intCoalesceCfg->txCoalesceFrameCount[0]) |
  136894:	e1833002 	orr	r3, r3, r2
                     config->intCoalesceCfg->txCoalesceTimeCount[0] | ENET_TXIC_ICCS_MASK | ENET_TXIC_ICEN_MASK;
  136898:	e3832103 	orr	r2, r3, #-1073741824	; 0xc0000000
        base->TXIC = ENET_TXIC_ICFT(config->intCoalesceCfg->txCoalesceFrameCount[0]) |
  13689c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1368a0:	e58320f0 	str	r2, [r3, #240]	; 0xf0
        base->RXIC = ENET_RXIC_ICFT(config->intCoalesceCfg->rxCoalesceFrameCount[0]) |
  1368a4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1368a8:	e5933020 	ldr	r3, [r3, #32]
  1368ac:	e5d33004 	ldrb	r3, [r3, #4]
  1368b0:	e1a03a03 	lsl	r3, r3, #20
  1368b4:	e20336ff 	and	r3, r3, #267386880	; 0xff00000
                     config->intCoalesceCfg->rxCoalesceTimeCount[0] | ENET_RXIC_ICCS_MASK | ENET_RXIC_ICEN_MASK;
  1368b8:	e51b202c 	ldr	r2, [fp, #-44]	; 0xffffffd4
  1368bc:	e5922020 	ldr	r2, [r2, #32]
  1368c0:	e1d220b6 	ldrh	r2, [r2, #6]
        base->RXIC = ENET_RXIC_ICFT(config->intCoalesceCfg->rxCoalesceFrameCount[0]) |
  1368c4:	e1833002 	orr	r3, r3, r2
                     config->intCoalesceCfg->rxCoalesceTimeCount[0] | ENET_RXIC_ICCS_MASK | ENET_RXIC_ICEN_MASK;
  1368c8:	e3832103 	orr	r2, r3, #-1073741824	; 0xc0000000
        base->RXIC = ENET_RXIC_ICFT(config->intCoalesceCfg->rxCoalesceFrameCount[0]) |
  1368cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1368d0:	e5832100 	str	r2, [r3, #256]	; 0x100
    }
#endif /* FSL_FEATURE_ENET_HAS_INTERRUPT_COALESCE */
    ENET_EnableInterrupts(base, config->interrupt);
  1368d4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
  1368d8:	e5933004 	ldr	r3, [r3, #4]
  1368dc:	e1a01003 	mov	r1, r3
  1368e0:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
  1368e4:	ebfffd8d 	bl	135f20 <ENET_EnableInterrupts>

    /* ENET control register setting. */
    ecr = base->ECR;
  1368e8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  1368ec:	e5933024 	ldr	r3, [r3, #36]	; 0x24
  1368f0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

    /* Enables Ethernet module after all configuration except the buffer descriptor active. */
    ecr |= ENET_ECR_ETHEREN_MASK | ENET_ECR_DBSWP_MASK;
  1368f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1368f8:	e3833c01 	orr	r3, r3, #256	; 0x100
  1368fc:	e3833002 	orr	r3, r3, #2
  136900:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    base->ECR = ecr;
  136904:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
  136908:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  13690c:	e5832024 	str	r2, [r3, #36]	; 0x24
}
  136910:	e320f000 	nop	{0}
  136914:	e24bd004 	sub	sp, fp, #4
  136918:	e8bd8800 	pop	{fp, pc}

0013691c <ENET_SetTxBufferDescriptors>:
static void ENET_SetTxBufferDescriptors(volatile enet_tx_bd_struct_t *txBdStartAlign,
                                        uint8_t *txBuffStartAlign,
                                        uint8_t *txBuffStartAlign_vaddr,
                                        uint32_t txBuffSizeAlign,
                                        uint32_t txBdNumber)
{
  13691c:	e92d4800 	push	{fp, lr}
  136920:	e28db004 	add	fp, sp, #4
  136924:	e24dd018 	sub	sp, sp, #24
  136928:	e50b0010 	str	r0, [fp, #-16]
  13692c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  136930:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  136934:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(txBdStartAlign);
  136938:	e51b3010 	ldr	r3, [fp, #-16]
  13693c:	e3530000 	cmp	r3, #0
  136940:	1a000005 	bne	13695c <ENET_SetTxBufferDescriptors+0x40>
  136944:	e30021e2 	movw	r2, #482	; 0x1e2
  136948:	e30a14c4 	movw	r1, #42180	; 0xa4c4
  13694c:	e3401014 	movt	r1, #20
  136950:	e30a0324 	movw	r0, #41764	; 0xa324
  136954:	e3400014 	movt	r0, #20
  136958:	ebff330e 	bl	103598 <rt_assert_handler>
    RT_ASSERT(txBuffStartAlign);
  13695c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136960:	e3530000 	cmp	r3, #0
  136964:	1a000005 	bne	136980 <ENET_SetTxBufferDescriptors+0x64>
  136968:	e30021e3 	movw	r2, #483	; 0x1e3
  13696c:	e30a14c4 	movw	r1, #42180	; 0xa4c4
  136970:	e3401014 	movt	r1, #20
  136974:	e30a0334 	movw	r0, #41780	; 0xa334
  136978:	e3400014 	movt	r0, #20
  13697c:	ebff3305 	bl	103598 <rt_assert_handler>
    uint32_t count;
    volatile enet_tx_bd_struct_t *curBuffDescrip = txBdStartAlign;
  136980:	e51b3010 	ldr	r3, [fp, #-16]
  136984:	e50b300c 	str	r3, [fp, #-12]
    for (count = 0; count < txBdNumber; count++)
  136988:	e3a03000 	mov	r3, #0
  13698c:	e50b3008 	str	r3, [fp, #-8]
  136990:	ea00002c 	b	136a48 <ENET_SetTxBufferDescriptors+0x12c>
        /* Set data buffer address. */
        // curBuffDescrip->buffer = (uint8_t *)((uint32_t)&txBuffStartAlign[(-1) * count * txBuffSizeAlign]);
        // curBuffDescrip->buffer = (uint8_t *)ueth_v2p((void*)&txBuffStartAlign_vaddr[count * txBuffSizeAlign]);
        // curBuffDescrip->buffer_vaddr = (uint8_t *)((uint32_t)&txBuffStartAlign_vaddr[count * txBuffSizeAlign]);
        // buffer_vaddr_tx[count] = (uint8_t *)((void*)&txBuffStartAlign_vaddr[count * txBuffSizeAlign]);
        curBuffDescrip->buffer = (uint8_t *)ueth_v2p((void*)&txBuffStartAlign_vaddr[count * txBuffSizeAlign]);
  136994:	e51b3008 	ldr	r3, [fp, #-8]
  136998:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  13699c:	e0030392 	mul	r3, r2, r3
  1369a0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1369a4:	e0823003 	add	r3, r2, r3
  1369a8:	e1a00003 	mov	r0, r3
  1369ac:	ebff3699 	bl	104418 <ueth_v2p>
  1369b0:	e1a02000 	mov	r2, r0
  1369b4:	e51b300c 	ldr	r3, [fp, #-12]
  1369b8:	e5832004 	str	r2, [r3, #4]
        buffer_vaddr_tx[count] = (uint8_t *)ueth_remap(curBuffDescrip->buffer, UETH_REMAP_NOCACHE, txBuffSizeAlign);
  1369bc:	e51b300c 	ldr	r3, [fp, #-12]
  1369c0:	e5933004 	ldr	r3, [r3, #4]
  1369c4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1369c8:	e3a01003 	mov	r1, #3
  1369cc:	e1a00003 	mov	r0, r3
  1369d0:	ebff36bd 	bl	1044cc <ueth_remap>
  1369d4:	e1a01000 	mov	r1, r0
  1369d8:	e3063c80 	movw	r3, #27776	; 0x6c80
  1369dc:	e3403057 	movt	r3, #87	; 0x57
  1369e0:	e51b2008 	ldr	r2, [fp, #-8]
  1369e4:	e7831102 	str	r1, [r3, r2, lsl #2]
        /* Initializes data length. */
        curBuffDescrip->length = 0;
  1369e8:	e51b300c 	ldr	r3, [fp, #-12]
  1369ec:	e3a02000 	mov	r2, #0
  1369f0:	e1c320b0 	strh	r2, [r3]
        /* Sets the crc. */
        curBuffDescrip->control = (ENET_BUFFDESCRIPTOR_TX_TRANMITCRC_MASK);
  1369f4:	e51b300c 	ldr	r3, [fp, #-12]
  1369f8:	e3a02b01 	mov	r2, #1024	; 0x400
  1369fc:	e1c320b2 	strh	r2, [r3, #2]
        /* Sets the last buffer descriptor with the wrap flag. */
        if (count == txBdNumber - 1)
  136a00:	e59b3004 	ldr	r3, [fp, #4]
  136a04:	e2433001 	sub	r3, r3, #1
  136a08:	e51b2008 	ldr	r2, [fp, #-8]
  136a0c:	e1520003 	cmp	r2, r3
  136a10:	1a000006 	bne	136a30 <ENET_SetTxBufferDescriptors+0x114>
        {
            curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_WRAP_MASK;
  136a14:	e51b300c 	ldr	r3, [fp, #-12]
  136a18:	e1d330b2 	ldrh	r3, [r3, #2]
  136a1c:	e6ff3073 	uxth	r3, r3
  136a20:	e3833a02 	orr	r3, r3, #8192	; 0x2000
  136a24:	e6ff2073 	uxth	r2, r3
  136a28:	e51b300c 	ldr	r3, [fp, #-12]
  136a2c:	e1c320b2 	strh	r2, [r3, #2]

        /* Add cache clean operation. */
        // rt_hw_cpu_dcache_clean((void *)curBuffDescrip, sizeof(enet_tx_bd_struct_t));
        // ueth_dcache_clean((void *)curBuffDescrip, sizeof(enet_tx_bd_struct_t));
        /* Increase the index. */
        curBuffDescrip++;
  136a30:	e51b300c 	ldr	r3, [fp, #-12]
  136a34:	e2833008 	add	r3, r3, #8
  136a38:	e50b300c 	str	r3, [fp, #-12]
    for (count = 0; count < txBdNumber; count++)
  136a3c:	e51b3008 	ldr	r3, [fp, #-8]
  136a40:	e2833001 	add	r3, r3, #1
  136a44:	e50b3008 	str	r3, [fp, #-8]
  136a48:	e51b2008 	ldr	r2, [fp, #-8]
  136a4c:	e59b3004 	ldr	r3, [fp, #4]
  136a50:	e1520003 	cmp	r2, r3
  136a54:	3affffce 	bcc	136994 <ENET_SetTxBufferDescriptors+0x78>
    }
}
  136a58:	e320f000 	nop	{0}
  136a5c:	e24bd004 	sub	sp, fp, #4
  136a60:	e8bd8800 	pop	{fp, pc}

00136a64 <ENET_SetRxBufferDescriptors>:
                                        uint8_t *rxBuffStartAlign,
                                        uint8_t *rxBuffStartAlign_vaddr,
                                        uint32_t rxBuffSizeAlign,
                                        uint32_t rxBdNumber,
                                        bool enableInterrupt)
{
  136a64:	e92d4800 	push	{fp, lr}
  136a68:	e28db004 	add	fp, sp, #4
  136a6c:	e24dd018 	sub	sp, sp, #24
  136a70:	e50b0010 	str	r0, [fp, #-16]
  136a74:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  136a78:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  136a7c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(rxBdStartAlign);
  136a80:	e51b3010 	ldr	r3, [fp, #-16]
  136a84:	e3530000 	cmp	r3, #0
  136a88:	1a000005 	bne	136aa4 <ENET_SetRxBufferDescriptors+0x40>
  136a8c:	e3002209 	movw	r2, #521	; 0x209
  136a90:	e30a14e0 	movw	r1, #42208	; 0xa4e0
  136a94:	e3401014 	movt	r1, #20
  136a98:	e30a0348 	movw	r0, #41800	; 0xa348
  136a9c:	e3400014 	movt	r0, #20
  136aa0:	ebff32bc 	bl	103598 <rt_assert_handler>
    RT_ASSERT(rxBuffStartAlign);
  136aa4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136aa8:	e3530000 	cmp	r3, #0
  136aac:	1a000005 	bne	136ac8 <ENET_SetRxBufferDescriptors+0x64>
  136ab0:	e300220a 	movw	r2, #522	; 0x20a
  136ab4:	e30a14e0 	movw	r1, #42208	; 0xa4e0
  136ab8:	e3401014 	movt	r1, #20
  136abc:	e30a0358 	movw	r0, #41816	; 0xa358
  136ac0:	e3400014 	movt	r0, #20
  136ac4:	ebff32b3 	bl	103598 <rt_assert_handler>

    volatile enet_rx_bd_struct_t *curBuffDescrip = rxBdStartAlign;
  136ac8:	e51b3010 	ldr	r3, [fp, #-16]
  136acc:	e50b3008 	str	r3, [fp, #-8]
    uint32_t count = 0;
  136ad0:	e3a03000 	mov	r3, #0
  136ad4:	e50b300c 	str	r3, [fp, #-12]

    /* Initializes receive buffer descriptors. */
    for (count = 0; count < rxBdNumber; count++)
  136ad8:	e3a03000 	mov	r3, #0
  136adc:	e50b300c 	str	r3, [fp, #-12]
  136ae0:	ea00002c 	b	136b98 <ENET_SetRxBufferDescriptors+0x134>
    {
        /* Set data buffer and the length. */
        // curBuffDescrip->buffer = (uint8_t *)((void *)&rxBuffStartAlign[(-1) * count * rxBuffSizeAlign]);
        curBuffDescrip->buffer = (uint8_t *)ueth_v2p((void*)&rxBuffStartAlign_vaddr[count * rxBuffSizeAlign]);
  136ae4:	e51b300c 	ldr	r3, [fp, #-12]
  136ae8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  136aec:	e0030392 	mul	r3, r2, r3
  136af0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  136af4:	e0823003 	add	r3, r2, r3
  136af8:	e1a00003 	mov	r0, r3
  136afc:	ebff3645 	bl	104418 <ueth_v2p>
  136b00:	e1a02000 	mov	r2, r0
  136b04:	e51b3008 	ldr	r3, [fp, #-8]
  136b08:	e5832004 	str	r2, [r3, #4]
        // curBuffDescrip->buffer_vaddr = (uint8_t *)((void *)&rxBuffStartAlign_vaddr[count * rxBuffSizeAlign]);
        buffer_vaddr_rx[count] = (uint8_t *)ueth_remap(curBuffDescrip->buffer, UETH_REMAP_NOCACHE, rxBuffSizeAlign);
  136b0c:	e51b3008 	ldr	r3, [fp, #-8]
  136b10:	e5933004 	ldr	r3, [r3, #4]
  136b14:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  136b18:	e3a01003 	mov	r1, #3
  136b1c:	e1a00003 	mov	r0, r3
  136b20:	ebff3669 	bl	1044cc <ueth_remap>
  136b24:	e1a01000 	mov	r1, r0
  136b28:	e3063a80 	movw	r3, #27264	; 0x6a80
  136b2c:	e3403057 	movt	r3, #87	; 0x57
  136b30:	e51b200c 	ldr	r2, [fp, #-12]
  136b34:	e7831102 	str	r1, [r3, r2, lsl #2]
        curBuffDescrip->length = 0;
  136b38:	e51b3008 	ldr	r3, [fp, #-8]
  136b3c:	e3a02000 	mov	r2, #0
  136b40:	e1c320b0 	strh	r2, [r3]
        /* Initializes the buffer descriptors with empty bit. */
        curBuffDescrip->control = ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
  136b44:	e51b3008 	ldr	r3, [fp, #-8]
  136b48:	e3a02902 	mov	r2, #32768	; 0x8000
  136b4c:	e1c320b2 	strh	r2, [r3, #2]
        /* Sets the last buffer descriptor with the wrap flag. */
        if (count == rxBdNumber - 1)
  136b50:	e59b3004 	ldr	r3, [fp, #4]
  136b54:	e2433001 	sub	r3, r3, #1
  136b58:	e51b200c 	ldr	r2, [fp, #-12]
  136b5c:	e1520003 	cmp	r2, r3
  136b60:	1a000006 	bne	136b80 <ENET_SetRxBufferDescriptors+0x11c>
        {
            curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_RX_WRAP_MASK;
  136b64:	e51b3008 	ldr	r3, [fp, #-8]
  136b68:	e1d330b2 	ldrh	r3, [r3, #2]
  136b6c:	e6ff3073 	uxth	r3, r3
  136b70:	e3833a02 	orr	r3, r3, #8192	; 0x2000
  136b74:	e6ff2073 	uxth	r2, r3
  136b78:	e51b3008 	ldr	r3, [fp, #-8]
  136b7c:	e1c320b2 	strh	r2, [r3, #2]
        
#ifdef ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
        curBuffDescrip->controlExtend1 |= ENET_BUFFDESCRIPTOR_RX_INTERRUPT_MASK;
#endif

        curBuffDescrip++;
  136b80:	e51b3008 	ldr	r3, [fp, #-8]
  136b84:	e2833008 	add	r3, r3, #8
  136b88:	e50b3008 	str	r3, [fp, #-8]
    for (count = 0; count < rxBdNumber; count++)
  136b8c:	e51b300c 	ldr	r3, [fp, #-12]
  136b90:	e2833001 	add	r3, r3, #1
  136b94:	e50b300c 	str	r3, [fp, #-12]
  136b98:	e51b200c 	ldr	r2, [fp, #-12]
  136b9c:	e59b3004 	ldr	r3, [fp, #4]
  136ba0:	e1520003 	cmp	r2, r3
  136ba4:	3affffce 	bcc	136ae4 <ENET_SetRxBufferDescriptors+0x80>

    }
}
  136ba8:	e320f000 	nop	{0}
  136bac:	e24bd004 	sub	sp, fp, #4
  136bb0:	e8bd8800 	pop	{fp, pc}

00136bb4 <ENET_SetMII>:

void ENET_SetMII(ENET_Type *base, enet_mii_speed_t speed, enet_mii_duplex_t duplex)
{
  136bb4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  136bb8:	e28db000 	add	fp, sp, #0
  136bbc:	e24dd01c 	sub	sp, sp, #28
  136bc0:	e50b0010 	str	r0, [fp, #-16]
  136bc4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  136bc8:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    uint32_t rcr = base->RCR;
  136bcc:	e51b3010 	ldr	r3, [fp, #-16]
  136bd0:	e5933084 	ldr	r3, [r3, #132]	; 0x84
  136bd4:	e50b3008 	str	r3, [fp, #-8]
    uint32_t tcr = base->TCR;
  136bd8:	e51b3010 	ldr	r3, [fp, #-16]
  136bdc:	e59330c4 	ldr	r3, [r3, #196]	; 0xc4
  136be0:	e50b300c 	str	r3, [fp, #-12]
    /* Sets speed mode. */
    if (kENET_MiiSpeed10M == speed)
  136be4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136be8:	e3530000 	cmp	r3, #0
  136bec:	1a000003 	bne	136c00 <ENET_SetMII+0x4c>
    {
        rcr |= ENET_RCR_RMII_10T_MASK;
  136bf0:	e51b3008 	ldr	r3, [fp, #-8]
  136bf4:	e3833c02 	orr	r3, r3, #512	; 0x200
  136bf8:	e50b3008 	str	r3, [fp, #-8]
  136bfc:	ea000002 	b	136c0c <ENET_SetMII+0x58>
    }
    else
    {
        rcr &= ~ENET_RCR_RMII_10T_MASK;
  136c00:	e51b3008 	ldr	r3, [fp, #-8]
  136c04:	e3c33c02 	bic	r3, r3, #512	; 0x200
  136c08:	e50b3008 	str	r3, [fp, #-8]
    }
    /* Set duplex mode. */
    if (duplex == kENET_MiiHalfDuplex)
  136c0c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  136c10:	e3530000 	cmp	r3, #0
  136c14:	1a000006 	bne	136c34 <ENET_SetMII+0x80>
    {
        rcr |= ENET_RCR_DRT_MASK;
  136c18:	e51b3008 	ldr	r3, [fp, #-8]
  136c1c:	e3833002 	orr	r3, r3, #2
  136c20:	e50b3008 	str	r3, [fp, #-8]
        tcr &= ~ENET_TCR_FDEN_MASK;
  136c24:	e51b300c 	ldr	r3, [fp, #-12]
  136c28:	e3c33004 	bic	r3, r3, #4
  136c2c:	e50b300c 	str	r3, [fp, #-12]
  136c30:	ea000005 	b	136c4c <ENET_SetMII+0x98>
    }
    else
    {
        rcr &= ~ENET_RCR_DRT_MASK;
  136c34:	e51b3008 	ldr	r3, [fp, #-8]
  136c38:	e3c33002 	bic	r3, r3, #2
  136c3c:	e50b3008 	str	r3, [fp, #-8]
        tcr |= ENET_TCR_FDEN_MASK;
  136c40:	e51b300c 	ldr	r3, [fp, #-12]
  136c44:	e3833004 	orr	r3, r3, #4
  136c48:	e50b300c 	str	r3, [fp, #-12]
    }

    base->RCR = rcr;
  136c4c:	e51b3010 	ldr	r3, [fp, #-16]
  136c50:	e51b2008 	ldr	r2, [fp, #-8]
  136c54:	e5832084 	str	r2, [r3, #132]	; 0x84
    base->TCR = tcr;
  136c58:	e51b3010 	ldr	r3, [fp, #-16]
  136c5c:	e51b200c 	ldr	r2, [fp, #-12]
  136c60:	e58320c4 	str	r2, [r3, #196]	; 0xc4
}
  136c64:	e320f000 	nop	{0}
  136c68:	e28bd000 	add	sp, fp, #0
  136c6c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  136c70:	e12fff1e 	bx	lr

00136c74 <ENET_SetMacAddr>:

void ENET_SetMacAddr(ENET_Type *base, uint8_t *macAddr)
{
  136c74:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  136c78:	e28db000 	add	fp, sp, #0
  136c7c:	e24dd014 	sub	sp, sp, #20
  136c80:	e50b0010 	str	r0, [fp, #-16]
  136c84:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    uint32_t address;

    /* Set physical address lower register. */
    address = (uint32_t)(((uint32_t)macAddr[0] << 24U) | ((uint32_t)macAddr[1] << 16U) | ((uint32_t)macAddr[2] << 8U) |
  136c88:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136c8c:	e5d33000 	ldrb	r3, [r3]
  136c90:	e1a02c03 	lsl	r2, r3, #24
  136c94:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136c98:	e2833001 	add	r3, r3, #1
  136c9c:	e5d33000 	ldrb	r3, [r3]
  136ca0:	e1a03803 	lsl	r3, r3, #16
  136ca4:	e1822003 	orr	r2, r2, r3
  136ca8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136cac:	e2833002 	add	r3, r3, #2
  136cb0:	e5d33000 	ldrb	r3, [r3]
  136cb4:	e1a03403 	lsl	r3, r3, #8
  136cb8:	e1823003 	orr	r3, r2, r3
                         (uint32_t)macAddr[3]);
  136cbc:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  136cc0:	e2822003 	add	r2, r2, #3
  136cc4:	e5d22000 	ldrb	r2, [r2]
    address = (uint32_t)(((uint32_t)macAddr[0] << 24U) | ((uint32_t)macAddr[1] << 16U) | ((uint32_t)macAddr[2] << 8U) |
  136cc8:	e1833002 	orr	r3, r3, r2
  136ccc:	e50b3008 	str	r3, [fp, #-8]
    base->PALR = address;
  136cd0:	e51b3010 	ldr	r3, [fp, #-16]
  136cd4:	e51b2008 	ldr	r2, [fp, #-8]
  136cd8:	e58320e4 	str	r2, [r3, #228]	; 0xe4
    /* Set physical address high register. */
    address = (uint32_t)(((uint32_t)macAddr[4] << 8U) | ((uint32_t)macAddr[5]));
  136cdc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136ce0:	e2833004 	add	r3, r3, #4
  136ce4:	e5d33000 	ldrb	r3, [r3]
  136ce8:	e1a03403 	lsl	r3, r3, #8
  136cec:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  136cf0:	e2822005 	add	r2, r2, #5
  136cf4:	e5d22000 	ldrb	r2, [r2]
  136cf8:	e1833002 	orr	r3, r3, r2
  136cfc:	e50b3008 	str	r3, [fp, #-8]
    base->PAUR = address << ENET_PAUR_PADDR2_SHIFT;
  136d00:	e51b3008 	ldr	r3, [fp, #-8]
  136d04:	e1a02803 	lsl	r2, r3, #16
  136d08:	e51b3010 	ldr	r3, [fp, #-16]
  136d0c:	e58320e8 	str	r2, [r3, #232]	; 0xe8
}
  136d10:	e320f000 	nop	{0}
  136d14:	e28bd000 	add	sp, fp, #0
  136d18:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  136d1c:	e12fff1e 	bx	lr

00136d20 <ENET_GetMacAddr>:

void ENET_GetMacAddr(ENET_Type *base, uint8_t *macAddr)
{
  136d20:	e92d4800 	push	{fp, lr}
  136d24:	e28db004 	add	fp, sp, #4
  136d28:	e24dd010 	sub	sp, sp, #16
  136d2c:	e50b0010 	str	r0, [fp, #-16]
  136d30:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    RT_ASSERT(macAddr);
  136d34:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136d38:	e3530000 	cmp	r3, #0
  136d3c:	1a000005 	bne	136d58 <ENET_GetMacAddr+0x38>
  136d40:	e3002259 	movw	r2, #601	; 0x259
  136d44:	e30a14fc 	movw	r1, #42236	; 0xa4fc
  136d48:	e3401014 	movt	r1, #20
  136d4c:	e30a01cc 	movw	r0, #41420	; 0xa1cc
  136d50:	e3400014 	movt	r0, #20
  136d54:	ebff320f 	bl	103598 <rt_assert_handler>

    uint32_t address;

    /* Get from physical address lower register. */
    address = base->PALR;
  136d58:	e51b3010 	ldr	r3, [fp, #-16]
  136d5c:	e59330e4 	ldr	r3, [r3, #228]	; 0xe4
  136d60:	e50b3008 	str	r3, [fp, #-8]
    macAddr[0] = 0xFFU & (address >> 24U);
  136d64:	e51b3008 	ldr	r3, [fp, #-8]
  136d68:	e1a03c23 	lsr	r3, r3, #24
  136d6c:	e6ef2073 	uxtb	r2, r3
  136d70:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136d74:	e5c32000 	strb	r2, [r3]
    macAddr[1] = 0xFFU & (address >> 16U);
  136d78:	e51b3008 	ldr	r3, [fp, #-8]
  136d7c:	e1a02823 	lsr	r2, r3, #16
  136d80:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136d84:	e2833001 	add	r3, r3, #1
  136d88:	e6ef2072 	uxtb	r2, r2
  136d8c:	e5c32000 	strb	r2, [r3]
    macAddr[2] = 0xFFU & (address >> 8U);
  136d90:	e51b3008 	ldr	r3, [fp, #-8]
  136d94:	e1a02423 	lsr	r2, r3, #8
  136d98:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136d9c:	e2833002 	add	r3, r3, #2
  136da0:	e6ef2072 	uxtb	r2, r2
  136da4:	e5c32000 	strb	r2, [r3]
    macAddr[3] = 0xFFU & address;
  136da8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136dac:	e2833003 	add	r3, r3, #3
  136db0:	e51b2008 	ldr	r2, [fp, #-8]
  136db4:	e6ef2072 	uxtb	r2, r2
  136db8:	e5c32000 	strb	r2, [r3]

    /* Get from physical address high register. */
    address = (base->PAUR & ENET_PAUR_PADDR2_MASK) >> ENET_PAUR_PADDR2_SHIFT;
  136dbc:	e51b3010 	ldr	r3, [fp, #-16]
  136dc0:	e59330e8 	ldr	r3, [r3, #232]	; 0xe8
  136dc4:	e1a03823 	lsr	r3, r3, #16
  136dc8:	e6ff3073 	uxth	r3, r3
  136dcc:	e50b3008 	str	r3, [fp, #-8]
    macAddr[4] = 0xFFU & (address >> 8U);
  136dd0:	e51b3008 	ldr	r3, [fp, #-8]
  136dd4:	e1a02423 	lsr	r2, r3, #8
  136dd8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136ddc:	e2833004 	add	r3, r3, #4
  136de0:	e6ef2072 	uxtb	r2, r2
  136de4:	e5c32000 	strb	r2, [r3]
    macAddr[5] = 0xFFU & address;
  136de8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136dec:	e2833005 	add	r3, r3, #5
  136df0:	e51b2008 	ldr	r2, [fp, #-8]
  136df4:	e6ef2072 	uxtb	r2, r2
  136df8:	e5c32000 	strb	r2, [r3]
}
  136dfc:	e320f000 	nop	{0}
  136e00:	e24bd004 	sub	sp, fp, #4
  136e04:	e8bd8800 	pop	{fp, pc}

00136e08 <ENET_SetSMI>:

void ENET_SetSMI(ENET_Type *base, uint32_t srcClock_Hz, bool isPreambleDisabled)
{
  136e08:	e92d4810 	push	{r4, fp, lr}
  136e0c:	e28db008 	add	fp, sp, #8
  136e10:	e24dd024 	sub	sp, sp, #36	; 0x24
  136e14:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
  136e18:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
  136e1c:	e1a03002 	mov	r3, r2
  136e20:	e54b3025 	strb	r3, [fp, #-37]	; 0xffffffdb
    RT_ASSERT(srcClock_Hz);
  136e24:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  136e28:	e3530000 	cmp	r3, #0
  136e2c:	1a000005 	bne	136e48 <ENET_SetSMI+0x40>
  136e30:	e3a02f9b 	mov	r2, #620	; 0x26c
  136e34:	e30a150c 	movw	r1, #42252	; 0xa50c
  136e38:	e3401014 	movt	r1, #20
  136e3c:	e30a036c 	movw	r0, #41836	; 0xa36c
  136e40:	e3400014 	movt	r0, #20
  136e44:	ebff31d3 	bl	103598 <rt_assert_handler>

    uint32_t clkCycle = 0;
  136e48:	e3a03000 	mov	r3, #0
  136e4c:	e50b3010 	str	r3, [fp, #-16]
    uint32_t speed = 0;
  136e50:	e3a03000 	mov	r3, #0
  136e54:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    uint32_t mscr = 0;
  136e58:	e3a03000 	mov	r3, #0
  136e5c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    /* Calculate the MII speed which controls the frequency of the MDC. */
    speed = srcClock_Hz / (2 * ENET_MDC_FREQUENCY);
  136e60:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  136e64:	e30c3a6b 	movw	r3, #51819	; 0xca6b
  136e68:	e3463b5f 	movt	r3, #27487	; 0x6b5f
  136e6c:	e0832392 	umull	r2, r3, r2, r3
  136e70:	e1a03aa3 	lsr	r3, r3, #21
  136e74:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    /* Calculate the hold time on the MDIO output. */
    clkCycle = (10 + ENET_NANOSECOND_ONE_SECOND / srcClock_Hz - 1) / (ENET_NANOSECOND_ONE_SECOND / srcClock_Hz) - 1;
  136e78:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  136e7c:	e3a00cca 	mov	r0, #51712	; 0xca00
  136e80:	e3430b9a 	movt	r0, #15258	; 0x3b9a
  136e84:	eb0006fa 	bl	138a74 <__udivsi3>
  136e88:	e1a03000 	mov	r3, r0
  136e8c:	e2834009 	add	r4, r3, #9
  136e90:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
  136e94:	e3a00cca 	mov	r0, #51712	; 0xca00
  136e98:	e3430b9a 	movt	r0, #15258	; 0x3b9a
  136e9c:	eb0006f4 	bl	138a74 <__udivsi3>
  136ea0:	e1a03000 	mov	r3, r0
  136ea4:	e1a01003 	mov	r1, r3
  136ea8:	e1a00004 	mov	r0, r4
  136eac:	eb0006f0 	bl	138a74 <__udivsi3>
  136eb0:	e1a03000 	mov	r3, r0
  136eb4:	e2433001 	sub	r3, r3, #1
  136eb8:	e50b3010 	str	r3, [fp, #-16]
    /* Build the configuration for MDC/MDIO control. */
    mscr = ENET_MSCR_MII_SPEED(speed) | ENET_MSCR_DIS_PRE(isPreambleDisabled) | ENET_MSCR_HOLDTIME(clkCycle);
  136ebc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136ec0:	e1a03083 	lsl	r3, r3, #1
  136ec4:	e203207e 	and	r2, r3, #126	; 0x7e
  136ec8:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
  136ecc:	e1a03383 	lsl	r3, r3, #7
  136ed0:	e6ef3073 	uxtb	r3, r3
  136ed4:	e1822003 	orr	r2, r2, r3
  136ed8:	e51b3010 	ldr	r3, [fp, #-16]
  136edc:	e1a03403 	lsl	r3, r3, #8
  136ee0:	e2033c07 	and	r3, r3, #1792	; 0x700
  136ee4:	e1823003 	orr	r3, r2, r3
  136ee8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    base->MSCR = mscr;
  136eec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  136ef0:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  136ef4:	e5832044 	str	r2, [r3, #68]	; 0x44
}
  136ef8:	e320f000 	nop	{0}
  136efc:	e24bd008 	sub	sp, fp, #8
  136f00:	e8bd8810 	pop	{r4, fp, pc}

00136f04 <ENET_StartSMIWrite>:

void ENET_StartSMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_write_t operation, uint32_t data)
{
  136f04:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  136f08:	e28db000 	add	fp, sp, #0
  136f0c:	e24dd01c 	sub	sp, sp, #28
  136f10:	e50b0010 	str	r0, [fp, #-16]
  136f14:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  136f18:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  136f1c:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    uint32_t mmfr = 0;
  136f20:	e3a03000 	mov	r3, #0
  136f24:	e50b3008 	str	r3, [fp, #-8]

    /* Build MII write command. */
    mmfr = ENET_MMFR_ST(1) | ENET_MMFR_OP(operation) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(phyReg) | ENET_MMFR_TA(2) |
  136f28:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  136f2c:	e1a03e03 	lsl	r3, r3, #28
  136f30:	e2032203 	and	r2, r3, #805306368	; 0x30000000
  136f34:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136f38:	e1a03b83 	lsl	r3, r3, #23
  136f3c:	e203353e 	and	r3, r3, #260046848	; 0xf800000
  136f40:	e1822003 	orr	r2, r2, r3
  136f44:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  136f48:	e1a03903 	lsl	r3, r3, #18
  136f4c:	e203371f 	and	r3, r3, #8126464	; 0x7c0000
  136f50:	e1822003 	orr	r2, r2, r3
           (data & 0xFFFF);
  136f54:	e59b3004 	ldr	r3, [fp, #4]
  136f58:	e6ff3073 	uxth	r3, r3
    mmfr = ENET_MMFR_ST(1) | ENET_MMFR_OP(operation) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(phyReg) | ENET_MMFR_TA(2) |
  136f5c:	e1823003 	orr	r3, r2, r3
  136f60:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
  136f64:	e3833802 	orr	r3, r3, #131072	; 0x20000
  136f68:	e50b3008 	str	r3, [fp, #-8]
    base->MMFR = mmfr;
  136f6c:	e51b3010 	ldr	r3, [fp, #-16]
  136f70:	e51b2008 	ldr	r2, [fp, #-8]
  136f74:	e5832040 	str	r2, [r3, #64]	; 0x40
}
  136f78:	e320f000 	nop	{0}
  136f7c:	e28bd000 	add	sp, fp, #0
  136f80:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  136f84:	e12fff1e 	bx	lr

00136f88 <ENET_StartSMIRead>:

void ENET_StartSMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, enet_mii_read_t operation)
{
  136f88:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  136f8c:	e28db000 	add	fp, sp, #0
  136f90:	e24dd01c 	sub	sp, sp, #28
  136f94:	e50b0010 	str	r0, [fp, #-16]
  136f98:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  136f9c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  136fa0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    uint32_t mmfr = 0;
  136fa4:	e3a03000 	mov	r3, #0
  136fa8:	e50b3008 	str	r3, [fp, #-8]

    /* Build MII read command. */
    mmfr = ENET_MMFR_ST(1) | ENET_MMFR_OP(operation) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(phyReg) | ENET_MMFR_TA(2);
  136fac:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  136fb0:	e1a03e03 	lsl	r3, r3, #28
  136fb4:	e2032203 	and	r2, r3, #805306368	; 0x30000000
  136fb8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  136fbc:	e1a03b83 	lsl	r3, r3, #23
  136fc0:	e203353e 	and	r3, r3, #260046848	; 0xf800000
  136fc4:	e1822003 	orr	r2, r2, r3
  136fc8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  136fcc:	e1a03903 	lsl	r3, r3, #18
  136fd0:	e203371f 	and	r3, r3, #8126464	; 0x7c0000
  136fd4:	e1823003 	orr	r3, r2, r3
  136fd8:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
  136fdc:	e3833802 	orr	r3, r3, #131072	; 0x20000
  136fe0:	e50b3008 	str	r3, [fp, #-8]
    base->MMFR = mmfr;
  136fe4:	e51b3010 	ldr	r3, [fp, #-16]
  136fe8:	e51b2008 	ldr	r2, [fp, #-8]
  136fec:	e5832040 	str	r2, [r3, #64]	; 0x40
}
  136ff0:	e320f000 	nop	{0}
  136ff4:	e28bd000 	add	sp, fp, #0
  136ff8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  136ffc:	e12fff1e 	bx	lr

00137000 <ENET_StartExtC45SMIWrite>:

#if defined(FSL_FEATURE_ENET_HAS_EXTEND_MDIO) && FSL_FEATURE_ENET_HAS_EXTEND_MDIO
void ENET_StartExtC45SMIWrite(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, uint32_t data)
{
  137000:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  137004:	e28db000 	add	fp, sp, #0
  137008:	e24dd01c 	sub	sp, sp, #28
  13700c:	e50b0010 	str	r0, [fp, #-16]
  137010:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  137014:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  137018:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    uint32_t mmfr = 0;
  13701c:	e3a03000 	mov	r3, #0
  137020:	e50b3008 	str	r3, [fp, #-8]

    /* Parse the address from the input register. */
    uint16_t devAddr = (phyReg >> ENET_MMFR_TA_SHIFT) & 0x1FU;
  137024:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137028:	e1a03823 	lsr	r3, r3, #16
  13702c:	e6ff3073 	uxth	r3, r3
  137030:	e203301f 	and	r3, r3, #31
  137034:	e14b30ba 	strh	r3, [fp, #-10]
    uint16_t regAddr = (uint16_t)(phyReg & 0xFFFFU);
  137038:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  13703c:	e14b30bc 	strh	r3, [fp, #-12]

    /* Address write firstly. */
    mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiAddrWrite_C45) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(devAddr) |
  137040:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137044:	e1a03b83 	lsl	r3, r3, #23
  137048:	e203253e 	and	r2, r3, #260046848	; 0xf800000
  13704c:	e15b30ba 	ldrh	r3, [fp, #-10]
  137050:	e1a03903 	lsl	r3, r3, #18
  137054:	e203371f 	and	r3, r3, #8126464	; 0x7c0000
  137058:	e1822003 	orr	r2, r2, r3
           ENET_MMFR_TA(2) | ENET_MMFR_DATA(regAddr);
  13705c:	e15b30bc 	ldrh	r3, [fp, #-12]
  137060:	e1823003 	orr	r3, r2, r3
    mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiAddrWrite_C45) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(devAddr) |
  137064:	e3833802 	orr	r3, r3, #131072	; 0x20000
  137068:	e50b3008 	str	r3, [fp, #-8]
    base->MMFR = mmfr;
  13706c:	e51b3010 	ldr	r3, [fp, #-16]
  137070:	e51b2008 	ldr	r2, [fp, #-8]
  137074:	e5832040 	str	r2, [r3, #64]	; 0x40

    /* Build MII write command. */
    mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiWriteFrame_C45) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(devAddr) |
  137078:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13707c:	e1a03b83 	lsl	r3, r3, #23
  137080:	e203253e 	and	r2, r3, #260046848	; 0xf800000
  137084:	e15b30ba 	ldrh	r3, [fp, #-10]
  137088:	e1a03903 	lsl	r3, r3, #18
  13708c:	e203371f 	and	r3, r3, #8126464	; 0x7c0000
  137090:	e1822003 	orr	r2, r2, r3
           ENET_MMFR_TA(2) | ENET_MMFR_DATA(data);
  137094:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  137098:	e6ff3073 	uxth	r3, r3
  13709c:	e1823003 	orr	r3, r2, r3
    mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiWriteFrame_C45) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(devAddr) |
  1370a0:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
  1370a4:	e3833802 	orr	r3, r3, #131072	; 0x20000
  1370a8:	e50b3008 	str	r3, [fp, #-8]
    base->MMFR = mmfr;
  1370ac:	e51b3010 	ldr	r3, [fp, #-16]
  1370b0:	e51b2008 	ldr	r2, [fp, #-8]
  1370b4:	e5832040 	str	r2, [r3, #64]	; 0x40
}
  1370b8:	e320f000 	nop	{0}
  1370bc:	e28bd000 	add	sp, fp, #0
  1370c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1370c4:	e12fff1e 	bx	lr

001370c8 <ENET_StartExtC45SMIRead>:

void ENET_StartExtC45SMIRead(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg)
{
  1370c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1370cc:	e28db000 	add	fp, sp, #0
  1370d0:	e24dd01c 	sub	sp, sp, #28
  1370d4:	e50b0010 	str	r0, [fp, #-16]
  1370d8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1370dc:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    uint32_t mmfr = 0;
  1370e0:	e3a03000 	mov	r3, #0
  1370e4:	e50b3008 	str	r3, [fp, #-8]

    /* Parse the address from the input register. */
    uint16_t devAddr = (phyReg >> ENET_MMFR_TA_SHIFT) & 0x1FU;
  1370e8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1370ec:	e1a03823 	lsr	r3, r3, #16
  1370f0:	e6ff3073 	uxth	r3, r3
  1370f4:	e203301f 	and	r3, r3, #31
  1370f8:	e14b30ba 	strh	r3, [fp, #-10]
    uint16_t regAddr = (uint16_t)(phyReg & 0xFFFFU);
  1370fc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137100:	e14b30bc 	strh	r3, [fp, #-12]

    /* Address write firstly. */
    mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiAddrWrite_C45) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(devAddr) |
  137104:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137108:	e1a03b83 	lsl	r3, r3, #23
  13710c:	e203253e 	and	r2, r3, #260046848	; 0xf800000
  137110:	e15b30ba 	ldrh	r3, [fp, #-10]
  137114:	e1a03903 	lsl	r3, r3, #18
  137118:	e203371f 	and	r3, r3, #8126464	; 0x7c0000
  13711c:	e1822003 	orr	r2, r2, r3
           ENET_MMFR_TA(2) | ENET_MMFR_DATA(regAddr);
  137120:	e15b30bc 	ldrh	r3, [fp, #-12]
  137124:	e1823003 	orr	r3, r2, r3
    mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiAddrWrite_C45) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(devAddr) |
  137128:	e3833802 	orr	r3, r3, #131072	; 0x20000
  13712c:	e50b3008 	str	r3, [fp, #-8]
    base->MMFR = mmfr;
  137130:	e51b3010 	ldr	r3, [fp, #-16]
  137134:	e51b2008 	ldr	r2, [fp, #-8]
  137138:	e5832040 	str	r2, [r3, #64]	; 0x40

    /* Build MII read command. */
    mmfr = ENET_MMFR_ST(0) | ENET_MMFR_OP(kENET_MiiReadFrame_C45) | ENET_MMFR_PA(phyAddr) | ENET_MMFR_RA(devAddr) |
  13713c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137140:	e1a03b83 	lsl	r3, r3, #23
  137144:	e203253e 	and	r2, r3, #260046848	; 0xf800000
  137148:	e15b30ba 	ldrh	r3, [fp, #-10]
  13714c:	e1a03903 	lsl	r3, r3, #18
  137150:	e203371f 	and	r3, r3, #8126464	; 0x7c0000
  137154:	e1823003 	orr	r3, r2, r3
  137158:	e3833203 	orr	r3, r3, #805306368	; 0x30000000
  13715c:	e3833802 	orr	r3, r3, #131072	; 0x20000
  137160:	e50b3008 	str	r3, [fp, #-8]
           ENET_MMFR_TA(2);
    base->MMFR = mmfr;
  137164:	e51b3010 	ldr	r3, [fp, #-16]
  137168:	e51b2008 	ldr	r2, [fp, #-8]
  13716c:	e5832040 	str	r2, [r3, #64]	; 0x40
}
  137170:	e320f000 	nop	{0}
  137174:	e28bd000 	add	sp, fp, #0
  137178:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  13717c:	e12fff1e 	bx	lr

00137180 <ENET_GetRxErrBeforeReadFrame>:
#endif /* FSL_FEATURE_ENET_HAS_EXTEND_MDIO */

void ENET_GetRxErrBeforeReadFrame(enet_handle_t *handle, enet_data_error_stats_t *eErrorStatic)
{
  137180:	e92d4800 	push	{fp, lr}
  137184:	e28db004 	add	fp, sp, #4
  137188:	e24dd010 	sub	sp, sp, #16
  13718c:	e50b0010 	str	r0, [fp, #-16]
  137190:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    RT_ASSERT(handle);
  137194:	e51b3010 	ldr	r3, [fp, #-16]
  137198:	e3530000 	cmp	r3, #0
  13719c:	1a000005 	bne	1371b8 <ENET_GetRxErrBeforeReadFrame+0x38>
  1371a0:	e3a02fae 	mov	r2, #696	; 0x2b8
  1371a4:	e30a1518 	movw	r1, #42264	; 0xa518
  1371a8:	e3401014 	movt	r1, #20
  1371ac:	e30a0134 	movw	r0, #41268	; 0xa134
  1371b0:	e3400014 	movt	r0, #20
  1371b4:	ebff30f7 	bl	103598 <rt_assert_handler>
    RT_ASSERT(handle->rxBdCurrent);
  1371b8:	e51b3010 	ldr	r3, [fp, #-16]
  1371bc:	e5933004 	ldr	r3, [r3, #4]
  1371c0:	e3530000 	cmp	r3, #0
  1371c4:	1a000005 	bne	1371e0 <ENET_GetRxErrBeforeReadFrame+0x60>
  1371c8:	e30022b9 	movw	r2, #697	; 0x2b9
  1371cc:	e30a1518 	movw	r1, #42264	; 0xa518
  1371d0:	e3401014 	movt	r1, #20
  1371d4:	e30a0378 	movw	r0, #41848	; 0xa378
  1371d8:	e3400014 	movt	r0, #20
  1371dc:	ebff30ed 	bl	103598 <rt_assert_handler>
    RT_ASSERT(eErrorStatic);
  1371e0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1371e4:	e3530000 	cmp	r3, #0
  1371e8:	1a000005 	bne	137204 <ENET_GetRxErrBeforeReadFrame+0x84>
  1371ec:	e30022ba 	movw	r2, #698	; 0x2ba
  1371f0:	e30a1518 	movw	r1, #42264	; 0xa518
  1371f4:	e3401014 	movt	r1, #20
  1371f8:	e30a038c 	movw	r0, #41868	; 0xa38c
  1371fc:	e3400014 	movt	r0, #20
  137200:	ebff30e4 	bl	103598 <rt_assert_handler>

    uint16_t control = 0;
  137204:	e3a03000 	mov	r3, #0
  137208:	e14b30ba 	strh	r3, [fp, #-10]
    volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent;
  13720c:	e51b3010 	ldr	r3, [fp, #-16]
  137210:	e5933004 	ldr	r3, [r3, #4]
  137214:	e50b3008 	str	r3, [fp, #-8]
        /* Add the cache invalidate maintain. */
        // rt_hw_cpu_dcache_invalidate((void *)curBuffDescrip, sizeof(enet_rx_bd_struct_t));
        // ueth_dcache_invalid((void *)curBuffDescrip, sizeof(enet_rx_bd_struct_t));

        /* The last buffer descriptor of a frame. */
        if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
  137218:	e51b3008 	ldr	r3, [fp, #-8]
  13721c:	e1d330b2 	ldrh	r3, [r3, #2]
  137220:	e6ff3073 	uxth	r3, r3
  137224:	e2033b02 	and	r3, r3, #2048	; 0x800
  137228:	e3530000 	cmp	r3, #0
  13722c:	0a000030 	beq	1372f4 <ENET_GetRxErrBeforeReadFrame+0x174>
        {
            control = curBuffDescrip->control;
  137230:	e51b3008 	ldr	r3, [fp, #-8]
  137234:	e1d330b2 	ldrh	r3, [r3, #2]
  137238:	e14b30ba 	strh	r3, [fp, #-10]
            if (control & ENET_BUFFDESCRIPTOR_RX_TRUNC_MASK)
  13723c:	e15b30ba 	ldrh	r3, [fp, #-10]
  137240:	e2033001 	and	r3, r3, #1
  137244:	e3530000 	cmp	r3, #0
  137248:	0a000004 	beq	137260 <ENET_GetRxErrBeforeReadFrame+0xe0>
            {
                /* The receive truncate error. */
                eErrorStatic->statsRxTruncateErr++;
  13724c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137250:	e5933010 	ldr	r3, [r3, #16]
  137254:	e2832001 	add	r2, r3, #1
  137258:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13725c:	e5832010 	str	r2, [r3, #16]
            }
            if (control & ENET_BUFFDESCRIPTOR_RX_OVERRUN_MASK)
  137260:	e15b30ba 	ldrh	r3, [fp, #-10]
  137264:	e2033002 	and	r3, r3, #2
  137268:	e3530000 	cmp	r3, #0
  13726c:	0a000004 	beq	137284 <ENET_GetRxErrBeforeReadFrame+0x104>
            {
                /* The receive over run error. */
                eErrorStatic->statsRxOverRunErr++;
  137270:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137274:	e593300c 	ldr	r3, [r3, #12]
  137278:	e2832001 	add	r2, r3, #1
  13727c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137280:	e583200c 	str	r2, [r3, #12]
            }
            if (control & ENET_BUFFDESCRIPTOR_RX_LENVLIOLATE_MASK)
  137284:	e15b30ba 	ldrh	r3, [fp, #-10]
  137288:	e2033020 	and	r3, r3, #32
  13728c:	e3530000 	cmp	r3, #0
  137290:	0a000004 	beq	1372a8 <ENET_GetRxErrBeforeReadFrame+0x128>
            {
                /* The receive length violation error. */
                eErrorStatic->statsRxLenGreaterErr++;
  137294:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137298:	e5933000 	ldr	r3, [r3]
  13729c:	e2832001 	add	r2, r3, #1
  1372a0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1372a4:	e5832000 	str	r2, [r3]
            }
            if (control & ENET_BUFFDESCRIPTOR_RX_NOOCTET_MASK)
  1372a8:	e15b30ba 	ldrh	r3, [fp, #-10]
  1372ac:	e2033010 	and	r3, r3, #16
  1372b0:	e3530000 	cmp	r3, #0
  1372b4:	0a000004 	beq	1372cc <ENET_GetRxErrBeforeReadFrame+0x14c>
            {
                /* The receive alignment error. */
                eErrorStatic->statsRxAlignErr++;
  1372b8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1372bc:	e5933004 	ldr	r3, [r3, #4]
  1372c0:	e2832001 	add	r2, r3, #1
  1372c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1372c8:	e5832004 	str	r2, [r3, #4]
            }
            if (control & ENET_BUFFDESCRIPTOR_RX_CRC_MASK)
  1372cc:	e15b30ba 	ldrh	r3, [fp, #-10]
  1372d0:	e2033004 	and	r3, r3, #4
  1372d4:	e3530000 	cmp	r3, #0
  1372d8:	0a000018 	beq	137340 <ENET_GetRxErrBeforeReadFrame+0x1c0>
            {
                /* The receive CRC error. */
                eErrorStatic->statsRxFcsErr++;
  1372dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1372e0:	e5933008 	ldr	r3, [r3, #8]
  1372e4:	e2832001 	add	r2, r3, #1
  1372e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1372ec:	e5832008 	str	r2, [r3, #8]
            }
            break;
  1372f0:	ea000012 	b	137340 <ENET_GetRxErrBeforeReadFrame+0x1c0>
        }

        /* Increase the buffer descriptor, if it is the last one, increase to first one of the ring buffer. */
        if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
  1372f4:	e51b3008 	ldr	r3, [fp, #-8]
  1372f8:	e1d330b2 	ldrh	r3, [r3, #2]
  1372fc:	e6ff3073 	uxth	r3, r3
  137300:	e2033a02 	and	r3, r3, #8192	; 0x2000
  137304:	e3530000 	cmp	r3, #0
  137308:	0a000003 	beq	13731c <ENET_GetRxErrBeforeReadFrame+0x19c>
        {
            curBuffDescrip = handle->rxBdBase;
  13730c:	e51b3010 	ldr	r3, [fp, #-16]
  137310:	e5933000 	ldr	r3, [r3]
  137314:	e50b3008 	str	r3, [fp, #-8]
  137318:	ea000002 	b	137328 <ENET_GetRxErrBeforeReadFrame+0x1a8>
        }
        else
        {
            curBuffDescrip++;
  13731c:	e51b3008 	ldr	r3, [fp, #-8]
  137320:	e2833008 	add	r3, r3, #8
  137324:	e50b3008 	str	r3, [fp, #-8]
        }

    } while (curBuffDescrip != handle->rxBdCurrent);
  137328:	e51b3010 	ldr	r3, [fp, #-16]
  13732c:	e5933004 	ldr	r3, [r3, #4]
  137330:	e51b2008 	ldr	r2, [fp, #-8]
  137334:	e1520003 	cmp	r2, r3
  137338:	1affffb6 	bne	137218 <ENET_GetRxErrBeforeReadFrame+0x98>
}
  13733c:	ea000000 	b	137344 <ENET_GetRxErrBeforeReadFrame+0x1c4>
            break;
  137340:	e320f000 	nop	{0}
}
  137344:	e320f000 	nop	{0}
  137348:	e24bd004 	sub	sp, fp, #4
  13734c:	e8bd8800 	pop	{fp, pc}

00137350 <ENET_ReadFrame>:

status_t ENET_ReadFrame(ENET_Type *base,enet_handle_t *handle,const enet_config_t *config,uint8_t *data,uint16_t *length)
{
  137350:	e92d4800 	push	{fp, lr}
  137354:	e28db004 	add	fp, sp, #4
  137358:	e24dd018 	sub	sp, sp, #24
  13735c:	e50b0010 	str	r0, [fp, #-16]
  137360:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  137364:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  137368:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(handle);
  13736c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137370:	e3530000 	cmp	r3, #0
  137374:	1a000005 	bne	137390 <ENET_ReadFrame+0x40>
  137378:	e3a02fbd 	mov	r2, #756	; 0x2f4
  13737c:	e30a1538 	movw	r1, #42296	; 0xa538
  137380:	e3401014 	movt	r1, #20
  137384:	e30a0134 	movw	r0, #41268	; 0xa134
  137388:	e3400014 	movt	r0, #20
  13738c:	ebff3081 	bl	103598 <rt_assert_handler>
    RT_ASSERT(handle->rxBdCurrent);
  137390:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137394:	e5933004 	ldr	r3, [r3, #4]
  137398:	e3530000 	cmp	r3, #0
  13739c:	1a000005 	bne	1373b8 <ENET_ReadFrame+0x68>
  1373a0:	e30022f5 	movw	r2, #757	; 0x2f5
  1373a4:	e30a1538 	movw	r1, #42296	; 0xa538
  1373a8:	e3401014 	movt	r1, #20
  1373ac:	e30a0378 	movw	r0, #41848	; 0xa378
  1373b0:	e3400014 	movt	r0, #20
  1373b4:	ebff3077 	bl	103598 <rt_assert_handler>
    RT_ASSERT(length);
  1373b8:	e59b3004 	ldr	r3, [fp, #4]
  1373bc:	e3530000 	cmp	r3, #0
  1373c0:	1a000005 	bne	1373dc <ENET_ReadFrame+0x8c>
  1373c4:	e30022f6 	movw	r2, #758	; 0x2f6
  1373c8:	e30a1538 	movw	r1, #42296	; 0xa538
  1373cc:	e3401014 	movt	r1, #20
  1373d0:	e30a039c 	movw	r0, #41884	; 0xa39c
  1373d4:	e3400014 	movt	r0, #20
  1373d8:	ebff306e 	bl	103598 <rt_assert_handler>

    /* Reset the length to zero. */
    *length = 0;
  1373dc:	e59b3004 	ldr	r3, [fp, #4]
  1373e0:	e3a02000 	mov	r2, #0
  1373e4:	e1c320b0 	strh	r2, [r3]

    uint16_t validLastMask = ENET_BUFFDESCRIPTOR_RX_LAST_MASK | ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
  1373e8:	e3a03b22 	mov	r3, #34816	; 0x8800
  1373ec:	e14b30b6 	strh	r3, [fp, #-6]
    volatile enet_rx_bd_struct_t *curBuffDescrip = handle->rxBdCurrent;
  1373f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1373f4:	e5933004 	ldr	r3, [r3, #4]
  1373f8:	e50b300c 	str	r3, [fp, #-12]

    // rt_hw_cpu_dcache_invalidate((void *)physical_to_virtual(curBuffDescrip->buffer), handle->rxBuffSizeAlign);
    // ueth_dcache_invalid((void *)(curBuffDescrip->buffer_vaddr), handle->rxBuffSizeAlign);
    /* Check the current buffer descriptor's empty flag.  if empty means there is no frame received. */
    if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK)
  1373fc:	e51b300c 	ldr	r3, [fp, #-12]
  137400:	e1d330b2 	ldrh	r3, [r3, #2]
  137404:	e6ff3073 	uxth	r3, r3
  137408:	e6bf3073 	sxth	r3, r3
  13740c:	e3530000 	cmp	r3, #0
  137410:	aa000001 	bge	13741c <ENET_ReadFrame+0xcc>
    {
        return kStatus_ENET_RxFrameEmpty;
  137414:	e3003fa2 	movw	r3, #4002	; 0xfa2
  137418:	ea00005c 	b	137590 <ENET_ReadFrame+0x240>
    }
    else
    {
        if ((curBuffDescrip->control & validLastMask) == ENET_BUFFDESCRIPTOR_RX_LAST_MASK)
  13741c:	e51b300c 	ldr	r3, [fp, #-12]
  137420:	e1d330b2 	ldrh	r3, [r3, #2]
  137424:	e6ff2073 	uxth	r2, r3
  137428:	e15b30b6 	ldrh	r3, [fp, #-6]
  13742c:	e0033002 	and	r3, r3, r2
  137430:	e6ff3073 	uxth	r3, r3
  137434:	e3530b02 	cmp	r3, #2048	; 0x800
  137438:	1a00003a 	bne	137528 <ENET_ReadFrame+0x1d8>
        {
            if(curBuffDescrip->length <= config->rxMaxFrameLen)
  13743c:	e51b300c 	ldr	r3, [fp, #-12]
  137440:	e1d330b0 	ldrh	r3, [r3]
  137444:	e6ff2073 	uxth	r2, r3
  137448:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  13744c:	e1d330b8 	ldrh	r3, [r3, #8]
  137450:	e1520003 	cmp	r2, r3
  137454:	8a000018 	bhi	1374bc <ENET_ReadFrame+0x16c>
            {
                *length = curBuffDescrip->length;
  137458:	e51b300c 	ldr	r3, [fp, #-12]
  13745c:	e1d330b0 	ldrh	r3, [r3]
  137460:	e6ff2073 	uxth	r2, r3
  137464:	e59b3004 	ldr	r3, [fp, #4]
  137468:	e1c320b0 	strh	r2, [r3]
                rt_memcpy(data, buffer_vaddr_rx[curBuffDescrip - handle->rxBdBase], curBuffDescrip->length);
  13746c:	e51b300c 	ldr	r3, [fp, #-12]
  137470:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  137474:	e5922000 	ldr	r2, [r2]
  137478:	e0433002 	sub	r3, r3, r2
  13747c:	e1a031c3 	asr	r3, r3, #3
  137480:	e1a02003 	mov	r2, r3
  137484:	e3063a80 	movw	r3, #27264	; 0x6a80
  137488:	e3403057 	movt	r3, #87	; 0x57
  13748c:	e7931102 	ldr	r1, [r3, r2, lsl #2]
  137490:	e51b300c 	ldr	r3, [fp, #-12]
  137494:	e1d330b0 	ldrh	r3, [r3]
  137498:	e6ff3073 	uxth	r3, r3
  13749c:	e1a02003 	mov	r2, r3
  1374a0:	e51b001c 	ldr	r0, [fp, #-28]	; 0xffffffe4
  1374a4:	ebff2f95 	bl	103300 <rt_memcpy>
                /* Updates the receive buffer descriptors. */
                ENET_UpdateReadBuffers(base, handle);
  1374a8:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1374ac:	e51b0010 	ldr	r0, [fp, #-16]
  1374b0:	eb000039 	bl	13759c <ENET_UpdateReadBuffers>
                return kStatus_Success;
  1374b4:	e3a03000 	mov	r3, #0
  1374b8:	ea000034 	b	137590 <ENET_ReadFrame+0x240>
            }
            else
            {
                LOG_E("frame error0 curBuffDescrip->control 0x%04x length %d\n",curBuffDescrip->control,curBuffDescrip->length);
  1374bc:	e30a03a4 	movw	r0, #41892	; 0xa3a4
  1374c0:	e3400014 	movt	r0, #20
  1374c4:	ebff2f12 	bl	103114 <rt_kprintf>
  1374c8:	e51b300c 	ldr	r3, [fp, #-12]
  1374cc:	e1d330b2 	ldrh	r3, [r3, #2]
  1374d0:	e6ff3073 	uxth	r3, r3
  1374d4:	e1a01003 	mov	r1, r3
  1374d8:	e51b300c 	ldr	r3, [fp, #-12]
  1374dc:	e1d330b0 	ldrh	r3, [r3]
  1374e0:	e6ff3073 	uxth	r3, r3
  1374e4:	e1a02003 	mov	r2, r3
  1374e8:	e30a03b8 	movw	r0, #41912	; 0xa3b8
  1374ec:	e3400014 	movt	r0, #20
  1374f0:	ebff2f07 	bl	103114 <rt_kprintf>
  1374f4:	e30a03f0 	movw	r0, #41968	; 0xa3f0
  1374f8:	e3400014 	movt	r0, #20
  1374fc:	ebff2f04 	bl	103114 <rt_kprintf>
                *length = curBuffDescrip->length;
  137500:	e51b300c 	ldr	r3, [fp, #-12]
  137504:	e1d330b0 	ldrh	r3, [r3]
  137508:	e6ff2073 	uxth	r2, r3
  13750c:	e59b3004 	ldr	r3, [fp, #4]
  137510:	e1c320b0 	strh	r2, [r3]
                /* Updates the receive buffer descriptors. */
                ENET_UpdateReadBuffers(base, handle);
  137514:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  137518:	e51b0010 	ldr	r0, [fp, #-16]
  13751c:	eb00001e 	bl	13759c <ENET_UpdateReadBuffers>
                return kStatus_ENET_RxFrameError;
  137520:	e3a03efa 	mov	r3, #4000	; 0xfa0
  137524:	ea000019 	b	137590 <ENET_ReadFrame+0x240>
            }
        }
        else
        {
            LOG_E("frame error1 curBuffDescrip->control 0x%04x length %d\n",curBuffDescrip->control,curBuffDescrip->length);
  137528:	e30a03a4 	movw	r0, #41892	; 0xa3a4
  13752c:	e3400014 	movt	r0, #20
  137530:	ebff2ef7 	bl	103114 <rt_kprintf>
  137534:	e51b300c 	ldr	r3, [fp, #-12]
  137538:	e1d330b2 	ldrh	r3, [r3, #2]
  13753c:	e6ff3073 	uxth	r3, r3
  137540:	e1a01003 	mov	r1, r3
  137544:	e51b300c 	ldr	r3, [fp, #-12]
  137548:	e1d330b0 	ldrh	r3, [r3]
  13754c:	e6ff3073 	uxth	r3, r3
  137550:	e1a02003 	mov	r2, r3
  137554:	e30a03f8 	movw	r0, #41976	; 0xa3f8
  137558:	e3400014 	movt	r0, #20
  13755c:	ebff2eec 	bl	103114 <rt_kprintf>
  137560:	e30a03f0 	movw	r0, #41968	; 0xa3f0
  137564:	e3400014 	movt	r0, #20
  137568:	ebff2ee9 	bl	103114 <rt_kprintf>
            *length = curBuffDescrip->length;
  13756c:	e51b300c 	ldr	r3, [fp, #-12]
  137570:	e1d330b0 	ldrh	r3, [r3]
  137574:	e6ff2073 	uxth	r2, r3
  137578:	e59b3004 	ldr	r3, [fp, #4]
  13757c:	e1c320b0 	strh	r2, [r3]
            ENET_UpdateReadBuffers(base, handle);
  137580:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  137584:	e51b0010 	ldr	r0, [fp, #-16]
  137588:	eb000003 	bl	13759c <ENET_UpdateReadBuffers>
            return kStatus_ENET_RxFrameError;
  13758c:	e3a03efa 	mov	r3, #4000	; 0xfa0
        }
    }
    /* The frame is on processing - set to empty status to make application to receive it next time. */
    return kStatus_ENET_RxFrameEmpty;
}
  137590:	e1a00003 	mov	r0, r3
  137594:	e24bd004 	sub	sp, fp, #4
  137598:	e8bd8800 	pop	{fp, pc}

0013759c <ENET_UpdateReadBuffers>:

static void ENET_UpdateReadBuffers(ENET_Type *base, enet_handle_t *handle)
{
  13759c:	e92d4800 	push	{fp, lr}
  1375a0:	e28db004 	add	fp, sp, #4
  1375a4:	e24dd008 	sub	sp, sp, #8
  1375a8:	e50b0008 	str	r0, [fp, #-8]
  1375ac:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(handle);
  1375b0:	e51b300c 	ldr	r3, [fp, #-12]
  1375b4:	e3530000 	cmp	r3, #0
  1375b8:	1a000005 	bne	1375d4 <ENET_UpdateReadBuffers+0x38>
  1375bc:	e3a02fca 	mov	r2, #808	; 0x328
  1375c0:	e30a1548 	movw	r1, #42312	; 0xa548
  1375c4:	e3401014 	movt	r1, #20
  1375c8:	e30a0134 	movw	r0, #41268	; 0xa134
  1375cc:	e3400014 	movt	r0, #20
  1375d0:	ebff2ff0 	bl	103598 <rt_assert_handler>

    /* Clears status. */
    handle->rxBdCurrent->control &= ENET_BUFFDESCRIPTOR_RX_WRAP_MASK;
  1375d4:	e51b300c 	ldr	r3, [fp, #-12]
  1375d8:	e5933004 	ldr	r3, [r3, #4]
  1375dc:	e1d330b2 	ldrh	r3, [r3, #2]
  1375e0:	e6ff2073 	uxth	r2, r3
  1375e4:	e51b300c 	ldr	r3, [fp, #-12]
  1375e8:	e5933004 	ldr	r3, [r3, #4]
  1375ec:	e2022a02 	and	r2, r2, #8192	; 0x2000
  1375f0:	e6ff2072 	uxth	r2, r2
  1375f4:	e1c320b2 	strh	r2, [r3, #2]
    /* Sets the receive buffer descriptor with the empty flag. */
    handle->rxBdCurrent->control |= ENET_BUFFDESCRIPTOR_RX_EMPTY_MASK;
  1375f8:	e51b300c 	ldr	r3, [fp, #-12]
  1375fc:	e5933004 	ldr	r3, [r3, #4]
  137600:	e1d330b2 	ldrh	r3, [r3, #2]
  137604:	e6ff3073 	uxth	r3, r3
  137608:	e51b200c 	ldr	r2, [fp, #-12]
  13760c:	e5922004 	ldr	r2, [r2, #4]
  137610:	e1e03883 	mvn	r3, r3, lsl #17
  137614:	e1e038a3 	mvn	r3, r3, lsr #17
  137618:	e6ff3073 	uxth	r3, r3
  13761c:	e1c230b2 	strh	r3, [r2, #2]
    /* Increase current buffer descriptor to the next one. */
    if (handle->rxBdCurrent->control & ENET_BUFFDESCRIPTOR_RX_WRAP_MASK)
  137620:	e51b300c 	ldr	r3, [fp, #-12]
  137624:	e5933004 	ldr	r3, [r3, #4]
  137628:	e1d330b2 	ldrh	r3, [r3, #2]
  13762c:	e6ff3073 	uxth	r3, r3
  137630:	e2033a02 	and	r3, r3, #8192	; 0x2000
  137634:	e3530000 	cmp	r3, #0
  137638:	0a000004 	beq	137650 <ENET_UpdateReadBuffers+0xb4>
    {
        handle->rxBdCurrent = handle->rxBdBase;
  13763c:	e51b300c 	ldr	r3, [fp, #-12]
  137640:	e5932000 	ldr	r2, [r3]
  137644:	e51b300c 	ldr	r3, [fp, #-12]
  137648:	e5832004 	str	r2, [r3, #4]
  13764c:	ea000004 	b	137664 <ENET_UpdateReadBuffers+0xc8>
    }
    else
    {
        handle->rxBdCurrent++;
  137650:	e51b300c 	ldr	r3, [fp, #-12]
  137654:	e5933004 	ldr	r3, [r3, #4]
  137658:	e2832008 	add	r2, r3, #8
  13765c:	e51b300c 	ldr	r3, [fp, #-12]
  137660:	e5832004 	str	r2, [r3, #4]
    }
    /* Actives the receive buffer descriptor. */
    base->RDAR = ENET_RDAR_RDAR_MASK;
  137664:	e51b3008 	ldr	r3, [fp, #-8]
  137668:	e3a02401 	mov	r2, #16777216	; 0x1000000
  13766c:	e5832010 	str	r2, [r3, #16]
}
  137670:	e320f000 	nop	{0}
  137674:	e24bd004 	sub	sp, fp, #4
  137678:	e8bd8800 	pop	{fp, pc}

0013767c <ENET_SendFrame>:

status_t ENET_SendFrame(ENET_Type *base, enet_handle_t *handle, const uint8_t *data, uint16_t length,uint32_t last_flag)
{
  13767c:	e92d4800 	push	{fp, lr}
  137680:	e28db004 	add	fp, sp, #4
  137684:	e24dd018 	sub	sp, sp, #24
  137688:	e50b0010 	str	r0, [fp, #-16]
  13768c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  137690:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  137694:	e14b31ba 	strh	r3, [fp, #-26]	; 0xffffffe6
    RT_ASSERT(handle);
  137698:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13769c:	e3530000 	cmp	r3, #0
  1376a0:	1a000005 	bne	1376bc <ENET_SendFrame+0x40>
  1376a4:	e300233d 	movw	r2, #829	; 0x33d
  1376a8:	e30a1560 	movw	r1, #42336	; 0xa560
  1376ac:	e3401014 	movt	r1, #20
  1376b0:	e30a0134 	movw	r0, #41268	; 0xa134
  1376b4:	e3400014 	movt	r0, #20
  1376b8:	ebff2fb6 	bl	103598 <rt_assert_handler>
    RT_ASSERT(handle->txBdCurrent);
  1376bc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1376c0:	e593300c 	ldr	r3, [r3, #12]
  1376c4:	e3530000 	cmp	r3, #0
  1376c8:	1a000005 	bne	1376e4 <ENET_SendFrame+0x68>
  1376cc:	e300233e 	movw	r2, #830	; 0x33e
  1376d0:	e30a1560 	movw	r1, #42336	; 0xa560
  1376d4:	e3401014 	movt	r1, #20
  1376d8:	e30a0430 	movw	r0, #42032	; 0xa430
  1376dc:	e3400014 	movt	r0, #20
  1376e0:	ebff2fac 	bl	103598 <rt_assert_handler>
    RT_ASSERT(data);
  1376e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1376e8:	e3530000 	cmp	r3, #0
  1376ec:	1a000005 	bne	137708 <ENET_SendFrame+0x8c>
  1376f0:	e300233f 	movw	r2, #831	; 0x33f
  1376f4:	e30a1560 	movw	r1, #42336	; 0xa560
  1376f8:	e3401014 	movt	r1, #20
  1376fc:	e30a0444 	movw	r0, #42052	; 0xa444
  137700:	e3400014 	movt	r0, #20
  137704:	ebff2fa3 	bl	103598 <rt_assert_handler>
    RT_ASSERT(length <= ENET_FRAME_MAX_FRAMELEN);
  137708:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  13770c:	e30025ee 	movw	r2, #1518	; 0x5ee
  137710:	e1530002 	cmp	r3, r2
  137714:	9a000005 	bls	137730 <ENET_SendFrame+0xb4>
  137718:	e3a02d0d 	mov	r2, #832	; 0x340
  13771c:	e30a1560 	movw	r1, #42336	; 0xa560
  137720:	e3401014 	movt	r1, #20
  137724:	e30a044c 	movw	r0, #42060	; 0xa44c
  137728:	e3400014 	movt	r0, #20
  13772c:	ebff2f99 	bl	103598 <rt_assert_handler>

    volatile enet_tx_bd_struct_t *curBuffDescrip = handle->txBdCurrent;
  137730:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137734:	e593300c 	ldr	r3, [r3, #12]
  137738:	e50b3008 	str	r3, [fp, #-8]
    /* Check if the transmit buffer is ready. */
    if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_READY_MASK)
  13773c:	e51b3008 	ldr	r3, [fp, #-8]
  137740:	e1d330b2 	ldrh	r3, [r3, #2]
  137744:	e6ff3073 	uxth	r3, r3
  137748:	e6bf3073 	sxth	r3, r3
  13774c:	e3530000 	cmp	r3, #0
  137750:	aa000001 	bge	13775c <ENET_SendFrame+0xe0>
    {
        return kStatus_ENET_TxFrameBusy;
  137754:	e3003fa3 	movw	r3, #4003	; 0xfa3
  137758:	ea00004b 	b	13788c <ENET_SendFrame+0x210>
    }
    /* One transmit buffer is enough for one frame. */
    if (handle->txBuffSizeAlign >= length)
  13775c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137760:	e5932014 	ldr	r2, [r3, #20]
  137764:	e15b31ba 	ldrh	r3, [fp, #-26]	; 0xffffffe6
  137768:	e1520003 	cmp	r2, r3
  13776c:	3a000045 	bcc	137888 <ENET_SendFrame+0x20c>
    {
        /* Copy data to the buffer for uDMA transfer. */
        rt_memcpy(buffer_vaddr_tx[curBuffDescrip - handle->txBdBase], data, length);
  137770:	e51b3008 	ldr	r3, [fp, #-8]
  137774:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
  137778:	e5922008 	ldr	r2, [r2, #8]
  13777c:	e0433002 	sub	r3, r3, r2
  137780:	e1a031c3 	asr	r3, r3, #3
  137784:	e1a02003 	mov	r2, r3
  137788:	e3063c80 	movw	r3, #27776	; 0x6c80
  13778c:	e3403057 	movt	r3, #87	; 0x57
  137790:	e7933102 	ldr	r3, [r3, r2, lsl #2]
  137794:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
  137798:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
  13779c:	e1a00003 	mov	r0, r3
  1377a0:	ebff2ed6 	bl	103300 <rt_memcpy>
        /* Set data length. */
        curBuffDescrip->length = length;
  1377a4:	e51b3008 	ldr	r3, [fp, #-8]
  1377a8:	e15b21ba 	ldrh	r2, [fp, #-26]	; 0xffffffe6
  1377ac:	e1c320b0 	strh	r2, [r3]
        if(last_flag)
  1377b0:	e59b3004 	ldr	r3, [fp, #4]
  1377b4:	e3530000 	cmp	r3, #0
  1377b8:	0a000009 	beq	1377e4 <ENET_SendFrame+0x168>
        {
            curBuffDescrip->control |= (ENET_BUFFDESCRIPTOR_TX_READY_MASK | ENET_BUFFDESCRIPTOR_TX_LAST_MASK);
  1377bc:	e51b3008 	ldr	r3, [fp, #-8]
  1377c0:	e1d330b2 	ldrh	r3, [r3, #2]
  1377c4:	e6ff2073 	uxth	r2, r3
  1377c8:	e3a03b22 	mov	r3, #34816	; 0x8800
  1377cc:	e34f3fff 	movt	r3, #65535	; 0xffff
  1377d0:	e1823003 	orr	r3, r2, r3
  1377d4:	e6ff2073 	uxth	r2, r3
  1377d8:	e51b3008 	ldr	r3, [fp, #-8]
  1377dc:	e1c320b2 	strh	r2, [r3, #2]
  1377e0:	ea00000e 	b	137820 <ENET_SendFrame+0x1a4>
        }
        else
        {
            curBuffDescrip->control &= ~ENET_BUFFDESCRIPTOR_TX_LAST_MASK;
  1377e4:	e51b3008 	ldr	r3, [fp, #-8]
  1377e8:	e1d330b2 	ldrh	r3, [r3, #2]
  1377ec:	e6ff3073 	uxth	r3, r3
  1377f0:	e3c33b02 	bic	r3, r3, #2048	; 0x800
  1377f4:	e6ff2073 	uxth	r2, r3
  1377f8:	e51b3008 	ldr	r3, [fp, #-8]
  1377fc:	e1c320b2 	strh	r2, [r3, #2]
            curBuffDescrip->control |= ENET_BUFFDESCRIPTOR_TX_READY_MASK;
  137800:	e51b3008 	ldr	r3, [fp, #-8]
  137804:	e1d330b2 	ldrh	r3, [r3, #2]
  137808:	e6ff3073 	uxth	r3, r3
  13780c:	e1e03883 	mvn	r3, r3, lsl #17
  137810:	e1e038a3 	mvn	r3, r3, lsr #17
  137814:	e6ff2073 	uxth	r2, r3
  137818:	e51b3008 	ldr	r3, [fp, #-8]
  13781c:	e1c320b2 	strh	r2, [r3, #2]

        // rt_hw_cpu_dcache_clean((void *)physical_to_virtual(curBuffDescrip->buffer),length);
        // ueth_dcache_clean(curBuffDescrip->buffer_vaddr, length);
        /* Active the transmit buffer descriptor. */

        base->TDAR = ENET_TDAR_TDAR_MASK;
  137820:	e51b3010 	ldr	r3, [fp, #-16]
  137824:	e3a02401 	mov	r2, #16777216	; 0x1000000
  137828:	e5832014 	str	r2, [r3, #20]
        /* Increase the buffer descriptor address. */
        while((base->TDAR != 0))
  13782c:	e320f000 	nop	{0}
  137830:	e51b3010 	ldr	r3, [fp, #-16]
  137834:	e5933014 	ldr	r3, [r3, #20]
  137838:	e3530000 	cmp	r3, #0
  13783c:	1afffffb 	bne	137830 <ENET_SendFrame+0x1b4>
        {
        }
        if (curBuffDescrip->control & ENET_BUFFDESCRIPTOR_TX_WRAP_MASK)
  137840:	e51b3008 	ldr	r3, [fp, #-8]
  137844:	e1d330b2 	ldrh	r3, [r3, #2]
  137848:	e6ff3073 	uxth	r3, r3
  13784c:	e2033a02 	and	r3, r3, #8192	; 0x2000
  137850:	e3530000 	cmp	r3, #0
  137854:	0a000004 	beq	13786c <ENET_SendFrame+0x1f0>
        {
            handle->txBdCurrent = handle->txBdBase;
  137858:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13785c:	e5932008 	ldr	r2, [r3, #8]
  137860:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137864:	e583200c 	str	r2, [r3, #12]
  137868:	ea000004 	b	137880 <ENET_SendFrame+0x204>
        }
        else
        {
            handle->txBdCurrent++;
  13786c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  137870:	e593300c 	ldr	r3, [r3, #12]
  137874:	e2832008 	add	r2, r3, #8
  137878:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  13787c:	e583200c 	str	r2, [r3, #12]
        }
        return kStatus_Success;
  137880:	e3a03000 	mov	r3, #0
  137884:	ea000000 	b	13788c <ENET_SendFrame+0x210>
    }
    else
    {
        return kStatus_ENET_RxFrameError;
  137888:	e3a03efa 	mov	r3, #4000	; 0xfa0
    }
}
  13788c:	e1a00003 	mov	r0, r3
  137890:	e24bd004 	sub	sp, fp, #4
  137894:	e8bd8800 	pop	{fp, pc}

00137898 <ENET_AddMulticastGroup>:

void ENET_AddMulticastGroup(ENET_Type *base, uint8_t *address)
{
  137898:	e92d4800 	push	{fp, lr}
  13789c:	e28db004 	add	fp, sp, #4
  1378a0:	e24dd018 	sub	sp, sp, #24
  1378a4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1378a8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(address);
  1378ac:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1378b0:	e3530000 	cmp	r3, #0
  1378b4:	1a000005 	bne	1378d0 <ENET_AddMulticastGroup+0x38>
  1378b8:	e3a02fdd 	mov	r2, #884	; 0x374
  1378bc:	e30a1570 	movw	r1, #42352	; 0xa570
  1378c0:	e3401014 	movt	r1, #20
  1378c4:	e30a0470 	movw	r0, #42096	; 0xa470
  1378c8:	e3400014 	movt	r0, #20
  1378cc:	ebff2f31 	bl	103598 <rt_assert_handler>

    uint32_t crc = 0xFFFFFFFFU;
  1378d0:	e3e03000 	mvn	r3, #0
  1378d4:	e50b3008 	str	r3, [fp, #-8]
    uint32_t count1 = 0;
  1378d8:	e3a03000 	mov	r3, #0
  1378dc:	e50b300c 	str	r3, [fp, #-12]
    uint32_t count2 = 0;
  1378e0:	e3a03000 	mov	r3, #0
  1378e4:	e50b3010 	str	r3, [fp, #-16]

    /* Calculates the CRC-32 polynomial on the multicast group address. */
    for (count1 = 0; count1 < ENET_FRAME_MACLEN; count1++)
  1378e8:	e3a03000 	mov	r3, #0
  1378ec:	e50b300c 	str	r3, [fp, #-12]
  1378f0:	ea000028 	b	137998 <ENET_AddMulticastGroup+0x100>
    {
        uint8_t c = address[count1];
  1378f4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  1378f8:	e51b300c 	ldr	r3, [fp, #-12]
  1378fc:	e0823003 	add	r3, r2, r3
  137900:	e5d33000 	ldrb	r3, [r3]
  137904:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
        for (count2 = 0; count2 < 0x08U; count2++)
  137908:	e3a03000 	mov	r3, #0
  13790c:	e50b3010 	str	r3, [fp, #-16]
  137910:	ea00001a 	b	137980 <ENET_AddMulticastGroup+0xe8>
        {
            if ((c ^ crc) & 1U)
  137914:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  137918:	e51b3008 	ldr	r3, [fp, #-8]
  13791c:	e0233002 	eor	r3, r3, r2
  137920:	e2033001 	and	r3, r3, #1
  137924:	e3530000 	cmp	r3, #0
  137928:	0a00000b 	beq	13795c <ENET_AddMulticastGroup+0xc4>
            {
                crc >>= 1U;
  13792c:	e51b3008 	ldr	r3, [fp, #-8]
  137930:	e1a030a3 	lsr	r3, r3, #1
  137934:	e50b3008 	str	r3, [fp, #-8]
                c >>= 1U;
  137938:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  13793c:	e1a030a3 	lsr	r3, r3, #1
  137940:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                crc ^= 0xEDB88320U;
  137944:	e51b2008 	ldr	r2, [fp, #-8]
  137948:	e3083320 	movw	r3, #33568	; 0x8320
  13794c:	e34e3db8 	movt	r3, #60856	; 0xedb8
  137950:	e0233002 	eor	r3, r3, r2
  137954:	e50b3008 	str	r3, [fp, #-8]
  137958:	ea000005 	b	137974 <ENET_AddMulticastGroup+0xdc>
            }
            else
            {
                crc >>= 1U;
  13795c:	e51b3008 	ldr	r3, [fp, #-8]
  137960:	e1a030a3 	lsr	r3, r3, #1
  137964:	e50b3008 	str	r3, [fp, #-8]
                c >>= 1U;
  137968:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  13796c:	e1a030a3 	lsr	r3, r3, #1
  137970:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
        for (count2 = 0; count2 < 0x08U; count2++)
  137974:	e51b3010 	ldr	r3, [fp, #-16]
  137978:	e2833001 	add	r3, r3, #1
  13797c:	e50b3010 	str	r3, [fp, #-16]
  137980:	e51b3010 	ldr	r3, [fp, #-16]
  137984:	e3530007 	cmp	r3, #7
  137988:	9affffe1 	bls	137914 <ENET_AddMulticastGroup+0x7c>
    for (count1 = 0; count1 < ENET_FRAME_MACLEN; count1++)
  13798c:	e51b300c 	ldr	r3, [fp, #-12]
  137990:	e2833001 	add	r3, r3, #1
  137994:	e50b300c 	str	r3, [fp, #-12]
  137998:	e51b300c 	ldr	r3, [fp, #-12]
  13799c:	e3530005 	cmp	r3, #5
  1379a0:	9affffd3 	bls	1378f4 <ENET_AddMulticastGroup+0x5c>
            }
        }
    }

    /* Enable a multicast group address. */
    if (!((crc >> 0x1FU) & 1U))
  1379a4:	e51b3008 	ldr	r3, [fp, #-8]
  1379a8:	e3530000 	cmp	r3, #0
  1379ac:	ba00000a 	blt	1379dc <ENET_AddMulticastGroup+0x144>
    {
        base->GALR |= 1U << ((crc >> 0x1AU) & 0x1FU);
  1379b0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1379b4:	e5932124 	ldr	r2, [r3, #292]	; 0x124
  1379b8:	e51b3008 	ldr	r3, [fp, #-8]
  1379bc:	e1a03d23 	lsr	r3, r3, #26
  1379c0:	e203301f 	and	r3, r3, #31
  1379c4:	e3a01001 	mov	r1, #1
  1379c8:	e1a03311 	lsl	r3, r1, r3
  1379cc:	e1822003 	orr	r2, r2, r3
  1379d0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1379d4:	e5832124 	str	r2, [r3, #292]	; 0x124
    }
    else
    {
        base->GAUR |= 1U << ((crc >> 0x1AU) & 0x1FU);
    }
}
  1379d8:	ea000009 	b	137a04 <ENET_AddMulticastGroup+0x16c>
        base->GAUR |= 1U << ((crc >> 0x1AU) & 0x1FU);
  1379dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1379e0:	e5932120 	ldr	r2, [r3, #288]	; 0x120
  1379e4:	e51b3008 	ldr	r3, [fp, #-8]
  1379e8:	e1a03d23 	lsr	r3, r3, #26
  1379ec:	e203301f 	and	r3, r3, #31
  1379f0:	e3a01001 	mov	r1, #1
  1379f4:	e1a03311 	lsl	r3, r1, r3
  1379f8:	e1822003 	orr	r2, r2, r3
  1379fc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137a00:	e5832120 	str	r2, [r3, #288]	; 0x120
}
  137a04:	e320f000 	nop	{0}
  137a08:	e24bd004 	sub	sp, fp, #4
  137a0c:	e8bd8800 	pop	{fp, pc}

00137a10 <ENET_LeaveMulticastGroup>:

void ENET_LeaveMulticastGroup(ENET_Type *base, uint8_t *address)
{
  137a10:	e92d4800 	push	{fp, lr}
  137a14:	e28db004 	add	fp, sp, #4
  137a18:	e24dd018 	sub	sp, sp, #24
  137a1c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  137a20:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(address);
  137a24:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  137a28:	e3530000 	cmp	r3, #0
  137a2c:	1a000005 	bne	137a48 <ENET_LeaveMulticastGroup+0x38>
  137a30:	e300239b 	movw	r2, #923	; 0x39b
  137a34:	e30a1588 	movw	r1, #42376	; 0xa588
  137a38:	e3401014 	movt	r1, #20
  137a3c:	e30a0470 	movw	r0, #42096	; 0xa470
  137a40:	e3400014 	movt	r0, #20
  137a44:	ebff2ed3 	bl	103598 <rt_assert_handler>

    uint32_t crc = 0xFFFFFFFFU;
  137a48:	e3e03000 	mvn	r3, #0
  137a4c:	e50b3008 	str	r3, [fp, #-8]
    uint32_t count1 = 0;
  137a50:	e3a03000 	mov	r3, #0
  137a54:	e50b300c 	str	r3, [fp, #-12]
    uint32_t count2 = 0;
  137a58:	e3a03000 	mov	r3, #0
  137a5c:	e50b3010 	str	r3, [fp, #-16]

    /* Calculates the CRC-32 polynomial on the multicast group address. */
    for (count1 = 0; count1 < ENET_FRAME_MACLEN; count1++)
  137a60:	e3a03000 	mov	r3, #0
  137a64:	e50b300c 	str	r3, [fp, #-12]
  137a68:	ea000028 	b	137b10 <ENET_LeaveMulticastGroup+0x100>
    {
        uint8_t c = address[count1];
  137a6c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
  137a70:	e51b300c 	ldr	r3, [fp, #-12]
  137a74:	e0823003 	add	r3, r2, r3
  137a78:	e5d33000 	ldrb	r3, [r3]
  137a7c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
        for (count2 = 0; count2 < 0x08U; count2++)
  137a80:	e3a03000 	mov	r3, #0
  137a84:	e50b3010 	str	r3, [fp, #-16]
  137a88:	ea00001a 	b	137af8 <ENET_LeaveMulticastGroup+0xe8>
        {
            if ((c ^ crc) & 1U)
  137a8c:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
  137a90:	e51b3008 	ldr	r3, [fp, #-8]
  137a94:	e0233002 	eor	r3, r3, r2
  137a98:	e2033001 	and	r3, r3, #1
  137a9c:	e3530000 	cmp	r3, #0
  137aa0:	0a00000b 	beq	137ad4 <ENET_LeaveMulticastGroup+0xc4>
            {
                crc >>= 1U;
  137aa4:	e51b3008 	ldr	r3, [fp, #-8]
  137aa8:	e1a030a3 	lsr	r3, r3, #1
  137aac:	e50b3008 	str	r3, [fp, #-8]
                c >>= 1U;
  137ab0:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  137ab4:	e1a030a3 	lsr	r3, r3, #1
  137ab8:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
                crc ^= 0xEDB88320U;
  137abc:	e51b2008 	ldr	r2, [fp, #-8]
  137ac0:	e3083320 	movw	r3, #33568	; 0x8320
  137ac4:	e34e3db8 	movt	r3, #60856	; 0xedb8
  137ac8:	e0233002 	eor	r3, r3, r2
  137acc:	e50b3008 	str	r3, [fp, #-8]
  137ad0:	ea000005 	b	137aec <ENET_LeaveMulticastGroup+0xdc>
            }
            else
            {
                crc >>= 1U;
  137ad4:	e51b3008 	ldr	r3, [fp, #-8]
  137ad8:	e1a030a3 	lsr	r3, r3, #1
  137adc:	e50b3008 	str	r3, [fp, #-8]
                c >>= 1U;
  137ae0:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
  137ae4:	e1a030a3 	lsr	r3, r3, #1
  137ae8:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
        for (count2 = 0; count2 < 0x08U; count2++)
  137aec:	e51b3010 	ldr	r3, [fp, #-16]
  137af0:	e2833001 	add	r3, r3, #1
  137af4:	e50b3010 	str	r3, [fp, #-16]
  137af8:	e51b3010 	ldr	r3, [fp, #-16]
  137afc:	e3530007 	cmp	r3, #7
  137b00:	9affffe1 	bls	137a8c <ENET_LeaveMulticastGroup+0x7c>
    for (count1 = 0; count1 < ENET_FRAME_MACLEN; count1++)
  137b04:	e51b300c 	ldr	r3, [fp, #-12]
  137b08:	e2833001 	add	r3, r3, #1
  137b0c:	e50b300c 	str	r3, [fp, #-12]
  137b10:	e51b300c 	ldr	r3, [fp, #-12]
  137b14:	e3530005 	cmp	r3, #5
  137b18:	9affffd3 	bls	137a6c <ENET_LeaveMulticastGroup+0x5c>
            }
        }
    }

    /* Set the hash table. */
    if (!((crc >> 0x1FU) & 1U))
  137b1c:	e51b3008 	ldr	r3, [fp, #-8]
  137b20:	e3530000 	cmp	r3, #0
  137b24:	ba00000b 	blt	137b58 <ENET_LeaveMulticastGroup+0x148>
    {
        base->GALR &= ~(1U << ((crc >> 0x1AU) & 0x1FU));
  137b28:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137b2c:	e5932124 	ldr	r2, [r3, #292]	; 0x124
  137b30:	e51b3008 	ldr	r3, [fp, #-8]
  137b34:	e1a03d23 	lsr	r3, r3, #26
  137b38:	e203301f 	and	r3, r3, #31
  137b3c:	e3a01001 	mov	r1, #1
  137b40:	e1a03311 	lsl	r3, r1, r3
  137b44:	e1e03003 	mvn	r3, r3
  137b48:	e0022003 	and	r2, r2, r3
  137b4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137b50:	e5832124 	str	r2, [r3, #292]	; 0x124
    }
    else
    {
        base->GAUR &= ~(1U << ((crc >> 0x1AU) & 0x1FU));
    }
}
  137b54:	ea00000a 	b	137b84 <ENET_LeaveMulticastGroup+0x174>
        base->GAUR &= ~(1U << ((crc >> 0x1AU) & 0x1FU));
  137b58:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137b5c:	e5932120 	ldr	r2, [r3, #288]	; 0x120
  137b60:	e51b3008 	ldr	r3, [fp, #-8]
  137b64:	e1a03d23 	lsr	r3, r3, #26
  137b68:	e203301f 	and	r3, r3, #31
  137b6c:	e3a01001 	mov	r1, #1
  137b70:	e1a03311 	lsl	r3, r1, r3
  137b74:	e1e03003 	mvn	r3, r3
  137b78:	e0022003 	and	r2, r2, r3
  137b7c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137b80:	e5832120 	str	r2, [r3, #288]	; 0x120
}
  137b84:	e320f000 	nop	{0}
  137b88:	e24bd004 	sub	sp, fp, #4
  137b8c:	e8bd8800 	pop	{fp, pc}

00137b90 <ENET_TransmitIRQHandler>:
void tx_enet_callback(void *base);
void ENET_TransmitIRQHandler(ENET_Type *base, enet_handle_t *handle)
{
  137b90:	e92d4800 	push	{fp, lr}
  137b94:	e28db004 	add	fp, sp, #4
  137b98:	e24dd008 	sub	sp, sp, #8
  137b9c:	e50b0008 	str	r0, [fp, #-8]
  137ba0:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(handle);
  137ba4:	e51b300c 	ldr	r3, [fp, #-12]
  137ba8:	e3530000 	cmp	r3, #0
  137bac:	1a000005 	bne	137bc8 <ENET_TransmitIRQHandler+0x38>
  137bb0:	e30023c2 	movw	r2, #962	; 0x3c2
  137bb4:	e30a15a4 	movw	r1, #42404	; 0xa5a4
  137bb8:	e3401014 	movt	r1, #20
  137bbc:	e30a0134 	movw	r0, #41268	; 0xa134
  137bc0:	e3400014 	movt	r0, #20
  137bc4:	ebff2e73 	bl	103598 <rt_assert_handler>
    /* Check if the transmit interrupt happen. */
    if((kENET_TxBufferInterrupt | kENET_TxFrameInterrupt) & base->EIR)
  137bc8:	e51b3008 	ldr	r3, [fp, #-8]
  137bcc:	e5933004 	ldr	r3, [r3, #4]
  137bd0:	e2033303 	and	r3, r3, #201326592	; 0xc000000
  137bd4:	e3530000 	cmp	r3, #0
  137bd8:	0a000002 	beq	137be8 <ENET_TransmitIRQHandler+0x58>
    {
        /* Clear the transmit interrupt event. */
        base->EIR = kENET_TxFrameInterrupt | kENET_TxBufferInterrupt;
  137bdc:	e51b3008 	ldr	r3, [fp, #-8]
  137be0:	e3a02303 	mov	r2, #201326592	; 0xc000000
  137be4:	e5832004 	str	r2, [r3, #4]
    }
    tx_enet_callback((void *)base);
  137be8:	e51b0008 	ldr	r0, [fp, #-8]
  137bec:	ebfff6e5 	bl	135788 <tx_enet_callback>
}
  137bf0:	e320f000 	nop	{0}
  137bf4:	e24bd004 	sub	sp, fp, #4
  137bf8:	e8bd8800 	pop	{fp, pc}

00137bfc <ENET_ReceiveIRQHandler>:
void rx_enet_callback(void *base);
void ENET_ReceiveIRQHandler(ENET_Type *base, enet_handle_t *handle)
{
  137bfc:	e92d4800 	push	{fp, lr}
  137c00:	e28db004 	add	fp, sp, #4
  137c04:	e24dd008 	sub	sp, sp, #8
  137c08:	e50b0008 	str	r0, [fp, #-8]
  137c0c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(handle);
  137c10:	e51b300c 	ldr	r3, [fp, #-12]
  137c14:	e3530000 	cmp	r3, #0
  137c18:	1a000005 	bne	137c34 <ENET_ReceiveIRQHandler+0x38>
  137c1c:	e30023ce 	movw	r2, #974	; 0x3ce
  137c20:	e30a15bc 	movw	r1, #42428	; 0xa5bc
  137c24:	e3401014 	movt	r1, #20
  137c28:	e30a0134 	movw	r0, #41268	; 0xa134
  137c2c:	e3400014 	movt	r0, #20
  137c30:	ebff2e58 	bl	103598 <rt_assert_handler>

    /* Check if the receive interrupt happen. */
    if((kENET_RxBufferInterrupt | kENET_RxFrameInterrupt) & base->EIR)
  137c34:	e51b3008 	ldr	r3, [fp, #-8]
  137c38:	e5933004 	ldr	r3, [r3, #4]
  137c3c:	e2033403 	and	r3, r3, #50331648	; 0x3000000
  137c40:	e3530000 	cmp	r3, #0
  137c44:	0a000004 	beq	137c5c <ENET_ReceiveIRQHandler+0x60>
    {
        /* Clear the transmit interrupt event. */
        base->EIR = kENET_RxFrameInterrupt | kENET_RxBufferInterrupt;
  137c48:	e51b3008 	ldr	r3, [fp, #-8]
  137c4c:	e3a02403 	mov	r2, #50331648	; 0x3000000
  137c50:	e5832004 	str	r2, [r3, #4]
        rx_enet_callback((void *)base);
  137c54:	e51b0008 	ldr	r0, [fp, #-8]
  137c58:	ebfff6a7 	bl	1356fc <rx_enet_callback>
    }
}
  137c5c:	e320f000 	nop	{0}
  137c60:	e24bd004 	sub	sp, fp, #4
  137c64:	e8bd8800 	pop	{fp, pc}

00137c68 <ENET_ErrorIRQHandler>:
void ENET_ErrorIRQHandler(ENET_Type *base, enet_handle_t *handle)
{
  137c68:	e92d4810 	push	{r4, fp, lr}
  137c6c:	e28db008 	add	fp, sp, #8
  137c70:	e24dd014 	sub	sp, sp, #20
  137c74:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  137c78:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(handle);
  137c7c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  137c80:	e3530000 	cmp	r3, #0
  137c84:	1a000005 	bne	137ca0 <ENET_ErrorIRQHandler+0x38>
  137c88:	e30023da 	movw	r2, #986	; 0x3da
  137c8c:	e30a15d4 	movw	r1, #42452	; 0xa5d4
  137c90:	e3401014 	movt	r1, #20
  137c94:	e30a0134 	movw	r0, #41268	; 0xa134
  137c98:	e3400014 	movt	r0, #20
  137c9c:	ebff2e3d 	bl	103598 <rt_assert_handler>

    uint32_t errMask = kENET_BabrInterrupt | kENET_BabtInterrupt | kENET_EBusERInterrupt | kENET_PayloadRxInterrupt |
  137ca0:	e3a03000 	mov	r3, #0
  137ca4:	e346307c 	movt	r3, #24700	; 0x607c
  137ca8:	e50b3010 	str	r3, [fp, #-16]
                       kENET_LateCollisionInterrupt | kENET_RetryLimitInterrupt | kENET_UnderrunInterrupt;
    /* Check if the error interrupt happen. */
    if (kENET_WakeupInterrupt & base->EIR)
  137cac:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137cb0:	e5933004 	ldr	r3, [r3, #4]
  137cb4:	e2033802 	and	r3, r3, #131072	; 0x20000
  137cb8:	e3530000 	cmp	r3, #0
  137cbc:	0a000012 	beq	137d0c <ENET_ErrorIRQHandler+0xa4>
    {
        /* Clear the wakeup interrupt. */
        base->EIR = kENET_WakeupInterrupt;
  137cc0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137cc4:	e3a02802 	mov	r2, #131072	; 0x20000
  137cc8:	e5832004 	str	r2, [r3, #4]
        /* wake up and enter the normal mode. */
        ENET_EnableSleepMode(base, false);
  137ccc:	e3a01000 	mov	r1, #0
  137cd0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  137cd4:	ebfff879 	bl	135ec0 <ENET_EnableSleepMode>
        /* Callback function. */
        if (handle->callback)
  137cd8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  137cdc:	e5933018 	ldr	r3, [r3, #24]
  137ce0:	e3530000 	cmp	r3, #0
  137ce4:	0a00001c 	beq	137d5c <ENET_ErrorIRQHandler+0xf4>
        {
            handle->callback(base, handle, kENET_WakeUpEvent, handle->userData);
  137ce8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  137cec:	e5934018 	ldr	r4, [r3, #24]
  137cf0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  137cf4:	e593301c 	ldr	r3, [r3, #28]
  137cf8:	e3a02003 	mov	r2, #3
  137cfc:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  137d00:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  137d04:	e12fff34 	blx	r4
        if (handle->callback)
        {
            handle->callback(base, handle, kENET_ErrEvent, handle->userData);
        }
    }
}
  137d08:	ea000013 	b	137d5c <ENET_ErrorIRQHandler+0xf4>
        errMask &= base->EIR;
  137d0c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137d10:	e5933004 	ldr	r3, [r3, #4]
  137d14:	e51b2010 	ldr	r2, [fp, #-16]
  137d18:	e0033002 	and	r3, r3, r2
  137d1c:	e50b3010 	str	r3, [fp, #-16]
        base->EIR = errMask;
  137d20:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  137d24:	e51b2010 	ldr	r2, [fp, #-16]
  137d28:	e5832004 	str	r2, [r3, #4]
        if (handle->callback)
  137d2c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  137d30:	e5933018 	ldr	r3, [r3, #24]
  137d34:	e3530000 	cmp	r3, #0
  137d38:	0a000007 	beq	137d5c <ENET_ErrorIRQHandler+0xf4>
            handle->callback(base, handle, kENET_ErrEvent, handle->userData);
  137d3c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  137d40:	e5934018 	ldr	r4, [r3, #24]
  137d44:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  137d48:	e593301c 	ldr	r3, [r3, #28]
  137d4c:	e3a02002 	mov	r2, #2
  137d50:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  137d54:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  137d58:	e12fff34 	blx	r4
}
  137d5c:	e320f000 	nop	{0}
  137d60:	e24bd008 	sub	sp, fp, #8
  137d64:	e8bd8810 	pop	{r4, fp, pc}

00137d68 <ENET_CommonFrame0IRQHandler>:

void ENET_CommonFrame0IRQHandler(ENET_Type *base)
{
  137d68:	e92d4800 	push	{fp, lr}
  137d6c:	e28db004 	add	fp, sp, #4
  137d70:	e24dd010 	sub	sp, sp, #16
  137d74:	e50b0010 	str	r0, [fp, #-16]
    uint32_t event = base->EIR;
  137d78:	e51b3010 	ldr	r3, [fp, #-16]
  137d7c:	e5933004 	ldr	r3, [r3, #4]
  137d80:	e50b3008 	str	r3, [fp, #-8]
    uint32_t instance = get_instance_by_base(base);
  137d84:	e51b0010 	ldr	r0, [fp, #-16]
  137d88:	ebfff633 	bl	13565c <get_instance_by_base>
  137d8c:	e1a03000 	mov	r3, r0
  137d90:	e50b300c 	str	r3, [fp, #-12]

    if(base->EIMR & ENET_TX_INTERRUPT)
  137d94:	e51b3010 	ldr	r3, [fp, #-16]
  137d98:	e5933008 	ldr	r3, [r3, #8]
  137d9c:	e2033303 	and	r3, r3, #201326592	; 0xc000000
  137da0:	e3530000 	cmp	r3, #0
  137da4:	0a000012 	beq	137df4 <ENET_CommonFrame0IRQHandler+0x8c>
    {
        if (event & ENET_TX_INTERRUPT)
  137da8:	e51b3008 	ldr	r3, [fp, #-8]
  137dac:	e2033303 	and	r3, r3, #201326592	; 0xc000000
  137db0:	e3530000 	cmp	r3, #0
  137db4:	0a00000e 	beq	137df4 <ENET_CommonFrame0IRQHandler+0x8c>
        {
            if(s_enetTxIsr)
  137db8:	e30f3c00 	movw	r3, #64512	; 0xfc00
  137dbc:	e3403014 	movt	r3, #20
  137dc0:	e5933000 	ldr	r3, [r3]
  137dc4:	e3530000 	cmp	r3, #0
  137dc8:	0a000009 	beq	137df4 <ENET_CommonFrame0IRQHandler+0x8c>
            {
                s_enetTxIsr(base, s_ENETHandle[instance]);
  137dcc:	e30f3c00 	movw	r3, #64512	; 0xfc00
  137dd0:	e3403014 	movt	r3, #20
  137dd4:	e5932000 	ldr	r2, [r3]
  137dd8:	e30f3bf8 	movw	r3, #64504	; 0xfbf8
  137ddc:	e3403014 	movt	r3, #20
  137de0:	e51b100c 	ldr	r1, [fp, #-12]
  137de4:	e7933101 	ldr	r3, [r3, r1, lsl #2]
  137de8:	e1a01003 	mov	r1, r3
  137dec:	e51b0010 	ldr	r0, [fp, #-16]
  137df0:	e12fff32 	blx	r2
            }
        }
    }
    if (base->EIMR & ENET_RX_INTERRUPT)
  137df4:	e51b3010 	ldr	r3, [fp, #-16]
  137df8:	e5933008 	ldr	r3, [r3, #8]
  137dfc:	e2033403 	and	r3, r3, #50331648	; 0x3000000
  137e00:	e3530000 	cmp	r3, #0
  137e04:	0a000012 	beq	137e54 <ENET_CommonFrame0IRQHandler+0xec>
    {
        if (event & ENET_RX_INTERRUPT)
  137e08:	e51b3008 	ldr	r3, [fp, #-8]
  137e0c:	e2033403 	and	r3, r3, #50331648	; 0x3000000
  137e10:	e3530000 	cmp	r3, #0
  137e14:	0a00000e 	beq	137e54 <ENET_CommonFrame0IRQHandler+0xec>
        {
            if(s_enetRxIsr)
  137e18:	e30f3c04 	movw	r3, #64516	; 0xfc04
  137e1c:	e3403014 	movt	r3, #20
  137e20:	e5933000 	ldr	r3, [r3]
  137e24:	e3530000 	cmp	r3, #0
  137e28:	0a000009 	beq	137e54 <ENET_CommonFrame0IRQHandler+0xec>
            {
                s_enetRxIsr(base, s_ENETHandle[instance]);
  137e2c:	e30f3c04 	movw	r3, #64516	; 0xfc04
  137e30:	e3403014 	movt	r3, #20
  137e34:	e5932000 	ldr	r2, [r3]
  137e38:	e30f3bf8 	movw	r3, #64504	; 0xfbf8
  137e3c:	e3403014 	movt	r3, #20
  137e40:	e51b100c 	ldr	r1, [fp, #-12]
  137e44:	e7933101 	ldr	r3, [r3, r1, lsl #2]
  137e48:	e1a01003 	mov	r1, r3
  137e4c:	e51b0010 	ldr	r0, [fp, #-16]
  137e50:	e12fff32 	blx	r2
            }
        }
    }
    if(base->EIMR & ENET_TS_INTERRUPT)
  137e54:	e51b3010 	ldr	r3, [fp, #-16]
  137e58:	e5933008 	ldr	r3, [r3, #8]
  137e5c:	e2033906 	and	r3, r3, #98304	; 0x18000
  137e60:	e3530000 	cmp	r3, #0
  137e64:	0a000012 	beq	137eb4 <ENET_CommonFrame0IRQHandler+0x14c>
    {
        if (event & ENET_TS_INTERRUPT)
  137e68:	e51b3008 	ldr	r3, [fp, #-8]
  137e6c:	e2033906 	and	r3, r3, #98304	; 0x18000
  137e70:	e3530000 	cmp	r3, #0
  137e74:	0a00000e 	beq	137eb4 <ENET_CommonFrame0IRQHandler+0x14c>
        {
            if(s_enetTsIsr)
  137e78:	e30f3c0c 	movw	r3, #64524	; 0xfc0c
  137e7c:	e3403014 	movt	r3, #20
  137e80:	e5933000 	ldr	r3, [r3]
  137e84:	e3530000 	cmp	r3, #0
  137e88:	0a000009 	beq	137eb4 <ENET_CommonFrame0IRQHandler+0x14c>
            {
                s_enetTsIsr(base, s_ENETHandle[instance]);
  137e8c:	e30f3c0c 	movw	r3, #64524	; 0xfc0c
  137e90:	e3403014 	movt	r3, #20
  137e94:	e5932000 	ldr	r2, [r3]
  137e98:	e30f3bf8 	movw	r3, #64504	; 0xfbf8
  137e9c:	e3403014 	movt	r3, #20
  137ea0:	e51b100c 	ldr	r1, [fp, #-12]
  137ea4:	e7933101 	ldr	r3, [r3, r1, lsl #2]
  137ea8:	e1a01003 	mov	r1, r3
  137eac:	e51b0010 	ldr	r0, [fp, #-16]
  137eb0:	e12fff32 	blx	r2
            }
        }
    }
    if(base->EIMR & ENET_ERR_INTERRUPT)
  137eb4:	e51b3010 	ldr	r3, [fp, #-16]
  137eb8:	e5932008 	ldr	r2, [r3, #8]
  137ebc:	e3a03000 	mov	r3, #0
  137ec0:	e346307c 	movt	r3, #24700	; 0x607c
  137ec4:	e0033002 	and	r3, r3, r2
  137ec8:	e3530000 	cmp	r3, #0
  137ecc:	0a000014 	beq	137f24 <ENET_CommonFrame0IRQHandler+0x1bc>
    {
        if (event & ENET_ERR_INTERRUPT)
  137ed0:	e51b2008 	ldr	r2, [fp, #-8]
  137ed4:	e3a03000 	mov	r3, #0
  137ed8:	e346307c 	movt	r3, #24700	; 0x607c
  137edc:	e0033002 	and	r3, r3, r2
  137ee0:	e3530000 	cmp	r3, #0
  137ee4:	0a00000e 	beq	137f24 <ENET_CommonFrame0IRQHandler+0x1bc>
        {
            if(s_enetErrIsr)
  137ee8:	e30f3c08 	movw	r3, #64520	; 0xfc08
  137eec:	e3403014 	movt	r3, #20
  137ef0:	e5933000 	ldr	r3, [r3]
  137ef4:	e3530000 	cmp	r3, #0
  137ef8:	0a000009 	beq	137f24 <ENET_CommonFrame0IRQHandler+0x1bc>
            {
                s_enetErrIsr(base, s_ENETHandle[instance]);
  137efc:	e30f3c08 	movw	r3, #64520	; 0xfc08
  137f00:	e3403014 	movt	r3, #20
  137f04:	e5932000 	ldr	r2, [r3]
  137f08:	e30f3bf8 	movw	r3, #64504	; 0xfbf8
  137f0c:	e3403014 	movt	r3, #20
  137f10:	e51b100c 	ldr	r1, [fp, #-12]
  137f14:	e7933101 	ldr	r3, [r3, r1, lsl #2]
  137f18:	e1a01003 	mov	r1, r3
  137f1c:	e51b0010 	ldr	r0, [fp, #-16]
  137f20:	e12fff32 	blx	r2
            }
        }
    }
}
  137f24:	e320f000 	nop	{0}
  137f28:	e24bd004 	sub	sp, fp, #4
  137f2c:	e8bd8800 	pop	{fp, pc}

00137f30 <ENET_DriverIRQHandler>:
void ENET_DriverIRQHandler(int irq, void *base)
{
  137f30:	e92d4800 	push	{fp, lr}
  137f34:	e28db004 	add	fp, sp, #4
  137f38:	e24dd008 	sub	sp, sp, #8
  137f3c:	e50b0008 	str	r0, [fp, #-8]
  137f40:	e50b100c 	str	r1, [fp, #-12]
    ENET_CommonFrame0IRQHandler((ENET_Type *)base);
  137f44:	e51b000c 	ldr	r0, [fp, #-12]
  137f48:	ebffff86 	bl	137d68 <ENET_CommonFrame0IRQHandler>
  137f4c:	e320f000 	nop	{0}
  137f50:	e24bd004 	sub	sp, fp, #4
  137f54:	e8bd8800 	pop	{fp, pc}

00137f58 <GPIO_PinInit>:

//     return instance;
// }

void GPIO_PinInit(GPIO_Type* base, uint32_t pin, const gpio_pin_config_t* Config)
{
  137f58:	e92d4800 	push	{fp, lr}
  137f5c:	e28db004 	add	fp, sp, #4
  137f60:	e24dd010 	sub	sp, sp, #16
  137f64:	e50b0008 	str	r0, [fp, #-8]
  137f68:	e50b100c 	str	r1, [fp, #-12]
  137f6c:	e50b2010 	str	r2, [fp, #-16]
//     /* Enable GPIO clock. */
//     CLOCK_EnableClock(s_gpioClock[GPIO_GetInstance(base)]);
// #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    /* Register reset to default value */
    base->IMR &= ~(1U << pin);
  137f70:	e51b3008 	ldr	r3, [fp, #-8]
  137f74:	e5932014 	ldr	r2, [r3, #20]
  137f78:	e3a01001 	mov	r1, #1
  137f7c:	e51b300c 	ldr	r3, [fp, #-12]
  137f80:	e1a03311 	lsl	r3, r1, r3
  137f84:	e1e03003 	mvn	r3, r3
  137f88:	e0022003 	and	r2, r2, r3
  137f8c:	e51b3008 	ldr	r3, [fp, #-8]
  137f90:	e5832014 	str	r2, [r3, #20]

    /* Configure GPIO pin direction */
    if (Config->direction == kGPIO_DigitalInput)
  137f94:	e51b3010 	ldr	r3, [fp, #-16]
  137f98:	e5933000 	ldr	r3, [r3]
  137f9c:	e3530000 	cmp	r3, #0
  137fa0:	1a000009 	bne	137fcc <GPIO_PinInit+0x74>
    {
        base->GDIR &= ~(1U << pin);
  137fa4:	e51b3008 	ldr	r3, [fp, #-8]
  137fa8:	e5932004 	ldr	r2, [r3, #4]
  137fac:	e3a01001 	mov	r1, #1
  137fb0:	e51b300c 	ldr	r3, [fp, #-12]
  137fb4:	e1a03311 	lsl	r3, r1, r3
  137fb8:	e1e03003 	mvn	r3, r3
  137fbc:	e0022003 	and	r2, r2, r3
  137fc0:	e51b3008 	ldr	r3, [fp, #-8]
  137fc4:	e5832004 	str	r2, [r3, #4]
  137fc8:	ea00000d 	b	138004 <GPIO_PinInit+0xac>
    }
    else
    {
        GPIO_WritePinOutput(base, pin, Config->outputLogic);
  137fcc:	e51b3010 	ldr	r3, [fp, #-16]
  137fd0:	e5d33004 	ldrb	r3, [r3, #4]
  137fd4:	e1a02003 	mov	r2, r3
  137fd8:	e51b100c 	ldr	r1, [fp, #-12]
  137fdc:	e51b0008 	ldr	r0, [fp, #-8]
  137fe0:	eb000010 	bl	138028 <GPIO_WritePinOutput>
        base->GDIR |= (1U << pin);
  137fe4:	e51b3008 	ldr	r3, [fp, #-8]
  137fe8:	e5932004 	ldr	r2, [r3, #4]
  137fec:	e3a01001 	mov	r1, #1
  137ff0:	e51b300c 	ldr	r3, [fp, #-12]
  137ff4:	e1a03311 	lsl	r3, r1, r3
  137ff8:	e1822003 	orr	r2, r2, r3
  137ffc:	e51b3008 	ldr	r3, [fp, #-8]
  138000:	e5832004 	str	r2, [r3, #4]
    }

    /* Configure GPIO pin interrupt mode */
    GPIO_SetPinInterruptConfig(base, pin, Config->interruptMode);
  138004:	e51b3010 	ldr	r3, [fp, #-16]
  138008:	e5933008 	ldr	r3, [r3, #8]
  13800c:	e1a02003 	mov	r2, r3
  138010:	e51b100c 	ldr	r1, [fp, #-12]
  138014:	e51b0008 	ldr	r0, [fp, #-8]
  138018:	eb00002c 	bl	1380d0 <GPIO_SetPinInterruptConfig>
}
  13801c:	e320f000 	nop	{0}
  138020:	e24bd004 	sub	sp, fp, #4
  138024:	e8bd8800 	pop	{fp, pc}

00138028 <GPIO_WritePinOutput>:

void GPIO_WritePinOutput(GPIO_Type* base, uint32_t pin, uint8_t output)
{
  138028:	e92d4800 	push	{fp, lr}
  13802c:	e28db004 	add	fp, sp, #4
  138030:	e24dd010 	sub	sp, sp, #16
  138034:	e50b0008 	str	r0, [fp, #-8]
  138038:	e50b100c 	str	r1, [fp, #-12]
  13803c:	e1a03002 	mov	r3, r2
  138040:	e54b300d 	strb	r3, [fp, #-13]
    assert(pin < 32);
  138044:	e51b300c 	ldr	r3, [fp, #-12]
  138048:	e353001f 	cmp	r3, #31
  13804c:	9a000007 	bls	138070 <GPIO_WritePinOutput+0x48>
  138050:	e30a3624 	movw	r3, #42532	; 0xa624
  138054:	e3403014 	movt	r3, #20
  138058:	e3a0206a 	mov	r2, #106	; 0x6a
  13805c:	e30a15ec 	movw	r1, #42476	; 0xa5ec
  138060:	e3401014 	movt	r1, #20
  138064:	e30a0618 	movw	r0, #42520	; 0xa618
  138068:	e3400014 	movt	r0, #20
  13806c:	eb000445 	bl	139188 <__assert_fail>
    if (output == 0U)
  138070:	e55b300d 	ldrb	r3, [fp, #-13]
  138074:	e3530000 	cmp	r3, #0
  138078:	1a000009 	bne	1380a4 <GPIO_WritePinOutput+0x7c>
    {
        base->DR &= ~(1U << pin);  /* Set pin output to low level.*/
  13807c:	e51b3008 	ldr	r3, [fp, #-8]
  138080:	e5932000 	ldr	r2, [r3]
  138084:	e3a01001 	mov	r1, #1
  138088:	e51b300c 	ldr	r3, [fp, #-12]
  13808c:	e1a03311 	lsl	r3, r1, r3
  138090:	e1e03003 	mvn	r3, r3
  138094:	e0022003 	and	r2, r2, r3
  138098:	e51b3008 	ldr	r3, [fp, #-8]
  13809c:	e5832000 	str	r2, [r3]
    }
    else
    {
        base->DR |= (1U << pin);  /* Set pin output to high level.*/
    }
}
  1380a0:	ea000007 	b	1380c4 <GPIO_WritePinOutput+0x9c>
        base->DR |= (1U << pin);  /* Set pin output to high level.*/
  1380a4:	e51b3008 	ldr	r3, [fp, #-8]
  1380a8:	e5932000 	ldr	r2, [r3]
  1380ac:	e3a01001 	mov	r1, #1
  1380b0:	e51b300c 	ldr	r3, [fp, #-12]
  1380b4:	e1a03311 	lsl	r3, r1, r3
  1380b8:	e1822003 	orr	r2, r2, r3
  1380bc:	e51b3008 	ldr	r3, [fp, #-8]
  1380c0:	e5832000 	str	r2, [r3]
}
  1380c4:	e320f000 	nop	{0}
  1380c8:	e24bd004 	sub	sp, fp, #4
  1380cc:	e8bd8800 	pop	{fp, pc}

001380d0 <GPIO_SetPinInterruptConfig>:

void GPIO_SetPinInterruptConfig(GPIO_Type* base, uint32_t pin, gpio_interrupt_mode_t pinInterruptMode)
{
  1380d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1380d4:	e28db000 	add	fp, sp, #0
  1380d8:	e24dd01c 	sub	sp, sp, #28
  1380dc:	e50b0010 	str	r0, [fp, #-16]
  1380e0:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1380e4:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    volatile uint32_t *icr;
    uint32_t icrShift;

    icrShift = pin;
  1380e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  1380ec:	e50b300c 	str	r3, [fp, #-12]

    /* Register reset to default value */
    base->EDGE_SEL &= ~(1U << pin);
  1380f0:	e51b3010 	ldr	r3, [fp, #-16]
  1380f4:	e593201c 	ldr	r2, [r3, #28]
  1380f8:	e3a01001 	mov	r1, #1
  1380fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  138100:	e1a03311 	lsl	r3, r1, r3
  138104:	e1e03003 	mvn	r3, r3
  138108:	e0022003 	and	r2, r2, r3
  13810c:	e51b3010 	ldr	r3, [fp, #-16]
  138110:	e583201c 	str	r2, [r3, #28]

    if(pin < 16)
  138114:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  138118:	e353000f 	cmp	r3, #15
  13811c:	8a000003 	bhi	138130 <GPIO_SetPinInterruptConfig+0x60>
    {
        icr = &(base->ICR1);
  138120:	e51b3010 	ldr	r3, [fp, #-16]
  138124:	e283300c 	add	r3, r3, #12
  138128:	e50b3008 	str	r3, [fp, #-8]
  13812c:	ea000005 	b	138148 <GPIO_SetPinInterruptConfig+0x78>
    }
    else
    {
        icr = &(base->ICR2);
  138130:	e51b3010 	ldr	r3, [fp, #-16]
  138134:	e2833010 	add	r3, r3, #16
  138138:	e50b3008 	str	r3, [fp, #-8]
        icrShift -= 16;
  13813c:	e51b300c 	ldr	r3, [fp, #-12]
  138140:	e2433010 	sub	r3, r3, #16
  138144:	e50b300c 	str	r3, [fp, #-12]
    }
    switch(pinInterruptMode)
  138148:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  13814c:	e2433001 	sub	r3, r3, #1
  138150:	e3530004 	cmp	r3, #4
  138154:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  138158:	ea000042 	b	138268 <GPIO_SetPinInterruptConfig+0x198>
  13815c:	00138170 	.word	0x00138170
  138160:	0013819c 	.word	0x0013819c
  138164:	001381dc 	.word	0x001381dc
  138168:	0013821c 	.word	0x0013821c
  13816c:	00138244 	.word	0x00138244
    {
        case(kGPIO_IntLowLevel):
            *icr &= ~(3U << (2 * icrShift));
  138170:	e51b3008 	ldr	r3, [fp, #-8]
  138174:	e5932000 	ldr	r2, [r3]
  138178:	e51b300c 	ldr	r3, [fp, #-12]
  13817c:	e1a03083 	lsl	r3, r3, #1
  138180:	e3a01003 	mov	r1, #3
  138184:	e1a03311 	lsl	r3, r1, r3
  138188:	e1e03003 	mvn	r3, r3
  13818c:	e0022003 	and	r2, r2, r3
  138190:	e51b3008 	ldr	r3, [fp, #-8]
  138194:	e5832000 	str	r2, [r3]
            break;
  138198:	ea000033 	b	13826c <GPIO_SetPinInterruptConfig+0x19c>
        case(kGPIO_IntHighLevel):
            *icr = (*icr & (~(3U << (2 * icrShift)))) | (1U << (2 * icrShift));
  13819c:	e51b3008 	ldr	r3, [fp, #-8]
  1381a0:	e5932000 	ldr	r2, [r3]
  1381a4:	e51b300c 	ldr	r3, [fp, #-12]
  1381a8:	e1a03083 	lsl	r3, r3, #1
  1381ac:	e3a01003 	mov	r1, #3
  1381b0:	e1a03311 	lsl	r3, r1, r3
  1381b4:	e1e03003 	mvn	r3, r3
  1381b8:	e0022003 	and	r2, r2, r3
  1381bc:	e51b300c 	ldr	r3, [fp, #-12]
  1381c0:	e1a03083 	lsl	r3, r3, #1
  1381c4:	e3a01001 	mov	r1, #1
  1381c8:	e1a03311 	lsl	r3, r1, r3
  1381cc:	e1822003 	orr	r2, r2, r3
  1381d0:	e51b3008 	ldr	r3, [fp, #-8]
  1381d4:	e5832000 	str	r2, [r3]
            break;
  1381d8:	ea000023 	b	13826c <GPIO_SetPinInterruptConfig+0x19c>
        case(kGPIO_IntRisingEdge):
            *icr = (*icr & (~(3U << (2 * icrShift)))) | (2U << (2 * icrShift));
  1381dc:	e51b3008 	ldr	r3, [fp, #-8]
  1381e0:	e5932000 	ldr	r2, [r3]
  1381e4:	e51b300c 	ldr	r3, [fp, #-12]
  1381e8:	e1a03083 	lsl	r3, r3, #1
  1381ec:	e3a01003 	mov	r1, #3
  1381f0:	e1a03311 	lsl	r3, r1, r3
  1381f4:	e1e03003 	mvn	r3, r3
  1381f8:	e0022003 	and	r2, r2, r3
  1381fc:	e51b300c 	ldr	r3, [fp, #-12]
  138200:	e1a03083 	lsl	r3, r3, #1
  138204:	e3a01002 	mov	r1, #2
  138208:	e1a03311 	lsl	r3, r1, r3
  13820c:	e1822003 	orr	r2, r2, r3
  138210:	e51b3008 	ldr	r3, [fp, #-8]
  138214:	e5832000 	str	r2, [r3]
            break;
  138218:	ea000013 	b	13826c <GPIO_SetPinInterruptConfig+0x19c>
        case(kGPIO_IntFallingEdge):
            *icr |= (3U << (2 * icrShift));
  13821c:	e51b3008 	ldr	r3, [fp, #-8]
  138220:	e5932000 	ldr	r2, [r3]
  138224:	e51b300c 	ldr	r3, [fp, #-12]
  138228:	e1a03083 	lsl	r3, r3, #1
  13822c:	e3a01003 	mov	r1, #3
  138230:	e1a03311 	lsl	r3, r1, r3
  138234:	e1822003 	orr	r2, r2, r3
  138238:	e51b3008 	ldr	r3, [fp, #-8]
  13823c:	e5832000 	str	r2, [r3]
            break;
  138240:	ea000009 	b	13826c <GPIO_SetPinInterruptConfig+0x19c>
        case(kGPIO_IntRisingOrFallingEdge):
            base->EDGE_SEL |= (1U << pin);
  138244:	e51b3010 	ldr	r3, [fp, #-16]
  138248:	e593201c 	ldr	r2, [r3, #28]
  13824c:	e3a01001 	mov	r1, #1
  138250:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  138254:	e1a03311 	lsl	r3, r1, r3
  138258:	e1822003 	orr	r2, r2, r3
  13825c:	e51b3010 	ldr	r3, [fp, #-16]
  138260:	e583201c 	str	r2, [r3, #28]
            break;
  138264:	ea000000 	b	13826c <GPIO_SetPinInterruptConfig+0x19c>
        default:
            break;
  138268:	e320f000 	nop	{0}
    }
}
  13826c:	e320f000 	nop	{0}
  138270:	e28bd000 	add	sp, fp, #0
  138274:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  138278:	e12fff1e 	bx	lr

0013827c <ENET_ReadSMIData>:
{
  13827c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  138280:	e28db000 	add	fp, sp, #0
  138284:	e24dd00c 	sub	sp, sp, #12
  138288:	e50b0008 	str	r0, [fp, #-8]
    return (uint32_t)((base->MMFR & ENET_MMFR_DATA_MASK) >> ENET_MMFR_DATA_SHIFT);
  13828c:	e51b3008 	ldr	r3, [fp, #-8]
  138290:	e5933040 	ldr	r3, [r3, #64]	; 0x40
  138294:	e6ff3073 	uxth	r3, r3
}
  138298:	e1a00003 	mov	r0, r3
  13829c:	e28bd000 	add	sp, fp, #0
  1382a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1382a4:	e12fff1e 	bx	lr

001382a8 <ENET_GetInterruptStatus>:
 * @param base  ENET peripheral base address.
 * @return The event status of the interrupt source. This is the logical OR of members
 *         of the enumeration :: enet_interrupt_enable_t.
 */
static inline uint32_t ENET_GetInterruptStatus(ENET_Type *base)
{
  1382a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1382ac:	e28db000 	add	fp, sp, #0
  1382b0:	e24dd00c 	sub	sp, sp, #12
  1382b4:	e50b0008 	str	r0, [fp, #-8]
    return base->EIR;
  1382b8:	e51b3008 	ldr	r3, [fp, #-8]
  1382bc:	e5933004 	ldr	r3, [r3, #4]
}
  1382c0:	e1a00003 	mov	r0, r3
  1382c4:	e28bd000 	add	sp, fp, #0
  1382c8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1382cc:	e12fff1e 	bx	lr

001382d0 <ENET_ClearInterruptStatus>:
 * @param base  ENET peripheral base address.
 * @param mask  ENET interrupt source to be cleared.
 * This is the logical OR of members of the enumeration :: enet_interrupt_enable_t.
 */
static inline void ENET_ClearInterruptStatus(ENET_Type *base, uint32_t mask)
{
  1382d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
  1382d4:	e28db000 	add	fp, sp, #0
  1382d8:	e24dd00c 	sub	sp, sp, #12
  1382dc:	e50b0008 	str	r0, [fp, #-8]
  1382e0:	e50b100c 	str	r1, [fp, #-12]
    base->EIR = mask;
  1382e4:	e51b3008 	ldr	r3, [fp, #-8]
  1382e8:	e51b200c 	ldr	r2, [fp, #-12]
  1382ec:	e5832004 	str	r2, [r3, #4]
}
  1382f0:	e320f000 	nop	{0}
  1382f4:	e28bd000 	add	sp, fp, #0
  1382f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
  1382fc:	e12fff1e 	bx	lr

00138300 <phy_reset>:

/*******************************************************************************
 * Code
 ******************************************************************************/
status_t phy_reset(GPIO_Type *base,uint32_t pin)
{
  138300:	e92d4800 	push	{fp, lr}
  138304:	e28db004 	add	fp, sp, #4
  138308:	e24dd018 	sub	sp, sp, #24
  13830c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  138310:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    GPIO_Type *gpio_base = NULL;
  138314:	e3a03000 	mov	r3, #0
  138318:	e50b3008 	str	r3, [fp, #-8]
    gpio_pin_config_t sw_config =
  13831c:	e3a03001 	mov	r3, #1
  138320:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  138324:	e3a03000 	mov	r3, #0
  138328:	e54b3010 	strb	r3, [fp, #-16]
  13832c:	e3a03000 	mov	r3, #0
  138330:	e50b300c 	str	r3, [fp, #-12]
        0,
        kGPIO_NoIntmode,
    };

    // gpio_base = (GPIO_Type *)rt_ioremap((void *)base,0x1000);
    gpio_base = (GPIO_Type *)ueth_remap((void *)base, UETH_REMAP, 0x1000);
  138334:	e3a02a01 	mov	r2, #4096	; 0x1000
  138338:	e3a01001 	mov	r1, #1
  13833c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  138340:	ebff3061 	bl	1044cc <ueth_remap>
  138344:	e50b0008 	str	r0, [fp, #-8]
    GPIO_PinInit(gpio_base, pin, &sw_config);
  138348:	e24b3014 	sub	r3, fp, #20
  13834c:	e1a02003 	mov	r2, r3
  138350:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  138354:	e51b0008 	ldr	r0, [fp, #-8]
  138358:	ebfffefe 	bl	137f58 <GPIO_PinInit>
    GPIO_WritePinOutput(gpio_base,pin,0);
  13835c:	e3a02000 	mov	r2, #0
  138360:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  138364:	e51b0008 	ldr	r0, [fp, #-8]
  138368:	ebffff2e 	bl	138028 <GPIO_WritePinOutput>
    rt_thread_mdelay(1);
  13836c:	e3a00001 	mov	r0, #1
  138370:	ebff26c1 	bl	101e7c <rt_thread_mdelay>
    GPIO_WritePinOutput(gpio_base,pin,1);
  138374:	e3a02001 	mov	r2, #1
  138378:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  13837c:	e51b0008 	ldr	r0, [fp, #-8]
  138380:	ebffff28 	bl	138028 <GPIO_WritePinOutput>

    return kStatus_Success;
  138384:	e3a03000 	mov	r3, #0

}
  138388:	e1a00003 	mov	r0, r3
  13838c:	e24bd004 	sub	sp, fp, #4
  138390:	e8bd8800 	pop	{fp, pc}

00138394 <PHY_StartNegotiation>:

status_t PHY_StartNegotiation(ENET_Type *base, uint32_t phyAddr)
{
  138394:	e92d4800 	push	{fp, lr}
  138398:	e28db004 	add	fp, sp, #4
  13839c:	e24dd018 	sub	sp, sp, #24
  1383a0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1383a4:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    uint32_t counter = PHY_TIMEOUT_COUNT;
  1383a8:	e3e034fb 	mvn	r3, #-83886080	; 0xfb000000
  1383ac:	e50b3008 	str	r3, [fp, #-8]
    status_t result = kStatus_Success;
  1383b0:	e3a03000 	mov	r3, #0
  1383b4:	e50b3010 	str	r3, [fp, #-16]
    uint32_t bssReg;
    uint32_t timeDelay;

    result = PHY_Write(base, phyAddr, PHY_BASICCONTROL_REG, PHY_BCTL_RESET_MASK);
  1383b8:	e3a03902 	mov	r3, #32768	; 0x8000
  1383bc:	e3a02000 	mov	r2, #0
  1383c0:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  1383c4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1383c8:	eb000071 	bl	138594 <PHY_Write>
  1383cc:	e50b0010 	str	r0, [fp, #-16]
    if (result == kStatus_Success)
  1383d0:	e51b3010 	ldr	r3, [fp, #-16]
  1383d4:	e3530000 	cmp	r3, #0
  1383d8:	1a000038 	bne	1384c0 <PHY_StartNegotiation+0x12c>
        {
            return result;
        }
#endif  /* FSL_FEATURE_PHYKSZ8081_USE_RMII50M_MODE */
        /* Set the negotiation. */
        result = PHY_Write(base, phyAddr, PHY_AUTONEG_ADVERTISE_REG,
  1383dc:	e30031e1 	movw	r3, #481	; 0x1e1
  1383e0:	e3a02004 	mov	r2, #4
  1383e4:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  1383e8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  1383ec:	eb000068 	bl	138594 <PHY_Write>
  1383f0:	e50b0010 	str	r0, [fp, #-16]
                           (PHY_100BASETX_FULLDUPLEX_MASK | PHY_100BASETX_HALFDUPLEX_MASK |
                            PHY_10BASETX_FULLDUPLEX_MASK | PHY_10BASETX_HALFDUPLEX_MASK | 0x1U));
        if (result == kStatus_Success)
  1383f4:	e51b3010 	ldr	r3, [fp, #-16]
  1383f8:	e3530000 	cmp	r3, #0
  1383fc:	1a00002f 	bne	1384c0 <PHY_StartNegotiation+0x12c>
        {
            result = PHY_Write(base, phyAddr, PHY_BASICCONTROL_REG,
  138400:	e3a03c12 	mov	r3, #4608	; 0x1200
  138404:	e3a02000 	mov	r2, #0
  138408:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  13840c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  138410:	eb00005f 	bl	138594 <PHY_Write>
  138414:	e50b0010 	str	r0, [fp, #-16]
                               (PHY_BCTL_AUTONEG_MASK | PHY_BCTL_RESTART_AUTONEG_MASK));
            if (result == kStatus_Success)
  138418:	e51b3010 	ldr	r3, [fp, #-16]
  13841c:	e3530000 	cmp	r3, #0
  138420:	1a000026 	bne	1384c0 <PHY_StartNegotiation+0x12c>
            {
                /* Check auto negotiation complete. */
                while (counter --)
  138424:	ea000020 	b	1384ac <PHY_StartNegotiation+0x118>
                {
                    result = PHY_Read(base, phyAddr, PHY_BASICSTATUS_REG, &bssReg);
  138428:	e24b3014 	sub	r3, fp, #20
  13842c:	e3a02001 	mov	r2, #1
  138430:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  138434:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  138438:	eb000083 	bl	13864c <PHY_Read>
  13843c:	e50b0010 	str	r0, [fp, #-16]
                    if ( result == kStatus_Success)
  138440:	e51b3010 	ldr	r3, [fp, #-16]
  138444:	e3530000 	cmp	r3, #0
  138448:	1a000010 	bne	138490 <PHY_StartNegotiation+0xfc>
                    {
                        if ((bssReg & PHY_BSTATUS_AUTONEGCOMP_MASK) != 0)
  13844c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
  138450:	e2033020 	and	r3, r3, #32
  138454:	e3530000 	cmp	r3, #0
  138458:	0a00000c 	beq	138490 <PHY_StartNegotiation+0xfc>
                        {
                            /* Wait a moment for Phy status stable. */
                            for (timeDelay = 0; timeDelay < PHY_TIMEOUT_COUNT; timeDelay ++)
  13845c:	e3a03000 	mov	r3, #0
  138460:	e50b300c 	str	r3, [fp, #-12]
  138464:	ea000003 	b	138478 <PHY_StartNegotiation+0xe4>
                            {
                                __ASM("nop");
  138468:	e320f000 	nop	{0}
                            for (timeDelay = 0; timeDelay < PHY_TIMEOUT_COUNT; timeDelay ++)
  13846c:	e51b300c 	ldr	r3, [fp, #-12]
  138470:	e2833001 	add	r3, r3, #1
  138474:	e50b300c 	str	r3, [fp, #-12]
  138478:	e51b200c 	ldr	r2, [fp, #-12]
  13847c:	e30f3ffe 	movw	r3, #65534	; 0xfffe
  138480:	e34034ff 	movt	r3, #1279	; 0x4ff
  138484:	e1520003 	cmp	r2, r3
  138488:	9afffff6 	bls	138468 <PHY_StartNegotiation+0xd4>
                            }
                            break;
  13848c:	ea00000b 	b	1384c0 <PHY_StartNegotiation+0x12c>
                        }
                    }
                    // rt_thread_delay(PHY_NEGOTIATION_DELAY);
                    rt_thread_mdelay(PHY_NEGOTIATION_DELAY);
  138490:	e3a00064 	mov	r0, #100	; 0x64
  138494:	ebff2678 	bl	101e7c <rt_thread_mdelay>
                    if (!counter)
  138498:	e51b3008 	ldr	r3, [fp, #-8]
  13849c:	e3530000 	cmp	r3, #0
  1384a0:	1a000001 	bne	1384ac <PHY_StartNegotiation+0x118>
                    {
                        return kStatus_PHY_AutoNegotiateFail;
  1384a4:	e3013006 	movw	r3, #4102	; 0x1006
  1384a8:	ea000005 	b	1384c4 <PHY_StartNegotiation+0x130>
                while (counter --)
  1384ac:	e51b3008 	ldr	r3, [fp, #-8]
  1384b0:	e2432001 	sub	r2, r3, #1
  1384b4:	e50b2008 	str	r2, [fp, #-8]
  1384b8:	e3530000 	cmp	r3, #0
  1384bc:	1affffd9 	bne	138428 <PHY_StartNegotiation+0x94>
                    }
                }
            }
        }
    }
    return kStatus_Success;
  1384c0:	e3a03000 	mov	r3, #0
}
  1384c4:	e1a00003 	mov	r0, r3
  1384c8:	e24bd004 	sub	sp, fp, #4
  1384cc:	e8bd8800 	pop	{fp, pc}

001384d0 <PHY_Init>:

status_t PHY_Init(ENET_Type *base, uint32_t phyAddr, uint32_t srcClock_Hz,uint32_t phy_id)
{
  1384d0:	e92d4800 	push	{fp, lr}
  1384d4:	e28db004 	add	fp, sp, #4
  1384d8:	e24dd020 	sub	sp, sp, #32
  1384dc:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  1384e0:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  1384e4:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  1384e8:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    uint32_t counter = PHY_TIMEOUT_COUNT;
  1384ec:	e3e034fb 	mvn	r3, #-83886080	; 0xfb000000
  1384f0:	e50b3008 	str	r3, [fp, #-8]
    uint32_t idReg = 0;
  1384f4:	e3a03000 	mov	r3, #0
  1384f8:	e50b3010 	str	r3, [fp, #-16]
    status_t result = kStatus_Success;
  1384fc:	e3a03000 	mov	r3, #0
  138500:	e50b300c 	str	r3, [fp, #-12]

    ENET_SetSMI(base, srcClock_Hz, false);
  138504:	e3a02000 	mov	r2, #0
  138508:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
  13850c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  138510:	ebfffa3c 	bl	136e08 <ENET_SetSMI>
    PHY_Read(base, phyAddr, PHY_ID1_REG, &idReg);
  138514:	e24b3010 	sub	r3, fp, #16
  138518:	e3a02002 	mov	r2, #2
  13851c:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  138520:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  138524:	eb000048 	bl	13864c <PHY_Read>
    while ((idReg != phy_id) && (counter != 0))
  138528:	ea000007 	b	13854c <PHY_Init+0x7c>
    {
        PHY_Read(base, phyAddr, PHY_ID1_REG, &idReg);
  13852c:	e24b3010 	sub	r3, fp, #16
  138530:	e3a02002 	mov	r2, #2
  138534:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  138538:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  13853c:	eb000042 	bl	13864c <PHY_Read>
        counter --;
  138540:	e51b3008 	ldr	r3, [fp, #-8]
  138544:	e2433001 	sub	r3, r3, #1
  138548:	e50b3008 	str	r3, [fp, #-8]
    while ((idReg != phy_id) && (counter != 0))
  13854c:	e51b3010 	ldr	r3, [fp, #-16]
  138550:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
  138554:	e1520003 	cmp	r2, r3
  138558:	0a000002 	beq	138568 <PHY_Init+0x98>
  13855c:	e51b3008 	ldr	r3, [fp, #-8]
  138560:	e3530000 	cmp	r3, #0
  138564:	1afffff0 	bne	13852c <PHY_Init+0x5c>
    }
    if (!counter)
  138568:	e51b3008 	ldr	r3, [fp, #-8]
  13856c:	e3530000 	cmp	r3, #0
  138570:	1a000001 	bne	13857c <PHY_Init+0xac>
    {
        return kStatus_Fail;
  138574:	e3a03001 	mov	r3, #1
  138578:	ea000002 	b	138588 <PHY_Init+0xb8>
    }
    /* Reset PHY. */
    counter = PHY_TIMEOUT_COUNT;
  13857c:	e3e034fb 	mvn	r3, #-83886080	; 0xfb000000
  138580:	e50b3008 	str	r3, [fp, #-8]
    return result;
  138584:	e51b300c 	ldr	r3, [fp, #-12]
}
  138588:	e1a00003 	mov	r0, r3
  13858c:	e24bd004 	sub	sp, fp, #4
  138590:	e8bd8800 	pop	{fp, pc}

00138594 <PHY_Write>:

status_t PHY_Write(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, uint32_t data)
{
  138594:	e92d4800 	push	{fp, lr}
  138598:	e28db004 	add	fp, sp, #4
  13859c:	e24dd020 	sub	sp, sp, #32
  1385a0:	e50b0010 	str	r0, [fp, #-16]
  1385a4:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1385a8:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  1385ac:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    uint32_t counter;

    /* Clear the SMI interrupt event. */
    ENET_ClearInterruptStatus(base, ENET_EIR_MII_MASK);
  1385b0:	e3a01502 	mov	r1, #8388608	; 0x800000
  1385b4:	e51b0010 	ldr	r0, [fp, #-16]
  1385b8:	ebffff44 	bl	1382d0 <ENET_ClearInterruptStatus>

    /* Starts a SMI write command. */
    ENET_StartSMIWrite(base, phyAddr, phyReg, kENET_MiiWriteValidFrame, data);
  1385bc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  1385c0:	e58d3000 	str	r3, [sp]
  1385c4:	e3a03001 	mov	r3, #1
  1385c8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1385cc:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1385d0:	e51b0010 	ldr	r0, [fp, #-16]
  1385d4:	ebfffa4a 	bl	136f04 <ENET_StartSMIWrite>

    /* Wait for SMI complete. */
    for (counter = PHY_TIMEOUT_COUNT; counter > 0; counter--)
  1385d8:	e3e034fb 	mvn	r3, #-83886080	; 0xfb000000
  1385dc:	e50b3008 	str	r3, [fp, #-8]
  1385e0:	ea000008 	b	138608 <PHY_Write+0x74>
    {
        if (ENET_GetInterruptStatus(base) & ENET_EIR_MII_MASK)
  1385e4:	e51b0010 	ldr	r0, [fp, #-16]
  1385e8:	ebffff2e 	bl	1382a8 <ENET_GetInterruptStatus>
  1385ec:	e1a03000 	mov	r3, r0
  1385f0:	e2033502 	and	r3, r3, #8388608	; 0x800000
  1385f4:	e3530000 	cmp	r3, #0
  1385f8:	1a000006 	bne	138618 <PHY_Write+0x84>
    for (counter = PHY_TIMEOUT_COUNT; counter > 0; counter--)
  1385fc:	e51b3008 	ldr	r3, [fp, #-8]
  138600:	e2433001 	sub	r3, r3, #1
  138604:	e50b3008 	str	r3, [fp, #-8]
  138608:	e51b3008 	ldr	r3, [fp, #-8]
  13860c:	e3530000 	cmp	r3, #0
  138610:	1afffff3 	bne	1385e4 <PHY_Write+0x50>
  138614:	ea000000 	b	13861c <PHY_Write+0x88>
        {
            break;
  138618:	e320f000 	nop	{0}
        }
    }

    /* Check for timeout. */
    if (!counter)
  13861c:	e51b3008 	ldr	r3, [fp, #-8]
  138620:	e3530000 	cmp	r3, #0
  138624:	1a000001 	bne	138630 <PHY_Write+0x9c>
    {
        return kStatus_PHY_SMIVisitTimeout;
  138628:	e3013005 	movw	r3, #4101	; 0x1005
  13862c:	ea000003 	b	138640 <PHY_Write+0xac>
    }

    /* Clear MII interrupt event. */
    ENET_ClearInterruptStatus(base, ENET_EIR_MII_MASK);
  138630:	e3a01502 	mov	r1, #8388608	; 0x800000
  138634:	e51b0010 	ldr	r0, [fp, #-16]
  138638:	ebffff24 	bl	1382d0 <ENET_ClearInterruptStatus>

    return kStatus_Success;
  13863c:	e3a03000 	mov	r3, #0
}
  138640:	e1a00003 	mov	r0, r3
  138644:	e24bd004 	sub	sp, fp, #4
  138648:	e8bd8800 	pop	{fp, pc}

0013864c <PHY_Read>:

status_t PHY_Read(ENET_Type *base, uint32_t phyAddr, uint32_t phyReg, uint32_t *dataPtr)
{
  13864c:	e92d4800 	push	{fp, lr}
  138650:	e28db004 	add	fp, sp, #4
  138654:	e24dd018 	sub	sp, sp, #24
  138658:	e50b0010 	str	r0, [fp, #-16]
  13865c:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  138660:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  138664:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    RT_ASSERT(dataPtr);
  138668:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  13866c:	e3530000 	cmp	r3, #0
  138670:	1a000005 	bne	13868c <PHY_Read+0x40>
  138674:	e3a020d0 	mov	r2, #208	; 0xd0
  138678:	e30a1650 	movw	r1, #42576	; 0xa650
  13867c:	e3401014 	movt	r1, #20
  138680:	e30a0638 	movw	r0, #42552	; 0xa638
  138684:	e3400014 	movt	r0, #20
  138688:	ebff2bc2 	bl	103598 <rt_assert_handler>

    uint32_t counter;

    /* Clear the MII interrupt event. */
    ENET_ClearInterruptStatus(base, ENET_EIR_MII_MASK);
  13868c:	e3a01502 	mov	r1, #8388608	; 0x800000
  138690:	e51b0010 	ldr	r0, [fp, #-16]
  138694:	ebffff0d 	bl	1382d0 <ENET_ClearInterruptStatus>

    /* Starts a SMI read command operation. */
    ENET_StartSMIRead(base, phyAddr, phyReg, kENET_MiiReadValidFrame);
  138698:	e3a03002 	mov	r3, #2
  13869c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
  1386a0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1386a4:	e51b0010 	ldr	r0, [fp, #-16]
  1386a8:	ebfffa36 	bl	136f88 <ENET_StartSMIRead>

    /* Wait for MII complete. */
    for (counter = PHY_TIMEOUT_COUNT; counter > 0; counter--)
  1386ac:	e3e034fb 	mvn	r3, #-83886080	; 0xfb000000
  1386b0:	e50b3008 	str	r3, [fp, #-8]
  1386b4:	ea000008 	b	1386dc <PHY_Read+0x90>
    {
        if (ENET_GetInterruptStatus(base) & ENET_EIR_MII_MASK)
  1386b8:	e51b0010 	ldr	r0, [fp, #-16]
  1386bc:	ebfffef9 	bl	1382a8 <ENET_GetInterruptStatus>
  1386c0:	e1a03000 	mov	r3, r0
  1386c4:	e2033502 	and	r3, r3, #8388608	; 0x800000
  1386c8:	e3530000 	cmp	r3, #0
  1386cc:	1a000006 	bne	1386ec <PHY_Read+0xa0>
    for (counter = PHY_TIMEOUT_COUNT; counter > 0; counter--)
  1386d0:	e51b3008 	ldr	r3, [fp, #-8]
  1386d4:	e2433001 	sub	r3, r3, #1
  1386d8:	e50b3008 	str	r3, [fp, #-8]
  1386dc:	e51b3008 	ldr	r3, [fp, #-8]
  1386e0:	e3530000 	cmp	r3, #0
  1386e4:	1afffff3 	bne	1386b8 <PHY_Read+0x6c>
  1386e8:	ea000000 	b	1386f0 <PHY_Read+0xa4>
        {
            break;
  1386ec:	e320f000 	nop	{0}
        }
    }

    /* Check for timeout. */
    if (!counter)
  1386f0:	e51b3008 	ldr	r3, [fp, #-8]
  1386f4:	e3530000 	cmp	r3, #0
  1386f8:	1a000001 	bne	138704 <PHY_Read+0xb8>
    {
        return kStatus_PHY_SMIVisitTimeout;
  1386fc:	e3013005 	movw	r3, #4101	; 0x1005
  138700:	ea000008 	b	138728 <PHY_Read+0xdc>
    }

    /* Get data from MII register. */
    *dataPtr = ENET_ReadSMIData(base);
  138704:	e51b0010 	ldr	r0, [fp, #-16]
  138708:	ebfffedb 	bl	13827c <ENET_ReadSMIData>
  13870c:	e1a02000 	mov	r2, r0
  138710:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
  138714:	e5832000 	str	r2, [r3]

    /* Clear MII interrupt event. */
    ENET_ClearInterruptStatus(base, ENET_EIR_MII_MASK);
  138718:	e3a01502 	mov	r1, #8388608	; 0x800000
  13871c:	e51b0010 	ldr	r0, [fp, #-16]
  138720:	ebfffeea 	bl	1382d0 <ENET_ClearInterruptStatus>

    return kStatus_Success;
  138724:	e3a03000 	mov	r3, #0
}
  138728:	e1a00003 	mov	r0, r3
  13872c:	e24bd004 	sub	sp, fp, #4
  138730:	e8bd8800 	pop	{fp, pc}

00138734 <PHY_EnableLoopback>:

status_t PHY_EnableLoopback(ENET_Type *base, uint32_t phyAddr, phy_loop_t mode, bool enable)
{
  138734:	e92d4800 	push	{fp, lr}
  138738:	e28db004 	add	fp, sp, #4
  13873c:	e24dd018 	sub	sp, sp, #24
  138740:	e50b0010 	str	r0, [fp, #-16]
  138744:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  138748:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  13874c:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7
    status_t result;
    uint32_t data = 0;
  138750:	e3a03000 	mov	r3, #0
  138754:	e50b300c 	str	r3, [fp, #-12]

    /* Set the loop mode. */
    if (enable)
  138758:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
  13875c:	e3530000 	cmp	r3, #0
  138760:	0a000024 	beq	1387f8 <PHY_EnableLoopback+0xc4>
    {
        if (mode == kPHY_LocalLoop)
  138764:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  138768:	e3530000 	cmp	r3, #0
  13876c:	1a000010 	bne	1387b4 <PHY_EnableLoopback+0x80>
        {
            /* First read the current status in control register. */
            result = PHY_Read(base, phyAddr, PHY_BASICCONTROL_REG, &data);
  138770:	e24b300c 	sub	r3, fp, #12
  138774:	e3a02000 	mov	r2, #0
  138778:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  13877c:	e51b0010 	ldr	r0, [fp, #-16]
  138780:	ebffffb1 	bl	13864c <PHY_Read>
  138784:	e50b0008 	str	r0, [fp, #-8]
            if (result == kStatus_Success)
  138788:	e51b3008 	ldr	r3, [fp, #-8]
  13878c:	e3530000 	cmp	r3, #0
  138790:	1a00003d 	bne	13888c <PHY_EnableLoopback+0x158>
            {
                return PHY_Write(base, phyAddr, PHY_BASICCONTROL_REG, (data | PHY_BCTL_LOOP_MASK));
  138794:	e51b300c 	ldr	r3, [fp, #-12]
  138798:	e3833901 	orr	r3, r3, #16384	; 0x4000
  13879c:	e3a02000 	mov	r2, #0
  1387a0:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1387a4:	e51b0010 	ldr	r0, [fp, #-16]
  1387a8:	ebffff79 	bl	138594 <PHY_Write>
  1387ac:	e1a03000 	mov	r3, r0
  1387b0:	ea000036 	b	138890 <PHY_EnableLoopback+0x15c>
            }
        }
        else
        {
            /* First read the current status in control register. */
            result = PHY_Read(base, phyAddr, PHY_CONTROL2_REG, &data);
  1387b4:	e24b300c 	sub	r3, fp, #12
  1387b8:	e3a0201f 	mov	r2, #31
  1387bc:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1387c0:	e51b0010 	ldr	r0, [fp, #-16]
  1387c4:	ebffffa0 	bl	13864c <PHY_Read>
  1387c8:	e50b0008 	str	r0, [fp, #-8]
            if (result == kStatus_Success)
  1387cc:	e51b3008 	ldr	r3, [fp, #-8]
  1387d0:	e3530000 	cmp	r3, #0
  1387d4:	1a00002c 	bne	13888c <PHY_EnableLoopback+0x158>
            {
                return PHY_Write(base, phyAddr, PHY_CONTROL2_REG, (data | PHY_CTL2_REMOTELOOP_MASK));
  1387d8:	e51b300c 	ldr	r3, [fp, #-12]
  1387dc:	e3833004 	orr	r3, r3, #4
  1387e0:	e3a0201f 	mov	r2, #31
  1387e4:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1387e8:	e51b0010 	ldr	r0, [fp, #-16]
  1387ec:	ebffff68 	bl	138594 <PHY_Write>
  1387f0:	e1a03000 	mov	r3, r0
  1387f4:	ea000025 	b	138890 <PHY_EnableLoopback+0x15c>
        }
    }
    else
    {
        /* Disable the loop mode. */
        if (mode == kPHY_LocalLoop)
  1387f8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1387fc:	e3530000 	cmp	r3, #0
  138800:	1a000010 	bne	138848 <PHY_EnableLoopback+0x114>
        {
            /* First read the current status in the basic control register. */
            result = PHY_Read(base, phyAddr, PHY_BASICCONTROL_REG, &data);
  138804:	e24b300c 	sub	r3, fp, #12
  138808:	e3a02000 	mov	r2, #0
  13880c:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  138810:	e51b0010 	ldr	r0, [fp, #-16]
  138814:	ebffff8c 	bl	13864c <PHY_Read>
  138818:	e50b0008 	str	r0, [fp, #-8]
            if (result == kStatus_Success)
  13881c:	e51b3008 	ldr	r3, [fp, #-8]
  138820:	e3530000 	cmp	r3, #0
  138824:	1a000018 	bne	13888c <PHY_EnableLoopback+0x158>
            {
                return PHY_Write(base, phyAddr, PHY_BASICCONTROL_REG, (data & ~PHY_BCTL_LOOP_MASK));
  138828:	e51b300c 	ldr	r3, [fp, #-12]
  13882c:	e3c33901 	bic	r3, r3, #16384	; 0x4000
  138830:	e3a02000 	mov	r2, #0
  138834:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  138838:	e51b0010 	ldr	r0, [fp, #-16]
  13883c:	ebffff54 	bl	138594 <PHY_Write>
  138840:	e1a03000 	mov	r3, r0
  138844:	ea000011 	b	138890 <PHY_EnableLoopback+0x15c>
            }
        }
        else
        {
            /* First read the current status in control one register. */
            result = PHY_Read(base, phyAddr, PHY_CONTROL2_REG, &data);
  138848:	e24b300c 	sub	r3, fp, #12
  13884c:	e3a0201f 	mov	r2, #31
  138850:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  138854:	e51b0010 	ldr	r0, [fp, #-16]
  138858:	ebffff7b 	bl	13864c <PHY_Read>
  13885c:	e50b0008 	str	r0, [fp, #-8]
            if (result == kStatus_Success)
  138860:	e51b3008 	ldr	r3, [fp, #-8]
  138864:	e3530000 	cmp	r3, #0
  138868:	1a000007 	bne	13888c <PHY_EnableLoopback+0x158>
            {
                return PHY_Write(base, phyAddr, PHY_CONTROL2_REG, (data & ~PHY_CTL2_REMOTELOOP_MASK));
  13886c:	e51b300c 	ldr	r3, [fp, #-12]
  138870:	e3c33004 	bic	r3, r3, #4
  138874:	e3a0201f 	mov	r2, #31
  138878:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  13887c:	e51b0010 	ldr	r0, [fp, #-16]
  138880:	ebffff43 	bl	138594 <PHY_Write>
  138884:	e1a03000 	mov	r3, r0
  138888:	ea000000 	b	138890 <PHY_EnableLoopback+0x15c>
            }
        }
    }
    return result;
  13888c:	e51b3008 	ldr	r3, [fp, #-8]
}
  138890:	e1a00003 	mov	r0, r3
  138894:	e24bd004 	sub	sp, fp, #4
  138898:	e8bd8800 	pop	{fp, pc}

0013889c <PHY_GetLinkStatus>:

status_t PHY_GetLinkStatus(ENET_Type *base, uint32_t phyAddr, bool *status)
{
  13889c:	e92d4800 	push	{fp, lr}
  1388a0:	e28db004 	add	fp, sp, #4
  1388a4:	e24dd018 	sub	sp, sp, #24
  1388a8:	e50b0010 	str	r0, [fp, #-16]
  1388ac:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
  1388b0:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    RT_ASSERT(status);
  1388b4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  1388b8:	e3530000 	cmp	r3, #0
  1388bc:	1a000005 	bne	1388d8 <PHY_GetLinkStatus+0x3c>
  1388c0:	e3a02f4a 	mov	r2, #296	; 0x128
  1388c4:	e30a165c 	movw	r1, #42588	; 0xa65c
  1388c8:	e3401014 	movt	r1, #20
  1388cc:	e30a0640 	movw	r0, #42560	; 0xa640
  1388d0:	e3400014 	movt	r0, #20
  1388d4:	ebff2b2f 	bl	103598 <rt_assert_handler>

    status_t result = kStatus_Success;
  1388d8:	e3a03000 	mov	r3, #0
  1388dc:	e50b3008 	str	r3, [fp, #-8]
    uint32_t data;

    /* Read the basic status register. */
    result = PHY_Read(base, phyAddr, PHY_BASICSTATUS_REG, &data);
  1388e0:	e24b300c 	sub	r3, fp, #12
  1388e4:	e3a02001 	mov	r2, #1
  1388e8:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
  1388ec:	e51b0010 	ldr	r0, [fp, #-16]
  1388f0:	ebffff55 	bl	13864c <PHY_Read>
  1388f4:	e50b0008 	str	r0, [fp, #-8]
    if (result == kStatus_Success)
  1388f8:	e51b3008 	ldr	r3, [fp, #-8]
  1388fc:	e3530000 	cmp	r3, #0
  138900:	1a00000a 	bne	138930 <PHY_GetLinkStatus+0x94>
    {
        if (!(PHY_BSTATUS_LINKSTATUS_MASK & data))
  138904:	e51b300c 	ldr	r3, [fp, #-12]
  138908:	e2033004 	and	r3, r3, #4
  13890c:	e3530000 	cmp	r3, #0
  138910:	1a000003 	bne	138924 <PHY_GetLinkStatus+0x88>
        {
            /* link down. */
            *status = false;
  138914:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  138918:	e3a02000 	mov	r2, #0
  13891c:	e5c32000 	strb	r2, [r3]
  138920:	ea000002 	b	138930 <PHY_GetLinkStatus+0x94>
        }
        else
        {
            /* link up. */
            *status = true;
  138924:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
  138928:	e3a02001 	mov	r2, #1
  13892c:	e5c32000 	strb	r2, [r3]
        }
    }
    return result;
  138930:	e51b3008 	ldr	r3, [fp, #-8]
}
  138934:	e1a00003 	mov	r0, r3
  138938:	e24bd004 	sub	sp, fp, #4
  13893c:	e8bd8800 	pop	{fp, pc}

00138940 <PHY_GetLinkSpeedDuplex>:

status_t PHY_GetLinkSpeedDuplex(ENET_Type *base, uint32_t phyAddr, phy_speed_t *speed, phy_duplex_t *duplex)
{
  138940:	e92d4800 	push	{fp, lr}
  138944:	e28db004 	add	fp, sp, #4
  138948:	e24dd020 	sub	sp, sp, #32
  13894c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  138950:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
  138954:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
  138958:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    RT_ASSERT(duplex);
  13895c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  138960:	e3530000 	cmp	r3, #0
  138964:	1a000005 	bne	138980 <PHY_GetLinkSpeedDuplex+0x40>
  138968:	e3002141 	movw	r2, #321	; 0x141
  13896c:	e30a1670 	movw	r1, #42608	; 0xa670
  138970:	e3401014 	movt	r1, #20
  138974:	e30a0648 	movw	r0, #42568	; 0xa648
  138978:	e3400014 	movt	r0, #20
  13897c:	ebff2b05 	bl	103598 <rt_assert_handler>

    status_t result = kStatus_Success;
  138980:	e3a03000 	mov	r3, #0
  138984:	e50b3008 	str	r3, [fp, #-8]
    uint32_t data, ctlReg;

    /* Read the control two register. */

    result = PHY_Read(base, phyAddr, 31, &ctlReg);
  138988:	e24b3010 	sub	r3, fp, #16
  13898c:	e3a0201f 	mov	r2, #31
  138990:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
  138994:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
  138998:	ebffff2b 	bl	13864c <PHY_Read>
  13899c:	e50b0008 	str	r0, [fp, #-8]

    data = ((ctlReg>>2) & 0x7);
  1389a0:	e51b3010 	ldr	r3, [fp, #-16]
  1389a4:	e1a03123 	lsr	r3, r3, #2
  1389a8:	e2033007 	and	r3, r3, #7
  1389ac:	e50b300c 	str	r3, [fp, #-12]
    switch (data)
  1389b0:	e51b300c 	ldr	r3, [fp, #-12]
  1389b4:	e2433001 	sub	r3, r3, #1
  1389b8:	e3530005 	cmp	r3, #5
  1389bc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  1389c0:	ea000021 	b	138a4c <PHY_GetLinkSpeedDuplex+0x10c>
  1389c4:	001389dc 	.word	0x001389dc
  1389c8:	00138a14 	.word	0x00138a14
  1389cc:	00138a4c 	.word	0x00138a4c
  1389d0:	00138a4c 	.word	0x00138a4c
  1389d4:	001389f8 	.word	0x001389f8
  1389d8:	00138a30 	.word	0x00138a30
    {
        case 1:
            *speed = kPHY_Speed10M;
  1389dc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1389e0:	e3a02000 	mov	r2, #0
  1389e4:	e5832000 	str	r2, [r3]
            *duplex = kPHY_HalfDuplex;
  1389e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  1389ec:	e3a02000 	mov	r2, #0
  1389f0:	e5832000 	str	r2, [r3]
            break;
  1389f4:	ea00001a 	b	138a64 <PHY_GetLinkSpeedDuplex+0x124>
        case 5:
            *speed = kPHY_Speed10M;
  1389f8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  1389fc:	e3a02000 	mov	r2, #0
  138a00:	e5832000 	str	r2, [r3]
            *duplex = kPHY_FullDuplex;
  138a04:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  138a08:	e3a02001 	mov	r2, #1
  138a0c:	e5832000 	str	r2, [r3]
            break;
  138a10:	ea000013 	b	138a64 <PHY_GetLinkSpeedDuplex+0x124>
        case 2:
            *speed = kPHY_Speed100M;
  138a14:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  138a18:	e3a02001 	mov	r2, #1
  138a1c:	e5832000 	str	r2, [r3]
            *duplex = kPHY_HalfDuplex;
  138a20:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  138a24:	e3a02000 	mov	r2, #0
  138a28:	e5832000 	str	r2, [r3]
            break;
  138a2c:	ea00000c 	b	138a64 <PHY_GetLinkSpeedDuplex+0x124>
        case 6:
            *speed = kPHY_Speed100M;
  138a30:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  138a34:	e3a02001 	mov	r2, #1
  138a38:	e5832000 	str	r2, [r3]
            *duplex = kPHY_FullDuplex;
  138a3c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  138a40:	e3a02001 	mov	r2, #1
  138a44:	e5832000 	str	r2, [r3]
            break;
  138a48:	ea000005 	b	138a64 <PHY_GetLinkSpeedDuplex+0x124>
        default:
            *speed = kPHY_Speed100M;
  138a4c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
  138a50:	e3a02001 	mov	r2, #1
  138a54:	e5832000 	str	r2, [r3]
            *duplex = kPHY_FullDuplex;
  138a58:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
  138a5c:	e3a02001 	mov	r2, #1
  138a60:	e5832000 	str	r2, [r3]
    }

    return result;
  138a64:	e51b3008 	ldr	r3, [fp, #-8]
}
  138a68:	e1a00003 	mov	r0, r3
  138a6c:	e24bd004 	sub	sp, fp, #4
  138a70:	e8bd8800 	pop	{fp, pc}

00138a74 <__udivsi3>:
  138a74:	e2512001 	subs	r2, r1, #1
  138a78:	012fff1e 	bxeq	lr
  138a7c:	3a000074 	bcc	138c54 <__udivsi3+0x1e0>
  138a80:	e1500001 	cmp	r0, r1
  138a84:	9a00006b 	bls	138c38 <__udivsi3+0x1c4>
  138a88:	e1110002 	tst	r1, r2
  138a8c:	0a00006c 	beq	138c44 <__udivsi3+0x1d0>
  138a90:	e16f3f10 	clz	r3, r0
  138a94:	e16f2f11 	clz	r2, r1
  138a98:	e0423003 	sub	r3, r2, r3
  138a9c:	e273301f 	rsbs	r3, r3, #31
  138aa0:	10833083 	addne	r3, r3, r3, lsl #1
  138aa4:	e3a02000 	mov	r2, #0
  138aa8:	108ff103 	addne	pc, pc, r3, lsl #2
  138aac:	e1a00000 	nop			; (mov r0, r0)
  138ab0:	e1500f81 	cmp	r0, r1, lsl #31
  138ab4:	e0a22002 	adc	r2, r2, r2
  138ab8:	20400f81 	subcs	r0, r0, r1, lsl #31
  138abc:	e1500f01 	cmp	r0, r1, lsl #30
  138ac0:	e0a22002 	adc	r2, r2, r2
  138ac4:	20400f01 	subcs	r0, r0, r1, lsl #30
  138ac8:	e1500e81 	cmp	r0, r1, lsl #29
  138acc:	e0a22002 	adc	r2, r2, r2
  138ad0:	20400e81 	subcs	r0, r0, r1, lsl #29
  138ad4:	e1500e01 	cmp	r0, r1, lsl #28
  138ad8:	e0a22002 	adc	r2, r2, r2
  138adc:	20400e01 	subcs	r0, r0, r1, lsl #28
  138ae0:	e1500d81 	cmp	r0, r1, lsl #27
  138ae4:	e0a22002 	adc	r2, r2, r2
  138ae8:	20400d81 	subcs	r0, r0, r1, lsl #27
  138aec:	e1500d01 	cmp	r0, r1, lsl #26
  138af0:	e0a22002 	adc	r2, r2, r2
  138af4:	20400d01 	subcs	r0, r0, r1, lsl #26
  138af8:	e1500c81 	cmp	r0, r1, lsl #25
  138afc:	e0a22002 	adc	r2, r2, r2
  138b00:	20400c81 	subcs	r0, r0, r1, lsl #25
  138b04:	e1500c01 	cmp	r0, r1, lsl #24
  138b08:	e0a22002 	adc	r2, r2, r2
  138b0c:	20400c01 	subcs	r0, r0, r1, lsl #24
  138b10:	e1500b81 	cmp	r0, r1, lsl #23
  138b14:	e0a22002 	adc	r2, r2, r2
  138b18:	20400b81 	subcs	r0, r0, r1, lsl #23
  138b1c:	e1500b01 	cmp	r0, r1, lsl #22
  138b20:	e0a22002 	adc	r2, r2, r2
  138b24:	20400b01 	subcs	r0, r0, r1, lsl #22
  138b28:	e1500a81 	cmp	r0, r1, lsl #21
  138b2c:	e0a22002 	adc	r2, r2, r2
  138b30:	20400a81 	subcs	r0, r0, r1, lsl #21
  138b34:	e1500a01 	cmp	r0, r1, lsl #20
  138b38:	e0a22002 	adc	r2, r2, r2
  138b3c:	20400a01 	subcs	r0, r0, r1, lsl #20
  138b40:	e1500981 	cmp	r0, r1, lsl #19
  138b44:	e0a22002 	adc	r2, r2, r2
  138b48:	20400981 	subcs	r0, r0, r1, lsl #19
  138b4c:	e1500901 	cmp	r0, r1, lsl #18
  138b50:	e0a22002 	adc	r2, r2, r2
  138b54:	20400901 	subcs	r0, r0, r1, lsl #18
  138b58:	e1500881 	cmp	r0, r1, lsl #17
  138b5c:	e0a22002 	adc	r2, r2, r2
  138b60:	20400881 	subcs	r0, r0, r1, lsl #17
  138b64:	e1500801 	cmp	r0, r1, lsl #16
  138b68:	e0a22002 	adc	r2, r2, r2
  138b6c:	20400801 	subcs	r0, r0, r1, lsl #16
  138b70:	e1500781 	cmp	r0, r1, lsl #15
  138b74:	e0a22002 	adc	r2, r2, r2
  138b78:	20400781 	subcs	r0, r0, r1, lsl #15
  138b7c:	e1500701 	cmp	r0, r1, lsl #14
  138b80:	e0a22002 	adc	r2, r2, r2
  138b84:	20400701 	subcs	r0, r0, r1, lsl #14
  138b88:	e1500681 	cmp	r0, r1, lsl #13
  138b8c:	e0a22002 	adc	r2, r2, r2
  138b90:	20400681 	subcs	r0, r0, r1, lsl #13
  138b94:	e1500601 	cmp	r0, r1, lsl #12
  138b98:	e0a22002 	adc	r2, r2, r2
  138b9c:	20400601 	subcs	r0, r0, r1, lsl #12
  138ba0:	e1500581 	cmp	r0, r1, lsl #11
  138ba4:	e0a22002 	adc	r2, r2, r2
  138ba8:	20400581 	subcs	r0, r0, r1, lsl #11
  138bac:	e1500501 	cmp	r0, r1, lsl #10
  138bb0:	e0a22002 	adc	r2, r2, r2
  138bb4:	20400501 	subcs	r0, r0, r1, lsl #10
  138bb8:	e1500481 	cmp	r0, r1, lsl #9
  138bbc:	e0a22002 	adc	r2, r2, r2
  138bc0:	20400481 	subcs	r0, r0, r1, lsl #9
  138bc4:	e1500401 	cmp	r0, r1, lsl #8
  138bc8:	e0a22002 	adc	r2, r2, r2
  138bcc:	20400401 	subcs	r0, r0, r1, lsl #8
  138bd0:	e1500381 	cmp	r0, r1, lsl #7
  138bd4:	e0a22002 	adc	r2, r2, r2
  138bd8:	20400381 	subcs	r0, r0, r1, lsl #7
  138bdc:	e1500301 	cmp	r0, r1, lsl #6
  138be0:	e0a22002 	adc	r2, r2, r2
  138be4:	20400301 	subcs	r0, r0, r1, lsl #6
  138be8:	e1500281 	cmp	r0, r1, lsl #5
  138bec:	e0a22002 	adc	r2, r2, r2
  138bf0:	20400281 	subcs	r0, r0, r1, lsl #5
  138bf4:	e1500201 	cmp	r0, r1, lsl #4
  138bf8:	e0a22002 	adc	r2, r2, r2
  138bfc:	20400201 	subcs	r0, r0, r1, lsl #4
  138c00:	e1500181 	cmp	r0, r1, lsl #3
  138c04:	e0a22002 	adc	r2, r2, r2
  138c08:	20400181 	subcs	r0, r0, r1, lsl #3
  138c0c:	e1500101 	cmp	r0, r1, lsl #2
  138c10:	e0a22002 	adc	r2, r2, r2
  138c14:	20400101 	subcs	r0, r0, r1, lsl #2
  138c18:	e1500081 	cmp	r0, r1, lsl #1
  138c1c:	e0a22002 	adc	r2, r2, r2
  138c20:	20400081 	subcs	r0, r0, r1, lsl #1
  138c24:	e1500001 	cmp	r0, r1
  138c28:	e0a22002 	adc	r2, r2, r2
  138c2c:	20400001 	subcs	r0, r0, r1
  138c30:	e1a00002 	mov	r0, r2
  138c34:	e12fff1e 	bx	lr
  138c38:	03a00001 	moveq	r0, #1
  138c3c:	13a00000 	movne	r0, #0
  138c40:	e12fff1e 	bx	lr
  138c44:	e16f2f11 	clz	r2, r1
  138c48:	e262201f 	rsb	r2, r2, #31
  138c4c:	e1a00230 	lsr	r0, r0, r2
  138c50:	e12fff1e 	bx	lr
  138c54:	e3500000 	cmp	r0, #0
  138c58:	13e00000 	mvnne	r0, #0
  138c5c:	ea000097 	b	138ec0 <__aeabi_idiv0>

00138c60 <__aeabi_uidivmod>:
  138c60:	e3510000 	cmp	r1, #0
  138c64:	0afffffa 	beq	138c54 <__udivsi3+0x1e0>
  138c68:	e92d4003 	push	{r0, r1, lr}
  138c6c:	ebffff80 	bl	138a74 <__udivsi3>
  138c70:	e8bd4006 	pop	{r1, r2, lr}
  138c74:	e0030092 	mul	r3, r2, r0
  138c78:	e0411003 	sub	r1, r1, r3
  138c7c:	e12fff1e 	bx	lr

00138c80 <__divsi3>:
  138c80:	e3510000 	cmp	r1, #0
  138c84:	0a000081 	beq	138e90 <.divsi3_skip_div0_test+0x208>

00138c88 <.divsi3_skip_div0_test>:
  138c88:	e020c001 	eor	ip, r0, r1
  138c8c:	42611000 	rsbmi	r1, r1, #0
  138c90:	e2512001 	subs	r2, r1, #1
  138c94:	0a000070 	beq	138e5c <.divsi3_skip_div0_test+0x1d4>
  138c98:	e1b03000 	movs	r3, r0
  138c9c:	42603000 	rsbmi	r3, r0, #0
  138ca0:	e1530001 	cmp	r3, r1
  138ca4:	9a00006f 	bls	138e68 <.divsi3_skip_div0_test+0x1e0>
  138ca8:	e1110002 	tst	r1, r2
  138cac:	0a000071 	beq	138e78 <.divsi3_skip_div0_test+0x1f0>
  138cb0:	e16f2f13 	clz	r2, r3
  138cb4:	e16f0f11 	clz	r0, r1
  138cb8:	e0402002 	sub	r2, r0, r2
  138cbc:	e272201f 	rsbs	r2, r2, #31
  138cc0:	10822082 	addne	r2, r2, r2, lsl #1
  138cc4:	e3a00000 	mov	r0, #0
  138cc8:	108ff102 	addne	pc, pc, r2, lsl #2
  138ccc:	e1a00000 	nop			; (mov r0, r0)
  138cd0:	e1530f81 	cmp	r3, r1, lsl #31
  138cd4:	e0a00000 	adc	r0, r0, r0
  138cd8:	20433f81 	subcs	r3, r3, r1, lsl #31
  138cdc:	e1530f01 	cmp	r3, r1, lsl #30
  138ce0:	e0a00000 	adc	r0, r0, r0
  138ce4:	20433f01 	subcs	r3, r3, r1, lsl #30
  138ce8:	e1530e81 	cmp	r3, r1, lsl #29
  138cec:	e0a00000 	adc	r0, r0, r0
  138cf0:	20433e81 	subcs	r3, r3, r1, lsl #29
  138cf4:	e1530e01 	cmp	r3, r1, lsl #28
  138cf8:	e0a00000 	adc	r0, r0, r0
  138cfc:	20433e01 	subcs	r3, r3, r1, lsl #28
  138d00:	e1530d81 	cmp	r3, r1, lsl #27
  138d04:	e0a00000 	adc	r0, r0, r0
  138d08:	20433d81 	subcs	r3, r3, r1, lsl #27
  138d0c:	e1530d01 	cmp	r3, r1, lsl #26
  138d10:	e0a00000 	adc	r0, r0, r0
  138d14:	20433d01 	subcs	r3, r3, r1, lsl #26
  138d18:	e1530c81 	cmp	r3, r1, lsl #25
  138d1c:	e0a00000 	adc	r0, r0, r0
  138d20:	20433c81 	subcs	r3, r3, r1, lsl #25
  138d24:	e1530c01 	cmp	r3, r1, lsl #24
  138d28:	e0a00000 	adc	r0, r0, r0
  138d2c:	20433c01 	subcs	r3, r3, r1, lsl #24
  138d30:	e1530b81 	cmp	r3, r1, lsl #23
  138d34:	e0a00000 	adc	r0, r0, r0
  138d38:	20433b81 	subcs	r3, r3, r1, lsl #23
  138d3c:	e1530b01 	cmp	r3, r1, lsl #22
  138d40:	e0a00000 	adc	r0, r0, r0
  138d44:	20433b01 	subcs	r3, r3, r1, lsl #22
  138d48:	e1530a81 	cmp	r3, r1, lsl #21
  138d4c:	e0a00000 	adc	r0, r0, r0
  138d50:	20433a81 	subcs	r3, r3, r1, lsl #21
  138d54:	e1530a01 	cmp	r3, r1, lsl #20
  138d58:	e0a00000 	adc	r0, r0, r0
  138d5c:	20433a01 	subcs	r3, r3, r1, lsl #20
  138d60:	e1530981 	cmp	r3, r1, lsl #19
  138d64:	e0a00000 	adc	r0, r0, r0
  138d68:	20433981 	subcs	r3, r3, r1, lsl #19
  138d6c:	e1530901 	cmp	r3, r1, lsl #18
  138d70:	e0a00000 	adc	r0, r0, r0
  138d74:	20433901 	subcs	r3, r3, r1, lsl #18
  138d78:	e1530881 	cmp	r3, r1, lsl #17
  138d7c:	e0a00000 	adc	r0, r0, r0
  138d80:	20433881 	subcs	r3, r3, r1, lsl #17
  138d84:	e1530801 	cmp	r3, r1, lsl #16
  138d88:	e0a00000 	adc	r0, r0, r0
  138d8c:	20433801 	subcs	r3, r3, r1, lsl #16
  138d90:	e1530781 	cmp	r3, r1, lsl #15
  138d94:	e0a00000 	adc	r0, r0, r0
  138d98:	20433781 	subcs	r3, r3, r1, lsl #15
  138d9c:	e1530701 	cmp	r3, r1, lsl #14
  138da0:	e0a00000 	adc	r0, r0, r0
  138da4:	20433701 	subcs	r3, r3, r1, lsl #14
  138da8:	e1530681 	cmp	r3, r1, lsl #13
  138dac:	e0a00000 	adc	r0, r0, r0
  138db0:	20433681 	subcs	r3, r3, r1, lsl #13
  138db4:	e1530601 	cmp	r3, r1, lsl #12
  138db8:	e0a00000 	adc	r0, r0, r0
  138dbc:	20433601 	subcs	r3, r3, r1, lsl #12
  138dc0:	e1530581 	cmp	r3, r1, lsl #11
  138dc4:	e0a00000 	adc	r0, r0, r0
  138dc8:	20433581 	subcs	r3, r3, r1, lsl #11
  138dcc:	e1530501 	cmp	r3, r1, lsl #10
  138dd0:	e0a00000 	adc	r0, r0, r0
  138dd4:	20433501 	subcs	r3, r3, r1, lsl #10
  138dd8:	e1530481 	cmp	r3, r1, lsl #9
  138ddc:	e0a00000 	adc	r0, r0, r0
  138de0:	20433481 	subcs	r3, r3, r1, lsl #9
  138de4:	e1530401 	cmp	r3, r1, lsl #8
  138de8:	e0a00000 	adc	r0, r0, r0
  138dec:	20433401 	subcs	r3, r3, r1, lsl #8
  138df0:	e1530381 	cmp	r3, r1, lsl #7
  138df4:	e0a00000 	adc	r0, r0, r0
  138df8:	20433381 	subcs	r3, r3, r1, lsl #7
  138dfc:	e1530301 	cmp	r3, r1, lsl #6
  138e00:	e0a00000 	adc	r0, r0, r0
  138e04:	20433301 	subcs	r3, r3, r1, lsl #6
  138e08:	e1530281 	cmp	r3, r1, lsl #5
  138e0c:	e0a00000 	adc	r0, r0, r0
  138e10:	20433281 	subcs	r3, r3, r1, lsl #5
  138e14:	e1530201 	cmp	r3, r1, lsl #4
  138e18:	e0a00000 	adc	r0, r0, r0
  138e1c:	20433201 	subcs	r3, r3, r1, lsl #4
  138e20:	e1530181 	cmp	r3, r1, lsl #3
  138e24:	e0a00000 	adc	r0, r0, r0
  138e28:	20433181 	subcs	r3, r3, r1, lsl #3
  138e2c:	e1530101 	cmp	r3, r1, lsl #2
  138e30:	e0a00000 	adc	r0, r0, r0
  138e34:	20433101 	subcs	r3, r3, r1, lsl #2
  138e38:	e1530081 	cmp	r3, r1, lsl #1
  138e3c:	e0a00000 	adc	r0, r0, r0
  138e40:	20433081 	subcs	r3, r3, r1, lsl #1
  138e44:	e1530001 	cmp	r3, r1
  138e48:	e0a00000 	adc	r0, r0, r0
  138e4c:	20433001 	subcs	r3, r3, r1
  138e50:	e35c0000 	cmp	ip, #0
  138e54:	42600000 	rsbmi	r0, r0, #0
  138e58:	e12fff1e 	bx	lr
  138e5c:	e13c0000 	teq	ip, r0
  138e60:	42600000 	rsbmi	r0, r0, #0
  138e64:	e12fff1e 	bx	lr
  138e68:	33a00000 	movcc	r0, #0
  138e6c:	01a00fcc 	asreq	r0, ip, #31
  138e70:	03800001 	orreq	r0, r0, #1
  138e74:	e12fff1e 	bx	lr
  138e78:	e16f2f11 	clz	r2, r1
  138e7c:	e262201f 	rsb	r2, r2, #31
  138e80:	e35c0000 	cmp	ip, #0
  138e84:	e1a00233 	lsr	r0, r3, r2
  138e88:	42600000 	rsbmi	r0, r0, #0
  138e8c:	e12fff1e 	bx	lr
  138e90:	e3500000 	cmp	r0, #0
  138e94:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
  138e98:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
  138e9c:	ea000007 	b	138ec0 <__aeabi_idiv0>

00138ea0 <__aeabi_idivmod>:
  138ea0:	e3510000 	cmp	r1, #0
  138ea4:	0afffff9 	beq	138e90 <.divsi3_skip_div0_test+0x208>
  138ea8:	e92d4003 	push	{r0, r1, lr}
  138eac:	ebffff75 	bl	138c88 <.divsi3_skip_div0_test>
  138eb0:	e8bd4006 	pop	{r1, r2, lr}
  138eb4:	e0030092 	mul	r3, r2, r0
  138eb8:	e0411003 	sub	r1, r1, r3
  138ebc:	e12fff1e 	bx	lr

00138ec0 <__aeabi_idiv0>:
  138ec0:	e92d4002 	push	{r1, lr}
  138ec4:	e3a00008 	mov	r0, #8
  138ec8:	eb001550 	bl	13e410 <raise>
  138ecc:	e8bd8002 	pop	{r1, pc}

00138ed0 <dummy>:
  138ed0:	e12fff1e 	bx	lr

00138ed4 <dummy1>:
  138ed4:	e12fff1e 	bx	lr

00138ed8 <__init_libc>:
  138ed8:	e92d4030 	push	{r4, r5, lr}
  138edc:	e1a04000 	mov	r4, r0
  138ee0:	e24dd09c 	sub	sp, sp, #156	; 0x9c
  138ee4:	e3a02098 	mov	r2, #152	; 0x98
  138ee8:	e1a05001 	mov	r5, r1
  138eec:	e1a0000d 	mov	r0, sp
  138ef0:	e3a01000 	mov	r1, #0
  138ef4:	eb00215e 	bl	141474 <memset>
  138ef8:	e5942000 	ldr	r2, [r4]
  138efc:	e59f3118 	ldr	r3, [pc, #280]	; 13901c <__init_libc+0x144>
  138f00:	e3520000 	cmp	r2, #0
  138f04:	e5834000 	str	r4, [r3]
  138f08:	03a02004 	moveq	r2, #4
  138f0c:	0a000009 	beq	138f38 <__init_libc+0x60>
  138f10:	e1a03004 	mov	r3, r4
  138f14:	e3a02000 	mov	r2, #0
  138f18:	ea000000 	b	138f20 <__init_libc+0x48>
  138f1c:	e1a02000 	mov	r2, r0
  138f20:	e5b31004 	ldr	r1, [r3, #4]!
  138f24:	e2820001 	add	r0, r2, #1
  138f28:	e3510000 	cmp	r1, #0
  138f2c:	1afffffa 	bne	138f1c <__init_libc+0x44>
  138f30:	e2822002 	add	r2, r2, #2
  138f34:	e1a02102 	lsl	r2, r2, #2
  138f38:	e7943002 	ldr	r3, [r4, r2]
  138f3c:	e59f00dc 	ldr	r0, [pc, #220]	; 139020 <__init_libc+0x148>
  138f40:	e0842002 	add	r2, r4, r2
  138f44:	e3530000 	cmp	r3, #0
  138f48:	e5802010 	str	r2, [r0, #16]
  138f4c:	0a00002d 	beq	139008 <__init_libc+0x130>
  138f50:	e3530025 	cmp	r3, #37	; 0x25
  138f54:	95921004 	ldrls	r1, [r2, #4]
  138f58:	928dc098 	addls	ip, sp, #152	; 0x98
  138f5c:	908c3103 	addls	r3, ip, r3, lsl #2
  138f60:	95031098 	strls	r1, [r3, #-152]	; 0xffffff68
  138f64:	e5b23008 	ldr	r3, [r2, #8]!
  138f68:	e3530000 	cmp	r3, #0
  138f6c:	1afffff7 	bne	138f50 <__init_libc+0x78>
  138f70:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
  138f74:	e59dc080 	ldr	ip, [sp, #128]	; 0x80
  138f78:	e59d2018 	ldr	r2, [sp, #24]
  138f7c:	e59f10a0 	ldr	r1, [pc, #160]	; 139024 <__init_libc+0x14c>
  138f80:	e5802024 	str	r2, [r0, #36]	; 0x24
  138f84:	e59f209c 	ldr	r2, [pc, #156]	; 139028 <__init_libc+0x150>
  138f88:	e3550000 	cmp	r5, #0
  138f8c:	e5813000 	str	r3, [r1]
  138f90:	e582c000 	str	ip, [r2]
  138f94:	0a000012 	beq	138fe4 <__init_libc+0x10c>
  138f98:	e59f308c 	ldr	r3, [pc, #140]	; 13902c <__init_libc+0x154>
  138f9c:	e59f208c 	ldr	r2, [pc, #140]	; 139030 <__init_libc+0x158>
  138fa0:	e5835000 	str	r5, [r3]
  138fa4:	e5825000 	str	r5, [r2]
  138fa8:	e5d53000 	ldrb	r3, [r5]
  138fac:	e3530000 	cmp	r3, #0
  138fb0:	0a000005 	beq	138fcc <__init_libc+0xf4>
  138fb4:	e2851001 	add	r1, r5, #1
  138fb8:	e353002f 	cmp	r3, #47	; 0x2f
  138fbc:	05821000 	streq	r1, [r2]
  138fc0:	e4d13001 	ldrb	r3, [r1], #1
  138fc4:	e3530000 	cmp	r3, #0
  138fc8:	1afffffa 	bne	138fb8 <__init_libc+0xe0>
  138fcc:	e1a0000d 	mov	r0, sp
  138fd0:	eb002850 	bl	143118 <__init_tls>
  138fd4:	e59d0064 	ldr	r0, [sp, #100]	; 0x64
  138fd8:	eb0028c5 	bl	1432f4 <__init_ssp>
  138fdc:	e28dd09c 	add	sp, sp, #156	; 0x9c
  138fe0:	e8bd8030 	pop	{r4, r5, pc}
  138fe4:	e59d107c 	ldr	r1, [sp, #124]	; 0x7c
  138fe8:	e3510000 	cmp	r1, #0
  138fec:	1a000008 	bne	139014 <__init_libc+0x13c>
  138ff0:	e59f303c 	ldr	r3, [pc, #60]	; 139034 <__init_libc+0x15c>
  138ff4:	e59f1030 	ldr	r1, [pc, #48]	; 13902c <__init_libc+0x154>
  138ff8:	e59f2030 	ldr	r2, [pc, #48]	; 139030 <__init_libc+0x158>
  138ffc:	e5813000 	str	r3, [r1]
  139000:	e5823000 	str	r3, [r2]
  139004:	eafffff0 	b	138fcc <__init_libc+0xf4>
  139008:	e1a02003 	mov	r2, r3
  13900c:	e1a0c003 	mov	ip, r3
  139010:	eaffffd9 	b	138f7c <__init_libc+0xa4>
  139014:	e1a05001 	mov	r5, r1
  139018:	eaffffde 	b	138f98 <__init_libc+0xc0>
  13901c:	00150480 	.word	0x00150480
  139020:	00576e84 	.word	0x00576e84
  139024:	00576e80 	.word	0x00576e80
  139028:	00576ec4 	.word	0x00576ec4
  13902c:	0014fc14 	.word	0x0014fc14
  139030:	0014fc10 	.word	0x0014fc10
  139034:	0014c904 	.word	0x0014c904

00139038 <__libc_start_init>:
  139038:	e92d4070 	push	{r4, r5, r6, lr}
  13903c:	e59f4020 	ldr	r4, [pc, #32]	; 139064 <__libc_start_init+0x2c>
  139040:	e59f5020 	ldr	r5, [pc, #32]	; 139068 <__libc_start_init+0x30>
  139044:	eb00314f 	bl	145588 <_init>
  139048:	e1540005 	cmp	r4, r5
  13904c:	28bd8070 	popcs	{r4, r5, r6, pc}
  139050:	e4943004 	ldr	r3, [r4], #4
  139054:	e12fff33 	blx	r3
  139058:	e1540005 	cmp	r4, r5
  13905c:	3afffffb 	bcc	139050 <__libc_start_init+0x18>
  139060:	e8bd8070 	pop	{r4, r5, r6, pc}
  139064:	0014e3e8 	.word	0x0014e3e8
  139068:	0014e3ec 	.word	0x0014e3ec

0013906c <libc_start_main_stage2>:
  13906c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  139070:	e1a05001 	mov	r5, r1
  139074:	e1a06002 	mov	r6, r2
  139078:	e2814001 	add	r4, r1, #1
  13907c:	e0824104 	add	r4, r2, r4, lsl #2
  139080:	e1a07000 	mov	r7, r0
  139084:	ebffffeb 	bl	139038 <__libc_start_init>
  139088:	e1a02004 	mov	r2, r4
  13908c:	e1a01006 	mov	r1, r6
  139090:	e1a00005 	mov	r0, r5
  139094:	e12fff37 	blx	r7
  139098:	eb000056 	bl	1391f8 <exit>

0013909c <__libc_start_main>:
  13909c:	e92d4070 	push	{r4, r5, r6, lr}
  1390a0:	e1a05001 	mov	r5, r1
  1390a4:	e1a04002 	mov	r4, r2
  1390a8:	e1a06000 	mov	r6, r0
  1390ac:	e2810001 	add	r0, r1, #1
  1390b0:	e0820100 	add	r0, r2, r0, lsl #2
  1390b4:	e5921000 	ldr	r1, [r2]
  1390b8:	ebffff86 	bl	138ed8 <__init_libc>
  1390bc:	e59f3010 	ldr	r3, [pc, #16]	; 1390d4 <__libc_start_main+0x38>
  1390c0:	e1a02004 	mov	r2, r4
  1390c4:	e1a01005 	mov	r1, r5
  1390c8:	e1a00006 	mov	r0, r6
  1390cc:	e8bd4070 	pop	{r4, r5, r6, lr}
  1390d0:	e12fff13 	bx	r3
  1390d4:	0013906c 	.word	0x0013906c

001390d8 <__errno_location>:
  1390d8:	e59f3010 	ldr	r3, [pc, #16]	; 1390f0 <__errno_location+0x18>
  1390dc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  1390e0:	e5930000 	ldr	r0, [r3]
  1390e4:	e12fff30 	blx	r0
  1390e8:	e2400058 	sub	r0, r0, #88	; 0x58
  1390ec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  1390f0:	0014e3dc 	.word	0x0014e3dc

001390f4 <__strerror_l>:
  1390f4:	e3500054 	cmp	r0, #84	; 0x54
  1390f8:	0a000013 	beq	13914c <__strerror_l+0x58>
  1390fc:	e3a0c001 	mov	ip, #1
  139100:	e3a03021 	mov	r3, #33	; 0x21
  139104:	e59f204c 	ldr	r2, [pc, #76]	; 139158 <__strerror_l+0x64>
  139108:	e1530000 	cmp	r3, r0
  13910c:	0a000003 	beq	139120 <__strerror_l+0x2c>
  139110:	e4d23001 	ldrb	r3, [r2], #1
  139114:	e28cc001 	add	ip, ip, #1
  139118:	e3530000 	cmp	r3, #0
  13911c:	1afffff9 	bne	139108 <__strerror_l+0x14>
  139120:	e3a02049 	mov	r2, #73	; 0x49
  139124:	e59f3030 	ldr	r3, [pc, #48]	; 13915c <__strerror_l+0x68>
  139128:	e3520000 	cmp	r2, #0
  13912c:	15f32001 	ldrbne	r2, [r3, #1]!
  139130:	1afffffc 	bne	139128 <__strerror_l+0x34>
  139134:	e25cc001 	subs	ip, ip, #1
  139138:	e2830001 	add	r0, r3, #1
  13913c:	0a000003 	beq	139150 <__strerror_l+0x5c>
  139140:	e5d32001 	ldrb	r2, [r3, #1]
  139144:	e1a03000 	mov	r3, r0
  139148:	eafffff6 	b	139128 <__strerror_l+0x34>
  13914c:	e59f0008 	ldr	r0, [pc, #8]	; 13915c <__strerror_l+0x68>
  139150:	e5911014 	ldr	r1, [r1, #20]
  139154:	ea000d54 	b	13c6ac <__lctrans>
  139158:	0014a68a 	.word	0x0014a68a
  13915c:	0014a6e4 	.word	0x0014a6e4

00139160 <strerror>:
  139160:	e1a03000 	mov	r3, r0
  139164:	e59f2018 	ldr	r2, [pc, #24]	; 139184 <strerror+0x24>
  139168:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13916c:	e5920000 	ldr	r0, [r2]
  139170:	e12fff30 	blx	r0
  139174:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  139178:	e5101018 	ldr	r1, [r0, #-24]	; 0xffffffe8
  13917c:	e1a00003 	mov	r0, r3
  139180:	eaffffdb 	b	1390f4 <__strerror_l>
  139184:	0014e3dc 	.word	0x0014e3dc

00139188 <__assert_fail>:
  139188:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13918c:	e24dd00c 	sub	sp, sp, #12
  139190:	e58d2004 	str	r2, [sp, #4]
  139194:	e58d3000 	str	r3, [sp]
  139198:	e1a02000 	mov	r2, r0
  13919c:	e1a03001 	mov	r3, r1
  1391a0:	e59f0010 	ldr	r0, [pc, #16]	; 1391b8 <__assert_fail+0x30>
  1391a4:	e59f1010 	ldr	r1, [pc, #16]	; 1391bc <__assert_fail+0x34>
  1391a8:	eb001523 	bl	13e63c <fprintf>
  1391ac:	e3a00000 	mov	r0, #0
  1391b0:	eb0014b0 	bl	13e478 <fflush>
  1391b4:	eb002872 	bl	143384 <abort>
  1391b8:	0014e2a8 	.word	0x0014e2a8
  1391bc:	0014ae04 	.word	0x0014ae04

001391c0 <__funcs_on_exit>:
  1391c0:	e12fff1e 	bx	lr

001391c4 <__libc_exit_fini>:
  1391c4:	e92d4070 	push	{r4, r5, r6, lr}
  1391c8:	e59f4020 	ldr	r4, [pc, #32]	; 1391f0 <__libc_exit_fini+0x2c>
  1391cc:	e59f5020 	ldr	r5, [pc, #32]	; 1391f4 <__libc_exit_fini+0x30>
  1391d0:	e1540005 	cmp	r4, r5
  1391d4:	9a000003 	bls	1391e8 <__libc_exit_fini+0x24>
  1391d8:	e5343004 	ldr	r3, [r4, #-4]!
  1391dc:	e12fff33 	blx	r3
  1391e0:	e1540005 	cmp	r4, r5
  1391e4:	8afffffb 	bhi	1391d8 <__libc_exit_fini+0x14>
  1391e8:	e8bd4070 	pop	{r4, r5, r6, lr}
  1391ec:	ea0030e8 	b	145594 <_fini>
  1391f0:	0014e3f0 	.word	0x0014e3f0
  1391f4:	0014e3ec 	.word	0x0014e3ec

001391f8 <exit>:
  1391f8:	e92d4010 	push	{r4, lr}
  1391fc:	e1a04000 	mov	r4, r0
  139200:	ebffffee 	bl	1391c0 <__funcs_on_exit>
  139204:	ebffffee 	bl	1391c4 <__libc_exit_fini>
  139208:	eb002daa 	bl	1448b8 <__stdio_exit>
  13920c:	e1a00004 	mov	r0, r4
  139210:	eb00284e 	bl	143350 <_Exit>

00139214 <fcntl>:
  139214:	e92d000e 	push	{r1, r2, r3}
  139218:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  13921c:	e24dd020 	sub	sp, sp, #32
  139220:	e59d4034 	ldr	r4, [sp, #52]	; 0x34
  139224:	e59d5038 	ldr	r5, [sp, #56]	; 0x38
  139228:	e28d3038 	add	r3, sp, #56	; 0x38
  13922c:	e3540004 	cmp	r4, #4
  139230:	e1a06000 	mov	r6, r0
  139234:	e58d3014 	str	r3, [sp, #20]
  139238:	03855802 	orreq	r5, r5, #131072	; 0x20000
  13923c:	0a00000f 	beq	139280 <fcntl+0x6c>
  139240:	e354000e 	cmp	r4, #14
  139244:	0a00001a 	beq	1392b4 <fcntl+0xa0>
  139248:	e3540009 	cmp	r4, #9
  13924c:	0a000026 	beq	1392ec <fcntl+0xd8>
  139250:	e59f3234 	ldr	r3, [pc, #564]	; 13948c <fcntl+0x278>
  139254:	e1540003 	cmp	r4, r3
  139258:	0a000034 	beq	139330 <fcntl+0x11c>
  13925c:	e244300c 	sub	r3, r4, #12
  139260:	e3530004 	cmp	r3, #4
  139264:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  139268:	ea000004 	b	139280 <fcntl+0x6c>
  13926c:	00139280 	.word	0x00139280
  139270:	00139280 	.word	0x00139280
  139274:	00139280 	.word	0x00139280
  139278:	00139280 	.word	0x00139280
  13927c:	00139280 	.word	0x00139280
  139280:	e3a000dd 	mov	r0, #221	; 0xdd
  139284:	eb000cc9 	bl	13c5b0 <get_rtt_syscall>
  139288:	e2503000 	subs	r3, r0, #0
  13928c:	0a000046 	beq	1393ac <fcntl+0x198>
  139290:	e1a02005 	mov	r2, r5
  139294:	e1a01004 	mov	r1, r4
  139298:	e1a00006 	mov	r0, r6
  13929c:	e12fff33 	blx	r3
  1392a0:	eb000cf7 	bl	13c684 <__syscall_ret>
  1392a4:	e28dd020 	add	sp, sp, #32
  1392a8:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  1392ac:	e28dd00c 	add	sp, sp, #12
  1392b0:	e12fff1e 	bx	lr
  1392b4:	e3a00000 	mov	r0, #0
  1392b8:	e1a03005 	mov	r3, r5
  1392bc:	e1a02004 	mov	r2, r4
  1392c0:	e1a01006 	mov	r1, r6
  1392c4:	e58d0008 	str	r0, [sp, #8]
  1392c8:	e58d0004 	str	r0, [sp, #4]
  1392cc:	e58d0000 	str	r0, [sp]
  1392d0:	e3a000dd 	mov	r0, #221	; 0xdd
  1392d4:	eb00231d 	bl	141f50 <__syscall_cp>
  1392d8:	eb000ce9 	bl	13c684 <__syscall_ret>
  1392dc:	e28dd020 	add	sp, sp, #32
  1392e0:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  1392e4:	e28dd00c 	add	sp, sp, #12
  1392e8:	e12fff1e 	bx	lr
  1392ec:	e3a000dd 	mov	r0, #221	; 0xdd
  1392f0:	eb000cae 	bl	13c5b0 <get_rtt_syscall>
  1392f4:	e2503000 	subs	r3, r0, #0
  1392f8:	0a000007 	beq	13931c <fcntl+0x108>
  1392fc:	e28d2018 	add	r2, sp, #24
  139300:	e3a01010 	mov	r1, #16
  139304:	e1a00006 	mov	r0, r6
  139308:	e12fff33 	blx	r3
  13930c:	e3700016 	cmn	r0, #22
  139310:	0a000027 	beq	1393b4 <fcntl+0x1a0>
  139314:	e3500000 	cmp	r0, #0
  139318:	1affffe0 	bne	1392a0 <fcntl+0x8c>
  13931c:	e59d3018 	ldr	r3, [sp, #24]
  139320:	e59d001c 	ldr	r0, [sp, #28]
  139324:	e3530002 	cmp	r3, #2
  139328:	02600000 	rsbeq	r0, r0, #0
  13932c:	eaffffdc 	b	1392a4 <fcntl+0x90>
  139330:	e3a000dd 	mov	r0, #221	; 0xdd
  139334:	eb000c9d 	bl	13c5b0 <get_rtt_syscall>
  139338:	e2503000 	subs	r3, r0, #0
  13933c:	0a00000f 	beq	139380 <fcntl+0x16c>
  139340:	e1a02005 	mov	r2, r5
  139344:	e1a01004 	mov	r1, r4
  139348:	e1a00006 	mov	r0, r6
  13934c:	e12fff33 	blx	r3
  139350:	e3700016 	cmn	r0, #22
  139354:	e1a07000 	mov	r7, r0
  139358:	0a00001e 	beq	1393d8 <fcntl+0x1c4>
  13935c:	e3500000 	cmp	r0, #0
  139360:	e1a04000 	mov	r4, r0
  139364:	aa000007 	bge	139388 <fcntl+0x174>
  139368:	e1a00004 	mov	r0, r4
  13936c:	eb000cc4 	bl	13c684 <__syscall_ret>
  139370:	e28dd020 	add	sp, sp, #32
  139374:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  139378:	e28dd00c 	add	sp, sp, #12
  13937c:	e12fff1e 	bx	lr
  139380:	e1a04003 	mov	r4, r3
  139384:	e1a07003 	mov	r7, r3
  139388:	e3a000dd 	mov	r0, #221	; 0xdd
  13938c:	eb000c87 	bl	13c5b0 <get_rtt_syscall>
  139390:	e2503000 	subs	r3, r0, #0
  139394:	0afffff3 	beq	139368 <fcntl+0x154>
  139398:	e1a00007 	mov	r0, r7
  13939c:	e3a02001 	mov	r2, #1
  1393a0:	e3a01002 	mov	r1, #2
  1393a4:	e12fff33 	blx	r3
  1393a8:	eaffffee 	b	139368 <fcntl+0x154>
  1393ac:	e1a00003 	mov	r0, r3
  1393b0:	eaffffba 	b	1392a0 <fcntl+0x8c>
  1393b4:	e3a000dd 	mov	r0, #221	; 0xdd
  1393b8:	eb000c7c 	bl	13c5b0 <get_rtt_syscall>
  1393bc:	e2503000 	subs	r3, r0, #0
  1393c0:	0a00002f 	beq	139484 <fcntl+0x270>
  1393c4:	e1a02005 	mov	r2, r5
  1393c8:	e1a01004 	mov	r1, r4
  1393cc:	e1a00006 	mov	r0, r6
  1393d0:	e12fff33 	blx	r3
  1393d4:	eaffffb2 	b	1392a4 <fcntl+0x90>
  1393d8:	e3a000dd 	mov	r0, #221	; 0xdd
  1393dc:	eb000c73 	bl	13c5b0 <get_rtt_syscall>
  1393e0:	e2503000 	subs	r3, r0, #0
  1393e4:	0a00000b 	beq	139418 <fcntl+0x204>
  1393e8:	e1a01004 	mov	r1, r4
  1393ec:	e3a02000 	mov	r2, #0
  1393f0:	e1a00006 	mov	r0, r6
  1393f4:	e12fff33 	blx	r3
  1393f8:	e3700016 	cmn	r0, #22
  1393fc:	e1a04000 	mov	r4, r0
  139400:	0a00000c 	beq	139438 <fcntl+0x224>
  139404:	e3500000 	cmp	r0, #0
  139408:	aa000003 	bge	13941c <fcntl+0x208>
  13940c:	e3e00015 	mvn	r0, #21
  139410:	eb000c9b 	bl	13c684 <__syscall_ret>
  139414:	eaffffa2 	b	1392a4 <fcntl+0x90>
  139418:	e1a04003 	mov	r4, r3
  13941c:	e3a00006 	mov	r0, #6
  139420:	eb000c62 	bl	13c5b0 <get_rtt_syscall>
  139424:	e2503000 	subs	r3, r0, #0
  139428:	0afffff7 	beq	13940c <fcntl+0x1f8>
  13942c:	e1a00004 	mov	r0, r4
  139430:	e12fff33 	blx	r3
  139434:	eafffff4 	b	13940c <fcntl+0x1f8>
  139438:	e3a000dd 	mov	r0, #221	; 0xdd
  13943c:	eb000c5b 	bl	13c5b0 <get_rtt_syscall>
  139440:	e2504000 	subs	r4, r0, #0
  139444:	0a000005 	beq	139460 <fcntl+0x24c>
  139448:	e1a02005 	mov	r2, r5
  13944c:	e1a00006 	mov	r0, r6
  139450:	e3a01000 	mov	r1, #0
  139454:	e12fff34 	blx	r4
  139458:	e2504000 	subs	r4, r0, #0
  13945c:	baffffc1 	blt	139368 <fcntl+0x154>
  139460:	e3a000dd 	mov	r0, #221	; 0xdd
  139464:	eb000c51 	bl	13c5b0 <get_rtt_syscall>
  139468:	e2503000 	subs	r3, r0, #0
  13946c:	0affffbd 	beq	139368 <fcntl+0x154>
  139470:	e3a02001 	mov	r2, #1
  139474:	e3a01002 	mov	r1, #2
  139478:	e1a00004 	mov	r0, r4
  13947c:	e12fff33 	blx	r3
  139480:	eaffffb8 	b	139368 <fcntl+0x154>
  139484:	e1a00003 	mov	r0, r3
  139488:	eaffff85 	b	1392a4 <fcntl+0x90>
  13948c:	00000406 	.word	0x00000406

00139490 <syscall_set_thread_area>:
  139490:	e1a01000 	mov	r1, r0
  139494:	e3a0007b 	mov	r0, #123	; 0x7b
  139498:	ea000c6f 	b	13c65c <syscall>

0013949c <syscall_trace>:
  13949c:	e92d4070 	push	{r4, r5, r6, lr}
  1394a0:	e1a04000 	mov	r4, r0
  1394a4:	e1a05001 	mov	r5, r1
  1394a8:	e3a0201d 	mov	r2, #29
  1394ac:	e59f1018 	ldr	r1, [pc, #24]	; 1394cc <syscall_trace+0x30>
  1394b0:	e3a000ff 	mov	r0, #255	; 0xff
  1394b4:	eb000c68 	bl	13c65c <syscall>
  1394b8:	e1a02005 	mov	r2, r5
  1394bc:	e1a01004 	mov	r1, r4
  1394c0:	e8bd4070 	pop	{r4, r5, r6, lr}
  1394c4:	e3a000ff 	mov	r0, #255	; 0xff
  1394c8:	ea000c63 	b	13c65c <syscall>
  1394cc:	0014cf48 	.word	0x0014cf48

001394d0 <syscall_io_pgetevents>:
  1394d0:	e92d4010 	push	{r4, lr}
  1394d4:	e3a01016 	mov	r1, #22
  1394d8:	e59f0008 	ldr	r0, [pc, #8]	; 1394e8 <syscall_io_pgetevents+0x18>
  1394dc:	ebffffee 	bl	13949c <syscall_trace>
  1394e0:	e3a00000 	mov	r0, #0
  1394e4:	e8bd8010 	pop	{r4, pc}
  1394e8:	0014c8d0 	.word	0x0014c8d0

001394ec <syscall_rseq>:
  1394ec:	e92d4010 	push	{r4, lr}
  1394f0:	e3a0100d 	mov	r1, #13
  1394f4:	e59f0008 	ldr	r0, [pc, #8]	; 139504 <syscall_rseq+0x18>
  1394f8:	ebffffe7 	bl	13949c <syscall_trace>
  1394fc:	e3a00000 	mov	r0, #0
  139500:	e8bd8010 	pop	{r4, pc}
  139504:	0014c8c0 	.word	0x0014c8c0

00139508 <syscall_statx>:
  139508:	e92d4010 	push	{r4, lr}
  13950c:	e3a0100e 	mov	r1, #14
  139510:	e59f0008 	ldr	r0, [pc, #8]	; 139520 <syscall_statx+0x18>
  139514:	ebffffe0 	bl	13949c <syscall_trace>
  139518:	e3a00000 	mov	r0, #0
  13951c:	e8bd8010 	pop	{r4, pc}
  139520:	0014c8b0 	.word	0x0014c8b0

00139524 <syscall_pkey_free>:
  139524:	e92d4010 	push	{r4, lr}
  139528:	e3a01012 	mov	r1, #18
  13952c:	e59f0008 	ldr	r0, [pc, #8]	; 13953c <syscall_pkey_free+0x18>
  139530:	ebffffd9 	bl	13949c <syscall_trace>
  139534:	e3a00000 	mov	r0, #0
  139538:	e8bd8010 	pop	{r4, pc}
  13953c:	0014c89c 	.word	0x0014c89c

00139540 <syscall_pkey_alloc>:
  139540:	e92d4010 	push	{r4, lr}
  139544:	e3a01013 	mov	r1, #19
  139548:	e59f0008 	ldr	r0, [pc, #8]	; 139558 <syscall_pkey_alloc+0x18>
  13954c:	ebffffd2 	bl	13949c <syscall_trace>
  139550:	e3a00000 	mov	r0, #0
  139554:	e8bd8010 	pop	{r4, pc}
  139558:	0014c888 	.word	0x0014c888

0013955c <syscall_pkey_mprotect>:
  13955c:	e92d4010 	push	{r4, lr}
  139560:	e3a01016 	mov	r1, #22
  139564:	e59f0008 	ldr	r0, [pc, #8]	; 139574 <syscall_pkey_mprotect+0x18>
  139568:	ebffffcb 	bl	13949c <syscall_trace>
  13956c:	e3a00000 	mov	r0, #0
  139570:	e8bd8010 	pop	{r4, pc}
  139574:	0014c870 	.word	0x0014c870

00139578 <syscall_pwritev2>:
  139578:	e92d4010 	push	{r4, lr}
  13957c:	e3a01011 	mov	r1, #17
  139580:	e59f0008 	ldr	r0, [pc, #8]	; 139590 <syscall_pwritev2+0x18>
  139584:	ebffffc4 	bl	13949c <syscall_trace>
  139588:	e3a00000 	mov	r0, #0
  13958c:	e8bd8010 	pop	{r4, pc}
  139590:	0014c85c 	.word	0x0014c85c

00139594 <syscall_preadv2>:
  139594:	e92d4010 	push	{r4, lr}
  139598:	e3a01010 	mov	r1, #16
  13959c:	e59f0008 	ldr	r0, [pc, #8]	; 1395ac <syscall_preadv2+0x18>
  1395a0:	ebffffbd 	bl	13949c <syscall_trace>
  1395a4:	e3a00000 	mov	r0, #0
  1395a8:	e8bd8010 	pop	{r4, pc}
  1395ac:	0014c84c 	.word	0x0014c84c

001395b0 <syscall_copy_file_range>:
  1395b0:	e92d4010 	push	{r4, lr}
  1395b4:	e3a01018 	mov	r1, #24
  1395b8:	e59f0008 	ldr	r0, [pc, #8]	; 1395c8 <syscall_copy_file_range+0x18>
  1395bc:	ebffffb6 	bl	13949c <syscall_trace>
  1395c0:	e3a00000 	mov	r0, #0
  1395c4:	e8bd8010 	pop	{r4, pc}
  1395c8:	0014c834 	.word	0x0014c834

001395cc <syscall_mlock2>:
  1395cc:	e92d4010 	push	{r4, lr}
  1395d0:	e3a0100f 	mov	r1, #15
  1395d4:	e59f0008 	ldr	r0, [pc, #8]	; 1395e4 <syscall_mlock2+0x18>
  1395d8:	ebffffaf 	bl	13949c <syscall_trace>
  1395dc:	e3a00000 	mov	r0, #0
  1395e0:	e8bd8010 	pop	{r4, pc}
  1395e4:	0014c824 	.word	0x0014c824

001395e8 <syscall_membarrier>:
  1395e8:	e92d4010 	push	{r4, lr}
  1395ec:	e3a01013 	mov	r1, #19
  1395f0:	e59f0008 	ldr	r0, [pc, #8]	; 139600 <syscall_membarrier+0x18>
  1395f4:	ebffffa8 	bl	13949c <syscall_trace>
  1395f8:	e3a00000 	mov	r0, #0
  1395fc:	e8bd8010 	pop	{r4, pc}
  139600:	0014c810 	.word	0x0014c810

00139604 <syscall_userfaultfd>:
  139604:	e92d4010 	push	{r4, lr}
  139608:	e3a01014 	mov	r1, #20
  13960c:	e59f0008 	ldr	r0, [pc, #8]	; 13961c <syscall_userfaultfd+0x18>
  139610:	ebffffa1 	bl	13949c <syscall_trace>
  139614:	e3a00000 	mov	r0, #0
  139618:	e8bd8010 	pop	{r4, pc}
  13961c:	0014c7fc 	.word	0x0014c7fc

00139620 <syscall_execveat>:
  139620:	e92d4010 	push	{r4, lr}
  139624:	e3a01011 	mov	r1, #17
  139628:	e59f0008 	ldr	r0, [pc, #8]	; 139638 <syscall_execveat+0x18>
  13962c:	ebffff9a 	bl	13949c <syscall_trace>
  139630:	e3a00000 	mov	r0, #0
  139634:	e8bd8010 	pop	{r4, pc}
  139638:	0014c7e8 	.word	0x0014c7e8

0013963c <syscall_bpf>:
  13963c:	e92d4010 	push	{r4, lr}
  139640:	e3a0100c 	mov	r1, #12
  139644:	e59f0008 	ldr	r0, [pc, #8]	; 139654 <syscall_bpf+0x18>
  139648:	ebffff93 	bl	13949c <syscall_trace>
  13964c:	e3a00000 	mov	r0, #0
  139650:	e8bd8010 	pop	{r4, pc}
  139654:	0014c7dc 	.word	0x0014c7dc

00139658 <syscall_memfd_create>:
  139658:	e92d4010 	push	{r4, lr}
  13965c:	e3a01015 	mov	r1, #21
  139660:	e59f0008 	ldr	r0, [pc, #8]	; 139670 <syscall_memfd_create+0x18>
  139664:	ebffff8c 	bl	13949c <syscall_trace>
  139668:	e3a00000 	mov	r0, #0
  13966c:	e8bd8010 	pop	{r4, pc}
  139670:	0014c7c4 	.word	0x0014c7c4

00139674 <syscall_seccomp>:
  139674:	e92d4010 	push	{r4, lr}
  139678:	e3a01010 	mov	r1, #16
  13967c:	e59f0008 	ldr	r0, [pc, #8]	; 13968c <syscall_seccomp+0x18>
  139680:	ebffff85 	bl	13949c <syscall_trace>
  139684:	e3a00000 	mov	r0, #0
  139688:	e8bd8010 	pop	{r4, pc}
  13968c:	0014c7a0 	.word	0x0014c7a0

00139690 <syscall_renameat2>:
  139690:	e92d4010 	push	{r4, lr}
  139694:	e3a01012 	mov	r1, #18
  139698:	e59f0008 	ldr	r0, [pc, #8]	; 1396a8 <syscall_renameat2+0x18>
  13969c:	ebffff7e 	bl	13949c <syscall_trace>
  1396a0:	e3a00000 	mov	r0, #0
  1396a4:	e8bd8010 	pop	{r4, pc}
  1396a8:	0014c78c 	.word	0x0014c78c

001396ac <syscall_sched_getattr>:
  1396ac:	e92d4010 	push	{r4, lr}
  1396b0:	e3a01016 	mov	r1, #22
  1396b4:	e59f0008 	ldr	r0, [pc, #8]	; 1396c4 <syscall_sched_getattr+0x18>
  1396b8:	ebffff77 	bl	13949c <syscall_trace>
  1396bc:	e3a00000 	mov	r0, #0
  1396c0:	e8bd8010 	pop	{r4, pc}
  1396c4:	0014c774 	.word	0x0014c774

001396c8 <syscall_sched_setattr>:
  1396c8:	e92d4010 	push	{r4, lr}
  1396cc:	e3a01016 	mov	r1, #22
  1396d0:	e59f0008 	ldr	r0, [pc, #8]	; 1396e0 <syscall_sched_setattr+0x18>
  1396d4:	ebffff70 	bl	13949c <syscall_trace>
  1396d8:	e3a00000 	mov	r0, #0
  1396dc:	e8bd8010 	pop	{r4, pc}
  1396e0:	0014c75c 	.word	0x0014c75c

001396e4 <syscall_finit_module>:
  1396e4:	e92d4010 	push	{r4, lr}
  1396e8:	e3a01015 	mov	r1, #21
  1396ec:	e59f0008 	ldr	r0, [pc, #8]	; 1396fc <syscall_finit_module+0x18>
  1396f0:	ebffff69 	bl	13949c <syscall_trace>
  1396f4:	e3a00000 	mov	r0, #0
  1396f8:	e8bd8010 	pop	{r4, pc}
  1396fc:	0014c744 	.word	0x0014c744

00139700 <syscall_kcmp>:
  139700:	e92d4010 	push	{r4, lr}
  139704:	e3a0100d 	mov	r1, #13
  139708:	e59f0008 	ldr	r0, [pc, #8]	; 139718 <syscall_kcmp+0x18>
  13970c:	ebffff62 	bl	13949c <syscall_trace>
  139710:	e3a00000 	mov	r0, #0
  139714:	e8bd8010 	pop	{r4, pc}
  139718:	0014c734 	.word	0x0014c734

0013971c <syscall_process_vm_writev>:
  13971c:	e92d4010 	push	{r4, lr}
  139720:	e3a0101a 	mov	r1, #26
  139724:	e59f0008 	ldr	r0, [pc, #8]	; 139734 <syscall_process_vm_writev+0x18>
  139728:	ebffff5b 	bl	13949c <syscall_trace>
  13972c:	e3a00000 	mov	r0, #0
  139730:	e8bd8010 	pop	{r4, pc}
  139734:	0014c718 	.word	0x0014c718

00139738 <syscall_process_vm_readv>:
  139738:	e92d4010 	push	{r4, lr}
  13973c:	e3a01019 	mov	r1, #25
  139740:	e59f0008 	ldr	r0, [pc, #8]	; 139750 <syscall_process_vm_readv+0x18>
  139744:	ebffff54 	bl	13949c <syscall_trace>
  139748:	e3a00000 	mov	r0, #0
  13974c:	e8bd8010 	pop	{r4, pc}
  139750:	0014c6fc 	.word	0x0014c6fc

00139754 <syscall_setns>:
  139754:	e92d4010 	push	{r4, lr}
  139758:	e3a0100e 	mov	r1, #14
  13975c:	e59f0008 	ldr	r0, [pc, #8]	; 13976c <syscall_setns+0x18>
  139760:	ebffff4d 	bl	13949c <syscall_trace>
  139764:	e3a00000 	mov	r0, #0
  139768:	e8bd8010 	pop	{r4, pc}
  13976c:	0014c6ec 	.word	0x0014c6ec

00139770 <syscall_sendmmsg>:
  139770:	e92d4010 	push	{r4, lr}
  139774:	e3a01011 	mov	r1, #17
  139778:	e59f0008 	ldr	r0, [pc, #8]	; 139788 <syscall_sendmmsg+0x18>
  13977c:	ebffff46 	bl	13949c <syscall_trace>
  139780:	e3a00000 	mov	r0, #0
  139784:	e8bd8010 	pop	{r4, pc}
  139788:	0014c6d8 	.word	0x0014c6d8

0013978c <syscall_syncfs>:
  13978c:	e92d4010 	push	{r4, lr}
  139790:	e3a0100f 	mov	r1, #15
  139794:	e59f0008 	ldr	r0, [pc, #8]	; 1397a4 <syscall_syncfs+0x18>
  139798:	ebffff3f 	bl	13949c <syscall_trace>
  13979c:	e3a00000 	mov	r0, #0
  1397a0:	e8bd8010 	pop	{r4, pc}
  1397a4:	0014c6c8 	.word	0x0014c6c8

001397a8 <syscall_clock_adjtime>:
  1397a8:	e92d4010 	push	{r4, lr}
  1397ac:	e3a01016 	mov	r1, #22
  1397b0:	e59f0008 	ldr	r0, [pc, #8]	; 1397c0 <syscall_clock_adjtime+0x18>
  1397b4:	ebffff38 	bl	13949c <syscall_trace>
  1397b8:	e3a00000 	mov	r0, #0
  1397bc:	e8bd8010 	pop	{r4, pc}
  1397c0:	0014c6b0 	.word	0x0014c6b0

001397c4 <syscall_open_by_handle_at>:
  1397c4:	e92d4010 	push	{r4, lr}
  1397c8:	e3a0101a 	mov	r1, #26
  1397cc:	e59f0008 	ldr	r0, [pc, #8]	; 1397dc <syscall_open_by_handle_at+0x18>
  1397d0:	ebffff31 	bl	13949c <syscall_trace>
  1397d4:	e3a00000 	mov	r0, #0
  1397d8:	e8bd8010 	pop	{r4, pc}
  1397dc:	0014c694 	.word	0x0014c694

001397e0 <syscall_name_to_handle_at>:
  1397e0:	e92d4010 	push	{r4, lr}
  1397e4:	e3a0101a 	mov	r1, #26
  1397e8:	e59f0008 	ldr	r0, [pc, #8]	; 1397f8 <syscall_name_to_handle_at+0x18>
  1397ec:	ebffff2a 	bl	13949c <syscall_trace>
  1397f0:	e3a00000 	mov	r0, #0
  1397f4:	e8bd8010 	pop	{r4, pc}
  1397f8:	0014c678 	.word	0x0014c678

001397fc <syscall_fanotify_mark>:
  1397fc:	e92d4010 	push	{r4, lr}
  139800:	e3a01016 	mov	r1, #22
  139804:	e59f0008 	ldr	r0, [pc, #8]	; 139814 <syscall_fanotify_mark+0x18>
  139808:	ebffff23 	bl	13949c <syscall_trace>
  13980c:	e3a00000 	mov	r0, #0
  139810:	e8bd8010 	pop	{r4, pc}
  139814:	0014c64c 	.word	0x0014c64c

00139818 <syscall_fanotify_init>:
  139818:	e92d4010 	push	{r4, lr}
  13981c:	e3a01016 	mov	r1, #22
  139820:	e59f0008 	ldr	r0, [pc, #8]	; 139830 <syscall_fanotify_init+0x18>
  139824:	ebffff1c 	bl	13949c <syscall_trace>
  139828:	e3a00000 	mov	r0, #0
  13982c:	e8bd8010 	pop	{r4, pc}
  139830:	0014c634 	.word	0x0014c634

00139834 <syscall_accept4>:
  139834:	e92d4010 	push	{r4, lr}
  139838:	e3a01010 	mov	r1, #16
  13983c:	e59f0008 	ldr	r0, [pc, #8]	; 13984c <syscall_accept4+0x18>
  139840:	ebffff15 	bl	13949c <syscall_trace>
  139844:	e3a00000 	mov	r0, #0
  139848:	e8bd8010 	pop	{r4, pc}
  13984c:	0014c624 	.word	0x0014c624

00139850 <syscall_recvmmsg>:
  139850:	e92d4010 	push	{r4, lr}
  139854:	e3a01011 	mov	r1, #17
  139858:	e59f0008 	ldr	r0, [pc, #8]	; 139868 <syscall_recvmmsg+0x18>
  13985c:	ebffff0e 	bl	13949c <syscall_trace>
  139860:	e3a00000 	mov	r0, #0
  139864:	e8bd8010 	pop	{r4, pc}
  139868:	0014c610 	.word	0x0014c610

0013986c <syscall_perf_event_open>:
  13986c:	e92d4010 	push	{r4, lr}
  139870:	e3a01018 	mov	r1, #24
  139874:	e59f0008 	ldr	r0, [pc, #8]	; 139884 <syscall_perf_event_open+0x18>
  139878:	ebffff07 	bl	13949c <syscall_trace>
  13987c:	e3a00000 	mov	r0, #0
  139880:	e8bd8010 	pop	{r4, pc}
  139884:	0014c5f8 	.word	0x0014c5f8

00139888 <syscall_rt_tgsigqueueinfo>:
  139888:	e92d4010 	push	{r4, lr}
  13988c:	e3a0101a 	mov	r1, #26
  139890:	e59f0008 	ldr	r0, [pc, #8]	; 1398a0 <syscall_rt_tgsigqueueinfo+0x18>
  139894:	ebffff00 	bl	13949c <syscall_trace>
  139898:	e3a00000 	mov	r0, #0
  13989c:	e8bd8010 	pop	{r4, pc}
  1398a0:	0014c5dc 	.word	0x0014c5dc

001398a4 <syscall_pwritev>:
  1398a4:	e92d4010 	push	{r4, lr}
  1398a8:	e3a01010 	mov	r1, #16
  1398ac:	e59f0008 	ldr	r0, [pc, #8]	; 1398bc <syscall_pwritev+0x18>
  1398b0:	ebfffef9 	bl	13949c <syscall_trace>
  1398b4:	e3a00000 	mov	r0, #0
  1398b8:	e8bd8010 	pop	{r4, pc}
  1398bc:	0014c5cc 	.word	0x0014c5cc

001398c0 <syscall_preadv>:
  1398c0:	e92d4010 	push	{r4, lr}
  1398c4:	e3a0100f 	mov	r1, #15
  1398c8:	e59f0008 	ldr	r0, [pc, #8]	; 1398d8 <syscall_preadv+0x18>
  1398cc:	ebfffef2 	bl	13949c <syscall_trace>
  1398d0:	e3a00000 	mov	r0, #0
  1398d4:	e8bd8010 	pop	{r4, pc}
  1398d8:	0014c5bc 	.word	0x0014c5bc

001398dc <syscall_inotify_init1>:
  1398dc:	e92d4010 	push	{r4, lr}
  1398e0:	e3a01016 	mov	r1, #22
  1398e4:	e59f0008 	ldr	r0, [pc, #8]	; 1398f4 <syscall_inotify_init1+0x18>
  1398e8:	ebfffeeb 	bl	13949c <syscall_trace>
  1398ec:	e3a00000 	mov	r0, #0
  1398f0:	e8bd8010 	pop	{r4, pc}
  1398f4:	0014c5a4 	.word	0x0014c5a4

001398f8 <syscall_pipe2>:
  1398f8:	e92d4010 	push	{r4, lr}
  1398fc:	e3a0100e 	mov	r1, #14
  139900:	e59f0008 	ldr	r0, [pc, #8]	; 139910 <syscall_pipe2+0x18>
  139904:	ebfffee4 	bl	13949c <syscall_trace>
  139908:	e3a00000 	mov	r0, #0
  13990c:	e8bd8010 	pop	{r4, pc}
  139910:	0014c594 	.word	0x0014c594

00139914 <syscall_dup3>:
  139914:	e92d4010 	push	{r4, lr}
  139918:	e3a0100d 	mov	r1, #13
  13991c:	e59f0008 	ldr	r0, [pc, #8]	; 13992c <syscall_dup3+0x18>
  139920:	ebfffedd 	bl	13949c <syscall_trace>
  139924:	e3a00000 	mov	r0, #0
  139928:	e8bd8010 	pop	{r4, pc}
  13992c:	0014c584 	.word	0x0014c584

00139930 <syscall_epoll_create1>:
  139930:	e92d4010 	push	{r4, lr}
  139934:	e3a01016 	mov	r1, #22
  139938:	e59f0008 	ldr	r0, [pc, #8]	; 139948 <syscall_epoll_create1+0x18>
  13993c:	ebfffed6 	bl	13949c <syscall_trace>
  139940:	e3e00025 	mvn	r0, #37	; 0x25
  139944:	e8bd8010 	pop	{r4, pc}
  139948:	0014c56c 	.word	0x0014c56c

0013994c <syscall_eventfd2>:
  13994c:	e92d4010 	push	{r4, lr}
  139950:	e3a01011 	mov	r1, #17
  139954:	e59f0008 	ldr	r0, [pc, #8]	; 139964 <syscall_eventfd2+0x18>
  139958:	ebfffecf 	bl	13949c <syscall_trace>
  13995c:	e3a00000 	mov	r0, #0
  139960:	e8bd8010 	pop	{r4, pc}
  139964:	0014c558 	.word	0x0014c558

00139968 <syscall_signalfd4>:
  139968:	e92d4010 	push	{r4, lr}
  13996c:	e3a01012 	mov	r1, #18
  139970:	e59f0008 	ldr	r0, [pc, #8]	; 139980 <syscall_signalfd4+0x18>
  139974:	ebfffec8 	bl	13949c <syscall_trace>
  139978:	e3a00000 	mov	r0, #0
  13997c:	e8bd8010 	pop	{r4, pc}
  139980:	0014c544 	.word	0x0014c544

00139984 <syscall_timerfd_gettime>:
  139984:	e92d4010 	push	{r4, lr}
  139988:	e3a01018 	mov	r1, #24
  13998c:	e59f0008 	ldr	r0, [pc, #8]	; 13999c <syscall_timerfd_gettime+0x18>
  139990:	ebfffec1 	bl	13949c <syscall_trace>
  139994:	e3a00000 	mov	r0, #0
  139998:	e8bd8010 	pop	{r4, pc}
  13999c:	0014c52c 	.word	0x0014c52c

001399a0 <syscall_timerfd_settime>:
  1399a0:	e92d4010 	push	{r4, lr}
  1399a4:	e3a01018 	mov	r1, #24
  1399a8:	e59f0008 	ldr	r0, [pc, #8]	; 1399b8 <syscall_timerfd_settime+0x18>
  1399ac:	ebfffeba 	bl	13949c <syscall_trace>
  1399b0:	e3a00000 	mov	r0, #0
  1399b4:	e8bd8010 	pop	{r4, pc}
  1399b8:	0014c514 	.word	0x0014c514

001399bc <syscall_fallocate>:
  1399bc:	e92d4010 	push	{r4, lr}
  1399c0:	e3a01012 	mov	r1, #18
  1399c4:	e59f0008 	ldr	r0, [pc, #8]	; 1399d4 <syscall_fallocate+0x18>
  1399c8:	ebfffeb3 	bl	13949c <syscall_trace>
  1399cc:	e3a00000 	mov	r0, #0
  1399d0:	e8bd8010 	pop	{r4, pc}
  1399d4:	0014c500 	.word	0x0014c500

001399d8 <syscall_eventfd>:
  1399d8:	e92d4010 	push	{r4, lr}
  1399dc:	e3a01010 	mov	r1, #16
  1399e0:	e59f0008 	ldr	r0, [pc, #8]	; 1399f0 <syscall_eventfd+0x18>
  1399e4:	ebfffeac 	bl	13949c <syscall_trace>
  1399e8:	e3a00000 	mov	r0, #0
  1399ec:	e8bd8010 	pop	{r4, pc}
  1399f0:	0014c4f0 	.word	0x0014c4f0

001399f4 <syscall_timerfd_create>:
  1399f4:	e92d4010 	push	{r4, lr}
  1399f8:	e3a01017 	mov	r1, #23
  1399fc:	e59f0008 	ldr	r0, [pc, #8]	; 139a0c <syscall_timerfd_create+0x18>
  139a00:	ebfffea5 	bl	13949c <syscall_trace>
  139a04:	e3a00000 	mov	r0, #0
  139a08:	e8bd8010 	pop	{r4, pc}
  139a0c:	0014c4d8 	.word	0x0014c4d8

00139a10 <syscall_signalfd>:
  139a10:	e92d4010 	push	{r4, lr}
  139a14:	e3a01011 	mov	r1, #17
  139a18:	e59f0008 	ldr	r0, [pc, #8]	; 139a28 <syscall_signalfd+0x18>
  139a1c:	ebfffe9e 	bl	13949c <syscall_trace>
  139a20:	e3a00000 	mov	r0, #0
  139a24:	e8bd8010 	pop	{r4, pc}
  139a28:	0014c4c4 	.word	0x0014c4c4

00139a2c <syscall_utimensat>:
  139a2c:	e92d4010 	push	{r4, lr}
  139a30:	e3a01012 	mov	r1, #18
  139a34:	e59f0008 	ldr	r0, [pc, #8]	; 139a44 <syscall_utimensat+0x18>
  139a38:	ebfffe97 	bl	13949c <syscall_trace>
  139a3c:	e3a00000 	mov	r0, #0
  139a40:	e8bd8010 	pop	{r4, pc}
  139a44:	0014c4b0 	.word	0x0014c4b0

00139a48 <syscall_kexec_load>:
  139a48:	e92d4010 	push	{r4, lr}
  139a4c:	e3a01013 	mov	r1, #19
  139a50:	e59f0008 	ldr	r0, [pc, #8]	; 139a60 <syscall_kexec_load+0x18>
  139a54:	ebfffe90 	bl	13949c <syscall_trace>
  139a58:	e3a00000 	mov	r0, #0
  139a5c:	e8bd8010 	pop	{r4, pc}
  139a60:	0014c49c 	.word	0x0014c49c

00139a64 <syscall_epoll_pwait>:
  139a64:	e92d4010 	push	{r4, lr}
  139a68:	e3a01014 	mov	r1, #20
  139a6c:	e59f0008 	ldr	r0, [pc, #8]	; 139a7c <syscall_epoll_pwait+0x18>
  139a70:	ebfffe89 	bl	13949c <syscall_trace>
  139a74:	e3e00025 	mvn	r0, #37	; 0x25
  139a78:	e8bd8010 	pop	{r4, pc}
  139a7c:	0014c488 	.word	0x0014c488

00139a80 <syscall_getcpu>:
  139a80:	e92d4010 	push	{r4, lr}
  139a84:	e3a0100f 	mov	r1, #15
  139a88:	e59f0008 	ldr	r0, [pc, #8]	; 139a98 <syscall_getcpu+0x18>
  139a8c:	ebfffe82 	bl	13949c <syscall_trace>
  139a90:	e3a00000 	mov	r0, #0
  139a94:	e8bd8010 	pop	{r4, pc}
  139a98:	0014c478 	.word	0x0014c478

00139a9c <syscall_move_pages>:
  139a9c:	e92d4010 	push	{r4, lr}
  139aa0:	e3a01013 	mov	r1, #19
  139aa4:	e59f0008 	ldr	r0, [pc, #8]	; 139ab4 <syscall_move_pages+0x18>
  139aa8:	ebfffe7b 	bl	13949c <syscall_trace>
  139aac:	e3a00000 	mov	r0, #0
  139ab0:	e8bd8010 	pop	{r4, pc}
  139ab4:	0014c464 	.word	0x0014c464

00139ab8 <syscall_vmsplice>:
  139ab8:	e92d4010 	push	{r4, lr}
  139abc:	e3a01011 	mov	r1, #17
  139ac0:	e59f0008 	ldr	r0, [pc, #8]	; 139ad0 <syscall_vmsplice+0x18>
  139ac4:	ebfffe74 	bl	13949c <syscall_trace>
  139ac8:	e3a00000 	mov	r0, #0
  139acc:	e8bd8010 	pop	{r4, pc}
  139ad0:	0014c450 	.word	0x0014c450

00139ad4 <syscall_tee>:
  139ad4:	e92d4010 	push	{r4, lr}
  139ad8:	e3a0100c 	mov	r1, #12
  139adc:	e59f0008 	ldr	r0, [pc, #8]	; 139aec <syscall_tee+0x18>
  139ae0:	ebfffe6d 	bl	13949c <syscall_trace>
  139ae4:	e3a00000 	mov	r0, #0
  139ae8:	e8bd8010 	pop	{r4, pc}
  139aec:	0014c444 	.word	0x0014c444

00139af0 <syscall_arm_sync_file_range>:
  139af0:	e92d4010 	push	{r4, lr}
  139af4:	e3a0101c 	mov	r1, #28
  139af8:	e59f0008 	ldr	r0, [pc, #8]	; 139b08 <syscall_arm_sync_file_range+0x18>
  139afc:	ebfffe66 	bl	13949c <syscall_trace>
  139b00:	e3a00000 	mov	r0, #0
  139b04:	e8bd8010 	pop	{r4, pc}
  139b08:	0014c428 	.word	0x0014c428

00139b0c <syscall_splice>:
  139b0c:	e92d4010 	push	{r4, lr}
  139b10:	e3a0100f 	mov	r1, #15
  139b14:	e59f0008 	ldr	r0, [pc, #8]	; 139b24 <syscall_splice+0x18>
  139b18:	ebfffe5f 	bl	13949c <syscall_trace>
  139b1c:	e3a00000 	mov	r0, #0
  139b20:	e8bd8010 	pop	{r4, pc}
  139b24:	0014c418 	.word	0x0014c418

00139b28 <syscall_get_robust_list>:
  139b28:	e92d4010 	push	{r4, lr}
  139b2c:	e3a01018 	mov	r1, #24
  139b30:	e59f0008 	ldr	r0, [pc, #8]	; 139b40 <syscall_get_robust_list+0x18>
  139b34:	ebfffe58 	bl	13949c <syscall_trace>
  139b38:	e3a00000 	mov	r0, #0
  139b3c:	e8bd8010 	pop	{r4, pc}
  139b40:	0014c400 	.word	0x0014c400

00139b44 <syscall_set_robust_list>:
  139b44:	e92d4010 	push	{r4, lr}
  139b48:	e3a01018 	mov	r1, #24
  139b4c:	e59f0008 	ldr	r0, [pc, #8]	; 139b5c <syscall_set_robust_list+0x18>
  139b50:	ebfffe51 	bl	13949c <syscall_trace>
  139b54:	e3a00000 	mov	r0, #0
  139b58:	e8bd8010 	pop	{r4, pc}
  139b5c:	0014c3e8 	.word	0x0014c3e8

00139b60 <syscall_unshare>:
  139b60:	e92d4010 	push	{r4, lr}
  139b64:	e3a01010 	mov	r1, #16
  139b68:	e59f0008 	ldr	r0, [pc, #8]	; 139b78 <syscall_unshare+0x18>
  139b6c:	ebfffe4a 	bl	13949c <syscall_trace>
  139b70:	e3a00000 	mov	r0, #0
  139b74:	e8bd8010 	pop	{r4, pc}
  139b78:	0014c3d8 	.word	0x0014c3d8

00139b7c <syscall_ppoll>:
  139b7c:	e92d4010 	push	{r4, lr}
  139b80:	e3a0100e 	mov	r1, #14
  139b84:	e59f0008 	ldr	r0, [pc, #8]	; 139b94 <syscall_ppoll+0x18>
  139b88:	ebfffe43 	bl	13949c <syscall_trace>
  139b8c:	e3a00000 	mov	r0, #0
  139b90:	e8bd8010 	pop	{r4, pc}
  139b94:	0014c3c8 	.word	0x0014c3c8

00139b98 <syscall_pselect6>:
  139b98:	e92d4010 	push	{r4, lr}
  139b9c:	e3a01011 	mov	r1, #17
  139ba0:	e59f0008 	ldr	r0, [pc, #8]	; 139bb0 <syscall_pselect6+0x18>
  139ba4:	ebfffe3c 	bl	13949c <syscall_trace>
  139ba8:	e3a00000 	mov	r0, #0
  139bac:	e8bd8010 	pop	{r4, pc}
  139bb0:	0014c3b4 	.word	0x0014c3b4

00139bb4 <syscall_faccessat>:
  139bb4:	e92d4010 	push	{r4, lr}
  139bb8:	e3a01012 	mov	r1, #18
  139bbc:	e59f0008 	ldr	r0, [pc, #8]	; 139bcc <syscall_faccessat+0x18>
  139bc0:	ebfffe35 	bl	13949c <syscall_trace>
  139bc4:	e3a00000 	mov	r0, #0
  139bc8:	e8bd8010 	pop	{r4, pc}
  139bcc:	0014c3a0 	.word	0x0014c3a0

00139bd0 <syscall_fchmodat>:
  139bd0:	e92d4010 	push	{r4, lr}
  139bd4:	e3a01011 	mov	r1, #17
  139bd8:	e59f0008 	ldr	r0, [pc, #8]	; 139be8 <syscall_fchmodat+0x18>
  139bdc:	ebfffe2e 	bl	13949c <syscall_trace>
  139be0:	e3a00000 	mov	r0, #0
  139be4:	e8bd8010 	pop	{r4, pc}
  139be8:	0014c38c 	.word	0x0014c38c

00139bec <syscall_readlinkat>:
  139bec:	e92d4010 	push	{r4, lr}
  139bf0:	e3a01013 	mov	r1, #19
  139bf4:	e59f0008 	ldr	r0, [pc, #8]	; 139c04 <syscall_readlinkat+0x18>
  139bf8:	ebfffe27 	bl	13949c <syscall_trace>
  139bfc:	e3a00000 	mov	r0, #0
  139c00:	e8bd8010 	pop	{r4, pc}
  139c04:	0014c378 	.word	0x0014c378

00139c08 <syscall_symlinkat>:
  139c08:	e92d4010 	push	{r4, lr}
  139c0c:	e3a01012 	mov	r1, #18
  139c10:	e59f0008 	ldr	r0, [pc, #8]	; 139c20 <syscall_symlinkat+0x18>
  139c14:	ebfffe20 	bl	13949c <syscall_trace>
  139c18:	e3a00000 	mov	r0, #0
  139c1c:	e8bd8010 	pop	{r4, pc}
  139c20:	0014c364 	.word	0x0014c364

00139c24 <syscall_linkat>:
  139c24:	e92d4010 	push	{r4, lr}
  139c28:	e3a0100f 	mov	r1, #15
  139c2c:	e59f0008 	ldr	r0, [pc, #8]	; 139c3c <syscall_linkat+0x18>
  139c30:	ebfffe19 	bl	13949c <syscall_trace>
  139c34:	e3a00000 	mov	r0, #0
  139c38:	e8bd8010 	pop	{r4, pc}
  139c3c:	0014c354 	.word	0x0014c354

00139c40 <syscall_renameat>:
  139c40:	e92d4010 	push	{r4, lr}
  139c44:	e3a01011 	mov	r1, #17
  139c48:	e59f0008 	ldr	r0, [pc, #8]	; 139c58 <syscall_renameat+0x18>
  139c4c:	ebfffe12 	bl	13949c <syscall_trace>
  139c50:	e3a00000 	mov	r0, #0
  139c54:	e8bd8010 	pop	{r4, pc}
  139c58:	0014c340 	.word	0x0014c340

00139c5c <syscall_unlinkat>:
  139c5c:	e92d4010 	push	{r4, lr}
  139c60:	e3a01011 	mov	r1, #17
  139c64:	e59f0008 	ldr	r0, [pc, #8]	; 139c74 <syscall_unlinkat+0x18>
  139c68:	ebfffe0b 	bl	13949c <syscall_trace>
  139c6c:	e3a00000 	mov	r0, #0
  139c70:	e8bd8010 	pop	{r4, pc}
  139c74:	0014c32c 	.word	0x0014c32c

00139c78 <syscall_fstatat64>:
  139c78:	e92d4010 	push	{r4, lr}
  139c7c:	e3a01012 	mov	r1, #18
  139c80:	e59f0008 	ldr	r0, [pc, #8]	; 139c90 <syscall_fstatat64+0x18>
  139c84:	ebfffe04 	bl	13949c <syscall_trace>
  139c88:	e3a00000 	mov	r0, #0
  139c8c:	e8bd8010 	pop	{r4, pc}
  139c90:	0014c318 	.word	0x0014c318

00139c94 <syscall_futimesat>:
  139c94:	e92d4010 	push	{r4, lr}
  139c98:	e3a01012 	mov	r1, #18
  139c9c:	e59f0008 	ldr	r0, [pc, #8]	; 139cac <syscall_futimesat+0x18>
  139ca0:	ebfffdfd 	bl	13949c <syscall_trace>
  139ca4:	e3a00000 	mov	r0, #0
  139ca8:	e8bd8010 	pop	{r4, pc}
  139cac:	0014c304 	.word	0x0014c304

00139cb0 <syscall_fchownat>:
  139cb0:	e92d4010 	push	{r4, lr}
  139cb4:	e3a01011 	mov	r1, #17
  139cb8:	e59f0008 	ldr	r0, [pc, #8]	; 139cc8 <syscall_fchownat+0x18>
  139cbc:	ebfffdf6 	bl	13949c <syscall_trace>
  139cc0:	e3a00000 	mov	r0, #0
  139cc4:	e8bd8010 	pop	{r4, pc}
  139cc8:	0014c2f0 	.word	0x0014c2f0

00139ccc <syscall_mknodat>:
  139ccc:	e92d4010 	push	{r4, lr}
  139cd0:	e3a01010 	mov	r1, #16
  139cd4:	e59f0008 	ldr	r0, [pc, #8]	; 139ce4 <syscall_mknodat+0x18>
  139cd8:	ebfffdef 	bl	13949c <syscall_trace>
  139cdc:	e3a00000 	mov	r0, #0
  139ce0:	e8bd8010 	pop	{r4, pc}
  139ce4:	0014c2e0 	.word	0x0014c2e0

00139ce8 <syscall_mkdirat>:
  139ce8:	e92d4010 	push	{r4, lr}
  139cec:	e3a01010 	mov	r1, #16
  139cf0:	e59f0008 	ldr	r0, [pc, #8]	; 139d00 <syscall_mkdirat+0x18>
  139cf4:	ebfffde8 	bl	13949c <syscall_trace>
  139cf8:	e3a00000 	mov	r0, #0
  139cfc:	e8bd8010 	pop	{r4, pc}
  139d00:	0014c2d0 	.word	0x0014c2d0

00139d04 <syscall_openat>:
  139d04:	e92d4010 	push	{r4, lr}
  139d08:	e3a0100f 	mov	r1, #15
  139d0c:	e59f0008 	ldr	r0, [pc, #8]	; 139d1c <syscall_openat+0x18>
  139d10:	ebfffde1 	bl	13949c <syscall_trace>
  139d14:	e3a00000 	mov	r0, #0
  139d18:	e8bd8010 	pop	{r4, pc}
  139d1c:	0014c2c0 	.word	0x0014c2c0

00139d20 <syscall_set_mempolicy>:
  139d20:	e92d4010 	push	{r4, lr}
  139d24:	e3a01016 	mov	r1, #22
  139d28:	e59f0008 	ldr	r0, [pc, #8]	; 139d38 <syscall_set_mempolicy+0x18>
  139d2c:	ebfffdda 	bl	13949c <syscall_trace>
  139d30:	e3a00000 	mov	r0, #0
  139d34:	e8bd8010 	pop	{r4, pc}
  139d38:	0014c2a8 	.word	0x0014c2a8

00139d3c <syscall_get_mempolicy>:
  139d3c:	e92d4010 	push	{r4, lr}
  139d40:	e3a01016 	mov	r1, #22
  139d44:	e59f0008 	ldr	r0, [pc, #8]	; 139d54 <syscall_get_mempolicy+0x18>
  139d48:	ebfffdd3 	bl	13949c <syscall_trace>
  139d4c:	e3a00000 	mov	r0, #0
  139d50:	e8bd8010 	pop	{r4, pc}
  139d54:	0014c290 	.word	0x0014c290

00139d58 <syscall_mbind>:
  139d58:	e92d4010 	push	{r4, lr}
  139d5c:	e3a0100e 	mov	r1, #14
  139d60:	e59f0008 	ldr	r0, [pc, #8]	; 139d70 <syscall_mbind+0x18>
  139d64:	ebfffdcc 	bl	13949c <syscall_trace>
  139d68:	e3a00000 	mov	r0, #0
  139d6c:	e8bd8010 	pop	{r4, pc}
  139d70:	0014c280 	.word	0x0014c280

00139d74 <syscall_inotify_rm_watch>:
  139d74:	e92d4010 	push	{r4, lr}
  139d78:	e3a01019 	mov	r1, #25
  139d7c:	e59f0008 	ldr	r0, [pc, #8]	; 139d8c <syscall_inotify_rm_watch+0x18>
  139d80:	ebfffdc5 	bl	13949c <syscall_trace>
  139d84:	e3a00000 	mov	r0, #0
  139d88:	e8bd8010 	pop	{r4, pc}
  139d8c:	0014c264 	.word	0x0014c264

00139d90 <syscall_inotify_add_watch>:
  139d90:	e92d4010 	push	{r4, lr}
  139d94:	e3a0101a 	mov	r1, #26
  139d98:	e59f0008 	ldr	r0, [pc, #8]	; 139da8 <syscall_inotify_add_watch+0x18>
  139d9c:	ebfffdbe 	bl	13949c <syscall_trace>
  139da0:	e3a00000 	mov	r0, #0
  139da4:	e8bd8010 	pop	{r4, pc}
  139da8:	0014c248 	.word	0x0014c248

00139dac <syscall_inotify_init>:
  139dac:	e92d4010 	push	{r4, lr}
  139db0:	e3a01015 	mov	r1, #21
  139db4:	e59f0008 	ldr	r0, [pc, #8]	; 139dc4 <syscall_inotify_init+0x18>
  139db8:	ebfffdb7 	bl	13949c <syscall_trace>
  139dbc:	e3a00000 	mov	r0, #0
  139dc0:	e8bd8010 	pop	{r4, pc}
  139dc4:	0014c230 	.word	0x0014c230

00139dc8 <syscall_ioprio_get>:
  139dc8:	e92d4010 	push	{r4, lr}
  139dcc:	e3a01013 	mov	r1, #19
  139dd0:	e59f0008 	ldr	r0, [pc, #8]	; 139de0 <syscall_ioprio_get+0x18>
  139dd4:	ebfffdb0 	bl	13949c <syscall_trace>
  139dd8:	e3a00000 	mov	r0, #0
  139ddc:	e8bd8010 	pop	{r4, pc}
  139de0:	0014c21c 	.word	0x0014c21c

00139de4 <syscall_ioprio_set>:
  139de4:	e92d4010 	push	{r4, lr}
  139de8:	e3a01013 	mov	r1, #19
  139dec:	e59f0008 	ldr	r0, [pc, #8]	; 139dfc <syscall_ioprio_set+0x18>
  139df0:	ebfffda9 	bl	13949c <syscall_trace>
  139df4:	e3a00000 	mov	r0, #0
  139df8:	e8bd8010 	pop	{r4, pc}
  139dfc:	0014c208 	.word	0x0014c208

00139e00 <syscall_vserver>:
  139e00:	e92d4010 	push	{r4, lr}
  139e04:	e3a01010 	mov	r1, #16
  139e08:	e59f0008 	ldr	r0, [pc, #8]	; 139e18 <syscall_vserver+0x18>
  139e0c:	ebfffda2 	bl	13949c <syscall_trace>
  139e10:	e3a00000 	mov	r0, #0
  139e14:	e8bd8010 	pop	{r4, pc}
  139e18:	0014c1f8 	.word	0x0014c1f8

00139e1c <syscall_semtimedop>:
  139e1c:	e92d4010 	push	{r4, lr}
  139e20:	e3a01013 	mov	r1, #19
  139e24:	e59f0008 	ldr	r0, [pc, #8]	; 139e34 <syscall_semtimedop+0x18>
  139e28:	ebfffd9b 	bl	13949c <syscall_trace>
  139e2c:	e3a00000 	mov	r0, #0
  139e30:	e8bd8010 	pop	{r4, pc}
  139e34:	0014c1e4 	.word	0x0014c1e4

00139e38 <syscall_keyctl>:
  139e38:	e92d4010 	push	{r4, lr}
  139e3c:	e3a0100f 	mov	r1, #15
  139e40:	e59f0008 	ldr	r0, [pc, #8]	; 139e50 <syscall_keyctl+0x18>
  139e44:	ebfffd94 	bl	13949c <syscall_trace>
  139e48:	e3a00000 	mov	r0, #0
  139e4c:	e8bd8010 	pop	{r4, pc}
  139e50:	0014c1d4 	.word	0x0014c1d4

00139e54 <syscall_request_key>:
  139e54:	e92d4010 	push	{r4, lr}
  139e58:	e3a01014 	mov	r1, #20
  139e5c:	e59f0008 	ldr	r0, [pc, #8]	; 139e6c <syscall_request_key+0x18>
  139e60:	ebfffd8d 	bl	13949c <syscall_trace>
  139e64:	e3a00000 	mov	r0, #0
  139e68:	e8bd8010 	pop	{r4, pc}
  139e6c:	0014c1c0 	.word	0x0014c1c0

00139e70 <syscall_add_key>:
  139e70:	e92d4010 	push	{r4, lr}
  139e74:	e3a01010 	mov	r1, #16
  139e78:	e59f0008 	ldr	r0, [pc, #8]	; 139e88 <syscall_add_key+0x18>
  139e7c:	ebfffd86 	bl	13949c <syscall_trace>
  139e80:	e3a00000 	mov	r0, #0
  139e84:	e8bd8010 	pop	{r4, pc}
  139e88:	0014c1b0 	.word	0x0014c1b0

00139e8c <syscall_msgctl>:
  139e8c:	e92d4010 	push	{r4, lr}
  139e90:	e3a0100f 	mov	r1, #15
  139e94:	e59f0008 	ldr	r0, [pc, #8]	; 139ea4 <syscall_msgctl+0x18>
  139e98:	ebfffd7f 	bl	13949c <syscall_trace>
  139e9c:	e3a00000 	mov	r0, #0
  139ea0:	e8bd8010 	pop	{r4, pc}
  139ea4:	0014c160 	.word	0x0014c160

00139ea8 <syscall_msgget>:
  139ea8:	e92d4010 	push	{r4, lr}
  139eac:	e3a0100f 	mov	r1, #15
  139eb0:	e59f0008 	ldr	r0, [pc, #8]	; 139ec0 <syscall_msgget+0x18>
  139eb4:	ebfffd78 	bl	13949c <syscall_trace>
  139eb8:	e3a00000 	mov	r0, #0
  139ebc:	e8bd8010 	pop	{r4, pc}
  139ec0:	0014c150 	.word	0x0014c150

00139ec4 <syscall_msgrcv>:
  139ec4:	e92d4010 	push	{r4, lr}
  139ec8:	e3a0100f 	mov	r1, #15
  139ecc:	e59f0008 	ldr	r0, [pc, #8]	; 139edc <syscall_msgrcv+0x18>
  139ed0:	ebfffd71 	bl	13949c <syscall_trace>
  139ed4:	e3a00000 	mov	r0, #0
  139ed8:	e8bd8010 	pop	{r4, pc}
  139edc:	0014c140 	.word	0x0014c140

00139ee0 <syscall_msgsnd>:
  139ee0:	e92d4010 	push	{r4, lr}
  139ee4:	e3a0100f 	mov	r1, #15
  139ee8:	e59f0008 	ldr	r0, [pc, #8]	; 139ef8 <syscall_msgsnd+0x18>
  139eec:	ebfffd6a 	bl	13949c <syscall_trace>
  139ef0:	e3a00000 	mov	r0, #0
  139ef4:	e8bd8010 	pop	{r4, pc}
  139ef8:	0014c130 	.word	0x0014c130

00139efc <syscall_semctl>:
  139efc:	e92d4010 	push	{r4, lr}
  139f00:	e3a0100f 	mov	r1, #15
  139f04:	e59f0008 	ldr	r0, [pc, #8]	; 139f14 <syscall_semctl+0x18>
  139f08:	ebfffd63 	bl	13949c <syscall_trace>
  139f0c:	e3a00000 	mov	r0, #0
  139f10:	e8bd8010 	pop	{r4, pc}
  139f14:	0014c120 	.word	0x0014c120

00139f18 <syscall_semget>:
  139f18:	e92d4010 	push	{r4, lr}
  139f1c:	e3a0100f 	mov	r1, #15
  139f20:	e59f0008 	ldr	r0, [pc, #8]	; 139f30 <syscall_semget+0x18>
  139f24:	ebfffd5c 	bl	13949c <syscall_trace>
  139f28:	e3a00000 	mov	r0, #0
  139f2c:	e8bd8010 	pop	{r4, pc}
  139f30:	0014c110 	.word	0x0014c110

00139f34 <syscall_semop>:
  139f34:	e92d4010 	push	{r4, lr}
  139f38:	e3a0100e 	mov	r1, #14
  139f3c:	e59f0008 	ldr	r0, [pc, #8]	; 139f4c <syscall_semop+0x18>
  139f40:	ebfffd55 	bl	13949c <syscall_trace>
  139f44:	e3a00000 	mov	r0, #0
  139f48:	e8bd8010 	pop	{r4, pc}
  139f4c:	0014c100 	.word	0x0014c100

00139f50 <syscall_recvmsg>:
  139f50:	e92d4010 	push	{r4, lr}
  139f54:	e3a01010 	mov	r1, #16
  139f58:	e59f0008 	ldr	r0, [pc, #8]	; 139f68 <syscall_recvmsg+0x18>
  139f5c:	ebfffd4e 	bl	13949c <syscall_trace>
  139f60:	e3a00000 	mov	r0, #0
  139f64:	e8bd8010 	pop	{r4, pc}
  139f68:	0014c0f0 	.word	0x0014c0f0

00139f6c <syscall_sendmsg>:
  139f6c:	e92d4010 	push	{r4, lr}
  139f70:	e3a01010 	mov	r1, #16
  139f74:	e59f0008 	ldr	r0, [pc, #8]	; 139f84 <syscall_sendmsg+0x18>
  139f78:	ebfffd47 	bl	13949c <syscall_trace>
  139f7c:	e3a00000 	mov	r0, #0
  139f80:	e8bd8010 	pop	{r4, pc}
  139f84:	0014c0e0 	.word	0x0014c0e0

00139f88 <syscall_shutdown>:
  139f88:	e92d4010 	push	{r4, lr}
  139f8c:	e3a01011 	mov	r1, #17
  139f90:	e59f0008 	ldr	r0, [pc, #8]	; 139fa0 <syscall_shutdown+0x18>
  139f94:	ebfffd40 	bl	13949c <syscall_trace>
  139f98:	e3a00000 	mov	r0, #0
  139f9c:	e8bd8010 	pop	{r4, pc}
  139fa0:	0014c0a4 	.word	0x0014c0a4

00139fa4 <syscall_socketpair>:
  139fa4:	e92d4010 	push	{r4, lr}
  139fa8:	e3a01013 	mov	r1, #19
  139fac:	e59f0008 	ldr	r0, [pc, #8]	; 139fbc <syscall_socketpair+0x18>
  139fb0:	ebfffd39 	bl	13949c <syscall_trace>
  139fb4:	e3a00000 	mov	r0, #0
  139fb8:	e8bd8010 	pop	{r4, pc}
  139fbc:	0014c04c 	.word	0x0014c04c

00139fc0 <syscall_waitid>:
  139fc0:	e92d4010 	push	{r4, lr}
  139fc4:	e3a0100f 	mov	r1, #15
  139fc8:	e59f0008 	ldr	r0, [pc, #8]	; 139fd8 <syscall_waitid+0x18>
  139fcc:	ebfffd32 	bl	13949c <syscall_trace>
  139fd0:	e3a00000 	mov	r0, #0
  139fd4:	e8bd8010 	pop	{r4, pc}
  139fd8:	0014bfc4 	.word	0x0014bfc4

00139fdc <syscall_mq_getsetattr>:
  139fdc:	e92d4010 	push	{r4, lr}
  139fe0:	e3a01016 	mov	r1, #22
  139fe4:	e59f0008 	ldr	r0, [pc, #8]	; 139ff4 <syscall_mq_getsetattr+0x18>
  139fe8:	ebfffd2b 	bl	13949c <syscall_trace>
  139fec:	e3a00000 	mov	r0, #0
  139ff0:	e8bd8010 	pop	{r4, pc}
  139ff4:	0014bfac 	.word	0x0014bfac

00139ff8 <syscall_mq_notify>:
  139ff8:	e92d4010 	push	{r4, lr}
  139ffc:	e3a01012 	mov	r1, #18
  13a000:	e59f0008 	ldr	r0, [pc, #8]	; 13a010 <syscall_mq_notify+0x18>
  13a004:	ebfffd24 	bl	13949c <syscall_trace>
  13a008:	e3a00000 	mov	r0, #0
  13a00c:	e8bd8010 	pop	{r4, pc}
  13a010:	0014bf98 	.word	0x0014bf98

0013a014 <syscall_mq_timedreceive>:
  13a014:	e92d4010 	push	{r4, lr}
  13a018:	e3a01018 	mov	r1, #24
  13a01c:	e59f0008 	ldr	r0, [pc, #8]	; 13a02c <syscall_mq_timedreceive+0x18>
  13a020:	ebfffd1d 	bl	13949c <syscall_trace>
  13a024:	e3a00000 	mov	r0, #0
  13a028:	e8bd8010 	pop	{r4, pc}
  13a02c:	0014bf80 	.word	0x0014bf80

0013a030 <syscall_mq_timedsend>:
  13a030:	e92d4010 	push	{r4, lr}
  13a034:	e3a01015 	mov	r1, #21
  13a038:	e59f0008 	ldr	r0, [pc, #8]	; 13a048 <syscall_mq_timedsend+0x18>
  13a03c:	ebfffd16 	bl	13949c <syscall_trace>
  13a040:	e3a00000 	mov	r0, #0
  13a044:	e8bd8010 	pop	{r4, pc}
  13a048:	0014bf68 	.word	0x0014bf68

0013a04c <syscall_mq_unlink>:
  13a04c:	e92d4010 	push	{r4, lr}
  13a050:	e3a01012 	mov	r1, #18
  13a054:	e59f0008 	ldr	r0, [pc, #8]	; 13a064 <syscall_mq_unlink+0x18>
  13a058:	ebfffd0f 	bl	13949c <syscall_trace>
  13a05c:	e3a00000 	mov	r0, #0
  13a060:	e8bd8010 	pop	{r4, pc}
  13a064:	0014bf54 	.word	0x0014bf54

0013a068 <syscall_mq_open>:
  13a068:	e92d4010 	push	{r4, lr}
  13a06c:	e3a01010 	mov	r1, #16
  13a070:	e59f0008 	ldr	r0, [pc, #8]	; 13a080 <syscall_mq_open+0x18>
  13a074:	ebfffd08 	bl	13949c <syscall_trace>
  13a078:	e3a00000 	mov	r0, #0
  13a07c:	e8bd8010 	pop	{r4, pc}
  13a080:	0014bf44 	.word	0x0014bf44

0013a084 <syscall_pciconfig_write>:
  13a084:	e92d4010 	push	{r4, lr}
  13a088:	e3a01018 	mov	r1, #24
  13a08c:	e59f0008 	ldr	r0, [pc, #8]	; 13a09c <syscall_pciconfig_write+0x18>
  13a090:	ebfffd01 	bl	13949c <syscall_trace>
  13a094:	e3a00000 	mov	r0, #0
  13a098:	e8bd8010 	pop	{r4, pc}
  13a09c:	0014bf2c 	.word	0x0014bf2c

0013a0a0 <syscall_pciconfig_read>:
  13a0a0:	e92d4010 	push	{r4, lr}
  13a0a4:	e3a01017 	mov	r1, #23
  13a0a8:	e59f0008 	ldr	r0, [pc, #8]	; 13a0b8 <syscall_pciconfig_read+0x18>
  13a0ac:	ebfffcfa 	bl	13949c <syscall_trace>
  13a0b0:	e3a00000 	mov	r0, #0
  13a0b4:	e8bd8010 	pop	{r4, pc}
  13a0b8:	0014bf14 	.word	0x0014bf14

0013a0bc <syscall_pciconfig_iobase>:
  13a0bc:	e92d4010 	push	{r4, lr}
  13a0c0:	e3a01019 	mov	r1, #25
  13a0c4:	e59f0008 	ldr	r0, [pc, #8]	; 13a0d4 <syscall_pciconfig_iobase+0x18>
  13a0c8:	ebfffcf3 	bl	13949c <syscall_trace>
  13a0cc:	e3a00000 	mov	r0, #0
  13a0d0:	e8bd8010 	pop	{r4, pc}
  13a0d4:	0014bef8 	.word	0x0014bef8

0013a0d8 <syscall_arm_fadvise64_64>:
  13a0d8:	e92d4010 	push	{r4, lr}
  13a0dc:	e3a01019 	mov	r1, #25
  13a0e0:	e59f0008 	ldr	r0, [pc, #8]	; 13a0f0 <syscall_arm_fadvise64_64+0x18>
  13a0e4:	ebfffcec 	bl	13949c <syscall_trace>
  13a0e8:	e3a00000 	mov	r0, #0
  13a0ec:	e8bd8010 	pop	{r4, pc}
  13a0f0:	0014bedc 	.word	0x0014bedc

0013a0f4 <syscall_utimes>:
  13a0f4:	e92d4010 	push	{r4, lr}
  13a0f8:	e3a0100f 	mov	r1, #15
  13a0fc:	e59f0008 	ldr	r0, [pc, #8]	; 13a10c <syscall_utimes+0x18>
  13a100:	ebfffce5 	bl	13949c <syscall_trace>
  13a104:	e3a00000 	mov	r0, #0
  13a108:	e8bd8010 	pop	{r4, pc}
  13a10c:	0014becc 	.word	0x0014becc

0013a110 <syscall_tgkill>:
  13a110:	e92d4010 	push	{r4, lr}
  13a114:	e3a0100f 	mov	r1, #15
  13a118:	e59f0008 	ldr	r0, [pc, #8]	; 13a128 <syscall_tgkill+0x18>
  13a11c:	ebfffcde 	bl	13949c <syscall_trace>
  13a120:	e3a00000 	mov	r0, #0
  13a124:	e8bd8010 	pop	{r4, pc}
  13a128:	0014bebc 	.word	0x0014bebc

0013a12c <syscall_fstatfs64>:
  13a12c:	e92d4010 	push	{r4, lr}
  13a130:	e3a01012 	mov	r1, #18
  13a134:	e59f0008 	ldr	r0, [pc, #8]	; 13a144 <syscall_fstatfs64+0x18>
  13a138:	ebfffcd7 	bl	13949c <syscall_trace>
  13a13c:	e3a00000 	mov	r0, #0
  13a140:	e8bd8010 	pop	{r4, pc}
  13a144:	0014bea8 	.word	0x0014bea8

0013a148 <syscall_statfs64>:
  13a148:	e92d4010 	push	{r4, lr}
  13a14c:	e3a01011 	mov	r1, #17
  13a150:	e59f0008 	ldr	r0, [pc, #8]	; 13a160 <syscall_statfs64+0x18>
  13a154:	ebfffcd0 	bl	13949c <syscall_trace>
  13a158:	e3a00000 	mov	r0, #0
  13a15c:	e8bd8010 	pop	{r4, pc}
  13a160:	0014be94 	.word	0x0014be94

0013a164 <syscall_clock_nanosleep>:
  13a164:	e92d4010 	push	{r4, lr}
  13a168:	e3a01018 	mov	r1, #24
  13a16c:	e59f0008 	ldr	r0, [pc, #8]	; 13a17c <syscall_clock_nanosleep+0x18>
  13a170:	ebfffcc9 	bl	13949c <syscall_trace>
  13a174:	e3a00000 	mov	r0, #0
  13a178:	e8bd8010 	pop	{r4, pc}
  13a17c:	0014be7c 	.word	0x0014be7c

0013a180 <syscall_timer_delete>:
  13a180:	e92d4010 	push	{r4, lr}
  13a184:	e3a01015 	mov	r1, #21
  13a188:	e59f0008 	ldr	r0, [pc, #8]	; 13a198 <syscall_timer_delete+0x18>
  13a18c:	ebfffcc2 	bl	13949c <syscall_trace>
  13a190:	e3a00000 	mov	r0, #0
  13a194:	e8bd8010 	pop	{r4, pc}
  13a198:	0014be1c 	.word	0x0014be1c

0013a19c <syscall_timer_getoverrun>:
  13a19c:	e92d4010 	push	{r4, lr}
  13a1a0:	e3a01019 	mov	r1, #25
  13a1a4:	e59f0008 	ldr	r0, [pc, #8]	; 13a1b4 <syscall_timer_getoverrun+0x18>
  13a1a8:	ebfffcbb 	bl	13949c <syscall_trace>
  13a1ac:	e3a00000 	mov	r0, #0
  13a1b0:	e8bd8010 	pop	{r4, pc}
  13a1b4:	0014be00 	.word	0x0014be00

0013a1b8 <syscall_timer_gettime>:
  13a1b8:	e92d4010 	push	{r4, lr}
  13a1bc:	e3a01016 	mov	r1, #22
  13a1c0:	e59f0008 	ldr	r0, [pc, #8]	; 13a1d0 <syscall_timer_gettime+0x18>
  13a1c4:	ebfffcb4 	bl	13949c <syscall_trace>
  13a1c8:	e3a00000 	mov	r0, #0
  13a1cc:	e8bd8010 	pop	{r4, pc}
  13a1d0:	0014bde8 	.word	0x0014bde8

0013a1d4 <syscall_timer_settime>:
  13a1d4:	e92d4010 	push	{r4, lr}
  13a1d8:	e3a01016 	mov	r1, #22
  13a1dc:	e59f0008 	ldr	r0, [pc, #8]	; 13a1ec <syscall_timer_settime+0x18>
  13a1e0:	ebfffcad 	bl	13949c <syscall_trace>
  13a1e4:	e3a00000 	mov	r0, #0
  13a1e8:	e8bd8010 	pop	{r4, pc}
  13a1ec:	0014bdd0 	.word	0x0014bdd0

0013a1f0 <syscall_timer_create>:
  13a1f0:	e92d4010 	push	{r4, lr}
  13a1f4:	e3a01015 	mov	r1, #21
  13a1f8:	e59f0008 	ldr	r0, [pc, #8]	; 13a208 <syscall_timer_create+0x18>
  13a1fc:	ebfffca6 	bl	13949c <syscall_trace>
  13a200:	e3a00000 	mov	r0, #0
  13a204:	e8bd8010 	pop	{r4, pc}
  13a208:	0014bdb8 	.word	0x0014bdb8

0013a20c <syscall_remap_file_pages>:
  13a20c:	e92d4010 	push	{r4, lr}
  13a210:	e3a01019 	mov	r1, #25
  13a214:	e59f0008 	ldr	r0, [pc, #8]	; 13a224 <syscall_remap_file_pages+0x18>
  13a218:	ebfffc9f 	bl	13949c <syscall_trace>
  13a21c:	e3a00000 	mov	r0, #0
  13a220:	e8bd8010 	pop	{r4, pc}
  13a224:	0014bd84 	.word	0x0014bd84

0013a228 <syscall_epoll_wait>:
  13a228:	e92d4010 	push	{r4, lr}
  13a22c:	e3a01013 	mov	r1, #19
  13a230:	e59f0008 	ldr	r0, [pc, #8]	; 13a240 <syscall_epoll_wait+0x18>
  13a234:	ebfffc98 	bl	13949c <syscall_trace>
  13a238:	e3e00025 	mvn	r0, #37	; 0x25
  13a23c:	e8bd8010 	pop	{r4, pc}
  13a240:	0014bd70 	.word	0x0014bd70

0013a244 <syscall_epoll_ctl>:
  13a244:	e92d4010 	push	{r4, lr}
  13a248:	e3a01012 	mov	r1, #18
  13a24c:	e59f0008 	ldr	r0, [pc, #8]	; 13a25c <syscall_epoll_ctl+0x18>
  13a250:	ebfffc91 	bl	13949c <syscall_trace>
  13a254:	e3e00025 	mvn	r0, #37	; 0x25
  13a258:	e8bd8010 	pop	{r4, pc}
  13a25c:	0014bd5c 	.word	0x0014bd5c

0013a260 <syscall_epoll_create>:
  13a260:	e92d4010 	push	{r4, lr}
  13a264:	e3a01015 	mov	r1, #21
  13a268:	e59f0008 	ldr	r0, [pc, #8]	; 13a278 <syscall_epoll_create+0x18>
  13a26c:	ebfffc8a 	bl	13949c <syscall_trace>
  13a270:	e3e00025 	mvn	r0, #37	; 0x25
  13a274:	e8bd8010 	pop	{r4, pc}
  13a278:	0014bd44 	.word	0x0014bd44

0013a27c <syscall_lookup_dcookie>:
  13a27c:	e92d4010 	push	{r4, lr}
  13a280:	e3a01017 	mov	r1, #23
  13a284:	e59f0008 	ldr	r0, [pc, #8]	; 13a294 <syscall_lookup_dcookie+0x18>
  13a288:	ebfffc83 	bl	13949c <syscall_trace>
  13a28c:	e3a00000 	mov	r0, #0
  13a290:	e8bd8010 	pop	{r4, pc}
  13a294:	0014bd2c 	.word	0x0014bd2c

0013a298 <syscall_io_cancel>:
  13a298:	e92d4010 	push	{r4, lr}
  13a29c:	e3a01012 	mov	r1, #18
  13a2a0:	e59f0008 	ldr	r0, [pc, #8]	; 13a2b0 <syscall_io_cancel+0x18>
  13a2a4:	ebfffc7c 	bl	13949c <syscall_trace>
  13a2a8:	e3a00000 	mov	r0, #0
  13a2ac:	e8bd8010 	pop	{r4, pc}
  13a2b0:	0014bd04 	.word	0x0014bd04

0013a2b4 <syscall_io_submit>:
  13a2b4:	e92d4010 	push	{r4, lr}
  13a2b8:	e3a01012 	mov	r1, #18
  13a2bc:	e59f0008 	ldr	r0, [pc, #8]	; 13a2cc <syscall_io_submit+0x18>
  13a2c0:	ebfffc75 	bl	13949c <syscall_trace>
  13a2c4:	e3a00000 	mov	r0, #0
  13a2c8:	e8bd8010 	pop	{r4, pc}
  13a2cc:	0014bcf0 	.word	0x0014bcf0

0013a2d0 <syscall_io_getevents>:
  13a2d0:	e92d4010 	push	{r4, lr}
  13a2d4:	e3a01015 	mov	r1, #21
  13a2d8:	e59f0008 	ldr	r0, [pc, #8]	; 13a2e8 <syscall_io_getevents+0x18>
  13a2dc:	ebfffc6e 	bl	13949c <syscall_trace>
  13a2e0:	e3a00000 	mov	r0, #0
  13a2e4:	e8bd8010 	pop	{r4, pc}
  13a2e8:	0014bcd8 	.word	0x0014bcd8

0013a2ec <syscall_io_destroy>:
  13a2ec:	e92d4010 	push	{r4, lr}
  13a2f0:	e3a01013 	mov	r1, #19
  13a2f4:	e59f0008 	ldr	r0, [pc, #8]	; 13a304 <syscall_io_destroy+0x18>
  13a2f8:	ebfffc67 	bl	13949c <syscall_trace>
  13a2fc:	e3a00000 	mov	r0, #0
  13a300:	e8bd8010 	pop	{r4, pc}
  13a304:	0014bcc4 	.word	0x0014bcc4

0013a308 <syscall_io_setup>:
  13a308:	e92d4010 	push	{r4, lr}
  13a30c:	e3a01011 	mov	r1, #17
  13a310:	e59f0008 	ldr	r0, [pc, #8]	; 13a320 <syscall_io_setup+0x18>
  13a314:	ebfffc60 	bl	13949c <syscall_trace>
  13a318:	e3a00000 	mov	r0, #0
  13a31c:	e8bd8010 	pop	{r4, pc}
  13a320:	0014bcb0 	.word	0x0014bcb0

0013a324 <syscall_sched_getaffinity>:
  13a324:	e92d4010 	push	{r4, lr}
  13a328:	e3a0101a 	mov	r1, #26
  13a32c:	e59f0008 	ldr	r0, [pc, #8]	; 13a33c <syscall_sched_getaffinity+0x18>
  13a330:	ebfffc59 	bl	13949c <syscall_trace>
  13a334:	e3a00000 	mov	r0, #0
  13a338:	e8bd8010 	pop	{r4, pc}
  13a33c:	0014bc94 	.word	0x0014bc94

0013a340 <syscall_sendfile64>:
  13a340:	e92d4010 	push	{r4, lr}
  13a344:	e3a01013 	mov	r1, #19
  13a348:	e59f0008 	ldr	r0, [pc, #8]	; 13a358 <syscall_sendfile64+0x18>
  13a34c:	ebfffc52 	bl	13949c <syscall_trace>
  13a350:	e3a00000 	mov	r0, #0
  13a354:	e8bd8010 	pop	{r4, pc}
  13a358:	0014bc54 	.word	0x0014bc54

0013a35c <syscall_fremovexattr>:
  13a35c:	e92d4010 	push	{r4, lr}
  13a360:	e3a01015 	mov	r1, #21
  13a364:	e59f0008 	ldr	r0, [pc, #8]	; 13a374 <syscall_fremovexattr+0x18>
  13a368:	ebfffc4b 	bl	13949c <syscall_trace>
  13a36c:	e3a00000 	mov	r0, #0
  13a370:	e8bd8010 	pop	{r4, pc}
  13a374:	0014bc2c 	.word	0x0014bc2c

0013a378 <syscall_lremovexattr>:
  13a378:	e92d4010 	push	{r4, lr}
  13a37c:	e3a01015 	mov	r1, #21
  13a380:	e59f0008 	ldr	r0, [pc, #8]	; 13a390 <syscall_lremovexattr+0x18>
  13a384:	ebfffc44 	bl	13949c <syscall_trace>
  13a388:	e3a00000 	mov	r0, #0
  13a38c:	e8bd8010 	pop	{r4, pc}
  13a390:	0014bc14 	.word	0x0014bc14

0013a394 <syscall_removexattr>:
  13a394:	e92d4010 	push	{r4, lr}
  13a398:	e3a01014 	mov	r1, #20
  13a39c:	e59f0008 	ldr	r0, [pc, #8]	; 13a3ac <syscall_removexattr+0x18>
  13a3a0:	ebfffc3d 	bl	13949c <syscall_trace>
  13a3a4:	e3a00000 	mov	r0, #0
  13a3a8:	e8bd8010 	pop	{r4, pc}
  13a3ac:	0014bc00 	.word	0x0014bc00

0013a3b0 <syscall_flistxattr>:
  13a3b0:	e92d4010 	push	{r4, lr}
  13a3b4:	e3a01013 	mov	r1, #19
  13a3b8:	e59f0008 	ldr	r0, [pc, #8]	; 13a3c8 <syscall_flistxattr+0x18>
  13a3bc:	ebfffc36 	bl	13949c <syscall_trace>
  13a3c0:	e3a00000 	mov	r0, #0
  13a3c4:	e8bd8010 	pop	{r4, pc}
  13a3c8:	0014bbec 	.word	0x0014bbec

0013a3cc <syscall_llistxattr>:
  13a3cc:	e92d4010 	push	{r4, lr}
  13a3d0:	e3a01013 	mov	r1, #19
  13a3d4:	e59f0008 	ldr	r0, [pc, #8]	; 13a3e4 <syscall_llistxattr+0x18>
  13a3d8:	ebfffc2f 	bl	13949c <syscall_trace>
  13a3dc:	e3a00000 	mov	r0, #0
  13a3e0:	e8bd8010 	pop	{r4, pc}
  13a3e4:	0014bbd8 	.word	0x0014bbd8

0013a3e8 <syscall_listxattr>:
  13a3e8:	e92d4010 	push	{r4, lr}
  13a3ec:	e3a01012 	mov	r1, #18
  13a3f0:	e59f0008 	ldr	r0, [pc, #8]	; 13a400 <syscall_listxattr+0x18>
  13a3f4:	ebfffc28 	bl	13949c <syscall_trace>
  13a3f8:	e3a00000 	mov	r0, #0
  13a3fc:	e8bd8010 	pop	{r4, pc}
  13a400:	0014bbc4 	.word	0x0014bbc4

0013a404 <syscall_fgetxattr>:
  13a404:	e92d4010 	push	{r4, lr}
  13a408:	e3a01012 	mov	r1, #18
  13a40c:	e59f0008 	ldr	r0, [pc, #8]	; 13a41c <syscall_fgetxattr+0x18>
  13a410:	ebfffc21 	bl	13949c <syscall_trace>
  13a414:	e3a00000 	mov	r0, #0
  13a418:	e8bd8010 	pop	{r4, pc}
  13a41c:	0014bbb0 	.word	0x0014bbb0

0013a420 <syscall_lgetxattr>:
  13a420:	e92d4010 	push	{r4, lr}
  13a424:	e3a01012 	mov	r1, #18
  13a428:	e59f0008 	ldr	r0, [pc, #8]	; 13a438 <syscall_lgetxattr+0x18>
  13a42c:	ebfffc1a 	bl	13949c <syscall_trace>
  13a430:	e3a00000 	mov	r0, #0
  13a434:	e8bd8010 	pop	{r4, pc}
  13a438:	0014bb9c 	.word	0x0014bb9c

0013a43c <syscall_getxattr>:
  13a43c:	e92d4010 	push	{r4, lr}
  13a440:	e3a01011 	mov	r1, #17
  13a444:	e59f0008 	ldr	r0, [pc, #8]	; 13a454 <syscall_getxattr+0x18>
  13a448:	ebfffc13 	bl	13949c <syscall_trace>
  13a44c:	e3a00000 	mov	r0, #0
  13a450:	e8bd8010 	pop	{r4, pc}
  13a454:	0014bb88 	.word	0x0014bb88

0013a458 <syscall_fsetxattr>:
  13a458:	e92d4010 	push	{r4, lr}
  13a45c:	e3a01012 	mov	r1, #18
  13a460:	e59f0008 	ldr	r0, [pc, #8]	; 13a470 <syscall_fsetxattr+0x18>
  13a464:	ebfffc0c 	bl	13949c <syscall_trace>
  13a468:	e3a00000 	mov	r0, #0
  13a46c:	e8bd8010 	pop	{r4, pc}
  13a470:	0014bb74 	.word	0x0014bb74

0013a474 <syscall_lsetxattr>:
  13a474:	e92d4010 	push	{r4, lr}
  13a478:	e3a01012 	mov	r1, #18
  13a47c:	e59f0008 	ldr	r0, [pc, #8]	; 13a48c <syscall_lsetxattr+0x18>
  13a480:	ebfffc05 	bl	13949c <syscall_trace>
  13a484:	e3a00000 	mov	r0, #0
  13a488:	e8bd8010 	pop	{r4, pc}
  13a48c:	0014bb60 	.word	0x0014bb60

0013a490 <syscall_setxattr>:
  13a490:	e92d4010 	push	{r4, lr}
  13a494:	e3a01011 	mov	r1, #17
  13a498:	e59f0008 	ldr	r0, [pc, #8]	; 13a4a8 <syscall_setxattr+0x18>
  13a49c:	ebfffbfe 	bl	13949c <syscall_trace>
  13a4a0:	e3a00000 	mov	r0, #0
  13a4a4:	e8bd8010 	pop	{r4, pc}
  13a4a8:	0014bb4c 	.word	0x0014bb4c

0013a4ac <syscall_readahead>:
  13a4ac:	e92d4010 	push	{r4, lr}
  13a4b0:	e3a01012 	mov	r1, #18
  13a4b4:	e59f0008 	ldr	r0, [pc, #8]	; 13a4c4 <syscall_readahead+0x18>
  13a4b8:	ebfffbf7 	bl	13949c <syscall_trace>
  13a4bc:	e3a00000 	mov	r0, #0
  13a4c0:	e8bd8010 	pop	{r4, pc}
  13a4c4:	0014bb38 	.word	0x0014bb38

0013a4c8 <syscall_mincore>:
  13a4c8:	e92d4010 	push	{r4, lr}
  13a4cc:	e3a01010 	mov	r1, #16
  13a4d0:	e59f0008 	ldr	r0, [pc, #8]	; 13a4e0 <syscall_mincore+0x18>
  13a4d4:	ebfffbf0 	bl	13949c <syscall_trace>
  13a4d8:	e3a00000 	mov	r0, #0
  13a4dc:	e8bd8010 	pop	{r4, pc}
  13a4e0:	0014baf8 	.word	0x0014baf8

0013a4e4 <syscall_pivot_root>:
  13a4e4:	e92d4010 	push	{r4, lr}
  13a4e8:	e3a01013 	mov	r1, #19
  13a4ec:	e59f0008 	ldr	r0, [pc, #8]	; 13a4fc <syscall_pivot_root+0x18>
  13a4f0:	ebfffbe9 	bl	13949c <syscall_trace>
  13a4f4:	e3a00000 	mov	r0, #0
  13a4f8:	e8bd8010 	pop	{r4, pc}
  13a4fc:	0014bae4 	.word	0x0014bae4

0013a500 <syscall_setfsgid32>:
  13a500:	e92d4010 	push	{r4, lr}
  13a504:	e3a01013 	mov	r1, #19
  13a508:	e59f0008 	ldr	r0, [pc, #8]	; 13a518 <syscall_setfsgid32+0x18>
  13a50c:	ebfffbe2 	bl	13949c <syscall_trace>
  13a510:	e3a00000 	mov	r0, #0
  13a514:	e8bd8010 	pop	{r4, pc}
  13a518:	0014babc 	.word	0x0014babc

0013a51c <syscall_setfsuid32>:
  13a51c:	e92d4010 	push	{r4, lr}
  13a520:	e3a01013 	mov	r1, #19
  13a524:	e59f0008 	ldr	r0, [pc, #8]	; 13a534 <syscall_setfsuid32+0x18>
  13a528:	ebfffbdb 	bl	13949c <syscall_trace>
  13a52c:	e3a00000 	mov	r0, #0
  13a530:	e8bd8010 	pop	{r4, pc}
  13a534:	0014baa8 	.word	0x0014baa8

0013a538 <syscall_setgid32>:
  13a538:	e92d4010 	push	{r4, lr}
  13a53c:	e3a01011 	mov	r1, #17
  13a540:	e59f0008 	ldr	r0, [pc, #8]	; 13a550 <syscall_setgid32+0x18>
  13a544:	ebfffbd4 	bl	13949c <syscall_trace>
  13a548:	e3a00000 	mov	r0, #0
  13a54c:	e8bd8010 	pop	{r4, pc}
  13a550:	0014ba94 	.word	0x0014ba94

0013a554 <syscall_setuid32>:
  13a554:	e92d4010 	push	{r4, lr}
  13a558:	e3a01011 	mov	r1, #17
  13a55c:	e59f0008 	ldr	r0, [pc, #8]	; 13a56c <syscall_setuid32+0x18>
  13a560:	ebfffbcd 	bl	13949c <syscall_trace>
  13a564:	e3a00000 	mov	r0, #0
  13a568:	e8bd8010 	pop	{r4, pc}
  13a56c:	0014ba80 	.word	0x0014ba80

0013a570 <syscall_chown32>:
  13a570:	e92d4010 	push	{r4, lr}
  13a574:	e3a01010 	mov	r1, #16
  13a578:	e59f0008 	ldr	r0, [pc, #8]	; 13a588 <syscall_chown32+0x18>
  13a57c:	ebfffbc6 	bl	13949c <syscall_trace>
  13a580:	e3a00000 	mov	r0, #0
  13a584:	e8bd8010 	pop	{r4, pc}
  13a588:	0014ba70 	.word	0x0014ba70

0013a58c <syscall_getresgid32>:
  13a58c:	e92d4010 	push	{r4, lr}
  13a590:	e3a01014 	mov	r1, #20
  13a594:	e59f0008 	ldr	r0, [pc, #8]	; 13a5a4 <syscall_getresgid32+0x18>
  13a598:	ebfffbbf 	bl	13949c <syscall_trace>
  13a59c:	e3a00000 	mov	r0, #0
  13a5a0:	e8bd8010 	pop	{r4, pc}
  13a5a4:	0014ba5c 	.word	0x0014ba5c

0013a5a8 <syscall_setresgid32>:
  13a5a8:	e92d4010 	push	{r4, lr}
  13a5ac:	e3a01014 	mov	r1, #20
  13a5b0:	e59f0008 	ldr	r0, [pc, #8]	; 13a5c0 <syscall_setresgid32+0x18>
  13a5b4:	ebfffbb8 	bl	13949c <syscall_trace>
  13a5b8:	e3a00000 	mov	r0, #0
  13a5bc:	e8bd8010 	pop	{r4, pc}
  13a5c0:	0014ba48 	.word	0x0014ba48

0013a5c4 <syscall_getresuid32>:
  13a5c4:	e92d4010 	push	{r4, lr}
  13a5c8:	e3a01014 	mov	r1, #20
  13a5cc:	e59f0008 	ldr	r0, [pc, #8]	; 13a5dc <syscall_getresuid32+0x18>
  13a5d0:	ebfffbb1 	bl	13949c <syscall_trace>
  13a5d4:	e3a00000 	mov	r0, #0
  13a5d8:	e8bd8010 	pop	{r4, pc}
  13a5dc:	0014ba34 	.word	0x0014ba34

0013a5e0 <syscall_setresuid32>:
  13a5e0:	e92d4010 	push	{r4, lr}
  13a5e4:	e3a01014 	mov	r1, #20
  13a5e8:	e59f0008 	ldr	r0, [pc, #8]	; 13a5f8 <syscall_setresuid32+0x18>
  13a5ec:	ebfffbaa 	bl	13949c <syscall_trace>
  13a5f0:	e3a00000 	mov	r0, #0
  13a5f4:	e8bd8010 	pop	{r4, pc}
  13a5f8:	0014ba20 	.word	0x0014ba20

0013a5fc <syscall_fchown32>:
  13a5fc:	e92d4010 	push	{r4, lr}
  13a600:	e3a01011 	mov	r1, #17
  13a604:	e59f0008 	ldr	r0, [pc, #8]	; 13a614 <syscall_fchown32+0x18>
  13a608:	ebfffba3 	bl	13949c <syscall_trace>
  13a60c:	e3a00000 	mov	r0, #0
  13a610:	e8bd8010 	pop	{r4, pc}
  13a614:	0014ba0c 	.word	0x0014ba0c

0013a618 <syscall_setgroups32>:
  13a618:	e92d4010 	push	{r4, lr}
  13a61c:	e3a01014 	mov	r1, #20
  13a620:	e59f0008 	ldr	r0, [pc, #8]	; 13a630 <syscall_setgroups32+0x18>
  13a624:	ebfffb9c 	bl	13949c <syscall_trace>
  13a628:	e3a00000 	mov	r0, #0
  13a62c:	e8bd8010 	pop	{r4, pc}
  13a630:	0014b9f8 	.word	0x0014b9f8

0013a634 <syscall_getgroups32>:
  13a634:	e92d4010 	push	{r4, lr}
  13a638:	e3a01014 	mov	r1, #20
  13a63c:	e59f0008 	ldr	r0, [pc, #8]	; 13a64c <syscall_getgroups32+0x18>
  13a640:	ebfffb95 	bl	13949c <syscall_trace>
  13a644:	e3a00000 	mov	r0, #0
  13a648:	e8bd8010 	pop	{r4, pc}
  13a64c:	0014b9e4 	.word	0x0014b9e4

0013a650 <syscall_setregid32>:
  13a650:	e92d4010 	push	{r4, lr}
  13a654:	e3a01013 	mov	r1, #19
  13a658:	e59f0008 	ldr	r0, [pc, #8]	; 13a668 <syscall_setregid32+0x18>
  13a65c:	ebfffb8e 	bl	13949c <syscall_trace>
  13a660:	e3a00000 	mov	r0, #0
  13a664:	e8bd8010 	pop	{r4, pc}
  13a668:	0014b9d0 	.word	0x0014b9d0

0013a66c <syscall_setreuid32>:
  13a66c:	e92d4010 	push	{r4, lr}
  13a670:	e3a01013 	mov	r1, #19
  13a674:	e59f0008 	ldr	r0, [pc, #8]	; 13a684 <syscall_setreuid32+0x18>
  13a678:	ebfffb87 	bl	13949c <syscall_trace>
  13a67c:	e3a00000 	mov	r0, #0
  13a680:	e8bd8010 	pop	{r4, pc}
  13a684:	0014b9bc 	.word	0x0014b9bc

0013a688 <syscall_getegid32>:
  13a688:	e92d4010 	push	{r4, lr}
  13a68c:	e3a01012 	mov	r1, #18
  13a690:	e59f0008 	ldr	r0, [pc, #8]	; 13a6a0 <syscall_getegid32+0x18>
  13a694:	ebfffb80 	bl	13949c <syscall_trace>
  13a698:	e3a00000 	mov	r0, #0
  13a69c:	e8bd8010 	pop	{r4, pc}
  13a6a0:	0014b9a8 	.word	0x0014b9a8

0013a6a4 <syscall_geteuid32>:
  13a6a4:	e92d4010 	push	{r4, lr}
  13a6a8:	e3a01012 	mov	r1, #18
  13a6ac:	e59f0008 	ldr	r0, [pc, #8]	; 13a6bc <syscall_geteuid32+0x18>
  13a6b0:	ebfffb79 	bl	13949c <syscall_trace>
  13a6b4:	e3a00000 	mov	r0, #0
  13a6b8:	e8bd8010 	pop	{r4, pc}
  13a6bc:	0014b994 	.word	0x0014b994

0013a6c0 <syscall_getgid32>:
  13a6c0:	e92d4010 	push	{r4, lr}
  13a6c4:	e3a01011 	mov	r1, #17
  13a6c8:	e59f0008 	ldr	r0, [pc, #8]	; 13a6d8 <syscall_getgid32+0x18>
  13a6cc:	ebfffb72 	bl	13949c <syscall_trace>
  13a6d0:	e3a00000 	mov	r0, #0
  13a6d4:	e8bd8010 	pop	{r4, pc}
  13a6d8:	0014b980 	.word	0x0014b980

0013a6dc <syscall_getuid32>:
  13a6dc:	e92d4010 	push	{r4, lr}
  13a6e0:	e3a01011 	mov	r1, #17
  13a6e4:	e59f0008 	ldr	r0, [pc, #8]	; 13a6f4 <syscall_getuid32+0x18>
  13a6e8:	ebfffb6b 	bl	13949c <syscall_trace>
  13a6ec:	e3a00000 	mov	r0, #0
  13a6f0:	e8bd8010 	pop	{r4, pc}
  13a6f4:	0014b96c 	.word	0x0014b96c

0013a6f8 <syscall_lchown32>:
  13a6f8:	e92d4010 	push	{r4, lr}
  13a6fc:	e3a01011 	mov	r1, #17
  13a700:	e59f0008 	ldr	r0, [pc, #8]	; 13a710 <syscall_lchown32+0x18>
  13a704:	ebfffb64 	bl	13949c <syscall_trace>
  13a708:	e3a00000 	mov	r0, #0
  13a70c:	e8bd8010 	pop	{r4, pc}
  13a710:	0014b958 	.word	0x0014b958

0013a714 <syscall_ftruncate64>:
  13a714:	e92d4010 	push	{r4, lr}
  13a718:	e3a01014 	mov	r1, #20
  13a71c:	e59f0008 	ldr	r0, [pc, #8]	; 13a72c <syscall_ftruncate64+0x18>
  13a720:	ebfffb5d 	bl	13949c <syscall_trace>
  13a724:	e3a00000 	mov	r0, #0
  13a728:	e8bd8010 	pop	{r4, pc}
  13a72c:	0014b914 	.word	0x0014b914

0013a730 <syscall_truncate64>:
  13a730:	e92d4010 	push	{r4, lr}
  13a734:	e3a01013 	mov	r1, #19
  13a738:	e59f0008 	ldr	r0, [pc, #8]	; 13a748 <syscall_truncate64+0x18>
  13a73c:	ebfffb56 	bl	13949c <syscall_trace>
  13a740:	e3a00000 	mov	r0, #0
  13a744:	e8bd8010 	pop	{r4, pc}
  13a748:	0014b900 	.word	0x0014b900

0013a74c <syscall_sendfile>:
  13a74c:	e92d4010 	push	{r4, lr}
  13a750:	e3a01011 	mov	r1, #17
  13a754:	e59f0008 	ldr	r0, [pc, #8]	; 13a764 <syscall_sendfile+0x18>
  13a758:	ebfffb4f 	bl	13949c <syscall_trace>
  13a75c:	e3a00000 	mov	r0, #0
  13a760:	e8bd8010 	pop	{r4, pc}
  13a764:	0014b8b8 	.word	0x0014b8b8

0013a768 <syscall_sigaltstack>:
  13a768:	e92d4010 	push	{r4, lr}
  13a76c:	e3a01014 	mov	r1, #20
  13a770:	e59f0008 	ldr	r0, [pc, #8]	; 13a780 <syscall_sigaltstack+0x18>
  13a774:	ebfffb48 	bl	13949c <syscall_trace>
  13a778:	e3a00000 	mov	r0, #0
  13a77c:	e8bd8010 	pop	{r4, pc}
  13a780:	0014b8a4 	.word	0x0014b8a4

0013a784 <syscall_capset>:
  13a784:	e92d4010 	push	{r4, lr}
  13a788:	e3a0100f 	mov	r1, #15
  13a78c:	e59f0008 	ldr	r0, [pc, #8]	; 13a79c <syscall_capset+0x18>
  13a790:	ebfffb41 	bl	13949c <syscall_trace>
  13a794:	e3a00000 	mov	r0, #0
  13a798:	e8bd8010 	pop	{r4, pc}
  13a79c:	0014b894 	.word	0x0014b894

0013a7a0 <syscall_capget>:
  13a7a0:	e92d4010 	push	{r4, lr}
  13a7a4:	e3a0100f 	mov	r1, #15
  13a7a8:	e59f0008 	ldr	r0, [pc, #8]	; 13a7b8 <syscall_capget+0x18>
  13a7ac:	ebfffb3a 	bl	13949c <syscall_trace>
  13a7b0:	e3a00000 	mov	r0, #0
  13a7b4:	e8bd8010 	pop	{r4, pc}
  13a7b8:	0014b884 	.word	0x0014b884

0013a7bc <syscall_chown>:
  13a7bc:	e92d4010 	push	{r4, lr}
  13a7c0:	e3a0100e 	mov	r1, #14
  13a7c4:	e59f0008 	ldr	r0, [pc, #8]	; 13a7d4 <syscall_chown+0x18>
  13a7c8:	ebfffb33 	bl	13949c <syscall_trace>
  13a7cc:	e3a00000 	mov	r0, #0
  13a7d0:	e8bd8010 	pop	{r4, pc}
  13a7d4:	0014b864 	.word	0x0014b864

0013a7d8 <syscall_pwrite64>:
  13a7d8:	e92d4010 	push	{r4, lr}
  13a7dc:	e3a01011 	mov	r1, #17
  13a7e0:	e59f0008 	ldr	r0, [pc, #8]	; 13a7f0 <syscall_pwrite64+0x18>
  13a7e4:	ebfffb2c 	bl	13949c <syscall_trace>
  13a7e8:	e3a00000 	mov	r0, #0
  13a7ec:	e8bd8010 	pop	{r4, pc}
  13a7f0:	0014b850 	.word	0x0014b850

0013a7f4 <syscall_pread64>:
  13a7f4:	e92d4010 	push	{r4, lr}
  13a7f8:	e3a01010 	mov	r1, #16
  13a7fc:	e59f0008 	ldr	r0, [pc, #8]	; 13a80c <syscall_pread64+0x18>
  13a800:	ebfffb25 	bl	13949c <syscall_trace>
  13a804:	e3a00000 	mov	r0, #0
  13a808:	e8bd8010 	pop	{r4, pc}
  13a80c:	0014b840 	.word	0x0014b840

0013a810 <syscall_rt_sigsuspend>:
  13a810:	e92d4010 	push	{r4, lr}
  13a814:	e3a01016 	mov	r1, #22
  13a818:	e59f0008 	ldr	r0, [pc, #8]	; 13a828 <syscall_rt_sigsuspend+0x18>
  13a81c:	ebfffb1e 	bl	13949c <syscall_trace>
  13a820:	e3a00000 	mov	r0, #0
  13a824:	e8bd8010 	pop	{r4, pc}
  13a828:	0014b828 	.word	0x0014b828

0013a82c <syscall_rt_sigqueueinfo>:
  13a82c:	e92d4010 	push	{r4, lr}
  13a830:	e3a01018 	mov	r1, #24
  13a834:	e59f0008 	ldr	r0, [pc, #8]	; 13a844 <syscall_rt_sigqueueinfo+0x18>
  13a838:	ebfffb17 	bl	13949c <syscall_trace>
  13a83c:	e3a00000 	mov	r0, #0
  13a840:	e8bd8010 	pop	{r4, pc}
  13a844:	0014b810 	.word	0x0014b810

0013a848 <syscall_rt_sigtimedwait>:
  13a848:	e92d4010 	push	{r4, lr}
  13a84c:	e3a01018 	mov	r1, #24
  13a850:	e59f0008 	ldr	r0, [pc, #8]	; 13a860 <syscall_rt_sigtimedwait+0x18>
  13a854:	ebfffb10 	bl	13949c <syscall_trace>
  13a858:	e3a00000 	mov	r0, #0
  13a85c:	e8bd8010 	pop	{r4, pc}
  13a860:	0014b7f8 	.word	0x0014b7f8

0013a864 <syscall_rt_sigpending>:
  13a864:	e92d4010 	push	{r4, lr}
  13a868:	e3a01016 	mov	r1, #22
  13a86c:	e59f0008 	ldr	r0, [pc, #8]	; 13a87c <syscall_rt_sigpending+0x18>
  13a870:	ebfffb09 	bl	13949c <syscall_trace>
  13a874:	e3a00000 	mov	r0, #0
  13a878:	e8bd8010 	pop	{r4, pc}
  13a87c:	0014b7e0 	.word	0x0014b7e0

0013a880 <syscall_rt_sigreturn>:
  13a880:	e92d4010 	push	{r4, lr}
  13a884:	e3a01015 	mov	r1, #21
  13a888:	e59f0008 	ldr	r0, [pc, #8]	; 13a898 <syscall_rt_sigreturn+0x18>
  13a88c:	ebfffb02 	bl	13949c <syscall_trace>
  13a890:	e3a00000 	mov	r0, #0
  13a894:	e8bd8010 	pop	{r4, pc}
  13a898:	0014b798 	.word	0x0014b798

0013a89c <syscall_prctl>:
  13a89c:	e92d4010 	push	{r4, lr}
  13a8a0:	e3a0100e 	mov	r1, #14
  13a8a4:	e59f0008 	ldr	r0, [pc, #8]	; 13a8b4 <syscall_prctl+0x18>
  13a8a8:	ebfffafb 	bl	13949c <syscall_trace>
  13a8ac:	e3a00000 	mov	r0, #0
  13a8b0:	e8bd8010 	pop	{r4, pc}
  13a8b4:	0014b788 	.word	0x0014b788

0013a8b8 <syscall_getresgid>:
  13a8b8:	e92d4010 	push	{r4, lr}
  13a8bc:	e3a01012 	mov	r1, #18
  13a8c0:	e59f0008 	ldr	r0, [pc, #8]	; 13a8d0 <syscall_getresgid+0x18>
  13a8c4:	ebfffaf4 	bl	13949c <syscall_trace>
  13a8c8:	e3a00000 	mov	r0, #0
  13a8cc:	e8bd8010 	pop	{r4, pc}
  13a8d0:	0014b774 	.word	0x0014b774

0013a8d4 <syscall_setresgid>:
  13a8d4:	e92d4010 	push	{r4, lr}
  13a8d8:	e3a01012 	mov	r1, #18
  13a8dc:	e59f0008 	ldr	r0, [pc, #8]	; 13a8ec <syscall_setresgid+0x18>
  13a8e0:	ebfffaed 	bl	13949c <syscall_trace>
  13a8e4:	e3a00000 	mov	r0, #0
  13a8e8:	e8bd8010 	pop	{r4, pc}
  13a8ec:	0014b760 	.word	0x0014b760

0013a8f0 <syscall_nfsservctl>:
  13a8f0:	e92d4010 	push	{r4, lr}
  13a8f4:	e3a01013 	mov	r1, #19
  13a8f8:	e59f0008 	ldr	r0, [pc, #8]	; 13a908 <syscall_nfsservctl+0x18>
  13a8fc:	ebfffae6 	bl	13949c <syscall_trace>
  13a900:	e3a00000 	mov	r0, #0
  13a904:	e8bd8010 	pop	{r4, pc}
  13a908:	0014b74c 	.word	0x0014b74c

0013a90c <syscall_getresuid>:
  13a90c:	e92d4010 	push	{r4, lr}
  13a910:	e3a01012 	mov	r1, #18
  13a914:	e59f0008 	ldr	r0, [pc, #8]	; 13a924 <syscall_getresuid+0x18>
  13a918:	ebfffadf 	bl	13949c <syscall_trace>
  13a91c:	e3a00000 	mov	r0, #0
  13a920:	e8bd8010 	pop	{r4, pc}
  13a924:	0014b728 	.word	0x0014b728

0013a928 <syscall_setresuid>:
  13a928:	e92d4010 	push	{r4, lr}
  13a92c:	e3a01012 	mov	r1, #18
  13a930:	e59f0008 	ldr	r0, [pc, #8]	; 13a940 <syscall_setresuid+0x18>
  13a934:	ebfffad8 	bl	13949c <syscall_trace>
  13a938:	e3a00000 	mov	r0, #0
  13a93c:	e8bd8010 	pop	{r4, pc}
  13a940:	0014b714 	.word	0x0014b714

0013a944 <syscall_sched_rr_get_interval>:
  13a944:	e92d4010 	push	{r4, lr}
  13a948:	e3a0101e 	mov	r1, #30
  13a94c:	e59f0008 	ldr	r0, [pc, #8]	; 13a95c <syscall_sched_rr_get_interval+0x18>
  13a950:	ebfffad1 	bl	13949c <syscall_trace>
  13a954:	e3a00000 	mov	r0, #0
  13a958:	e8bd8010 	pop	{r4, pc}
  13a95c:	0014b6d0 	.word	0x0014b6d0

0013a960 <syscall_sched_yield>:
  13a960:	e92d4010 	push	{r4, lr}
  13a964:	e3a01014 	mov	r1, #20
  13a968:	e59f0008 	ldr	r0, [pc, #8]	; 13a978 <syscall_sched_yield+0x18>
  13a96c:	ebfffaca 	bl	13949c <syscall_trace>
  13a970:	e3a00000 	mov	r0, #0
  13a974:	e8bd8010 	pop	{r4, pc}
  13a978:	0014b67c 	.word	0x0014b67c

0013a97c <syscall_munlockall>:
  13a97c:	e92d4010 	push	{r4, lr}
  13a980:	e3a01013 	mov	r1, #19
  13a984:	e59f0008 	ldr	r0, [pc, #8]	; 13a994 <syscall_munlockall+0x18>
  13a988:	ebfffac3 	bl	13949c <syscall_trace>
  13a98c:	e3a00000 	mov	r0, #0
  13a990:	e8bd8010 	pop	{r4, pc}
  13a994:	0014b600 	.word	0x0014b600

0013a998 <syscall_mlockall>:
  13a998:	e92d4010 	push	{r4, lr}
  13a99c:	e3a01011 	mov	r1, #17
  13a9a0:	e59f0008 	ldr	r0, [pc, #8]	; 13a9b0 <syscall_mlockall+0x18>
  13a9a4:	ebfffabc 	bl	13949c <syscall_trace>
  13a9a8:	e3a00000 	mov	r0, #0
  13a9ac:	e8bd8010 	pop	{r4, pc}
  13a9b0:	0014b5ec 	.word	0x0014b5ec

0013a9b4 <syscall_munlock>:
  13a9b4:	e92d4010 	push	{r4, lr}
  13a9b8:	e3a01010 	mov	r1, #16
  13a9bc:	e59f0008 	ldr	r0, [pc, #8]	; 13a9cc <syscall_munlock+0x18>
  13a9c0:	ebfffab5 	bl	13949c <syscall_trace>
  13a9c4:	e3a00000 	mov	r0, #0
  13a9c8:	e8bd8010 	pop	{r4, pc}
  13a9cc:	0014b5dc 	.word	0x0014b5dc

0013a9d0 <syscall_mlock>:
  13a9d0:	e92d4010 	push	{r4, lr}
  13a9d4:	e3a0100e 	mov	r1, #14
  13a9d8:	e59f0008 	ldr	r0, [pc, #8]	; 13a9e8 <syscall_mlock+0x18>
  13a9dc:	ebfffaae 	bl	13949c <syscall_trace>
  13a9e0:	e3a00000 	mov	r0, #0
  13a9e4:	e8bd8010 	pop	{r4, pc}
  13a9e8:	0014b5cc 	.word	0x0014b5cc

0013a9ec <syscall__sysctl>:
  13a9ec:	e92d4010 	push	{r4, lr}
  13a9f0:	e3a01010 	mov	r1, #16
  13a9f4:	e59f0008 	ldr	r0, [pc, #8]	; 13aa04 <syscall__sysctl+0x18>
  13a9f8:	ebfffaa7 	bl	13949c <syscall_trace>
  13a9fc:	e3a00000 	mov	r0, #0
  13aa00:	e8bd8010 	pop	{r4, pc}
  13aa04:	0014b5bc 	.word	0x0014b5bc

0013aa08 <syscall_fdatasync>:
  13aa08:	e92d4010 	push	{r4, lr}
  13aa0c:	e3a01012 	mov	r1, #18
  13aa10:	e59f0008 	ldr	r0, [pc, #8]	; 13aa20 <syscall_fdatasync+0x18>
  13aa14:	ebfffaa0 	bl	13949c <syscall_trace>
  13aa18:	e3a00000 	mov	r0, #0
  13aa1c:	e8bd8010 	pop	{r4, pc}
  13aa20:	0014b5a8 	.word	0x0014b5a8

0013aa24 <syscall_getsid>:
  13aa24:	e92d4010 	push	{r4, lr}
  13aa28:	e3a0100f 	mov	r1, #15
  13aa2c:	e59f0008 	ldr	r0, [pc, #8]	; 13aa3c <syscall_getsid+0x18>
  13aa30:	ebfffa99 	bl	13949c <syscall_trace>
  13aa34:	e3a00000 	mov	r0, #0
  13aa38:	e8bd8010 	pop	{r4, pc}
  13aa3c:	0014b598 	.word	0x0014b598

0013aa40 <syscall_msync>:
  13aa40:	e92d4010 	push	{r4, lr}
  13aa44:	e3a0100e 	mov	r1, #14
  13aa48:	e59f0008 	ldr	r0, [pc, #8]	; 13aa58 <syscall_msync+0x18>
  13aa4c:	ebfffa92 	bl	13949c <syscall_trace>
  13aa50:	e3a00000 	mov	r0, #0
  13aa54:	e8bd8010 	pop	{r4, pc}
  13aa58:	0014b568 	.word	0x0014b568

0013aa5c <syscall_flock>:
  13aa5c:	e92d4010 	push	{r4, lr}
  13aa60:	e3a0100e 	mov	r1, #14
  13aa64:	e59f0008 	ldr	r0, [pc, #8]	; 13aa74 <syscall_flock+0x18>
  13aa68:	ebfffa8b 	bl	13949c <syscall_trace>
  13aa6c:	e3a00000 	mov	r0, #0
  13aa70:	e8bd8010 	pop	{r4, pc}
  13aa74:	0014b558 	.word	0x0014b558

0013aa78 <syscall_setfsgid>:
  13aa78:	e92d4010 	push	{r4, lr}
  13aa7c:	e3a01011 	mov	r1, #17
  13aa80:	e59f0008 	ldr	r0, [pc, #8]	; 13aa90 <syscall_setfsgid+0x18>
  13aa84:	ebfffa84 	bl	13949c <syscall_trace>
  13aa88:	e3a00000 	mov	r0, #0
  13aa8c:	e8bd8010 	pop	{r4, pc}
  13aa90:	0014b50c 	.word	0x0014b50c

0013aa94 <syscall_setfsuid>:
  13aa94:	e92d4010 	push	{r4, lr}
  13aa98:	e3a01011 	mov	r1, #17
  13aa9c:	e59f0008 	ldr	r0, [pc, #8]	; 13aaac <syscall_setfsuid+0x18>
  13aaa0:	ebfffa7d 	bl	13949c <syscall_trace>
  13aaa4:	e3a00000 	mov	r0, #0
  13aaa8:	e8bd8010 	pop	{r4, pc}
  13aaac:	0014b4f8 	.word	0x0014b4f8

0013aab0 <syscall_personality>:
  13aab0:	e92d4010 	push	{r4, lr}
  13aab4:	e3a01014 	mov	r1, #20
  13aab8:	e59f0008 	ldr	r0, [pc, #8]	; 13aac8 <syscall_personality+0x18>
  13aabc:	ebfffa76 	bl	13949c <syscall_trace>
  13aac0:	e3a00000 	mov	r0, #0
  13aac4:	e8bd8010 	pop	{r4, pc}
  13aac8:	0014b4e4 	.word	0x0014b4e4

0013aacc <syscall_sysfs>:
  13aacc:	e92d4010 	push	{r4, lr}
  13aad0:	e3a0100e 	mov	r1, #14
  13aad4:	e59f0008 	ldr	r0, [pc, #8]	; 13aae4 <syscall_sysfs+0x18>
  13aad8:	ebfffa6f 	bl	13949c <syscall_trace>
  13aadc:	e3a00000 	mov	r0, #0
  13aae0:	e8bd8010 	pop	{r4, pc}
  13aae4:	0014b4d4 	.word	0x0014b4d4

0013aae8 <syscall_bdflush>:
  13aae8:	e92d4010 	push	{r4, lr}
  13aaec:	e3a01010 	mov	r1, #16
  13aaf0:	e59f0008 	ldr	r0, [pc, #8]	; 13ab00 <syscall_bdflush+0x18>
  13aaf4:	ebfffa68 	bl	13949c <syscall_trace>
  13aaf8:	e3a00000 	mov	r0, #0
  13aafc:	e8bd8010 	pop	{r4, pc}
  13ab00:	0014b4c4 	.word	0x0014b4c4

0013ab04 <syscall_fchdir>:
  13ab04:	e92d4010 	push	{r4, lr}
  13ab08:	e3a0100f 	mov	r1, #15
  13ab0c:	e59f0008 	ldr	r0, [pc, #8]	; 13ab1c <syscall_fchdir+0x18>
  13ab10:	ebfffa61 	bl	13949c <syscall_trace>
  13ab14:	e3a00000 	mov	r0, #0
  13ab18:	e8bd8010 	pop	{r4, pc}
  13ab1c:	0014b4b4 	.word	0x0014b4b4

0013ab20 <syscall_getpgid>:
  13ab20:	e92d4010 	push	{r4, lr}
  13ab24:	e3a01010 	mov	r1, #16
  13ab28:	e59f0008 	ldr	r0, [pc, #8]	; 13ab38 <syscall_getpgid+0x18>
  13ab2c:	ebfffa5a 	bl	13949c <syscall_trace>
  13ab30:	e3a00000 	mov	r0, #0
  13ab34:	e8bd8010 	pop	{r4, pc}
  13ab38:	0014b4a4 	.word	0x0014b4a4

0013ab3c <syscall_quotactl>:
  13ab3c:	e92d4010 	push	{r4, lr}
  13ab40:	e3a01011 	mov	r1, #17
  13ab44:	e59f0008 	ldr	r0, [pc, #8]	; 13ab54 <syscall_quotactl+0x18>
  13ab48:	ebfffa53 	bl	13949c <syscall_trace>
  13ab4c:	e3a00000 	mov	r0, #0
  13ab50:	e8bd8010 	pop	{r4, pc}
  13ab54:	0014b490 	.word	0x0014b490

0013ab58 <syscall_delete_module>:
  13ab58:	e92d4010 	push	{r4, lr}
  13ab5c:	e3a01016 	mov	r1, #22
  13ab60:	e59f0008 	ldr	r0, [pc, #8]	; 13ab70 <syscall_delete_module+0x18>
  13ab64:	ebfffa4c 	bl	13949c <syscall_trace>
  13ab68:	e3a00000 	mov	r0, #0
  13ab6c:	e8bd8010 	pop	{r4, pc}
  13ab70:	0014b478 	.word	0x0014b478

0013ab74 <syscall_init_module>:
  13ab74:	e92d4010 	push	{r4, lr}
  13ab78:	e3a01014 	mov	r1, #20
  13ab7c:	e59f0008 	ldr	r0, [pc, #8]	; 13ab8c <syscall_init_module+0x18>
  13ab80:	ebfffa45 	bl	13949c <syscall_trace>
  13ab84:	e3a00000 	mov	r0, #0
  13ab88:	e8bd8010 	pop	{r4, pc}
  13ab8c:	0014b464 	.word	0x0014b464

0013ab90 <syscall_mprotect>:
  13ab90:	e92d4010 	push	{r4, lr}
  13ab94:	e3a01011 	mov	r1, #17
  13ab98:	e59f0008 	ldr	r0, [pc, #8]	; 13aba8 <syscall_mprotect+0x18>
  13ab9c:	ebfffa3e 	bl	13949c <syscall_trace>
  13aba0:	e3a00000 	mov	r0, #0
  13aba4:	e8bd8010 	pop	{r4, pc}
  13aba8:	0014b43c 	.word	0x0014b43c

0013abac <syscall_adjtimex>:
  13abac:	e92d4010 	push	{r4, lr}
  13abb0:	e3a01011 	mov	r1, #17
  13abb4:	e59f0008 	ldr	r0, [pc, #8]	; 13abc4 <syscall_adjtimex+0x18>
  13abb8:	ebfffa37 	bl	13949c <syscall_trace>
  13abbc:	e3a00000 	mov	r0, #0
  13abc0:	e8bd8010 	pop	{r4, pc}
  13abc4:	0014b428 	.word	0x0014b428

0013abc8 <syscall_uname>:
  13abc8:	e92d4010 	push	{r4, lr}
  13abcc:	e3a0100e 	mov	r1, #14
  13abd0:	e59f0008 	ldr	r0, [pc, #8]	; 13abe0 <syscall_uname+0x18>
  13abd4:	ebfffa30 	bl	13949c <syscall_trace>
  13abd8:	e3a00000 	mov	r0, #0
  13abdc:	e8bd8010 	pop	{r4, pc}
  13abe0:	0014b418 	.word	0x0014b418

0013abe4 <syscall_setdomainname>:
  13abe4:	e92d4010 	push	{r4, lr}
  13abe8:	e3a01016 	mov	r1, #22
  13abec:	e59f0008 	ldr	r0, [pc, #8]	; 13abfc <syscall_setdomainname+0x18>
  13abf0:	ebfffa29 	bl	13949c <syscall_trace>
  13abf4:	e3a00000 	mov	r0, #0
  13abf8:	e8bd8010 	pop	{r4, pc}
  13abfc:	0014b400 	.word	0x0014b400

0013ac00 <syscall_clone>:
  13ac00:	e92d4010 	push	{r4, lr}
  13ac04:	e3a0100e 	mov	r1, #14
  13ac08:	e59f0008 	ldr	r0, [pc, #8]	; 13ac18 <syscall_clone+0x18>
  13ac0c:	ebfffa22 	bl	13949c <syscall_trace>
  13ac10:	e3a00000 	mov	r0, #0
  13ac14:	e8bd8010 	pop	{r4, pc}
  13ac18:	0014b3f0 	.word	0x0014b3f0

0013ac1c <syscall_sigreturn>:
  13ac1c:	e92d4010 	push	{r4, lr}
  13ac20:	e3a01012 	mov	r1, #18
  13ac24:	e59f0008 	ldr	r0, [pc, #8]	; 13ac34 <syscall_sigreturn+0x18>
  13ac28:	ebfffa1b 	bl	13949c <syscall_trace>
  13ac2c:	e3a00000 	mov	r0, #0
  13ac30:	e8bd8010 	pop	{r4, pc}
  13ac34:	0014b3dc 	.word	0x0014b3dc

0013ac38 <syscall_sysinfo>:
  13ac38:	e92d4010 	push	{r4, lr}
  13ac3c:	e3a01010 	mov	r1, #16
  13ac40:	e59f0008 	ldr	r0, [pc, #8]	; 13ac50 <syscall_sysinfo+0x18>
  13ac44:	ebfffa14 	bl	13949c <syscall_trace>
  13ac48:	e3a00000 	mov	r0, #0
  13ac4c:	e8bd8010 	pop	{r4, pc}
  13ac50:	0014b3bc 	.word	0x0014b3bc

0013ac54 <syscall_swapoff>:
  13ac54:	e92d4010 	push	{r4, lr}
  13ac58:	e3a01010 	mov	r1, #16
  13ac5c:	e59f0008 	ldr	r0, [pc, #8]	; 13ac6c <syscall_swapoff+0x18>
  13ac60:	ebfffa0d 	bl	13949c <syscall_trace>
  13ac64:	e3a00000 	mov	r0, #0
  13ac68:	e8bd8010 	pop	{r4, pc}
  13ac6c:	0014b3ac 	.word	0x0014b3ac

0013ac70 <syscall_wait4>:
  13ac70:	e92d4010 	push	{r4, lr}
  13ac74:	e3a0100e 	mov	r1, #14
  13ac78:	e59f0008 	ldr	r0, [pc, #8]	; 13ac88 <syscall_wait4+0x18>
  13ac7c:	ebfffa06 	bl	13949c <syscall_trace>
  13ac80:	e3a00000 	mov	r0, #0
  13ac84:	e8bd8010 	pop	{r4, pc}
  13ac88:	0014b39c 	.word	0x0014b39c

0013ac8c <syscall_vhangup>:
  13ac8c:	e92d4010 	push	{r4, lr}
  13ac90:	e3a01010 	mov	r1, #16
  13ac94:	e59f0008 	ldr	r0, [pc, #8]	; 13aca4 <syscall_vhangup+0x18>
  13ac98:	ebfff9ff 	bl	13949c <syscall_trace>
  13ac9c:	e3a00000 	mov	r0, #0
  13aca0:	e8bd8010 	pop	{r4, pc}
  13aca4:	0014b38c 	.word	0x0014b38c

0013aca8 <syscall_fstat>:
  13aca8:	e92d4010 	push	{r4, lr}
  13acac:	e3a0100e 	mov	r1, #14
  13acb0:	e59f0008 	ldr	r0, [pc, #8]	; 13acc0 <syscall_fstat+0x18>
  13acb4:	ebfff9f8 	bl	13949c <syscall_trace>
  13acb8:	e3a00000 	mov	r0, #0
  13acbc:	e8bd8010 	pop	{r4, pc}
  13acc0:	0014b37c 	.word	0x0014b37c

0013acc4 <syscall_getitimer>:
  13acc4:	e92d4010 	push	{r4, lr}
  13acc8:	e3a01012 	mov	r1, #18
  13accc:	e59f0008 	ldr	r0, [pc, #8]	; 13acdc <syscall_getitimer+0x18>
  13acd0:	ebfff9f1 	bl	13949c <syscall_trace>
  13acd4:	e3a00000 	mov	r0, #0
  13acd8:	e8bd8010 	pop	{r4, pc}
  13acdc:	0014b348 	.word	0x0014b348

0013ace0 <syscall_setitimer>:
  13ace0:	e92d4010 	push	{r4, lr}
  13ace4:	e3a01012 	mov	r1, #18
  13ace8:	e59f0008 	ldr	r0, [pc, #8]	; 13acf8 <syscall_setitimer+0x18>
  13acec:	ebfff9ea 	bl	13949c <syscall_trace>
  13acf0:	e3a00000 	mov	r0, #0
  13acf4:	e8bd8010 	pop	{r4, pc}
  13acf8:	0014b334 	.word	0x0014b334

0013acfc <syscall_syslog>:
  13acfc:	e92d4010 	push	{r4, lr}
  13ad00:	e3a0100f 	mov	r1, #15
  13ad04:	e59f0008 	ldr	r0, [pc, #8]	; 13ad14 <syscall_syslog+0x18>
  13ad08:	ebfff9e3 	bl	13949c <syscall_trace>
  13ad0c:	e3a00000 	mov	r0, #0
  13ad10:	e8bd8010 	pop	{r4, pc}
  13ad14:	0014b324 	.word	0x0014b324

0013ad18 <syscall_fstatfs>:
  13ad18:	e92d4010 	push	{r4, lr}
  13ad1c:	e3a01010 	mov	r1, #16
  13ad20:	e59f0008 	ldr	r0, [pc, #8]	; 13ad30 <syscall_fstatfs+0x18>
  13ad24:	ebfff9dc 	bl	13949c <syscall_trace>
  13ad28:	e3a00000 	mov	r0, #0
  13ad2c:	e8bd8010 	pop	{r4, pc}
  13ad30:	0014b314 	.word	0x0014b314

0013ad34 <syscall_statfs>:
  13ad34:	e92d4010 	push	{r4, lr}
  13ad38:	e3a0100f 	mov	r1, #15
  13ad3c:	e59f0008 	ldr	r0, [pc, #8]	; 13ad4c <syscall_statfs+0x18>
  13ad40:	ebfff9d5 	bl	13949c <syscall_trace>
  13ad44:	e3a00000 	mov	r0, #0
  13ad48:	e8bd8010 	pop	{r4, pc}
  13ad4c:	0014b304 	.word	0x0014b304

0013ad50 <syscall_setpriority>:
  13ad50:	e92d4010 	push	{r4, lr}
  13ad54:	e3a01014 	mov	r1, #20
  13ad58:	e59f0008 	ldr	r0, [pc, #8]	; 13ad68 <syscall_setpriority+0x18>
  13ad5c:	ebfff9ce 	bl	13949c <syscall_trace>
  13ad60:	e3a00000 	mov	r0, #0
  13ad64:	e8bd8010 	pop	{r4, pc}
  13ad68:	0014b2f0 	.word	0x0014b2f0

0013ad6c <syscall_getpriority>:
  13ad6c:	e92d4010 	push	{r4, lr}
  13ad70:	e3a01014 	mov	r1, #20
  13ad74:	e59f0008 	ldr	r0, [pc, #8]	; 13ad84 <syscall_getpriority+0x18>
  13ad78:	ebfff9c7 	bl	13949c <syscall_trace>
  13ad7c:	e3a00000 	mov	r0, #0
  13ad80:	e8bd8010 	pop	{r4, pc}
  13ad84:	0014b2dc 	.word	0x0014b2dc

0013ad88 <syscall_fchown>:
  13ad88:	e92d4010 	push	{r4, lr}
  13ad8c:	e3a0100f 	mov	r1, #15
  13ad90:	e59f0008 	ldr	r0, [pc, #8]	; 13ada0 <syscall_fchown+0x18>
  13ad94:	ebfff9c0 	bl	13949c <syscall_trace>
  13ad98:	e3a00000 	mov	r0, #0
  13ad9c:	e8bd8010 	pop	{r4, pc}
  13ada0:	0014b2cc 	.word	0x0014b2cc

0013ada4 <syscall_fchmod>:
  13ada4:	e92d4010 	push	{r4, lr}
  13ada8:	e3a0100f 	mov	r1, #15
  13adac:	e59f0008 	ldr	r0, [pc, #8]	; 13adbc <syscall_fchmod+0x18>
  13adb0:	ebfff9b9 	bl	13949c <syscall_trace>
  13adb4:	e3a00000 	mov	r0, #0
  13adb8:	e8bd8010 	pop	{r4, pc}
  13adbc:	0014b2bc 	.word	0x0014b2bc

0013adc0 <syscall_ftruncate>:
  13adc0:	e92d4010 	push	{r4, lr}
  13adc4:	e3a01012 	mov	r1, #18
  13adc8:	e59f0008 	ldr	r0, [pc, #8]	; 13add8 <syscall_ftruncate+0x18>
  13adcc:	ebfff9b2 	bl	13949c <syscall_trace>
  13add0:	e3a00000 	mov	r0, #0
  13add4:	e8bd8010 	pop	{r4, pc}
  13add8:	0014b2a8 	.word	0x0014b2a8

0013addc <syscall_truncate>:
  13addc:	e92d4010 	push	{r4, lr}
  13ade0:	e3a01011 	mov	r1, #17
  13ade4:	e59f0008 	ldr	r0, [pc, #8]	; 13adf4 <syscall_truncate+0x18>
  13ade8:	ebfff9ab 	bl	13949c <syscall_trace>
  13adec:	e3a00000 	mov	r0, #0
  13adf0:	e8bd8010 	pop	{r4, pc}
  13adf4:	0014b294 	.word	0x0014b294

0013adf8 <syscall_reboot>:
  13adf8:	e92d4010 	push	{r4, lr}
  13adfc:	e3a0100f 	mov	r1, #15
  13ae00:	e59f0008 	ldr	r0, [pc, #8]	; 13ae10 <syscall_reboot+0x18>
  13ae04:	ebfff9a4 	bl	13949c <syscall_trace>
  13ae08:	e3a00000 	mov	r0, #0
  13ae0c:	e8bd8010 	pop	{r4, pc}
  13ae10:	0014b274 	.word	0x0014b274

0013ae14 <syscall_swapon>:
  13ae14:	e92d4010 	push	{r4, lr}
  13ae18:	e3a0100f 	mov	r1, #15
  13ae1c:	e59f0008 	ldr	r0, [pc, #8]	; 13ae2c <syscall_swapon+0x18>
  13ae20:	ebfff99d 	bl	13949c <syscall_trace>
  13ae24:	e3a00000 	mov	r0, #0
  13ae28:	e8bd8010 	pop	{r4, pc}
  13ae2c:	0014b264 	.word	0x0014b264

0013ae30 <syscall_uselib>:
  13ae30:	e92d4010 	push	{r4, lr}
  13ae34:	e3a0100f 	mov	r1, #15
  13ae38:	e59f0008 	ldr	r0, [pc, #8]	; 13ae48 <syscall_uselib+0x18>
  13ae3c:	ebfff996 	bl	13949c <syscall_trace>
  13ae40:	e3a00000 	mov	r0, #0
  13ae44:	e8bd8010 	pop	{r4, pc}
  13ae48:	0014b254 	.word	0x0014b254

0013ae4c <syscall_symlink>:
  13ae4c:	e92d4010 	push	{r4, lr}
  13ae50:	e3a01010 	mov	r1, #16
  13ae54:	e59f0008 	ldr	r0, [pc, #8]	; 13ae64 <syscall_symlink+0x18>
  13ae58:	ebfff98f 	bl	13949c <syscall_trace>
  13ae5c:	e3a00000 	mov	r0, #0
  13ae60:	e8bd8010 	pop	{r4, pc}
  13ae64:	0014b230 	.word	0x0014b230

0013ae68 <syscall_setgroups>:
  13ae68:	e92d4010 	push	{r4, lr}
  13ae6c:	e3a01012 	mov	r1, #18
  13ae70:	e59f0008 	ldr	r0, [pc, #8]	; 13ae80 <syscall_setgroups+0x18>
  13ae74:	ebfff988 	bl	13949c <syscall_trace>
  13ae78:	e3a00000 	mov	r0, #0
  13ae7c:	e8bd8010 	pop	{r4, pc}
  13ae80:	0014b21c 	.word	0x0014b21c

0013ae84 <syscall_getgroups>:
  13ae84:	e92d4010 	push	{r4, lr}
  13ae88:	e3a01012 	mov	r1, #18
  13ae8c:	e59f0008 	ldr	r0, [pc, #8]	; 13ae9c <syscall_getgroups+0x18>
  13ae90:	ebfff981 	bl	13949c <syscall_trace>
  13ae94:	e3a00000 	mov	r0, #0
  13ae98:	e8bd8010 	pop	{r4, pc}
  13ae9c:	0014b208 	.word	0x0014b208

0013aea0 <syscall_settimeofday>:
  13aea0:	e92d4010 	push	{r4, lr}
  13aea4:	e3a01015 	mov	r1, #21
  13aea8:	e59f0008 	ldr	r0, [pc, #8]	; 13aeb8 <syscall_settimeofday+0x18>
  13aeac:	ebfff97a 	bl	13949c <syscall_trace>
  13aeb0:	e3a00000 	mov	r0, #0
  13aeb4:	e8bd8010 	pop	{r4, pc}
  13aeb8:	0014b1f0 	.word	0x0014b1f0

0013aebc <syscall_gettimeofday>:
  13aebc:	e92d4010 	push	{r4, lr}
  13aec0:	e3a01015 	mov	r1, #21
  13aec4:	e59f0008 	ldr	r0, [pc, #8]	; 13aed4 <syscall_gettimeofday+0x18>
  13aec8:	ebfff973 	bl	13949c <syscall_trace>
  13aecc:	e3a00000 	mov	r0, #0
  13aed0:	e8bd8010 	pop	{r4, pc}
  13aed4:	0014b1d8 	.word	0x0014b1d8

0013aed8 <syscall_getrusage>:
  13aed8:	e92d4010 	push	{r4, lr}
  13aedc:	e3a01012 	mov	r1, #18
  13aee0:	e59f0008 	ldr	r0, [pc, #8]	; 13aef0 <syscall_getrusage+0x18>
  13aee4:	ebfff96c 	bl	13949c <syscall_trace>
  13aee8:	e3a00000 	mov	r0, #0
  13aeec:	e8bd8010 	pop	{r4, pc}
  13aef0:	0014b1c4 	.word	0x0014b1c4

0013aef4 <syscall_sethostname>:
  13aef4:	e92d4010 	push	{r4, lr}
  13aef8:	e3a01014 	mov	r1, #20
  13aefc:	e59f0008 	ldr	r0, [pc, #8]	; 13af0c <syscall_sethostname+0x18>
  13af00:	ebfff965 	bl	13949c <syscall_trace>
  13af04:	e3a00000 	mov	r0, #0
  13af08:	e8bd8010 	pop	{r4, pc}
  13af0c:	0014b19c 	.word	0x0014b19c

0013af10 <syscall_sigpending>:
  13af10:	e92d4010 	push	{r4, lr}
  13af14:	e3a01013 	mov	r1, #19
  13af18:	e59f0008 	ldr	r0, [pc, #8]	; 13af28 <syscall_sigpending+0x18>
  13af1c:	ebfff95e 	bl	13949c <syscall_trace>
  13af20:	e3a00000 	mov	r0, #0
  13af24:	e8bd8010 	pop	{r4, pc}
  13af28:	0014b188 	.word	0x0014b188

0013af2c <syscall_sigsuspend>:
  13af2c:	e92d4010 	push	{r4, lr}
  13af30:	e3a01013 	mov	r1, #19
  13af34:	e59f0008 	ldr	r0, [pc, #8]	; 13af44 <syscall_sigsuspend+0x18>
  13af38:	ebfff957 	bl	13949c <syscall_trace>
  13af3c:	e3a00000 	mov	r0, #0
  13af40:	e8bd8010 	pop	{r4, pc}
  13af44:	0014b174 	.word	0x0014b174

0013af48 <syscall_setregid>:
  13af48:	e92d4010 	push	{r4, lr}
  13af4c:	e3a01011 	mov	r1, #17
  13af50:	e59f0008 	ldr	r0, [pc, #8]	; 13af60 <syscall_setregid+0x18>
  13af54:	ebfff950 	bl	13949c <syscall_trace>
  13af58:	e3a00000 	mov	r0, #0
  13af5c:	e8bd8010 	pop	{r4, pc}
  13af60:	0014b160 	.word	0x0014b160

0013af64 <syscall_setreuid>:
  13af64:	e92d4010 	push	{r4, lr}
  13af68:	e3a01011 	mov	r1, #17
  13af6c:	e59f0008 	ldr	r0, [pc, #8]	; 13af7c <syscall_setreuid+0x18>
  13af70:	ebfff949 	bl	13949c <syscall_trace>
  13af74:	e3a00000 	mov	r0, #0
  13af78:	e8bd8010 	pop	{r4, pc}
  13af7c:	0014b14c 	.word	0x0014b14c

0013af80 <syscall_getpgrp>:
  13af80:	e92d4010 	push	{r4, lr}
  13af84:	e3a01010 	mov	r1, #16
  13af88:	e59f0008 	ldr	r0, [pc, #8]	; 13af98 <syscall_getpgrp+0x18>
  13af8c:	ebfff942 	bl	13949c <syscall_trace>
  13af90:	e3a00000 	mov	r0, #0
  13af94:	e8bd8010 	pop	{r4, pc}
  13af98:	0014b118 	.word	0x0014b118

0013af9c <syscall_getppid>:
  13af9c:	e92d4010 	push	{r4, lr}
  13afa0:	e3a01010 	mov	r1, #16
  13afa4:	e59f0008 	ldr	r0, [pc, #8]	; 13afb4 <syscall_getppid+0x18>
  13afa8:	ebfff93b 	bl	13949c <syscall_trace>
  13afac:	e3a00000 	mov	r0, #0
  13afb0:	e8bd8010 	pop	{r4, pc}
  13afb4:	0014b108 	.word	0x0014b108

0013afb8 <syscall_ustat>:
  13afb8:	e92d4010 	push	{r4, lr}
  13afbc:	e3a0100e 	mov	r1, #14
  13afc0:	e59f0008 	ldr	r0, [pc, #8]	; 13afd0 <syscall_ustat+0x18>
  13afc4:	ebfff934 	bl	13949c <syscall_trace>
  13afc8:	e3a00000 	mov	r0, #0
  13afcc:	e8bd8010 	pop	{r4, pc}
  13afd0:	0014b0e8 	.word	0x0014b0e8

0013afd4 <syscall_chroot>:
  13afd4:	e92d4010 	push	{r4, lr}
  13afd8:	e3a0100f 	mov	r1, #15
  13afdc:	e59f0008 	ldr	r0, [pc, #8]	; 13afec <syscall_chroot+0x18>
  13afe0:	ebfff92d 	bl	13949c <syscall_trace>
  13afe4:	e3a00000 	mov	r0, #0
  13afe8:	e8bd8010 	pop	{r4, pc}
  13afec:	0014b0d8 	.word	0x0014b0d8

0013aff0 <syscall_umask>:
  13aff0:	e92d4010 	push	{r4, lr}
  13aff4:	e3a0100e 	mov	r1, #14
  13aff8:	e59f0008 	ldr	r0, [pc, #8]	; 13b008 <syscall_umask+0x18>
  13affc:	ebfff926 	bl	13949c <syscall_trace>
  13b000:	e3a00000 	mov	r0, #0
  13b004:	e8bd8010 	pop	{r4, pc}
  13b008:	0014b0c8 	.word	0x0014b0c8

0013b00c <syscall_setpgid>:
  13b00c:	e92d4010 	push	{r4, lr}
  13b010:	e3a01010 	mov	r1, #16
  13b014:	e59f0008 	ldr	r0, [pc, #8]	; 13b024 <syscall_setpgid+0x18>
  13b018:	ebfff91f 	bl	13949c <syscall_trace>
  13b01c:	e3a00000 	mov	r0, #0
  13b020:	e8bd8010 	pop	{r4, pc}
  13b024:	0014b0b8 	.word	0x0014b0b8

0013b028 <syscall_umount2>:
  13b028:	e92d4010 	push	{r4, lr}
  13b02c:	e3a01010 	mov	r1, #16
  13b030:	e59f0008 	ldr	r0, [pc, #8]	; 13b040 <syscall_umount2+0x18>
  13b034:	ebfff918 	bl	13949c <syscall_trace>
  13b038:	e3a00000 	mov	r0, #0
  13b03c:	e8bd8010 	pop	{r4, pc}
  13b040:	0014b088 	.word	0x0014b088

0013b044 <syscall_acct>:
  13b044:	e92d4010 	push	{r4, lr}
  13b048:	e3a0100d 	mov	r1, #13
  13b04c:	e59f0008 	ldr	r0, [pc, #8]	; 13b05c <syscall_acct+0x18>
  13b050:	ebfff911 	bl	13949c <syscall_trace>
  13b054:	e3a00000 	mov	r0, #0
  13b058:	e8bd8010 	pop	{r4, pc}
  13b05c:	0014b078 	.word	0x0014b078

0013b060 <syscall_getegid>:
  13b060:	e92d4010 	push	{r4, lr}
  13b064:	e3a01010 	mov	r1, #16
  13b068:	e59f0008 	ldr	r0, [pc, #8]	; 13b078 <syscall_getegid+0x18>
  13b06c:	ebfff90a 	bl	13949c <syscall_trace>
  13b070:	e3a00000 	mov	r0, #0
  13b074:	e8bd8010 	pop	{r4, pc}
  13b078:	0014b068 	.word	0x0014b068

0013b07c <syscall_geteuid>:
  13b07c:	e92d4010 	push	{r4, lr}
  13b080:	e3a01010 	mov	r1, #16
  13b084:	e59f0008 	ldr	r0, [pc, #8]	; 13b094 <syscall_geteuid+0x18>
  13b088:	ebfff903 	bl	13949c <syscall_trace>
  13b08c:	e3a00000 	mov	r0, #0
  13b090:	e8bd8010 	pop	{r4, pc}
  13b094:	0014b058 	.word	0x0014b058

0013b098 <syscall_getgid>:
  13b098:	e92d4010 	push	{r4, lr}
  13b09c:	e3a0100f 	mov	r1, #15
  13b0a0:	e59f0008 	ldr	r0, [pc, #8]	; 13b0b0 <syscall_getgid+0x18>
  13b0a4:	ebfff8fc 	bl	13949c <syscall_trace>
  13b0a8:	e3a00000 	mov	r0, #0
  13b0ac:	e8bd8010 	pop	{r4, pc}
  13b0b0:	0014b048 	.word	0x0014b048

0013b0b4 <syscall_setgid>:
  13b0b4:	e92d4010 	push	{r4, lr}
  13b0b8:	e3a0100f 	mov	r1, #15
  13b0bc:	e59f0008 	ldr	r0, [pc, #8]	; 13b0cc <syscall_setgid+0x18>
  13b0c0:	ebfff8f5 	bl	13949c <syscall_trace>
  13b0c4:	e3a00000 	mov	r0, #0
  13b0c8:	e8bd8010 	pop	{r4, pc}
  13b0cc:	0014b038 	.word	0x0014b038

0013b0d0 <syscall_times>:
  13b0d0:	e92d4010 	push	{r4, lr}
  13b0d4:	e3a0100e 	mov	r1, #14
  13b0d8:	e59f0008 	ldr	r0, [pc, #8]	; 13b0e8 <syscall_times+0x18>
  13b0dc:	ebfff8ee 	bl	13949c <syscall_trace>
  13b0e0:	e3a00000 	mov	r0, #0
  13b0e4:	e8bd8010 	pop	{r4, pc}
  13b0e8:	0014b01c 	.word	0x0014b01c

0013b0ec <syscall_sync>:
  13b0ec:	e92d4010 	push	{r4, lr}
  13b0f0:	e3a0100d 	mov	r1, #13
  13b0f4:	e59f0008 	ldr	r0, [pc, #8]	; 13b104 <syscall_sync+0x18>
  13b0f8:	ebfff8e7 	bl	13949c <syscall_trace>
  13b0fc:	e3a00000 	mov	r0, #0
  13b100:	e8bd8010 	pop	{r4, pc}
  13b104:	0014afb0 	.word	0x0014afb0

0013b108 <syscall_nice>:
  13b108:	e92d4010 	push	{r4, lr}
  13b10c:	e3a0100d 	mov	r1, #13
  13b110:	e59f0008 	ldr	r0, [pc, #8]	; 13b120 <syscall_nice+0x18>
  13b114:	ebfff8e0 	bl	13949c <syscall_trace>
  13b118:	e3a00000 	mov	r0, #0
  13b11c:	e8bd8010 	pop	{r4, pc}
  13b120:	0014afa0 	.word	0x0014afa0

0013b124 <syscall_pause>:
  13b124:	e92d4010 	push	{r4, lr}
  13b128:	e3a0100e 	mov	r1, #14
  13b12c:	e59f0008 	ldr	r0, [pc, #8]	; 13b13c <syscall_pause+0x18>
  13b130:	ebfff8d9 	bl	13949c <syscall_trace>
  13b134:	e3a00000 	mov	r0, #0
  13b138:	e8bd8010 	pop	{r4, pc}
  13b13c:	0014af80 	.word	0x0014af80

0013b140 <syscall_ptrace>:
  13b140:	e92d4010 	push	{r4, lr}
  13b144:	e3a0100f 	mov	r1, #15
  13b148:	e59f0008 	ldr	r0, [pc, #8]	; 13b158 <syscall_ptrace+0x18>
  13b14c:	ebfff8d2 	bl	13949c <syscall_trace>
  13b150:	e3a00000 	mov	r0, #0
  13b154:	e8bd8010 	pop	{r4, pc}
  13b158:	0014af70 	.word	0x0014af70

0013b15c <syscall_getuid>:
  13b15c:	e92d4010 	push	{r4, lr}
  13b160:	e3a0100f 	mov	r1, #15
  13b164:	e59f0008 	ldr	r0, [pc, #8]	; 13b174 <syscall_getuid+0x18>
  13b168:	ebfff8cb 	bl	13949c <syscall_trace>
  13b16c:	e3a00000 	mov	r0, #0
  13b170:	e8bd8010 	pop	{r4, pc}
  13b174:	0014af60 	.word	0x0014af60

0013b178 <syscall_setuid>:
  13b178:	e92d4010 	push	{r4, lr}
  13b17c:	e3a0100f 	mov	r1, #15
  13b180:	e59f0008 	ldr	r0, [pc, #8]	; 13b190 <syscall_setuid+0x18>
  13b184:	ebfff8c4 	bl	13949c <syscall_trace>
  13b188:	e3a00000 	mov	r0, #0
  13b18c:	e8bd8010 	pop	{r4, pc}
  13b190:	0014af50 	.word	0x0014af50

0013b194 <syscall_mount>:
  13b194:	e92d4010 	push	{r4, lr}
  13b198:	e3a0100e 	mov	r1, #14
  13b19c:	e59f0008 	ldr	r0, [pc, #8]	; 13b1ac <syscall_mount+0x18>
  13b1a0:	ebfff8bd 	bl	13949c <syscall_trace>
  13b1a4:	e3a00000 	mov	r0, #0
  13b1a8:	e8bd8010 	pop	{r4, pc}
  13b1ac:	0014af40 	.word	0x0014af40

0013b1b0 <syscall_lchown>:
  13b1b0:	e92d4010 	push	{r4, lr}
  13b1b4:	e3a0100f 	mov	r1, #15
  13b1b8:	e59f0008 	ldr	r0, [pc, #8]	; 13b1c8 <syscall_lchown+0x18>
  13b1bc:	ebfff8b6 	bl	13949c <syscall_trace>
  13b1c0:	e3a00000 	mov	r0, #0
  13b1c4:	e8bd8010 	pop	{r4, pc}
  13b1c8:	0014af10 	.word	0x0014af10

0013b1cc <syscall_chmod>:
  13b1cc:	e92d4010 	push	{r4, lr}
  13b1d0:	e3a0100e 	mov	r1, #14
  13b1d4:	e59f0008 	ldr	r0, [pc, #8]	; 13b1e4 <syscall_chmod+0x18>
  13b1d8:	ebfff8af 	bl	13949c <syscall_trace>
  13b1dc:	e3a00000 	mov	r0, #0
  13b1e0:	e8bd8010 	pop	{r4, pc}
  13b1e4:	0014af00 	.word	0x0014af00

0013b1e8 <syscall_mknod>:
  13b1e8:	e92d4010 	push	{r4, lr}
  13b1ec:	e3a0100e 	mov	r1, #14
  13b1f0:	e59f0008 	ldr	r0, [pc, #8]	; 13b200 <syscall_mknod+0x18>
  13b1f4:	ebfff8a8 	bl	13949c <syscall_trace>
  13b1f8:	e3a00000 	mov	r0, #0
  13b1fc:	e8bd8010 	pop	{r4, pc}
  13b200:	0014aef0 	.word	0x0014aef0

0013b204 <syscall_link>:
  13b204:	e92d4010 	push	{r4, lr}
  13b208:	e3a0100d 	mov	r1, #13
  13b20c:	e59f0008 	ldr	r0, [pc, #8]	; 13b21c <syscall_link+0x18>
  13b210:	ebfff8a1 	bl	13949c <syscall_trace>
  13b214:	e3a00000 	mov	r0, #0
  13b218:	e8bd8010 	pop	{r4, pc}
  13b21c:	0014aeb0 	.word	0x0014aeb0

0013b220 <syscall_creat>:
  13b220:	e92d4010 	push	{r4, lr}
  13b224:	e3a0100e 	mov	r1, #14
  13b228:	e59f0008 	ldr	r0, [pc, #8]	; 13b238 <syscall_creat+0x18>
  13b22c:	ebfff89a 	bl	13949c <syscall_trace>
  13b230:	e3a00000 	mov	r0, #0
  13b234:	e8bd8010 	pop	{r4, pc}
  13b238:	0014aea0 	.word	0x0014aea0

0013b23c <syscall_restart_syscall>:
  13b23c:	e92d4010 	push	{r4, lr}
  13b240:	e3a01018 	mov	r1, #24
  13b244:	e59f0008 	ldr	r0, [pc, #8]	; 13b254 <syscall_restart_syscall+0x18>
  13b248:	ebfff893 	bl	13949c <syscall_trace>
  13b24c:	e3a00000 	mov	r0, #0
  13b250:	e8bd8010 	pop	{r4, pc}
  13b254:	0014ae28 	.word	0x0014ae28

0013b258 <syscall_debug>:
  13b258:	e92d4070 	push	{r4, r5, r6, lr}
  13b25c:	e1a04000 	mov	r4, r0
  13b260:	e1a05001 	mov	r5, r1
  13b264:	e3a0201d 	mov	r2, #29
  13b268:	e59f1018 	ldr	r1, [pc, #24]	; 13b288 <syscall_debug+0x30>
  13b26c:	e3a000ff 	mov	r0, #255	; 0xff
  13b270:	eb0004f9 	bl	13c65c <syscall>
  13b274:	e1a02005 	mov	r2, r5
  13b278:	e1a01004 	mov	r1, r4
  13b27c:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b280:	e3a000ff 	mov	r0, #255	; 0xff
  13b284:	ea0004f4 	b	13c65c <syscall>
  13b288:	0014c8e8 	.word	0x0014c8e8

0013b28c <syscall_shmdt>:
  13b28c:	e92d4010 	push	{r4, lr}
  13b290:	e1a04000 	mov	r4, r0
  13b294:	e3a0100e 	mov	r1, #14
  13b298:	e59f0010 	ldr	r0, [pc, #16]	; 13b2b0 <syscall_shmdt+0x24>
  13b29c:	ebffffed 	bl	13b258 <syscall_debug>
  13b2a0:	e1a01004 	mov	r1, r4
  13b2a4:	e8bd4010 	pop	{r4, lr}
  13b2a8:	e59f0004 	ldr	r0, [pc, #4]	; 13b2b4 <syscall_shmdt+0x28>
  13b2ac:	ea0004ea 	b	13c65c <syscall>
  13b2b0:	0014c180 	.word	0x0014c180
  13b2b4:	00000132 	.word	0x00000132

0013b2b8 <syscall_set_tid_address>:
  13b2b8:	e92d4010 	push	{r4, lr}
  13b2bc:	e1a04000 	mov	r4, r0
  13b2c0:	e3a01018 	mov	r1, #24
  13b2c4:	e59f0010 	ldr	r0, [pc, #16]	; 13b2dc <syscall_set_tid_address+0x24>
  13b2c8:	ebffffe2 	bl	13b258 <syscall_debug>
  13b2cc:	e1a01004 	mov	r1, r4
  13b2d0:	e8bd4010 	pop	{r4, lr}
  13b2d4:	e3a0007c 	mov	r0, #124	; 0x7c
  13b2d8:	ea0004df 	b	13c65c <syscall>
  13b2dc:	0014bda0 	.word	0x0014bda0

0013b2e0 <syscall_exit_group>:
  13b2e0:	e92d4010 	push	{r4, lr}
  13b2e4:	e1a04000 	mov	r4, r0
  13b2e8:	e3a01013 	mov	r1, #19
  13b2ec:	e59f0010 	ldr	r0, [pc, #16]	; 13b304 <syscall_exit_group+0x24>
  13b2f0:	ebffffd8 	bl	13b258 <syscall_debug>
  13b2f4:	e1a01004 	mov	r1, r4
  13b2f8:	e8bd4010 	pop	{r4, lr}
  13b2fc:	e3a00062 	mov	r0, #98	; 0x62
  13b300:	ea0004d5 	b	13c65c <syscall>
  13b304:	0014bd18 	.word	0x0014bd18

0013b308 <syscall_sched_get_priority_min>:
  13b308:	e92d4010 	push	{r4, lr}
  13b30c:	e1a04000 	mov	r4, r0
  13b310:	e3a0101f 	mov	r1, #31
  13b314:	e59f0010 	ldr	r0, [pc, #16]	; 13b32c <syscall_sched_get_priority_min+0x24>
  13b318:	ebffffce 	bl	13b258 <syscall_debug>
  13b31c:	e1a01004 	mov	r1, r4
  13b320:	e8bd4010 	pop	{r4, lr}
  13b324:	e3a00097 	mov	r0, #151	; 0x97
  13b328:	ea0004cb 	b	13c65c <syscall>
  13b32c:	0014b6b0 	.word	0x0014b6b0

0013b330 <syscall_sched_get_priority_max>:
  13b330:	e92d4010 	push	{r4, lr}
  13b334:	e1a04000 	mov	r4, r0
  13b338:	e3a0101f 	mov	r1, #31
  13b33c:	e59f0010 	ldr	r0, [pc, #16]	; 13b354 <syscall_sched_get_priority_max+0x24>
  13b340:	ebffffc4 	bl	13b258 <syscall_debug>
  13b344:	e1a01004 	mov	r1, r4
  13b348:	e8bd4010 	pop	{r4, lr}
  13b34c:	e3a00096 	mov	r0, #150	; 0x96
  13b350:	ea0004c1 	b	13c65c <syscall>
  13b354:	0014b690 	.word	0x0014b690

0013b358 <syscall_fsync>:
  13b358:	e92d4010 	push	{r4, lr}
  13b35c:	e1a04000 	mov	r4, r0
  13b360:	e3a0100e 	mov	r1, #14
  13b364:	e59f0010 	ldr	r0, [pc, #16]	; 13b37c <syscall_fsync+0x24>
  13b368:	ebffffba 	bl	13b258 <syscall_debug>
  13b36c:	e1a01004 	mov	r1, r4
  13b370:	e8bd4010 	pop	{r4, lr}
  13b374:	e3a0009b 	mov	r0, #155	; 0x9b
  13b378:	ea0004b7 	b	13c65c <syscall>
  13b37c:	0014b3cc 	.word	0x0014b3cc

0013b380 <syscall_brk>:
  13b380:	e92d4010 	push	{r4, lr}
  13b384:	e1a04000 	mov	r4, r0
  13b388:	e3a0100c 	mov	r1, #12
  13b38c:	e59f0010 	ldr	r0, [pc, #16]	; 13b3a4 <syscall_brk+0x24>
  13b390:	ebffffb0 	bl	13b258 <syscall_debug>
  13b394:	e1a01004 	mov	r1, r4
  13b398:	e8bd4010 	pop	{r4, lr}
  13b39c:	e3a00034 	mov	r0, #52	; 0x34
  13b3a0:	ea0004ad 	b	13c65c <syscall>
  13b3a4:	0014b02c 	.word	0x0014b02c

0013b3a8 <syscall_pipe>:
  13b3a8:	e92d4010 	push	{r4, lr}
  13b3ac:	e1a04000 	mov	r4, r0
  13b3b0:	e3a0100d 	mov	r1, #13
  13b3b4:	e59f0010 	ldr	r0, [pc, #16]	; 13b3cc <syscall_pipe+0x24>
  13b3b8:	ebffffa6 	bl	13b258 <syscall_debug>
  13b3bc:	e1a01004 	mov	r1, r4
  13b3c0:	e8bd4010 	pop	{r4, lr}
  13b3c4:	e3a0007e 	mov	r0, #126	; 0x7e
  13b3c8:	ea0004a3 	b	13c65c <syscall>
  13b3cc:	0014b00c 	.word	0x0014b00c

0013b3d0 <syscall_dup>:
  13b3d0:	e92d4010 	push	{r4, lr}
  13b3d4:	e1a04000 	mov	r4, r0
  13b3d8:	e3a0100c 	mov	r1, #12
  13b3dc:	e59f0010 	ldr	r0, [pc, #16]	; 13b3f4 <syscall_dup+0x24>
  13b3e0:	ebffff9c 	bl	13b258 <syscall_debug>
  13b3e4:	e1a01004 	mov	r1, r4
  13b3e8:	e8bd4010 	pop	{r4, lr}
  13b3ec:	e3a00085 	mov	r0, #133	; 0x85
  13b3f0:	ea000499 	b	13c65c <syscall>
  13b3f4:	0014b000 	.word	0x0014b000

0013b3f8 <syscall_rmdir>:
  13b3f8:	e92d4010 	push	{r4, lr}
  13b3fc:	e1a04000 	mov	r4, r0
  13b400:	e3a0100e 	mov	r1, #14
  13b404:	e59f0010 	ldr	r0, [pc, #16]	; 13b41c <syscall_rmdir+0x24>
  13b408:	ebffff92 	bl	13b258 <syscall_debug>
  13b40c:	e1a01004 	mov	r1, r4
  13b410:	e8bd4010 	pop	{r4, lr}
  13b414:	e3a00078 	mov	r0, #120	; 0x78
  13b418:	ea00048f 	b	13c65c <syscall>
  13b41c:	0014aff0 	.word	0x0014aff0

0013b420 <syscall_chdir>:
  13b420:	e92d4010 	push	{r4, lr}
  13b424:	e1a04000 	mov	r4, r0
  13b428:	e3a0100e 	mov	r1, #14
  13b42c:	e59f0010 	ldr	r0, [pc, #16]	; 13b444 <syscall_chdir+0x24>
  13b430:	ebffff88 	bl	13b258 <syscall_debug>
  13b434:	e1a01004 	mov	r1, r4
  13b438:	e8bd4010 	pop	{r4, lr}
  13b43c:	e3a00075 	mov	r0, #117	; 0x75
  13b440:	ea000485 	b	13c65c <syscall>
  13b444:	0014aee0 	.word	0x0014aee0

0013b448 <syscall_unlink>:
  13b448:	e92d4010 	push	{r4, lr}
  13b44c:	e1a04000 	mov	r4, r0
  13b450:	e3a0100f 	mov	r1, #15
  13b454:	e59f0010 	ldr	r0, [pc, #16]	; 13b46c <syscall_unlink+0x24>
  13b458:	ebffff7e 	bl	13b258 <syscall_debug>
  13b45c:	e1a01004 	mov	r1, r4
  13b460:	e8bd4010 	pop	{r4, lr}
  13b464:	e3a00076 	mov	r0, #118	; 0x76
  13b468:	ea00047b 	b	13c65c <syscall>
  13b46c:	0014aec0 	.word	0x0014aec0

0013b470 <syscall_close>:
  13b470:	e92d4010 	push	{r4, lr}
  13b474:	e1a04000 	mov	r4, r0
  13b478:	e3a0100e 	mov	r1, #14
  13b47c:	e59f0010 	ldr	r0, [pc, #16]	; 13b494 <syscall_close+0x24>
  13b480:	ebffff74 	bl	13b258 <syscall_debug>
  13b484:	e1a01004 	mov	r1, r4
  13b488:	e8bd4010 	pop	{r4, lr}
  13b48c:	e3a00006 	mov	r0, #6
  13b490:	ea000471 	b	13c65c <syscall>
  13b494:	0014ae90 	.word	0x0014ae90

0013b498 <syscall_exit>:
  13b498:	e92d4010 	push	{r4, lr}
  13b49c:	e1a04000 	mov	r4, r0
  13b4a0:	e3a0100d 	mov	r1, #13
  13b4a4:	e59f0010 	ldr	r0, [pc, #16]	; 13b4bc <syscall_exit+0x24>
  13b4a8:	ebffff6a 	bl	13b258 <syscall_debug>
  13b4ac:	e1a01004 	mov	r1, r4
  13b4b0:	e8bd4010 	pop	{r4, lr}
  13b4b4:	e3a00001 	mov	r0, #1
  13b4b8:	ea000467 	b	13c65c <syscall>
  13b4bc:	0014ae40 	.word	0x0014ae40

0013b4c0 <syscall_listen>:
  13b4c0:	e92d4070 	push	{r4, r5, r6, lr}
  13b4c4:	e1a04000 	mov	r4, r0
  13b4c8:	e1a05001 	mov	r5, r1
  13b4cc:	e59f0018 	ldr	r0, [pc, #24]	; 13b4ec <syscall_listen+0x2c>
  13b4d0:	e3a0100f 	mov	r1, #15
  13b4d4:	ebffff5f 	bl	13b258 <syscall_debug>
  13b4d8:	e1a02005 	mov	r2, r5
  13b4dc:	e1a01004 	mov	r1, r4
  13b4e0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b4e4:	e3a0004d 	mov	r0, #77	; 0x4d
  13b4e8:	ea00045b 	b	13c65c <syscall>
  13b4ec:	0014c004 	.word	0x0014c004

0013b4f0 <syscall_clock_getres>:
  13b4f0:	e92d4070 	push	{r4, r5, r6, lr}
  13b4f4:	e1a04000 	mov	r4, r0
  13b4f8:	e1a05001 	mov	r5, r1
  13b4fc:	e59f0018 	ldr	r0, [pc, #24]	; 13b51c <syscall_clock_getres+0x2c>
  13b500:	e3a01015 	mov	r1, #21
  13b504:	ebffff53 	bl	13b258 <syscall_debug>
  13b508:	e1a02005 	mov	r2, r5
  13b50c:	e1a01004 	mov	r1, r4
  13b510:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b514:	e3a00081 	mov	r0, #129	; 0x81
  13b518:	ea00044f 	b	13c65c <syscall>
  13b51c:	0014be64 	.word	0x0014be64

0013b520 <syscall_clock_gettime>:
  13b520:	e92d4070 	push	{r4, r5, r6, lr}
  13b524:	e1a04000 	mov	r4, r0
  13b528:	e1a05001 	mov	r5, r1
  13b52c:	e59f0018 	ldr	r0, [pc, #24]	; 13b54c <syscall_clock_gettime+0x2c>
  13b530:	e3a01016 	mov	r1, #22
  13b534:	ebffff47 	bl	13b258 <syscall_debug>
  13b538:	e1a02005 	mov	r2, r5
  13b53c:	e1a01004 	mov	r1, r4
  13b540:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b544:	e3a00080 	mov	r0, #128	; 0x80
  13b548:	ea000443 	b	13c65c <syscall>
  13b54c:	0014be4c 	.word	0x0014be4c

0013b550 <syscall_clock_settime>:
  13b550:	e92d4070 	push	{r4, r5, r6, lr}
  13b554:	e1a04000 	mov	r4, r0
  13b558:	e1a05001 	mov	r5, r1
  13b55c:	e59f0018 	ldr	r0, [pc, #24]	; 13b57c <syscall_clock_settime+0x2c>
  13b560:	e3a01016 	mov	r1, #22
  13b564:	ebffff3b 	bl	13b258 <syscall_debug>
  13b568:	e1a02005 	mov	r2, r5
  13b56c:	e1a01004 	mov	r1, r4
  13b570:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b574:	e3a0007f 	mov	r0, #127	; 0x7f
  13b578:	ea000437 	b	13c65c <syscall>
  13b57c:	0014be34 	.word	0x0014be34

0013b580 <syscall_tkill>:
  13b580:	e92d4070 	push	{r4, r5, r6, lr}
  13b584:	e1a04000 	mov	r4, r0
  13b588:	e1a05001 	mov	r5, r1
  13b58c:	e59f0018 	ldr	r0, [pc, #24]	; 13b5ac <syscall_tkill+0x2c>
  13b590:	e3a0100e 	mov	r1, #14
  13b594:	ebffff2f 	bl	13b258 <syscall_debug>
  13b598:	e1a02005 	mov	r2, r5
  13b59c:	e1a01004 	mov	r1, r4
  13b5a0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b5a4:	e3a00069 	mov	r0, #105	; 0x69
  13b5a8:	ea00042b 	b	13c65c <syscall>
  13b5ac:	0014bc44 	.word	0x0014bc44

0013b5b0 <syscall_fstat64>:
  13b5b0:	e92d4070 	push	{r4, r5, r6, lr}
  13b5b4:	e1a04000 	mov	r4, r0
  13b5b8:	e1a05001 	mov	r5, r1
  13b5bc:	e59f0018 	ldr	r0, [pc, #24]	; 13b5dc <syscall_fstat64+0x2c>
  13b5c0:	e3a01010 	mov	r1, #16
  13b5c4:	ebffff23 	bl	13b258 <syscall_debug>
  13b5c8:	e1a02005 	mov	r2, r5
  13b5cc:	e1a01004 	mov	r1, r4
  13b5d0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b5d4:	e3a00008 	mov	r0, #8
  13b5d8:	ea00041f 	b	13c65c <syscall>
  13b5dc:	0014b948 	.word	0x0014b948

0013b5e0 <syscall_lstat64>:
  13b5e0:	e92d4070 	push	{r4, r5, r6, lr}
  13b5e4:	e1a04000 	mov	r4, r0
  13b5e8:	e1a05001 	mov	r5, r1
  13b5ec:	e59f0018 	ldr	r0, [pc, #24]	; 13b60c <syscall_lstat64+0x2c>
  13b5f0:	e3a01010 	mov	r1, #16
  13b5f4:	ebffff17 	bl	13b258 <syscall_debug>
  13b5f8:	e1a02005 	mov	r2, r5
  13b5fc:	e1a01004 	mov	r1, r4
  13b600:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b604:	e3a00043 	mov	r0, #67	; 0x43
  13b608:	ea000413 	b	13c65c <syscall>
  13b60c:	0014b938 	.word	0x0014b938

0013b610 <syscall_stat64>:
  13b610:	e92d4070 	push	{r4, r5, r6, lr}
  13b614:	e1a04000 	mov	r4, r0
  13b618:	e1a05001 	mov	r5, r1
  13b61c:	e59f0018 	ldr	r0, [pc, #24]	; 13b63c <syscall_stat64+0x2c>
  13b620:	e3a0100f 	mov	r1, #15
  13b624:	ebffff0b 	bl	13b258 <syscall_debug>
  13b628:	e1a02005 	mov	r2, r5
  13b62c:	e1a01004 	mov	r1, r4
  13b630:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b634:	e3a00043 	mov	r0, #67	; 0x43
  13b638:	ea000407 	b	13c65c <syscall>
  13b63c:	0014b928 	.word	0x0014b928

0013b640 <syscall_ugetrlimit>:
  13b640:	e92d4070 	push	{r4, r5, r6, lr}
  13b644:	e1a04000 	mov	r4, r0
  13b648:	e1a05001 	mov	r5, r1
  13b64c:	e59f0018 	ldr	r0, [pc, #24]	; 13b66c <syscall_ugetrlimit+0x2c>
  13b650:	e3a01013 	mov	r1, #19
  13b654:	ebfffeff 	bl	13b258 <syscall_debug>
  13b658:	e1a02005 	mov	r2, r5
  13b65c:	e1a01004 	mov	r1, r4
  13b660:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b664:	e3a0008d 	mov	r0, #141	; 0x8d
  13b668:	ea0003fb 	b	13c65c <syscall>
  13b66c:	0014b8dc 	.word	0x0014b8dc

0013b670 <syscall_getcwd>:
  13b670:	e92d4070 	push	{r4, r5, r6, lr}
  13b674:	e1a04000 	mov	r4, r0
  13b678:	e1a05001 	mov	r5, r1
  13b67c:	e59f0018 	ldr	r0, [pc, #24]	; 13b69c <syscall_getcwd+0x2c>
  13b680:	e3a0100f 	mov	r1, #15
  13b684:	ebfffef3 	bl	13b258 <syscall_debug>
  13b688:	e1a02005 	mov	r2, r5
  13b68c:	e1a01004 	mov	r1, r4
  13b690:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b694:	e3a00074 	mov	r0, #116	; 0x74
  13b698:	ea0003ef 	b	13c65c <syscall>
  13b69c:	0014b874 	.word	0x0014b874

0013b6a0 <syscall_nanosleep>:
  13b6a0:	e92d4070 	push	{r4, r5, r6, lr}
  13b6a4:	e1a04000 	mov	r4, r0
  13b6a8:	e1a05001 	mov	r5, r1
  13b6ac:	e59f0018 	ldr	r0, [pc, #24]	; 13b6cc <syscall_nanosleep+0x2c>
  13b6b0:	e3a01012 	mov	r1, #18
  13b6b4:	ebfffee7 	bl	13b258 <syscall_debug>
  13b6b8:	e1a02005 	mov	r2, r5
  13b6bc:	e1a01004 	mov	r1, r4
  13b6c0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b6c4:	e3a0000a 	mov	r0, #10
  13b6c8:	ea0003e3 	b	13c65c <syscall>
  13b6cc:	0014b6f0 	.word	0x0014b6f0

0013b6d0 <syscall_sched_getparam>:
  13b6d0:	e92d4070 	push	{r4, r5, r6, lr}
  13b6d4:	e1a04000 	mov	r4, r0
  13b6d8:	e1a05001 	mov	r5, r1
  13b6dc:	e59f0018 	ldr	r0, [pc, #24]	; 13b6fc <syscall_sched_getparam+0x2c>
  13b6e0:	e3a01017 	mov	r1, #23
  13b6e4:	ebfffedb 	bl	13b258 <syscall_debug>
  13b6e8:	e1a02005 	mov	r2, r5
  13b6ec:	e1a01004 	mov	r1, r4
  13b6f0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b6f4:	e3a00095 	mov	r0, #149	; 0x95
  13b6f8:	ea0003d7 	b	13c65c <syscall>
  13b6fc:	0014b62c 	.word	0x0014b62c

0013b700 <syscall_sched_setparam>:
  13b700:	e92d4070 	push	{r4, r5, r6, lr}
  13b704:	e1a04000 	mov	r4, r0
  13b708:	e1a05001 	mov	r5, r1
  13b70c:	e59f0018 	ldr	r0, [pc, #24]	; 13b72c <syscall_sched_setparam+0x2c>
  13b710:	e3a01017 	mov	r1, #23
  13b714:	ebfffecf 	bl	13b258 <syscall_debug>
  13b718:	e1a02005 	mov	r2, r5
  13b71c:	e1a01004 	mov	r1, r4
  13b720:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b724:	e3a00094 	mov	r0, #148	; 0x94
  13b728:	ea0003cb 	b	13c65c <syscall>
  13b72c:	0014b614 	.word	0x0014b614

0013b730 <syscall_lstat>:
  13b730:	e92d4070 	push	{r4, r5, r6, lr}
  13b734:	e1a04000 	mov	r4, r0
  13b738:	e1a05001 	mov	r5, r1
  13b73c:	e59f0018 	ldr	r0, [pc, #24]	; 13b75c <syscall_lstat+0x2c>
  13b740:	e3a0100e 	mov	r1, #14
  13b744:	ebfffec3 	bl	13b258 <syscall_debug>
  13b748:	e1a02005 	mov	r2, r5
  13b74c:	e1a01004 	mov	r1, r4
  13b750:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b754:	e3a00043 	mov	r0, #67	; 0x43
  13b758:	ea0003bf 	b	13c65c <syscall>
  13b75c:	0014b36c 	.word	0x0014b36c

0013b760 <syscall_stat>:
  13b760:	e92d4070 	push	{r4, r5, r6, lr}
  13b764:	e1a04000 	mov	r4, r0
  13b768:	e1a05001 	mov	r5, r1
  13b76c:	e59f0018 	ldr	r0, [pc, #24]	; 13b78c <syscall_stat+0x2c>
  13b770:	e3a0100d 	mov	r1, #13
  13b774:	ebfffeb7 	bl	13b258 <syscall_debug>
  13b778:	e1a02005 	mov	r2, r5
  13b77c:	e1a01004 	mov	r1, r4
  13b780:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b784:	e3a00043 	mov	r0, #67	; 0x43
  13b788:	ea0003b3 	b	13c65c <syscall>
  13b78c:	0014b35c 	.word	0x0014b35c

0013b790 <syscall_munmap>:
  13b790:	e92d4070 	push	{r4, r5, r6, lr}
  13b794:	e1a04000 	mov	r4, r0
  13b798:	e1a05001 	mov	r5, r1
  13b79c:	e59f0018 	ldr	r0, [pc, #24]	; 13b7bc <syscall_munmap+0x2c>
  13b7a0:	e3a0100f 	mov	r1, #15
  13b7a4:	ebfffeab 	bl	13b258 <syscall_debug>
  13b7a8:	e1a02005 	mov	r2, r5
  13b7ac:	e1a01004 	mov	r1, r4
  13b7b0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b7b4:	e3a00036 	mov	r0, #54	; 0x36
  13b7b8:	ea0003a7 	b	13c65c <syscall>
  13b7bc:	0014b284 	.word	0x0014b284

0013b7c0 <syscall_setrlimit>:
  13b7c0:	e92d4070 	push	{r4, r5, r6, lr}
  13b7c4:	e1a04000 	mov	r4, r0
  13b7c8:	e1a05001 	mov	r5, r1
  13b7cc:	e59f0018 	ldr	r0, [pc, #24]	; 13b7ec <syscall_setrlimit+0x2c>
  13b7d0:	e3a01012 	mov	r1, #18
  13b7d4:	ebfffe9f 	bl	13b258 <syscall_debug>
  13b7d8:	e1a02005 	mov	r2, r5
  13b7dc:	e1a01004 	mov	r1, r4
  13b7e0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b7e4:	e3a0008e 	mov	r0, #142	; 0x8e
  13b7e8:	ea00039b 	b	13c65c <syscall>
  13b7ec:	0014b1b0 	.word	0x0014b1b0

0013b7f0 <syscall_dup2>:
  13b7f0:	e92d4070 	push	{r4, r5, r6, lr}
  13b7f4:	e1a04000 	mov	r4, r0
  13b7f8:	e1a05001 	mov	r5, r1
  13b7fc:	e59f0018 	ldr	r0, [pc, #24]	; 13b81c <syscall_dup2+0x2c>
  13b800:	e3a0100d 	mov	r1, #13
  13b804:	ebfffe93 	bl	13b258 <syscall_debug>
  13b808:	e1a02005 	mov	r2, r5
  13b80c:	e1a01004 	mov	r1, r4
  13b810:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b814:	e3a00086 	mov	r0, #134	; 0x86
  13b818:	ea00038f 	b	13c65c <syscall>
  13b81c:	0014b0f8 	.word	0x0014b0f8

0013b820 <syscall_mkdir>:
  13b820:	e92d4070 	push	{r4, r5, r6, lr}
  13b824:	e1a04000 	mov	r4, r0
  13b828:	e1a05001 	mov	r5, r1
  13b82c:	e59f0018 	ldr	r0, [pc, #24]	; 13b84c <syscall_mkdir+0x2c>
  13b830:	e3a0100e 	mov	r1, #14
  13b834:	ebfffe87 	bl	13b258 <syscall_debug>
  13b838:	e1a02005 	mov	r2, r5
  13b83c:	e1a01004 	mov	r1, r4
  13b840:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b844:	e3a00077 	mov	r0, #119	; 0x77
  13b848:	ea000383 	b	13c65c <syscall>
  13b84c:	0014afe0 	.word	0x0014afe0

0013b850 <syscall_rename>:
  13b850:	e92d4070 	push	{r4, r5, r6, lr}
  13b854:	e1a04000 	mov	r4, r0
  13b858:	e1a05001 	mov	r5, r1
  13b85c:	e59f0018 	ldr	r0, [pc, #24]	; 13b87c <syscall_rename+0x2c>
  13b860:	e3a0100f 	mov	r1, #15
  13b864:	ebfffe7b 	bl	13b258 <syscall_debug>
  13b868:	e1a02005 	mov	r2, r5
  13b86c:	e1a01004 	mov	r1, r4
  13b870:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b874:	e3a00087 	mov	r0, #135	; 0x87
  13b878:	ea000377 	b	13c65c <syscall>
  13b87c:	0014afd0 	.word	0x0014afd0

0013b880 <syscall_kill>:
  13b880:	e92d4070 	push	{r4, r5, r6, lr}
  13b884:	e1a04000 	mov	r4, r0
  13b888:	e1a05001 	mov	r5, r1
  13b88c:	e59f0018 	ldr	r0, [pc, #24]	; 13b8ac <syscall_kill+0x2c>
  13b890:	e3a0100d 	mov	r1, #13
  13b894:	ebfffe6f 	bl	13b258 <syscall_debug>
  13b898:	e1a02005 	mov	r2, r5
  13b89c:	e1a01004 	mov	r1, r4
  13b8a0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b8a4:	e3a0000e 	mov	r0, #14
  13b8a8:	ea00036b 	b	13c65c <syscall>
  13b8ac:	0014afc0 	.word	0x0014afc0

0013b8b0 <syscall_access>:
  13b8b0:	e92d4070 	push	{r4, r5, r6, lr}
  13b8b4:	e1a04000 	mov	r4, r0
  13b8b8:	e1a05001 	mov	r5, r1
  13b8bc:	e59f0018 	ldr	r0, [pc, #24]	; 13b8dc <syscall_access+0x2c>
  13b8c0:	e3a0100f 	mov	r1, #15
  13b8c4:	ebfffe63 	bl	13b258 <syscall_debug>
  13b8c8:	e1a02005 	mov	r2, r5
  13b8cc:	e1a01004 	mov	r1, r4
  13b8d0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b8d4:	e3a0007d 	mov	r0, #125	; 0x7d
  13b8d8:	ea00035f 	b	13c65c <syscall>
  13b8dc:	0014af90 	.word	0x0014af90

0013b8e0 <syscall_getrandom>:
  13b8e0:	e92d4070 	push	{r4, r5, r6, lr}
  13b8e4:	e1a06002 	mov	r6, r2
  13b8e8:	e1a04000 	mov	r4, r0
  13b8ec:	e1a05001 	mov	r5, r1
  13b8f0:	e59f001c 	ldr	r0, [pc, #28]	; 13b914 <syscall_getrandom+0x34>
  13b8f4:	e3a01012 	mov	r1, #18
  13b8f8:	ebfffe56 	bl	13b258 <syscall_debug>
  13b8fc:	e1a03006 	mov	r3, r6
  13b900:	e1a02005 	mov	r2, r5
  13b904:	e1a01004 	mov	r1, r4
  13b908:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b90c:	e3a00090 	mov	r0, #144	; 0x90
  13b910:	ea000351 	b	13c65c <syscall>
  13b914:	0014c7b0 	.word	0x0014c7b0

0013b918 <syscall_shmctl>:
  13b918:	e92d4070 	push	{r4, r5, r6, lr}
  13b91c:	e1a06002 	mov	r6, r2
  13b920:	e1a04000 	mov	r4, r0
  13b924:	e1a05001 	mov	r5, r1
  13b928:	e59f001c 	ldr	r0, [pc, #28]	; 13b94c <syscall_shmctl+0x34>
  13b92c:	e3a0100f 	mov	r1, #15
  13b930:	ebfffe48 	bl	13b258 <syscall_debug>
  13b934:	e1a03006 	mov	r3, r6
  13b938:	e1a02005 	mov	r2, r5
  13b93c:	e1a01004 	mov	r1, r4
  13b940:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b944:	e3a00f4d 	mov	r0, #308	; 0x134
  13b948:	ea000343 	b	13c65c <syscall>
  13b94c:	0014c1a0 	.word	0x0014c1a0

0013b950 <syscall_shmget>:
  13b950:	e92d4070 	push	{r4, r5, r6, lr}
  13b954:	e1a06002 	mov	r6, r2
  13b958:	e1a04000 	mov	r4, r0
  13b95c:	e1a05001 	mov	r5, r1
  13b960:	e59f001c 	ldr	r0, [pc, #28]	; 13b984 <syscall_shmget+0x34>
  13b964:	e3a0100f 	mov	r1, #15
  13b968:	ebfffe3a 	bl	13b258 <syscall_debug>
  13b96c:	e1a03006 	mov	r3, r6
  13b970:	e1a02005 	mov	r2, r5
  13b974:	e1a01004 	mov	r1, r4
  13b978:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b97c:	e59f0004 	ldr	r0, [pc, #4]	; 13b988 <syscall_shmget+0x38>
  13b980:	ea000335 	b	13c65c <syscall>
  13b984:	0014c190 	.word	0x0014c190
  13b988:	00000133 	.word	0x00000133

0013b98c <syscall_shmat>:
  13b98c:	e92d4070 	push	{r4, r5, r6, lr}
  13b990:	e1a06002 	mov	r6, r2
  13b994:	e1a04000 	mov	r4, r0
  13b998:	e1a05001 	mov	r5, r1
  13b99c:	e59f001c 	ldr	r0, [pc, #28]	; 13b9c0 <syscall_shmat+0x34>
  13b9a0:	e3a0100e 	mov	r1, #14
  13b9a4:	ebfffe2b 	bl	13b258 <syscall_debug>
  13b9a8:	e1a03006 	mov	r3, r6
  13b9ac:	e1a02005 	mov	r2, r5
  13b9b0:	e1a01004 	mov	r1, r4
  13b9b4:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b9b8:	e59f0004 	ldr	r0, [pc, #4]	; 13b9c4 <syscall_shmat+0x38>
  13b9bc:	ea000326 	b	13c65c <syscall>
  13b9c0:	0014c170 	.word	0x0014c170
  13b9c4:	00000131 	.word	0x00000131

0013b9c8 <syscall_getpeername>:
  13b9c8:	e92d4070 	push	{r4, r5, r6, lr}
  13b9cc:	e1a06002 	mov	r6, r2
  13b9d0:	e1a04000 	mov	r4, r0
  13b9d4:	e1a05001 	mov	r5, r1
  13b9d8:	e59f001c 	ldr	r0, [pc, #28]	; 13b9fc <syscall_getpeername+0x34>
  13b9dc:	e3a01014 	mov	r1, #20
  13b9e0:	ebfffe1c 	bl	13b258 <syscall_debug>
  13b9e4:	e1a03006 	mov	r3, r6
  13b9e8:	e1a02005 	mov	r2, r5
  13b9ec:	e1a01004 	mov	r1, r4
  13b9f0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13b9f4:	e3a00048 	mov	r0, #72	; 0x48
  13b9f8:	ea000317 	b	13c65c <syscall>
  13b9fc:	0014c038 	.word	0x0014c038

0013ba00 <syscall_getsockname>:
  13ba00:	e92d4070 	push	{r4, r5, r6, lr}
  13ba04:	e1a06002 	mov	r6, r2
  13ba08:	e1a04000 	mov	r4, r0
  13ba0c:	e1a05001 	mov	r5, r1
  13ba10:	e59f001c 	ldr	r0, [pc, #28]	; 13ba34 <syscall_getsockname+0x34>
  13ba14:	e3a01014 	mov	r1, #20
  13ba18:	ebfffe0e 	bl	13b258 <syscall_debug>
  13ba1c:	e1a03006 	mov	r3, r6
  13ba20:	e1a02005 	mov	r2, r5
  13ba24:	e1a01004 	mov	r1, r4
  13ba28:	e8bd4070 	pop	{r4, r5, r6, lr}
  13ba2c:	e3a00049 	mov	r0, #73	; 0x49
  13ba30:	ea000309 	b	13c65c <syscall>
  13ba34:	0014c024 	.word	0x0014c024

0013ba38 <syscall_accept>:
  13ba38:	e92d4070 	push	{r4, r5, r6, lr}
  13ba3c:	e1a06002 	mov	r6, r2
  13ba40:	e1a04000 	mov	r4, r0
  13ba44:	e1a05001 	mov	r5, r1
  13ba48:	e59f001c 	ldr	r0, [pc, #28]	; 13ba6c <syscall_accept+0x34>
  13ba4c:	e3a0100f 	mov	r1, #15
  13ba50:	ebfffe00 	bl	13b258 <syscall_debug>
  13ba54:	e1a03006 	mov	r3, r6
  13ba58:	e1a02005 	mov	r2, r5
  13ba5c:	e1a01004 	mov	r1, r4
  13ba60:	e8bd4070 	pop	{r4, r5, r6, lr}
  13ba64:	e3a00045 	mov	r0, #69	; 0x45
  13ba68:	ea0002fb 	b	13c65c <syscall>
  13ba6c:	0014c014 	.word	0x0014c014

0013ba70 <syscall_connect>:
  13ba70:	e92d4070 	push	{r4, r5, r6, lr}
  13ba74:	e1a06002 	mov	r6, r2
  13ba78:	e1a04000 	mov	r4, r0
  13ba7c:	e1a05001 	mov	r5, r1
  13ba80:	e59f001c 	ldr	r0, [pc, #28]	; 13baa4 <syscall_connect+0x34>
  13ba84:	e3a01010 	mov	r1, #16
  13ba88:	ebfffdf2 	bl	13b258 <syscall_debug>
  13ba8c:	e1a03006 	mov	r3, r6
  13ba90:	e1a02005 	mov	r2, r5
  13ba94:	e1a01004 	mov	r1, r4
  13ba98:	e8bd4070 	pop	{r4, r5, r6, lr}
  13ba9c:	e3a0004c 	mov	r0, #76	; 0x4c
  13baa0:	ea0002ed 	b	13c65c <syscall>
  13baa4:	0014bff4 	.word	0x0014bff4

0013baa8 <syscall_bind>:
  13baa8:	e92d4070 	push	{r4, r5, r6, lr}
  13baac:	e1a06002 	mov	r6, r2
  13bab0:	e1a04000 	mov	r4, r0
  13bab4:	e1a05001 	mov	r5, r1
  13bab8:	e59f001c 	ldr	r0, [pc, #28]	; 13badc <syscall_bind+0x34>
  13babc:	e3a0100d 	mov	r1, #13
  13bac0:	ebfffde4 	bl	13b258 <syscall_debug>
  13bac4:	e1a03006 	mov	r3, r6
  13bac8:	e1a02005 	mov	r2, r5
  13bacc:	e1a01004 	mov	r1, r4
  13bad0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bad4:	e3a00046 	mov	r0, #70	; 0x46
  13bad8:	ea0002df 	b	13c65c <syscall>
  13badc:	0014bfe4 	.word	0x0014bfe4

0013bae0 <syscall_socket>:
  13bae0:	e92d4070 	push	{r4, r5, r6, lr}
  13bae4:	e1a06002 	mov	r6, r2
  13bae8:	e1a04000 	mov	r4, r0
  13baec:	e1a05001 	mov	r5, r1
  13baf0:	e59f001c 	ldr	r0, [pc, #28]	; 13bb14 <syscall_socket+0x34>
  13baf4:	e3a0100f 	mov	r1, #15
  13baf8:	ebfffdd6 	bl	13b258 <syscall_debug>
  13bafc:	e1a03006 	mov	r3, r6
  13bb00:	e1a02005 	mov	r2, r5
  13bb04:	e1a01004 	mov	r1, r4
  13bb08:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bb0c:	e3a00052 	mov	r0, #82	; 0x52
  13bb10:	ea0002d1 	b	13c65c <syscall>
  13bb14:	0014bfd4 	.word	0x0014bfd4

0013bb18 <syscall_sched_setaffinity>:
  13bb18:	e92d4070 	push	{r4, r5, r6, lr}
  13bb1c:	e1a06002 	mov	r6, r2
  13bb20:	e1a04000 	mov	r4, r0
  13bb24:	e1a05001 	mov	r5, r1
  13bb28:	e59f001c 	ldr	r0, [pc, #28]	; 13bb4c <syscall_sched_setaffinity+0x34>
  13bb2c:	e3a0101a 	mov	r1, #26
  13bb30:	ebfffdc8 	bl	13b258 <syscall_debug>
  13bb34:	e1a03006 	mov	r3, r6
  13bb38:	e1a02005 	mov	r2, r5
  13bb3c:	e1a01004 	mov	r1, r4
  13bb40:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bb44:	e3a0009a 	mov	r0, #154	; 0x9a
  13bb48:	ea0002c3 	b	13c65c <syscall>
  13bb4c:	0014bc78 	.word	0x0014bc78

0013bb50 <syscall_fcntl64>:
  13bb50:	e92d4070 	push	{r4, r5, r6, lr}
  13bb54:	e1a06002 	mov	r6, r2
  13bb58:	e1a04000 	mov	r4, r0
  13bb5c:	e1a05001 	mov	r5, r1
  13bb60:	e59f001c 	ldr	r0, [pc, #28]	; 13bb84 <syscall_fcntl64+0x34>
  13bb64:	e3a01010 	mov	r1, #16
  13bb68:	ebfffdba 	bl	13b258 <syscall_debug>
  13bb6c:	e1a03006 	mov	r3, r6
  13bb70:	e1a02005 	mov	r2, r5
  13bb74:	e1a01004 	mov	r1, r4
  13bb78:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bb7c:	e3a00007 	mov	r0, #7
  13bb80:	ea0002b5 	b	13c65c <syscall>
  13bb84:	0014bb18 	.word	0x0014bb18

0013bb88 <syscall_madvise>:
  13bb88:	e92d4070 	push	{r4, r5, r6, lr}
  13bb8c:	e1a06002 	mov	r6, r2
  13bb90:	e1a04000 	mov	r4, r0
  13bb94:	e1a05001 	mov	r5, r1
  13bb98:	e59f001c 	ldr	r0, [pc, #28]	; 13bbbc <syscall_madvise+0x34>
  13bb9c:	e3a01010 	mov	r1, #16
  13bba0:	ebfffdac 	bl	13b258 <syscall_debug>
  13bba4:	e1a03006 	mov	r3, r6
  13bba8:	e1a02005 	mov	r2, r5
  13bbac:	e1a01004 	mov	r1, r4
  13bbb0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bbb4:	e3a00093 	mov	r0, #147	; 0x93
  13bbb8:	ea0002a7 	b	13c65c <syscall>
  13bbbc:	0014bb08 	.word	0x0014bb08

0013bbc0 <syscall_getdents64>:
  13bbc0:	e92d4070 	push	{r4, r5, r6, lr}
  13bbc4:	e1a06002 	mov	r6, r2
  13bbc8:	e1a04000 	mov	r4, r0
  13bbcc:	e1a05001 	mov	r5, r1
  13bbd0:	e59f001c 	ldr	r0, [pc, #28]	; 13bbf4 <syscall_getdents64+0x34>
  13bbd4:	e3a01013 	mov	r1, #19
  13bbd8:	ebfffd9e 	bl	13b258 <syscall_debug>
  13bbdc:	e1a03006 	mov	r3, r6
  13bbe0:	e1a02005 	mov	r2, r5
  13bbe4:	e1a01004 	mov	r1, r4
  13bbe8:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bbec:	e3a00079 	mov	r0, #121	; 0x79
  13bbf0:	ea000299 	b	13c65c <syscall>
  13bbf4:	0014bad0 	.word	0x0014bad0

0013bbf8 <syscall_poll>:
  13bbf8:	e92d4070 	push	{r4, r5, r6, lr}
  13bbfc:	e1a06002 	mov	r6, r2
  13bc00:	e1a04000 	mov	r4, r0
  13bc04:	e1a05001 	mov	r5, r1
  13bc08:	e59f001c 	ldr	r0, [pc, #28]	; 13bc2c <syscall_poll+0x34>
  13bc0c:	e3a0100d 	mov	r1, #13
  13bc10:	ebfffd90 	bl	13b258 <syscall_debug>
  13bc14:	e1a03006 	mov	r3, r6
  13bc18:	e1a02005 	mov	r2, r5
  13bc1c:	e1a01004 	mov	r1, r4
  13bc20:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bc24:	e3a00009 	mov	r0, #9
  13bc28:	ea00028b 	b	13c65c <syscall>
  13bc2c:	0014b73c 	.word	0x0014b73c

0013bc30 <syscall_sched_getscheduler>:
  13bc30:	e92d4070 	push	{r4, r5, r6, lr}
  13bc34:	e1a06002 	mov	r6, r2
  13bc38:	e1a04000 	mov	r4, r0
  13bc3c:	e1a05001 	mov	r5, r1
  13bc40:	e59f001c 	ldr	r0, [pc, #28]	; 13bc64 <syscall_sched_getscheduler+0x34>
  13bc44:	e3a0101b 	mov	r1, #27
  13bc48:	ebfffd82 	bl	13b258 <syscall_debug>
  13bc4c:	e1a03006 	mov	r3, r6
  13bc50:	e1a02005 	mov	r2, r5
  13bc54:	e1a01004 	mov	r1, r4
  13bc58:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bc5c:	e3a00099 	mov	r0, #153	; 0x99
  13bc60:	ea00027d 	b	13c65c <syscall>
  13bc64:	0014b660 	.word	0x0014b660

0013bc68 <syscall_sched_setscheduler>:
  13bc68:	e92d4070 	push	{r4, r5, r6, lr}
  13bc6c:	e1a06002 	mov	r6, r2
  13bc70:	e1a04000 	mov	r4, r0
  13bc74:	e1a05001 	mov	r5, r1
  13bc78:	e59f001c 	ldr	r0, [pc, #28]	; 13bc9c <syscall_sched_setscheduler+0x34>
  13bc7c:	e3a0101b 	mov	r1, #27
  13bc80:	ebfffd74 	bl	13b258 <syscall_debug>
  13bc84:	e1a03006 	mov	r3, r6
  13bc88:	e1a02005 	mov	r2, r5
  13bc8c:	e1a01004 	mov	r1, r4
  13bc90:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bc94:	e3a00098 	mov	r0, #152	; 0x98
  13bc98:	ea00026f 	b	13c65c <syscall>
  13bc9c:	0014b644 	.word	0x0014b644

0013bca0 <syscall_writev>:
  13bca0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  13bca4:	e1a06002 	mov	r6, r2
  13bca8:	e1a08000 	mov	r8, r0
  13bcac:	e1a04001 	mov	r4, r1
  13bcb0:	e59f0088 	ldr	r0, [pc, #136]	; 13bd40 <syscall_writev+0xa0>
  13bcb4:	e3a0100f 	mov	r1, #15
  13bcb8:	ebfffd66 	bl	13b258 <syscall_debug>
  13bcbc:	e3560000 	cmp	r6, #0
  13bcc0:	e3a07000 	mov	r7, #0
  13bcc4:	da000013 	ble	13bd18 <syscall_writev+0x78>
  13bcc8:	e1a05007 	mov	r5, r7
  13bccc:	ea000003 	b	13bce0 <syscall_writev+0x40>
  13bcd0:	e2855001 	add	r5, r5, #1
  13bcd4:	e1560005 	cmp	r6, r5
  13bcd8:	e2844008 	add	r4, r4, #8
  13bcdc:	0a00000d 	beq	13bd18 <syscall_writev+0x78>
  13bce0:	e5943004 	ldr	r3, [r4, #4]
  13bce4:	e3530000 	cmp	r3, #0
  13bce8:	0afffff8 	beq	13bcd0 <syscall_writev+0x30>
  13bcec:	e5942000 	ldr	r2, [r4]
  13bcf0:	e1a01008 	mov	r1, r8
  13bcf4:	e3a00003 	mov	r0, #3
  13bcf8:	eb000257 	bl	13c65c <syscall>
  13bcfc:	e3500000 	cmp	r0, #0
  13bd00:	da000006 	ble	13bd20 <syscall_writev+0x80>
  13bd04:	e2855001 	add	r5, r5, #1
  13bd08:	e1560005 	cmp	r6, r5
  13bd0c:	e0877000 	add	r7, r7, r0
  13bd10:	e2844008 	add	r4, r4, #8
  13bd14:	1afffff1 	bne	13bce0 <syscall_writev+0x40>
  13bd18:	e1a00007 	mov	r0, r7
  13bd1c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13bd20:	13a03000 	movne	r3, #0
  13bd24:	03a03001 	moveq	r3, #1
  13bd28:	e3570000 	cmp	r7, #0
  13bd2c:	13a03001 	movne	r3, #1
  13bd30:	e3530000 	cmp	r3, #0
  13bd34:	01a07000 	moveq	r7, r0
  13bd38:	e1a00007 	mov	r0, r7
  13bd3c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13bd40:	0014b588 	.word	0x0014b588

0013bd44 <syscall_readv>:
  13bd44:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  13bd48:	e1a06002 	mov	r6, r2
  13bd4c:	e1a08000 	mov	r8, r0
  13bd50:	e1a04001 	mov	r4, r1
  13bd54:	e59f0088 	ldr	r0, [pc, #136]	; 13bde4 <syscall_readv+0xa0>
  13bd58:	e3a0100e 	mov	r1, #14
  13bd5c:	ebfffd3d 	bl	13b258 <syscall_debug>
  13bd60:	e3560000 	cmp	r6, #0
  13bd64:	e3a07000 	mov	r7, #0
  13bd68:	da000013 	ble	13bdbc <syscall_readv+0x78>
  13bd6c:	e1a05007 	mov	r5, r7
  13bd70:	ea000003 	b	13bd84 <syscall_readv+0x40>
  13bd74:	e2855001 	add	r5, r5, #1
  13bd78:	e1560005 	cmp	r6, r5
  13bd7c:	e2844008 	add	r4, r4, #8
  13bd80:	0a00000d 	beq	13bdbc <syscall_readv+0x78>
  13bd84:	e5943004 	ldr	r3, [r4, #4]
  13bd88:	e3530000 	cmp	r3, #0
  13bd8c:	0afffff8 	beq	13bd74 <syscall_readv+0x30>
  13bd90:	e5942000 	ldr	r2, [r4]
  13bd94:	e1a01008 	mov	r1, r8
  13bd98:	e3a00002 	mov	r0, #2
  13bd9c:	eb00022e 	bl	13c65c <syscall>
  13bda0:	e3500000 	cmp	r0, #0
  13bda4:	da000006 	ble	13bdc4 <syscall_readv+0x80>
  13bda8:	e2855001 	add	r5, r5, #1
  13bdac:	e1560005 	cmp	r6, r5
  13bdb0:	e0877000 	add	r7, r7, r0
  13bdb4:	e2844008 	add	r4, r4, #8
  13bdb8:	1afffff1 	bne	13bd84 <syscall_readv+0x40>
  13bdbc:	e1a00007 	mov	r0, r7
  13bdc0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13bdc4:	13a03000 	movne	r3, #0
  13bdc8:	03a03001 	moveq	r3, #1
  13bdcc:	e3570000 	cmp	r7, #0
  13bdd0:	13a03001 	movne	r3, #1
  13bdd4:	e3530000 	cmp	r3, #0
  13bdd8:	01a07000 	moveq	r7, r0
  13bddc:	e1a00007 	mov	r0, r7
  13bde0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13bde4:	0014b578 	.word	0x0014b578

0013bde8 <syscall_getdents>:
  13bde8:	e92d4070 	push	{r4, r5, r6, lr}
  13bdec:	e1a06002 	mov	r6, r2
  13bdf0:	e1a04000 	mov	r4, r0
  13bdf4:	e1a05001 	mov	r5, r1
  13bdf8:	e59f001c 	ldr	r0, [pc, #28]	; 13be1c <syscall_getdents+0x34>
  13bdfc:	e3a01011 	mov	r1, #17
  13be00:	ebfffd14 	bl	13b258 <syscall_debug>
  13be04:	e1a03006 	mov	r3, r6
  13be08:	e1a02005 	mov	r2, r5
  13be0c:	e1a01004 	mov	r1, r4
  13be10:	e8bd4070 	pop	{r4, r5, r6, lr}
  13be14:	e3a00079 	mov	r0, #121	; 0x79
  13be18:	ea00020f 	b	13c65c <syscall>
  13be1c:	0014b530 	.word	0x0014b530

0013be20 <syscall_readlink>:
  13be20:	e92d4070 	push	{r4, r5, r6, lr}
  13be24:	e1a06002 	mov	r6, r2
  13be28:	e1a04000 	mov	r4, r0
  13be2c:	e1a05001 	mov	r5, r1
  13be30:	e59f001c 	ldr	r0, [pc, #28]	; 13be54 <syscall_readlink+0x34>
  13be34:	e3a01011 	mov	r1, #17
  13be38:	ebfffd06 	bl	13b258 <syscall_debug>
  13be3c:	e1a03006 	mov	r3, r6
  13be40:	e1a02005 	mov	r2, r5
  13be44:	e1a01004 	mov	r1, r4
  13be48:	e8bd4070 	pop	{r4, r5, r6, lr}
  13be4c:	e3a00091 	mov	r0, #145	; 0x91
  13be50:	ea000201 	b	13c65c <syscall>
  13be54:	0014b240 	.word	0x0014b240

0013be58 <syscall_fcntl>:
  13be58:	e92d4070 	push	{r4, r5, r6, lr}
  13be5c:	e1a06002 	mov	r6, r2
  13be60:	e1a04000 	mov	r4, r0
  13be64:	e1a05001 	mov	r5, r1
  13be68:	e59f001c 	ldr	r0, [pc, #28]	; 13be8c <syscall_fcntl+0x34>
  13be6c:	e3a0100e 	mov	r1, #14
  13be70:	ebfffcf8 	bl	13b258 <syscall_debug>
  13be74:	e1a03006 	mov	r3, r6
  13be78:	e1a02005 	mov	r2, r5
  13be7c:	e1a01004 	mov	r1, r4
  13be80:	e8bd4070 	pop	{r4, r5, r6, lr}
  13be84:	e3a00007 	mov	r0, #7
  13be88:	ea0001f3 	b	13c65c <syscall>
  13be8c:	0014b0a8 	.word	0x0014b0a8

0013be90 <syscall_execve>:
  13be90:	e92d4070 	push	{r4, r5, r6, lr}
  13be94:	e1a06002 	mov	r6, r2
  13be98:	e1a04000 	mov	r4, r0
  13be9c:	e1a05001 	mov	r5, r1
  13bea0:	e59f001c 	ldr	r0, [pc, #28]	; 13bec4 <syscall_execve+0x34>
  13bea4:	e3a0100f 	mov	r1, #15
  13bea8:	ebfffcea 	bl	13b258 <syscall_debug>
  13beac:	e1a03006 	mov	r3, r6
  13beb0:	e1a02005 	mov	r2, r5
  13beb4:	e1a01004 	mov	r1, r4
  13beb8:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bebc:	e3a00089 	mov	r0, #137	; 0x89
  13bec0:	ea0001e5 	b	13c65c <syscall>
  13bec4:	0014aed0 	.word	0x0014aed0

0013bec8 <syscall_open>:
  13bec8:	e92d4070 	push	{r4, r5, r6, lr}
  13becc:	e1a06002 	mov	r6, r2
  13bed0:	e1a04000 	mov	r4, r0
  13bed4:	e1a05001 	mov	r5, r1
  13bed8:	e59f001c 	ldr	r0, [pc, #28]	; 13befc <syscall_open+0x34>
  13bedc:	e3a0100d 	mov	r1, #13
  13bee0:	ebfffcdc 	bl	13b258 <syscall_debug>
  13bee4:	e1a03006 	mov	r3, r6
  13bee8:	e1a02005 	mov	r2, r5
  13beec:	e1a01004 	mov	r1, r4
  13bef0:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bef4:	e3a00005 	mov	r0, #5
  13bef8:	ea0001d7 	b	13c65c <syscall>
  13befc:	0014ae80 	.word	0x0014ae80

0013bf00 <syscall_write>:
  13bf00:	e92d4070 	push	{r4, r5, r6, lr}
  13bf04:	e1a06002 	mov	r6, r2
  13bf08:	e1a04000 	mov	r4, r0
  13bf0c:	e1a05001 	mov	r5, r1
  13bf10:	e59f001c 	ldr	r0, [pc, #28]	; 13bf34 <syscall_write+0x34>
  13bf14:	e3a0100e 	mov	r1, #14
  13bf18:	ebfffcce 	bl	13b258 <syscall_debug>
  13bf1c:	e1a03006 	mov	r3, r6
  13bf20:	e1a02005 	mov	r2, r5
  13bf24:	e1a01004 	mov	r1, r4
  13bf28:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bf2c:	e3a00003 	mov	r0, #3
  13bf30:	ea0001c9 	b	13c65c <syscall>
  13bf34:	0014ae70 	.word	0x0014ae70

0013bf38 <syscall_read>:
  13bf38:	e92d4070 	push	{r4, r5, r6, lr}
  13bf3c:	e1a06002 	mov	r6, r2
  13bf40:	e1a04000 	mov	r4, r0
  13bf44:	e1a05001 	mov	r5, r1
  13bf48:	e59f001c 	ldr	r0, [pc, #28]	; 13bf6c <syscall_read+0x34>
  13bf4c:	e3a0100d 	mov	r1, #13
  13bf50:	ebfffcc0 	bl	13b258 <syscall_debug>
  13bf54:	e1a03006 	mov	r3, r6
  13bf58:	e1a02005 	mov	r2, r5
  13bf5c:	e1a01004 	mov	r1, r4
  13bf60:	e8bd4070 	pop	{r4, r5, r6, lr}
  13bf64:	e3a00002 	mov	r0, #2
  13bf68:	ea0001bb 	b	13c65c <syscall>
  13bf6c:	0014ae60 	.word	0x0014ae60

0013bf70 <syscall_prlimit64>:
  13bf70:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  13bf74:	e1a06002 	mov	r6, r2
  13bf78:	e1a07003 	mov	r7, r3
  13bf7c:	e1a04000 	mov	r4, r0
  13bf80:	e1a05001 	mov	r5, r1
  13bf84:	e24dd00c 	sub	sp, sp, #12
  13bf88:	e3a01012 	mov	r1, #18
  13bf8c:	e59f0020 	ldr	r0, [pc, #32]	; 13bfb4 <syscall_prlimit64+0x44>
  13bf90:	ebfffcb0 	bl	13b258 <syscall_debug>
  13bf94:	e58d7000 	str	r7, [sp]
  13bf98:	e1a03006 	mov	r3, r6
  13bf9c:	e1a02005 	mov	r2, r5
  13bfa0:	e1a01004 	mov	r1, r4
  13bfa4:	e3a0008c 	mov	r0, #140	; 0x8c
  13bfa8:	eb0001ab 	bl	13c65c <syscall>
  13bfac:	e28dd00c 	add	sp, sp, #12
  13bfb0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  13bfb4:	0014c664 	.word	0x0014c664

0013bfb8 <syscall_recv>:
  13bfb8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  13bfbc:	e1a06002 	mov	r6, r2
  13bfc0:	e1a07003 	mov	r7, r3
  13bfc4:	e1a04000 	mov	r4, r0
  13bfc8:	e1a05001 	mov	r5, r1
  13bfcc:	e24dd00c 	sub	sp, sp, #12
  13bfd0:	e3a0100d 	mov	r1, #13
  13bfd4:	e59f0020 	ldr	r0, [pc, #32]	; 13bffc <syscall_recv+0x44>
  13bfd8:	ebfffc9e 	bl	13b258 <syscall_debug>
  13bfdc:	e58d7000 	str	r7, [sp]
  13bfe0:	e1a03006 	mov	r3, r6
  13bfe4:	e1a02005 	mov	r2, r5
  13bfe8:	e1a01004 	mov	r1, r4
  13bfec:	e3a0004e 	mov	r0, #78	; 0x4e
  13bff0:	eb000199 	bl	13c65c <syscall>
  13bff4:	e28dd00c 	add	sp, sp, #12
  13bff8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  13bffc:	0014c080 	.word	0x0014c080

0013c000 <syscall_send>:
  13c000:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  13c004:	e1a06002 	mov	r6, r2
  13c008:	e1a07003 	mov	r7, r3
  13c00c:	e1a04000 	mov	r4, r0
  13c010:	e1a05001 	mov	r5, r1
  13c014:	e24dd00c 	sub	sp, sp, #12
  13c018:	e3a0100d 	mov	r1, #13
  13c01c:	e59f0020 	ldr	r0, [pc, #32]	; 13c044 <syscall_send+0x44>
  13c020:	ebfffc8c 	bl	13b258 <syscall_debug>
  13c024:	e58d7000 	str	r7, [sp]
  13c028:	e1a03006 	mov	r3, r6
  13c02c:	e1a02005 	mov	r2, r5
  13c030:	e1a01004 	mov	r1, r4
  13c034:	e3a00050 	mov	r0, #80	; 0x50
  13c038:	eb000187 	bl	13c65c <syscall>
  13c03c:	e28dd00c 	add	sp, sp, #12
  13c040:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  13c044:	0014c060 	.word	0x0014c060

0013c048 <syscall_rt_sigprocmask>:
  13c048:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  13c04c:	e1a06002 	mov	r6, r2
  13c050:	e1a07003 	mov	r7, r3
  13c054:	e1a04000 	mov	r4, r0
  13c058:	e1a05001 	mov	r5, r1
  13c05c:	e24dd00c 	sub	sp, sp, #12
  13c060:	e3a01017 	mov	r1, #23
  13c064:	e59f0020 	ldr	r0, [pc, #32]	; 13c08c <syscall_rt_sigprocmask+0x44>
  13c068:	ebfffc7a 	bl	13b258 <syscall_debug>
  13c06c:	e58d7000 	str	r7, [sp]
  13c070:	e1a03006 	mov	r3, r6
  13c074:	e1a02005 	mov	r2, r5
  13c078:	e1a01004 	mov	r1, r4
  13c07c:	e3a00068 	mov	r0, #104	; 0x68
  13c080:	eb000175 	bl	13c65c <syscall>
  13c084:	e28dd00c 	add	sp, sp, #12
  13c088:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  13c08c:	0014b7c8 	.word	0x0014b7c8

0013c090 <syscall_rt_sigaction>:
  13c090:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  13c094:	e1a06002 	mov	r6, r2
  13c098:	e1a07003 	mov	r7, r3
  13c09c:	e1a04000 	mov	r4, r0
  13c0a0:	e1a05001 	mov	r5, r1
  13c0a4:	e24dd00c 	sub	sp, sp, #12
  13c0a8:	e3a01015 	mov	r1, #21
  13c0ac:	e59f0020 	ldr	r0, [pc, #32]	; 13c0d4 <syscall_rt_sigaction+0x44>
  13c0b0:	ebfffc68 	bl	13b258 <syscall_debug>
  13c0b4:	e58d7000 	str	r7, [sp]
  13c0b8:	e1a03006 	mov	r3, r6
  13c0bc:	e1a02005 	mov	r2, r5
  13c0c0:	e1a01004 	mov	r1, r4
  13c0c4:	e3a00067 	mov	r0, #103	; 0x67
  13c0c8:	eb000163 	bl	13c65c <syscall>
  13c0cc:	e28dd00c 	add	sp, sp, #12
  13c0d0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  13c0d4:	0014b7b0 	.word	0x0014b7b0

0013c0d8 <syscall_sigprocmask>:
  13c0d8:	e92d4070 	push	{r4, r5, r6, lr}
  13c0dc:	e1a04000 	mov	r4, r0
  13c0e0:	e24dd008 	sub	sp, sp, #8
  13c0e4:	e1a05001 	mov	r5, r1
  13c0e8:	e59f002c 	ldr	r0, [pc, #44]	; 13c11c <syscall_sigprocmask+0x44>
  13c0ec:	e3a01014 	mov	r1, #20
  13c0f0:	e1a06002 	mov	r6, r2
  13c0f4:	ebfffc57 	bl	13b258 <syscall_debug>
  13c0f8:	e3a00080 	mov	r0, #128	; 0x80
  13c0fc:	e1a03006 	mov	r3, r6
  13c100:	e58d0000 	str	r0, [sp]
  13c104:	e1a02005 	mov	r2, r5
  13c108:	e1a01004 	mov	r1, r4
  13c10c:	e3a00068 	mov	r0, #104	; 0x68
  13c110:	eb000151 	bl	13c65c <syscall>
  13c114:	e28dd008 	add	sp, sp, #8
  13c118:	e8bd8070 	pop	{r4, r5, r6, pc}
  13c11c:	0014b450 	.word	0x0014b450

0013c120 <syscall_sigaction>:
  13c120:	e92d4070 	push	{r4, r5, r6, lr}
  13c124:	e1a04000 	mov	r4, r0
  13c128:	e24dd008 	sub	sp, sp, #8
  13c12c:	e1a05001 	mov	r5, r1
  13c130:	e59f002c 	ldr	r0, [pc, #44]	; 13c164 <syscall_sigaction+0x44>
  13c134:	e3a01012 	mov	r1, #18
  13c138:	e1a06002 	mov	r6, r2
  13c13c:	ebfffc45 	bl	13b258 <syscall_debug>
  13c140:	e3a00080 	mov	r0, #128	; 0x80
  13c144:	e1a03006 	mov	r3, r6
  13c148:	e58d0000 	str	r0, [sp]
  13c14c:	e1a02005 	mov	r2, r5
  13c150:	e1a01004 	mov	r1, r4
  13c154:	e3a00067 	mov	r0, #103	; 0x67
  13c158:	eb00013f 	bl	13c65c <syscall>
  13c15c:	e28dd008 	add	sp, sp, #8
  13c160:	e8bd8070 	pop	{r4, r5, r6, pc}
  13c164:	0014b138 	.word	0x0014b138

0013c168 <syscall_getsockopt>:
  13c168:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  13c16c:	e1a06002 	mov	r6, r2
  13c170:	e1a08003 	mov	r8, r3
  13c174:	e1a04000 	mov	r4, r0
  13c178:	e1a05001 	mov	r5, r1
  13c17c:	e24dd008 	sub	sp, sp, #8
  13c180:	e59d7020 	ldr	r7, [sp, #32]
  13c184:	e3a01013 	mov	r1, #19
  13c188:	e59f0024 	ldr	r0, [pc, #36]	; 13c1b4 <syscall_getsockopt+0x4c>
  13c18c:	ebfffc31 	bl	13b258 <syscall_debug>
  13c190:	e58d8000 	str	r8, [sp]
  13c194:	e58d7004 	str	r7, [sp, #4]
  13c198:	e1a03006 	mov	r3, r6
  13c19c:	e1a02005 	mov	r2, r5
  13c1a0:	e1a01004 	mov	r1, r4
  13c1a4:	e3a0004a 	mov	r0, #74	; 0x4a
  13c1a8:	eb00012b 	bl	13c65c <syscall>
  13c1ac:	e28dd008 	add	sp, sp, #8
  13c1b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13c1b4:	0014c0cc 	.word	0x0014c0cc

0013c1b8 <syscall_setsockopt>:
  13c1b8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  13c1bc:	e1a06002 	mov	r6, r2
  13c1c0:	e1a08003 	mov	r8, r3
  13c1c4:	e1a04000 	mov	r4, r0
  13c1c8:	e1a05001 	mov	r5, r1
  13c1cc:	e24dd008 	sub	sp, sp, #8
  13c1d0:	e59d7020 	ldr	r7, [sp, #32]
  13c1d4:	e3a01013 	mov	r1, #19
  13c1d8:	e59f0024 	ldr	r0, [pc, #36]	; 13c204 <syscall_setsockopt+0x4c>
  13c1dc:	ebfffc1d 	bl	13b258 <syscall_debug>
  13c1e0:	e58d8000 	str	r8, [sp]
  13c1e4:	e58d7004 	str	r7, [sp, #4]
  13c1e8:	e1a03006 	mov	r3, r6
  13c1ec:	e1a02005 	mov	r2, r5
  13c1f0:	e1a01004 	mov	r1, r4
  13c1f4:	e3a0004b 	mov	r0, #75	; 0x4b
  13c1f8:	eb000117 	bl	13c65c <syscall>
  13c1fc:	e28dd008 	add	sp, sp, #8
  13c200:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13c204:	0014c0b8 	.word	0x0014c0b8

0013c208 <syscall_mremap>:
  13c208:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  13c20c:	e1a06002 	mov	r6, r2
  13c210:	e1a08003 	mov	r8, r3
  13c214:	e1a04000 	mov	r4, r0
  13c218:	e1a05001 	mov	r5, r1
  13c21c:	e24dd008 	sub	sp, sp, #8
  13c220:	e59d7020 	ldr	r7, [sp, #32]
  13c224:	e3a0100f 	mov	r1, #15
  13c228:	e59f0024 	ldr	r0, [pc, #36]	; 13c254 <syscall_mremap+0x4c>
  13c22c:	ebfffc09 	bl	13b258 <syscall_debug>
  13c230:	e58d8000 	str	r8, [sp]
  13c234:	e58d7004 	str	r7, [sp, #4]
  13c238:	e1a03006 	mov	r3, r6
  13c23c:	e1a02005 	mov	r2, r5
  13c240:	e1a01004 	mov	r1, r4
  13c244:	e3a00092 	mov	r0, #146	; 0x92
  13c248:	eb000103 	bl	13c65c <syscall>
  13c24c:	e28dd008 	add	sp, sp, #8
  13c250:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13c254:	0014b704 	.word	0x0014b704

0013c258 <syscall__newselect>:
  13c258:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  13c25c:	e1a06002 	mov	r6, r2
  13c260:	e1a08003 	mov	r8, r3
  13c264:	e1a04000 	mov	r4, r0
  13c268:	e1a05001 	mov	r5, r1
  13c26c:	e24dd008 	sub	sp, sp, #8
  13c270:	e59d7020 	ldr	r7, [sp, #32]
  13c274:	e3a01013 	mov	r1, #19
  13c278:	e59f0024 	ldr	r0, [pc, #36]	; 13c2a4 <syscall__newselect+0x4c>
  13c27c:	ebfffbf5 	bl	13b258 <syscall_debug>
  13c280:	e58d8000 	str	r8, [sp]
  13c284:	e58d7004 	str	r7, [sp, #4]
  13c288:	e1a03006 	mov	r3, r6
  13c28c:	e1a02005 	mov	r2, r5
  13c290:	e1a01004 	mov	r1, r4
  13c294:	e3a0005e 	mov	r0, #94	; 0x5e
  13c298:	eb0000ef 	bl	13c65c <syscall>
  13c29c:	e28dd008 	add	sp, sp, #8
  13c2a0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13c2a4:	0014b544 	.word	0x0014b544

0013c2a8 <syscall__llseek>:
  13c2a8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  13c2ac:	e1a06002 	mov	r6, r2
  13c2b0:	e1a05000 	mov	r5, r0
  13c2b4:	e1a08001 	mov	r8, r1
  13c2b8:	e24dd008 	sub	sp, sp, #8
  13c2bc:	e59d7020 	ldr	r7, [sp, #32]
  13c2c0:	e3a01010 	mov	r1, #16
  13c2c4:	e59f0034 	ldr	r0, [pc, #52]	; 13c300 <syscall__llseek+0x58>
  13c2c8:	e1a04003 	mov	r4, r3
  13c2cc:	ebfffbe1 	bl	13b258 <syscall_debug>
  13c2d0:	e1a01005 	mov	r1, r5
  13c2d4:	e58d8000 	str	r8, [sp]
  13c2d8:	e58d7004 	str	r7, [sp, #4]
  13c2dc:	e1a03006 	mov	r3, r6
  13c2e0:	e3a02000 	mov	r2, #0
  13c2e4:	e3a00004 	mov	r0, #4
  13c2e8:	eb0000db 	bl	13c65c <syscall>
  13c2ec:	e1a01fc0 	asr	r1, r0, #31
  13c2f0:	e8840003 	stm	r4, {r0, r1}
  13c2f4:	e1a00fc1 	asr	r0, r1, #31
  13c2f8:	e28dd008 	add	sp, sp, #8
  13c2fc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13c300:	0014b520 	.word	0x0014b520

0013c304 <syscall_recvfrom>:
  13c304:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  13c308:	e1a06002 	mov	r6, r2
  13c30c:	e1a09003 	mov	r9, r3
  13c310:	e1a04000 	mov	r4, r0
  13c314:	e1a05001 	mov	r5, r1
  13c318:	e24dd014 	sub	sp, sp, #20
  13c31c:	e59d7030 	ldr	r7, [sp, #48]	; 0x30
  13c320:	e59d8034 	ldr	r8, [sp, #52]	; 0x34
  13c324:	e3a01011 	mov	r1, #17
  13c328:	e59f0024 	ldr	r0, [pc, #36]	; 13c354 <syscall_recvfrom+0x50>
  13c32c:	ebfffbc9 	bl	13b258 <syscall_debug>
  13c330:	e58d9000 	str	r9, [sp]
  13c334:	e98d0180 	stmib	sp, {r7, r8}
  13c338:	e1a03006 	mov	r3, r6
  13c33c:	e1a02005 	mov	r2, r5
  13c340:	e1a01004 	mov	r1, r4
  13c344:	e3a0004f 	mov	r0, #79	; 0x4f
  13c348:	eb0000c3 	bl	13c65c <syscall>
  13c34c:	e28dd014 	add	sp, sp, #20
  13c350:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  13c354:	0014c090 	.word	0x0014c090

0013c358 <syscall_sendto>:
  13c358:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  13c35c:	e1a06002 	mov	r6, r2
  13c360:	e1a09003 	mov	r9, r3
  13c364:	e1a04000 	mov	r4, r0
  13c368:	e1a05001 	mov	r5, r1
  13c36c:	e24dd014 	sub	sp, sp, #20
  13c370:	e59d7030 	ldr	r7, [sp, #48]	; 0x30
  13c374:	e59d8034 	ldr	r8, [sp, #52]	; 0x34
  13c378:	e3a0100f 	mov	r1, #15
  13c37c:	e59f0024 	ldr	r0, [pc, #36]	; 13c3a8 <syscall_sendto+0x50>
  13c380:	ebfffbb4 	bl	13b258 <syscall_debug>
  13c384:	e58d9000 	str	r9, [sp]
  13c388:	e98d0180 	stmib	sp, {r7, r8}
  13c38c:	e1a03006 	mov	r3, r6
  13c390:	e1a02005 	mov	r2, r5
  13c394:	e1a01004 	mov	r1, r4
  13c398:	e3a00051 	mov	r0, #81	; 0x51
  13c39c:	eb0000ae 	bl	13c65c <syscall>
  13c3a0:	e28dd014 	add	sp, sp, #20
  13c3a4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  13c3a8:	0014c070 	.word	0x0014c070

0013c3ac <syscall_futex>:
  13c3ac:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  13c3b0:	e1a06002 	mov	r6, r2
  13c3b4:	e1a09003 	mov	r9, r3
  13c3b8:	e1a04000 	mov	r4, r0
  13c3bc:	e1a05001 	mov	r5, r1
  13c3c0:	e24dd014 	sub	sp, sp, #20
  13c3c4:	e59d7030 	ldr	r7, [sp, #48]	; 0x30
  13c3c8:	e59d8034 	ldr	r8, [sp, #52]	; 0x34
  13c3cc:	e3a0100e 	mov	r1, #14
  13c3d0:	e59f0024 	ldr	r0, [pc, #36]	; 13c3fc <syscall_futex+0x50>
  13c3d4:	ebfffb9f 	bl	13b258 <syscall_debug>
  13c3d8:	e58d9000 	str	r9, [sp]
  13c3dc:	e98d0180 	stmib	sp, {r7, r8}
  13c3e0:	e1a03006 	mov	r3, r6
  13c3e4:	e1a02005 	mov	r2, r5
  13c3e8:	e1a01004 	mov	r1, r4
  13c3ec:	e3a00083 	mov	r0, #131	; 0x83
  13c3f0:	eb000099 	bl	13c65c <syscall>
  13c3f4:	e28dd014 	add	sp, sp, #20
  13c3f8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  13c3fc:	0014bc68 	.word	0x0014bc68

0013c400 <syscall_mmap2>:
  13c400:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  13c404:	e1a06002 	mov	r6, r2
  13c408:	e1a09003 	mov	r9, r3
  13c40c:	e1a04000 	mov	r4, r0
  13c410:	e1a05001 	mov	r5, r1
  13c414:	e59d7020 	ldr	r7, [sp, #32]
  13c418:	e59d8028 	ldr	r8, [sp, #40]	; 0x28
  13c41c:	e3a0100e 	mov	r1, #14
  13c420:	e59f0024 	ldr	r0, [pc, #36]	; 13c44c <syscall_mmap2+0x4c>
  13c424:	ebfffb8b 	bl	13b258 <syscall_debug>
  13c428:	e58d9020 	str	r9, [sp, #32]
  13c42c:	e58d8028 	str	r8, [sp, #40]	; 0x28
  13c430:	e58d7024 	str	r7, [sp, #36]	; 0x24
  13c434:	e1a03006 	mov	r3, r6
  13c438:	e1a02005 	mov	r2, r5
  13c43c:	e1a01004 	mov	r1, r4
  13c440:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
  13c444:	e3a00035 	mov	r0, #53	; 0x35
  13c448:	ea000083 	b	13c65c <syscall>
  13c44c:	0014b8f0 	.word	0x0014b8f0

0013c450 <syscall_gettid>:
  13c450:	e92d4010 	push	{r4, lr}
  13c454:	e59f0010 	ldr	r0, [pc, #16]	; 13c46c <syscall_gettid+0x1c>
  13c458:	e3a0100f 	mov	r1, #15
  13c45c:	ebfffb7d 	bl	13b258 <syscall_debug>
  13c460:	e8bd4010 	pop	{r4, lr}
  13c464:	e3a0008b 	mov	r0, #139	; 0x8b
  13c468:	ea00007b 	b	13c65c <syscall>
  13c46c:	0014bb28 	.word	0x0014bb28

0013c470 <syscall_vfork>:
  13c470:	e92d4010 	push	{r4, lr}
  13c474:	e59f0010 	ldr	r0, [pc, #16]	; 13c48c <syscall_vfork+0x1c>
  13c478:	e3a0100e 	mov	r1, #14
  13c47c:	ebfffb75 	bl	13b258 <syscall_debug>
  13c480:	e8bd4010 	pop	{r4, lr}
  13c484:	e3a0008a 	mov	r0, #138	; 0x8a
  13c488:	ea000073 	b	13c65c <syscall>
  13c48c:	0014b8cc 	.word	0x0014b8cc

0013c490 <syscall_setsid>:
  13c490:	e92d4010 	push	{r4, lr}
  13c494:	e59f0010 	ldr	r0, [pc, #16]	; 13c4ac <syscall_setsid+0x1c>
  13c498:	e3a0100f 	mov	r1, #15
  13c49c:	ebfffb6d 	bl	13b258 <syscall_debug>
  13c4a0:	e8bd4010 	pop	{r4, lr}
  13c4a4:	e3a0008f 	mov	r0, #143	; 0x8f
  13c4a8:	ea00006b 	b	13c65c <syscall>
  13c4ac:	0014b128 	.word	0x0014b128

0013c4b0 <syscall_getpid>:
  13c4b0:	e92d4010 	push	{r4, lr}
  13c4b4:	e59f0010 	ldr	r0, [pc, #16]	; 13c4cc <syscall_getpid+0x1c>
  13c4b8:	e3a0100f 	mov	r1, #15
  13c4bc:	ebfffb65 	bl	13b258 <syscall_debug>
  13c4c0:	e8bd4010 	pop	{r4, lr}
  13c4c4:	e3a0000f 	mov	r0, #15
  13c4c8:	ea000063 	b	13c65c <syscall>
  13c4cc:	0014af30 	.word	0x0014af30

0013c4d0 <syscall_fork>:
  13c4d0:	e92d4010 	push	{r4, lr}
  13c4d4:	e59f0010 	ldr	r0, [pc, #16]	; 13c4ec <syscall_fork+0x1c>
  13c4d8:	e3a0100d 	mov	r1, #13
  13c4dc:	ebfffb5d 	bl	13b258 <syscall_debug>
  13c4e0:	e8bd4010 	pop	{r4, lr}
  13c4e4:	e3a00088 	mov	r0, #136	; 0x88
  13c4e8:	ea00005b 	b	13c65c <syscall>
  13c4ec:	0014ae50 	.word	0x0014ae50

0013c4f0 <syscall_ioctl>:
  13c4f0:	e92d4070 	push	{r4, r5, r6, lr}
  13c4f4:	e1a04000 	mov	r4, r0
  13c4f8:	e1a05001 	mov	r5, r1
  13c4fc:	e59f0030 	ldr	r0, [pc, #48]	; 13c534 <syscall_ioctl+0x44>
  13c500:	e3a0100e 	mov	r1, #14
  13c504:	e1a06002 	mov	r6, r2
  13c508:	ebfffb52 	bl	13b258 <syscall_debug>
  13c50c:	e3540001 	cmp	r4, #1
  13c510:	0a000005 	beq	13c52c <syscall_ioctl+0x3c>
  13c514:	e1a03006 	mov	r3, r6
  13c518:	e1a02005 	mov	r2, r5
  13c51c:	e1a01004 	mov	r1, r4
  13c520:	e8bd4070 	pop	{r4, r5, r6, lr}
  13c524:	e3a00007 	mov	r0, #7
  13c528:	ea00004b 	b	13c65c <syscall>
  13c52c:	e3a00000 	mov	r0, #0
  13c530:	e8bd8070 	pop	{r4, r5, r6, pc}
  13c534:	0014b098 	.word	0x0014b098

0013c538 <syscall_lseek>:
  13c538:	e92d4070 	push	{r4, r5, r6, lr}
  13c53c:	e1a04001 	mov	r4, r1
  13c540:	e24dd008 	sub	sp, sp, #8
  13c544:	e1a05000 	mov	r5, r0
  13c548:	e3a0100e 	mov	r1, #14
  13c54c:	e59f0058 	ldr	r0, [pc, #88]	; 13c5ac <syscall_lseek+0x74>
  13c550:	e1a06002 	mov	r6, r2
  13c554:	ebfffb3f 	bl	13b258 <syscall_debug>
  13c558:	e3540000 	cmp	r4, #0
  13c55c:	ba000008 	blt	13c584 <syscall_lseek+0x4c>
  13c560:	e3a02000 	mov	r2, #0
  13c564:	e58d6004 	str	r6, [sp, #4]
  13c568:	e1a03004 	mov	r3, r4
  13c56c:	e1a01005 	mov	r1, r5
  13c570:	e58d2000 	str	r2, [sp]
  13c574:	e3a00004 	mov	r0, #4
  13c578:	eb000037 	bl	13c65c <syscall>
  13c57c:	e28dd008 	add	sp, sp, #8
  13c580:	e8bd8070 	pop	{r4, r5, r6, pc}
  13c584:	e3e02000 	mvn	r2, #0
  13c588:	e58d6004 	str	r6, [sp, #4]
  13c58c:	e58d2000 	str	r2, [sp]
  13c590:	e1a03004 	mov	r3, r4
  13c594:	e1a01005 	mov	r1, r5
  13c598:	e3a02000 	mov	r2, #0
  13c59c:	e3a00004 	mov	r0, #4
  13c5a0:	eb00002d 	bl	13c65c <syscall>
  13c5a4:	e28dd008 	add	sp, sp, #8
  13c5a8:	e8bd8070 	pop	{r4, r5, r6, pc}
  13c5ac:	0014af20 	.word	0x0014af20

0013c5b0 <get_rtt_syscall>:
  13c5b0:	e3500e19 	cmp	r0, #400	; 0x190
  13c5b4:	3a000005 	bcc	13c5d0 <get_rtt_syscall+0x20>
  13c5b8:	e59f201c 	ldr	r2, [pc, #28]	; 13c5dc <get_rtt_syscall+0x2c>
  13c5bc:	e59f301c 	ldr	r3, [pc, #28]	; 13c5e0 <get_rtt_syscall+0x30>
  13c5c0:	e1500002 	cmp	r0, r2
  13c5c4:	01a00003 	moveq	r0, r3
  13c5c8:	13a00000 	movne	r0, #0
  13c5cc:	e12fff1e 	bx	lr
  13c5d0:	e59f300c 	ldr	r3, [pc, #12]	; 13c5e4 <get_rtt_syscall+0x34>
  13c5d4:	e7930100 	ldr	r0, [r3, r0, lsl #2]
  13c5d8:	e12fff1e 	bx	lr
  13c5dc:	000f0005 	.word	0x000f0005
  13c5e0:	00139490 	.word	0x00139490
  13c5e4:	0014c908 	.word	0x0014c908

0013c5e8 <___syscall>:
  13c5e8:	e92d4070 	push	{r4, r5, r6, lr}
  13c5ec:	e1a0c001 	mov	ip, r1
  13c5f0:	e3500e19 	cmp	r0, #400	; 0x190
  13c5f4:	e1a01002 	mov	r1, r2
  13c5f8:	e1a02003 	mov	r2, r3
  13c5fc:	e28d3010 	add	r3, sp, #16
  13c600:	e8930078 	ldm	r3, {r3, r4, r5, r6}
  13c604:	2a00000a 	bcs	13c634 <___syscall+0x4c>
  13c608:	e59fe03c 	ldr	lr, [pc, #60]	; 13c64c <___syscall+0x64>
  13c60c:	e79ee100 	ldr	lr, [lr, r0, lsl #2]
  13c610:	e35e0000 	cmp	lr, #0
  13c614:	0a00000a 	beq	13c644 <___syscall+0x5c>
  13c618:	e58d6018 	str	r6, [sp, #24]
  13c61c:	e58d5014 	str	r5, [sp, #20]
  13c620:	e58d4010 	str	r4, [sp, #16]
  13c624:	e1a0000c 	mov	r0, ip
  13c628:	e1a0c00e 	mov	ip, lr
  13c62c:	e8bd4070 	pop	{r4, r5, r6, lr}
  13c630:	e12fff1c 	bx	ip
  13c634:	e59fe014 	ldr	lr, [pc, #20]	; 13c650 <___syscall+0x68>
  13c638:	e150000e 	cmp	r0, lr
  13c63c:	059fe010 	ldreq	lr, [pc, #16]	; 13c654 <___syscall+0x6c>
  13c640:	0afffff4 	beq	13c618 <___syscall+0x30>
  13c644:	e3a00000 	mov	r0, #0
  13c648:	e8bd8070 	pop	{r4, r5, r6, pc}
  13c64c:	0014c908 	.word	0x0014c908
  13c650:	000f0005 	.word	0x000f0005
  13c654:	00139490 	.word	0x00139490

0013c658 <__syscall>:
  13c658:	eaffffe2 	b	13c5e8 <___syscall>

0013c65c <syscall>:
  13c65c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  13c660:	e1a07000 	mov	r7, r0
  13c664:	e1a00001 	mov	r0, r1
  13c668:	e1a01002 	mov	r1, r2
  13c66c:	e1a02003 	mov	r2, r3
  13c670:	e28d6014 	add	r6, sp, #20
  13c674:	e8960038 	ldm	r6, {r3, r4, r5}
  13c678:	ef000000 	svc	0x00000000
  13c67c:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  13c680:	e12fff1e 	bx	lr

0013c684 <__syscall_ret>:
  13c684:	e3700a01 	cmn	r0, #4096	; 0x1000
  13c688:	912fff1e 	bxls	lr
  13c68c:	e92d4010 	push	{r4, lr}
  13c690:	e1a04000 	mov	r4, r0
  13c694:	ebfff28f 	bl	1390d8 <__errno_location>
  13c698:	e2644000 	rsb	r4, r4, #0
  13c69c:	e5804000 	str	r4, [r0]
  13c6a0:	e3e00000 	mvn	r0, #0
  13c6a4:	e8bd8010 	pop	{r4, pc}

0013c6a8 <__lctrans_impl>:
  13c6a8:	e12fff1e 	bx	lr

0013c6ac <__lctrans>:
  13c6ac:	eafffffd 	b	13c6a8 <__lctrans_impl>

0013c6b0 <__lctrans_cur>:
  13c6b0:	e1a02000 	mov	r2, r0
  13c6b4:	e59f301c 	ldr	r3, [pc, #28]	; 13c6d8 <__lctrans_cur+0x28>
  13c6b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13c6bc:	e5930000 	ldr	r0, [r3]
  13c6c0:	e12fff30 	blx	r0
  13c6c4:	e5103018 	ldr	r3, [r0, #-24]	; 0xffffffe8
  13c6c8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  13c6cc:	e1a00002 	mov	r0, r2
  13c6d0:	e5931014 	ldr	r1, [r3, #20]
  13c6d4:	eafffff3 	b	13c6a8 <__lctrans_impl>
  13c6d8:	0014e3dc 	.word	0x0014e3dc

0013c6dc <__simple_malloc>:
  13c6dc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  13c6e0:	e2505000 	subs	r5, r0, #0
  13c6e4:	e24dd008 	sub	sp, sp, #8
  13c6e8:	0a000016 	beq	13c748 <__simple_malloc+0x6c>
  13c6ec:	e3550001 	cmp	r5, #1
  13c6f0:	9a000037 	bls	13c7d4 <__simple_malloc+0xf8>
  13c6f4:	e3a03001 	mov	r3, #1
  13c6f8:	e1a03083 	lsl	r3, r3, #1
  13c6fc:	e1550003 	cmp	r5, r3
  13c700:	83a02001 	movhi	r2, #1
  13c704:	93a02000 	movls	r2, #0
  13c708:	e353000f 	cmp	r3, #15
  13c70c:	83a02000 	movhi	r2, #0
  13c710:	e3520000 	cmp	r2, #0
  13c714:	1afffff7 	bne	13c6f8 <__simple_malloc+0x1c>
  13c718:	e2434001 	sub	r4, r3, #1
  13c71c:	e59f60c8 	ldr	r6, [pc, #200]	; 13c7ec <__simple_malloc+0x110>
  13c720:	e59f00c8 	ldr	r0, [pc, #200]	; 13c7f0 <__simple_malloc+0x114>
  13c724:	eb001587 	bl	141d48 <__lock>
  13c728:	e5962000 	ldr	r2, [r6]
  13c72c:	e355013e 	cmp	r5, #-2147483633	; 0x8000000f
  13c730:	e2623000 	rsb	r3, r2, #0
  13c734:	e0044003 	and	r4, r4, r3
  13c738:	8a000009 	bhi	13c764 <__simple_malloc+0x88>
  13c73c:	e0853004 	add	r3, r5, r4
  13c740:	e1a05004 	mov	r5, r4
  13c744:	ea000004 	b	13c75c <__simple_malloc+0x80>
  13c748:	e59f00a0 	ldr	r0, [pc, #160]	; 13c7f0 <__simple_malloc+0x114>
  13c74c:	eb00157d 	bl	141d48 <__lock>
  13c750:	e3a03001 	mov	r3, #1
  13c754:	e59f6090 	ldr	r6, [pc, #144]	; 13c7ec <__simple_malloc+0x110>
  13c758:	e5962000 	ldr	r2, [r6]
  13c75c:	e1a04005 	mov	r4, r5
  13c760:	e1a05003 	mov	r5, r3
  13c764:	e59f8088 	ldr	r8, [pc, #136]	; 13c7f4 <__simple_malloc+0x118>
  13c768:	e5981000 	ldr	r1, [r8]
  13c76c:	e0411002 	sub	r1, r1, r2
  13c770:	e1510005 	cmp	r1, r5
  13c774:	20827004 	addcs	r7, r2, r4
  13c778:	2a00000e 	bcs	13c7b8 <__simple_malloc+0xdc>
  13c77c:	e28d0008 	add	r0, sp, #8
  13c780:	e5205004 	str	r5, [r0, #-4]!
  13c784:	eb001b35 	bl	143460 <__expand_heap>
  13c788:	e2503000 	subs	r3, r0, #0
  13c78c:	0a000012 	beq	13c7dc <__simple_malloc+0x100>
  13c790:	e5982000 	ldr	r2, [r8]
  13c794:	e59d1004 	ldr	r1, [sp, #4]
  13c798:	e1520003 	cmp	r2, r3
  13c79c:	05962000 	ldreq	r2, [r6]
  13c7a0:	11a07003 	movne	r7, r3
  13c7a4:	11a02003 	movne	r2, r3
  13c7a8:	e0833001 	add	r3, r3, r1
  13c7ac:	00827004 	addeq	r7, r2, r4
  13c7b0:	10455004 	subne	r5, r5, r4
  13c7b4:	e5883000 	str	r3, [r8]
  13c7b8:	e0825005 	add	r5, r2, r5
  13c7bc:	e59f002c 	ldr	r0, [pc, #44]	; 13c7f0 <__simple_malloc+0x114>
  13c7c0:	e5865000 	str	r5, [r6]
  13c7c4:	eb0015b7 	bl	141ea8 <__unlock>
  13c7c8:	e1a00007 	mov	r0, r7
  13c7cc:	e28dd008 	add	sp, sp, #8
  13c7d0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  13c7d4:	e3a04000 	mov	r4, #0
  13c7d8:	eaffffcf 	b	13c71c <__simple_malloc+0x40>
  13c7dc:	e59f000c 	ldr	r0, [pc, #12]	; 13c7f0 <__simple_malloc+0x114>
  13c7e0:	e1a07003 	mov	r7, r3
  13c7e4:	eb0015af 	bl	141ea8 <__unlock>
  13c7e8:	eafffff6 	b	13c7c8 <__simple_malloc+0xec>
  13c7ec:	0014fc18 	.word	0x0014fc18
  13c7f0:	0014fc20 	.word	0x0014fc20
  13c7f4:	0014fc1c 	.word	0x0014fc1c

0013c7f8 <__simple_calloc>:
  13c7f8:	e3510000 	cmp	r1, #0
  13c7fc:	e1a0c000 	mov	ip, r0
  13c800:	0a000002 	beq	13c810 <__simple_calloc+0x18>
  13c804:	e0832190 	umull	r2, r3, r0, r1
  13c808:	e3530000 	cmp	r3, #0
  13c80c:	1a000001 	bne	13c818 <__simple_calloc+0x20>
  13c810:	e0000c91 	mul	r0, r1, ip
  13c814:	eaffffb0 	b	13c6dc <__simple_malloc>
  13c818:	e92d4010 	push	{r4, lr}
  13c81c:	ebfff22d 	bl	1390d8 <__errno_location>
  13c820:	e3a0300c 	mov	r3, #12
  13c824:	e5803000 	str	r3, [r0]
  13c828:	e3a00000 	mov	r0, #0
  13c82c:	e8bd8010 	pop	{r4, pc}

0013c830 <adjust_size>:
  13c830:	e5903000 	ldr	r3, [r0]
  13c834:	e59f2058 	ldr	r2, [pc, #88]	; 13c894 <adjust_size+0x64>
  13c838:	e2431001 	sub	r1, r3, #1
  13c83c:	e1510002 	cmp	r1, r2
  13c840:	9a000006 	bls	13c860 <adjust_size+0x30>
  13c844:	e3530000 	cmp	r3, #0
  13c848:	03a01010 	moveq	r1, #16
  13c84c:	01a02003 	moveq	r2, r3
  13c850:	05801000 	streq	r1, [r0]
  13c854:	1a000007 	bne	13c878 <adjust_size+0x48>
  13c858:	e1a00002 	mov	r0, r2
  13c85c:	e12fff1e 	bx	lr
  13c860:	e3a02000 	mov	r2, #0
  13c864:	e2833017 	add	r3, r3, #23
  13c868:	e3c3300f 	bic	r3, r3, #15
  13c86c:	e5803000 	str	r3, [r0]
  13c870:	e1a00002 	mov	r0, r2
  13c874:	e12fff1e 	bx	lr
  13c878:	e92d4010 	push	{r4, lr}
  13c87c:	ebfff215 	bl	1390d8 <__errno_location>
  13c880:	e3a0300c 	mov	r3, #12
  13c884:	e3e02000 	mvn	r2, #0
  13c888:	e5803000 	str	r3, [r0]
  13c88c:	e1a00002 	mov	r0, r2
  13c890:	e8bd8010 	pop	{r4, pc}
  13c894:	7fffefef 	.word	0x7fffefef

0013c898 <unbin>:
  13c898:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  13c89c:	e590200c 	ldr	r2, [r0, #12]
  13c8a0:	e1a07000 	mov	r7, r0
  13c8a4:	e5900008 	ldr	r0, [r0, #8]
  13c8a8:	e24dd00c 	sub	sp, sp, #12
  13c8ac:	e1520000 	cmp	r2, r0
  13c8b0:	0a00000b 	beq	13c8e4 <unbin+0x4c>
  13c8b4:	e5973004 	ldr	r3, [r7, #4]
  13c8b8:	e5820008 	str	r0, [r2, #8]
  13c8bc:	e3c30001 	bic	r0, r3, #1
  13c8c0:	e7971000 	ldr	r1, [r7, r0]
  13c8c4:	e597c008 	ldr	ip, [r7, #8]
  13c8c8:	e3833001 	orr	r3, r3, #1
  13c8cc:	e3811001 	orr	r1, r1, #1
  13c8d0:	e58c200c 	str	r2, [ip, #12]
  13c8d4:	e5873004 	str	r3, [r7, #4]
  13c8d8:	e7871000 	str	r1, [r7, r0]
  13c8dc:	e28dd00c 	add	sp, sp, #12
  13c8e0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13c8e4:	e3a00001 	mov	r0, #1
  13c8e8:	e241c020 	sub	ip, r1, #32
  13c8ec:	e1a0a110 	lsl	sl, r0, r1
  13c8f0:	e1a0bc10 	lsl	fp, r0, ip
  13c8f4:	e261c020 	rsb	ip, r1, #32
  13c8f8:	e1e0100a 	mvn	r1, sl
  13c8fc:	e18bbc30 	orr	fp, fp, r0, lsr ip
  13c900:	e3710001 	cmn	r1, #1
  13c904:	e1e0200b 	mvn	r2, fp
  13c908:	0a000014 	beq	13c960 <unbin+0xc8>
  13c90c:	e59f40a4 	ldr	r4, [pc, #164]	; 13c9b8 <unbin+0x120>
  13c910:	e1a0b007 	mov	fp, r7
  13c914:	e1a09004 	mov	r9, r4
  13c918:	e1a07001 	mov	r7, r1
  13c91c:	e88d0006 	stm	sp, {r1, r2}
  13c920:	e59f6094 	ldr	r6, [pc, #148]	; 13c9bc <unbin+0x124>
  13c924:	e5945000 	ldr	r5, [r4]
  13c928:	e0078005 	and	r8, r7, r5
  13c92c:	ea000002 	b	13c93c <unbin+0xa4>
  13c930:	e5943000 	ldr	r3, [r4]
  13c934:	e1550003 	cmp	r5, r3
  13c938:	1afffff9 	bne	13c924 <unbin+0x8c>
  13c93c:	e1a00005 	mov	r0, r5
  13c940:	e1a01008 	mov	r1, r8
  13c944:	e1a02009 	mov	r2, r9
  13c948:	e5963000 	ldr	r3, [r6]
  13c94c:	e12fff33 	blx	r3
  13c950:	e3500000 	cmp	r0, #0
  13c954:	1afffff5 	bne	13c930 <unbin+0x98>
  13c958:	e1a0700b 	mov	r7, fp
  13c95c:	e89d0006 	ldm	sp, {r1, r2}
  13c960:	e3720001 	cmn	r2, #1
  13c964:	0a000010 	beq	13c9ac <unbin+0x114>
  13c968:	e1a0a002 	mov	sl, r2
  13c96c:	e59f4044 	ldr	r4, [pc, #68]	; 13c9b8 <unbin+0x120>
  13c970:	e59f6044 	ldr	r6, [pc, #68]	; 13c9bc <unbin+0x124>
  13c974:	e2849004 	add	r9, r4, #4
  13c978:	e5945004 	ldr	r5, [r4, #4]
  13c97c:	e00a8005 	and	r8, sl, r5
  13c980:	ea000002 	b	13c990 <unbin+0xf8>
  13c984:	e5943004 	ldr	r3, [r4, #4]
  13c988:	e1550003 	cmp	r5, r3
  13c98c:	1afffff9 	bne	13c978 <unbin+0xe0>
  13c990:	e1a00005 	mov	r0, r5
  13c994:	e1a01008 	mov	r1, r8
  13c998:	e1a02009 	mov	r2, r9
  13c99c:	e5963000 	ldr	r3, [r6]
  13c9a0:	e12fff33 	blx	r3
  13c9a4:	e3500000 	cmp	r0, #0
  13c9a8:	1afffff5 	bne	13c984 <unbin+0xec>
  13c9ac:	e597200c 	ldr	r2, [r7, #12]
  13c9b0:	e5970008 	ldr	r0, [r7, #8]
  13c9b4:	eaffffbe 	b	13c8b4 <unbin+0x1c>
  13c9b8:	0014fc30 	.word	0x0014fc30
  13c9bc:	0014e3d8 	.word	0x0014e3d8

0013c9c0 <alloc_fwd>:
  13c9c0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  13c9c4:	e59f925c 	ldr	r9, [pc, #604]	; 13cc28 <alloc_fwd+0x268>
  13c9c8:	e24dd00c 	sub	sp, sp, #12
  13c9cc:	e58d0004 	str	r0, [sp, #4]
  13c9d0:	e59f6254 	ldr	r6, [pc, #596]	; 13cc2c <alloc_fwd+0x26c>
  13c9d4:	e59d3004 	ldr	r3, [sp, #4]
  13c9d8:	e5938004 	ldr	r8, [r3, #4]
  13c9dc:	e3180001 	tst	r8, #1
  13c9e0:	1a000055 	bne	13cb3c <alloc_fwd+0x17c>
  13c9e4:	e1a07228 	lsr	r7, r8, #4
  13c9e8:	e2477001 	sub	r7, r7, #1
  13c9ec:	e3570020 	cmp	r7, #32
  13c9f0:	9a000005 	bls	13ca0c <alloc_fwd+0x4c>
  13c9f4:	e59f3234 	ldr	r3, [pc, #564]	; 13cc30 <alloc_fwd+0x270>
  13c9f8:	e1570003 	cmp	r7, r3
  13c9fc:	8a000058 	bhi	13cb64 <alloc_fwd+0x1a4>
  13ca00:	e59f322c 	ldr	r3, [pc, #556]	; 13cc34 <alloc_fwd+0x274>
  13ca04:	e08371a7 	add	r7, r3, r7, lsr #3
  13ca08:	e5577004 	ldrb	r7, [r7, #-4]
  13ca0c:	e1a0b007 	mov	fp, r7
  13ca10:	e1a04207 	lsl	r4, r7, #4
  13ca14:	e2844008 	add	r4, r4, #8
  13ca18:	e59f3218 	ldr	r3, [pc, #536]	; 13cc38 <alloc_fwd+0x278>
  13ca1c:	e0894004 	add	r4, r9, r4
  13ca20:	e593300c 	ldr	r3, [r3, #12]
  13ca24:	e3530000 	cmp	r3, #0
  13ca28:	1284a004 	addne	sl, r4, #4
  13ca2c:	1a000032 	bne	13cafc <alloc_fwd+0x13c>
  13ca30:	e28b3001 	add	r3, fp, #1
  13ca34:	e7992203 	ldr	r2, [r9, r3, lsl #4]
  13ca38:	e3520000 	cmp	r2, #0
  13ca3c:	1a000053 	bne	13cb90 <alloc_fwd+0x1d0>
  13ca40:	e1a02008 	mov	r2, r8
  13ca44:	e0891207 	add	r1, r9, r7, lsl #4
  13ca48:	e2811008 	add	r1, r1, #8
  13ca4c:	e0890203 	add	r0, r9, r3, lsl #4
  13ca50:	e7891203 	str	r1, [r9, r3, lsl #4]
  13ca54:	e5801004 	str	r1, [r0, #4]
  13ca58:	e1580002 	cmp	r8, r2
  13ca5c:	0a00004b 	beq	13cb90 <alloc_fwd+0x1d0>
  13ca60:	e5943000 	ldr	r3, [r4]
  13ca64:	e3530000 	cmp	r3, #0
  13ca68:	0a000030 	beq	13cb30 <alloc_fwd+0x170>
  13ca6c:	e59f31c8 	ldr	r3, [pc, #456]	; 13cc3c <alloc_fwd+0x27c>
  13ca70:	e593c000 	ldr	ip, [r3]
  13ca74:	e12fff3c 	blx	ip
  13ca78:	e3a02000 	mov	r2, #0
  13ca7c:	e593c000 	ldr	ip, [r3]
  13ca80:	e5842000 	str	r2, [r4]
  13ca84:	e12fff3c 	blx	ip
  13ca88:	e5943004 	ldr	r3, [r4, #4]
  13ca8c:	e1530002 	cmp	r3, r2
  13ca90:	0affffcf 	beq	13c9d4 <alloc_fwd+0x14>
  13ca94:	e3a000f0 	mov	r0, #240	; 0xf0
  13ca98:	ebfffec4 	bl	13c5b0 <get_rtt_syscall>
  13ca9c:	e2503000 	subs	r3, r0, #0
  13caa0:	0affffca 	beq	13c9d0 <alloc_fwd+0x10>
  13caa4:	e3a02001 	mov	r2, #1
  13caa8:	e3a01081 	mov	r1, #129	; 0x81
  13caac:	e1a00004 	mov	r0, r4
  13cab0:	e12fff33 	blx	r3
  13cab4:	e3700026 	cmn	r0, #38	; 0x26
  13cab8:	1affffc4 	bne	13c9d0 <alloc_fwd+0x10>
  13cabc:	e3a000f0 	mov	r0, #240	; 0xf0
  13cac0:	ebfffeba 	bl	13c5b0 <get_rtt_syscall>
  13cac4:	e2503000 	subs	r3, r0, #0
  13cac8:	0affffc0 	beq	13c9d0 <alloc_fwd+0x10>
  13cacc:	e3a02001 	mov	r2, #1
  13cad0:	e1a00004 	mov	r0, r4
  13cad4:	e1a01002 	mov	r1, r2
  13cad8:	e12fff33 	blx	r3
  13cadc:	eaffffbb 	b	13c9d0 <alloc_fwd+0x10>
  13cae0:	e3550000 	cmp	r5, #0
  13cae4:	0a000017 	beq	13cb48 <alloc_fwd+0x188>
  13cae8:	e1a03001 	mov	r3, r1
  13caec:	e1a02001 	mov	r2, r1
  13caf0:	e1a00004 	mov	r0, r4
  13caf4:	e1a0100a 	mov	r1, sl
  13caf8:	eb001515 	bl	141f54 <__wait>
  13cafc:	e5945000 	ldr	r5, [r4]
  13cb00:	ea000002 	b	13cb10 <alloc_fwd+0x150>
  13cb04:	e5943000 	ldr	r3, [r4]
  13cb08:	e1550003 	cmp	r5, r3
  13cb0c:	1afffffa 	bne	13cafc <alloc_fwd+0x13c>
  13cb10:	e1a00005 	mov	r0, r5
  13cb14:	e3a01001 	mov	r1, #1
  13cb18:	e1a02004 	mov	r2, r4
  13cb1c:	e5963000 	ldr	r3, [r6]
  13cb20:	e12fff33 	blx	r3
  13cb24:	e3500000 	cmp	r0, #0
  13cb28:	1afffff5 	bne	13cb04 <alloc_fwd+0x144>
  13cb2c:	eaffffeb 	b	13cae0 <alloc_fwd+0x120>
  13cb30:	e1a08002 	mov	r8, r2
  13cb34:	e3180001 	tst	r8, #1
  13cb38:	0affffa9 	beq	13c9e4 <alloc_fwd+0x24>
  13cb3c:	e3a00000 	mov	r0, #0
  13cb40:	e28dd00c 	add	sp, sp, #12
  13cb44:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13cb48:	e28b3001 	add	r3, fp, #1
  13cb4c:	e7991203 	ldr	r1, [r9, r3, lsl #4]
  13cb50:	e59d2004 	ldr	r2, [sp, #4]
  13cb54:	e3510000 	cmp	r1, #0
  13cb58:	e5922004 	ldr	r2, [r2, #4]
  13cb5c:	1affffbd 	bne	13ca58 <alloc_fwd+0x98>
  13cb60:	eaffffb7 	b	13ca44 <alloc_fwd+0x84>
  13cb64:	e3570b07 	cmp	r7, #7168	; 0x1c00
  13cb68:	83a0703f 	movhi	r7, #63	; 0x3f
  13cb6c:	959f30c0 	ldrls	r3, [pc, #192]	; 13cc34 <alloc_fwd+0x274>
  13cb70:	83a04ffe 	movhi	r4, #1016	; 0x3f8
  13cb74:	908373a7 	addls	r7, r3, r7, lsr #7
  13cb78:	95577004 	ldrbls	r7, [r7, #-4]
  13cb7c:	92877010 	addls	r7, r7, #16
  13cb80:	91a04207 	lslls	r4, r7, #4
  13cb84:	92844008 	addls	r4, r4, #8
  13cb88:	e1a0b007 	mov	fp, r7
  13cb8c:	eaffffa1 	b	13ca18 <alloc_fwd+0x58>
  13cb90:	e1a0100b 	mov	r1, fp
  13cb94:	e59d0004 	ldr	r0, [sp, #4]
  13cb98:	ebffff3e 	bl	13c898 <unbin>
  13cb9c:	e5943000 	ldr	r3, [r4]
  13cba0:	e3530000 	cmp	r3, #0
  13cba4:	0a000009 	beq	13cbd0 <alloc_fwd+0x210>
  13cba8:	e59f308c 	ldr	r3, [pc, #140]	; 13cc3c <alloc_fwd+0x27c>
  13cbac:	e593c000 	ldr	ip, [r3]
  13cbb0:	e12fff3c 	blx	ip
  13cbb4:	e3a02000 	mov	r2, #0
  13cbb8:	e593c000 	ldr	ip, [r3]
  13cbbc:	e5842000 	str	r2, [r4]
  13cbc0:	e12fff3c 	blx	ip
  13cbc4:	e5943004 	ldr	r3, [r4, #4]
  13cbc8:	e1530002 	cmp	r3, r2
  13cbcc:	1a000002 	bne	13cbdc <alloc_fwd+0x21c>
  13cbd0:	e3a00001 	mov	r0, #1
  13cbd4:	e28dd00c 	add	sp, sp, #12
  13cbd8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13cbdc:	e3a000f0 	mov	r0, #240	; 0xf0
  13cbe0:	ebfffe72 	bl	13c5b0 <get_rtt_syscall>
  13cbe4:	e2503000 	subs	r3, r0, #0
  13cbe8:	0afffff8 	beq	13cbd0 <alloc_fwd+0x210>
  13cbec:	e3a02001 	mov	r2, #1
  13cbf0:	e3a01081 	mov	r1, #129	; 0x81
  13cbf4:	e1a00004 	mov	r0, r4
  13cbf8:	e12fff33 	blx	r3
  13cbfc:	e3700026 	cmn	r0, #38	; 0x26
  13cc00:	1afffff2 	bne	13cbd0 <alloc_fwd+0x210>
  13cc04:	e3a000f0 	mov	r0, #240	; 0xf0
  13cc08:	ebfffe68 	bl	13c5b0 <get_rtt_syscall>
  13cc0c:	e2503000 	subs	r3, r0, #0
  13cc10:	0affffee 	beq	13cbd0 <alloc_fwd+0x210>
  13cc14:	e3a02001 	mov	r2, #1
  13cc18:	e1a00004 	mov	r0, r4
  13cc1c:	e1a01002 	mov	r1, r2
  13cc20:	e12fff33 	blx	r3
  13cc24:	eaffffe9 	b	13cbd0 <alloc_fwd+0x210>
  13cc28:	0014fc30 	.word	0x0014fc30
  13cc2c:	0014e3d8 	.word	0x0014e3d8
  13cc30:	000001ff 	.word	0x000001ff
  13cc34:	0014cf68 	.word	0x0014cf68
  13cc38:	00576e84 	.word	0x00576e84
  13cc3c:	0014e3d4 	.word	0x0014e3d4

0013cc40 <alloc_rev>:
  13cc40:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  13cc44:	e59f9264 	ldr	r9, [pc, #612]	; 13ceb0 <alloc_rev+0x270>
  13cc48:	e24dd00c 	sub	sp, sp, #12
  13cc4c:	e58d0004 	str	r0, [sp, #4]
  13cc50:	e59f625c 	ldr	r6, [pc, #604]	; 13ceb4 <alloc_rev+0x274>
  13cc54:	e59d3004 	ldr	r3, [sp, #4]
  13cc58:	e5938000 	ldr	r8, [r3]
  13cc5c:	e3180001 	tst	r8, #1
  13cc60:	1a000055 	bne	13cdbc <alloc_rev+0x17c>
  13cc64:	e1a07228 	lsr	r7, r8, #4
  13cc68:	e2477001 	sub	r7, r7, #1
  13cc6c:	e3570020 	cmp	r7, #32
  13cc70:	9a000005 	bls	13cc8c <alloc_rev+0x4c>
  13cc74:	e59f323c 	ldr	r3, [pc, #572]	; 13ceb8 <alloc_rev+0x278>
  13cc78:	e1570003 	cmp	r7, r3
  13cc7c:	8a000058 	bhi	13cde4 <alloc_rev+0x1a4>
  13cc80:	e59f3234 	ldr	r3, [pc, #564]	; 13cebc <alloc_rev+0x27c>
  13cc84:	e08371a7 	add	r7, r3, r7, lsr #3
  13cc88:	e5577004 	ldrb	r7, [r7, #-4]
  13cc8c:	e1a0b007 	mov	fp, r7
  13cc90:	e1a04207 	lsl	r4, r7, #4
  13cc94:	e2844008 	add	r4, r4, #8
  13cc98:	e59f3220 	ldr	r3, [pc, #544]	; 13cec0 <alloc_rev+0x280>
  13cc9c:	e0894004 	add	r4, r9, r4
  13cca0:	e593300c 	ldr	r3, [r3, #12]
  13cca4:	e3530000 	cmp	r3, #0
  13cca8:	1284a004 	addne	sl, r4, #4
  13ccac:	1a000032 	bne	13cd7c <alloc_rev+0x13c>
  13ccb0:	e28b3001 	add	r3, fp, #1
  13ccb4:	e7992203 	ldr	r2, [r9, r3, lsl #4]
  13ccb8:	e3520000 	cmp	r2, #0
  13ccbc:	1a000053 	bne	13ce10 <alloc_rev+0x1d0>
  13ccc0:	e1a02008 	mov	r2, r8
  13ccc4:	e0891207 	add	r1, r9, r7, lsl #4
  13ccc8:	e2811008 	add	r1, r1, #8
  13cccc:	e0890203 	add	r0, r9, r3, lsl #4
  13ccd0:	e7891203 	str	r1, [r9, r3, lsl #4]
  13ccd4:	e5801004 	str	r1, [r0, #4]
  13ccd8:	e1580002 	cmp	r8, r2
  13ccdc:	0a00004b 	beq	13ce10 <alloc_rev+0x1d0>
  13cce0:	e5943000 	ldr	r3, [r4]
  13cce4:	e3530000 	cmp	r3, #0
  13cce8:	0a000030 	beq	13cdb0 <alloc_rev+0x170>
  13ccec:	e59f31d0 	ldr	r3, [pc, #464]	; 13cec4 <alloc_rev+0x284>
  13ccf0:	e593c000 	ldr	ip, [r3]
  13ccf4:	e12fff3c 	blx	ip
  13ccf8:	e3a02000 	mov	r2, #0
  13ccfc:	e593c000 	ldr	ip, [r3]
  13cd00:	e5842000 	str	r2, [r4]
  13cd04:	e12fff3c 	blx	ip
  13cd08:	e5943004 	ldr	r3, [r4, #4]
  13cd0c:	e1530002 	cmp	r3, r2
  13cd10:	0affffcf 	beq	13cc54 <alloc_rev+0x14>
  13cd14:	e3a000f0 	mov	r0, #240	; 0xf0
  13cd18:	ebfffe24 	bl	13c5b0 <get_rtt_syscall>
  13cd1c:	e2503000 	subs	r3, r0, #0
  13cd20:	0affffca 	beq	13cc50 <alloc_rev+0x10>
  13cd24:	e3a02001 	mov	r2, #1
  13cd28:	e3a01081 	mov	r1, #129	; 0x81
  13cd2c:	e1a00004 	mov	r0, r4
  13cd30:	e12fff33 	blx	r3
  13cd34:	e3700026 	cmn	r0, #38	; 0x26
  13cd38:	1affffc4 	bne	13cc50 <alloc_rev+0x10>
  13cd3c:	e3a000f0 	mov	r0, #240	; 0xf0
  13cd40:	ebfffe1a 	bl	13c5b0 <get_rtt_syscall>
  13cd44:	e2503000 	subs	r3, r0, #0
  13cd48:	0affffc0 	beq	13cc50 <alloc_rev+0x10>
  13cd4c:	e3a02001 	mov	r2, #1
  13cd50:	e1a00004 	mov	r0, r4
  13cd54:	e1a01002 	mov	r1, r2
  13cd58:	e12fff33 	blx	r3
  13cd5c:	eaffffbb 	b	13cc50 <alloc_rev+0x10>
  13cd60:	e3550000 	cmp	r5, #0
  13cd64:	0a000017 	beq	13cdc8 <alloc_rev+0x188>
  13cd68:	e1a03001 	mov	r3, r1
  13cd6c:	e1a02001 	mov	r2, r1
  13cd70:	e1a00004 	mov	r0, r4
  13cd74:	e1a0100a 	mov	r1, sl
  13cd78:	eb001475 	bl	141f54 <__wait>
  13cd7c:	e5945000 	ldr	r5, [r4]
  13cd80:	ea000002 	b	13cd90 <alloc_rev+0x150>
  13cd84:	e5943000 	ldr	r3, [r4]
  13cd88:	e1550003 	cmp	r5, r3
  13cd8c:	1afffffa 	bne	13cd7c <alloc_rev+0x13c>
  13cd90:	e1a00005 	mov	r0, r5
  13cd94:	e3a01001 	mov	r1, #1
  13cd98:	e1a02004 	mov	r2, r4
  13cd9c:	e5963000 	ldr	r3, [r6]
  13cda0:	e12fff33 	blx	r3
  13cda4:	e3500000 	cmp	r0, #0
  13cda8:	1afffff5 	bne	13cd84 <alloc_rev+0x144>
  13cdac:	eaffffeb 	b	13cd60 <alloc_rev+0x120>
  13cdb0:	e1a08002 	mov	r8, r2
  13cdb4:	e3180001 	tst	r8, #1
  13cdb8:	0affffa9 	beq	13cc64 <alloc_rev+0x24>
  13cdbc:	e3a00000 	mov	r0, #0
  13cdc0:	e28dd00c 	add	sp, sp, #12
  13cdc4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13cdc8:	e28b3001 	add	r3, fp, #1
  13cdcc:	e7991203 	ldr	r1, [r9, r3, lsl #4]
  13cdd0:	e59d2004 	ldr	r2, [sp, #4]
  13cdd4:	e3510000 	cmp	r1, #0
  13cdd8:	e5922000 	ldr	r2, [r2]
  13cddc:	1affffbd 	bne	13ccd8 <alloc_rev+0x98>
  13cde0:	eaffffb7 	b	13ccc4 <alloc_rev+0x84>
  13cde4:	e3570b07 	cmp	r7, #7168	; 0x1c00
  13cde8:	83a0703f 	movhi	r7, #63	; 0x3f
  13cdec:	959f30c8 	ldrls	r3, [pc, #200]	; 13cebc <alloc_rev+0x27c>
  13cdf0:	83a04ffe 	movhi	r4, #1016	; 0x3f8
  13cdf4:	908373a7 	addls	r7, r3, r7, lsr #7
  13cdf8:	95577004 	ldrbls	r7, [r7, #-4]
  13cdfc:	92877010 	addls	r7, r7, #16
  13ce00:	91a04207 	lslls	r4, r7, #4
  13ce04:	92844008 	addls	r4, r4, #8
  13ce08:	e1a0b007 	mov	fp, r7
  13ce0c:	eaffffa1 	b	13cc98 <alloc_rev+0x58>
  13ce10:	e59d3004 	ldr	r3, [sp, #4]
  13ce14:	e3c80001 	bic	r0, r8, #1
  13ce18:	e0430000 	sub	r0, r3, r0
  13ce1c:	e1a0100b 	mov	r1, fp
  13ce20:	ebfffe9c 	bl	13c898 <unbin>
  13ce24:	e5943000 	ldr	r3, [r4]
  13ce28:	e3530000 	cmp	r3, #0
  13ce2c:	0a000009 	beq	13ce58 <alloc_rev+0x218>
  13ce30:	e59f308c 	ldr	r3, [pc, #140]	; 13cec4 <alloc_rev+0x284>
  13ce34:	e593c000 	ldr	ip, [r3]
  13ce38:	e12fff3c 	blx	ip
  13ce3c:	e3a02000 	mov	r2, #0
  13ce40:	e593c000 	ldr	ip, [r3]
  13ce44:	e5842000 	str	r2, [r4]
  13ce48:	e12fff3c 	blx	ip
  13ce4c:	e5943004 	ldr	r3, [r4, #4]
  13ce50:	e1530002 	cmp	r3, r2
  13ce54:	1a000002 	bne	13ce64 <alloc_rev+0x224>
  13ce58:	e3a00001 	mov	r0, #1
  13ce5c:	e28dd00c 	add	sp, sp, #12
  13ce60:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13ce64:	e3a000f0 	mov	r0, #240	; 0xf0
  13ce68:	ebfffdd0 	bl	13c5b0 <get_rtt_syscall>
  13ce6c:	e2503000 	subs	r3, r0, #0
  13ce70:	0afffff8 	beq	13ce58 <alloc_rev+0x218>
  13ce74:	e3a02001 	mov	r2, #1
  13ce78:	e3a01081 	mov	r1, #129	; 0x81
  13ce7c:	e1a00004 	mov	r0, r4
  13ce80:	e12fff33 	blx	r3
  13ce84:	e3700026 	cmn	r0, #38	; 0x26
  13ce88:	1afffff2 	bne	13ce58 <alloc_rev+0x218>
  13ce8c:	e3a000f0 	mov	r0, #240	; 0xf0
  13ce90:	ebfffdc6 	bl	13c5b0 <get_rtt_syscall>
  13ce94:	e2503000 	subs	r3, r0, #0
  13ce98:	0affffee 	beq	13ce58 <alloc_rev+0x218>
  13ce9c:	e3a02001 	mov	r2, #1
  13cea0:	e1a00004 	mov	r0, r4
  13cea4:	e1a01002 	mov	r1, r2
  13cea8:	e12fff33 	blx	r3
  13ceac:	eaffffe9 	b	13ce58 <alloc_rev+0x218>
  13ceb0:	0014fc30 	.word	0x0014fc30
  13ceb4:	0014e3d8 	.word	0x0014e3d8
  13ceb8:	000001ff 	.word	0x000001ff
  13cebc:	0014cf68 	.word	0x0014cf68
  13cec0:	00576e84 	.word	0x00576e84
  13cec4:	0014e3d4 	.word	0x0014e3d4

0013cec8 <__bin_chunk>:
  13cec8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  13cecc:	e5903004 	ldr	r3, [r0, #4]
  13ced0:	e24dd01c 	sub	sp, sp, #28
  13ced4:	e3c31001 	bic	r1, r3, #1
  13ced8:	e7902001 	ldr	r2, [r0, r1]
  13cedc:	e1a06000 	mov	r6, r0
  13cee0:	e1530002 	cmp	r3, r2
  13cee4:	e58d1010 	str	r1, [sp, #16]
  13cee8:	e080b001 	add	fp, r0, r1
  13ceec:	0a000000 	beq	13cef4 <__bin_chunk+0x2c>
  13cef0:	e7f000f0 	.word	0xe7f000f0
  13cef4:	e59d3010 	ldr	r3, [sp, #16]
  13cef8:	e59f55e8 	ldr	r5, [pc, #1512]	; 13d4e8 <__bin_chunk+0x620>
  13cefc:	e58d3000 	str	r3, [sp]
  13cf00:	e3a03000 	mov	r3, #0
  13cf04:	e58d3014 	str	r3, [sp, #20]
  13cf08:	e2853b01 	add	r3, r5, #1024	; 0x400
  13cf0c:	e283300c 	add	r3, r3, #12
  13cf10:	e59f95d4 	ldr	r9, [pc, #1492]	; 13d4ec <__bin_chunk+0x624>
  13cf14:	e58d300c 	str	r3, [sp, #12]
  13cf18:	e5963000 	ldr	r3, [r6]
  13cf1c:	e59b2004 	ldr	r2, [fp, #4]
  13cf20:	e0033002 	and	r3, r3, r2
  13cf24:	e3130001 	tst	r3, #1
  13cf28:	0a000038 	beq	13d010 <__bin_chunk+0x148>
  13cf2c:	e59d1000 	ldr	r1, [sp]
  13cf30:	e1a03221 	lsr	r3, r1, #4
  13cf34:	e2432001 	sub	r2, r3, #1
  13cf38:	e3520020 	cmp	r2, #32
  13cf3c:	e3813001 	orr	r3, r1, #1
  13cf40:	e5863004 	str	r3, [r6, #4]
  13cf44:	e58d2008 	str	r2, [sp, #8]
  13cf48:	e58b3000 	str	r3, [fp]
  13cf4c:	8a00006c 	bhi	13d104 <__bin_chunk+0x23c>
  13cf50:	e1a04202 	lsl	r4, r2, #4
  13cf54:	e2844008 	add	r4, r4, #8
  13cf58:	e58d2004 	str	r2, [sp, #4]
  13cf5c:	e59f358c 	ldr	r3, [pc, #1420]	; 13d4f0 <__bin_chunk+0x628>
  13cf60:	e0854004 	add	r4, r5, r4
  13cf64:	e593300c 	ldr	r3, [r3, #12]
  13cf68:	e3530000 	cmp	r3, #0
  13cf6c:	12848004 	addne	r8, r4, #4
  13cf70:	1a000056 	bne	13d0d0 <__bin_chunk+0x208>
  13cf74:	e59d3004 	ldr	r3, [sp, #4]
  13cf78:	e2837001 	add	r7, r3, #1
  13cf7c:	e7953207 	ldr	r3, [r5, r7, lsl #4]
  13cf80:	e3530000 	cmp	r3, #0
  13cf84:	0a000069 	beq	13d130 <__bin_chunk+0x268>
  13cf88:	e59f3560 	ldr	r3, [pc, #1376]	; 13d4f0 <__bin_chunk+0x628>
  13cf8c:	e593300c 	ldr	r3, [r3, #12]
  13cf90:	e3530000 	cmp	r3, #0
  13cf94:	1a00006f 	bne	13d158 <__bin_chunk+0x290>
  13cf98:	e5963000 	ldr	r3, [r6]
  13cf9c:	e59b2004 	ldr	r2, [fp, #4]
  13cfa0:	e0033002 	and	r3, r3, r2
  13cfa4:	e2133001 	ands	r3, r3, #1
  13cfa8:	1a0000b5 	bne	13d284 <__bin_chunk+0x3bc>
  13cfac:	e5952408 	ldr	r2, [r5, #1032]	; 0x408
  13cfb0:	e3520000 	cmp	r2, #0
  13cfb4:	0a000008 	beq	13cfdc <__bin_chunk+0x114>
  13cfb8:	e59f2534 	ldr	r2, [pc, #1332]	; 13d4f4 <__bin_chunk+0x62c>
  13cfbc:	e592c000 	ldr	ip, [r2]
  13cfc0:	e12fff3c 	blx	ip
  13cfc4:	e5853408 	str	r3, [r5, #1032]	; 0x408
  13cfc8:	e592c000 	ldr	ip, [r2]
  13cfcc:	e12fff3c 	blx	ip
  13cfd0:	e595340c 	ldr	r3, [r5, #1036]	; 0x40c
  13cfd4:	e3530000 	cmp	r3, #0
  13cfd8:	1a000095 	bne	13d234 <__bin_chunk+0x36c>
  13cfdc:	e5943000 	ldr	r3, [r4]
  13cfe0:	e3530000 	cmp	r3, #0
  13cfe4:	0a000009 	beq	13d010 <__bin_chunk+0x148>
  13cfe8:	e59f2504 	ldr	r2, [pc, #1284]	; 13d4f4 <__bin_chunk+0x62c>
  13cfec:	e592c000 	ldr	ip, [r2]
  13cff0:	e12fff3c 	blx	ip
  13cff4:	e3a03000 	mov	r3, #0
  13cff8:	e592c000 	ldr	ip, [r2]
  13cffc:	e5843000 	str	r3, [r4]
  13d000:	e12fff3c 	blx	ip
  13d004:	e5943004 	ldr	r3, [r4, #4]
  13d008:	e3530000 	cmp	r3, #0
  13d00c:	1a000075 	bne	13d1e8 <__bin_chunk+0x320>
  13d010:	e1a00006 	mov	r0, r6
  13d014:	ebffff09 	bl	13cc40 <alloc_rev>
  13d018:	e3500000 	cmp	r0, #0
  13d01c:	0a000010 	beq	13d064 <__bin_chunk+0x19c>
  13d020:	e5963000 	ldr	r3, [r6]
  13d024:	e59d2010 	ldr	r2, [sp, #16]
  13d028:	e3c33001 	bic	r3, r3, #1
  13d02c:	e0466003 	sub	r6, r6, r3
  13d030:	e5963004 	ldr	r3, [r6, #4]
  13d034:	e59d1000 	ldr	r1, [sp]
  13d038:	e3c33001 	bic	r3, r3, #1
  13d03c:	e0822003 	add	r2, r2, r3
  13d040:	e0811003 	add	r1, r1, r3
  13d044:	e352090a 	cmp	r2, #163840	; 0x28000
  13d048:	e58d1000 	str	r1, [sp]
  13d04c:	9a000004 	bls	13d064 <__bin_chunk+0x19c>
  13d050:	e0222003 	eor	r2, r2, r3
  13d054:	e1520003 	cmp	r2, r3
  13d058:	e59d1014 	ldr	r1, [sp, #20]
  13d05c:	83a01001 	movhi	r1, #1
  13d060:	e58d1014 	str	r1, [sp, #20]
  13d064:	e1a0000b 	mov	r0, fp
  13d068:	ebfffe54 	bl	13c9c0 <alloc_fwd>
  13d06c:	e3500000 	cmp	r0, #0
  13d070:	0affffa8 	beq	13cf18 <__bin_chunk+0x50>
  13d074:	e59b3004 	ldr	r3, [fp, #4]
  13d078:	e59d2010 	ldr	r2, [sp, #16]
  13d07c:	e3c33001 	bic	r3, r3, #1
  13d080:	e59d1000 	ldr	r1, [sp]
  13d084:	e0822003 	add	r2, r2, r3
  13d088:	e0811003 	add	r1, r1, r3
  13d08c:	e352090a 	cmp	r2, #163840	; 0x28000
  13d090:	e58d1000 	str	r1, [sp]
  13d094:	9a000004 	bls	13d0ac <__bin_chunk+0x1e4>
  13d098:	e0222003 	eor	r2, r2, r3
  13d09c:	e1520003 	cmp	r2, r3
  13d0a0:	e59d1014 	ldr	r1, [sp, #20]
  13d0a4:	83a01001 	movhi	r1, #1
  13d0a8:	e58d1014 	str	r1, [sp, #20]
  13d0ac:	e08bb003 	add	fp, fp, r3
  13d0b0:	eaffff98 	b	13cf18 <__bin_chunk+0x50>
  13d0b4:	e3570000 	cmp	r7, #0
  13d0b8:	0affffad 	beq	13cf74 <__bin_chunk+0xac>
  13d0bc:	e1a03001 	mov	r3, r1
  13d0c0:	e1a02001 	mov	r2, r1
  13d0c4:	e1a00004 	mov	r0, r4
  13d0c8:	e1a01008 	mov	r1, r8
  13d0cc:	eb0013a0 	bl	141f54 <__wait>
  13d0d0:	e5947000 	ldr	r7, [r4]
  13d0d4:	ea000002 	b	13d0e4 <__bin_chunk+0x21c>
  13d0d8:	e5943000 	ldr	r3, [r4]
  13d0dc:	e1570003 	cmp	r7, r3
  13d0e0:	1afffffa 	bne	13d0d0 <__bin_chunk+0x208>
  13d0e4:	e1a00007 	mov	r0, r7
  13d0e8:	e3a01001 	mov	r1, #1
  13d0ec:	e1a02004 	mov	r2, r4
  13d0f0:	e5993000 	ldr	r3, [r9]
  13d0f4:	e12fff33 	blx	r3
  13d0f8:	e3500000 	cmp	r0, #0
  13d0fc:	1afffff5 	bne	13d0d8 <__bin_chunk+0x210>
  13d100:	eaffffeb 	b	13d0b4 <__bin_chunk+0x1ec>
  13d104:	e59d3008 	ldr	r3, [sp, #8]
  13d108:	e3530c02 	cmp	r3, #512	; 0x200
  13d10c:	2a000027 	bcs	13d1b0 <__bin_chunk+0x2e8>
  13d110:	e59f23e0 	ldr	r2, [pc, #992]	; 13d4f8 <__bin_chunk+0x630>
  13d114:	e08231a3 	add	r3, r2, r3, lsr #3
  13d118:	e5533004 	ldrb	r3, [r3, #-4]
  13d11c:	e1a04203 	lsl	r4, r3, #4
  13d120:	e58d3008 	str	r3, [sp, #8]
  13d124:	e2844008 	add	r4, r4, #8
  13d128:	e58d3004 	str	r3, [sp, #4]
  13d12c:	eaffff8a 	b	13cf5c <__bin_chunk+0x94>
  13d130:	e59d3008 	ldr	r3, [sp, #8]
  13d134:	e0852207 	add	r2, r5, r7, lsl #4
  13d138:	e0853203 	add	r3, r5, r3, lsl #4
  13d13c:	e2833008 	add	r3, r3, #8
  13d140:	e7853207 	str	r3, [r5, r7, lsl #4]
  13d144:	e5823004 	str	r3, [r2, #4]
  13d148:	e59f33a0 	ldr	r3, [pc, #928]	; 13d4f0 <__bin_chunk+0x628>
  13d14c:	e593300c 	ldr	r3, [r3, #12]
  13d150:	e3530000 	cmp	r3, #0
  13d154:	0affff8f 	beq	13cf98 <__bin_chunk+0xd0>
  13d158:	e59f339c 	ldr	r3, [pc, #924]	; 13d4fc <__bin_chunk+0x634>
  13d15c:	e283a008 	add	sl, r3, #8
  13d160:	e5958408 	ldr	r8, [r5, #1032]	; 0x408
  13d164:	ea000002 	b	13d174 <__bin_chunk+0x2ac>
  13d168:	e5953408 	ldr	r3, [r5, #1032]	; 0x408
  13d16c:	e1580003 	cmp	r8, r3
  13d170:	1afffffa 	bne	13d160 <__bin_chunk+0x298>
  13d174:	e1a00008 	mov	r0, r8
  13d178:	e3a01001 	mov	r1, #1
  13d17c:	e1a0200a 	mov	r2, sl
  13d180:	e5993000 	ldr	r3, [r9]
  13d184:	e12fff33 	blx	r3
  13d188:	e3500000 	cmp	r0, #0
  13d18c:	1afffff5 	bne	13d168 <__bin_chunk+0x2a0>
  13d190:	e3580000 	cmp	r8, #0
  13d194:	0affff7f 	beq	13cf98 <__bin_chunk+0xd0>
  13d198:	e1a03001 	mov	r3, r1
  13d19c:	e1a02001 	mov	r2, r1
  13d1a0:	e1a0000a 	mov	r0, sl
  13d1a4:	e59d100c 	ldr	r1, [sp, #12]
  13d1a8:	eb001369 	bl	141f54 <__wait>
  13d1ac:	eaffffeb 	b	13d160 <__bin_chunk+0x298>
  13d1b0:	e59d3008 	ldr	r3, [sp, #8]
  13d1b4:	e3530b07 	cmp	r3, #7168	; 0x1c00
  13d1b8:	83a0303f 	movhi	r3, #63	; 0x3f
  13d1bc:	959f2334 	ldrls	r2, [pc, #820]	; 13d4f8 <__bin_chunk+0x630>
  13d1c0:	858d3008 	strhi	r3, [sp, #8]
  13d1c4:	908233a3 	addls	r3, r2, r3, lsr #7
  13d1c8:	95533004 	ldrbls	r3, [r3, #-4]
  13d1cc:	83a04ffe 	movhi	r4, #1016	; 0x3f8
  13d1d0:	92833010 	addls	r3, r3, #16
  13d1d4:	91a04203 	lslls	r4, r3, #4
  13d1d8:	958d3008 	strls	r3, [sp, #8]
  13d1dc:	92844008 	addls	r4, r4, #8
  13d1e0:	e58d3004 	str	r3, [sp, #4]
  13d1e4:	eaffff5c 	b	13cf5c <__bin_chunk+0x94>
  13d1e8:	e3a000f0 	mov	r0, #240	; 0xf0
  13d1ec:	ebfffcef 	bl	13c5b0 <get_rtt_syscall>
  13d1f0:	e2503000 	subs	r3, r0, #0
  13d1f4:	0affff85 	beq	13d010 <__bin_chunk+0x148>
  13d1f8:	e3a02001 	mov	r2, #1
  13d1fc:	e3a01081 	mov	r1, #129	; 0x81
  13d200:	e1a00004 	mov	r0, r4
  13d204:	e12fff33 	blx	r3
  13d208:	e3700026 	cmn	r0, #38	; 0x26
  13d20c:	1affff7f 	bne	13d010 <__bin_chunk+0x148>
  13d210:	e3a000f0 	mov	r0, #240	; 0xf0
  13d214:	ebfffce5 	bl	13c5b0 <get_rtt_syscall>
  13d218:	e2503000 	subs	r3, r0, #0
  13d21c:	0affff7b 	beq	13d010 <__bin_chunk+0x148>
  13d220:	e3a02001 	mov	r2, #1
  13d224:	e1a00004 	mov	r0, r4
  13d228:	e1a01002 	mov	r1, r2
  13d22c:	e12fff33 	blx	r3
  13d230:	eaffff76 	b	13d010 <__bin_chunk+0x148>
  13d234:	e3a000f0 	mov	r0, #240	; 0xf0
  13d238:	ebfffcdc 	bl	13c5b0 <get_rtt_syscall>
  13d23c:	e2503000 	subs	r3, r0, #0
  13d240:	e59f72b8 	ldr	r7, [pc, #696]	; 13d500 <__bin_chunk+0x638>
  13d244:	0affff64 	beq	13cfdc <__bin_chunk+0x114>
  13d248:	e3a02001 	mov	r2, #1
  13d24c:	e3a01081 	mov	r1, #129	; 0x81
  13d250:	e1a00007 	mov	r0, r7
  13d254:	e12fff33 	blx	r3
  13d258:	e3700026 	cmn	r0, #38	; 0x26
  13d25c:	1affff5e 	bne	13cfdc <__bin_chunk+0x114>
  13d260:	e3a000f0 	mov	r0, #240	; 0xf0
  13d264:	ebfffcd1 	bl	13c5b0 <get_rtt_syscall>
  13d268:	e2503000 	subs	r3, r0, #0
  13d26c:	0affff5a 	beq	13cfdc <__bin_chunk+0x114>
  13d270:	e3a02001 	mov	r2, #1
  13d274:	e1a00007 	mov	r0, r7
  13d278:	e1a01002 	mov	r1, r2
  13d27c:	e12fff33 	blx	r3
  13d280:	eaffff55 	b	13cfdc <__bin_chunk+0x114>
  13d284:	e59d3004 	ldr	r3, [sp, #4]
  13d288:	e8950006 	ldm	r5, {r1, r2}
  13d28c:	e263c020 	rsb	ip, r3, #32
  13d290:	e1a08331 	lsr	r8, r1, r3
  13d294:	e2430020 	sub	r0, r3, #32
  13d298:	e3a03000 	mov	r3, #0
  13d29c:	e1888c12 	orr	r8, r8, r2, lsl ip
  13d2a0:	e1888032 	orr	r8, r8, r2, lsr r0
  13d2a4:	e2082001 	and	r2, r8, #1
  13d2a8:	e1923003 	orrs	r3, r2, r3
  13d2ac:	0a00005d 	beq	13d428 <__bin_chunk+0x560>
  13d2b0:	e59d3000 	ldr	r3, [sp]
  13d2b4:	e5863004 	str	r3, [r6, #4]
  13d2b8:	e58b3000 	str	r3, [fp]
  13d2bc:	e5953408 	ldr	r3, [r5, #1032]	; 0x408
  13d2c0:	e3530000 	cmp	r3, #0
  13d2c4:	0a000009 	beq	13d2f0 <__bin_chunk+0x428>
  13d2c8:	e59f3224 	ldr	r3, [pc, #548]	; 13d4f4 <__bin_chunk+0x62c>
  13d2cc:	e593c000 	ldr	ip, [r3]
  13d2d0:	e12fff3c 	blx	ip
  13d2d4:	e3a02000 	mov	r2, #0
  13d2d8:	e593c000 	ldr	ip, [r3]
  13d2dc:	e5852408 	str	r2, [r5, #1032]	; 0x408
  13d2e0:	e12fff3c 	blx	ip
  13d2e4:	e595340c 	ldr	r3, [r5, #1036]	; 0x40c
  13d2e8:	e1530002 	cmp	r3, r2
  13d2ec:	1a000039 	bne	13d3d8 <__bin_chunk+0x510>
  13d2f0:	e59d3008 	ldr	r3, [sp, #8]
  13d2f4:	e0857207 	add	r7, r5, r7, lsl #4
  13d2f8:	e2833001 	add	r3, r3, #1
  13d2fc:	e5972004 	ldr	r2, [r7, #4]
  13d300:	e0855203 	add	r5, r5, r3, lsl #4
  13d304:	e2453008 	sub	r3, r5, #8
  13d308:	e586200c 	str	r2, [r6, #12]
  13d30c:	e5863008 	str	r3, [r6, #8]
  13d310:	e59d2014 	ldr	r2, [sp, #20]
  13d314:	e5856004 	str	r6, [r5, #4]
  13d318:	e596300c 	ldr	r3, [r6, #12]
  13d31c:	e3520000 	cmp	r2, #0
  13d320:	e5836008 	str	r6, [r3, #8]
  13d324:	0a000008 	beq	13d34c <__bin_chunk+0x484>
  13d328:	e59f31d4 	ldr	r3, [pc, #468]	; 13d504 <__bin_chunk+0x63c>
  13d32c:	e2866a01 	add	r6, r6, #4096	; 0x1000
  13d330:	e286600f 	add	r6, r6, #15
  13d334:	e24b1010 	sub	r1, fp, #16
  13d338:	e0060003 	and	r0, r6, r3
  13d33c:	e0011003 	and	r1, r1, r3
  13d340:	e0411000 	sub	r1, r1, r0
  13d344:	e3a02004 	mov	r2, #4
  13d348:	eb0002ca 	bl	13de78 <__madvise>
  13d34c:	e5943000 	ldr	r3, [r4]
  13d350:	e3530000 	cmp	r3, #0
  13d354:	0a000009 	beq	13d380 <__bin_chunk+0x4b8>
  13d358:	e59f3194 	ldr	r3, [pc, #404]	; 13d4f4 <__bin_chunk+0x62c>
  13d35c:	e593c000 	ldr	ip, [r3]
  13d360:	e12fff3c 	blx	ip
  13d364:	e3a02000 	mov	r2, #0
  13d368:	e593c000 	ldr	ip, [r3]
  13d36c:	e5842000 	str	r2, [r4]
  13d370:	e12fff3c 	blx	ip
  13d374:	e5943004 	ldr	r3, [r4, #4]
  13d378:	e1530002 	cmp	r3, r2
  13d37c:	1a000001 	bne	13d388 <__bin_chunk+0x4c0>
  13d380:	e28dd01c 	add	sp, sp, #28
  13d384:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13d388:	e3a000f0 	mov	r0, #240	; 0xf0
  13d38c:	ebfffc87 	bl	13c5b0 <get_rtt_syscall>
  13d390:	e2503000 	subs	r3, r0, #0
  13d394:	0afffff9 	beq	13d380 <__bin_chunk+0x4b8>
  13d398:	e3a02001 	mov	r2, #1
  13d39c:	e3a01081 	mov	r1, #129	; 0x81
  13d3a0:	e1a00004 	mov	r0, r4
  13d3a4:	e12fff33 	blx	r3
  13d3a8:	e3700026 	cmn	r0, #38	; 0x26
  13d3ac:	1afffff3 	bne	13d380 <__bin_chunk+0x4b8>
  13d3b0:	e3a000f0 	mov	r0, #240	; 0xf0
  13d3b4:	ebfffc7d 	bl	13c5b0 <get_rtt_syscall>
  13d3b8:	e2503000 	subs	r3, r0, #0
  13d3bc:	0affffef 	beq	13d380 <__bin_chunk+0x4b8>
  13d3c0:	e3a02001 	mov	r2, #1
  13d3c4:	e1a00004 	mov	r0, r4
  13d3c8:	e1a01002 	mov	r1, r2
  13d3cc:	e28dd01c 	add	sp, sp, #28
  13d3d0:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  13d3d4:	e12fff13 	bx	r3
  13d3d8:	e3a000f0 	mov	r0, #240	; 0xf0
  13d3dc:	ebfffc73 	bl	13c5b0 <get_rtt_syscall>
  13d3e0:	e2503000 	subs	r3, r0, #0
  13d3e4:	e59f8114 	ldr	r8, [pc, #276]	; 13d500 <__bin_chunk+0x638>
  13d3e8:	0affffc0 	beq	13d2f0 <__bin_chunk+0x428>
  13d3ec:	e3a02001 	mov	r2, #1
  13d3f0:	e3a01081 	mov	r1, #129	; 0x81
  13d3f4:	e1a00008 	mov	r0, r8
  13d3f8:	e12fff33 	blx	r3
  13d3fc:	e3700026 	cmn	r0, #38	; 0x26
  13d400:	1affffba 	bne	13d2f0 <__bin_chunk+0x428>
  13d404:	e3a000f0 	mov	r0, #240	; 0xf0
  13d408:	ebfffc68 	bl	13c5b0 <get_rtt_syscall>
  13d40c:	e2503000 	subs	r3, r0, #0
  13d410:	0affffb6 	beq	13d2f0 <__bin_chunk+0x428>
  13d414:	e3a02001 	mov	r2, #1
  13d418:	e1a00008 	mov	r0, r8
  13d41c:	e1a01002 	mov	r1, r2
  13d420:	e12fff33 	blx	r3
  13d424:	eaffffb1 	b	13d2f0 <__bin_chunk+0x428>
  13d428:	e3a03001 	mov	r3, #1
  13d42c:	e59d1004 	ldr	r1, [sp, #4]
  13d430:	e1a02013 	lsl	r2, r3, r0
  13d434:	e1b01113 	lsls	r1, r3, r1
  13d438:	e1823c33 	orr	r3, r2, r3, lsr ip
  13d43c:	e58d100c 	str	r1, [sp, #12]
  13d440:	e58d3004 	str	r3, [sp, #4]
  13d444:	0a000011 	beq	13d490 <__bin_chunk+0x5c8>
  13d448:	e59f809c 	ldr	r8, [pc, #156]	; 13d4ec <__bin_chunk+0x624>
  13d44c:	e59fa094 	ldr	sl, [pc, #148]	; 13d4e8 <__bin_chunk+0x620>
  13d450:	e58db010 	str	fp, [sp, #16]
  13d454:	e5959000 	ldr	r9, [r5]
  13d458:	e59d300c 	ldr	r3, [sp, #12]
  13d45c:	e183b009 	orr	fp, r3, r9
  13d460:	ea000002 	b	13d470 <__bin_chunk+0x5a8>
  13d464:	e5953000 	ldr	r3, [r5]
  13d468:	e1590003 	cmp	r9, r3
  13d46c:	1afffff8 	bne	13d454 <__bin_chunk+0x58c>
  13d470:	e1a00009 	mov	r0, r9
  13d474:	e1a0100b 	mov	r1, fp
  13d478:	e1a0200a 	mov	r2, sl
  13d47c:	e5983000 	ldr	r3, [r8]
  13d480:	e12fff33 	blx	r3
  13d484:	e3500000 	cmp	r0, #0
  13d488:	1afffff5 	bne	13d464 <__bin_chunk+0x59c>
  13d48c:	e59db010 	ldr	fp, [sp, #16]
  13d490:	e59d3004 	ldr	r3, [sp, #4]
  13d494:	e3530000 	cmp	r3, #0
  13d498:	0affff84 	beq	13d2b0 <__bin_chunk+0x3e8>
  13d49c:	e59f8048 	ldr	r8, [pc, #72]	; 13d4ec <__bin_chunk+0x624>
  13d4a0:	e59fa060 	ldr	sl, [pc, #96]	; 13d508 <__bin_chunk+0x640>
  13d4a4:	e58db00c 	str	fp, [sp, #12]
  13d4a8:	e5959004 	ldr	r9, [r5, #4]
  13d4ac:	e59d3004 	ldr	r3, [sp, #4]
  13d4b0:	e183b009 	orr	fp, r3, r9
  13d4b4:	ea000002 	b	13d4c4 <__bin_chunk+0x5fc>
  13d4b8:	e5953004 	ldr	r3, [r5, #4]
  13d4bc:	e1590003 	cmp	r9, r3
  13d4c0:	1afffff8 	bne	13d4a8 <__bin_chunk+0x5e0>
  13d4c4:	e1a00009 	mov	r0, r9
  13d4c8:	e1a0100b 	mov	r1, fp
  13d4cc:	e1a0200a 	mov	r2, sl
  13d4d0:	e5983000 	ldr	r3, [r8]
  13d4d4:	e12fff33 	blx	r3
  13d4d8:	e3500000 	cmp	r0, #0
  13d4dc:	1afffff5 	bne	13d4b8 <__bin_chunk+0x5f0>
  13d4e0:	e59db00c 	ldr	fp, [sp, #12]
  13d4e4:	eaffff71 	b	13d2b0 <__bin_chunk+0x3e8>
  13d4e8:	0014fc30 	.word	0x0014fc30
  13d4ec:	0014e3d8 	.word	0x0014e3d8
  13d4f0:	00576e84 	.word	0x00576e84
  13d4f4:	0014e3d4 	.word	0x0014e3d4
  13d4f8:	0014cf68 	.word	0x0014cf68
  13d4fc:	00150030 	.word	0x00150030
  13d500:	00150038 	.word	0x00150038
  13d504:	fffff000 	.word	0xfffff000
  13d508:	0014fc34 	.word	0x0014fc34

0013d50c <trim>:
  13d50c:	e5903004 	ldr	r3, [r0, #4]
  13d510:	e1a02000 	mov	r2, r0
  13d514:	e3c33001 	bic	r3, r3, #1
  13d518:	e2430010 	sub	r0, r3, #16
  13d51c:	e1500001 	cmp	r0, r1
  13d520:	912fff1e 	bxls	lr
  13d524:	e043c001 	sub	ip, r3, r1
  13d528:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13d52c:	e38cc001 	orr	ip, ip, #1
  13d530:	e381e001 	orr	lr, r1, #1
  13d534:	e0820001 	add	r0, r2, r1
  13d538:	e782e001 	str	lr, [r2, r1]
  13d53c:	e580c004 	str	ip, [r0, #4]
  13d540:	e782c003 	str	ip, [r2, r3]
  13d544:	e582e004 	str	lr, [r2, #4]
  13d548:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  13d54c:	eafffe5d 	b	13cec8 <__bin_chunk>

0013d550 <malloc>:
  13d550:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  13d554:	e24dd02c 	sub	sp, sp, #44	; 0x2c
  13d558:	e28d3028 	add	r3, sp, #40	; 0x28
  13d55c:	e523000c 	str	r0, [r3, #-12]!
  13d560:	e1a00003 	mov	r0, r3
  13d564:	ebfffcb1 	bl	13c830 <adjust_size>
  13d568:	e3500000 	cmp	r0, #0
  13d56c:	ba000145 	blt	13da88 <malloc+0x538>
  13d570:	e59d301c 	ldr	r3, [sp, #28]
  13d574:	e3530907 	cmp	r3, #114688	; 0x1c000
  13d578:	8a000076 	bhi	13d758 <malloc+0x208>
  13d57c:	e1a03223 	lsr	r3, r3, #4
  13d580:	e2432001 	sub	r2, r3, #1
  13d584:	e3520020 	cmp	r2, #32
  13d588:	958d2018 	strls	r2, [sp, #24]
  13d58c:	8a000066 	bhi	13d72c <malloc+0x1dc>
  13d590:	e3a01001 	mov	r1, #1
  13d594:	e59dc018 	ldr	ip, [sp, #24]
  13d598:	e59f85a8 	ldr	r8, [pc, #1448]	; 13db48 <malloc+0x5f8>
  13d59c:	e24c0020 	sub	r0, ip, #32
  13d5a0:	e1a03011 	lsl	r3, r1, r0
  13d5a4:	e1a02c11 	lsl	r2, r1, ip
  13d5a8:	e26c0020 	rsb	r0, ip, #32
  13d5ac:	e2722000 	rsbs	r2, r2, #0
  13d5b0:	e1833031 	orr	r3, r3, r1, lsr r0
  13d5b4:	e2e33000 	rsc	r3, r3, #0
  13d5b8:	e58d2010 	str	r2, [sp, #16]
  13d5bc:	e58d3014 	str	r3, [sp, #20]
  13d5c0:	e59fb584 	ldr	fp, [pc, #1412]	; 13db4c <malloc+0x5fc>
  13d5c4:	e59f6584 	ldr	r6, [pc, #1412]	; 13db50 <malloc+0x600>
  13d5c8:	e898000c 	ldm	r8, {r2, r3}
  13d5cc:	e28d1010 	add	r1, sp, #16
  13d5d0:	e8910003 	ldm	r1, {r0, r1}
  13d5d4:	e0011003 	and	r1, r1, r3
  13d5d8:	e0000002 	and	r0, r0, r2
  13d5dc:	e1a02000 	mov	r2, r0
  13d5e0:	e1a03001 	mov	r3, r1
  13d5e4:	e1921003 	orrs	r1, r2, r3
  13d5e8:	0a000073 	beq	13d7bc <malloc+0x26c>
  13d5ec:	e3500000 	cmp	r0, #0
  13d5f0:	1a000048 	bne	13d718 <malloc+0x1c8>
  13d5f4:	e2637000 	rsb	r7, r3, #0
  13d5f8:	e0077003 	and	r7, r7, r3
  13d5fc:	e16f7f17 	clz	r7, r7
  13d600:	e267703f 	rsb	r7, r7, #63	; 0x3f
  13d604:	e59b300c 	ldr	r3, [fp, #12]
  13d608:	e1a09207 	lsl	r9, r7, #4
  13d60c:	e2899008 	add	r9, r9, #8
  13d610:	e3530000 	cmp	r3, #0
  13d614:	e0885009 	add	r5, r8, r9
  13d618:	1285a004 	addne	sl, r5, #4
  13d61c:	1a000030 	bne	13d6e4 <malloc+0x194>
  13d620:	e2873001 	add	r3, r7, #1
  13d624:	e7984203 	ldr	r4, [r8, r3, lsl #4]
  13d628:	e0882009 	add	r2, r8, r9
  13d62c:	e3540000 	cmp	r4, #0
  13d630:	00881203 	addeq	r1, r8, r3, lsl #4
  13d634:	07882203 	streq	r2, [r8, r3, lsl #4]
  13d638:	05812004 	streq	r2, [r1, #4]
  13d63c:	0a000001 	beq	13d648 <malloc+0xf8>
  13d640:	e1540002 	cmp	r4, r2
  13d644:	1a00009d 	bne	13d8c0 <malloc+0x370>
  13d648:	e7983009 	ldr	r3, [r8, r9]
  13d64c:	e3530000 	cmp	r3, #0
  13d650:	0affffdc 	beq	13d5c8 <malloc+0x78>
  13d654:	e59f24f8 	ldr	r2, [pc, #1272]	; 13db54 <malloc+0x604>
  13d658:	e592c000 	ldr	ip, [r2]
  13d65c:	e12fff3c 	blx	ip
  13d660:	e3a03000 	mov	r3, #0
  13d664:	e592c000 	ldr	ip, [r2]
  13d668:	e5853000 	str	r3, [r5]
  13d66c:	e12fff3c 	blx	ip
  13d670:	e5953004 	ldr	r3, [r5, #4]
  13d674:	e3530000 	cmp	r3, #0
  13d678:	0affffd2 	beq	13d5c8 <malloc+0x78>
  13d67c:	e3a000f0 	mov	r0, #240	; 0xf0
  13d680:	ebfffbca 	bl	13c5b0 <get_rtt_syscall>
  13d684:	e2503000 	subs	r3, r0, #0
  13d688:	0affffce 	beq	13d5c8 <malloc+0x78>
  13d68c:	e3a02001 	mov	r2, #1
  13d690:	e3a01081 	mov	r1, #129	; 0x81
  13d694:	e1a00005 	mov	r0, r5
  13d698:	e12fff33 	blx	r3
  13d69c:	e3700026 	cmn	r0, #38	; 0x26
  13d6a0:	1affffc8 	bne	13d5c8 <malloc+0x78>
  13d6a4:	e3a000f0 	mov	r0, #240	; 0xf0
  13d6a8:	ebfffbc0 	bl	13c5b0 <get_rtt_syscall>
  13d6ac:	e2503000 	subs	r3, r0, #0
  13d6b0:	0affffc4 	beq	13d5c8 <malloc+0x78>
  13d6b4:	e3a02001 	mov	r2, #1
  13d6b8:	e1a00005 	mov	r0, r5
  13d6bc:	e1a01002 	mov	r1, r2
  13d6c0:	e12fff33 	blx	r3
  13d6c4:	eaffffbf 	b	13d5c8 <malloc+0x78>
  13d6c8:	e3540000 	cmp	r4, #0
  13d6cc:	0affffd3 	beq	13d620 <malloc+0xd0>
  13d6d0:	e1a03001 	mov	r3, r1
  13d6d4:	e1a02001 	mov	r2, r1
  13d6d8:	e1a00005 	mov	r0, r5
  13d6dc:	e1a0100a 	mov	r1, sl
  13d6e0:	eb00121b 	bl	141f54 <__wait>
  13d6e4:	e5954000 	ldr	r4, [r5]
  13d6e8:	ea000002 	b	13d6f8 <malloc+0x1a8>
  13d6ec:	e5953000 	ldr	r3, [r5]
  13d6f0:	e1540003 	cmp	r4, r3
  13d6f4:	1afffffa 	bne	13d6e4 <malloc+0x194>
  13d6f8:	e1a00004 	mov	r0, r4
  13d6fc:	e3a01001 	mov	r1, #1
  13d700:	e1a02005 	mov	r2, r5
  13d704:	e5963000 	ldr	r3, [r6]
  13d708:	e12fff33 	blx	r3
  13d70c:	e3500000 	cmp	r0, #0
  13d710:	1afffff5 	bne	13d6ec <malloc+0x19c>
  13d714:	eaffffeb 	b	13d6c8 <malloc+0x178>
  13d718:	e2607000 	rsb	r7, r0, #0
  13d71c:	e0077000 	and	r7, r7, r0
  13d720:	e16f7f17 	clz	r7, r7
  13d724:	e267701f 	rsb	r7, r7, #31
  13d728:	eaffffb5 	b	13d604 <malloc+0xb4>
  13d72c:	e2433002 	sub	r3, r3, #2
  13d730:	e59f2420 	ldr	r2, [pc, #1056]	; 13db58 <malloc+0x608>
  13d734:	e3530c02 	cmp	r3, #512	; 0x200
  13d738:	308231a3 	addcc	r3, r2, r3, lsr #3
  13d73c:	208233a3 	addcs	r3, r2, r3, lsr #7
  13d740:	35533004 	ldrbcc	r3, [r3, #-4]
  13d744:	25533004 	ldrbcs	r3, [r3, #-4]
  13d748:	32833001 	addcc	r3, r3, #1
  13d74c:	22833011 	addcs	r3, r3, #17
  13d750:	e58d3018 	str	r3, [sp, #24]
  13d754:	eaffff8d 	b	13d590 <malloc+0x40>
  13d758:	e3e02000 	mvn	r2, #0
  13d75c:	e3a06000 	mov	r6, #0
  13d760:	e3a07000 	mov	r7, #0
  13d764:	e2833a01 	add	r3, r3, #4096	; 0x1000
  13d768:	e2833007 	add	r3, r3, #7
  13d76c:	e3c34eff 	bic	r4, r3, #4080	; 0xff0
  13d770:	e3c4400f 	bic	r4, r4, #15
  13d774:	e58d2000 	str	r2, [sp]
  13d778:	e1a01004 	mov	r1, r4
  13d77c:	e58d6008 	str	r6, [sp, #8]
  13d780:	e58d700c 	str	r7, [sp, #12]
  13d784:	e3a03022 	mov	r3, #34	; 0x22
  13d788:	e3a02003 	mov	r2, #3
  13d78c:	e3a00000 	mov	r0, #0
  13d790:	eb0001ca 	bl	13dec0 <__mmap>
  13d794:	e3700001 	cmn	r0, #1
  13d798:	0a0000ba 	beq	13da88 <malloc+0x538>
  13d79c:	e3a03008 	mov	r3, #8
  13d7a0:	e2444008 	sub	r4, r4, #8
  13d7a4:	e580400c 	str	r4, [r0, #12]
  13d7a8:	e5803008 	str	r3, [r0, #8]
  13d7ac:	e2804010 	add	r4, r0, #16
  13d7b0:	e1a00004 	mov	r0, r4
  13d7b4:	e28dd02c 	add	sp, sp, #44	; 0x2c
  13d7b8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13d7bc:	e59b200c 	ldr	r2, [fp, #12]
  13d7c0:	e59d301c 	ldr	r3, [sp, #28]
  13d7c4:	e3520000 	cmp	r2, #0
  13d7c8:	e2833010 	add	r3, r3, #16
  13d7cc:	e59f5388 	ldr	r5, [pc, #904]	; 13db5c <malloc+0x60c>
  13d7d0:	e58d3024 	str	r3, [sp, #36]	; 0x24
  13d7d4:	1a000094 	bne	13da2c <malloc+0x4dc>
  13d7d8:	e28d0024 	add	r0, sp, #36	; 0x24
  13d7dc:	eb00171f 	bl	143460 <__expand_heap>
  13d7e0:	e2504000 	subs	r4, r0, #0
  13d7e4:	0a0000b8 	beq	13dacc <malloc+0x57c>
  13d7e8:	e59f1370 	ldr	r1, [pc, #880]	; 13db60 <malloc+0x610>
  13d7ec:	e3a07001 	mov	r7, #1
  13d7f0:	e5916000 	ldr	r6, [r1]
  13d7f4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  13d7f8:	e1540006 	cmp	r4, r6
  13d7fc:	13a02001 	movne	r2, #1
  13d800:	e5950000 	ldr	r0, [r5]
  13d804:	12433010 	subne	r3, r3, #16
  13d808:	12846010 	addne	r6, r4, #16
  13d80c:	15842008 	strne	r2, [r4, #8]
  13d810:	158d3024 	strne	r3, [sp, #36]	; 0x24
  13d814:	e0862003 	add	r2, r6, r3
  13d818:	e3500000 	cmp	r0, #0
  13d81c:	e1833007 	orr	r3, r3, r7
  13d820:	e9020088 	stmdb	r2, {r3, r7}
  13d824:	e5812000 	str	r2, [r1]
  13d828:	e5063004 	str	r3, [r6, #-4]
  13d82c:	e2464008 	sub	r4, r6, #8
  13d830:	0a000009 	beq	13d85c <malloc+0x30c>
  13d834:	e59f3318 	ldr	r3, [pc, #792]	; 13db54 <malloc+0x604>
  13d838:	e593c000 	ldr	ip, [r3]
  13d83c:	e12fff3c 	blx	ip
  13d840:	e3a02000 	mov	r2, #0
  13d844:	e593c000 	ldr	ip, [r3]
  13d848:	e5852000 	str	r2, [r5]
  13d84c:	e12fff3c 	blx	ip
  13d850:	e5953004 	ldr	r3, [r5, #4]
  13d854:	e1530002 	cmp	r3, r2
  13d858:	1a000060 	bne	13d9e0 <malloc+0x490>
  13d85c:	e3540000 	cmp	r4, #0
  13d860:	0a000088 	beq	13da88 <malloc+0x538>
  13d864:	e1a00004 	mov	r0, r4
  13d868:	ebfffcf4 	bl	13cc40 <alloc_rev>
  13d86c:	e3500000 	cmp	r0, #0
  13d870:	0a00000b 	beq	13d8a4 <malloc+0x354>
  13d874:	e5163008 	ldr	r3, [r6, #-8]
  13d878:	e5161004 	ldr	r1, [r6, #-4]
  13d87c:	e3c33001 	bic	r3, r3, #1
  13d880:	e0443003 	sub	r3, r4, r3
  13d884:	e5932004 	ldr	r2, [r3, #4]
  13d888:	e3c22001 	bic	r2, r2, #1
  13d88c:	e0822001 	add	r2, r2, r1
  13d890:	e5832004 	str	r2, [r3, #4]
  13d894:	e5161004 	ldr	r1, [r6, #-4]
  13d898:	e3c11001 	bic	r1, r1, #1
  13d89c:	e7842001 	str	r2, [r4, r1]
  13d8a0:	e1a04003 	mov	r4, r3
  13d8a4:	e1a00004 	mov	r0, r4
  13d8a8:	e59d101c 	ldr	r1, [sp, #28]
  13d8ac:	e2844008 	add	r4, r4, #8
  13d8b0:	ebffff15 	bl	13d50c <trim>
  13d8b4:	e1a00004 	mov	r0, r4
  13d8b8:	e28dd02c 	add	sp, sp, #44	; 0x2c
  13d8bc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13d8c0:	e3570027 	cmp	r7, #39	; 0x27
  13d8c4:	da000041 	ble	13d9d0 <malloc+0x480>
  13d8c8:	e59d3018 	ldr	r3, [sp, #24]
  13d8cc:	e59d001c 	ldr	r0, [sp, #28]
  13d8d0:	e2833002 	add	r3, r3, #2
  13d8d4:	e1570003 	cmp	r7, r3
  13d8d8:	da00003a 	ble	13d9c8 <malloc+0x478>
  13d8dc:	e5942004 	ldr	r2, [r4, #4]
  13d8e0:	e3c22001 	bic	r2, r2, #1
  13d8e4:	e0421000 	sub	r1, r2, r0
  13d8e8:	e1a03221 	lsr	r3, r1, #4
  13d8ec:	e2433001 	sub	r3, r3, #1
  13d8f0:	e3530020 	cmp	r3, #32
  13d8f4:	9a000035 	bls	13d9d0 <malloc+0x480>
  13d8f8:	e3530c02 	cmp	r3, #512	; 0x200
  13d8fc:	2a000065 	bcs	13da98 <malloc+0x548>
  13d900:	e59fc250 	ldr	ip, [pc, #592]	; 13db58 <malloc+0x608>
  13d904:	e08c31a3 	add	r3, ip, r3, lsr #3
  13d908:	e5533004 	ldrb	r3, [r3, #-4]
  13d90c:	e1570003 	cmp	r7, r3
  13d910:	1a00002e 	bne	13d9d0 <malloc+0x480>
  13d914:	e594c00c 	ldr	ip, [r4, #12]
  13d918:	e594e008 	ldr	lr, [r4, #8]
  13d91c:	e0843000 	add	r3, r4, r0
  13d920:	e583c00c 	str	ip, [r3, #12]
  13d924:	e583e008 	str	lr, [r3, #8]
  13d928:	e58c3008 	str	r3, [ip, #8]
  13d92c:	e593e008 	ldr	lr, [r3, #8]
  13d930:	e380c001 	orr	ip, r0, #1
  13d934:	e58e300c 	str	r3, [lr, #12]
  13d938:	e784c000 	str	ip, [r4, r0]
  13d93c:	e5831004 	str	r1, [r3, #4]
  13d940:	e7841002 	str	r1, [r4, r2]
  13d944:	e584c004 	str	ip, [r4, #4]
  13d948:	e5953000 	ldr	r3, [r5]
  13d94c:	e3530000 	cmp	r3, #0
  13d950:	0affffd3 	beq	13d8a4 <malloc+0x354>
  13d954:	e59f31f8 	ldr	r3, [pc, #504]	; 13db54 <malloc+0x604>
  13d958:	e593c000 	ldr	ip, [r3]
  13d95c:	e12fff3c 	blx	ip
  13d960:	e3a02000 	mov	r2, #0
  13d964:	e593c000 	ldr	ip, [r3]
  13d968:	e5852000 	str	r2, [r5]
  13d96c:	e12fff3c 	blx	ip
  13d970:	e5953004 	ldr	r3, [r5, #4]
  13d974:	e1530002 	cmp	r3, r2
  13d978:	0affffc9 	beq	13d8a4 <malloc+0x354>
  13d97c:	e3a000f0 	mov	r0, #240	; 0xf0
  13d980:	ebfffb0a 	bl	13c5b0 <get_rtt_syscall>
  13d984:	e2503000 	subs	r3, r0, #0
  13d988:	0affffc5 	beq	13d8a4 <malloc+0x354>
  13d98c:	e3a02001 	mov	r2, #1
  13d990:	e3a01081 	mov	r1, #129	; 0x81
  13d994:	e1a00005 	mov	r0, r5
  13d998:	e12fff33 	blx	r3
  13d99c:	e3700026 	cmn	r0, #38	; 0x26
  13d9a0:	1affffbf 	bne	13d8a4 <malloc+0x354>
  13d9a4:	e3a000f0 	mov	r0, #240	; 0xf0
  13d9a8:	ebfffb00 	bl	13c5b0 <get_rtt_syscall>
  13d9ac:	e2503000 	subs	r3, r0, #0
  13d9b0:	0affffbb 	beq	13d8a4 <malloc+0x354>
  13d9b4:	e3a02001 	mov	r2, #1
  13d9b8:	e1a00005 	mov	r0, r5
  13d9bc:	e1a01002 	mov	r1, r2
  13d9c0:	e12fff33 	blx	r3
  13d9c4:	eaffffb6 	b	13d8a4 <malloc+0x354>
  13d9c8:	e357003f 	cmp	r7, #63	; 0x3f
  13d9cc:	0a000038 	beq	13dab4 <malloc+0x564>
  13d9d0:	e1a01007 	mov	r1, r7
  13d9d4:	e1a00004 	mov	r0, r4
  13d9d8:	ebfffbae 	bl	13c898 <unbin>
  13d9dc:	eaffffd9 	b	13d948 <malloc+0x3f8>
  13d9e0:	e3a000f0 	mov	r0, #240	; 0xf0
  13d9e4:	ebfffaf1 	bl	13c5b0 <get_rtt_syscall>
  13d9e8:	e2503000 	subs	r3, r0, #0
  13d9ec:	0affff9a 	beq	13d85c <malloc+0x30c>
  13d9f0:	e1a02007 	mov	r2, r7
  13d9f4:	e3a01081 	mov	r1, #129	; 0x81
  13d9f8:	e59f015c 	ldr	r0, [pc, #348]	; 13db5c <malloc+0x60c>
  13d9fc:	e12fff33 	blx	r3
  13da00:	e3700026 	cmn	r0, #38	; 0x26
  13da04:	1affff94 	bne	13d85c <malloc+0x30c>
  13da08:	e3a000f0 	mov	r0, #240	; 0xf0
  13da0c:	ebfffae7 	bl	13c5b0 <get_rtt_syscall>
  13da10:	e2503000 	subs	r3, r0, #0
  13da14:	0affff90 	beq	13d85c <malloc+0x30c>
  13da18:	e1a02007 	mov	r2, r7
  13da1c:	e1a01007 	mov	r1, r7
  13da20:	e59f0134 	ldr	r0, [pc, #308]	; 13db5c <malloc+0x60c>
  13da24:	e12fff33 	blx	r3
  13da28:	eaffff8b 	b	13d85c <malloc+0x30c>
  13da2c:	e1a06005 	mov	r6, r5
  13da30:	e59f7118 	ldr	r7, [pc, #280]	; 13db50 <malloc+0x600>
  13da34:	e2858004 	add	r8, r5, #4
  13da38:	e5954000 	ldr	r4, [r5]
  13da3c:	ea000002 	b	13da4c <malloc+0x4fc>
  13da40:	e5953000 	ldr	r3, [r5]
  13da44:	e1540003 	cmp	r4, r3
  13da48:	1afffffa 	bne	13da38 <malloc+0x4e8>
  13da4c:	e1a00004 	mov	r0, r4
  13da50:	e3a01001 	mov	r1, #1
  13da54:	e1a02006 	mov	r2, r6
  13da58:	e5973000 	ldr	r3, [r7]
  13da5c:	e12fff33 	blx	r3
  13da60:	e3500000 	cmp	r0, #0
  13da64:	1afffff5 	bne	13da40 <malloc+0x4f0>
  13da68:	e3540000 	cmp	r4, #0
  13da6c:	0affff59 	beq	13d7d8 <malloc+0x288>
  13da70:	e1a03001 	mov	r3, r1
  13da74:	e1a02001 	mov	r2, r1
  13da78:	e59f00dc 	ldr	r0, [pc, #220]	; 13db5c <malloc+0x60c>
  13da7c:	e1a01008 	mov	r1, r8
  13da80:	eb001133 	bl	141f54 <__wait>
  13da84:	eaffffeb 	b	13da38 <malloc+0x4e8>
  13da88:	e3a04000 	mov	r4, #0
  13da8c:	e1a00004 	mov	r0, r4
  13da90:	e28dd02c 	add	sp, sp, #44	; 0x2c
  13da94:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13da98:	e3530b07 	cmp	r3, #7168	; 0x1c00
  13da9c:	959fc0b4 	ldrls	ip, [pc, #180]	; 13db58 <malloc+0x608>
  13daa0:	83a0303f 	movhi	r3, #63	; 0x3f
  13daa4:	908c33a3 	addls	r3, ip, r3, lsr #7
  13daa8:	95533004 	ldrbls	r3, [r3, #-4]
  13daac:	92833010 	addls	r3, r3, #16
  13dab0:	eaffff95 	b	13d90c <malloc+0x3bc>
  13dab4:	e5942004 	ldr	r2, [r4, #4]
  13dab8:	e3c22001 	bic	r2, r2, #1
  13dabc:	e0421000 	sub	r1, r2, r0
  13dac0:	e3510907 	cmp	r1, #114688	; 0x1c000
  13dac4:	8affff87 	bhi	13d8e8 <malloc+0x398>
  13dac8:	eaffffc0 	b	13d9d0 <malloc+0x480>
  13dacc:	e5953000 	ldr	r3, [r5]
  13dad0:	e3530000 	cmp	r3, #0
  13dad4:	0affffeb 	beq	13da88 <malloc+0x538>
  13dad8:	e59f3074 	ldr	r3, [pc, #116]	; 13db54 <malloc+0x604>
  13dadc:	e593c000 	ldr	ip, [r3]
  13dae0:	e12fff3c 	blx	ip
  13dae4:	e5854000 	str	r4, [r5]
  13dae8:	e593c000 	ldr	ip, [r3]
  13daec:	e12fff3c 	blx	ip
  13daf0:	e5953004 	ldr	r3, [r5, #4]
  13daf4:	e3530000 	cmp	r3, #0
  13daf8:	0affffe2 	beq	13da88 <malloc+0x538>
  13dafc:	e3a000f0 	mov	r0, #240	; 0xf0
  13db00:	ebfffaaa 	bl	13c5b0 <get_rtt_syscall>
  13db04:	e2503000 	subs	r3, r0, #0
  13db08:	0affffde 	beq	13da88 <malloc+0x538>
  13db0c:	e3a02001 	mov	r2, #1
  13db10:	e3a01081 	mov	r1, #129	; 0x81
  13db14:	e59f0040 	ldr	r0, [pc, #64]	; 13db5c <malloc+0x60c>
  13db18:	e12fff33 	blx	r3
  13db1c:	e3700026 	cmn	r0, #38	; 0x26
  13db20:	1affffd8 	bne	13da88 <malloc+0x538>
  13db24:	e3a000f0 	mov	r0, #240	; 0xf0
  13db28:	ebfffaa0 	bl	13c5b0 <get_rtt_syscall>
  13db2c:	e2503000 	subs	r3, r0, #0
  13db30:	0affffd4 	beq	13da88 <malloc+0x538>
  13db34:	e3a02001 	mov	r2, #1
  13db38:	e59f001c 	ldr	r0, [pc, #28]	; 13db5c <malloc+0x60c>
  13db3c:	e1a01002 	mov	r1, r2
  13db40:	e12fff33 	blx	r3
  13db44:	eaffff19 	b	13d7b0 <malloc+0x260>
  13db48:	0014fc30 	.word	0x0014fc30
  13db4c:	00576e84 	.word	0x00576e84
  13db50:	0014e3d8 	.word	0x0014e3d8
  13db54:	0014e3d4 	.word	0x0014e3d4
  13db58:	0014cf68 	.word	0x0014cf68
  13db5c:	0014fc28 	.word	0x0014fc28
  13db60:	0014fc24 	.word	0x0014fc24

0013db64 <calloc>:
  13db64:	e3510000 	cmp	r1, #0
  13db68:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
  13db6c:	0a000002 	beq	13db7c <calloc+0x18>
  13db70:	e0832190 	umull	r2, r3, r0, r1
  13db74:	e3530000 	cmp	r3, #0
  13db78:	1a000013 	bne	13dbcc <calloc+0x68>
  13db7c:	e0040190 	mul	r4, r0, r1
  13db80:	e1a00004 	mov	r0, r4
  13db84:	ebfffe71 	bl	13d550 <malloc>
  13db88:	e2509000 	subs	r9, r0, #0
  13db8c:	0a000012 	beq	13dbdc <calloc+0x78>
  13db90:	e59f30a0 	ldr	r3, [pc, #160]	; 13dc38 <calloc+0xd4>
  13db94:	e5933000 	ldr	r3, [r3]
  13db98:	e3530000 	cmp	r3, #0
  13db9c:	1a000005 	bne	13dbb8 <calloc+0x54>
  13dba0:	e5193004 	ldr	r3, [r9, #-4]
  13dba4:	e3130001 	tst	r3, #1
  13dba8:	0a00000b 	beq	13dbdc <calloc+0x78>
  13dbac:	e59f3088 	ldr	r3, [pc, #136]	; 13dc3c <calloc+0xd8>
  13dbb0:	e1540003 	cmp	r4, r3
  13dbb4:	8a00000a 	bhi	13dbe4 <calloc+0x80>
  13dbb8:	e1a02004 	mov	r2, r4
  13dbbc:	e1a00009 	mov	r0, r9
  13dbc0:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
  13dbc4:	e3a01000 	mov	r1, #0
  13dbc8:	ea000e29 	b	141474 <memset>
  13dbcc:	ebffed41 	bl	1390d8 <__errno_location>
  13dbd0:	e3a0300c 	mov	r3, #12
  13dbd4:	e3a09000 	mov	r9, #0
  13dbd8:	e5803000 	str	r3, [r0]
  13dbdc:	e1a00009 	mov	r0, r9
  13dbe0:	e8bd8bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, pc}
  13dbe4:	e1a08003 	mov	r8, r3
  13dbe8:	e0890004 	add	r0, r9, r4
  13dbec:	e0002003 	and	r2, r0, r3
  13dbf0:	e0400002 	sub	r0, r0, r2
  13dbf4:	e3a01000 	mov	r1, #0
  13dbf8:	eb000e1d 	bl	141474 <memset>
  13dbfc:	e0404009 	sub	r4, r0, r9
  13dc00:	e1540008 	cmp	r4, r8
  13dc04:	9affffeb 	bls	13dbb8 <calloc+0x54>
  13dc08:	e3a02a01 	mov	r2, #4096	; 0x1000
  13dc0c:	e9100030 	ldmdb	r0, {r4, r5}
  13dc10:	e2407010 	sub	r7, r0, #16
  13dc14:	e89700c0 	ldm	r7, {r6, r7}
  13dc18:	e184b006 	orr	fp, r4, r6
  13dc1c:	e185c007 	orr	ip, r5, r7
  13dc20:	e19b300c 	orrs	r3, fp, ip
  13dc24:	1afffff1 	bne	13dbf0 <calloc+0x8c>
  13dc28:	e2522010 	subs	r2, r2, #16
  13dc2c:	e2400010 	sub	r0, r0, #16
  13dc30:	1afffff5 	bne	13dc0c <calloc+0xa8>
  13dc34:	eaffffed 	b	13dbf0 <calloc+0x8c>
  13dc38:	00576ec8 	.word	0x00576ec8
  13dc3c:	00000fff 	.word	0x00000fff

0013dc40 <free>:
  13dc40:	e2502000 	subs	r2, r0, #0
  13dc44:	012fff1e 	bxeq	lr
  13dc48:	e5123004 	ldr	r3, [r2, #-4]
  13dc4c:	e2420008 	sub	r0, r2, #8
  13dc50:	e3130001 	tst	r3, #1
  13dc54:	0a000000 	beq	13dc5c <free+0x1c>
  13dc58:	eafffc9a 	b	13cec8 <__bin_chunk>
  13dc5c:	e5121008 	ldr	r1, [r2, #-8]
  13dc60:	e3c33001 	bic	r3, r3, #1
  13dc64:	e3110001 	tst	r1, #1
  13dc68:	e0400001 	sub	r0, r0, r1
  13dc6c:	e0831001 	add	r1, r3, r1
  13dc70:	0a000000 	beq	13dc78 <free+0x38>
  13dc74:	e7f000f0 	.word	0xe7f000f0
  13dc78:	ea0000f6 	b	13e058 <__munmap>

0013dc7c <realloc>:
  13dc7c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  13dc80:	e2505000 	subs	r5, r0, #0
  13dc84:	e24dd008 	sub	sp, sp, #8
  13dc88:	e58d1004 	str	r1, [sp, #4]
  13dc8c:	0a000034 	beq	13dd64 <realloc+0xe8>
  13dc90:	e28d0004 	add	r0, sp, #4
  13dc94:	ebfffae5 	bl	13c830 <adjust_size>
  13dc98:	e3500000 	cmp	r0, #0
  13dc9c:	ba00005b 	blt	13de10 <realloc+0x194>
  13dca0:	e5153004 	ldr	r3, [r5, #-4]
  13dca4:	e2459008 	sub	r9, r5, #8
  13dca8:	e3130001 	tst	r3, #1
  13dcac:	e3c36001 	bic	r6, r3, #1
  13dcb0:	0a000010 	beq	13dcf8 <realloc+0x7c>
  13dcb4:	e7992006 	ldr	r2, [r9, r6]
  13dcb8:	e0894006 	add	r4, r9, r6
  13dcbc:	e1530002 	cmp	r3, r2
  13dcc0:	0a000000 	beq	13dcc8 <realloc+0x4c>
  13dcc4:	e7f000f0 	.word	0xe7f000f0
  13dcc8:	e59d1004 	ldr	r1, [sp, #4]
  13dccc:	e1510006 	cmp	r1, r6
  13dcd0:	93866001 	orrls	r6, r6, #1
  13dcd4:	95056004 	strls	r6, [r5, #-4]
  13dcd8:	95846000 	strls	r6, [r4]
  13dcdc:	8a000038 	bhi	13ddc4 <realloc+0x148>
  13dce0:	e1a00009 	mov	r0, r9
  13dce4:	ebfffe08 	bl	13d50c <trim>
  13dce8:	e1a07005 	mov	r7, r5
  13dcec:	e1a00007 	mov	r0, r7
  13dcf0:	e28dd008 	add	sp, sp, #8
  13dcf4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  13dcf8:	e5158008 	ldr	r8, [r5, #-8]
  13dcfc:	e59d4004 	ldr	r4, [sp, #4]
  13dd00:	e3180001 	tst	r8, #1
  13dd04:	e086a008 	add	sl, r6, r8
  13dd08:	e0884004 	add	r4, r8, r4
  13dd0c:	1a00001a 	bne	13dd7c <realloc+0x100>
  13dd10:	e3540a01 	cmp	r4, #4096	; 0x1000
  13dd14:	3a00001b 	bcc	13dd88 <realloc+0x10c>
  13dd18:	e2844eff 	add	r4, r4, #4080	; 0xff0
  13dd1c:	e284400f 	add	r4, r4, #15
  13dd20:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
  13dd24:	e3c4400f 	bic	r4, r4, #15
  13dd28:	e15a0004 	cmp	sl, r4
  13dd2c:	01a07005 	moveq	r7, r5
  13dd30:	0affffed 	beq	13dcec <realloc+0x70>
  13dd34:	e1a0100a 	mov	r1, sl
  13dd38:	e0490008 	sub	r0, r9, r8
  13dd3c:	e3a03001 	mov	r3, #1
  13dd40:	e1a02004 	mov	r2, r4
  13dd44:	eb00009a 	bl	13dfb4 <__mremap>
  13dd48:	e3700001 	cmn	r0, #1
  13dd4c:	0a000031 	beq	13de18 <realloc+0x19c>
  13dd50:	e0800008 	add	r0, r0, r8
  13dd54:	e0444008 	sub	r4, r4, r8
  13dd58:	e5804004 	str	r4, [r0, #4]
  13dd5c:	e2807008 	add	r7, r0, #8
  13dd60:	eaffffe1 	b	13dcec <realloc+0x70>
  13dd64:	e1a00001 	mov	r0, r1
  13dd68:	ebfffdf8 	bl	13d550 <malloc>
  13dd6c:	e1a07000 	mov	r7, r0
  13dd70:	e1a00007 	mov	r0, r7
  13dd74:	e28dd008 	add	sp, sp, #8
  13dd78:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  13dd7c:	e7f000f0 	.word	0xe7f000f0
  13dd80:	e3540a01 	cmp	r4, #4096	; 0x1000
  13dd84:	2affffe3 	bcs	13dd18 <realloc+0x9c>
  13dd88:	e59d0004 	ldr	r0, [sp, #4]
  13dd8c:	e2400008 	sub	r0, r0, #8
  13dd90:	ebfffdee 	bl	13d550 <malloc>
  13dd94:	e2507000 	subs	r7, r0, #0
  13dd98:	0affffde 	beq	13dd18 <realloc+0x9c>
  13dd9c:	e59d6004 	ldr	r6, [sp, #4]
  13dda0:	e2462008 	sub	r2, r6, #8
  13dda4:	e1a01005 	mov	r1, r5
  13dda8:	e1a00007 	mov	r0, r7
  13ddac:	eb000c78 	bl	140f94 <memcpy>
  13ddb0:	e1a00005 	mov	r0, r5
  13ddb4:	ebffffa1 	bl	13dc40 <free>
  13ddb8:	e1a00007 	mov	r0, r7
  13ddbc:	e28dd008 	add	sp, sp, #8
  13ddc0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  13ddc4:	e1a00004 	mov	r0, r4
  13ddc8:	ebfffafc 	bl	13c9c0 <alloc_fwd>
  13ddcc:	e3500000 	cmp	r0, #0
  13ddd0:	01a03006 	moveq	r3, r6
  13ddd4:	15943004 	ldrne	r3, [r4, #4]
  13ddd8:	059d1004 	ldreq	r1, [sp, #4]
  13dddc:	13c33001 	bicne	r3, r3, #1
  13dde0:	159d1004 	ldrne	r1, [sp, #4]
  13dde4:	10844003 	addne	r4, r4, r3
  13dde8:	10833006 	addne	r3, r3, r6
  13ddec:	e1530001 	cmp	r3, r1
  13ddf0:	e3833001 	orr	r3, r3, #1
  13ddf4:	e5053004 	str	r3, [r5, #-4]
  13ddf8:	e5843000 	str	r3, [r4]
  13ddfc:	2affffb7 	bcs	13dce0 <realloc+0x64>
  13de00:	e2410008 	sub	r0, r1, #8
  13de04:	ebfffdd1 	bl	13d550 <malloc>
  13de08:	e2507000 	subs	r7, r0, #0
  13de0c:	1affffe3 	bne	13dda0 <realloc+0x124>
  13de10:	e3a07000 	mov	r7, #0
  13de14:	eaffffb4 	b	13dcec <realloc+0x70>
  13de18:	e59d1004 	ldr	r1, [sp, #4]
  13de1c:	eafffff7 	b	13de00 <realloc+0x184>

0013de20 <__malloc_donate>:
  13de20:	e2602008 	rsb	r2, r0, #8
  13de24:	e201300f 	and	r3, r1, #15
  13de28:	e202200f 	and	r2, r2, #15
  13de2c:	e2833008 	add	r3, r3, #8
  13de30:	e0833002 	add	r3, r3, r2
  13de34:	e041c000 	sub	ip, r1, r0
  13de38:	e15c0003 	cmp	ip, r3
  13de3c:	912fff1e 	bxls	lr
  13de40:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13de44:	e3a0e001 	mov	lr, #1
  13de48:	e2823008 	add	r3, r2, #8
  13de4c:	e0803003 	add	r3, r0, r3
  13de50:	e3c1100f 	bic	r1, r1, #15
  13de54:	e041c003 	sub	ip, r1, r3
  13de58:	e18cc00e 	orr	ip, ip, lr
  13de5c:	e501e004 	str	lr, [r1, #-4]
  13de60:	e0800002 	add	r0, r0, r2
  13de64:	e503e008 	str	lr, [r3, #-8]
  13de68:	e501c008 	str	ip, [r1, #-8]
  13de6c:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  13de70:	e503c004 	str	ip, [r3, #-4]
  13de74:	eafffc13 	b	13cec8 <__bin_chunk>

0013de78 <__madvise>:
  13de78:	e92d4070 	push	{r4, r5, r6, lr}
  13de7c:	e1a04000 	mov	r4, r0
  13de80:	e3a000dc 	mov	r0, #220	; 0xdc
  13de84:	e1a05001 	mov	r5, r1
  13de88:	e1a06002 	mov	r6, r2
  13de8c:	ebfff9c7 	bl	13c5b0 <get_rtt_syscall>
  13de90:	e2503000 	subs	r3, r0, #0
  13de94:	0a000005 	beq	13deb0 <__madvise+0x38>
  13de98:	e1a02006 	mov	r2, r6
  13de9c:	e1a01005 	mov	r1, r5
  13dea0:	e1a00004 	mov	r0, r4
  13dea4:	e12fff33 	blx	r3
  13dea8:	e8bd4070 	pop	{r4, r5, r6, lr}
  13deac:	eafff9f4 	b	13c684 <__syscall_ret>
  13deb0:	e1a00003 	mov	r0, r3
  13deb4:	eafffffb 	b	13dea8 <__madvise+0x30>

0013deb8 <dummy>:
  13deb8:	e12fff1e 	bx	lr
  13debc:	00000000 	andeq	r0, r0, r0

0013dec0 <__mmap>:
  13dec0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  13dec4:	e28f50dc 	add	r5, pc, #220	; 0xdc
  13dec8:	e8950030 	ldm	r5, {r4, r5}
  13decc:	e24dd00c 	sub	sp, sp, #12
  13ded0:	e28d7038 	add	r7, sp, #56	; 0x38
  13ded4:	e89700c0 	ldm	r7, {r6, r7}
  13ded8:	e0048006 	and	r8, r4, r6
  13dedc:	e0059007 	and	r9, r5, r7
  13dee0:	e198c009 	orrs	ip, r8, r9
  13dee4:	e59db030 	ldr	fp, [sp, #48]	; 0x30
  13dee8:	1a000024 	bne	13df80 <__mmap+0xc0>
  13deec:	e371010a 	cmn	r1, #-2147483646	; 0x80000002
  13def0:	e1a08001 	mov	r8, r1
  13def4:	8a00001b 	bhi	13df68 <__mmap+0xa8>
  13def8:	e3130010 	tst	r3, #16
  13defc:	e1a09000 	mov	r9, r0
  13df00:	e1a0a002 	mov	sl, r2
  13df04:	e1a05003 	mov	r5, r3
  13df08:	1a000022 	bne	13df98 <__mmap+0xd8>
  13df0c:	e3a000c0 	mov	r0, #192	; 0xc0
  13df10:	ebfff9a6 	bl	13c5b0 <get_rtt_syscall>
  13df14:	e1a03626 	lsr	r3, r6, #12
  13df18:	e2504000 	subs	r4, r0, #0
  13df1c:	e1833a07 	orr	r3, r3, r7, lsl #20
  13df20:	0a00001e 	beq	13dfa0 <__mmap+0xe0>
  13df24:	e58d3004 	str	r3, [sp, #4]
  13df28:	e58db000 	str	fp, [sp]
  13df2c:	e1a0200a 	mov	r2, sl
  13df30:	e1a01008 	mov	r1, r8
  13df34:	e1a03005 	mov	r3, r5
  13df38:	e1a00009 	mov	r0, r9
  13df3c:	e12fff34 	blx	r4
  13df40:	e3590000 	cmp	r9, #0
  13df44:	03700001 	cmneq	r0, #1
  13df48:	1a000003 	bne	13df5c <__mmap+0x9c>
  13df4c:	e2055030 	and	r5, r5, #48	; 0x30
  13df50:	e3550020 	cmp	r5, #32
  13df54:	03e0000b 	mvneq	r0, #11
  13df58:	13e00000 	mvnne	r0, #0
  13df5c:	e28dd00c 	add	sp, sp, #12
  13df60:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  13df64:	eafff9c6 	b	13c684 <__syscall_ret>
  13df68:	ebffec5a 	bl	1390d8 <__errno_location>
  13df6c:	e3a0300c 	mov	r3, #12
  13df70:	e5803000 	str	r3, [r0]
  13df74:	e3e00000 	mvn	r0, #0
  13df78:	e28dd00c 	add	sp, sp, #12
  13df7c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13df80:	ebffec54 	bl	1390d8 <__errno_location>
  13df84:	e3a03016 	mov	r3, #22
  13df88:	e5803000 	str	r3, [r0]
  13df8c:	e3e00000 	mvn	r0, #0
  13df90:	e28dd00c 	add	sp, sp, #12
  13df94:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13df98:	eb00139d 	bl	142e14 <__vm_wait>
  13df9c:	eaffffda 	b	13df0c <__mmap+0x4c>
  13dfa0:	e1a00004 	mov	r0, r4
  13dfa4:	eaffffec 	b	13df5c <__mmap+0x9c>
  13dfa8:	00000fff 	.word	0x00000fff
  13dfac:	fffff000 	.word	0xfffff000

0013dfb0 <dummy>:
  13dfb0:	e12fff1e 	bx	lr

0013dfb4 <__mremap>:
  13dfb4:	e52d3004 	push	{r3}		; (str r3, [sp, #-4]!)
  13dfb8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  13dfbc:	e372010a 	cmn	r2, #-2147483646	; 0x80000002
  13dfc0:	e24dd014 	sub	sp, sp, #20
  13dfc4:	8a00001b 	bhi	13e038 <__mremap+0x84>
  13dfc8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  13dfcc:	e1a05002 	mov	r5, r2
  13dfd0:	e2136002 	ands	r6, r3, #2
  13dfd4:	e1a07000 	mov	r7, r0
  13dfd8:	e1a08001 	mov	r8, r1
  13dfdc:	1a000010 	bne	13e024 <__mremap+0x70>
  13dfe0:	e3a000a3 	mov	r0, #163	; 0xa3
  13dfe4:	ebfff971 	bl	13c5b0 <get_rtt_syscall>
  13dfe8:	e2504000 	subs	r4, r0, #0
  13dfec:	0a000016 	beq	13e04c <__mremap+0x98>
  13dff0:	e58d6000 	str	r6, [sp]
  13dff4:	e1a02005 	mov	r2, r5
  13dff8:	e1a01008 	mov	r1, r8
  13dffc:	e1a00007 	mov	r0, r7
  13e000:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  13e004:	e12fff34 	blx	r4
  13e008:	ebfff99d 	bl	13c684 <__syscall_ret>
  13e00c:	e1a03000 	mov	r3, r0
  13e010:	e1a00003 	mov	r0, r3
  13e014:	e28dd014 	add	sp, sp, #20
  13e018:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  13e01c:	e28dd004 	add	sp, sp, #4
  13e020:	e12fff1e 	bx	lr
  13e024:	eb00137a 	bl	142e14 <__vm_wait>
  13e028:	e28d3030 	add	r3, sp, #48	; 0x30
  13e02c:	e58d300c 	str	r3, [sp, #12]
  13e030:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
  13e034:	eaffffe9 	b	13dfe0 <__mremap+0x2c>
  13e038:	ebffec26 	bl	1390d8 <__errno_location>
  13e03c:	e3a0200c 	mov	r2, #12
  13e040:	e3e03000 	mvn	r3, #0
  13e044:	e5802000 	str	r2, [r0]
  13e048:	eafffff0 	b	13e010 <__mremap+0x5c>
  13e04c:	e1a00004 	mov	r0, r4
  13e050:	eaffffec 	b	13e008 <__mremap+0x54>

0013e054 <dummy>:
  13e054:	e12fff1e 	bx	lr

0013e058 <__munmap>:
  13e058:	e92d4070 	push	{r4, r5, r6, lr}
  13e05c:	e1a04000 	mov	r4, r0
  13e060:	e1a05001 	mov	r5, r1
  13e064:	eb00136a 	bl	142e14 <__vm_wait>
  13e068:	e3a0005b 	mov	r0, #91	; 0x5b
  13e06c:	ebfff94f 	bl	13c5b0 <get_rtt_syscall>
  13e070:	e2503000 	subs	r3, r0, #0
  13e074:	0a000004 	beq	13e08c <__munmap+0x34>
  13e078:	e1a01005 	mov	r1, r5
  13e07c:	e1a00004 	mov	r0, r4
  13e080:	e12fff33 	blx	r3
  13e084:	e8bd4070 	pop	{r4, r5, r6, lr}
  13e088:	eafff97d 	b	13c684 <__syscall_ret>
  13e08c:	e1a00003 	mov	r0, r3
  13e090:	eafffffb 	b	13e084 <__munmap+0x2c>

0013e094 <accept>:
  13e094:	e3a0c000 	mov	ip, #0
  13e098:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13e09c:	e24dd014 	sub	sp, sp, #20
  13e0a0:	e1a03002 	mov	r3, r2
  13e0a4:	e58dc008 	str	ip, [sp, #8]
  13e0a8:	e1a02001 	mov	r2, r1
  13e0ac:	e58dc004 	str	ip, [sp, #4]
  13e0b0:	e1a01000 	mov	r1, r0
  13e0b4:	e58dc000 	str	ip, [sp]
  13e0b8:	e59f000c 	ldr	r0, [pc, #12]	; 13e0cc <accept+0x38>
  13e0bc:	eb000fa3 	bl	141f50 <__syscall_cp>
  13e0c0:	e28dd014 	add	sp, sp, #20
  13e0c4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  13e0c8:	eafff96d 	b	13c684 <__syscall_ret>
  13e0cc:	0000011d 	.word	0x0000011d

0013e0d0 <bind>:
  13e0d0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  13e0d4:	e1a05000 	mov	r5, r0
  13e0d8:	e24dd00c 	sub	sp, sp, #12
  13e0dc:	e59f0040 	ldr	r0, [pc, #64]	; 13e124 <bind+0x54>
  13e0e0:	e1a06001 	mov	r6, r1
  13e0e4:	e1a07002 	mov	r7, r2
  13e0e8:	ebfff930 	bl	13c5b0 <get_rtt_syscall>
  13e0ec:	e2504000 	subs	r4, r0, #0
  13e0f0:	0a000009 	beq	13e11c <bind+0x4c>
  13e0f4:	e3a03000 	mov	r3, #0
  13e0f8:	e1a02007 	mov	r2, r7
  13e0fc:	e1a01006 	mov	r1, r6
  13e100:	e1a00005 	mov	r0, r5
  13e104:	e58d3004 	str	r3, [sp, #4]
  13e108:	e58d3000 	str	r3, [sp]
  13e10c:	e12fff34 	blx	r4
  13e110:	e28dd00c 	add	sp, sp, #12
  13e114:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  13e118:	eafff959 	b	13c684 <__syscall_ret>
  13e11c:	e1a00004 	mov	r0, r4
  13e120:	eafffffa 	b	13e110 <bind+0x40>
  13e124:	0000011a 	.word	0x0000011a

0013e128 <connect>:
  13e128:	e3a0c000 	mov	ip, #0
  13e12c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13e130:	e24dd014 	sub	sp, sp, #20
  13e134:	e1a03002 	mov	r3, r2
  13e138:	e58dc008 	str	ip, [sp, #8]
  13e13c:	e1a02001 	mov	r2, r1
  13e140:	e58dc004 	str	ip, [sp, #4]
  13e144:	e1a01000 	mov	r1, r0
  13e148:	e58dc000 	str	ip, [sp]
  13e14c:	e59f000c 	ldr	r0, [pc, #12]	; 13e160 <connect+0x38>
  13e150:	eb000f7e 	bl	141f50 <__syscall_cp>
  13e154:	e28dd014 	add	sp, sp, #20
  13e158:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  13e15c:	eafff948 	b	13c684 <__syscall_ret>
  13e160:	0000011b 	.word	0x0000011b

0013e164 <htonl>:
  13e164:	e0203860 	eor	r3, r0, r0, ror #16
  13e168:	e1a03423 	lsr	r3, r3, #8
  13e16c:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
  13e170:	e0230460 	eor	r0, r3, r0, ror #8
  13e174:	e12fff1e 	bx	lr

0013e178 <htons>:
  13e178:	e1a03420 	lsr	r3, r0, #8
  13e17c:	e1830400 	orr	r0, r3, r0, lsl #8
  13e180:	e1a00800 	lsl	r0, r0, #16
  13e184:	e1a00820 	lsr	r0, r0, #16
  13e188:	e12fff1e 	bx	lr

0013e18c <listen>:
  13e18c:	e92d4070 	push	{r4, r5, r6, lr}
  13e190:	e1a05000 	mov	r5, r0
  13e194:	e24dd008 	sub	sp, sp, #8
  13e198:	e3a00f47 	mov	r0, #284	; 0x11c
  13e19c:	e1a06001 	mov	r6, r1
  13e1a0:	ebfff902 	bl	13c5b0 <get_rtt_syscall>
  13e1a4:	e2504000 	subs	r4, r0, #0
  13e1a8:	0a000009 	beq	13e1d4 <listen+0x48>
  13e1ac:	e3a03000 	mov	r3, #0
  13e1b0:	e1a01006 	mov	r1, r6
  13e1b4:	e1a00005 	mov	r0, r5
  13e1b8:	e58d3004 	str	r3, [sp, #4]
  13e1bc:	e58d3000 	str	r3, [sp]
  13e1c0:	e1a02003 	mov	r2, r3
  13e1c4:	e12fff34 	blx	r4
  13e1c8:	e28dd008 	add	sp, sp, #8
  13e1cc:	e8bd4070 	pop	{r4, r5, r6, lr}
  13e1d0:	eafff92b 	b	13c684 <__syscall_ret>
  13e1d4:	e1a00004 	mov	r0, r4
  13e1d8:	eafffffa 	b	13e1c8 <listen+0x3c>

0013e1dc <setsockopt>:
  13e1dc:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  13e1e0:	e1a05000 	mov	r5, r0
  13e1e4:	e24dd00c 	sub	sp, sp, #12
  13e1e8:	e59f004c 	ldr	r0, [pc, #76]	; 13e23c <setsockopt+0x60>
  13e1ec:	e1a06001 	mov	r6, r1
  13e1f0:	e1a07002 	mov	r7, r2
  13e1f4:	e1a08003 	mov	r8, r3
  13e1f8:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
  13e1fc:	ebfff8eb 	bl	13c5b0 <get_rtt_syscall>
  13e200:	e2504000 	subs	r4, r0, #0
  13e204:	0a00000a 	beq	13e234 <setsockopt+0x58>
  13e208:	e3a0c000 	mov	ip, #0
  13e20c:	e58d9000 	str	r9, [sp]
  13e210:	e1a03008 	mov	r3, r8
  13e214:	e1a02007 	mov	r2, r7
  13e218:	e1a01006 	mov	r1, r6
  13e21c:	e1a00005 	mov	r0, r5
  13e220:	e58dc004 	str	ip, [sp, #4]
  13e224:	e12fff34 	blx	r4
  13e228:	e28dd00c 	add	sp, sp, #12
  13e22c:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, lr}
  13e230:	eafff913 	b	13c684 <__syscall_ret>
  13e234:	e1a00004 	mov	r0, r4
  13e238:	eafffffa 	b	13e228 <setsockopt+0x4c>
  13e23c:	00000126 	.word	0x00000126

0013e240 <socket>:
  13e240:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  13e244:	e1a06000 	mov	r6, r0
  13e248:	e24dd00c 	sub	sp, sp, #12
  13e24c:	e59f0118 	ldr	r0, [pc, #280]	; 13e36c <socket+0x12c>
  13e250:	e1a05001 	mov	r5, r1
  13e254:	e1a07002 	mov	r7, r2
  13e258:	ebfff8d4 	bl	13c5b0 <get_rtt_syscall>
  13e25c:	e2504000 	subs	r4, r0, #0
  13e260:	0a000034 	beq	13e338 <socket+0xf8>
  13e264:	e3a03000 	mov	r3, #0
  13e268:	e1a02007 	mov	r2, r7
  13e26c:	e58d3004 	str	r3, [sp, #4]
  13e270:	e58d3000 	str	r3, [sp]
  13e274:	e1a01005 	mov	r1, r5
  13e278:	e1a00006 	mov	r0, r6
  13e27c:	e12fff34 	blx	r4
  13e280:	ebfff8ff 	bl	13c684 <__syscall_ret>
  13e284:	e2504000 	subs	r4, r0, #0
  13e288:	ba000002 	blt	13e298 <socket+0x58>
  13e28c:	e1a00004 	mov	r0, r4
  13e290:	e28dd00c 	add	sp, sp, #12
  13e294:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  13e298:	ebffeb8e 	bl	1390d8 <__errno_location>
  13e29c:	e5903000 	ldr	r3, [r0]
  13e2a0:	e3530016 	cmp	r3, #22
  13e2a4:	1a00001e 	bne	13e324 <socket+0xe4>
  13e2a8:	e59f30c0 	ldr	r3, [pc, #192]	; 13e370 <socket+0x130>
  13e2ac:	e1150003 	tst	r5, r3
  13e2b0:	0afffff5 	beq	13e28c <socket+0x4c>
  13e2b4:	e59f00b0 	ldr	r0, [pc, #176]	; 13e36c <socket+0x12c>
  13e2b8:	ebfff8bc 	bl	13c5b0 <get_rtt_syscall>
  13e2bc:	e3c51702 	bic	r1, r5, #524288	; 0x80000
  13e2c0:	e2504000 	subs	r4, r0, #0
  13e2c4:	e3c11b02 	bic	r1, r1, #2048	; 0x800
  13e2c8:	0a000025 	beq	13e364 <socket+0x124>
  13e2cc:	e3a03000 	mov	r3, #0
  13e2d0:	e1a02007 	mov	r2, r7
  13e2d4:	e1a00006 	mov	r0, r6
  13e2d8:	e58d3004 	str	r3, [sp, #4]
  13e2dc:	e58d3000 	str	r3, [sp]
  13e2e0:	e12fff34 	blx	r4
  13e2e4:	ebfff8e6 	bl	13c684 <__syscall_ret>
  13e2e8:	e2504000 	subs	r4, r0, #0
  13e2ec:	baffffe6 	blt	13e28c <socket+0x4c>
  13e2f0:	e3150702 	tst	r5, #524288	; 0x80000
  13e2f4:	1a000011 	bne	13e340 <socket+0x100>
  13e2f8:	e3150b02 	tst	r5, #2048	; 0x800
  13e2fc:	0affffe2 	beq	13e28c <socket+0x4c>
  13e300:	e3a000dd 	mov	r0, #221	; 0xdd
  13e304:	ebfff8a9 	bl	13c5b0 <get_rtt_syscall>
  13e308:	e2503000 	subs	r3, r0, #0
  13e30c:	0affffde 	beq	13e28c <socket+0x4c>
  13e310:	e3a02b02 	mov	r2, #2048	; 0x800
  13e314:	e3a01004 	mov	r1, #4
  13e318:	e1a00004 	mov	r0, r4
  13e31c:	e12fff33 	blx	r3
  13e320:	eaffffd9 	b	13e28c <socket+0x4c>
  13e324:	ebffeb6b 	bl	1390d8 <__errno_location>
  13e328:	e5903000 	ldr	r3, [r0]
  13e32c:	e353005d 	cmp	r3, #93	; 0x5d
  13e330:	1affffd5 	bne	13e28c <socket+0x4c>
  13e334:	eaffffdb 	b	13e2a8 <socket+0x68>
  13e338:	e1a00004 	mov	r0, r4
  13e33c:	eaffffcf 	b	13e280 <socket+0x40>
  13e340:	e3a000dd 	mov	r0, #221	; 0xdd
  13e344:	ebfff899 	bl	13c5b0 <get_rtt_syscall>
  13e348:	e2503000 	subs	r3, r0, #0
  13e34c:	0affffe9 	beq	13e2f8 <socket+0xb8>
  13e350:	e3a02001 	mov	r2, #1
  13e354:	e3a01002 	mov	r1, #2
  13e358:	e1a00004 	mov	r0, r4
  13e35c:	e12fff33 	blx	r3
  13e360:	eaffffe4 	b	13e2f8 <socket+0xb8>
  13e364:	e1a00004 	mov	r0, r4
  13e368:	eaffffdd 	b	13e2e4 <socket+0xa4>
  13e36c:	00000119 	.word	0x00000119
  13e370:	00080800 	.word	0x00080800

0013e374 <srand>:
  13e374:	e3a02000 	mov	r2, #0
  13e378:	e59f3008 	ldr	r3, [pc, #8]	; 13e388 <srand+0x14>
  13e37c:	e2400001 	sub	r0, r0, #1
  13e380:	e8830005 	stm	r3, {r0, r2}
  13e384:	e12fff1e 	bx	lr
  13e388:	00150040 	.word	0x00150040

0013e38c <rand>:
  13e38c:	e59f1034 	ldr	r1, [pc, #52]	; 13e3c8 <rand+0x3c>
  13e390:	e92d4800 	push	{fp, lr}
  13e394:	e59f3030 	ldr	r3, [pc, #48]	; 13e3cc <rand+0x40>
  13e398:	e591e000 	ldr	lr, [r1]
  13e39c:	e5912004 	ldr	r2, [r1, #4]
  13e3a0:	e00b039e 	mul	fp, lr, r3
  13e3a4:	e59fc024 	ldr	ip, [pc, #36]	; 13e3d0 <rand+0x44>
  13e3a8:	e020b29c 	mla	r0, ip, r2, fp
  13e3ac:	e0832c9e 	umull	r2, r3, lr, ip
  13e3b0:	e0803003 	add	r3, r0, r3
  13e3b4:	e292b001 	adds	fp, r2, #1
  13e3b8:	e2a3c000 	adc	ip, r3, #0
  13e3bc:	e8811800 	stm	r1, {fp, ip}
  13e3c0:	e1a000ac 	lsr	r0, ip, #1
  13e3c4:	e8bd8800 	pop	{fp, pc}
  13e3c8:	00150040 	.word	0x00150040
  13e3cc:	5851f42d 	.word	0x5851f42d
  13e3d0:	4c957f2d 	.word	0x4c957f2d

0013e3d4 <select>:
  13e3d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13e3d8:	e3a0e000 	mov	lr, #0
  13e3dc:	e24dd014 	sub	sp, sp, #20
  13e3e0:	e59dc018 	ldr	ip, [sp, #24]
  13e3e4:	e58d3000 	str	r3, [sp]
  13e3e8:	e58de008 	str	lr, [sp, #8]
  13e3ec:	e1a03002 	mov	r3, r2
  13e3f0:	e58dc004 	str	ip, [sp, #4]
  13e3f4:	e1a02001 	mov	r2, r1
  13e3f8:	e1a01000 	mov	r1, r0
  13e3fc:	e3a0008e 	mov	r0, #142	; 0x8e
  13e400:	eb000ed2 	bl	141f50 <__syscall_cp>
  13e404:	e28dd014 	add	sp, sp, #20
  13e408:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  13e40c:	eafff89c 	b	13c684 <__syscall_ret>

0013e410 <raise>:
  13e410:	e92d4030 	push	{r4, r5, lr}
  13e414:	e24dd084 	sub	sp, sp, #132	; 0x84
  13e418:	e1a05000 	mov	r5, r0
  13e41c:	e1a0000d 	mov	r0, sp
  13e420:	eb00149d 	bl	14369c <__block_app_sigs>
  13e424:	e59f3048 	ldr	r3, [pc, #72]	; 13e474 <raise+0x64>
  13e428:	e5930000 	ldr	r0, [r3]
  13e42c:	e12fff30 	blx	r0
  13e430:	e510405c 	ldr	r4, [r0, #-92]	; 0xffffffa4
  13e434:	e3a000ee 	mov	r0, #238	; 0xee
  13e438:	ebfff85c 	bl	13c5b0 <get_rtt_syscall>
  13e43c:	e2503000 	subs	r3, r0, #0
  13e440:	0a000009 	beq	13e46c <raise+0x5c>
  13e444:	e1a01005 	mov	r1, r5
  13e448:	e1a00004 	mov	r0, r4
  13e44c:	e12fff33 	blx	r3
  13e450:	ebfff88b 	bl	13c684 <__syscall_ret>
  13e454:	e1a04000 	mov	r4, r0
  13e458:	e1a0000d 	mov	r0, sp
  13e45c:	eb00149c 	bl	1436d4 <__restore_sigs>
  13e460:	e1a00004 	mov	r0, r4
  13e464:	e28dd084 	add	sp, sp, #132	; 0x84
  13e468:	e8bd8030 	pop	{r4, r5, pc}
  13e46c:	e1a00003 	mov	r0, r3
  13e470:	eafffff6 	b	13e450 <raise+0x40>
  13e474:	0014e3dc 	.word	0x0014e3dc

0013e478 <fflush>:
  13e478:	e92d4070 	push	{r4, r5, r6, lr}
  13e47c:	e2504000 	subs	r4, r0, #0
  13e480:	e24dd008 	sub	sp, sp, #8
  13e484:	0a000027 	beq	13e528 <fflush+0xb0>
  13e488:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
  13e48c:	e3530000 	cmp	r3, #0
  13e490:	b3a05000 	movlt	r5, #0
  13e494:	aa000020 	bge	13e51c <fflush+0xa4>
  13e498:	e5942014 	ldr	r2, [r4, #20]
  13e49c:	e594301c 	ldr	r3, [r4, #28]
  13e4a0:	e1520003 	cmp	r2, r3
  13e4a4:	0a000007 	beq	13e4c8 <fflush+0x50>
  13e4a8:	e3a02000 	mov	r2, #0
  13e4ac:	e5943024 	ldr	r3, [r4, #36]	; 0x24
  13e4b0:	e1a01002 	mov	r1, r2
  13e4b4:	e1a00004 	mov	r0, r4
  13e4b8:	e12fff33 	blx	r3
  13e4bc:	e5943014 	ldr	r3, [r4, #20]
  13e4c0:	e3530000 	cmp	r3, #0
  13e4c4:	0a00003d 	beq	13e5c0 <fflush+0x148>
  13e4c8:	e994000c 	ldmib	r4, {r2, r3}
  13e4cc:	e1520003 	cmp	r2, r3
  13e4d0:	0a000006 	beq	13e4f0 <fflush+0x78>
  13e4d4:	e3a01001 	mov	r1, #1
  13e4d8:	e0422003 	sub	r2, r2, r3
  13e4dc:	e58d1000 	str	r1, [sp]
  13e4e0:	e5941028 	ldr	r1, [r4, #40]	; 0x28
  13e4e4:	e1a03fc2 	asr	r3, r2, #31
  13e4e8:	e1a00004 	mov	r0, r4
  13e4ec:	e12fff31 	blx	r1
  13e4f0:	e3a06000 	mov	r6, #0
  13e4f4:	e1550006 	cmp	r5, r6
  13e4f8:	e5846010 	str	r6, [r4, #16]
  13e4fc:	e584601c 	str	r6, [r4, #28]
  13e500:	e5846014 	str	r6, [r4, #20]
  13e504:	e5846008 	str	r6, [r4, #8]
  13e508:	e5846004 	str	r6, [r4, #4]
  13e50c:	1a000032 	bne	13e5dc <fflush+0x164>
  13e510:	e1a00005 	mov	r0, r5
  13e514:	e28dd008 	add	sp, sp, #8
  13e518:	e8bd8070 	pop	{r4, r5, r6, pc}
  13e51c:	eb001479 	bl	143708 <__lockfile>
  13e520:	e1a05000 	mov	r5, r0
  13e524:	eaffffdb 	b	13e498 <fflush+0x20>
  13e528:	e59f3104 	ldr	r3, [pc, #260]	; 13e634 <fflush+0x1bc>
  13e52c:	e5935000 	ldr	r5, [r3]
  13e530:	e3550000 	cmp	r5, #0
  13e534:	1a00003a 	bne	13e624 <fflush+0x1ac>
  13e538:	e59f30f8 	ldr	r3, [pc, #248]	; 13e638 <fflush+0x1c0>
  13e53c:	e5932000 	ldr	r2, [r3]
  13e540:	e3520000 	cmp	r2, #0
  13e544:	1a000032 	bne	13e614 <fflush+0x19c>
  13e548:	eb000047 	bl	13e66c <__ofl_lock>
  13e54c:	e5904000 	ldr	r4, [r0]
  13e550:	e3540000 	cmp	r4, #0
  13e554:	0a000009 	beq	13e580 <fflush+0x108>
  13e558:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
  13e55c:	e3530000 	cmp	r3, #0
  13e560:	aa00000a 	bge	13e590 <fflush+0x118>
  13e564:	e5942014 	ldr	r2, [r4, #20]
  13e568:	e594301c 	ldr	r3, [r4, #28]
  13e56c:	e1520003 	cmp	r2, r3
  13e570:	1a00001f 	bne	13e5f4 <fflush+0x17c>
  13e574:	e5944038 	ldr	r4, [r4, #56]	; 0x38
  13e578:	e3540000 	cmp	r4, #0
  13e57c:	1afffff5 	bne	13e558 <fflush+0xe0>
  13e580:	eb000040 	bl	13e688 <__ofl_unlock>
  13e584:	e1a00005 	mov	r0, r5
  13e588:	e28dd008 	add	sp, sp, #8
  13e58c:	e8bd8070 	pop	{r4, r5, r6, pc}
  13e590:	e1a00004 	mov	r0, r4
  13e594:	eb00145b 	bl	143708 <__lockfile>
  13e598:	e5942014 	ldr	r2, [r4, #20]
  13e59c:	e594301c 	ldr	r3, [r4, #28]
  13e5a0:	e1a06000 	mov	r6, r0
  13e5a4:	e1520003 	cmp	r2, r3
  13e5a8:	1a000015 	bne	13e604 <fflush+0x18c>
  13e5ac:	e3560000 	cmp	r6, #0
  13e5b0:	0affffef 	beq	13e574 <fflush+0xfc>
  13e5b4:	e1a00004 	mov	r0, r4
  13e5b8:	eb00149f 	bl	14383c <__unlockfile>
  13e5bc:	eaffffec 	b	13e574 <fflush+0xfc>
  13e5c0:	e3550000 	cmp	r5, #0
  13e5c4:	03e05000 	mvneq	r5, #0
  13e5c8:	0affffd0 	beq	13e510 <fflush+0x98>
  13e5cc:	e1a00004 	mov	r0, r4
  13e5d0:	eb001499 	bl	14383c <__unlockfile>
  13e5d4:	e3e05000 	mvn	r5, #0
  13e5d8:	eaffffcc 	b	13e510 <fflush+0x98>
  13e5dc:	e1a05006 	mov	r5, r6
  13e5e0:	e1a00004 	mov	r0, r4
  13e5e4:	eb001494 	bl	14383c <__unlockfile>
  13e5e8:	e1a00005 	mov	r0, r5
  13e5ec:	e28dd008 	add	sp, sp, #8
  13e5f0:	e8bd8070 	pop	{r4, r5, r6, pc}
  13e5f4:	e1a00004 	mov	r0, r4
  13e5f8:	ebffff9e 	bl	13e478 <fflush>
  13e5fc:	e1855000 	orr	r5, r5, r0
  13e600:	eaffffdb 	b	13e574 <fflush+0xfc>
  13e604:	e1a00004 	mov	r0, r4
  13e608:	ebffff9a 	bl	13e478 <fflush>
  13e60c:	e1855000 	orr	r5, r5, r0
  13e610:	eaffffe5 	b	13e5ac <fflush+0x134>
  13e614:	e5930000 	ldr	r0, [r3]
  13e618:	ebffff96 	bl	13e478 <fflush>
  13e61c:	e1855000 	orr	r5, r5, r0
  13e620:	eaffffc8 	b	13e548 <fflush+0xd0>
  13e624:	e5930000 	ldr	r0, [r3]
  13e628:	ebffff92 	bl	13e478 <fflush>
  13e62c:	e1a05000 	mov	r5, r0
  13e630:	eaffffc0 	b	13e538 <fflush+0xc0>
  13e634:	0014e3d0 	.word	0x0014e3d0
  13e638:	0014e338 	.word	0x0014e338

0013e63c <fprintf>:
  13e63c:	e92d000e 	push	{r1, r2, r3}
  13e640:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13e644:	e24dd008 	sub	sp, sp, #8
  13e648:	e28d3010 	add	r3, sp, #16
  13e64c:	e1a02003 	mov	r2, r3
  13e650:	e59d100c 	ldr	r1, [sp, #12]
  13e654:	e58d3004 	str	r3, [sp, #4]
  13e658:	eb000959 	bl	140bc4 <vfprintf>
  13e65c:	e28dd008 	add	sp, sp, #8
  13e660:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  13e664:	e28dd00c 	add	sp, sp, #12
  13e668:	e12fff1e 	bx	lr

0013e66c <__ofl_lock>:
  13e66c:	e92d4010 	push	{r4, lr}
  13e670:	e59f0008 	ldr	r0, [pc, #8]	; 13e680 <__ofl_lock+0x14>
  13e674:	eb000db3 	bl	141d48 <__lock>
  13e678:	e59f0004 	ldr	r0, [pc, #4]	; 13e684 <__ofl_lock+0x18>
  13e67c:	e8bd8010 	pop	{r4, pc}
  13e680:	00150050 	.word	0x00150050
  13e684:	0015004c 	.word	0x0015004c

0013e688 <__ofl_unlock>:
  13e688:	e59f0000 	ldr	r0, [pc]	; 13e690 <__ofl_unlock+0x8>
  13e68c:	ea000e05 	b	141ea8 <__unlock>
  13e690:	00150050 	.word	0x00150050

0013e694 <perror>:
  13e694:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  13e698:	e1a05000 	mov	r5, r0
  13e69c:	ebffea8d 	bl	1390d8 <__errno_location>
  13e6a0:	e5900000 	ldr	r0, [r0]
  13e6a4:	ebffeaad 	bl	139160 <strerror>
  13e6a8:	e59f4104 	ldr	r4, [pc, #260]	; 13e7b4 <perror+0x120>
  13e6ac:	e1a06000 	mov	r6, r0
  13e6b0:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
  13e6b4:	e3530000 	cmp	r3, #0
  13e6b8:	aa000026 	bge	13e758 <perror+0xc4>
  13e6bc:	e3550000 	cmp	r5, #0
  13e6c0:	e5947088 	ldr	r7, [r4, #136]	; 0x88
  13e6c4:	e5948048 	ldr	r8, [r4, #72]	; 0x48
  13e6c8:	13a09000 	movne	r9, #0
  13e6cc:	0a00002c 	beq	13e784 <perror+0xf0>
  13e6d0:	e5d53000 	ldrb	r3, [r5]
  13e6d4:	e3530000 	cmp	r3, #0
  13e6d8:	1a000010 	bne	13e720 <perror+0x8c>
  13e6dc:	e1a00006 	mov	r0, r6
  13e6e0:	eb000bf4 	bl	1416b8 <strlen>
  13e6e4:	e59f30c8 	ldr	r3, [pc, #200]	; 13e7b4 <perror+0x120>
  13e6e8:	e1a01000 	mov	r1, r0
  13e6ec:	e3a02001 	mov	r2, #1
  13e6f0:	e1a00006 	mov	r0, r6
  13e6f4:	eb001601 	bl	143f00 <fwrite>
  13e6f8:	e59f10b4 	ldr	r1, [pc, #180]	; 13e7b4 <perror+0x120>
  13e6fc:	e3a0000a 	mov	r0, #10
  13e700:	eb00157f 	bl	143d04 <fputc>
  13e704:	e3590000 	cmp	r9, #0
  13e708:	e5848048 	str	r8, [r4, #72]	; 0x48
  13e70c:	e5847088 	str	r7, [r4, #136]	; 0x88
  13e710:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
  13e714:	e59f0098 	ldr	r0, [pc, #152]	; 13e7b4 <perror+0x120>
  13e718:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
  13e71c:	ea001446 	b	14383c <__unlockfile>
  13e720:	e1a00005 	mov	r0, r5
  13e724:	eb000be3 	bl	1416b8 <strlen>
  13e728:	e59f3084 	ldr	r3, [pc, #132]	; 13e7b4 <perror+0x120>
  13e72c:	e1a01000 	mov	r1, r0
  13e730:	e3a02001 	mov	r2, #1
  13e734:	e1a00005 	mov	r0, r5
  13e738:	eb0015f0 	bl	143f00 <fwrite>
  13e73c:	e59f1070 	ldr	r1, [pc, #112]	; 13e7b4 <perror+0x120>
  13e740:	e3a0003a 	mov	r0, #58	; 0x3a
  13e744:	eb00156e 	bl	143d04 <fputc>
  13e748:	e59f1064 	ldr	r1, [pc, #100]	; 13e7b4 <perror+0x120>
  13e74c:	e3a00020 	mov	r0, #32
  13e750:	eb00156b 	bl	143d04 <fputc>
  13e754:	eaffffe0 	b	13e6dc <perror+0x48>
  13e758:	e1a00004 	mov	r0, r4
  13e75c:	eb0013e9 	bl	143708 <__lockfile>
  13e760:	e3550000 	cmp	r5, #0
  13e764:	e1a09000 	mov	r9, r0
  13e768:	e5947088 	ldr	r7, [r4, #136]	; 0x88
  13e76c:	e5948048 	ldr	r8, [r4, #72]	; 0x48
  13e770:	0affffd9 	beq	13e6dc <perror+0x48>
  13e774:	e5d53000 	ldrb	r3, [r5]
  13e778:	e3530000 	cmp	r3, #0
  13e77c:	0affffd6 	beq	13e6dc <perror+0x48>
  13e780:	eaffffe6 	b	13e720 <perror+0x8c>
  13e784:	eb000bcb 	bl	1416b8 <strlen>
  13e788:	e1a03004 	mov	r3, r4
  13e78c:	e1a01000 	mov	r1, r0
  13e790:	e3a02001 	mov	r2, #1
  13e794:	e1a00006 	mov	r0, r6
  13e798:	eb0015d8 	bl	143f00 <fwrite>
  13e79c:	e1a01004 	mov	r1, r4
  13e7a0:	e3a0000a 	mov	r0, #10
  13e7a4:	eb001556 	bl	143d04 <fputc>
  13e7a8:	e5848048 	str	r8, [r4, #72]	; 0x48
  13e7ac:	e5847088 	str	r7, [r4, #136]	; 0x88
  13e7b0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  13e7b4:	0014e2a8 	.word	0x0014e2a8

0013e7b8 <printf>:
  13e7b8:	e92d000f 	push	{r0, r1, r2, r3}
  13e7bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  13e7c0:	e24dd00c 	sub	sp, sp, #12
  13e7c4:	e28d3014 	add	r3, sp, #20
  13e7c8:	e1a02003 	mov	r2, r3
  13e7cc:	e59d1010 	ldr	r1, [sp, #16]
  13e7d0:	e59f0014 	ldr	r0, [pc, #20]	; 13e7ec <printf+0x34>
  13e7d4:	e58d3004 	str	r3, [sp, #4]
  13e7d8:	eb0008f9 	bl	140bc4 <vfprintf>
  13e7dc:	e28dd00c 	add	sp, sp, #12
  13e7e0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  13e7e4:	e28dd010 	add	sp, sp, #16
  13e7e8:	e12fff1e 	bx	lr
  13e7ec:	0014e340 	.word	0x0014e340

0013e7f0 <puts>:
  13e7f0:	e92d4070 	push	{r4, r5, r6, lr}
  13e7f4:	e59f40b0 	ldr	r4, [pc, #176]	; 13e8ac <puts+0xbc>
  13e7f8:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
  13e7fc:	e3530000 	cmp	r3, #0
  13e800:	aa00001b 	bge	13e874 <puts+0x84>
  13e804:	e1a01004 	mov	r1, r4
  13e808:	eb001570 	bl	143dd0 <fputs>
  13e80c:	e3500000 	cmp	r0, #0
  13e810:	a3a05000 	movge	r5, #0
  13e814:	ba000021 	blt	13e8a0 <puts+0xb0>
  13e818:	e5943050 	ldr	r3, [r4, #80]	; 0x50
  13e81c:	e353000a 	cmp	r3, #10
  13e820:	0a00000e 	beq	13e860 <puts+0x70>
  13e824:	e5943014 	ldr	r3, [r4, #20]
  13e828:	e5942010 	ldr	r2, [r4, #16]
  13e82c:	e1530002 	cmp	r3, r2
  13e830:	0a00000a 	beq	13e860 <puts+0x70>
  13e834:	e3a0200a 	mov	r2, #10
  13e838:	e2831001 	add	r1, r3, #1
  13e83c:	e5841014 	str	r1, [r4, #20]
  13e840:	e3a04000 	mov	r4, #0
  13e844:	e5c32000 	strb	r2, [r3]
  13e848:	e3550000 	cmp	r5, #0
  13e84c:	0a000001 	beq	13e858 <puts+0x68>
  13e850:	e59f0054 	ldr	r0, [pc, #84]	; 13e8ac <puts+0xbc>
  13e854:	eb0013f8 	bl	14383c <__unlockfile>
  13e858:	e1a00004 	mov	r0, r4
  13e85c:	e8bd8070 	pop	{r4, r5, r6, pc}
  13e860:	e3a0100a 	mov	r1, #10
  13e864:	e59f0040 	ldr	r0, [pc, #64]	; 13e8ac <puts+0xbc>
  13e868:	eb001419 	bl	1438d4 <__overflow>
  13e86c:	e1a04fc0 	asr	r4, r0, #31
  13e870:	eafffff4 	b	13e848 <puts+0x58>
  13e874:	e1a06000 	mov	r6, r0
  13e878:	e1a00004 	mov	r0, r4
  13e87c:	eb0013a1 	bl	143708 <__lockfile>
  13e880:	e1a01004 	mov	r1, r4
  13e884:	e1a05000 	mov	r5, r0
  13e888:	e1a00006 	mov	r0, r6
  13e88c:	eb00154f 	bl	143dd0 <fputs>
  13e890:	e3500000 	cmp	r0, #0
  13e894:	b3e04000 	mvnlt	r4, #0
  13e898:	aaffffde 	bge	13e818 <puts+0x28>
  13e89c:	eaffffe9 	b	13e848 <puts+0x58>
  13e8a0:	e3e04000 	mvn	r4, #0
  13e8a4:	e1a00004 	mov	r0, r4
  13e8a8:	e8bd8070 	pop	{r4, r5, r6, pc}
  13e8ac:	0014e340 	.word	0x0014e340

0013e8b0 <pop_arg>:
  13e8b0:	e2411009 	sub	r1, r1, #9
  13e8b4:	e92d0030 	push	{r4, r5}
  13e8b8:	e3510011 	cmp	r1, #17
  13e8bc:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
  13e8c0:	ea000018 	b	13e928 <pop_arg+0x78>
  13e8c4:	0013e9f0 	.word	0x0013e9f0
  13e8c8:	0013e954 	.word	0x0013e954
  13e8cc:	0013e974 	.word	0x0013e974
  13e8d0:	0013e930 	.word	0x0013e930
  13e8d4:	0013e954 	.word	0x0013e954
  13e8d8:	0013e974 	.word	0x0013e974
  13e8dc:	0013ea28 	.word	0x0013ea28
  13e8e0:	0013e998 	.word	0x0013e998
  13e8e4:	0013e9b8 	.word	0x0013e9b8
  13e8e8:	0013e9d4 	.word	0x0013e9d4
  13e8ec:	0013e930 	.word	0x0013e930
  13e8f0:	0013e974 	.word	0x0013e974
  13e8f4:	0013e930 	.word	0x0013e930
  13e8f8:	0013e930 	.word	0x0013e930
  13e8fc:	0013e954 	.word	0x0013e954
  13e900:	0013ea08 	.word	0x0013ea08
  13e904:	0013e90c 	.word	0x0013e90c
  13e908:	0013e90c 	.word	0x0013e90c
  13e90c:	e5923000 	ldr	r3, [r2]
  13e910:	e2833007 	add	r3, r3, #7
  13e914:	e3c33007 	bic	r3, r3, #7
  13e918:	e2831008 	add	r1, r3, #8
  13e91c:	e5821000 	str	r1, [r2]
  13e920:	e893000c 	ldm	r3, {r2, r3}
  13e924:	e880000c 	stm	r0, {r2, r3}
  13e928:	e8bd0030 	pop	{r4, r5}
  13e92c:	e12fff1e 	bx	lr
  13e930:	e5923000 	ldr	r3, [r2]
  13e934:	e8bd0030 	pop	{r4, r5}
  13e938:	e2833007 	add	r3, r3, #7
  13e93c:	e3c33007 	bic	r3, r3, #7
  13e940:	e2831008 	add	r1, r3, #8
  13e944:	e5821000 	str	r1, [r2]
  13e948:	e893000c 	ldm	r3, {r2, r3}
  13e94c:	e880000c 	stm	r0, {r2, r3}
  13e950:	e12fff1e 	bx	lr
  13e954:	e5923000 	ldr	r3, [r2]
  13e958:	e5934000 	ldr	r4, [r3]
  13e95c:	e2833004 	add	r3, r3, #4
  13e960:	e1a05fc4 	asr	r5, r4, #31
  13e964:	e5823000 	str	r3, [r2]
  13e968:	e8800030 	stm	r0, {r4, r5}
  13e96c:	e8bd0030 	pop	{r4, r5}
  13e970:	e12fff1e 	bx	lr
  13e974:	e3a01000 	mov	r1, #0
  13e978:	e8bd0030 	pop	{r4, r5}
  13e97c:	e5923000 	ldr	r3, [r2]
  13e980:	e593c000 	ldr	ip, [r3]
  13e984:	e2833004 	add	r3, r3, #4
  13e988:	e5823000 	str	r3, [r2]
  13e98c:	e580c000 	str	ip, [r0]
  13e990:	e5801004 	str	r1, [r0, #4]
  13e994:	e12fff1e 	bx	lr
  13e998:	e3a01000 	mov	r1, #0
  13e99c:	e5923000 	ldr	r3, [r2]
  13e9a0:	e1d3c0b0 	ldrh	ip, [r3]
  13e9a4:	e2833004 	add	r3, r3, #4
  13e9a8:	e5823000 	str	r3, [r2]
  13e9ac:	e580c000 	str	ip, [r0]
  13e9b0:	e5801004 	str	r1, [r0, #4]
  13e9b4:	eaffffdb 	b	13e928 <pop_arg+0x78>
  13e9b8:	e5923000 	ldr	r3, [r2]
  13e9bc:	e1d340d0 	ldrsb	r4, [r3]
  13e9c0:	e2833004 	add	r3, r3, #4
  13e9c4:	e1a05fc4 	asr	r5, r4, #31
  13e9c8:	e5823000 	str	r3, [r2]
  13e9cc:	e8800030 	stm	r0, {r4, r5}
  13e9d0:	eaffffd4 	b	13e928 <pop_arg+0x78>
  13e9d4:	e3a05000 	mov	r5, #0
  13e9d8:	e5923000 	ldr	r3, [r2]
  13e9dc:	e5d34000 	ldrb	r4, [r3]
  13e9e0:	e2833004 	add	r3, r3, #4
  13e9e4:	e5823000 	str	r3, [r2]
  13e9e8:	e8800030 	stm	r0, {r4, r5}
  13e9ec:	eaffffcd 	b	13e928 <pop_arg+0x78>
  13e9f0:	e5923000 	ldr	r3, [r2]
  13e9f4:	e2831004 	add	r1, r3, #4
  13e9f8:	e5821000 	str	r1, [r2]
  13e9fc:	e5933000 	ldr	r3, [r3]
  13ea00:	e5803000 	str	r3, [r0]
  13ea04:	eaffffc7 	b	13e928 <pop_arg+0x78>
  13ea08:	e3a01000 	mov	r1, #0
  13ea0c:	e5923000 	ldr	r3, [r2]
  13ea10:	e283c004 	add	ip, r3, #4
  13ea14:	e582c000 	str	ip, [r2]
  13ea18:	e5933000 	ldr	r3, [r3]
  13ea1c:	e5801004 	str	r1, [r0, #4]
  13ea20:	e5803000 	str	r3, [r0]
  13ea24:	eaffffbf 	b	13e928 <pop_arg+0x78>
  13ea28:	e5923000 	ldr	r3, [r2]
  13ea2c:	e1d340f0 	ldrsh	r4, [r3]
  13ea30:	e2833004 	add	r3, r3, #4
  13ea34:	e1a05fc4 	asr	r5, r4, #31
  13ea38:	e5823000 	str	r3, [r2]
  13ea3c:	e8800030 	stm	r0, {r4, r5}
  13ea40:	eaffffb8 	b	13e928 <pop_arg+0x78>

0013ea44 <pad.part.0>:
  13ea44:	e92d4070 	push	{r4, r5, r6, lr}
  13ea48:	e0425003 	sub	r5, r2, r3
  13ea4c:	e3550c01 	cmp	r5, #256	; 0x100
  13ea50:	e24ddc01 	sub	sp, sp, #256	; 0x100
  13ea54:	31a02005 	movcc	r2, r5
  13ea58:	23a02c01 	movcs	r2, #256	; 0x100
  13ea5c:	e1a06000 	mov	r6, r0
  13ea60:	e1a0000d 	mov	r0, sp
  13ea64:	eb000a82 	bl	141474 <memset>
  13ea68:	e35500ff 	cmp	r5, #255	; 0xff
  13ea6c:	9a00001b 	bls	13eae0 <pad.part.0+0x9c>
  13ea70:	e5962000 	ldr	r2, [r6]
  13ea74:	e1a04005 	mov	r4, r5
  13ea78:	e2022020 	and	r2, r2, #32
  13ea7c:	ea000001 	b	13ea88 <pad.part.0+0x44>
  13ea80:	e35400ff 	cmp	r4, #255	; 0xff
  13ea84:	9a00000c 	bls	13eabc <pad.part.0+0x78>
  13ea88:	e3520000 	cmp	r2, #0
  13ea8c:	e2444c01 	sub	r4, r4, #256	; 0x100
  13ea90:	e1a01002 	mov	r1, r2
  13ea94:	1afffff9 	bne	13ea80 <pad.part.0+0x3c>
  13ea98:	e1a02006 	mov	r2, r6
  13ea9c:	e3a01c01 	mov	r1, #256	; 0x100
  13eaa0:	e1a0000d 	mov	r0, sp
  13eaa4:	eb0014d6 	bl	143e04 <__fwritex>
  13eaa8:	e5962000 	ldr	r2, [r6]
  13eaac:	e35400ff 	cmp	r4, #255	; 0xff
  13eab0:	e2022020 	and	r2, r2, #32
  13eab4:	e1a01002 	mov	r1, r2
  13eab8:	8afffff2 	bhi	13ea88 <pad.part.0+0x44>
  13eabc:	e20550ff 	and	r5, r5, #255	; 0xff
  13eac0:	e3510000 	cmp	r1, #0
  13eac4:	1a000003 	bne	13ead8 <pad.part.0+0x94>
  13eac8:	e1a02006 	mov	r2, r6
  13eacc:	e1a01005 	mov	r1, r5
  13ead0:	e1a0000d 	mov	r0, sp
  13ead4:	eb0014ca 	bl	143e04 <__fwritex>
  13ead8:	e28ddc01 	add	sp, sp, #256	; 0x100
  13eadc:	e8bd8070 	pop	{r4, r5, r6, pc}
  13eae0:	e5961000 	ldr	r1, [r6]
  13eae4:	e2011020 	and	r1, r1, #32
  13eae8:	eafffff4 	b	13eac0 <pad.part.0+0x7c>
  13eaec:	00000000 	andeq	r0, r0, r0

0013eaf0 <printf_core>:
  13eaf0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  13eaf4:	e3a0a000 	mov	sl, #0
  13eaf8:	e1a0b001 	mov	fp, r1
  13eafc:	e24ddfb3 	sub	sp, sp, #716	; 0x2cc
  13eb00:	e58d0004 	str	r0, [sp, #4]
  13eb04:	e58d2018 	str	r2, [sp, #24]
  13eb08:	e58d3028 	str	r3, [sp, #40]	; 0x28
  13eb0c:	e58da000 	str	sl, [sp]
  13eb10:	e58da00c 	str	sl, [sp, #12]
  13eb14:	e59d2000 	ldr	r2, [sp]
  13eb18:	e5db3000 	ldrb	r3, [fp]
  13eb1c:	e082200a 	add	r2, r2, sl
  13eb20:	e3530000 	cmp	r3, #0
  13eb24:	e58d2000 	str	r2, [sp]
  13eb28:	0a0001c8 	beq	13f250 <printf_core+0x760>
  13eb2c:	e3530025 	cmp	r3, #37	; 0x25
  13eb30:	e1a0300b 	mov	r3, fp
  13eb34:	0a000005 	beq	13eb50 <printf_core+0x60>
  13eb38:	e5f32001 	ldrb	r2, [r3, #1]!
  13eb3c:	e3520000 	cmp	r2, #0
  13eb40:	13520025 	cmpne	r2, #37	; 0x25
  13eb44:	1afffffb 	bne	13eb38 <printf_core+0x48>
  13eb48:	e3520025 	cmp	r2, #37	; 0x25
  13eb4c:	1a00019c 	bne	13f1c4 <printf_core+0x6d4>
  13eb50:	e5d32001 	ldrb	r2, [r3, #1]
  13eb54:	e1a04003 	mov	r4, r3
  13eb58:	e3520025 	cmp	r2, #37	; 0x25
  13eb5c:	0a000003 	beq	13eb70 <printf_core+0x80>
  13eb60:	ea000006 	b	13eb80 <printf_core+0x90>
  13eb64:	e5d42001 	ldrb	r2, [r4, #1]
  13eb68:	e3520025 	cmp	r2, #37	; 0x25
  13eb6c:	1a000003 	bne	13eb80 <printf_core+0x90>
  13eb70:	e5f42002 	ldrb	r2, [r4, #2]!
  13eb74:	e2833001 	add	r3, r3, #1
  13eb78:	e3520025 	cmp	r2, #37	; 0x25
  13eb7c:	0afffff8 	beq	13eb64 <printf_core+0x74>
  13eb80:	e3e02102 	mvn	r2, #-2147483648	; 0x80000000
  13eb84:	e043a00b 	sub	sl, r3, fp
  13eb88:	e59d3000 	ldr	r3, [sp]
  13eb8c:	e0423003 	sub	r3, r2, r3
  13eb90:	e15a0003 	cmp	sl, r3
  13eb94:	e58d3008 	str	r3, [sp, #8]
  13eb98:	ca000181 	bgt	13f1a4 <printf_core+0x6b4>
  13eb9c:	e59d3004 	ldr	r3, [sp, #4]
  13eba0:	e3530000 	cmp	r3, #0
  13eba4:	0a000002 	beq	13ebb4 <printf_core+0xc4>
  13eba8:	e5933000 	ldr	r3, [r3]
  13ebac:	e3130020 	tst	r3, #32
  13ebb0:	0a000146 	beq	13f0d0 <printf_core+0x5e0>
  13ebb4:	e35a0000 	cmp	sl, #0
  13ebb8:	1a0000b7 	bne	13ee9c <printf_core+0x3ac>
  13ebbc:	e5d42001 	ldrb	r2, [r4, #1]
  13ebc0:	e242c030 	sub	ip, r2, #48	; 0x30
  13ebc4:	e35c0009 	cmp	ip, #9
  13ebc8:	8a000002 	bhi	13ebd8 <printf_core+0xe8>
  13ebcc:	e5d43002 	ldrb	r3, [r4, #2]
  13ebd0:	e3530024 	cmp	r3, #36	; 0x24
  13ebd4:	0a000194 	beq	13f22c <printf_core+0x73c>
  13ebd8:	e2423020 	sub	r3, r2, #32
  13ebdc:	e353001f 	cmp	r3, #31
  13ebe0:	e3e0c000 	mvn	ip, #0
  13ebe4:	e2846001 	add	r6, r4, #1
  13ebe8:	8a000196 	bhi	13f248 <printf_core+0x758>
  13ebec:	e59f0f44 	ldr	r0, [pc, #3908]	; 13fb38 <printf_core+0x1048>
  13ebf0:	e1a01330 	lsr	r1, r0, r3
  13ebf4:	e2118001 	ands	r8, r1, #1
  13ebf8:	0a00000a 	beq	13ec28 <printf_core+0x138>
  13ebfc:	e3a08000 	mov	r8, #0
  13ec00:	e3a0e001 	mov	lr, #1
  13ec04:	ea000002 	b	13ec14 <printf_core+0x124>
  13ec08:	e1a01330 	lsr	r1, r0, r3
  13ec0c:	e3110001 	tst	r1, #1
  13ec10:	0a000004 	beq	13ec28 <printf_core+0x138>
  13ec14:	e5f62001 	ldrb	r2, [r6, #1]!
  13ec18:	e188831e 	orr	r8, r8, lr, lsl r3
  13ec1c:	e2423020 	sub	r3, r2, #32
  13ec20:	e353001f 	cmp	r3, #31
  13ec24:	9afffff7 	bls	13ec08 <printf_core+0x118>
  13ec28:	e352002a 	cmp	r2, #42	; 0x2a
  13ec2c:	0a00009c 	beq	13eea4 <printf_core+0x3b4>
  13ec30:	e5d61000 	ldrb	r1, [r6]
  13ec34:	e2413030 	sub	r3, r1, #48	; 0x30
  13ec38:	e3530009 	cmp	r3, #9
  13ec3c:	81a02001 	movhi	r2, r1
  13ec40:	83a09000 	movhi	r9, #0
  13ec44:	8a000012 	bhi	13ec94 <printf_core+0x1a4>
  13ec48:	e3a09000 	mov	r9, #0
  13ec4c:	e59f0ee8 	ldr	r0, [pc, #3816]	; 13fb3c <printf_core+0x104c>
  13ec50:	e0693e89 	rsb	r3, r9, r9, lsl #29
  13ec54:	e0693103 	rsb	r3, r9, r3, lsl #2
  13ec58:	e5f62001 	ldrb	r2, [r6, #1]!
  13ec5c:	e1a03083 	lsl	r3, r3, #1
  13ec60:	e1590000 	cmp	r9, r0
  13ec64:	e2411030 	sub	r1, r1, #48	; 0x30
  13ec68:	e2433106 	sub	r3, r3, #-2147483647	; 0x80000001
  13ec6c:	e242e030 	sub	lr, r2, #48	; 0x30
  13ec70:	8a000025 	bhi	13ed0c <printf_core+0x21c>
  13ec74:	e1510003 	cmp	r1, r3
  13ec78:	e0899109 	add	r9, r9, r9, lsl #2
  13ec7c:	ca000022 	bgt	13ed0c <printf_core+0x21c>
  13ec80:	e35e0009 	cmp	lr, #9
  13ec84:	e0819089 	add	r9, r1, r9, lsl #1
  13ec88:	9a000022 	bls	13ed18 <printf_core+0x228>
  13ec8c:	e3590000 	cmp	r9, #0
  13ec90:	ba000143 	blt	13f1a4 <printf_core+0x6b4>
  13ec94:	e352002e 	cmp	r2, #46	; 0x2e
  13ec98:	1a000097 	bne	13eefc <printf_core+0x40c>
  13ec9c:	e5d62001 	ldrb	r2, [r6, #1]
  13eca0:	e352002a 	cmp	r2, #42	; 0x2a
  13eca4:	1a00011e 	bne	13f124 <printf_core+0x634>
  13eca8:	e5d62002 	ldrb	r2, [r6, #2]
  13ecac:	e2423030 	sub	r3, r2, #48	; 0x30
  13ecb0:	e3530009 	cmp	r3, #9
  13ecb4:	8a000002 	bhi	13ecc4 <printf_core+0x1d4>
  13ecb8:	e5d63003 	ldrb	r3, [r6, #3]
  13ecbc:	e3530024 	cmp	r3, #36	; 0x24
  13ecc0:	0a000143 	beq	13f1d4 <printf_core+0x6e4>
  13ecc4:	e59d300c 	ldr	r3, [sp, #12]
  13ecc8:	e3530000 	cmp	r3, #0
  13eccc:	1a00009f 	bne	13ef50 <printf_core+0x460>
  13ecd0:	e59d3004 	ldr	r3, [sp, #4]
  13ecd4:	e2866002 	add	r6, r6, #2
  13ecd8:	e3530000 	cmp	r3, #0
  13ecdc:	159d1018 	ldrne	r1, [sp, #24]
  13ece0:	03a03001 	moveq	r3, #1
  13ece4:	15913000 	ldrne	r3, [r1]
  13ece8:	059d5004 	ldreq	r5, [sp, #4]
  13ecec:	15935000 	ldrne	r5, [r3]
  13ecf0:	12832004 	addne	r2, r3, #4
  13ecf4:	11e03005 	mvnne	r3, r5
  13ecf8:	15812000 	strne	r2, [r1]
  13ecfc:	11a03fa3 	lsrne	r3, r3, #31
  13ed00:	15d62000 	ldrbne	r2, [r6]
  13ed04:	e58d301c 	str	r3, [sp, #28]
  13ed08:	ea00007e 	b	13ef08 <printf_core+0x418>
  13ed0c:	e35e0009 	cmp	lr, #9
  13ed10:	8a000123 	bhi	13f1a4 <printf_core+0x6b4>
  13ed14:	e3e09000 	mvn	r9, #0
  13ed18:	e1a01002 	mov	r1, r2
  13ed1c:	eaffffcb 	b	13ec50 <printf_core+0x160>
  13ed20:	e28d3070 	add	r3, sp, #112	; 0x70
  13ed24:	e893000c 	ldm	r3, {r2, r3}
  13ed28:	e28da0d0 	add	sl, sp, #208	; 0xd0
  13ed2c:	e1921003 	orrs	r1, r2, r3
  13ed30:	e1a0b00a 	mov	fp, sl
  13ed34:	0a000009 	beq	13ed60 <printf_core+0x270>
  13ed38:	e1a001a2 	lsr	r0, r2, #3
  13ed3c:	e1800e83 	orr	r0, r0, r3, lsl #29
  13ed40:	e1a0c1a3 	lsr	ip, r3, #3
  13ed44:	e2021007 	and	r1, r2, #7
  13ed48:	e1a0300c 	mov	r3, ip
  13ed4c:	e1a02000 	mov	r2, r0
  13ed50:	e2811030 	add	r1, r1, #48	; 0x30
  13ed54:	e1920003 	orrs	r0, r2, r3
  13ed58:	e56b1001 	strb	r1, [fp, #-1]!
  13ed5c:	1afffff5 	bne	13ed38 <printf_core+0x248>
  13ed60:	e2183008 	ands	r3, r8, #8
  13ed64:	0a00026f 	beq	13f728 <printf_core+0xc38>
  13ed68:	e04a300b 	sub	r3, sl, fp
  13ed6c:	e1530005 	cmp	r3, r5
  13ed70:	ba00026b 	blt	13f724 <printf_core+0xc34>
  13ed74:	e2835001 	add	r5, r3, #1
  13ed78:	e3a03000 	mov	r3, #0
  13ed7c:	e58d3020 	str	r3, [sp, #32]
  13ed80:	e59f3db8 	ldr	r3, [pc, #3512]	; 13fb40 <printf_core+0x1050>
  13ed84:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  13ed88:	e59d301c 	ldr	r3, [sp, #28]
  13ed8c:	e0132fa5 	ands	r2, r3, r5, lsr #31
  13ed90:	1a000103 	bne	13f1a4 <printf_core+0x6b4>
  13ed94:	e59d2070 	ldr	r2, [sp, #112]	; 0x70
  13ed98:	e3530000 	cmp	r3, #0
  13ed9c:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
  13eda0:	13c88801 	bicne	r8, r8, #65536	; 0x10000
  13eda4:	e1923003 	orrs	r3, r2, r3
  13eda8:	03a03001 	moveq	r3, #1
  13edac:	13a03000 	movne	r3, #0
  13edb0:	e3550000 	cmp	r5, #0
  13edb4:	01a02003 	moveq	r2, r3
  13edb8:	13a02000 	movne	r2, #0
  13edbc:	e3520000 	cmp	r2, #0
  13edc0:	1a0002a8 	bne	13f868 <printf_core+0xd78>
  13edc4:	e04a600b 	sub	r6, sl, fp
  13edc8:	e1560005 	cmp	r6, r5
  13edcc:	a1a05006 	movge	r5, r6
  13edd0:	e0833006 	add	r3, r3, r6
  13edd4:	e1530005 	cmp	r3, r5
  13edd8:	e3e02102 	mvn	r2, #-2147483648	; 0x80000000
  13eddc:	a1a05003 	movge	r5, r3
  13ede0:	e59d3020 	ldr	r3, [sp, #32]
  13ede4:	e0423003 	sub	r3, r2, r3
  13ede8:	e1530005 	cmp	r3, r5
  13edec:	ba0000ec 	blt	13f1a4 <printf_core+0x6b4>
  13edf0:	e59d3020 	ldr	r3, [sp, #32]
  13edf4:	e0857003 	add	r7, r5, r3
  13edf8:	e1570009 	cmp	r7, r9
  13edfc:	a1a0a007 	movge	sl, r7
  13ee00:	b1a0a009 	movlt	sl, r9
  13ee04:	e59d3008 	ldr	r3, [sp, #8]
  13ee08:	e153000a 	cmp	r3, sl
  13ee0c:	ba0000e4 	blt	13f1a4 <printf_core+0x6b4>
  13ee10:	e157000a 	cmp	r7, sl
  13ee14:	b3a09000 	movlt	r9, #0
  13ee18:	a3a09001 	movge	r9, #1
  13ee1c:	e3180a12 	tst	r8, #73728	; 0x12000
  13ee20:	01a03009 	moveq	r3, r9
  13ee24:	13a03001 	movne	r3, #1
  13ee28:	e3530000 	cmp	r3, #0
  13ee2c:	0a000281 	beq	13f838 <printf_core+0xd48>
  13ee30:	e59d3004 	ldr	r3, [sp, #4]
  13ee34:	e5933000 	ldr	r3, [r3]
  13ee38:	e3130020 	tst	r3, #32
  13ee3c:	0a000233 	beq	13f710 <printf_core+0xc20>
  13ee40:	e2283801 	eor	r3, r8, #65536	; 0x10000
  13ee44:	e3130a12 	tst	r3, #73728	; 0x12000
  13ee48:	01a03009 	moveq	r3, r9
  13ee4c:	13a03001 	movne	r3, #1
  13ee50:	e3530000 	cmp	r3, #0
  13ee54:	0a00027d 	beq	13f850 <printf_core+0xd60>
  13ee58:	e1550006 	cmp	r5, r6
  13ee5c:	ca000225 	bgt	13f6f8 <printf_core+0xc08>
  13ee60:	e59d3004 	ldr	r3, [sp, #4]
  13ee64:	e5933000 	ldr	r3, [r3]
  13ee68:	e3130020 	tst	r3, #32
  13ee6c:	0a00021c 	beq	13f6e4 <printf_core+0xbf4>
  13ee70:	e2283a02 	eor	r3, r8, #8192	; 0x2000
  13ee74:	e3130a12 	tst	r3, #73728	; 0x12000
  13ee78:	01a03009 	moveq	r3, r9
  13ee7c:	13a03001 	movne	r3, #1
  13ee80:	e3530000 	cmp	r3, #0
  13ee84:	1a000004 	bne	13ee9c <printf_core+0x3ac>
  13ee88:	e1a03007 	mov	r3, r7
  13ee8c:	e1a0200a 	mov	r2, sl
  13ee90:	e3a01020 	mov	r1, #32
  13ee94:	e59d0004 	ldr	r0, [sp, #4]
  13ee98:	ebfffee9 	bl	13ea44 <pad.part.0>
  13ee9c:	e1a0b004 	mov	fp, r4
  13eea0:	eaffff1b 	b	13eb14 <printf_core+0x24>
  13eea4:	e5d62001 	ldrb	r2, [r6, #1]
  13eea8:	e2423030 	sub	r3, r2, #48	; 0x30
  13eeac:	e3530009 	cmp	r3, #9
  13eeb0:	9a00008b 	bls	13f0e4 <printf_core+0x5f4>
  13eeb4:	e59d300c 	ldr	r3, [sp, #12]
  13eeb8:	e3530000 	cmp	r3, #0
  13eebc:	1a000023 	bne	13ef50 <printf_core+0x460>
  13eec0:	e59d3004 	ldr	r3, [sp, #4]
  13eec4:	e2866001 	add	r6, r6, #1
  13eec8:	e3530000 	cmp	r3, #0
  13eecc:	0a0000be 	beq	13f1cc <printf_core+0x6dc>
  13eed0:	e59d1018 	ldr	r1, [sp, #24]
  13eed4:	e5913000 	ldr	r3, [r1]
  13eed8:	e2832004 	add	r2, r3, #4
  13eedc:	e5939000 	ldr	r9, [r3]
  13eee0:	e5812000 	str	r2, [r1]
  13eee4:	e5d62000 	ldrb	r2, [r6]
  13eee8:	e3590000 	cmp	r9, #0
  13eeec:	b3888a02 	orrlt	r8, r8, #8192	; 0x2000
  13eef0:	b2699000 	rsblt	r9, r9, #0
  13eef4:	e352002e 	cmp	r2, #46	; 0x2e
  13eef8:	0affff67 	beq	13ec9c <printf_core+0x1ac>
  13eefc:	e3a03000 	mov	r3, #0
  13ef00:	e3e05000 	mvn	r5, #0
  13ef04:	e58d301c 	str	r3, [sp, #28]
  13ef08:	e3a07000 	mov	r7, #0
  13ef0c:	e59f0c30 	ldr	r0, [pc, #3120]	; 13fb44 <printf_core+0x1054>
  13ef10:	ea000007 	b	13ef34 <printf_core+0x444>
  13ef14:	e5531041 	ldrb	r1, [r3, #-65]	; 0xffffffbf
  13ef18:	e2864001 	add	r4, r6, #1
  13ef1c:	e2413001 	sub	r3, r1, #1
  13ef20:	e3530007 	cmp	r3, #7
  13ef24:	8a000011 	bhi	13ef70 <printf_core+0x480>
  13ef28:	e5d62001 	ldrb	r2, [r6, #1]
  13ef2c:	e1a07001 	mov	r7, r1
  13ef30:	e1a06004 	mov	r6, r4
  13ef34:	e0673187 	rsb	r3, r7, r7, lsl #3
  13ef38:	e0873103 	add	r3, r7, r3, lsl #2
  13ef3c:	e0803083 	add	r3, r0, r3, lsl #1
  13ef40:	e0833002 	add	r3, r3, r2
  13ef44:	e2422041 	sub	r2, r2, #65	; 0x41
  13ef48:	e3520039 	cmp	r2, #57	; 0x39
  13ef4c:	9afffff0 	bls	13ef14 <printf_core+0x424>
  13ef50:	ebffe860 	bl	1390d8 <__errno_location>
  13ef54:	e3a03016 	mov	r3, #22
  13ef58:	e3e02000 	mvn	r2, #0
  13ef5c:	e58d2000 	str	r2, [sp]
  13ef60:	e5803000 	str	r3, [r0]
  13ef64:	e59d0000 	ldr	r0, [sp]
  13ef68:	e28ddfb3 	add	sp, sp, #716	; 0x2cc
  13ef6c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13ef70:	e3510000 	cmp	r1, #0
  13ef74:	0afffff5 	beq	13ef50 <printf_core+0x460>
  13ef78:	e351001b 	cmp	r1, #27
  13ef7c:	0a000080 	beq	13f184 <printf_core+0x694>
  13ef80:	e35c0000 	cmp	ip, #0
  13ef84:	ba0000a1 	blt	13f210 <printf_core+0x720>
  13ef88:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  13ef8c:	e59d22f0 	ldr	r2, [sp, #752]	; 0x2f0
  13ef90:	e083318c 	add	r3, r3, ip, lsl #3
  13ef94:	e782110c 	str	r1, [r2, ip, lsl #2]
  13ef98:	e893000c 	ldm	r3, {r2, r3}
  13ef9c:	e58d2070 	str	r2, [sp, #112]	; 0x70
  13efa0:	e58d3074 	str	r3, [sp, #116]	; 0x74
  13efa4:	e59d3004 	ldr	r3, [sp, #4]
  13efa8:	e3530000 	cmp	r3, #0
  13efac:	0a000079 	beq	13f198 <printf_core+0x6a8>
  13efb0:	e5d63000 	ldrb	r3, [r6]
  13efb4:	e3570000 	cmp	r7, #0
  13efb8:	e58d3010 	str	r3, [sp, #16]
  13efbc:	0a000004 	beq	13efd4 <printf_core+0x4e4>
  13efc0:	e203300f 	and	r3, r3, #15
  13efc4:	e3530003 	cmp	r3, #3
  13efc8:	059d3010 	ldreq	r3, [sp, #16]
  13efcc:	03c33020 	biceq	r3, r3, #32
  13efd0:	058d3010 	streq	r3, [sp, #16]
  13efd4:	e59d3010 	ldr	r3, [sp, #16]
  13efd8:	e3180a02 	tst	r8, #8192	; 0x2000
  13efdc:	e2433041 	sub	r3, r3, #65	; 0x41
  13efe0:	13c88801 	bicne	r8, r8, #65536	; 0x10000
  13efe4:	e3530037 	cmp	r3, #55	; 0x37
  13efe8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  13efec:	ea0001a2 	b	13f67c <printf_core+0xb8c>
  13eff0:	0013f4d0 	.word	0x0013f4d0
  13eff4:	0013f67c 	.word	0x0013f67c
  13eff8:	0013f36c 	.word	0x0013f36c
  13effc:	0013f67c 	.word	0x0013f67c
  13f000:	0013f4d0 	.word	0x0013f4d0
  13f004:	0013f4d0 	.word	0x0013f4d0
  13f008:	0013f4d0 	.word	0x0013f4d0
  13f00c:	0013f67c 	.word	0x0013f67c
  13f010:	0013f67c 	.word	0x0013f67c
  13f014:	0013f67c 	.word	0x0013f67c
  13f018:	0013f67c 	.word	0x0013f67c
  13f01c:	0013f67c 	.word	0x0013f67c
  13f020:	0013f67c 	.word	0x0013f67c
  13f024:	0013f67c 	.word	0x0013f67c
  13f028:	0013f67c 	.word	0x0013f67c
  13f02c:	0013f67c 	.word	0x0013f67c
  13f030:	0013f67c 	.word	0x0013f67c
  13f034:	0013f67c 	.word	0x0013f67c
  13f038:	0013f3dc 	.word	0x0013f3dc
  13f03c:	0013f67c 	.word	0x0013f67c
  13f040:	0013f67c 	.word	0x0013f67c
  13f044:	0013f67c 	.word	0x0013f67c
  13f048:	0013f67c 	.word	0x0013f67c
  13f04c:	0013f670 	.word	0x0013f670
  13f050:	0013f67c 	.word	0x0013f67c
  13f054:	0013f67c 	.word	0x0013f67c
  13f058:	0013f67c 	.word	0x0013f67c
  13f05c:	0013f67c 	.word	0x0013f67c
  13f060:	0013f67c 	.word	0x0013f67c
  13f064:	0013f67c 	.word	0x0013f67c
  13f068:	0013f67c 	.word	0x0013f67c
  13f06c:	0013f67c 	.word	0x0013f67c
  13f070:	0013f4d0 	.word	0x0013f4d0
  13f074:	0013f67c 	.word	0x0013f67c
  13f078:	0013f3f0 	.word	0x0013f3f0
  13f07c:	0013f42c 	.word	0x0013f42c
  13f080:	0013f4d0 	.word	0x0013f4d0
  13f084:	0013f4d0 	.word	0x0013f4d0
  13f088:	0013f4d0 	.word	0x0013f4d0
  13f08c:	0013f67c 	.word	0x0013f67c
  13f090:	0013f42c 	.word	0x0013f42c
  13f094:	0013f67c 	.word	0x0013f67c
  13f098:	0013f67c 	.word	0x0013f67c
  13f09c:	0013f67c 	.word	0x0013f67c
  13f0a0:	0013f474 	.word	0x0013f474
  13f0a4:	0013f4a4 	.word	0x0013f4a4
  13f0a8:	0013ed20 	.word	0x0013ed20
  13f0ac:	0013f5c4 	.word	0x0013f5c4
  13f0b0:	0013f67c 	.word	0x0013f67c
  13f0b4:	0013f67c 	.word	0x0013f67c
  13f0b8:	0013f65c 	.word	0x0013f65c
  13f0bc:	0013f67c 	.word	0x0013f67c
  13f0c0:	0013f2b0 	.word	0x0013f2b0
  13f0c4:	0013f67c 	.word	0x0013f67c
  13f0c8:	0013f67c 	.word	0x0013f67c
  13f0cc:	0013f670 	.word	0x0013f670
  13f0d0:	e59d2004 	ldr	r2, [sp, #4]
  13f0d4:	e1a0100a 	mov	r1, sl
  13f0d8:	e1a0000b 	mov	r0, fp
  13f0dc:	eb001348 	bl	143e04 <__fwritex>
  13f0e0:	eafffeb3 	b	13ebb4 <printf_core+0xc4>
  13f0e4:	e5d63002 	ldrb	r3, [r6, #2]
  13f0e8:	e3530024 	cmp	r3, #36	; 0x24
  13f0ec:	1affff70 	bne	13eeb4 <printf_core+0x3c4>
  13f0f0:	e3a0300a 	mov	r3, #10
  13f0f4:	e59d12f0 	ldr	r1, [sp, #752]	; 0x2f0
  13f0f8:	e24221c3 	sub	r2, r2, #-1073741776	; 0xc0000030
  13f0fc:	e7813102 	str	r3, [r1, r2, lsl #2]
  13f100:	e3a02001 	mov	r2, #1
  13f104:	e5d63001 	ldrb	r3, [r6, #1]
  13f108:	e58d200c 	str	r2, [sp, #12]
  13f10c:	e2833202 	add	r3, r3, #536870912	; 0x20000000
  13f110:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
  13f114:	e2433030 	sub	r3, r3, #48	; 0x30
  13f118:	e7929183 	ldr	r9, [r2, r3, lsl #3]
  13f11c:	e2866003 	add	r6, r6, #3
  13f120:	eaffff6f 	b	13eee4 <printf_core+0x3f4>
  13f124:	e2421030 	sub	r1, r2, #48	; 0x30
  13f128:	e3510009 	cmp	r1, #9
  13f12c:	e3a05000 	mov	r5, #0
  13f130:	e2866001 	add	r6, r6, #1
  13f134:	8a00000f 	bhi	13f178 <printf_core+0x688>
  13f138:	e59f09fc 	ldr	r0, [pc, #2556]	; 13fb3c <printf_core+0x104c>
  13f13c:	e0653e85 	rsb	r3, r5, r5, lsl #29
  13f140:	e0653103 	rsb	r3, r5, r3, lsl #2
  13f144:	e1a03083 	lsl	r3, r3, #1
  13f148:	e1550000 	cmp	r5, r0
  13f14c:	e2433106 	sub	r3, r3, #-2147483647	; 0x80000001
  13f150:	8a000003 	bhi	13f164 <printf_core+0x674>
  13f154:	e1510003 	cmp	r1, r3
  13f158:	e0855105 	add	r5, r5, r5, lsl #2
  13f15c:	d0815085 	addle	r5, r1, r5, lsl #1
  13f160:	da000000 	ble	13f168 <printf_core+0x678>
  13f164:	e3e05000 	mvn	r5, #0
  13f168:	e5f62001 	ldrb	r2, [r6, #1]!
  13f16c:	e2421030 	sub	r1, r2, #48	; 0x30
  13f170:	e3510009 	cmp	r1, #9
  13f174:	9afffff0 	bls	13f13c <printf_core+0x64c>
  13f178:	e3a03001 	mov	r3, #1
  13f17c:	e58d301c 	str	r3, [sp, #28]
  13f180:	eaffff60 	b	13ef08 <printf_core+0x418>
  13f184:	e35c0000 	cmp	ip, #0
  13f188:	aaffff70 	bge	13ef50 <printf_core+0x460>
  13f18c:	e59d3004 	ldr	r3, [sp, #4]
  13f190:	e3530000 	cmp	r3, #0
  13f194:	1affff85 	bne	13efb0 <printf_core+0x4c0>
  13f198:	e59d3008 	ldr	r3, [sp, #8]
  13f19c:	e153000a 	cmp	r3, sl
  13f1a0:	aaffff3d 	bge	13ee9c <printf_core+0x3ac>
  13f1a4:	ebffe7cb 	bl	1390d8 <__errno_location>
  13f1a8:	e3e02000 	mvn	r2, #0
  13f1ac:	e3a0304b 	mov	r3, #75	; 0x4b
  13f1b0:	e58d2000 	str	r2, [sp]
  13f1b4:	e5803000 	str	r3, [r0]
  13f1b8:	e59d0000 	ldr	r0, [sp]
  13f1bc:	e28ddfb3 	add	sp, sp, #716	; 0x2cc
  13f1c0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  13f1c4:	e1a04003 	mov	r4, r3
  13f1c8:	eafffe6c 	b	13eb80 <printf_core+0x90>
  13f1cc:	e59d9004 	ldr	r9, [sp, #4]
  13f1d0:	eafffeaf 	b	13ec94 <printf_core+0x1a4>
  13f1d4:	e3a0300a 	mov	r3, #10
  13f1d8:	e59d12f0 	ldr	r1, [sp, #752]	; 0x2f0
  13f1dc:	e24221c3 	sub	r2, r2, #-1073741776	; 0xc0000030
  13f1e0:	e7813102 	str	r3, [r1, r2, lsl #2]
  13f1e4:	e5d63002 	ldrb	r3, [r6, #2]
  13f1e8:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
  13f1ec:	e2833202 	add	r3, r3, #536870912	; 0x20000000
  13f1f0:	e2433030 	sub	r3, r3, #48	; 0x30
  13f1f4:	e7915183 	ldr	r5, [r1, r3, lsl #3]
  13f1f8:	e5d62004 	ldrb	r2, [r6, #4]
  13f1fc:	e1e03005 	mvn	r3, r5
  13f200:	e1a03fa3 	lsr	r3, r3, #31
  13f204:	e2866004 	add	r6, r6, #4
  13f208:	e58d301c 	str	r3, [sp, #28]
  13f20c:	eaffff3d 	b	13ef08 <printf_core+0x418>
  13f210:	e59d3004 	ldr	r3, [sp, #4]
  13f214:	e3530000 	cmp	r3, #0
  13f218:	0a000409 	beq	140244 <printf_core+0x1754>
  13f21c:	e59d2018 	ldr	r2, [sp, #24]
  13f220:	e28d0070 	add	r0, sp, #112	; 0x70
  13f224:	ebfffda1 	bl	13e8b0 <pop_arg>
  13f228:	eaffff60 	b	13efb0 <printf_core+0x4c0>
  13f22c:	e3a03001 	mov	r3, #1
  13f230:	e5d42003 	ldrb	r2, [r4, #3]
  13f234:	e58d300c 	str	r3, [sp, #12]
  13f238:	e2423020 	sub	r3, r2, #32
  13f23c:	e353001f 	cmp	r3, #31
  13f240:	e2846003 	add	r6, r4, #3
  13f244:	9afffe68 	bls	13ebec <printf_core+0xfc>
  13f248:	e3a08000 	mov	r8, #0
  13f24c:	eafffe75 	b	13ec28 <printf_core+0x138>
  13f250:	e59d3004 	ldr	r3, [sp, #4]
  13f254:	e3530000 	cmp	r3, #0
  13f258:	1affff41 	bne	13ef64 <printf_core+0x474>
  13f25c:	e59d300c 	ldr	r3, [sp, #12]
  13f260:	e3530000 	cmp	r3, #0
  13f264:	0a0003f6 	beq	140244 <printf_core+0x1754>
  13f268:	e3a05001 	mov	r5, #1
  13f26c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  13f270:	e59d62f0 	ldr	r6, [sp, #752]	; 0x2f0
  13f274:	e59d7018 	ldr	r7, [sp, #24]
  13f278:	e2834008 	add	r4, r3, #8
  13f27c:	e5b61004 	ldr	r1, [r6, #4]!
  13f280:	e3510000 	cmp	r1, #0
  13f284:	0a0004f8 	beq	14066c <printf_core+0x1b7c>
  13f288:	e1a00004 	mov	r0, r4
  13f28c:	e2855001 	add	r5, r5, #1
  13f290:	e1a02007 	mov	r2, r7
  13f294:	ebfffd85 	bl	13e8b0 <pop_arg>
  13f298:	e355000a 	cmp	r5, #10
  13f29c:	e2844008 	add	r4, r4, #8
  13f2a0:	1afffff5 	bne	13f27c <printf_core+0x78c>
  13f2a4:	e3a03001 	mov	r3, #1
  13f2a8:	e58d3000 	str	r3, [sp]
  13f2ac:	eaffff2c 	b	13ef64 <printf_core+0x474>
  13f2b0:	e3a03000 	mov	r3, #0
  13f2b4:	e28d7070 	add	r7, sp, #112	; 0x70
  13f2b8:	e89700c0 	ldm	r7, {r6, r7}
  13f2bc:	e58d3020 	str	r3, [sp, #32]
  13f2c0:	e59f3878 	ldr	r3, [pc, #2168]	; 13fb40 <printf_core+0x1050>
  13f2c4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  13f2c8:	e3a03000 	mov	r3, #0
  13f2cc:	e3e02000 	mvn	r2, #0
  13f2d0:	e1570003 	cmp	r7, r3
  13f2d4:	01560002 	cmpeq	r6, r2
  13f2d8:	e28da0d0 	add	sl, sp, #208	; 0xd0
  13f2dc:	91a0b00a 	movls	fp, sl
  13f2e0:	9a000015 	bls	13f33c <printf_core+0x84c>
  13f2e4:	e1a0b00a 	mov	fp, sl
  13f2e8:	e58d2010 	str	r2, [sp, #16]
  13f2ec:	e58d3014 	str	r3, [sp, #20]
  13f2f0:	e1a00006 	mov	r0, r6
  13f2f4:	e1a01007 	mov	r1, r7
  13f2f8:	e3a0200a 	mov	r2, #10
  13f2fc:	e3a03000 	mov	r3, #0
  13f300:	eb00183b 	bl	1453f4 <__aeabi_uldivmod>
  13f304:	e2822030 	add	r2, r2, #48	; 0x30
  13f308:	e56b2001 	strb	r2, [fp, #-1]!
  13f30c:	e1a00006 	mov	r0, r6
  13f310:	e1a01007 	mov	r1, r7
  13f314:	e3a0200a 	mov	r2, #10
  13f318:	e3a03000 	mov	r3, #0
  13f31c:	eb001834 	bl	1453f4 <__aeabi_uldivmod>
  13f320:	e28d3010 	add	r3, sp, #16
  13f324:	e893000c 	ldm	r3, {r2, r3}
  13f328:	e1510003 	cmp	r1, r3
  13f32c:	01500002 	cmpeq	r0, r2
  13f330:	e1a06000 	mov	r6, r0
  13f334:	e1a07001 	mov	r7, r1
  13f338:	8affffec 	bhi	13f2f0 <printf_core+0x800>
  13f33c:	e3560000 	cmp	r6, #0
  13f340:	0afffe90 	beq	13ed88 <printf_core+0x298>
  13f344:	e59f1838 	ldr	r1, [pc, #2104]	; 13fb84 <printf_core+0x1094>
  13f348:	e0832196 	umull	r2, r3, r6, r1
  13f34c:	e1a031a3 	lsr	r3, r3, #3
  13f350:	e0832103 	add	r2, r3, r3, lsl #2
  13f354:	e0466082 	sub	r6, r6, r2, lsl #1
  13f358:	e2862030 	add	r2, r6, #48	; 0x30
  13f35c:	e2536000 	subs	r6, r3, #0
  13f360:	e56b2001 	strb	r2, [fp, #-1]!
  13f364:	1afffff6 	bne	13f344 <printf_core+0x854>
  13f368:	eafffe86 	b	13ed88 <printf_core+0x298>
  13f36c:	e3a03000 	mov	r3, #0
  13f370:	e3e0a000 	mvn	sl, #0
  13f374:	e59d1070 	ldr	r1, [sp, #112]	; 0x70
  13f378:	e28d707c 	add	r7, sp, #124	; 0x7c
  13f37c:	e58d3080 	str	r3, [sp, #128]	; 0x80
  13f380:	e58d107c 	str	r1, [sp, #124]	; 0x7c
  13f384:	e58d7070 	str	r7, [sp, #112]	; 0x70
  13f388:	e3510000 	cmp	r1, #0
  13f38c:	0a000112 	beq	13f7dc <printf_core+0xcec>
  13f390:	e3a05000 	mov	r5, #0
  13f394:	e28d6068 	add	r6, sp, #104	; 0x68
  13f398:	ea000007 	b	13f3bc <printf_core+0x8cc>
  13f39c:	e1530000 	cmp	r3, r0
  13f3a0:	3a0000e4 	bcc	13f738 <printf_core+0xc48>
  13f3a4:	e0855000 	add	r5, r5, r0
  13f3a8:	e155000a 	cmp	r5, sl
  13f3ac:	2a0000e1 	bcs	13f738 <printf_core+0xc48>
  13f3b0:	e5b71004 	ldr	r1, [r7, #4]!
  13f3b4:	e3510000 	cmp	r1, #0
  13f3b8:	0a0000de 	beq	13f738 <printf_core+0xc48>
  13f3bc:	e1a00006 	mov	r0, r6
  13f3c0:	eb0010a3 	bl	143654 <wctomb>
  13f3c4:	e3500000 	cmp	r0, #0
  13f3c8:	e04a3005 	sub	r3, sl, r5
  13f3cc:	aafffff2 	bge	13f39c <printf_core+0x8ac>
  13f3d0:	e3e03000 	mvn	r3, #0
  13f3d4:	e58d3000 	str	r3, [sp]
  13f3d8:	eafffee1 	b	13ef64 <printf_core+0x474>
  13f3dc:	e255a000 	subs	sl, r5, #0
  13f3e0:	e59d7070 	ldr	r7, [sp, #112]	; 0x70
  13f3e4:	0a0000fc 	beq	13f7dc <printf_core+0xcec>
  13f3e8:	e5971000 	ldr	r1, [r7]
  13f3ec:	eaffffe5 	b	13f388 <printf_core+0x898>
  13f3f0:	e3a00001 	mov	r0, #1
  13f3f4:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
  13f3f8:	e3c88801 	bic	r8, r8, #65536	; 0x10000
  13f3fc:	e5cd30cf 	strb	r3, [sp, #207]	; 0xcf
  13f400:	e28d60d0 	add	r6, sp, #208	; 0xd0
  13f404:	e28db0cf 	add	fp, sp, #207	; 0xcf
  13f408:	e3a03000 	mov	r3, #0
  13f40c:	e046600b 	sub	r6, r6, fp
  13f410:	e58d3020 	str	r3, [sp, #32]
  13f414:	e59f3724 	ldr	r3, [pc, #1828]	; 13fb40 <printf_core+0x1050>
  13f418:	e1560000 	cmp	r6, r0
  13f41c:	a1a05006 	movge	r5, r6
  13f420:	b1a05000 	movlt	r5, r0
  13f424:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  13f428:	eafffe70 	b	13edf0 <printf_core+0x300>
  13f42c:	e28d7070 	add	r7, sp, #112	; 0x70
  13f430:	e89700c0 	ldm	r7, {r6, r7}
  13f434:	e3560000 	cmp	r6, #0
  13f438:	e2d73000 	sbcs	r3, r7, #0
  13f43c:	ba000122 	blt	13f8cc <printf_core+0xddc>
  13f440:	e3180b02 	tst	r8, #2048	; 0x800
  13f444:	1a000379 	bne	140230 <printf_core+0x1740>
  13f448:	e59fa6f0 	ldr	sl, [pc, #1776]	; 13fb40 <printf_core+0x1050>
  13f44c:	e2083001 	and	r3, r8, #1
  13f450:	e3530000 	cmp	r3, #0
  13f454:	e28a2002 	add	r2, sl, #2
  13f458:	01a0300a 	moveq	r3, sl
  13f45c:	11a03002 	movne	r3, r2
  13f460:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  13f464:	13a03001 	movne	r3, #1
  13f468:	03a03000 	moveq	r3, #0
  13f46c:	e58d3020 	str	r3, [sp, #32]
  13f470:	eaffff94 	b	13f2c8 <printf_core+0x7d8>
  13f474:	ebffe717 	bl	1390d8 <__errno_location>
  13f478:	e5900000 	ldr	r0, [r0]
  13f47c:	ebffe737 	bl	139160 <strerror>
  13f480:	e1a0b000 	mov	fp, r0
  13f484:	e3550000 	cmp	r5, #0
  13f488:	ba0000fa 	blt	13f878 <printf_core+0xd88>
  13f48c:	e1a01005 	mov	r1, r5
  13f490:	e1a0000b 	mov	r0, fp
  13f494:	eb0008dd 	bl	141810 <strnlen>
  13f498:	e08b6000 	add	r6, fp, r0
  13f49c:	e3c88801 	bic	r8, r8, #65536	; 0x10000
  13f4a0:	eaffffd8 	b	13f408 <printf_core+0x918>
  13f4a4:	e3570007 	cmp	r7, #7
  13f4a8:	979ff107 	ldrls	pc, [pc, r7, lsl #2]
  13f4ac:	eaffff39 	b	13f198 <printf_core+0x6a8>
  13f4b0:	0013f6a0 	.word	0x0013f6a0
  13f4b4:	0013f6a0 	.word	0x0013f6a0
  13f4b8:	0013f6b0 	.word	0x0013f6b0
  13f4bc:	0013f6c4 	.word	0x0013f6c4
  13f4c0:	0013f6d4 	.word	0x0013f6d4
  13f4c4:	0013f198 	.word	0x0013f198
  13f4c8:	0013f6a0 	.word	0x0013f6a0
  13f4cc:	0013f6b0 	.word	0x0013f6b0
  13f4d0:	e59d301c 	ldr	r3, [sp, #28]
  13f4d4:	e0133fa5 	ands	r3, r3, r5, lsr #31
  13f4d8:	1affff31 	bne	13f1a4 <printf_core+0x6b4>
  13f4dc:	e28d7070 	add	r7, sp, #112	; 0x70
  13f4e0:	e89700c0 	ldm	r7, {r6, r7}
  13f4e4:	e1b02fa7 	lsrs	r2, r7, #31
  13f4e8:	e58d2030 	str	r2, [sp, #48]	; 0x30
  13f4ec:	e58d306c 	str	r3, [sp, #108]	; 0x6c
  13f4f0:	0a0000e8 	beq	13f898 <printf_core+0xda8>
  13f4f4:	e2873102 	add	r3, r7, #-2147483648	; 0x80000000
  13f4f8:	e1a07003 	mov	r7, r3
  13f4fc:	e59f3644 	ldr	r3, [pc, #1604]	; 13fb48 <printf_core+0x1058>
  13f500:	e58d3034 	str	r3, [sp, #52]	; 0x34
  13f504:	e3e02000 	mvn	r2, #0
  13f508:	e59f363c 	ldr	r3, [pc, #1596]	; 13fb4c <printf_core+0x105c>
  13f50c:	e3c71102 	bic	r1, r7, #-2147483648	; 0x80000000
  13f510:	e1510003 	cmp	r1, r3
  13f514:	01560002 	cmpeq	r6, r2
  13f518:	e1a00006 	mov	r0, r6
  13f51c:	9a0000fb 	bls	13f910 <printf_core+0xe20>
  13f520:	e59d3010 	ldr	r3, [sp, #16]
  13f524:	e59fe624 	ldr	lr, [pc, #1572]	; 13fb50 <printf_core+0x1060>
  13f528:	e59fc624 	ldr	ip, [pc, #1572]	; 13fb54 <printf_core+0x1064>
  13f52c:	e213a020 	ands	sl, r3, #32
  13f530:	e1a02006 	mov	r2, r6
  13f534:	e1a03007 	mov	r3, r7
  13f538:	e1a01007 	mov	r1, r7
  13f53c:	01a0600e 	moveq	r6, lr
  13f540:	11a0600c 	movne	r6, ip
  13f544:	eb001730 	bl	14520c <__aeabi_dcmpeq>
  13f548:	e3500000 	cmp	r0, #0
  13f54c:	1a000004 	bne	13f564 <printf_core+0xa74>
  13f550:	e59fe600 	ldr	lr, [pc, #1536]	; 13fb58 <printf_core+0x1068>
  13f554:	e59fc600 	ldr	ip, [pc, #1536]	; 13fb5c <printf_core+0x106c>
  13f558:	e35a0000 	cmp	sl, #0
  13f55c:	01a0600e 	moveq	r6, lr
  13f560:	11a0600c 	movne	r6, ip
  13f564:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  13f568:	e283a003 	add	sl, r3, #3
  13f56c:	e159000a 	cmp	r9, sl
  13f570:	c3a07000 	movgt	r7, #0
  13f574:	d3a07001 	movle	r7, #1
  13f578:	e3180a02 	tst	r8, #8192	; 0x2000
  13f57c:	01a03007 	moveq	r3, r7
  13f580:	13a03001 	movne	r3, #1
  13f584:	e3530000 	cmp	r3, #0
  13f588:	0a00042e 	beq	140648 <printf_core+0x1b58>
  13f58c:	e59d3004 	ldr	r3, [sp, #4]
  13f590:	e5933000 	ldr	r3, [r3]
  13f594:	e3130020 	tst	r3, #32
  13f598:	0a00032c 	beq	140250 <printf_core+0x1760>
  13f59c:	e2283a02 	eor	r3, r8, #8192	; 0x2000
  13f5a0:	e3130a12 	tst	r3, #73728	; 0x12000
  13f5a4:	13a07001 	movne	r7, #1
  13f5a8:	e3570000 	cmp	r7, #0
  13f5ac:	0a00034f 	beq	1402f0 <printf_core+0x1800>
  13f5b0:	e159000a 	cmp	r9, sl
  13f5b4:	a1a0a009 	movge	sl, r9
  13f5b8:	e35a0000 	cmp	sl, #0
  13f5bc:	aafffef5 	bge	13f198 <printf_core+0x6a8>
  13f5c0:	eafffef7 	b	13f1a4 <printf_core+0x6b4>
  13f5c4:	e3550008 	cmp	r5, #8
  13f5c8:	e3a03078 	mov	r3, #120	; 0x78
  13f5cc:	33a05008 	movcc	r5, #8
  13f5d0:	e3a0c020 	mov	ip, #32
  13f5d4:	e58d3010 	str	r3, [sp, #16]
  13f5d8:	e3888008 	orr	r8, r8, #8
  13f5dc:	e28d3070 	add	r3, sp, #112	; 0x70
  13f5e0:	e893000c 	ldm	r3, {r2, r3}
  13f5e4:	e28da0d0 	add	sl, sp, #208	; 0xd0
  13f5e8:	e1921003 	orrs	r1, r2, r3
  13f5ec:	e1a0b00a 	mov	fp, sl
  13f5f0:	0a00004b 	beq	13f724 <printf_core+0xc34>
  13f5f4:	e59f6584 	ldr	r6, [pc, #1412]	; 13fb80 <printf_core+0x1090>
  13f5f8:	e3a01000 	mov	r1, #0
  13f5fc:	e202000f 	and	r0, r2, #15
  13f600:	e1a0e222 	lsr	lr, r2, #4
  13f604:	e58d0020 	str	r0, [sp, #32]
  13f608:	e58d1024 	str	r1, [sp, #36]	; 0x24
  13f60c:	e18eee03 	orr	lr, lr, r3, lsl #28
  13f610:	e1a01223 	lsr	r1, r3, #4
  13f614:	e1a03001 	mov	r3, r1
  13f618:	e1a0200e 	mov	r2, lr
  13f61c:	e59d1020 	ldr	r1, [sp, #32]
  13f620:	e0860001 	add	r0, r6, r1
  13f624:	e5d01000 	ldrb	r1, [r0]
  13f628:	e1920003 	orrs	r0, r2, r3
  13f62c:	e18c1001 	orr	r1, ip, r1
  13f630:	e56b1001 	strb	r1, [fp, #-1]!
  13f634:	1affffef 	bne	13f5f8 <printf_core+0xb08>
  13f638:	e2183008 	ands	r3, r8, #8
  13f63c:	0a000039 	beq	13f728 <printf_core+0xc38>
  13f640:	e3a02002 	mov	r2, #2
  13f644:	e59f34f4 	ldr	r3, [pc, #1268]	; 13fb40 <printf_core+0x1050>
  13f648:	e58d2020 	str	r2, [sp, #32]
  13f64c:	e59d2010 	ldr	r2, [sp, #16]
  13f650:	e0833242 	add	r3, r3, r2, asr #4
  13f654:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  13f658:	eafffdca 	b	13ed88 <printf_core+0x298>
  13f65c:	e59db070 	ldr	fp, [sp, #112]	; 0x70
  13f660:	e59f34f8 	ldr	r3, [pc, #1272]	; 13fb60 <printf_core+0x1070>
  13f664:	e35b0000 	cmp	fp, #0
  13f668:	01a0b003 	moveq	fp, r3
  13f66c:	eaffff84 	b	13f484 <printf_core+0x994>
  13f670:	e59d3010 	ldr	r3, [sp, #16]
  13f674:	e203c020 	and	ip, r3, #32
  13f678:	eaffffd7 	b	13f5dc <printf_core+0xaec>
  13f67c:	e3a03000 	mov	r3, #0
  13f680:	e28d60d0 	add	r6, sp, #208	; 0xd0
  13f684:	e046600b 	sub	r6, r6, fp
  13f688:	e58d3020 	str	r3, [sp, #32]
  13f68c:	e59f34ac 	ldr	r3, [pc, #1196]	; 13fb40 <printf_core+0x1050>
  13f690:	e1560005 	cmp	r6, r5
  13f694:	a1a05006 	movge	r5, r6
  13f698:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  13f69c:	eafffdd3 	b	13edf0 <printf_core+0x300>
  13f6a0:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
  13f6a4:	e59d2000 	ldr	r2, [sp]
  13f6a8:	e5832000 	str	r2, [r3]
  13f6ac:	eafffeb9 	b	13f198 <printf_core+0x6a8>
  13f6b0:	e59d2000 	ldr	r2, [sp]
  13f6b4:	e59d1070 	ldr	r1, [sp, #112]	; 0x70
  13f6b8:	e1a03fc2 	asr	r3, r2, #31
  13f6bc:	e881000c 	stm	r1, {r2, r3}
  13f6c0:	eafffeb4 	b	13f198 <printf_core+0x6a8>
  13f6c4:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
  13f6c8:	e59d2000 	ldr	r2, [sp]
  13f6cc:	e1c320b0 	strh	r2, [r3]
  13f6d0:	eafffeb0 	b	13f198 <printf_core+0x6a8>
  13f6d4:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
  13f6d8:	e59d2000 	ldr	r2, [sp]
  13f6dc:	e5c32000 	strb	r2, [r3]
  13f6e0:	eafffeac 	b	13f198 <printf_core+0x6a8>
  13f6e4:	e1a01006 	mov	r1, r6
  13f6e8:	e1a0000b 	mov	r0, fp
  13f6ec:	e59d2004 	ldr	r2, [sp, #4]
  13f6f0:	eb0011c3 	bl	143e04 <__fwritex>
  13f6f4:	eafffddd 	b	13ee70 <printf_core+0x380>
  13f6f8:	e1a02005 	mov	r2, r5
  13f6fc:	e1a03006 	mov	r3, r6
  13f700:	e3a01030 	mov	r1, #48	; 0x30
  13f704:	e59d0004 	ldr	r0, [sp, #4]
  13f708:	ebfffccd 	bl	13ea44 <pad.part.0>
  13f70c:	eafffdd3 	b	13ee60 <printf_core+0x370>
  13f710:	e59d1020 	ldr	r1, [sp, #32]
  13f714:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
  13f718:	e59d2004 	ldr	r2, [sp, #4]
  13f71c:	eb0011b8 	bl	143e04 <__fwritex>
  13f720:	eafffdc6 	b	13ee40 <printf_core+0x350>
  13f724:	e3a03000 	mov	r3, #0
  13f728:	e58d3020 	str	r3, [sp, #32]
  13f72c:	e59f340c 	ldr	r3, [pc, #1036]	; 13fb40 <printf_core+0x1050>
  13f730:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  13f734:	eafffd93 	b	13ed88 <printf_core+0x298>
  13f738:	e3550000 	cmp	r5, #0
  13f73c:	e1a0b005 	mov	fp, r5
  13f740:	bafffe97 	blt	13f1a4 <printf_core+0x6b4>
  13f744:	e1550009 	cmp	r5, r9
  13f748:	b3a03000 	movlt	r3, #0
  13f74c:	a3a03001 	movge	r3, #1
  13f750:	e3180a12 	tst	r8, #73728	; 0x12000
  13f754:	e58d3010 	str	r3, [sp, #16]
  13f758:	13a03001 	movne	r3, #1
  13f75c:	e3530000 	cmp	r3, #0
  13f760:	0a000062 	beq	13f8f0 <printf_core+0xe00>
  13f764:	e3550000 	cmp	r5, #0
  13f768:	e59d7070 	ldr	r7, [sp, #112]	; 0x70
  13f76c:	0a000025 	beq	13f808 <printf_core+0xd18>
  13f770:	e5971000 	ldr	r1, [r7]
  13f774:	e3510000 	cmp	r1, #0
  13f778:	0a000022 	beq	13f808 <printf_core+0xd18>
  13f77c:	e3a0a000 	mov	sl, #0
  13f780:	e58d401c 	str	r4, [sp, #28]
  13f784:	e28d6068 	add	r6, sp, #104	; 0x68
  13f788:	e1a0400a 	mov	r4, sl
  13f78c:	e59da004 	ldr	sl, [sp, #4]
  13f790:	ea000004 	b	13f7a8 <printf_core+0xcb8>
  13f794:	e1540005 	cmp	r4, r5
  13f798:	2a000024 	bcs	13f830 <printf_core+0xd40>
  13f79c:	e5b71004 	ldr	r1, [r7, #4]!
  13f7a0:	e3510000 	cmp	r1, #0
  13f7a4:	0a000021 	beq	13f830 <printf_core+0xd40>
  13f7a8:	e1a00006 	mov	r0, r6
  13f7ac:	eb000fa8 	bl	143654 <wctomb>
  13f7b0:	e0844000 	add	r4, r4, r0
  13f7b4:	e1540005 	cmp	r4, r5
  13f7b8:	8a00001c 	bhi	13f830 <printf_core+0xd40>
  13f7bc:	e59a2000 	ldr	r2, [sl]
  13f7c0:	e3120020 	tst	r2, #32
  13f7c4:	1afffff2 	bne	13f794 <printf_core+0xca4>
  13f7c8:	e1a01000 	mov	r1, r0
  13f7cc:	e1a0200a 	mov	r2, sl
  13f7d0:	e1a00006 	mov	r0, r6
  13f7d4:	eb00118a 	bl	143e04 <__fwritex>
  13f7d8:	eaffffed 	b	13f794 <printf_core+0xca4>
  13f7dc:	e3590000 	cmp	r9, #0
  13f7e0:	c3a03000 	movgt	r3, #0
  13f7e4:	d3a03001 	movle	r3, #1
  13f7e8:	e3180a12 	tst	r8, #73728	; 0x12000
  13f7ec:	e58d3010 	str	r3, [sp, #16]
  13f7f0:	13a03001 	movne	r3, #1
  13f7f4:	e3530000 	cmp	r3, #0
  13f7f8:	01a0b003 	moveq	fp, r3
  13f7fc:	01a0500b 	moveq	r5, fp
  13f800:	0a00003a 	beq	13f8f0 <printf_core+0xe00>
  13f804:	e3a0b000 	mov	fp, #0
  13f808:	e2283a02 	eor	r3, r8, #8192	; 0x2000
  13f80c:	e3130a12 	tst	r3, #73728	; 0x12000
  13f810:	e59d3010 	ldr	r3, [sp, #16]
  13f814:	13a03001 	movne	r3, #1
  13f818:	e3530000 	cmp	r3, #0
  13f81c:	0a00027d 	beq	140218 <printf_core+0x1728>
  13f820:	e159000b 	cmp	r9, fp
  13f824:	a1a0a009 	movge	sl, r9
  13f828:	b1a0a00b 	movlt	sl, fp
  13f82c:	eafffe59 	b	13f198 <printf_core+0x6a8>
  13f830:	e59d401c 	ldr	r4, [sp, #28]
  13f834:	eafffff3 	b	13f808 <printf_core+0xd18>
  13f838:	e1a03007 	mov	r3, r7
  13f83c:	e1a0200a 	mov	r2, sl
  13f840:	e3a01020 	mov	r1, #32
  13f844:	e59d0004 	ldr	r0, [sp, #4]
  13f848:	ebfffc7d 	bl	13ea44 <pad.part.0>
  13f84c:	eafffd77 	b	13ee30 <printf_core+0x340>
  13f850:	e1a03007 	mov	r3, r7
  13f854:	e1a0200a 	mov	r2, sl
  13f858:	e3a01030 	mov	r1, #48	; 0x30
  13f85c:	e59d0004 	ldr	r0, [sp, #4]
  13f860:	ebfffc77 	bl	13ea44 <pad.part.0>
  13f864:	eafffd7b 	b	13ee58 <printf_core+0x368>
  13f868:	e3a05000 	mov	r5, #0
  13f86c:	e1a0b00a 	mov	fp, sl
  13f870:	e1a06005 	mov	r6, r5
  13f874:	eafffd5d 	b	13edf0 <printf_core+0x300>
  13f878:	e3e01102 	mvn	r1, #-2147483648	; 0x80000000
  13f87c:	e1a0000b 	mov	r0, fp
  13f880:	eb0007e2 	bl	141810 <strnlen>
  13f884:	e7db3000 	ldrb	r3, [fp, r0]
  13f888:	e08b6000 	add	r6, fp, r0
  13f88c:	e3530000 	cmp	r3, #0
  13f890:	0affff01 	beq	13f49c <printf_core+0x9ac>
  13f894:	eafffe42 	b	13f1a4 <printf_core+0x6b4>
  13f898:	e3180b02 	tst	r8, #2048	; 0x800
  13f89c:	1a000278 	bne	140284 <printf_core+0x1794>
  13f8a0:	e59f22bc 	ldr	r2, [pc, #700]	; 13fb64 <printf_core+0x1074>
  13f8a4:	e2083001 	and	r3, r8, #1
  13f8a8:	e3530000 	cmp	r3, #0
  13f8ac:	e2821005 	add	r1, r2, #5
  13f8b0:	01a03002 	moveq	r3, r2
  13f8b4:	11a03001 	movne	r3, r1
  13f8b8:	e58d3034 	str	r3, [sp, #52]	; 0x34
  13f8bc:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  13f8c0:	13a03001 	movne	r3, #1
  13f8c4:	e58d3030 	str	r3, [sp, #48]	; 0x30
  13f8c8:	eaffff0d 	b	13f504 <printf_core+0xa14>
  13f8cc:	e3a03001 	mov	r3, #1
  13f8d0:	e2766000 	rsbs	r6, r6, #0
  13f8d4:	e58d3020 	str	r3, [sp, #32]
  13f8d8:	e59f3260 	ldr	r3, [pc, #608]	; 13fb40 <printf_core+0x1050>
  13f8dc:	e2e77000 	rsc	r7, r7, #0
  13f8e0:	e58d6070 	str	r6, [sp, #112]	; 0x70
  13f8e4:	e58d7074 	str	r7, [sp, #116]	; 0x74
  13f8e8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  13f8ec:	eafffe75 	b	13f2c8 <printf_core+0x7d8>
  13f8f0:	e1a0300b 	mov	r3, fp
  13f8f4:	e1a02009 	mov	r2, r9
  13f8f8:	e3a01020 	mov	r1, #32
  13f8fc:	e59d0004 	ldr	r0, [sp, #4]
  13f900:	ebfffc4f 	bl	13ea44 <pad.part.0>
  13f904:	e3a03000 	mov	r3, #0
  13f908:	e58d3010 	str	r3, [sp, #16]
  13f90c:	eaffff94 	b	13f764 <printf_core+0xc74>
  13f910:	e28d206c 	add	r2, sp, #108	; 0x6c
  13f914:	e1a01007 	mov	r1, r7
  13f918:	eb000f36 	bl	1435f8 <frexpl>
  13f91c:	e1a02000 	mov	r2, r0
  13f920:	e1a03001 	mov	r3, r1
  13f924:	eb0013fd 	bl	144920 <__adddf3>
  13f928:	e3a03000 	mov	r3, #0
  13f92c:	e3a02000 	mov	r2, #0
  13f930:	e58d001c 	str	r0, [sp, #28]
  13f934:	e58d1038 	str	r1, [sp, #56]	; 0x38
  13f938:	eb001633 	bl	14520c <__aeabi_dcmpeq>
  13f93c:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
  13f940:	e3500000 	cmp	r0, #0
  13f944:	02433001 	subeq	r3, r3, #1
  13f948:	158d3020 	strne	r3, [sp, #32]
  13f94c:	058d3020 	streq	r3, [sp, #32]
  13f950:	058d306c 	streq	r3, [sp, #108]	; 0x6c
  13f954:	e59d3010 	ldr	r3, [sp, #16]
  13f958:	e3833020 	orr	r3, r3, #32
  13f95c:	e3530061 	cmp	r3, #97	; 0x61
  13f960:	e58d303c 	str	r3, [sp, #60]	; 0x3c
  13f964:	0a000267 	beq	140308 <printf_core+0x1818>
  13f968:	e3550000 	cmp	r5, #0
  13f96c:	ba000460 	blt	140af4 <printf_core+0x2004>
  13f970:	13a03001 	movne	r3, #1
  13f974:	03a03000 	moveq	r3, #0
  13f978:	e58d3044 	str	r3, [sp, #68]	; 0x44
  13f97c:	e59d701c 	ldr	r7, [sp, #28]
  13f980:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
  13f984:	e1a00007 	mov	r0, r7
  13f988:	e1a01006 	mov	r1, r6
  13f98c:	e3a02000 	mov	r2, #0
  13f990:	e3a03000 	mov	r3, #0
  13f994:	eb00161c 	bl	14520c <__aeabi_dcmpeq>
  13f998:	e3500000 	cmp	r0, #0
  13f99c:	1a00000a 	bne	13f9cc <printf_core+0xedc>
  13f9a0:	e59f31c0 	ldr	r3, [pc, #448]	; 13fb68 <printf_core+0x1078>
  13f9a4:	e1a00007 	mov	r0, r7
  13f9a8:	e1a01006 	mov	r1, r6
  13f9ac:	e3a02000 	mov	r2, #0
  13f9b0:	eb0014c7 	bl	144cd4 <__aeabi_dmul>
  13f9b4:	e59d3020 	ldr	r3, [sp, #32]
  13f9b8:	e58d001c 	str	r0, [sp, #28]
  13f9bc:	e243301c 	sub	r3, r3, #28
  13f9c0:	e58d1038 	str	r1, [sp, #56]	; 0x38
  13f9c4:	e58d3020 	str	r3, [sp, #32]
  13f9c8:	e58d306c 	str	r3, [sp, #108]	; 0x6c
  13f9cc:	e59d3020 	ldr	r3, [sp, #32]
  13f9d0:	e59d601c 	ldr	r6, [sp, #28]
  13f9d4:	e3530000 	cmp	r3, #0
  13f9d8:	a28d3e1f 	addge	r3, sp, #496	; 0x1f0
  13f9dc:	b28d30d0 	addlt	r3, sp, #208	; 0xd0
  13f9e0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  13f9e4:	e59db02c 	ldr	fp, [sp, #44]	; 0x2c
  13f9e8:	e59d7038 	ldr	r7, [sp, #56]	; 0x38
  13f9ec:	e1a01007 	mov	r1, r7
  13f9f0:	e1a00006 	mov	r0, r6
  13f9f4:	eb001634 	bl	1452cc <__aeabi_d2uiz>
  13f9f8:	e48b0004 	str	r0, [fp], #4
  13f9fc:	eb001472 	bl	144bcc <__aeabi_ui2d>
  13fa00:	e1a02000 	mov	r2, r0
  13fa04:	e1a03001 	mov	r3, r1
  13fa08:	e1a00006 	mov	r0, r6
  13fa0c:	e1a01007 	mov	r1, r7
  13fa10:	eb0013c1 	bl	14491c <__aeabi_dsub>
  13fa14:	e3a02000 	mov	r2, #0
  13fa18:	e59f314c 	ldr	r3, [pc, #332]	; 13fb6c <printf_core+0x107c>
  13fa1c:	eb0014ac 	bl	144cd4 <__aeabi_dmul>
  13fa20:	e3a02000 	mov	r2, #0
  13fa24:	e3a03000 	mov	r3, #0
  13fa28:	e1a07001 	mov	r7, r1
  13fa2c:	e1a06000 	mov	r6, r0
  13fa30:	eb0015f5 	bl	14520c <__aeabi_dcmpeq>
  13fa34:	e3500000 	cmp	r0, #0
  13fa38:	0affffeb 	beq	13f9ec <printf_core+0xefc>
  13fa3c:	e59d2020 	ldr	r2, [sp, #32]
  13fa40:	e1a0300b 	mov	r3, fp
  13fa44:	e3520000 	cmp	r2, #0
  13fa48:	e58db01c 	str	fp, [sp, #28]
  13fa4c:	e59db02c 	ldr	fp, [sp, #44]	; 0x2c
  13fa50:	da000067 	ble	13fbf4 <printf_core+0x1104>
  13fa54:	e58da048 	str	sl, [sp, #72]	; 0x48
  13fa58:	e1a0a003 	mov	sl, r3
  13fa5c:	e58d5060 	str	r5, [sp, #96]	; 0x60
  13fa60:	e58d4064 	str	r4, [sp, #100]	; 0x64
  13fa64:	e58d9058 	str	r9, [sp, #88]	; 0x58
  13fa68:	e58d805c 	str	r8, [sp, #92]	; 0x5c
  13fa6c:	e28d9050 	add	r9, sp, #80	; 0x50
  13fa70:	e8990300 	ldm	r9, {r8, r9}
  13fa74:	e59d2020 	ldr	r2, [sp, #32]
  13fa78:	e24a3004 	sub	r3, sl, #4
  13fa7c:	e352001d 	cmp	r2, #29
  13fa80:	b1a05002 	movlt	r5, r2
  13fa84:	a3a0501d 	movge	r5, #29
  13fa88:	e153000b 	cmp	r3, fp
  13fa8c:	e58d3038 	str	r3, [sp, #56]	; 0x38
  13fa90:	3a00001e 	bcc	13fb10 <printf_core+0x1020>
  13fa94:	e1a04003 	mov	r4, r3
  13fa98:	e2453020 	sub	r3, r5, #32
  13fa9c:	e58da040 	str	sl, [sp, #64]	; 0x40
  13faa0:	e3a00000 	mov	r0, #0
  13faa4:	e1a0a003 	mov	sl, r3
  13faa8:	e2652020 	rsb	r2, r5, #32
  13faac:	e58d201c 	str	r2, [sp, #28]
  13fab0:	e5941000 	ldr	r1, [r4]
  13fab4:	e59dc01c 	ldr	ip, [sp, #28]
  13fab8:	e1a09a11 	lsl	r9, r1, sl
  13fabc:	e1a08511 	lsl	r8, r1, r5
  13fac0:	e0986000 	adds	r6, r8, r0
  13fac4:	e1899c31 	orr	r9, r9, r1, lsr ip
  13fac8:	e2a97000 	adc	r7, r9, #0
  13facc:	e28f305c 	add	r3, pc, #92	; 0x5c
  13fad0:	e893000c 	ldm	r3, {r2, r3}
  13fad4:	e1a00006 	mov	r0, r6
  13fad8:	e1a01007 	mov	r1, r7
  13fadc:	eb001644 	bl	1453f4 <__aeabi_uldivmod>
  13fae0:	e1a00006 	mov	r0, r6
  13fae4:	e4042004 	str	r2, [r4], #-4
  13fae8:	e1a01007 	mov	r1, r7
  13faec:	e28f303c 	add	r3, pc, #60	; 0x3c
  13faf0:	e893000c 	ldm	r3, {r2, r3}
  13faf4:	eb00163e 	bl	1453f4 <__aeabi_uldivmod>
  13faf8:	e154000b 	cmp	r4, fp
  13fafc:	2affffeb 	bcs	13fab0 <printf_core+0xfc0>
  13fb00:	e3500000 	cmp	r0, #0
  13fb04:	e59da040 	ldr	sl, [sp, #64]	; 0x40
  13fb08:	150b0004 	strne	r0, [fp, #-4]
  13fb0c:	124bb004 	subne	fp, fp, #4
  13fb10:	e15b000a 	cmp	fp, sl
  13fb14:	2a000028 	bcs	13fbbc <printf_core+0x10cc>
  13fb18:	e51a3004 	ldr	r3, [sl, #-4]
  13fb1c:	e3530000 	cmp	r3, #0
  13fb20:	059d3038 	ldreq	r3, [sp, #56]	; 0x38
  13fb24:	0a000021 	beq	13fbb0 <printf_core+0x10c0>
  13fb28:	ea000023 	b	13fbbc <printf_core+0x10cc>
  13fb2c:	e1a00000 	nop			; (mov r0, r0)
  13fb30:	3b9aca00 	.word	0x3b9aca00
  13fb34:	00000000 	.word	0x00000000
  13fb38:	00012889 	.word	0x00012889
  13fb3c:	0ccccccc 	.word	0x0ccccccc
  13fb40:	0014cfac 	.word	0x0014cfac
  13fb44:	0014cfe8 	.word	0x0014cfe8
  13fb48:	0014cfc0 	.word	0x0014cfc0
  13fb4c:	7fefffff 	.word	0x7fefffff
  13fb50:	0014cfd8 	.word	0x0014cfd8
  13fb54:	0014cfd4 	.word	0x0014cfd4
  13fb58:	0014cfe0 	.word	0x0014cfe0
  13fb5c:	0014cfdc 	.word	0x0014cfdc
  13fb60:	0014cfb8 	.word	0x0014cfb8
  13fb64:	0014cfc1 	.word	0x0014cfc1
  13fb68:	41b00000 	.word	0x41b00000
  13fb6c:	41cdcd65 	.word	0x41cdcd65
  13fb70:	38e38e39 	.word	0x38e38e39
  13fb74:	3b9aca00 	.word	0x3b9aca00
  13fb78:	0014cfad 	.word	0x0014cfad
  13fb7c:	0014cfc3 	.word	0x0014cfc3
  13fb80:	0014d1b8 	.word	0x0014d1b8
  13fb84:	cccccccd 	.word	0xcccccccd
  13fb88:	0014cfe4 	.word	0x0014cfe4
  13fb8c:	3b9ac9ff 	.word	0x3b9ac9ff
  13fb90:	40300000 	.word	0x40300000
  13fb94:	3fe00000 	.word	0x3fe00000
  13fb98:	43400000 	.word	0x43400000
  13fb9c:	3ff00000 	.word	0x3ff00000
  13fba0:	3ff80000 	.word	0x3ff80000
  13fba4:	e5332004 	ldr	r2, [r3, #-4]!
  13fba8:	e3520000 	cmp	r2, #0
  13fbac:	1a000002 	bne	13fbbc <printf_core+0x10cc>
  13fbb0:	e153000b 	cmp	r3, fp
  13fbb4:	e1a0a003 	mov	sl, r3
  13fbb8:	8afffff9 	bhi	13fba4 <printf_core+0x10b4>
  13fbbc:	e59d3020 	ldr	r3, [sp, #32]
  13fbc0:	e0433005 	sub	r3, r3, r5
  13fbc4:	e3530000 	cmp	r3, #0
  13fbc8:	e58d3020 	str	r3, [sp, #32]
  13fbcc:	caffffa8 	bgt	13fa74 <printf_core+0xf84>
  13fbd0:	e58d8050 	str	r8, [sp, #80]	; 0x50
  13fbd4:	e58d9054 	str	r9, [sp, #84]	; 0x54
  13fbd8:	e58da01c 	str	sl, [sp, #28]
  13fbdc:	e59d5060 	ldr	r5, [sp, #96]	; 0x60
  13fbe0:	e59da048 	ldr	sl, [sp, #72]	; 0x48
  13fbe4:	e59d4064 	ldr	r4, [sp, #100]	; 0x64
  13fbe8:	e59d805c 	ldr	r8, [sp, #92]	; 0x5c
  13fbec:	e59d9058 	ldr	r9, [sp, #88]	; 0x58
  13fbf0:	e58d306c 	str	r3, [sp, #108]	; 0x6c
  13fbf4:	e59dc020 	ldr	ip, [sp, #32]
  13fbf8:	e35c0000 	cmp	ip, #0
  13fbfc:	0a000037 	beq	13fce0 <printf_core+0x11f0>
  13fc00:	e58da038 	str	sl, [sp, #56]	; 0x38
  13fc04:	e1a0a00c 	mov	sl, ip
  13fc08:	e51f10a0 	ldr	r1, [pc, #-160]	; 13fb70 <printf_core+0x1080>
  13fc0c:	e2850019 	add	r0, r5, #25
  13fc10:	e0832190 	umull	r2, r3, r0, r1
  13fc14:	e1a030a3 	lsr	r3, r3, #1
  13fc18:	e2836001 	add	r6, r3, #1
  13fc1c:	e1a03106 	lsl	r3, r6, #2
  13fc20:	e51f70b4 	ldr	r7, [pc, #-180]	; 13fb74 <printf_core+0x1084>
  13fc24:	e59d001c 	ldr	r0, [sp, #28]
  13fc28:	e58d3020 	str	r3, [sp, #32]
  13fc2c:	e58d9040 	str	r9, [sp, #64]	; 0x40
  13fc30:	e37a0009 	cmn	sl, #9
  13fc34:	a26ac000 	rsbge	ip, sl, #0
  13fc38:	b28aa009 	addlt	sl, sl, #9
  13fc3c:	b3a0c009 	movlt	ip, #9
  13fc40:	a3a0a000 	movge	sl, #0
  13fc44:	e150000b 	cmp	r0, fp
  13fc48:	e59b1000 	ldr	r1, [fp]
  13fc4c:	9a000191 	bls	140298 <printf_core+0x17a8>
  13fc50:	e3a0e001 	mov	lr, #1
  13fc54:	e1a0ec1e 	lsl	lr, lr, ip
  13fc58:	e1a0200b 	mov	r2, fp
  13fc5c:	e3a03000 	mov	r3, #0
  13fc60:	e24ee001 	sub	lr, lr, #1
  13fc64:	e1a09c57 	asr	r9, r7, ip
  13fc68:	ea000000 	b	13fc70 <printf_core+0x1180>
  13fc6c:	e5921000 	ldr	r1, [r2]
  13fc70:	e0833c31 	add	r3, r3, r1, lsr ip
  13fc74:	e4823004 	str	r3, [r2], #4
  13fc78:	e00e3001 	and	r3, lr, r1
  13fc7c:	e0010399 	mul	r1, r9, r3
  13fc80:	e1520000 	cmp	r2, r0
  13fc84:	e1a03001 	mov	r3, r1
  13fc88:	3afffff7 	bcc	13fc6c <printf_core+0x117c>
  13fc8c:	e59b2000 	ldr	r2, [fp]
  13fc90:	e3520000 	cmp	r2, #0
  13fc94:	028bb004 	addeq	fp, fp, #4
  13fc98:	e3510000 	cmp	r1, #0
  13fc9c:	15801000 	strne	r1, [r0]
  13fca0:	12800004 	addne	r0, r0, #4
  13fca4:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
  13fca8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  13fcac:	e3520066 	cmp	r2, #102	; 0x66
  13fcb0:	11a0300b 	movne	r3, fp
  13fcb4:	e0402003 	sub	r2, r0, r3
  13fcb8:	e1560142 	cmp	r6, r2, asr #2
  13fcbc:	b59d2020 	ldrlt	r2, [sp, #32]
  13fcc0:	b0830002 	addlt	r0, r3, r2
  13fcc4:	e35a0000 	cmp	sl, #0
  13fcc8:	1affffd8 	bne	13fc30 <printf_core+0x1140>
  13fccc:	e1a0300a 	mov	r3, sl
  13fcd0:	e59d9040 	ldr	r9, [sp, #64]	; 0x40
  13fcd4:	e59da038 	ldr	sl, [sp, #56]	; 0x38
  13fcd8:	e58d001c 	str	r0, [sp, #28]
  13fcdc:	e58d306c 	str	r3, [sp, #108]	; 0x6c
  13fce0:	e59d301c 	ldr	r3, [sp, #28]
  13fce4:	e153000b 	cmp	r3, fp
  13fce8:	91a03005 	movls	r3, r5
  13fcec:	93a06000 	movls	r6, #0
  13fcf0:	9a000013 	bls	13fd44 <printf_core+0x1254>
  13fcf4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  13fcf8:	e59b1000 	ldr	r1, [fp]
  13fcfc:	e043600b 	sub	r6, r3, fp
  13fd00:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
  13fd04:	e1a06146 	asr	r6, r6, #2
  13fd08:	e2530066 	subs	r0, r3, #102	; 0x66
  13fd0c:	13a00001 	movne	r0, #1
  13fd10:	e3510009 	cmp	r1, #9
  13fd14:	e0866186 	add	r6, r6, r6, lsl #3
  13fd18:	83a0200a 	movhi	r2, #10
  13fd1c:	81a03000 	movhi	r3, r0
  13fd20:	9a000005 	bls	13fd3c <printf_core+0x124c>
  13fd24:	e0822102 	add	r2, r2, r2, lsl #2
  13fd28:	e1a02082 	lsl	r2, r2, #1
  13fd2c:	e1510002 	cmp	r1, r2
  13fd30:	e2866001 	add	r6, r6, #1
  13fd34:	2afffffa 	bcs	13fd24 <printf_core+0x1234>
  13fd38:	e1a00003 	mov	r0, r3
  13fd3c:	e0030096 	mul	r3, r6, r0
  13fd40:	e0453003 	sub	r3, r5, r3
  13fd44:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
  13fd48:	e59d1044 	ldr	r1, [sp, #68]	; 0x44
  13fd4c:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
  13fd50:	e3520067 	cmp	r2, #103	; 0x67
  13fd54:	13a01000 	movne	r1, #0
  13fd58:	02011001 	andeq	r1, r1, #1
  13fd5c:	e59d201c 	ldr	r2, [sp, #28]
  13fd60:	e0433001 	sub	r3, r3, r1
  13fd64:	e042200c 	sub	r2, r2, ip
  13fd68:	e1a02142 	asr	r2, r2, #2
  13fd6c:	e2422001 	sub	r2, r2, #1
  13fd70:	e0822182 	add	r2, r2, r2, lsl #3
  13fd74:	e1530002 	cmp	r3, r2
  13fd78:	aa000057 	bge	13fedc <printf_core+0x13ec>
  13fd7c:	e51f2214 	ldr	r2, [pc, #-532]	; 13fb70 <printf_core+0x1080>
  13fd80:	e2833b09 	add	r3, r3, #9216	; 0x2400
  13fd84:	e0c10293 	smull	r0, r1, r3, r2
  13fd88:	e1a07fc3 	asr	r7, r3, #31
  13fd8c:	e06770c1 	rsb	r7, r7, r1, asr #1
  13fd90:	e0872187 	add	r2, r7, r7, lsl #3
  13fd94:	e0433002 	sub	r3, r3, r2
  13fd98:	e2833001 	add	r3, r3, #1
  13fd9c:	e2477fff 	sub	r7, r7, #1020	; 0x3fc
  13fda0:	e247710f 	sub	r7, r7, #-1073741821	; 0xc0000003
  13fda4:	e3530009 	cmp	r3, #9
  13fda8:	e08c7107 	add	r7, ip, r7, lsl #2
  13fdac:	0a00036b 	beq	140b60 <printf_core+0x2070>
  13fdb0:	e3a0200a 	mov	r2, #10
  13fdb4:	e2833001 	add	r3, r3, #1
  13fdb8:	e0822102 	add	r2, r2, r2, lsl #2
  13fdbc:	e3530009 	cmp	r3, #9
  13fdc0:	e1a02082 	lsl	r2, r2, #1
  13fdc4:	1afffffa 	bne	13fdb4 <printf_core+0x12c4>
  13fdc8:	e58d2038 	str	r2, [sp, #56]	; 0x38
  13fdcc:	e5973000 	ldr	r3, [r7]
  13fdd0:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
  13fdd4:	e1a00003 	mov	r0, r3
  13fdd8:	e58d3048 	str	r3, [sp, #72]	; 0x48
  13fddc:	ebffe39f 	bl	138c60 <__aeabi_uidivmod>
  13fde0:	e2513000 	subs	r3, r1, #0
  13fde4:	e58d3044 	str	r3, [sp, #68]	; 0x44
  13fde8:	1a000003 	bne	13fdfc <printf_core+0x130c>
  13fdec:	e59d301c 	ldr	r3, [sp, #28]
  13fdf0:	e287c004 	add	ip, r7, #4
  13fdf4:	e153000c 	cmp	r3, ip
  13fdf8:	0a000033 	beq	13fecc <printf_core+0x13dc>
  13fdfc:	e3100001 	tst	r0, #1
  13fe00:	1a000336 	bne	140ae0 <printf_core+0x1ff0>
  13fe04:	e51f3298 	ldr	r3, [pc, #-664]	; 13fb74 <printf_core+0x1084>
  13fe08:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
  13fe0c:	e157000b 	cmp	r7, fp
  13fe10:	e0422003 	sub	r2, r2, r3
  13fe14:	e16f2f12 	clz	r2, r2
  13fe18:	e1a022a2 	lsr	r2, r2, #5
  13fe1c:	93a02000 	movls	r2, #0
  13fe20:	e3520000 	cmp	r2, #0
  13fe24:	0a000329 	beq	140ad0 <printf_core+0x1fe0>
  13fe28:	e5173004 	ldr	r3, [r7, #-4]
  13fe2c:	e51f229c 	ldr	r2, [pc, #-668]	; 13fb98 <printf_core+0x10a8>
  13fe30:	e2033001 	and	r3, r3, #1
  13fe34:	e58d2020 	str	r2, [sp, #32]
  13fe38:	e58d3040 	str	r3, [sp, #64]	; 0x40
  13fe3c:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
  13fe40:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
  13fe44:	e15300c2 	cmp	r3, r2, asr #1
  13fe48:	3a00031d 	bcc	140ac4 <printf_core+0x1fd4>
  13fe4c:	13a0e000 	movne	lr, #0
  13fe50:	151fc2b8 	ldrne	ip, [pc, #-696]	; 13fba0 <printf_core+0x10b0>
  13fe54:	0a00032a 	beq	140b04 <printf_core+0x2014>
  13fe58:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  13fe5c:	e3530000 	cmp	r3, #0
  13fe60:	0a000006 	beq	13fe80 <printf_core+0x1390>
  13fe64:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
  13fe68:	e5d33000 	ldrb	r3, [r3]
  13fe6c:	e353002d 	cmp	r3, #45	; 0x2d
  13fe70:	059d3020 	ldreq	r3, [sp, #32]
  13fe74:	028cc102 	addeq	ip, ip, #-2147483648	; 0x80000000
  13fe78:	02833102 	addeq	r3, r3, #-2147483648	; 0x80000000
  13fe7c:	058d3020 	streq	r3, [sp, #32]
  13fe80:	e1a0200e 	mov	r2, lr
  13fe84:	e1a0300c 	mov	r3, ip
  13fe88:	e59de044 	ldr	lr, [sp, #68]	; 0x44
  13fe8c:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
  13fe90:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
  13fe94:	e04cc00e 	sub	ip, ip, lr
  13fe98:	e59d1020 	ldr	r1, [sp, #32]
  13fe9c:	e58dc044 	str	ip, [sp, #68]	; 0x44
  13fea0:	eb00129e 	bl	144920 <__adddf3>
  13fea4:	e1a02000 	mov	r2, r0
  13fea8:	e1a03001 	mov	r3, r1
  13feac:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
  13feb0:	e59d1020 	ldr	r1, [sp, #32]
  13feb4:	eb0014d4 	bl	14520c <__aeabi_dcmpeq>
  13feb8:	e2502000 	subs	r2, r0, #0
  13febc:	0a0002ab 	beq	140970 <printf_core+0x1e80>
  13fec0:	e1a0c007 	mov	ip, r7
  13fec4:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
  13fec8:	e48c3004 	str	r3, [ip], #4
  13fecc:	e59d301c 	ldr	r3, [sp, #28]
  13fed0:	e153000c 	cmp	r3, ip
  13fed4:	21a0300c 	movcs	r3, ip
  13fed8:	e58d301c 	str	r3, [sp, #28]
  13fedc:	e59d301c 	ldr	r3, [sp, #28]
  13fee0:	e15b0003 	cmp	fp, r3
  13fee4:	2a00000c 	bcs	13ff1c <printf_core+0x142c>
  13fee8:	e5133004 	ldr	r3, [r3, #-4]
  13feec:	e3530000 	cmp	r3, #0
  13fef0:	059d301c 	ldreq	r3, [sp, #28]
  13fef4:	02433004 	subeq	r3, r3, #4
  13fef8:	0a000003 	beq	13ff0c <printf_core+0x141c>
  13fefc:	ea000006 	b	13ff1c <printf_core+0x142c>
  13ff00:	e5332004 	ldr	r2, [r3, #-4]!
  13ff04:	e3520000 	cmp	r2, #0
  13ff08:	1a000002 	bne	13ff18 <printf_core+0x1428>
  13ff0c:	e153000b 	cmp	r3, fp
  13ff10:	e1a01003 	mov	r1, r3
  13ff14:	8afffff9 	bhi	13ff00 <printf_core+0x1410>
  13ff18:	e58d101c 	str	r1, [sp, #28]
  13ff1c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
  13ff20:	e3530067 	cmp	r3, #103	; 0x67
  13ff24:	0a000192 	beq	140574 <printf_core+0x1a84>
  13ff28:	e3550000 	cmp	r5, #0
  13ff2c:	1a00018b 	bne	140560 <printf_core+0x1a70>
  13ff30:	e3a02001 	mov	r2, #1
  13ff34:	e1a031a8 	lsr	r3, r8, #3
  13ff38:	e0033002 	and	r3, r3, r2
  13ff3c:	e3e0e102 	mvn	lr, #-2147483648	; 0x80000000
  13ff40:	e59d1010 	ldr	r1, [sp, #16]
  13ff44:	e0833002 	add	r3, r3, r2
  13ff48:	e381a020 	orr	sl, r1, #32
  13ff4c:	e35a0066 	cmp	sl, #102	; 0x66
  13ff50:	e04ee003 	sub	lr, lr, r3
  13ff54:	0a000280 	beq	14095c <printf_core+0x1e6c>
  13ff58:	e026cfc6 	eor	ip, r6, r6, asr #31
  13ff5c:	e28d7090 	add	r7, sp, #144	; 0x90
  13ff60:	e3560000 	cmp	r6, #0
  13ff64:	e04ccfc6 	sub	ip, ip, r6, asr #31
  13ff68:	e1a02007 	mov	r2, r7
  13ff6c:	0a00000a 	beq	13ff9c <printf_core+0x14ac>
  13ff70:	e58d3020 	str	r3, [sp, #32]
  13ff74:	e51f33f8 	ldr	r3, [pc, #-1016]	; 13fb84 <printf_core+0x1094>
  13ff78:	e081039c 	umull	r0, r1, ip, r3
  13ff7c:	e1a001a1 	lsr	r0, r1, #3
  13ff80:	e0801100 	add	r1, r0, r0, lsl #2
  13ff84:	e04c1081 	sub	r1, ip, r1, lsl #1
  13ff88:	e2811030 	add	r1, r1, #48	; 0x30
  13ff8c:	e250c000 	subs	ip, r0, #0
  13ff90:	e5621001 	strb	r1, [r2, #-1]!
  13ff94:	1afffff6 	bne	13ff74 <printf_core+0x1484>
  13ff98:	e59d3020 	ldr	r3, [sp, #32]
  13ff9c:	e0471002 	sub	r1, r7, r2
  13ffa0:	e3510001 	cmp	r1, #1
  13ffa4:	ca000004 	bgt	13ffbc <printf_core+0x14cc>
  13ffa8:	e3a01030 	mov	r1, #48	; 0x30
  13ffac:	e5621001 	strb	r1, [r2, #-1]!
  13ffb0:	e0470002 	sub	r0, r7, r2
  13ffb4:	e3500001 	cmp	r0, #1
  13ffb8:	dafffffb 	ble	13ffac <printf_core+0x14bc>
  13ffbc:	e3560000 	cmp	r6, #0
  13ffc0:	a3a0102b 	movge	r1, #43	; 0x2b
  13ffc4:	b3a0102d 	movlt	r1, #45	; 0x2d
  13ffc8:	e2420002 	sub	r0, r2, #2
  13ffcc:	e0477000 	sub	r7, r7, r0
  13ffd0:	e58d004c 	str	r0, [sp, #76]	; 0x4c
  13ffd4:	e59d0010 	ldr	r0, [sp, #16]
  13ffd8:	e157000e 	cmp	r7, lr
  13ffdc:	e5420002 	strb	r0, [r2, #-2]
  13ffe0:	e5421001 	strb	r1, [r2, #-1]
  13ffe4:	cafffc6e 	bgt	13f1a4 <printf_core+0x6b4>
  13ffe8:	e0833007 	add	r3, r3, r7
  13ffec:	e3e02102 	mvn	r2, #-2147483648	; 0x80000000
  13fff0:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
  13fff4:	e0422001 	sub	r2, r2, r1
  13fff8:	e1520003 	cmp	r2, r3
  13fffc:	bafffc68 	blt	13f1a4 <printf_core+0x6b4>
  140000:	e0813003 	add	r3, r1, r3
  140004:	e1590003 	cmp	r9, r3
  140008:	e58d3010 	str	r3, [sp, #16]
  14000c:	c3a03000 	movgt	r3, #0
  140010:	d3a03001 	movle	r3, #1
  140014:	e3180a12 	tst	r8, #73728	; 0x12000
  140018:	e58d3020 	str	r3, [sp, #32]
  14001c:	13a03001 	movne	r3, #1
  140020:	e3530000 	cmp	r3, #0
  140024:	0a000246 	beq	140944 <printf_core+0x1e54>
  140028:	e59d3004 	ldr	r3, [sp, #4]
  14002c:	e5933000 	ldr	r3, [r3]
  140030:	e3130020 	tst	r3, #32
  140034:	0a00023d 	beq	140930 <printf_core+0x1e40>
  140038:	e2283801 	eor	r3, r8, #65536	; 0x10000
  14003c:	e3130a12 	tst	r3, #73728	; 0x12000
  140040:	e59d3020 	ldr	r3, [sp, #32]
  140044:	13a03001 	movne	r3, #1
  140048:	e3530000 	cmp	r3, #0
  14004c:	0a000231 	beq	140918 <printf_core+0x1e28>
  140050:	e35a0066 	cmp	sl, #102	; 0x66
  140054:	0a00018f 	beq	140698 <printf_core+0x1ba8>
  140058:	e59d301c 	ldr	r3, [sp, #28]
  14005c:	e15b0003 	cmp	fp, r3
  140060:	228b3004 	addcs	r3, fp, #4
  140064:	258d301c 	strcs	r3, [sp, #28]
  140068:	e59d301c 	ldr	r3, [sp, #28]
  14006c:	e15b0003 	cmp	fp, r3
  140070:	23a03000 	movcs	r3, #0
  140074:	33a03001 	movcc	r3, #1
  140078:	e3550000 	cmp	r5, #0
  14007c:	b3a03000 	movlt	r3, #0
  140080:	e3530000 	cmp	r3, #0
  140084:	0a000036 	beq	140164 <printf_core+0x1674>
  140088:	e1a0600b 	mov	r6, fp
  14008c:	e28d7090 	add	r7, sp, #144	; 0x90
  140090:	e58d9030 	str	r9, [sp, #48]	; 0x30
  140094:	e59d9004 	ldr	r9, [sp, #4]
  140098:	e287a009 	add	sl, r7, #9
  14009c:	e58d802c 	str	r8, [sp, #44]	; 0x2c
  1400a0:	e58d4034 	str	r4, [sp, #52]	; 0x34
  1400a4:	e5962000 	ldr	r2, [r6]
  1400a8:	e599e000 	ldr	lr, [r9]
  1400ac:	e3520000 	cmp	r2, #0
  1400b0:	1287c009 	addne	ip, r7, #9
  1400b4:	0a000046 	beq	1401d4 <printf_core+0x16e4>
  1400b8:	e51f353c 	ldr	r3, [pc, #-1340]	; 13fb84 <printf_core+0x1094>
  1400bc:	e0810392 	umull	r0, r1, r2, r3
  1400c0:	e1a031a1 	lsr	r3, r1, #3
  1400c4:	e0831103 	add	r1, r3, r3, lsl #2
  1400c8:	e0422081 	sub	r2, r2, r1, lsl #1
  1400cc:	e2821030 	add	r1, r2, #48	; 0x30
  1400d0:	e2532000 	subs	r2, r3, #0
  1400d4:	e56c1001 	strb	r1, [ip, #-1]!
  1400d8:	1afffff6 	bne	1400b8 <printf_core+0x15c8>
  1400dc:	e2872009 	add	r2, r7, #9
  1400e0:	e15c0002 	cmp	ip, r2
  1400e4:	0a00003a 	beq	1401d4 <printf_core+0x16e4>
  1400e8:	e15b0006 	cmp	fp, r6
  1400ec:	e20ee020 	and	lr, lr, #32
  1400f0:	0a00003d 	beq	1401ec <printf_core+0x16fc>
  1400f4:	e15c0007 	cmp	ip, r7
  1400f8:	9a000003 	bls	14010c <printf_core+0x161c>
  1400fc:	e3a02030 	mov	r2, #48	; 0x30
  140100:	e56c2001 	strb	r2, [ip, #-1]!
  140104:	e15c0007 	cmp	ip, r7
  140108:	8afffffc 	bhi	140100 <printf_core+0x1610>
  14010c:	e04a400c 	sub	r4, sl, ip
  140110:	e35e0000 	cmp	lr, #0
  140114:	1a000005 	bne	140130 <printf_core+0x1640>
  140118:	e1550004 	cmp	r5, r4
  14011c:	e1a0000c 	mov	r0, ip
  140120:	b1a01005 	movlt	r1, r5
  140124:	a1a01004 	movge	r1, r4
  140128:	e1a02009 	mov	r2, r9
  14012c:	eb000f34 	bl	143e04 <__fwritex>
  140130:	e59d201c 	ldr	r2, [sp, #28]
  140134:	e2866004 	add	r6, r6, #4
  140138:	e1560002 	cmp	r6, r2
  14013c:	e0455004 	sub	r5, r5, r4
  140140:	23a02000 	movcs	r2, #0
  140144:	33a02001 	movcc	r2, #1
  140148:	e3550000 	cmp	r5, #0
  14014c:	b3a02000 	movlt	r2, #0
  140150:	e3520000 	cmp	r2, #0
  140154:	1affffd2 	bne	1400a4 <printf_core+0x15b4>
  140158:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
  14015c:	e59d802c 	ldr	r8, [sp, #44]	; 0x2c
  140160:	e59d4034 	ldr	r4, [sp, #52]	; 0x34
  140164:	e2852012 	add	r2, r5, #18
  140168:	e3520012 	cmp	r2, #18
  14016c:	da000003 	ble	140180 <printf_core+0x1690>
  140170:	e3a03012 	mov	r3, #18
  140174:	e3a01030 	mov	r1, #48	; 0x30
  140178:	e59d0004 	ldr	r0, [sp, #4]
  14017c:	ebfffa30 	bl	13ea44 <pad.part.0>
  140180:	e59d3004 	ldr	r3, [sp, #4]
  140184:	e5933000 	ldr	r3, [r3]
  140188:	e3130020 	tst	r3, #32
  14018c:	1a000005 	bne	1401a8 <printf_core+0x16b8>
  140190:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
  140194:	e28d7090 	add	r7, sp, #144	; 0x90
  140198:	e0471003 	sub	r1, r7, r3
  14019c:	e59d2004 	ldr	r2, [sp, #4]
  1401a0:	e1a00003 	mov	r0, r3
  1401a4:	eb000f16 	bl	143e04 <__fwritex>
  1401a8:	e2283a02 	eor	r3, r8, #8192	; 0x2000
  1401ac:	e3130a12 	tst	r3, #73728	; 0x12000
  1401b0:	e59d3020 	ldr	r3, [sp, #32]
  1401b4:	13a03001 	movne	r3, #1
  1401b8:	e3530000 	cmp	r3, #0
  1401bc:	0a00023a 	beq	140aac <printf_core+0x1fbc>
  1401c0:	e59d3010 	ldr	r3, [sp, #16]
  1401c4:	e1590003 	cmp	r9, r3
  1401c8:	a1a0a009 	movge	sl, r9
  1401cc:	b1a0a003 	movlt	sl, r3
  1401d0:	eafffbf0 	b	13f198 <printf_core+0x6a8>
  1401d4:	e3a02030 	mov	r2, #48	; 0x30
  1401d8:	e15b0006 	cmp	fp, r6
  1401dc:	e28dc098 	add	ip, sp, #152	; 0x98
  1401e0:	e20ee020 	and	lr, lr, #32
  1401e4:	e5cd2098 	strb	r2, [sp, #152]	; 0x98
  1401e8:	1affffc3 	bne	1400fc <printf_core+0x160c>
  1401ec:	e35e0000 	cmp	lr, #0
  1401f0:	e28c8001 	add	r8, ip, #1
  1401f4:	0a00002a 	beq	1402a4 <printf_core+0x17b4>
  1401f8:	e3550000 	cmp	r5, #0
  1401fc:	e04a4008 	sub	r4, sl, r8
  140200:	1affffca 	bne	140130 <printf_core+0x1640>
  140204:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  140208:	e3130008 	tst	r3, #8
  14020c:	1a00002d 	bne	1402c8 <printf_core+0x17d8>
  140210:	e1a0c008 	mov	ip, r8
  140214:	eaffffbd 	b	140110 <printf_core+0x1620>
  140218:	e1a0300b 	mov	r3, fp
  14021c:	e1a02009 	mov	r2, r9
  140220:	e3a01020 	mov	r1, #32
  140224:	e59d0004 	ldr	r0, [sp, #4]
  140228:	ebfffa05 	bl	13ea44 <pad.part.0>
  14022c:	eafffd7b 	b	13f820 <printf_core+0xd30>
  140230:	e3a03001 	mov	r3, #1
  140234:	e58d3020 	str	r3, [sp, #32]
  140238:	e51f36c8 	ldr	r3, [pc, #-1736]	; 13fb78 <printf_core+0x1088>
  14023c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  140240:	eafffc20 	b	13f2c8 <printf_core+0x7d8>
  140244:	e3a03000 	mov	r3, #0
  140248:	e58d3000 	str	r3, [sp]
  14024c:	eafffb44 	b	13ef64 <printf_core+0x474>
  140250:	e59d5004 	ldr	r5, [sp, #4]
  140254:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
  140258:	e1a02005 	mov	r2, r5
  14025c:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
  140260:	eb000ee7 	bl	143e04 <__fwritex>
  140264:	e5953000 	ldr	r3, [r5]
  140268:	e1a02005 	mov	r2, r5
  14026c:	e3130020 	tst	r3, #32
  140270:	1afffcc9 	bne	13f59c <printf_core+0xaac>
  140274:	e1a00006 	mov	r0, r6
  140278:	e3a01003 	mov	r1, #3
  14027c:	eb000ee0 	bl	143e04 <__fwritex>
  140280:	eafffcc5 	b	13f59c <printf_core+0xaac>
  140284:	e3a03001 	mov	r3, #1
  140288:	e58d3030 	str	r3, [sp, #48]	; 0x30
  14028c:	e51f3718 	ldr	r3, [pc, #-1816]	; 13fb7c <printf_core+0x108c>
  140290:	e58d3034 	str	r3, [sp, #52]	; 0x34
  140294:	eafffc9a 	b	13f504 <printf_core+0xa14>
  140298:	e3510000 	cmp	r1, #0
  14029c:	028bb004 	addeq	fp, fp, #4
  1402a0:	eafffe7f 	b	13fca4 <printf_core+0x11b4>
  1402a4:	e1a0000c 	mov	r0, ip
  1402a8:	e1a02009 	mov	r2, r9
  1402ac:	e3a01001 	mov	r1, #1
  1402b0:	eb000ed3 	bl	143e04 <__fwritex>
  1402b4:	e599e000 	ldr	lr, [r9]
  1402b8:	e3550000 	cmp	r5, #0
  1402bc:	e20ee020 	and	lr, lr, #32
  1402c0:	e04a4008 	sub	r4, sl, r8
  1402c4:	0affffce 	beq	140204 <printf_core+0x1714>
  1402c8:	e35e0000 	cmp	lr, #0
  1402cc:	1affff97 	bne	140130 <printf_core+0x1640>
  1402d0:	e1a02009 	mov	r2, r9
  1402d4:	e3a01001 	mov	r1, #1
  1402d8:	e51f0758 	ldr	r0, [pc, #-1880]	; 13fb88 <printf_core+0x1098>
  1402dc:	eb000ec8 	bl	143e04 <__fwritex>
  1402e0:	e599e000 	ldr	lr, [r9]
  1402e4:	e1a0c008 	mov	ip, r8
  1402e8:	e20ee020 	and	lr, lr, #32
  1402ec:	eaffff87 	b	140110 <printf_core+0x1620>
  1402f0:	e1a0300a 	mov	r3, sl
  1402f4:	e1a02009 	mov	r2, r9
  1402f8:	e3a01020 	mov	r1, #32
  1402fc:	e59d0004 	ldr	r0, [sp, #4]
  140300:	ebfff9cf 	bl	13ea44 <pad.part.0>
  140304:	eafffca9 	b	13f5b0 <printf_core+0xac0>
  140308:	e59d3010 	ldr	r3, [sp, #16]
  14030c:	e213b020 	ands	fp, r3, #32
  140310:	159d3034 	ldrne	r3, [sp, #52]	; 0x34
  140314:	12833009 	addne	r3, r3, #9
  140318:	158d3034 	strne	r3, [sp, #52]	; 0x34
  14031c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  140320:	e355000b 	cmp	r5, #11
  140324:	e2833002 	add	r3, r3, #2
  140328:	e58d3030 	str	r3, [sp, #48]	; 0x30
  14032c:	9a0001b8 	bls	140a14 <printf_core+0x1f24>
  140330:	e59d2020 	ldr	r2, [sp, #32]
  140334:	e28d7090 	add	r7, sp, #144	; 0x90
  140338:	e3520000 	cmp	r2, #0
  14033c:	e1a03002 	mov	r3, r2
  140340:	b2623000 	rsblt	r3, r2, #0
  140344:	e3520000 	cmp	r2, #0
  140348:	11a0c007 	movne	ip, r7
  14034c:	0a0001ac 	beq	140a04 <printf_core+0x1f14>
  140350:	e51f27d4 	ldr	r2, [pc, #-2004]	; 13fb84 <printf_core+0x1094>
  140354:	e0810293 	umull	r0, r1, r3, r2
  140358:	e1a021a1 	lsr	r2, r1, #3
  14035c:	e0821102 	add	r1, r2, r2, lsl #2
  140360:	e0433081 	sub	r3, r3, r1, lsl #1
  140364:	e2831030 	add	r1, r3, #48	; 0x30
  140368:	e2523000 	subs	r3, r2, #0
  14036c:	e56c1001 	strb	r1, [ip, #-1]!
  140370:	1afffff6 	bne	140350 <printf_core+0x1860>
  140374:	e15c0007 	cmp	ip, r7
  140378:	0a0001a1 	beq	140a04 <printf_core+0x1f14>
  14037c:	e59d3020 	ldr	r3, [sp, #32]
  140380:	e59d2010 	ldr	r2, [sp, #16]
  140384:	e3530000 	cmp	r3, #0
  140388:	a3a0302b 	movge	r3, #43	; 0x2b
  14038c:	b3a0302d 	movlt	r3, #45	; 0x2d
  140390:	e54c3001 	strb	r3, [ip, #-1]
  140394:	e24c3002 	sub	r3, ip, #2
  140398:	e282200f 	add	r2, r2, #15
  14039c:	e58d3010 	str	r3, [sp, #16]
  1403a0:	e2083008 	and	r3, r8, #8
  1403a4:	e58db020 	str	fp, [sp, #32]
  1403a8:	e58d8040 	str	r8, [sp, #64]	; 0x40
  1403ac:	e58d4044 	str	r4, [sp, #68]	; 0x44
  1403b0:	e1a0b007 	mov	fp, r7
  1403b4:	e51f683c 	ldr	r6, [pc, #-2108]	; 13fb80 <printf_core+0x1090>
  1403b8:	e54c2002 	strb	r2, [ip, #-2]
  1403bc:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  1403c0:	e58da03c 	str	sl, [sp, #60]	; 0x3c
  1403c4:	e59d401c 	ldr	r4, [sp, #28]
  1403c8:	e59d8038 	ldr	r8, [sp, #56]	; 0x38
  1403cc:	ea000007 	b	1403f0 <printf_core+0x1900>
  1403d0:	e1a0b00a 	mov	fp, sl
  1403d4:	e1a00004 	mov	r0, r4
  1403d8:	e1a01008 	mov	r1, r8
  1403dc:	e3a02000 	mov	r2, #0
  1403e0:	e3a03000 	mov	r3, #0
  1403e4:	eb001388 	bl	14520c <__aeabi_dcmpeq>
  1403e8:	e3500000 	cmp	r0, #0
  1403ec:	1a000026 	bne	14048c <printf_core+0x199c>
  1403f0:	e1a01008 	mov	r1, r8
  1403f4:	e1a00004 	mov	r0, r4
  1403f8:	eb00139c 	bl	145270 <__aeabi_d2iz>
  1403fc:	e59d2020 	ldr	r2, [sp, #32]
  140400:	e7d63000 	ldrb	r3, [r6, r0]
  140404:	e28ba001 	add	sl, fp, #1
  140408:	e1823003 	orr	r3, r2, r3
  14040c:	e5cb3000 	strb	r3, [fp]
  140410:	eb0011f6 	bl	144bf0 <__aeabi_i2d>
  140414:	e1a02000 	mov	r2, r0
  140418:	e1a03001 	mov	r3, r1
  14041c:	e1a00004 	mov	r0, r4
  140420:	e1a01008 	mov	r1, r8
  140424:	eb00113c 	bl	14491c <__aeabi_dsub>
  140428:	e51f38a0 	ldr	r3, [pc, #-2208]	; 13fb90 <printf_core+0x10a0>
  14042c:	e3a02000 	mov	r2, #0
  140430:	eb001227 	bl	144cd4 <__aeabi_dmul>
  140434:	e04a3007 	sub	r3, sl, r7
  140438:	e3530001 	cmp	r3, #1
  14043c:	e1a04000 	mov	r4, r0
  140440:	e1a08001 	mov	r8, r1
  140444:	1affffe1 	bne	1403d0 <printf_core+0x18e0>
  140448:	e3a03000 	mov	r3, #0
  14044c:	e3a02000 	mov	r2, #0
  140450:	eb00136d 	bl	14520c <__aeabi_dcmpeq>
  140454:	e3500000 	cmp	r0, #0
  140458:	e3a03001 	mov	r3, #1
  14045c:	13a03000 	movne	r3, #0
  140460:	e3550000 	cmp	r5, #0
  140464:	c3833001 	orrgt	r3, r3, #1
  140468:	e3130001 	tst	r3, #1
  14046c:	1a000002 	bne	14047c <printf_core+0x198c>
  140470:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  140474:	e3530000 	cmp	r3, #0
  140478:	0affffd4 	beq	1403d0 <printf_core+0x18e0>
  14047c:	e3a0302e 	mov	r3, #46	; 0x2e
  140480:	e28bb002 	add	fp, fp, #2
  140484:	e54b3001 	strb	r3, [fp, #-1]
  140488:	eaffffd1 	b	1403d4 <printf_core+0x18e4>
  14048c:	e3e0310a 	mvn	r3, #-2147483646	; 0x80000002
  140490:	e59d2010 	ldr	r2, [sp, #16]
  140494:	e59da03c 	ldr	sl, [sp, #60]	; 0x3c
  140498:	e0476002 	sub	r6, r7, r2
  14049c:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
  1404a0:	e0433006 	sub	r3, r3, r6
  1404a4:	e0433002 	sub	r3, r3, r2
  1404a8:	e1550003 	cmp	r5, r3
  1404ac:	e59d8040 	ldr	r8, [sp, #64]	; 0x40
  1404b0:	e59d4044 	ldr	r4, [sp, #68]	; 0x44
  1404b4:	cafffb3a 	bgt	13f1a4 <printf_core+0x6b4>
  1404b8:	e04b2007 	sub	r2, fp, r7
  1404bc:	e3550000 	cmp	r5, #0
  1404c0:	e58d201c 	str	r2, [sp, #28]
  1404c4:	0a000065 	beq	140660 <printf_core+0x1b70>
  1404c8:	e2423001 	sub	r3, r2, #1
  1404cc:	e1550003 	cmp	r5, r3
  1404d0:	ba000062 	blt	140660 <printf_core+0x1b70>
  1404d4:	e2853002 	add	r3, r5, #2
  1404d8:	e0865003 	add	r5, r6, r3
  1404dc:	e043a002 	sub	sl, r3, r2
  1404e0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  1404e4:	e0835005 	add	r5, r3, r5
  1404e8:	e1590005 	cmp	r9, r5
  1404ec:	c3a0b000 	movgt	fp, #0
  1404f0:	d3a0b001 	movle	fp, #1
  1404f4:	e3180a12 	tst	r8, #73728	; 0x12000
  1404f8:	01a0300b 	moveq	r3, fp
  1404fc:	13a03001 	movne	r3, #1
  140500:	e3530000 	cmp	r3, #0
  140504:	0a0001a8 	beq	140bac <printf_core+0x20bc>
  140508:	e59d3004 	ldr	r3, [sp, #4]
  14050c:	e5933000 	ldr	r3, [r3]
  140510:	e3130020 	tst	r3, #32
  140514:	0a0000e4 	beq	1408ac <printf_core+0x1dbc>
  140518:	e2283801 	eor	r3, r8, #65536	; 0x10000
  14051c:	e3130a12 	tst	r3, #73728	; 0x12000
  140520:	01a0300b 	moveq	r3, fp
  140524:	13a03001 	movne	r3, #1
  140528:	e3530000 	cmp	r3, #0
  14052c:	0a000198 	beq	140b94 <printf_core+0x20a4>
  140530:	e35a0000 	cmp	sl, #0
  140534:	ca00012c 	bgt	1409ec <printf_core+0x1efc>
  140538:	e2283a02 	eor	r3, r8, #8192	; 0x2000
  14053c:	e3130a12 	tst	r3, #73728	; 0x12000
  140540:	01a0300b 	moveq	r3, fp
  140544:	13a03001 	movne	r3, #1
  140548:	e3530000 	cmp	r3, #0
  14054c:	0a000186 	beq	140b6c <printf_core+0x207c>
  140550:	e1590005 	cmp	r9, r5
  140554:	a1a0a009 	movge	sl, r9
  140558:	b1a0a005 	movlt	sl, r5
  14055c:	eafffb0d 	b	13f198 <printf_core+0x6a8>
  140560:	e375010e 	cmn	r5, #-2147483645	; 0x80000003
  140564:	cafffb0e 	bgt	13f1a4 <printf_core+0x6b4>
  140568:	e2852001 	add	r2, r5, #1
  14056c:	e3a03001 	mov	r3, #1
  140570:	eafffe71 	b	13ff3c <printf_core+0x144c>
  140574:	e3550000 	cmp	r5, #0
  140578:	03a05001 	moveq	r5, #1
  14057c:	e3760004 	cmn	r6, #4
  140580:	a1550006 	cmpge	r5, r6
  140584:	c59d2010 	ldrgt	r2, [sp, #16]
  140588:	d59d3010 	ldrle	r3, [sp, #16]
  14058c:	c2863001 	addgt	r3, r6, #1
  140590:	c2422001 	subgt	r2, r2, #1
  140594:	d2433002 	suble	r3, r3, #2
  140598:	c58d2010 	strgt	r2, [sp, #16]
  14059c:	c0455003 	subgt	r5, r5, r3
  1405a0:	d58d3010 	strle	r3, [sp, #16]
  1405a4:	d2455001 	suble	r5, r5, #1
  1405a8:	e3180008 	tst	r8, #8
  1405ac:	1afffe5d 	bne	13ff28 <printf_core+0x1438>
  1405b0:	e59d301c 	ldr	r3, [sp, #28]
  1405b4:	e15b0003 	cmp	fp, r3
  1405b8:	2a000034 	bcs	140690 <printf_core+0x1ba0>
  1405bc:	e5137004 	ldr	r7, [r3, #-4]
  1405c0:	e3570000 	cmp	r7, #0
  1405c4:	0a000031 	beq	140690 <printf_core+0x1ba0>
  1405c8:	e3a0100a 	mov	r1, #10
  1405cc:	e1a00007 	mov	r0, r7
  1405d0:	ebffe1a2 	bl	138c60 <__aeabi_uidivmod>
  1405d4:	e3510000 	cmp	r1, #0
  1405d8:	1a00000b 	bne	14060c <printf_core+0x1b1c>
  1405dc:	e3a0300a 	mov	r3, #10
  1405e0:	e58d4020 	str	r4, [sp, #32]
  1405e4:	e1a04003 	mov	r4, r3
  1405e8:	e0844104 	add	r4, r4, r4, lsl #2
  1405ec:	e1a04084 	lsl	r4, r4, #1
  1405f0:	e1a01004 	mov	r1, r4
  1405f4:	e1a00007 	mov	r0, r7
  1405f8:	ebffe198 	bl	138c60 <__aeabi_uidivmod>
  1405fc:	e3510000 	cmp	r1, #0
  140600:	e28aa001 	add	sl, sl, #1
  140604:	0afffff7 	beq	1405e8 <printf_core+0x1af8>
  140608:	e59d4020 	ldr	r4, [sp, #32]
  14060c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
  140610:	e59d301c 	ldr	r3, [sp, #28]
  140614:	e0433002 	sub	r3, r3, r2
  140618:	e59d2010 	ldr	r2, [sp, #16]
  14061c:	e1a03143 	asr	r3, r3, #2
  140620:	e3822020 	orr	r2, r2, #32
  140624:	e2433001 	sub	r3, r3, #1
  140628:	e3520066 	cmp	r2, #102	; 0x66
  14062c:	e0833183 	add	r3, r3, r3, lsl #3
  140630:	10863003 	addne	r3, r6, r3
  140634:	e043300a 	sub	r3, r3, sl
  140638:	e1c33fc3 	bic	r3, r3, r3, asr #31
  14063c:	e1550003 	cmp	r5, r3
  140640:	a1a05003 	movge	r5, r3
  140644:	eafffe37 	b	13ff28 <printf_core+0x1438>
  140648:	e1a0300a 	mov	r3, sl
  14064c:	e1a02009 	mov	r2, r9
  140650:	e3a01020 	mov	r1, #32
  140654:	e59d0004 	ldr	r0, [sp, #4]
  140658:	ebfff8f9 	bl	13ea44 <pad.part.0>
  14065c:	eafffbca 	b	13f58c <printf_core+0xa9c>
  140660:	e59d301c 	ldr	r3, [sp, #28]
  140664:	e0865003 	add	r5, r6, r3
  140668:	eaffff9c 	b	1404e0 <printf_core+0x19f0>
  14066c:	e59d32f0 	ldr	r3, [sp, #752]	; 0x2f0
  140670:	e0832105 	add	r2, r3, r5, lsl #2
  140674:	e2833024 	add	r3, r3, #36	; 0x24
  140678:	e1530002 	cmp	r3, r2
  14067c:	0afffb08 	beq	13f2a4 <printf_core+0x7b4>
  140680:	e5b21004 	ldr	r1, [r2, #4]!
  140684:	e3510000 	cmp	r1, #0
  140688:	0afffffa 	beq	140678 <printf_core+0x1b88>
  14068c:	eafffa2f 	b	13ef50 <printf_core+0x460>
  140690:	e3a0a009 	mov	sl, #9
  140694:	eaffffdc 	b	14060c <printf_core+0x1b1c>
  140698:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  14069c:	e15b0003 	cmp	fp, r3
  1406a0:	31a0a00b 	movcc	sl, fp
  1406a4:	21a0a003 	movcs	sl, r3
  1406a8:	e15a0003 	cmp	sl, r3
  1406ac:	8a00002f 	bhi	140770 <printf_core+0x1c80>
  1406b0:	e28d7090 	add	r7, sp, #144	; 0x90
  1406b4:	e043b00a 	sub	fp, r3, sl
  1406b8:	e2872009 	add	r2, r7, #9
  1406bc:	e58d2030 	str	r2, [sp, #48]	; 0x30
  1406c0:	e58d2034 	str	r2, [sp, #52]	; 0x34
  1406c4:	e3cb2003 	bic	r2, fp, #3
  1406c8:	e08a3002 	add	r3, sl, r2
  1406cc:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  1406d0:	e24a3004 	sub	r3, sl, #4
  1406d4:	e58db038 	str	fp, [sp, #56]	; 0x38
  1406d8:	e3a06030 	mov	r6, #48	; 0x30
  1406dc:	e1a0b004 	mov	fp, r4
  1406e0:	e1a04003 	mov	r4, r3
  1406e4:	e5b4c004 	ldr	ip, [r4, #4]!
  1406e8:	e35c0000 	cmp	ip, #0
  1406ec:	0a000068 	beq	140894 <printf_core+0x1da4>
  1406f0:	e2870009 	add	r0, r7, #9
  1406f4:	e51f1b78 	ldr	r1, [pc, #-2936]	; 13fb84 <printf_core+0x1094>
  1406f8:	e083219c 	umull	r2, r3, ip, r1
  1406fc:	e1a021a3 	lsr	r2, r3, #3
  140700:	e0823102 	add	r3, r2, r2, lsl #2
  140704:	e04c3083 	sub	r3, ip, r3, lsl #1
  140708:	e2833030 	add	r3, r3, #48	; 0x30
  14070c:	e252c000 	subs	ip, r2, #0
  140710:	e5603001 	strb	r3, [r0, #-1]!
  140714:	1afffff6 	bne	1406f4 <printf_core+0x1c04>
  140718:	e15a0004 	cmp	sl, r4
  14071c:	1a000001 	bne	140728 <printf_core+0x1c38>
  140720:	ea000117 	b	140b84 <printf_core+0x2094>
  140724:	e5606001 	strb	r6, [r0, #-1]!
  140728:	e1500007 	cmp	r0, r7
  14072c:	8afffffc 	bhi	140724 <printf_core+0x1c34>
  140730:	e59d3004 	ldr	r3, [sp, #4]
  140734:	e5932000 	ldr	r2, [r3]
  140738:	e3120020 	tst	r2, #32
  14073c:	1a000003 	bne	140750 <printf_core+0x1c60>
  140740:	e1a02003 	mov	r2, r3
  140744:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
  140748:	e0431000 	sub	r1, r3, r0
  14074c:	eb000dac 	bl	143e04 <__fwritex>
  140750:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  140754:	e1530004 	cmp	r3, r4
  140758:	1affffe1 	bne	1406e4 <printf_core+0x1bf4>
  14075c:	e1a0400b 	mov	r4, fp
  140760:	e59db038 	ldr	fp, [sp, #56]	; 0x38
  140764:	e3cb3003 	bic	r3, fp, #3
  140768:	e2833004 	add	r3, r3, #4
  14076c:	e08aa003 	add	sl, sl, r3
  140770:	e3550000 	cmp	r5, #0
  140774:	0a00003b 	beq	140868 <printf_core+0x1d78>
  140778:	e59d3004 	ldr	r3, [sp, #4]
  14077c:	e5933000 	ldr	r3, [r3]
  140780:	e3130020 	tst	r3, #32
  140784:	0a00003d 	beq	140880 <printf_core+0x1d90>
  140788:	e59d201c 	ldr	r2, [sp, #28]
  14078c:	e3550000 	cmp	r5, #0
  140790:	d3a03000 	movle	r3, #0
  140794:	c3a03001 	movgt	r3, #1
  140798:	e15a0002 	cmp	sl, r2
  14079c:	23a03000 	movcs	r3, #0
  1407a0:	e3530000 	cmp	r3, #0
  1407a4:	0a000027 	beq	140848 <printf_core+0x1d58>
  1407a8:	e1a0600a 	mov	r6, sl
  1407ac:	e3a0a030 	mov	sl, #48	; 0x30
  1407b0:	e59db004 	ldr	fp, [sp, #4]
  1407b4:	e28d7090 	add	r7, sp, #144	; 0x90
  1407b8:	e4963004 	ldr	r3, [r6], #4
  1407bc:	e287c009 	add	ip, r7, #9
  1407c0:	e3530000 	cmp	r3, #0
  1407c4:	0a00000a 	beq	1407f4 <printf_core+0x1d04>
  1407c8:	e1a01003 	mov	r1, r3
  1407cc:	e51f0c50 	ldr	r0, [pc, #-3152]	; 13fb84 <printf_core+0x1094>
  1407d0:	e0832091 	umull	r2, r3, r1, r0
  1407d4:	e1a031a3 	lsr	r3, r3, #3
  1407d8:	e0832103 	add	r2, r3, r3, lsl #2
  1407dc:	e0412082 	sub	r2, r1, r2, lsl #1
  1407e0:	e2822030 	add	r2, r2, #48	; 0x30
  1407e4:	e2531000 	subs	r1, r3, #0
  1407e8:	e56c2001 	strb	r2, [ip, #-1]!
  1407ec:	1afffff6 	bne	1407cc <printf_core+0x1cdc>
  1407f0:	ea000000 	b	1407f8 <printf_core+0x1d08>
  1407f4:	e56ca001 	strb	sl, [ip, #-1]!
  1407f8:	e15c0007 	cmp	ip, r7
  1407fc:	8afffffc 	bhi	1407f4 <printf_core+0x1d04>
  140800:	e59b3000 	ldr	r3, [fp]
  140804:	e3130020 	tst	r3, #32
  140808:	1a000005 	bne	140824 <printf_core+0x1d34>
  14080c:	e3550009 	cmp	r5, #9
  140810:	e1a0000c 	mov	r0, ip
  140814:	b1a01005 	movlt	r1, r5
  140818:	a3a01009 	movge	r1, #9
  14081c:	e1a0200b 	mov	r2, fp
  140820:	eb000d77 	bl	143e04 <__fwritex>
  140824:	e59d301c 	ldr	r3, [sp, #28]
  140828:	e2455009 	sub	r5, r5, #9
  14082c:	e1530006 	cmp	r3, r6
  140830:	93a03000 	movls	r3, #0
  140834:	83a03001 	movhi	r3, #1
  140838:	e3550000 	cmp	r5, #0
  14083c:	d3a03000 	movle	r3, #0
  140840:	e3530000 	cmp	r3, #0
  140844:	1affffdb 	bne	1407b8 <printf_core+0x1cc8>
  140848:	e2852009 	add	r2, r5, #9
  14084c:	e3520009 	cmp	r2, #9
  140850:	dafffe54 	ble	1401a8 <printf_core+0x16b8>
  140854:	e3a03009 	mov	r3, #9
  140858:	e3a01030 	mov	r1, #48	; 0x30
  14085c:	e59d0004 	ldr	r0, [sp, #4]
  140860:	ebfff877 	bl	13ea44 <pad.part.0>
  140864:	eafffe4f 	b	1401a8 <printf_core+0x16b8>
  140868:	e3180008 	tst	r8, #8
  14086c:	0afffe4d 	beq	1401a8 <printf_core+0x16b8>
  140870:	e59d3004 	ldr	r3, [sp, #4]
  140874:	e5933000 	ldr	r3, [r3]
  140878:	e3130020 	tst	r3, #32
  14087c:	1afffe49 	bne	1401a8 <printf_core+0x16b8>
  140880:	e59d2004 	ldr	r2, [sp, #4]
  140884:	e3a01001 	mov	r1, #1
  140888:	e51f0d08 	ldr	r0, [pc, #-3336]	; 13fb88 <printf_core+0x1098>
  14088c:	eb000d5c 	bl	143e04 <__fwritex>
  140890:	eaffffbc 	b	140788 <printf_core+0x1c98>
  140894:	e15a0004 	cmp	sl, r4
  140898:	12870009 	addne	r0, r7, #9
  14089c:	1affffa0 	bne	140724 <printf_core+0x1c34>
  1408a0:	e28d0fb2 	add	r0, sp, #712	; 0x2c8
  1408a4:	e5606230 	strb	r6, [r0, #-560]!	; 0xfffffdd0
  1408a8:	eaffffa0 	b	140730 <printf_core+0x1c40>
  1408ac:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
  1408b0:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
  1408b4:	e59d2004 	ldr	r2, [sp, #4]
  1408b8:	eb000d51 	bl	143e04 <__fwritex>
  1408bc:	e2283801 	eor	r3, r8, #65536	; 0x10000
  1408c0:	e3130a12 	tst	r3, #73728	; 0x12000
  1408c4:	01a0300b 	moveq	r3, fp
  1408c8:	13a03001 	movne	r3, #1
  1408cc:	e3530000 	cmp	r3, #0
  1408d0:	0a0000af 	beq	140b94 <printf_core+0x20a4>
  1408d4:	e59d2004 	ldr	r2, [sp, #4]
  1408d8:	e5923000 	ldr	r3, [r2]
  1408dc:	e3130020 	tst	r3, #32
  1408e0:	1affff12 	bne	140530 <printf_core+0x1a40>
  1408e4:	e59d101c 	ldr	r1, [sp, #28]
  1408e8:	e1a00007 	mov	r0, r7
  1408ec:	eb000d44 	bl	143e04 <__fwritex>
  1408f0:	e35a0000 	cmp	sl, #0
  1408f4:	ca00003c 	bgt	1409ec <printf_core+0x1efc>
  1408f8:	e59d2004 	ldr	r2, [sp, #4]
  1408fc:	e5923000 	ldr	r3, [r2]
  140900:	e3130020 	tst	r3, #32
  140904:	1affff0b 	bne	140538 <printf_core+0x1a48>
  140908:	e1a01006 	mov	r1, r6
  14090c:	e59d0010 	ldr	r0, [sp, #16]
  140910:	eb000d3b 	bl	143e04 <__fwritex>
  140914:	eaffff07 	b	140538 <printf_core+0x1a48>
  140918:	e59d3010 	ldr	r3, [sp, #16]
  14091c:	e1a02009 	mov	r2, r9
  140920:	e3a01030 	mov	r1, #48	; 0x30
  140924:	e59d0004 	ldr	r0, [sp, #4]
  140928:	ebfff845 	bl	13ea44 <pad.part.0>
  14092c:	eafffdc7 	b	140050 <printf_core+0x1560>
  140930:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
  140934:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
  140938:	e59d2004 	ldr	r2, [sp, #4]
  14093c:	eb000d30 	bl	143e04 <__fwritex>
  140940:	eafffdbc 	b	140038 <printf_core+0x1548>
  140944:	e59d3010 	ldr	r3, [sp, #16]
  140948:	e1a02009 	mov	r2, r9
  14094c:	e3a01020 	mov	r1, #32
  140950:	e59d0004 	ldr	r0, [sp, #4]
  140954:	ebfff83a 	bl	13ea44 <pad.part.0>
  140958:	eafffdb2 	b	140028 <printf_core+0x1538>
  14095c:	e156000e 	cmp	r6, lr
  140960:	cafffa0f 	bgt	13f1a4 <printf_core+0x6b4>
  140964:	e3560000 	cmp	r6, #0
  140968:	c0833006 	addgt	r3, r3, r6
  14096c:	eafffd9e 	b	13ffec <printf_core+0x14fc>
  140970:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
  140974:	e59d0044 	ldr	r0, [sp, #68]	; 0x44
  140978:	e51f3df4 	ldr	r3, [pc, #-3572]	; 13fb8c <printf_core+0x109c>
  14097c:	e0811000 	add	r1, r1, r0
  140980:	e1510003 	cmp	r1, r3
  140984:	e5871000 	str	r1, [r7]
  140988:	9a000008 	bls	1409b0 <printf_core+0x1ec0>
  14098c:	e4072004 	str	r2, [r7], #-4
  140990:	e157000b 	cmp	r7, fp
  140994:	350b2004 	strcc	r2, [fp, #-4]
  140998:	e5971000 	ldr	r1, [r7]
  14099c:	324bb004 	subcc	fp, fp, #4
  1409a0:	e2811001 	add	r1, r1, #1
  1409a4:	e1510003 	cmp	r1, r3
  1409a8:	e5871000 	str	r1, [r7]
  1409ac:	8afffff6 	bhi	14098c <printf_core+0x1e9c>
  1409b0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  1409b4:	e59b2000 	ldr	r2, [fp]
  1409b8:	e043600b 	sub	r6, r3, fp
  1409bc:	e1a06146 	asr	r6, r6, #2
  1409c0:	e3520009 	cmp	r2, #9
  1409c4:	e0866186 	add	r6, r6, r6, lsl #3
  1409c8:	83a0300a 	movhi	r3, #10
  1409cc:	9a000004 	bls	1409e4 <printf_core+0x1ef4>
  1409d0:	e0833103 	add	r3, r3, r3, lsl #2
  1409d4:	e1a03083 	lsl	r3, r3, #1
  1409d8:	e1520003 	cmp	r2, r3
  1409dc:	e2866001 	add	r6, r6, #1
  1409e0:	2afffffa 	bcs	1409d0 <printf_core+0x1ee0>
  1409e4:	e287c004 	add	ip, r7, #4
  1409e8:	eafffd37 	b	13fecc <printf_core+0x13dc>
  1409ec:	e1a0200a 	mov	r2, sl
  1409f0:	e3a03000 	mov	r3, #0
  1409f4:	e3a01030 	mov	r1, #48	; 0x30
  1409f8:	e59d0004 	ldr	r0, [sp, #4]
  1409fc:	ebfff810 	bl	13ea44 <pad.part.0>
  140a00:	eaffffbc 	b	1408f8 <printf_core+0x1e08>
  140a04:	e3a03030 	mov	r3, #48	; 0x30
  140a08:	e28dc08f 	add	ip, sp, #143	; 0x8f
  140a0c:	e5cd308f 	strb	r3, [sp, #143]	; 0x8f
  140a10:	eafffe59 	b	14037c <printf_core+0x188c>
  140a14:	e265300b 	rsb	r3, r5, #11
  140a18:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  140a1c:	e1a0300b 	mov	r3, fp
  140a20:	e3a06000 	mov	r6, #0
  140a24:	e1a0b004 	mov	fp, r4
  140a28:	e1a04003 	mov	r4, r3
  140a2c:	e51f7ea4 	ldr	r7, [pc, #-3748]	; 13fb90 <printf_core+0x10a0>
  140a30:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  140a34:	e1a00006 	mov	r0, r6
  140a38:	e2433001 	sub	r3, r3, #1
  140a3c:	e1a01007 	mov	r1, r7
  140a40:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  140a44:	e3a02000 	mov	r2, #0
  140a48:	e51f3ec0 	ldr	r3, [pc, #-3776]	; 13fb90 <printf_core+0x10a0>
  140a4c:	eb0010a0 	bl	144cd4 <__aeabi_dmul>
  140a50:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
  140a54:	e1a06000 	mov	r6, r0
  140a58:	e3730001 	cmn	r3, #1
  140a5c:	e1a07001 	mov	r7, r1
  140a60:	1afffff2 	bne	140a30 <printf_core+0x1f40>
  140a64:	e1a03004 	mov	r3, r4
  140a68:	e1a0400b 	mov	r4, fp
  140a6c:	e1a0b003 	mov	fp, r3
  140a70:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
  140a74:	e59d001c 	ldr	r0, [sp, #28]
  140a78:	e5d33000 	ldrb	r3, [r3]
  140a7c:	e353002d 	cmp	r3, #45	; 0x2d
  140a80:	0a000028 	beq	140b28 <printf_core+0x2038>
  140a84:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
  140a88:	e1a02006 	mov	r2, r6
  140a8c:	e1a03007 	mov	r3, r7
  140a90:	eb000fa2 	bl	144920 <__adddf3>
  140a94:	e1a02006 	mov	r2, r6
  140a98:	e1a03007 	mov	r3, r7
  140a9c:	eb000f9e 	bl	14491c <__aeabi_dsub>
  140aa0:	e58d001c 	str	r0, [sp, #28]
  140aa4:	e58d1038 	str	r1, [sp, #56]	; 0x38
  140aa8:	eafffe20 	b	140330 <printf_core+0x1840>
  140aac:	e59d3010 	ldr	r3, [sp, #16]
  140ab0:	e1a02009 	mov	r2, r9
  140ab4:	e3a01020 	mov	r1, #32
  140ab8:	e59d0004 	ldr	r0, [sp, #4]
  140abc:	ebfff7e0 	bl	13ea44 <pad.part.0>
  140ac0:	eafffdbe 	b	1401c0 <printf_core+0x16d0>
  140ac4:	e3a0e000 	mov	lr, #0
  140ac8:	e51fcf3c 	ldr	ip, [pc, #-3900]	; 13fb94 <printf_core+0x10a4>
  140acc:	eafffce1 	b	13fe58 <printf_core+0x1368>
  140ad0:	e51f3f40 	ldr	r3, [pc, #-3904]	; 13fb98 <printf_core+0x10a8>
  140ad4:	e58d2040 	str	r2, [sp, #64]	; 0x40
  140ad8:	e58d3020 	str	r3, [sp, #32]
  140adc:	eafffcd6 	b	13fe3c <printf_core+0x134c>
  140ae0:	e3a03001 	mov	r3, #1
  140ae4:	e58d3040 	str	r3, [sp, #64]	; 0x40
  140ae8:	e51f3f58 	ldr	r3, [pc, #-3928]	; 13fb98 <printf_core+0x10a8>
  140aec:	e58d3020 	str	r3, [sp, #32]
  140af0:	eafffcd1 	b	13fe3c <printf_core+0x134c>
  140af4:	e3a03001 	mov	r3, #1
  140af8:	e3a05006 	mov	r5, #6
  140afc:	e58d3044 	str	r3, [sp, #68]	; 0x44
  140b00:	eafffb9d 	b	13f97c <printf_core+0xe8c>
  140b04:	e59d101c 	ldr	r1, [sp, #28]
  140b08:	e287c004 	add	ip, r7, #4
  140b0c:	e51f2f78 	ldr	r2, [pc, #-3960]	; 13fb9c <printf_core+0x10ac>
  140b10:	e51f3f78 	ldr	r3, [pc, #-3960]	; 13fba0 <printf_core+0x10b0>
  140b14:	e151000c 	cmp	r1, ip
  140b18:	01a0c002 	moveq	ip, r2
  140b1c:	11a0c003 	movne	ip, r3
  140b20:	e3a0e000 	mov	lr, #0
  140b24:	eafffccb 	b	13fe58 <printf_core+0x1368>
  140b28:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
  140b2c:	e1a02006 	mov	r2, r6
  140b30:	e2831102 	add	r1, r3, #-2147483648	; 0x80000000
  140b34:	e1a03007 	mov	r3, r7
  140b38:	eb000f77 	bl	14491c <__aeabi_dsub>
  140b3c:	e1a03001 	mov	r3, r1
  140b40:	e1a02000 	mov	r2, r0
  140b44:	e1a01007 	mov	r1, r7
  140b48:	e1a00006 	mov	r0, r6
  140b4c:	eb000f73 	bl	144920 <__adddf3>
  140b50:	e2813102 	add	r3, r1, #-2147483648	; 0x80000000
  140b54:	e58d001c 	str	r0, [sp, #28]
  140b58:	e58d3038 	str	r3, [sp, #56]	; 0x38
  140b5c:	eafffdf3 	b	140330 <printf_core+0x1840>
  140b60:	e3a0300a 	mov	r3, #10
  140b64:	e58d3038 	str	r3, [sp, #56]	; 0x38
  140b68:	eafffc97 	b	13fdcc <printf_core+0x12dc>
  140b6c:	e1a03005 	mov	r3, r5
  140b70:	e1a02009 	mov	r2, r9
  140b74:	e3a01020 	mov	r1, #32
  140b78:	e59d0004 	ldr	r0, [sp, #4]
  140b7c:	ebfff7b0 	bl	13ea44 <pad.part.0>
  140b80:	eafffe72 	b	140550 <printf_core+0x1a60>
  140b84:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
  140b88:	e1500003 	cmp	r0, r3
  140b8c:	1afffee7 	bne	140730 <printf_core+0x1c40>
  140b90:	eaffff42 	b	1408a0 <printf_core+0x1db0>
  140b94:	e1a03005 	mov	r3, r5
  140b98:	e1a02009 	mov	r2, r9
  140b9c:	e3a01030 	mov	r1, #48	; 0x30
  140ba0:	e59d0004 	ldr	r0, [sp, #4]
  140ba4:	ebfff7a6 	bl	13ea44 <pad.part.0>
  140ba8:	eaffff49 	b	1408d4 <printf_core+0x1de4>
  140bac:	e1a03005 	mov	r3, r5
  140bb0:	e1a02009 	mov	r2, r9
  140bb4:	e3a01020 	mov	r1, #32
  140bb8:	e59d0004 	ldr	r0, [sp, #4]
  140bbc:	ebfff7a0 	bl	13ea44 <pad.part.0>
  140bc0:	eafffe50 	b	140508 <printf_core+0x1a18>

00140bc4 <vfprintf>:
  140bc4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  140bc8:	e1a09001 	mov	r9, r1
  140bcc:	e1a06002 	mov	r6, r2
  140bd0:	e24dd0dc 	sub	sp, sp, #220	; 0xdc
  140bd4:	e28d5010 	add	r5, sp, #16
  140bd8:	e3a02028 	mov	r2, #40	; 0x28
  140bdc:	e3a01000 	mov	r1, #0
  140be0:	e1a04000 	mov	r4, r0
  140be4:	e1a00005 	mov	r0, r5
  140be8:	eb000221 	bl	141474 <memset>
  140bec:	e58d5000 	str	r5, [sp]
  140bf0:	e1a01009 	mov	r1, r9
  140bf4:	e28d3038 	add	r3, sp, #56	; 0x38
  140bf8:	e28d200c 	add	r2, sp, #12
  140bfc:	e3a00000 	mov	r0, #0
  140c00:	e58d600c 	str	r6, [sp, #12]
  140c04:	ebfff7b9 	bl	13eaf0 <printf_core>
  140c08:	e3500000 	cmp	r0, #0
  140c0c:	ba000047 	blt	140d30 <vfprintf+0x16c>
  140c10:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
  140c14:	e3530000 	cmp	r3, #0
  140c18:	b3a08000 	movlt	r8, #0
  140c1c:	ba000002 	blt	140c2c <vfprintf+0x68>
  140c20:	e1a00004 	mov	r0, r4
  140c24:	eb000ab7 	bl	143708 <__lockfile>
  140c28:	e1a08000 	mov	r8, r0
  140c2c:	e5942048 	ldr	r2, [r4, #72]	; 0x48
  140c30:	e5943000 	ldr	r3, [r4]
  140c34:	e3520000 	cmp	r2, #0
  140c38:	e2036020 	and	r6, r3, #32
  140c3c:	d3c33020 	bicle	r3, r3, #32
  140c40:	d5843000 	strle	r3, [r4]
  140c44:	e5943030 	ldr	r3, [r4, #48]	; 0x30
  140c48:	e3530000 	cmp	r3, #0
  140c4c:	0a000024 	beq	140ce4 <vfprintf+0x120>
  140c50:	e5947010 	ldr	r7, [r4, #16]
  140c54:	e3570000 	cmp	r7, #0
  140c58:	13a07000 	movne	r7, #0
  140c5c:	0a000035 	beq	140d38 <vfprintf+0x174>
  140c60:	e58d5000 	str	r5, [sp]
  140c64:	e28d3038 	add	r3, sp, #56	; 0x38
  140c68:	e28d200c 	add	r2, sp, #12
  140c6c:	e1a01009 	mov	r1, r9
  140c70:	e1a00004 	mov	r0, r4
  140c74:	ebfff79d 	bl	13eaf0 <printf_core>
  140c78:	e1a05000 	mov	r5, r0
  140c7c:	e3570000 	cmp	r7, #0
  140c80:	0a00000d 	beq	140cbc <vfprintf+0xf8>
  140c84:	e3a02000 	mov	r2, #0
  140c88:	e5943024 	ldr	r3, [r4, #36]	; 0x24
  140c8c:	e1a01002 	mov	r1, r2
  140c90:	e1a00004 	mov	r0, r4
  140c94:	e12fff33 	blx	r3
  140c98:	e3a03000 	mov	r3, #0
  140c9c:	e5942014 	ldr	r2, [r4, #20]
  140ca0:	e584702c 	str	r7, [r4, #44]	; 0x2c
  140ca4:	e1520003 	cmp	r2, r3
  140ca8:	03e05000 	mvneq	r5, #0
  140cac:	e5843030 	str	r3, [r4, #48]	; 0x30
  140cb0:	e5843010 	str	r3, [r4, #16]
  140cb4:	e584301c 	str	r3, [r4, #28]
  140cb8:	e5843014 	str	r3, [r4, #20]
  140cbc:	e5943000 	ldr	r3, [r4]
  140cc0:	e3130020 	tst	r3, #32
  140cc4:	13e05000 	mvnne	r5, #0
  140cc8:	e1866003 	orr	r6, r6, r3
  140ccc:	e3580000 	cmp	r8, #0
  140cd0:	e5846000 	str	r6, [r4]
  140cd4:	1a000010 	bne	140d1c <vfprintf+0x158>
  140cd8:	e1a00005 	mov	r0, r5
  140cdc:	e28dd0dc 	add	sp, sp, #220	; 0xdc
  140ce0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  140ce4:	e3a01050 	mov	r1, #80	; 0x50
  140ce8:	e28d2088 	add	r2, sp, #136	; 0x88
  140cec:	e594702c 	ldr	r7, [r4, #44]	; 0x2c
  140cf0:	e5843010 	str	r3, [r4, #16]
  140cf4:	e584301c 	str	r3, [r4, #28]
  140cf8:	e5843014 	str	r3, [r4, #20]
  140cfc:	e5841030 	str	r1, [r4, #48]	; 0x30
  140d00:	e584202c 	str	r2, [r4, #44]	; 0x2c
  140d04:	e1a00004 	mov	r0, r4
  140d08:	eb000b9c 	bl	143b80 <__towrite>
  140d0c:	e3500000 	cmp	r0, #0
  140d10:	13e05000 	mvnne	r5, #0
  140d14:	1affffd8 	bne	140c7c <vfprintf+0xb8>
  140d18:	eaffffd0 	b	140c60 <vfprintf+0x9c>
  140d1c:	e1a00004 	mov	r0, r4
  140d20:	eb000ac5 	bl	14383c <__unlockfile>
  140d24:	e1a00005 	mov	r0, r5
  140d28:	e28dd0dc 	add	sp, sp, #220	; 0xdc
  140d2c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  140d30:	e3e05000 	mvn	r5, #0
  140d34:	eaffffe7 	b	140cd8 <vfprintf+0x114>
  140d38:	e1a00004 	mov	r0, r4
  140d3c:	eb000b8f 	bl	143b80 <__towrite>
  140d40:	e3500000 	cmp	r0, #0
  140d44:	13e05000 	mvnne	r5, #0
  140d48:	1affffdb 	bne	140cbc <vfprintf+0xf8>
  140d4c:	eaffffc3 	b	140c60 <vfprintf+0x9c>

00140d50 <sn_write>:
  140d50:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  140d54:	e5906054 	ldr	r6, [r0, #84]	; 0x54
  140d58:	e590c01c 	ldr	ip, [r0, #28]
  140d5c:	e1a05000 	mov	r5, r0
  140d60:	e5900014 	ldr	r0, [r0, #20]
  140d64:	e5963004 	ldr	r3, [r6, #4]
  140d68:	e040000c 	sub	r0, r0, ip
  140d6c:	e1500003 	cmp	r0, r3
  140d70:	31a04000 	movcc	r4, r0
  140d74:	21a04003 	movcs	r4, r3
  140d78:	e3540000 	cmp	r4, #0
  140d7c:	e1a08001 	mov	r8, r1
  140d80:	e1a07002 	mov	r7, r2
  140d84:	e5960000 	ldr	r0, [r6]
  140d88:	1a000012 	bne	140dd8 <sn_write+0x88>
  140d8c:	e1570003 	cmp	r7, r3
  140d90:	31a04007 	movcc	r4, r7
  140d94:	21a04003 	movcs	r4, r3
  140d98:	e3540000 	cmp	r4, #0
  140d9c:	0a000006 	beq	140dbc <sn_write+0x6c>
  140da0:	e1a01008 	mov	r1, r8
  140da4:	e1a02004 	mov	r2, r4
  140da8:	eb000079 	bl	140f94 <memcpy>
  140dac:	e8960009 	ldm	r6, {r0, r3}
  140db0:	e0800004 	add	r0, r0, r4
  140db4:	e0433004 	sub	r3, r3, r4
  140db8:	e8860009 	stm	r6, {r0, r3}
  140dbc:	e3a03000 	mov	r3, #0
  140dc0:	e5c03000 	strb	r3, [r0]
  140dc4:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
  140dc8:	e1a00007 	mov	r0, r7
  140dcc:	e585301c 	str	r3, [r5, #28]
  140dd0:	e5853014 	str	r3, [r5, #20]
  140dd4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  140dd8:	e1a0100c 	mov	r1, ip
  140ddc:	e1a02004 	mov	r2, r4
  140de0:	eb00006b 	bl	140f94 <memcpy>
  140de4:	e8960009 	ldm	r6, {r0, r3}
  140de8:	e0800004 	add	r0, r0, r4
  140dec:	e0433004 	sub	r3, r3, r4
  140df0:	e8860009 	stm	r6, {r0, r3}
  140df4:	eaffffe4 	b	140d8c <sn_write+0x3c>

00140df8 <vsnprintf>:
  140df8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  140dfc:	e2516000 	subs	r6, r1, #0
  140e00:	e24dd0a4 	sub	sp, sp, #164	; 0xa4
  140e04:	e1a08002 	mov	r8, r2
  140e08:	e1a09003 	mov	r9, r3
  140e0c:	1a000018 	bne	140e74 <vsnprintf+0x7c>
  140e10:	e28d7010 	add	r7, sp, #16
  140e14:	e3a02090 	mov	r2, #144	; 0x90
  140e18:	e1a00007 	mov	r0, r7
  140e1c:	e28d4004 	add	r4, sp, #4
  140e20:	e58d600c 	str	r6, [sp, #12]
  140e24:	e58d4008 	str	r4, [sp, #8]
  140e28:	eb000191 	bl	141474 <memset>
  140e2c:	e3e02000 	mvn	r2, #0
  140e30:	e59f1098 	ldr	r1, [pc, #152]	; 140ed0 <vsnprintf+0xd8>
  140e34:	e28d3008 	add	r3, sp, #8
  140e38:	e58d205c 	str	r2, [sp, #92]	; 0x5c
  140e3c:	e58d2060 	str	r2, [sp, #96]	; 0x60
  140e40:	e58d1034 	str	r1, [sp, #52]	; 0x34
  140e44:	e58dd03c 	str	sp, [sp, #60]	; 0x3c
  140e48:	e58d3064 	str	r3, [sp, #100]	; 0x64
  140e4c:	e3a0c000 	mov	ip, #0
  140e50:	e1a02009 	mov	r2, r9
  140e54:	e1a01008 	mov	r1, r8
  140e58:	e1a00007 	mov	r0, r7
  140e5c:	e5c4c000 	strb	ip, [r4]
  140e60:	ebffff57 	bl	140bc4 <vfprintf>
  140e64:	e1a05000 	mov	r5, r0
  140e68:	e1a00005 	mov	r0, r5
  140e6c:	e28dd0a4 	add	sp, sp, #164	; 0xa4
  140e70:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  140e74:	e3e05000 	mvn	r5, #0
  140e78:	e1a04000 	mov	r4, r0
  140e7c:	e28d7010 	add	r7, sp, #16
  140e80:	e0863005 	add	r3, r6, r5
  140e84:	e3a02090 	mov	r2, #144	; 0x90
  140e88:	e1a00007 	mov	r0, r7
  140e8c:	e3a01000 	mov	r1, #0
  140e90:	e58d300c 	str	r3, [sp, #12]
  140e94:	e58d4008 	str	r4, [sp, #8]
  140e98:	eb000175 	bl	141474 <memset>
  140e9c:	e59f202c 	ldr	r2, [pc, #44]	; 140ed0 <vsnprintf+0xd8>
  140ea0:	e28d3008 	add	r3, sp, #8
  140ea4:	e3560000 	cmp	r6, #0
  140ea8:	e58d505c 	str	r5, [sp, #92]	; 0x5c
  140eac:	e58d5060 	str	r5, [sp, #96]	; 0x60
  140eb0:	e58d2034 	str	r2, [sp, #52]	; 0x34
  140eb4:	e58dd03c 	str	sp, [sp, #60]	; 0x3c
  140eb8:	e58d3064 	str	r3, [sp, #100]	; 0x64
  140ebc:	aaffffe2 	bge	140e4c <vsnprintf+0x54>
  140ec0:	ebffe084 	bl	1390d8 <__errno_location>
  140ec4:	e3a0204b 	mov	r2, #75	; 0x4b
  140ec8:	e5802000 	str	r2, [r0]
  140ecc:	eaffffe5 	b	140e68 <vsnprintf+0x70>
  140ed0:	00140d50 	.word	0x00140d50

00140ed4 <vsprintf>:
  140ed4:	e1a03002 	mov	r3, r2
  140ed8:	e1a02001 	mov	r2, r1
  140edc:	e3e01102 	mvn	r1, #-2147483648	; 0x80000000
  140ee0:	eaffffc4 	b	140df8 <vsnprintf>

00140ee4 <atoi>:
  140ee4:	e5d03000 	ldrb	r3, [r0]
  140ee8:	e2432009 	sub	r2, r3, #9
  140eec:	e3530020 	cmp	r3, #32
  140ef0:	13520004 	cmpne	r2, #4
  140ef4:	8a000004 	bhi	140f0c <atoi+0x28>
  140ef8:	e5f03001 	ldrb	r3, [r0, #1]!
  140efc:	e2432009 	sub	r2, r3, #9
  140f00:	e3530020 	cmp	r3, #32
  140f04:	13520004 	cmpne	r2, #4
  140f08:	9afffffa 	bls	140ef8 <atoi+0x14>
  140f0c:	e353002b 	cmp	r3, #43	; 0x2b
  140f10:	0a000019 	beq	140f7c <atoi+0x98>
  140f14:	e353002d 	cmp	r3, #45	; 0x2d
  140f18:	0a00000f 	beq	140f5c <atoi+0x78>
  140f1c:	e5d01000 	ldrb	r1, [r0]
  140f20:	e2412030 	sub	r2, r1, #48	; 0x30
  140f24:	e3520009 	cmp	r2, #9
  140f28:	91a03000 	movls	r3, r0
  140f2c:	8a000010 	bhi	140f74 <atoi+0x90>
  140f30:	e3a0c000 	mov	ip, #0
  140f34:	e3a00000 	mov	r0, #0
  140f38:	e5f31001 	ldrb	r1, [r3, #1]!
  140f3c:	e0800100 	add	r0, r0, r0, lsl #2
  140f40:	e0620080 	rsb	r0, r2, r0, lsl #1
  140f44:	e2412030 	sub	r2, r1, #48	; 0x30
  140f48:	e3520009 	cmp	r2, #9
  140f4c:	9afffff9 	bls	140f38 <atoi+0x54>
  140f50:	e35c0000 	cmp	ip, #0
  140f54:	02600000 	rsbeq	r0, r0, #0
  140f58:	e12fff1e 	bx	lr
  140f5c:	e5d01001 	ldrb	r1, [r0, #1]
  140f60:	e2803001 	add	r3, r0, #1
  140f64:	e2412030 	sub	r2, r1, #48	; 0x30
  140f68:	e3520009 	cmp	r2, #9
  140f6c:	93a0c001 	movls	ip, #1
  140f70:	9affffef 	bls	140f34 <atoi+0x50>
  140f74:	e3a00000 	mov	r0, #0
  140f78:	e12fff1e 	bx	lr
  140f7c:	e5d01001 	ldrb	r1, [r0, #1]
  140f80:	e2803001 	add	r3, r0, #1
  140f84:	e2412030 	sub	r2, r1, #48	; 0x30
  140f88:	e3520009 	cmp	r2, #9
  140f8c:	9affffe7 	bls	140f30 <atoi+0x4c>
  140f90:	eafffff7 	b	140f74 <atoi+0x90>

00140f94 <memcpy>:
  140f94:	e92d4011 	push	{r0, r4, lr}
  140f98:	e24dd01c 	sub	sp, sp, #28
  140f9c:	e3520004 	cmp	r2, #4
  140fa0:	3a0000b0 	bcc	141268 <copy_last_3_and_return>
  140fa4:	e2613000 	rsb	r3, r1, #0
  140fa8:	e2133003 	ands	r3, r3, #3
  140fac:	0a000007 	beq	140fd0 <src_aligned>
  140fb0:	e1b0cf83 	lsls	ip, r3, #31
  140fb4:	e0422003 	sub	r2, r2, r3
  140fb8:	44d13001 	ldrbmi	r3, [r1], #1
  140fbc:	24d14001 	ldrbcs	r4, [r1], #1
  140fc0:	24d1c001 	ldrbcs	ip, [r1], #1
  140fc4:	44c03001 	strbmi	r3, [r0], #1
  140fc8:	24c04001 	strbcs	r4, [r0], #1
  140fcc:	24c0c001 	strbcs	ip, [r0], #1

00140fd0 <src_aligned>:
  140fd0:	e020c001 	eor	ip, r0, r1
  140fd4:	e31c0003 	tst	ip, #3
  140fd8:	1a000027 	bne	14107c <non_congruent>
  140fdc:	e88d0fe0 	stm	sp, {r5, r6, r7, r8, r9, sl, fp}
  140fe0:	e2603000 	rsb	r3, r0, #0
  140fe4:	e213301c 	ands	r3, r3, #28
  140fe8:	0a00000a 	beq	141018 <cached_aligned32>
  140fec:	e1530002 	cmp	r3, r2
  140ff0:	8202301c 	andhi	r3, r2, #28
  140ff4:	e1b0ce03 	lsls	ip, r3, #28
  140ff8:	28b100f0 	ldmcs	r1!, {r4, r5, r6, r7}
  140ffc:	48b10300 	ldmmi	r1!, {r8, r9}
  141000:	28a000f0 	stmiacs	r0!, {r4, r5, r6, r7}
  141004:	48a00300 	stmiami	r0!, {r8, r9}
  141008:	e3130004 	tst	r3, #4
  14100c:	1491a004 	ldrne	sl, [r1], #4
  141010:	1480a004 	strne	sl, [r0], #4
  141014:	e0422003 	sub	r2, r2, r3

00141018 <cached_aligned32>:
  141018:	e2522020 	subs	r2, r2, #32
  14101c:	3a000004 	bcc	141034 <less_than_32_left>
  141020:	e8b10ff0 	ldm	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}
  141024:	e2522020 	subs	r2, r2, #32
  141028:	e8a00ff0 	stmia	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  14102c:	2afffffb 	bcs	141020 <cached_aligned32+0x8>
  141030:	e2822020 	add	r2, r2, #32

00141034 <less_than_32_left>:
  141034:	e312001f 	tst	r2, #31
  141038:	0a00000c 	beq	141070 <less_than_32_left+0x3c>
  14103c:	e1b0ce02 	lsls	ip, r2, #28
  141040:	28b100f0 	ldmcs	r1!, {r4, r5, r6, r7}
  141044:	48b10300 	ldmmi	r1!, {r8, r9}
  141048:	28a000f0 	stmiacs	r0!, {r4, r5, r6, r7}
  14104c:	48a00300 	stmiami	r0!, {r8, r9}
  141050:	e1b0cf02 	lsls	ip, r2, #30
  141054:	24913004 	ldrcs	r3, [r1], #4
  141058:	40d140b2 	ldrhmi	r4, [r1], #2
  14105c:	24803004 	strcs	r3, [r0], #4
  141060:	40c040b2 	strhmi	r4, [r0], #2
  141064:	e3120001 	tst	r2, #1
  141068:	15d13000 	ldrbne	r3, [r1]
  14106c:	15c03000 	strbne	r3, [r0]
  141070:	e8bd0fe0 	pop	{r5, r6, r7, r8, r9, sl, fp}
  141074:	e8bd4011 	pop	{r0, r4, lr}
  141078:	e12fff1e 	bx	lr

0014107c <non_congruent>:
  14107c:	e3520004 	cmp	r2, #4
  141080:	3a000078 	bcc	141268 <copy_last_3_and_return>
  141084:	e88d0fe0 	stm	sp, {r5, r6, r7, r8, r9, sl, fp}
  141088:	e2605000 	rsb	r5, r0, #0
  14108c:	e2055003 	and	r5, r5, #3
  141090:	e1a0c185 	lsl	ip, r5, #3
  141094:	e26ce020 	rsb	lr, ip, #32
  141098:	e4913004 	ldr	r3, [r1], #4
  14109c:	e2422004 	sub	r2, r2, #4
  1410a0:	e1b05f85 	lsls	r5, r5, #31
  1410a4:	44c03001 	strbmi	r3, [r0], #1
  1410a8:	41a03423 	lsrmi	r3, r3, #8
  1410ac:	24c03001 	strbcs	r3, [r0], #1
  1410b0:	21a03423 	lsrcs	r3, r3, #8
  1410b4:	24c03001 	strbcs	r3, [r0], #1
  1410b8:	21a03423 	lsrcs	r3, r3, #8
  1410bc:	e3520004 	cmp	r2, #4
  1410c0:	3a000061 	bcc	14124c <partial_word_tail>
  1410c4:	e310001c 	tst	r0, #28
  1410c8:	0a000007 	beq	1410ec <non_congruent+0x70>
  1410cc:	e4915004 	ldr	r5, [r1], #4
  1410d0:	e2422004 	sub	r2, r2, #4
  1410d4:	e1834e15 	orr	r4, r3, r5, lsl lr
  1410d8:	e1a03c35 	lsr	r3, r5, ip
  1410dc:	e4804004 	str	r4, [r0], #4
  1410e0:	e3520004 	cmp	r2, #4
  1410e4:	2afffff6 	bcs	1410c4 <non_congruent+0x48>
  1410e8:	3a000057 	bcc	14124c <partial_word_tail>
  1410ec:	e2522020 	subs	r2, r2, #32
  1410f0:	3a00004a 	bcc	141220 <less_than_thirtytwo>
  1410f4:	e35c0018 	cmp	ip, #24
  1410f8:	0a000031 	beq	1411c4 <loop24>
  1410fc:	e35c0008 	cmp	ip, #8
  141100:	0a000017 	beq	141164 <loop8>

00141104 <loop16>:
  141104:	e491c004 	ldr	ip, [r1], #4
  141108:	e1a0400c 	mov	r4, ip
  14110c:	e8b10fe0 	ldm	r1!, {r5, r6, r7, r8, r9, sl, fp}
  141110:	e2522020 	subs	r2, r2, #32
  141114:	2491c004 	ldrcs	ip, [r1], #4
  141118:	e1833804 	orr	r3, r3, r4, lsl #16
  14111c:	e1a04824 	lsr	r4, r4, #16
  141120:	e1844805 	orr	r4, r4, r5, lsl #16
  141124:	e1a05825 	lsr	r5, r5, #16
  141128:	e1855806 	orr	r5, r5, r6, lsl #16
  14112c:	e1a06826 	lsr	r6, r6, #16
  141130:	e1866807 	orr	r6, r6, r7, lsl #16
  141134:	e1a07827 	lsr	r7, r7, #16
  141138:	e1877808 	orr	r7, r7, r8, lsl #16
  14113c:	e1a08828 	lsr	r8, r8, #16
  141140:	e1888809 	orr	r8, r8, r9, lsl #16
  141144:	e1a09829 	lsr	r9, r9, #16
  141148:	e189980a 	orr	r9, r9, sl, lsl #16
  14114c:	e1a0a82a 	lsr	sl, sl, #16
  141150:	e18aa80b 	orr	sl, sl, fp, lsl #16
  141154:	e8a007f8 	stmia	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
  141158:	e1a0382b 	lsr	r3, fp, #16
  14115c:	2affffe9 	bcs	141108 <loop16+0x4>
  141160:	ea00002e 	b	141220 <less_than_thirtytwo>

00141164 <loop8>:
  141164:	e491c004 	ldr	ip, [r1], #4
  141168:	e1a0400c 	mov	r4, ip
  14116c:	e8b10fe0 	ldm	r1!, {r5, r6, r7, r8, r9, sl, fp}
  141170:	e2522020 	subs	r2, r2, #32
  141174:	2491c004 	ldrcs	ip, [r1], #4
  141178:	e1833c04 	orr	r3, r3, r4, lsl #24
  14117c:	e1a04424 	lsr	r4, r4, #8
  141180:	e1844c05 	orr	r4, r4, r5, lsl #24
  141184:	e1a05425 	lsr	r5, r5, #8
  141188:	e1855c06 	orr	r5, r5, r6, lsl #24
  14118c:	e1a06426 	lsr	r6, r6, #8
  141190:	e1866c07 	orr	r6, r6, r7, lsl #24
  141194:	e1a07427 	lsr	r7, r7, #8
  141198:	e1877c08 	orr	r7, r7, r8, lsl #24
  14119c:	e1a08428 	lsr	r8, r8, #8
  1411a0:	e1888c09 	orr	r8, r8, r9, lsl #24
  1411a4:	e1a09429 	lsr	r9, r9, #8
  1411a8:	e1899c0a 	orr	r9, r9, sl, lsl #24
  1411ac:	e1a0a42a 	lsr	sl, sl, #8
  1411b0:	e18aac0b 	orr	sl, sl, fp, lsl #24
  1411b4:	e8a007f8 	stmia	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
  1411b8:	e1a0342b 	lsr	r3, fp, #8
  1411bc:	2affffe9 	bcs	141168 <loop8+0x4>
  1411c0:	ea000016 	b	141220 <less_than_thirtytwo>

001411c4 <loop24>:
  1411c4:	e491c004 	ldr	ip, [r1], #4
  1411c8:	e1a0400c 	mov	r4, ip
  1411cc:	e8b10fe0 	ldm	r1!, {r5, r6, r7, r8, r9, sl, fp}
  1411d0:	e2522020 	subs	r2, r2, #32
  1411d4:	2491c004 	ldrcs	ip, [r1], #4
  1411d8:	e1833404 	orr	r3, r3, r4, lsl #8
  1411dc:	e1a04c24 	lsr	r4, r4, #24
  1411e0:	e1844405 	orr	r4, r4, r5, lsl #8
  1411e4:	e1a05c25 	lsr	r5, r5, #24
  1411e8:	e1855406 	orr	r5, r5, r6, lsl #8
  1411ec:	e1a06c26 	lsr	r6, r6, #24
  1411f0:	e1866407 	orr	r6, r6, r7, lsl #8
  1411f4:	e1a07c27 	lsr	r7, r7, #24
  1411f8:	e1877408 	orr	r7, r7, r8, lsl #8
  1411fc:	e1a08c28 	lsr	r8, r8, #24
  141200:	e1888409 	orr	r8, r8, r9, lsl #8
  141204:	e1a09c29 	lsr	r9, r9, #24
  141208:	e189940a 	orr	r9, r9, sl, lsl #8
  14120c:	e1a0ac2a 	lsr	sl, sl, #24
  141210:	e18aa40b 	orr	sl, sl, fp, lsl #8
  141214:	e8a007f8 	stmia	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
  141218:	e1a03c2b 	lsr	r3, fp, #24
  14121c:	2affffe9 	bcs	1411c8 <loop24+0x4>

00141220 <less_than_thirtytwo>:
  141220:	e26ec020 	rsb	ip, lr, #32
  141224:	e2822020 	add	r2, r2, #32
  141228:	e3520004 	cmp	r2, #4
  14122c:	3a000006 	bcc	14124c <partial_word_tail>
  141230:	e4915004 	ldr	r5, [r1], #4
  141234:	e2422004 	sub	r2, r2, #4
  141238:	e1834e15 	orr	r4, r3, r5, lsl lr
  14123c:	e1a03c35 	lsr	r3, r5, ip
  141240:	e4804004 	str	r4, [r0], #4
  141244:	e3520004 	cmp	r2, #4
  141248:	2afffff8 	bcs	141230 <less_than_thirtytwo+0x10>

0014124c <partial_word_tail>:
  14124c:	e1b05e0e 	lsls	r5, lr, #28
  141250:	44c03001 	strbmi	r3, [r0], #1
  141254:	41a03423 	lsrmi	r3, r3, #8
  141258:	24c03001 	strbcs	r3, [r0], #1
  14125c:	21a03423 	lsrcs	r3, r3, #8
  141260:	24c03001 	strbcs	r3, [r0], #1
  141264:	e89d0fe0 	ldm	sp, {r5, r6, r7, r8, r9, sl, fp}

00141268 <copy_last_3_and_return>:
  141268:	e1b02f82 	lsls	r2, r2, #31
  14126c:	44d12001 	ldrbmi	r2, [r1], #1
  141270:	24d13001 	ldrbcs	r3, [r1], #1
  141274:	25d1c000 	ldrbcs	ip, [r1]
  141278:	44c02001 	strbmi	r2, [r0], #1
  14127c:	24c03001 	strbcs	r3, [r0], #1
  141280:	25c0c000 	strbcs	ip, [r0]
  141284:	e28dd01c 	add	sp, sp, #28
  141288:	e8bd4011 	pop	{r0, r4, lr}
  14128c:	e12fff1e 	bx	lr

00141290 <memcmp>:
  141290:	e3520000 	cmp	r2, #0
  141294:	0a00000c 	beq	1412cc <memcmp+0x3c>
  141298:	e5d0c000 	ldrb	ip, [r0]
  14129c:	e5d13000 	ldrb	r3, [r1]
  1412a0:	e153000c 	cmp	r3, ip
  1412a4:	1a00000a 	bne	1412d4 <memcmp+0x44>
  1412a8:	e2422001 	sub	r2, r2, #1
  1412ac:	e0812002 	add	r2, r1, r2
  1412b0:	ea000003 	b	1412c4 <memcmp+0x34>
  1412b4:	e5f0c001 	ldrb	ip, [r0, #1]!
  1412b8:	e5f13001 	ldrb	r3, [r1, #1]!
  1412bc:	e15c0003 	cmp	ip, r3
  1412c0:	1a000003 	bne	1412d4 <memcmp+0x44>
  1412c4:	e1510002 	cmp	r1, r2
  1412c8:	1afffff9 	bne	1412b4 <memcmp+0x24>
  1412cc:	e3a00000 	mov	r0, #0
  1412d0:	e12fff1e 	bx	lr
  1412d4:	e04c0003 	sub	r0, ip, r3
  1412d8:	e12fff1e 	bx	lr

001412dc <memmove>:
  1412dc:	e1500001 	cmp	r0, r1
  1412e0:	e92d4030 	push	{r4, r5, lr}
  1412e4:	e1a0e000 	mov	lr, r0
  1412e8:	0a000030 	beq	1413b0 <memmove+0xd4>
  1412ec:	e0414000 	sub	r4, r1, r0
  1412f0:	e0444002 	sub	r4, r4, r2
  1412f4:	e0625f82 	rsb	r5, r2, r2, lsl #31
  1412f8:	e1540085 	cmp	r4, r5, lsl #1
  1412fc:	e1a0c001 	mov	ip, r1
  141300:	e1a03002 	mov	r3, r2
  141304:	9a000054 	bls	14145c <memmove+0x180>
  141308:	e0212000 	eor	r2, r1, r0
  14130c:	e1500001 	cmp	r0, r1
  141310:	e2022003 	and	r2, r2, #3
  141314:	2a000027 	bcs	1413b8 <memmove+0xdc>
  141318:	e3520000 	cmp	r2, #0
  14131c:	1a00001a 	bne	14138c <memmove+0xb0>
  141320:	e3100003 	tst	r0, #3
  141324:	0a000050 	beq	14146c <memmove+0x190>
  141328:	e3530000 	cmp	r3, #0
  14132c:	11a02000 	movne	r2, r0
  141330:	e2433001 	sub	r3, r3, #1
  141334:	1a000002 	bne	141344 <memmove+0x68>
  141338:	ea00001c 	b	1413b0 <memmove+0xd4>
  14133c:	e2533001 	subs	r3, r3, #1
  141340:	3a00001a 	bcc	1413b0 <memmove+0xd4>
  141344:	e4dc1001 	ldrb	r1, [ip], #1
  141348:	e4c21001 	strb	r1, [r2], #1
  14134c:	e3120003 	tst	r2, #3
  141350:	1afffff9 	bne	14133c <memmove+0x60>
  141354:	e3530003 	cmp	r3, #3
  141358:	9a00000c 	bls	141390 <memmove+0xb4>
  14135c:	e2435004 	sub	r5, r3, #4
  141360:	e3c55003 	bic	r5, r5, #3
  141364:	e2855004 	add	r5, r5, #4
  141368:	e0824005 	add	r4, r2, r5
  14136c:	e24c1004 	sub	r1, ip, #4
  141370:	e5b10004 	ldr	r0, [r1, #4]!
  141374:	e4820004 	str	r0, [r2], #4
  141378:	e1540002 	cmp	r4, r2
  14137c:	1afffffb 	bne	141370 <memmove+0x94>
  141380:	e2033003 	and	r3, r3, #3
  141384:	e08cc005 	add	ip, ip, r5
  141388:	ea000000 	b	141390 <memmove+0xb4>
  14138c:	e1a02000 	mov	r2, r0
  141390:	e3530000 	cmp	r3, #0
  141394:	12422001 	subne	r2, r2, #1
  141398:	108c3003 	addne	r3, ip, r3
  14139c:	0a000003 	beq	1413b0 <memmove+0xd4>
  1413a0:	e4dc1001 	ldrb	r1, [ip], #1
  1413a4:	e153000c 	cmp	r3, ip
  1413a8:	e5e21001 	strb	r1, [r2, #1]!
  1413ac:	1afffffb 	bne	1413a0 <memmove+0xc4>
  1413b0:	e1a0000e 	mov	r0, lr
  1413b4:	e8bd8030 	pop	{r4, r5, pc}
  1413b8:	e3520000 	cmp	r2, #0
  1413bc:	1a00001c 	bne	141434 <memmove+0x158>
  1413c0:	e0801003 	add	r1, r0, r3
  1413c4:	e3110003 	tst	r1, #3
  1413c8:	0a000025 	beq	141464 <memmove+0x188>
  1413cc:	e3530000 	cmp	r3, #0
  1413d0:	e2432001 	sub	r2, r3, #1
  1413d4:	0afffff5 	beq	1413b0 <memmove+0xd4>
  1413d8:	e08c3003 	add	r3, ip, r3
  1413dc:	ea000001 	b	1413e8 <memmove+0x10c>
  1413e0:	e2522001 	subs	r2, r2, #1
  1413e4:	3afffff1 	bcc	1413b0 <memmove+0xd4>
  1413e8:	e5730001 	ldrb	r0, [r3, #-1]!
  1413ec:	e5610001 	strb	r0, [r1, #-1]!
  1413f0:	e3110003 	tst	r1, #3
  1413f4:	1afffff9 	bne	1413e0 <memmove+0x104>
  1413f8:	e3520003 	cmp	r2, #3
  1413fc:	91a03002 	movls	r3, r2
  141400:	9a00000b 	bls	141434 <memmove+0x158>
  141404:	e24c0004 	sub	r0, ip, #4
  141408:	e2423004 	sub	r3, r2, #4
  14140c:	e3c33003 	bic	r3, r3, #3
  141410:	e0800002 	add	r0, r0, r2
  141414:	e0400003 	sub	r0, r0, r3
  141418:	e08e1002 	add	r1, lr, r2
  14141c:	e08c3002 	add	r3, ip, r2
  141420:	e5334004 	ldr	r4, [r3, #-4]!
  141424:	e1530000 	cmp	r3, r0
  141428:	e5214004 	str	r4, [r1, #-4]!
  14142c:	1afffffb 	bne	141420 <memmove+0x144>
  141430:	e2023003 	and	r3, r2, #3
  141434:	e3530000 	cmp	r3, #0
  141438:	108c2003 	addne	r2, ip, r3
  14143c:	108e3003 	addne	r3, lr, r3
  141440:	0affffda 	beq	1413b0 <memmove+0xd4>
  141444:	e5721001 	ldrb	r1, [r2, #-1]!
  141448:	e15c0002 	cmp	ip, r2
  14144c:	e5631001 	strb	r1, [r3, #-1]!
  141450:	1afffffb 	bne	141444 <memmove+0x168>
  141454:	e1a0000e 	mov	r0, lr
  141458:	e8bd8030 	pop	{r4, r5, pc}
  14145c:	e8bd4030 	pop	{r4, r5, lr}
  141460:	eafffecb 	b	140f94 <memcpy>
  141464:	e1a02003 	mov	r2, r3
  141468:	eaffffe2 	b	1413f8 <memmove+0x11c>
  14146c:	e1a02000 	mov	r2, r0
  141470:	eaffffb7 	b	141354 <memmove+0x78>

00141474 <memset>:
  141474:	e3520000 	cmp	r2, #0
  141478:	012fff1e 	bxeq	lr
  14147c:	e1a03000 	mov	r3, r0
  141480:	e20110ff 	and	r1, r1, #255	; 0xff
  141484:	e6c31002 	strb	r1, [r3], r2
  141488:	e3520002 	cmp	r2, #2
  14148c:	e5431001 	strb	r1, [r3, #-1]
  141490:	912fff1e 	bxls	lr
  141494:	e3520006 	cmp	r2, #6
  141498:	e5c01001 	strb	r1, [r0, #1]
  14149c:	e5c01002 	strb	r1, [r0, #2]
  1414a0:	e5431002 	strb	r1, [r3, #-2]
  1414a4:	e5431003 	strb	r1, [r3, #-3]
  1414a8:	912fff1e 	bxls	lr
  1414ac:	e3520008 	cmp	r2, #8
  1414b0:	e5c01003 	strb	r1, [r0, #3]
  1414b4:	e5431004 	strb	r1, [r3, #-4]
  1414b8:	912fff1e 	bxls	lr
  1414bc:	e260c000 	rsb	ip, r0, #0
  1414c0:	e20cc003 	and	ip, ip, #3
  1414c4:	e042200c 	sub	r2, r2, ip
  1414c8:	e3c22003 	bic	r2, r2, #3
  1414cc:	e0811401 	add	r1, r1, r1, lsl #8
  1414d0:	e080300c 	add	r3, r0, ip
  1414d4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  1414d8:	e0811801 	add	r1, r1, r1, lsl #16
  1414dc:	e3520008 	cmp	r2, #8
  1414e0:	e083e002 	add	lr, r3, r2
  1414e4:	e780100c 	str	r1, [r0, ip]
  1414e8:	e50e1004 	str	r1, [lr, #-4]
  1414ec:	98bd80f0 	popls	{r4, r5, r6, r7, pc}
  1414f0:	e3520018 	cmp	r2, #24
  1414f4:	e5831004 	str	r1, [r3, #4]
  1414f8:	e5831008 	str	r1, [r3, #8]
  1414fc:	e50e100c 	str	r1, [lr, #-12]
  141500:	e50e1008 	str	r1, [lr, #-8]
  141504:	98bd80f0 	popls	{r4, r5, r6, r7, pc}
  141508:	e3a04000 	mov	r4, #0
  14150c:	e203c004 	and	ip, r3, #4
  141510:	e28cc018 	add	ip, ip, #24
  141514:	e042200c 	sub	r2, r2, ip
  141518:	e352001f 	cmp	r2, #31
  14151c:	e583100c 	str	r1, [r3, #12]
  141520:	e5831010 	str	r1, [r3, #16]
  141524:	e5831014 	str	r1, [r3, #20]
  141528:	e5831018 	str	r1, [r3, #24]
  14152c:	e1a05001 	mov	r5, r1
  141530:	e50e101c 	str	r1, [lr, #-28]	; 0xffffffe4
  141534:	e50e1018 	str	r1, [lr, #-24]	; 0xffffffe8
  141538:	e50e1014 	str	r1, [lr, #-20]	; 0xffffffec
  14153c:	e50e1010 	str	r1, [lr, #-16]
  141540:	e1846001 	orr	r6, r4, r1
  141544:	e1a07001 	mov	r7, r1
  141548:	e083100c 	add	r1, r3, ip
  14154c:	98bd80f0 	popls	{r4, r5, r6, r7, pc}
  141550:	e2422020 	sub	r2, r2, #32
  141554:	e3c2301f 	bic	r3, r2, #31
  141558:	e2812040 	add	r2, r1, #64	; 0x40
  14155c:	e0833002 	add	r3, r3, r2
  141560:	e2812020 	add	r2, r1, #32
  141564:	e5026020 	str	r6, [r2, #-32]	; 0xffffffe0
  141568:	e502701c 	str	r7, [r2, #-28]	; 0xffffffe4
  14156c:	e5026018 	str	r6, [r2, #-24]	; 0xffffffe8
  141570:	e5027014 	str	r7, [r2, #-20]	; 0xffffffec
  141574:	e5026010 	str	r6, [r2, #-16]
  141578:	e502700c 	str	r7, [r2, #-12]
  14157c:	e90200c0 	stmdb	r2, {r6, r7}
  141580:	e2822020 	add	r2, r2, #32
  141584:	e1520003 	cmp	r2, r3
  141588:	1afffff5 	bne	141564 <memset+0xf0>
  14158c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

00141590 <strcasecmp>:
  141590:	e92d4070 	push	{r4, r5, r6, lr}
  141594:	e1a05000 	mov	r5, r0
  141598:	e5d00000 	ldrb	r0, [r0]
  14159c:	e1a04001 	mov	r4, r1
  1415a0:	e3500000 	cmp	r0, #0
  1415a4:	1a00000c 	bne	1415dc <strcasecmp+0x4c>
  1415a8:	ea00000e 	b	1415e8 <strcasecmp+0x58>
  1415ac:	e1500003 	cmp	r0, r3
  1415b0:	0a000005 	beq	1415cc <strcasecmp+0x3c>
  1415b4:	eb000686 	bl	142fd4 <tolower>
  1415b8:	e1a06000 	mov	r6, r0
  1415bc:	e5d40000 	ldrb	r0, [r4]
  1415c0:	eb000683 	bl	142fd4 <tolower>
  1415c4:	e1560000 	cmp	r6, r0
  1415c8:	1a00000c 	bne	141600 <strcasecmp+0x70>
  1415cc:	e5f50001 	ldrb	r0, [r5, #1]!
  1415d0:	e2844001 	add	r4, r4, #1
  1415d4:	e3500000 	cmp	r0, #0
  1415d8:	0a000002 	beq	1415e8 <strcasecmp+0x58>
  1415dc:	e5d43000 	ldrb	r3, [r4]
  1415e0:	e3530000 	cmp	r3, #0
  1415e4:	1afffff0 	bne	1415ac <strcasecmp+0x1c>
  1415e8:	eb000679 	bl	142fd4 <tolower>
  1415ec:	e1a05000 	mov	r5, r0
  1415f0:	e5d40000 	ldrb	r0, [r4]
  1415f4:	eb000676 	bl	142fd4 <tolower>
  1415f8:	e0450000 	sub	r0, r5, r0
  1415fc:	e8bd8070 	pop	{r4, r5, r6, pc}
  141600:	e5d50000 	ldrb	r0, [r5]
  141604:	eafffff7 	b	1415e8 <strcasecmp+0x58>

00141608 <__strcasecmp_l>:
  141608:	eaffffe0 	b	141590 <strcasecmp>

0014160c <strcat>:
  14160c:	e92d4070 	push	{r4, r5, r6, lr}
  141610:	e1a04000 	mov	r4, r0
  141614:	e1a05001 	mov	r5, r1
  141618:	eb000026 	bl	1416b8 <strlen>
  14161c:	e1a01005 	mov	r1, r5
  141620:	e0840000 	add	r0, r4, r0
  141624:	eb000012 	bl	141674 <strcpy>
  141628:	e1a00004 	mov	r0, r4
  14162c:	e8bd8070 	pop	{r4, r5, r6, pc}

00141630 <strcmp>:
  141630:	e5d02000 	ldrb	r2, [r0]
  141634:	e5d13000 	ldrb	r3, [r1]
  141638:	e1530002 	cmp	r3, r2
  14163c:	0a000004 	beq	141654 <strcmp+0x24>
  141640:	ea000009 	b	14166c <strcmp+0x3c>
  141644:	e5f03001 	ldrb	r3, [r0, #1]!
  141648:	e5f12001 	ldrb	r2, [r1, #1]!
  14164c:	e1530002 	cmp	r3, r2
  141650:	1a000003 	bne	141664 <strcmp+0x34>
  141654:	e3530000 	cmp	r3, #0
  141658:	1afffff9 	bne	141644 <strcmp+0x14>
  14165c:	e1a00003 	mov	r0, r3
  141660:	e12fff1e 	bx	lr
  141664:	e0430002 	sub	r0, r3, r2
  141668:	e12fff1e 	bx	lr
  14166c:	e0420003 	sub	r0, r2, r3
  141670:	e12fff1e 	bx	lr

00141674 <strcpy>:
  141674:	e92d4010 	push	{r4, lr}
  141678:	e1a04000 	mov	r4, r0
  14167c:	eb000a9b 	bl	1440f0 <__stpcpy>
  141680:	e1a00004 	mov	r0, r4
  141684:	e8bd8010 	pop	{r4, pc}

00141688 <strdup>:
  141688:	e92d4070 	push	{r4, r5, r6, lr}
  14168c:	e1a05000 	mov	r5, r0
  141690:	eb000008 	bl	1416b8 <strlen>
  141694:	e2804001 	add	r4, r0, #1
  141698:	e1a00004 	mov	r0, r4
  14169c:	ebffefab 	bl	13d550 <malloc>
  1416a0:	e3500000 	cmp	r0, #0
  1416a4:	08bd8070 	popeq	{r4, r5, r6, pc}
  1416a8:	e1a02004 	mov	r2, r4
  1416ac:	e1a01005 	mov	r1, r5
  1416b0:	e8bd4070 	pop	{r4, r5, r6, lr}
  1416b4:	eafffe36 	b	140f94 <memcpy>

001416b8 <strlen>:
  1416b8:	e3100003 	tst	r0, #3
  1416bc:	0a000023 	beq	141750 <strlen+0x98>
  1416c0:	e5d03000 	ldrb	r3, [r0]
  1416c4:	e3530000 	cmp	r3, #0
  1416c8:	12803001 	addne	r3, r0, #1
  1416cc:	1a000005 	bne	1416e8 <strlen+0x30>
  1416d0:	ea000020 	b	141758 <strlen+0xa0>
  1416d4:	e5d31000 	ldrb	r1, [r3]
  1416d8:	e283c001 	add	ip, r3, #1
  1416dc:	e3510000 	cmp	r1, #0
  1416e0:	0a000018 	beq	141748 <strlen+0x90>
  1416e4:	e1a0300c 	mov	r3, ip
  1416e8:	e3130003 	tst	r3, #3
  1416ec:	e1a02003 	mov	r2, r3
  1416f0:	1afffff7 	bne	1416d4 <strlen+0x1c>
  1416f4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  1416f8:	e59fe060 	ldr	lr, [pc, #96]	; 141760 <strlen+0xa8>
  1416fc:	e592c000 	ldr	ip, [r2]
  141700:	e59f305c 	ldr	r3, [pc, #92]	; 141764 <strlen+0xac>
  141704:	e08c100e 	add	r1, ip, lr
  141708:	e1c1100c 	bic	r1, r1, ip
  14170c:	e1110003 	tst	r1, r3
  141710:	1a000004 	bne	141728 <strlen+0x70>
  141714:	e5b2c004 	ldr	ip, [r2, #4]!
  141718:	e08c100e 	add	r1, ip, lr
  14171c:	e1c1100c 	bic	r1, r1, ip
  141720:	e1110003 	tst	r1, r3
  141724:	0afffffa 	beq	141714 <strlen+0x5c>
  141728:	e5d23000 	ldrb	r3, [r2]
  14172c:	e3530000 	cmp	r3, #0
  141730:	0a000002 	beq	141740 <strlen+0x88>
  141734:	e5f23001 	ldrb	r3, [r2, #1]!
  141738:	e3530000 	cmp	r3, #0
  14173c:	1afffffc 	bne	141734 <strlen+0x7c>
  141740:	e0420000 	sub	r0, r2, r0
  141744:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  141748:	e0430000 	sub	r0, r3, r0
  14174c:	e12fff1e 	bx	lr
  141750:	e1a02000 	mov	r2, r0
  141754:	eaffffe6 	b	1416f4 <strlen+0x3c>
  141758:	e1a00003 	mov	r0, r3
  14175c:	e12fff1e 	bx	lr
  141760:	fefefeff 	.word	0xfefefeff
  141764:	80808080 	.word	0x80808080

00141768 <strncmp>:
  141768:	e3520000 	cmp	r2, #0
  14176c:	0a00001e 	beq	1417ec <strncmp+0x84>
  141770:	e92d4010 	push	{r4, lr}
  141774:	e5d04000 	ldrb	r4, [r0]
  141778:	e5d1c000 	ldrb	ip, [r1]
  14177c:	e3540000 	cmp	r4, #0
  141780:	0a00001b 	beq	1417f4 <strncmp+0x8c>
  141784:	e3520001 	cmp	r2, #1
  141788:	135c0000 	cmpne	ip, #0
  14178c:	13a03001 	movne	r3, #1
  141790:	03a03000 	moveq	r3, #0
  141794:	e154000c 	cmp	r4, ip
  141798:	13a03000 	movne	r3, #0
  14179c:	02033001 	andeq	r3, r3, #1
  1417a0:	e3530000 	cmp	r3, #0
  1417a4:	e242e001 	sub	lr, r2, #1
  1417a8:	0a000011 	beq	1417f4 <strncmp+0x8c>
  1417ac:	e5f02001 	ldrb	r2, [r0, #1]!
  1417b0:	e24ee001 	sub	lr, lr, #1
  1417b4:	e3520000 	cmp	r2, #0
  1417b8:	e5f1c001 	ldrb	ip, [r1, #1]!
  1417bc:	0a000008 	beq	1417e4 <strncmp+0x7c>
  1417c0:	e042300c 	sub	r3, r2, ip
  1417c4:	e16f3f13 	clz	r3, r3
  1417c8:	e35c0000 	cmp	ip, #0
  1417cc:	e1a032a3 	lsr	r3, r3, #5
  1417d0:	03a03000 	moveq	r3, #0
  1417d4:	e35e0000 	cmp	lr, #0
  1417d8:	03a03000 	moveq	r3, #0
  1417dc:	e3530000 	cmp	r3, #0
  1417e0:	1afffff1 	bne	1417ac <strncmp+0x44>
  1417e4:	e042000c 	sub	r0, r2, ip
  1417e8:	e8bd8010 	pop	{r4, pc}
  1417ec:	e1a00002 	mov	r0, r2
  1417f0:	e12fff1e 	bx	lr
  1417f4:	e1a02004 	mov	r2, r4
  1417f8:	eafffff9 	b	1417e4 <strncmp+0x7c>

001417fc <strncpy>:
  1417fc:	e92d4010 	push	{r4, lr}
  141800:	e1a04000 	mov	r4, r0
  141804:	eb000a6a 	bl	1441b4 <__stpncpy>
  141808:	e1a00004 	mov	r0, r4
  14180c:	e8bd8010 	pop	{r4, pc}

00141810 <strnlen>:
  141810:	e92d4070 	push	{r4, r5, r6, lr}
  141814:	e1a04001 	mov	r4, r1
  141818:	e3a01000 	mov	r1, #0
  14181c:	e1a02004 	mov	r2, r4
  141820:	e1a05000 	mov	r5, r0
  141824:	eb0009db 	bl	143f98 <memchr>
  141828:	e3500000 	cmp	r0, #0
  14182c:	10400005 	subne	r0, r0, r5
  141830:	01a00004 	moveq	r0, r4
  141834:	e8bd8070 	pop	{r4, r5, r6, pc}

00141838 <twoway_strstr>:
  141838:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  14183c:	e1a08001 	mov	r8, r1
  141840:	e24dde43 	sub	sp, sp, #1072	; 0x430
  141844:	e24dd004 	sub	sp, sp, #4
  141848:	e1a09000 	mov	r9, r0
  14184c:	e3a02020 	mov	r2, #32
  141850:	e3a01000 	mov	r1, #0
  141854:	e28d0010 	add	r0, sp, #16
  141858:	ebffff05 	bl	141474 <memset>
  14185c:	e5d83000 	ldrb	r3, [r8]
  141860:	e3530000 	cmp	r3, #0
  141864:	0a0000c8 	beq	141b8c <twoway_strstr+0x354>
  141868:	e5d92000 	ldrb	r2, [r9]
  14186c:	e3520000 	cmp	r2, #0
  141870:	11a0c008 	movne	ip, r8
  141874:	11a0e009 	movne	lr, r9
  141878:	13a05000 	movne	r5, #0
  14187c:	13a06001 	movne	r6, #1
  141880:	1a000003 	bne	141894 <twoway_strstr+0x5c>
  141884:	ea000075 	b	141a60 <twoway_strstr+0x228>
  141888:	e5fe2001 	ldrb	r2, [lr, #1]!
  14188c:	e3520000 	cmp	r2, #0
  141890:	0a000072 	beq	141a60 <twoway_strstr+0x228>
  141894:	e28d1e43 	add	r1, sp, #1072	; 0x430
  141898:	e1a022a3 	lsr	r2, r3, #5
  14189c:	e0812102 	add	r2, r1, r2, lsl #2
  1418a0:	e0810103 	add	r0, r1, r3, lsl #2
  1418a4:	e203401f 	and	r4, r3, #31
  1418a8:	e5121420 	ldr	r1, [r2, #-1056]	; 0xfffffbe0
  1418ac:	e5fc3001 	ldrb	r3, [ip, #1]!
  1418b0:	e2855001 	add	r5, r5, #1
  1418b4:	e1811416 	orr	r1, r1, r6, lsl r4
  1418b8:	e3530000 	cmp	r3, #0
  1418bc:	e5005400 	str	r5, [r0, #-1024]	; 0xfffffc00
  1418c0:	e5021420 	str	r1, [r2, #-1056]	; 0xfffffbe0
  1418c4:	1affffef 	bne	141888 <twoway_strstr+0x50>
  1418c8:	e3a00001 	mov	r0, #1
  1418cc:	e3e0c000 	mvn	ip, #0
  1418d0:	e1a01000 	mov	r1, r0
  1418d4:	e0832001 	add	r2, r3, r1
  1418d8:	e1550002 	cmp	r5, r2
  1418dc:	e088e00c 	add	lr, r8, ip
  1418e0:	9a00000b 	bls	141914 <twoway_strstr+0xdc>
  1418e4:	e7de4001 	ldrb	r4, [lr, r1]
  1418e8:	e7d8e002 	ldrb	lr, [r8, r2]
  1418ec:	e154000e 	cmp	r4, lr
  1418f0:	0a00008f 	beq	141b34 <twoway_strstr+0x2fc>
  1418f4:	9a000096 	bls	141b54 <twoway_strstr+0x31c>
  1418f8:	e042000c 	sub	r0, r2, ip
  1418fc:	e1a03002 	mov	r3, r2
  141900:	e3a01001 	mov	r1, #1
  141904:	e0832001 	add	r2, r3, r1
  141908:	e1550002 	cmp	r5, r2
  14190c:	e088e00c 	add	lr, r8, ip
  141910:	8afffff3 	bhi	1418e4 <twoway_strstr+0xac>
  141914:	e3a06001 	mov	r6, #1
  141918:	e3a01000 	mov	r1, #0
  14191c:	e1a02006 	mov	r2, r6
  141920:	e3e0a000 	mvn	sl, #0
  141924:	e0813002 	add	r3, r1, r2
  141928:	e1550003 	cmp	r5, r3
  14192c:	e088e002 	add	lr, r8, r2
  141930:	9a00000b 	bls	141964 <twoway_strstr+0x12c>
  141934:	e7de400a 	ldrb	r4, [lr, sl]
  141938:	e7d8e003 	ldrb	lr, [r8, r3]
  14193c:	e154000e 	cmp	r4, lr
  141940:	0a00007f 	beq	141b44 <twoway_strstr+0x30c>
  141944:	2a000087 	bcs	141b68 <twoway_strstr+0x330>
  141948:	e043600a 	sub	r6, r3, sl
  14194c:	e3a02001 	mov	r2, #1
  141950:	e1a01003 	mov	r1, r3
  141954:	e0813002 	add	r3, r1, r2
  141958:	e1550003 	cmp	r5, r3
  14195c:	e088e002 	add	lr, r8, r2
  141960:	8afffff3 	bhi	141934 <twoway_strstr+0xfc>
  141964:	e58d6008 	str	r6, [sp, #8]
  141968:	e28a2001 	add	r2, sl, #1
  14196c:	e28c3001 	add	r3, ip, #1
  141970:	e1520003 	cmp	r2, r3
  141974:	91a0b003 	movls	fp, r3
  141978:	81a0b002 	movhi	fp, r2
  14197c:	e59d3008 	ldr	r3, [sp, #8]
  141980:	91a03000 	movls	r3, r0
  141984:	e1a0200b 	mov	r2, fp
  141988:	e0881003 	add	r1, r8, r3
  14198c:	e1a00008 	mov	r0, r8
  141990:	91a0a00c 	movls	sl, ip
  141994:	e58d3008 	str	r3, [sp, #8]
  141998:	ebfffe3c 	bl	141290 <memcmp>
  14199c:	e3500000 	cmp	r0, #0
  1419a0:	0a000075 	beq	141b7c <twoway_strstr+0x344>
  1419a4:	e2452001 	sub	r2, r5, #1
  1419a8:	e042200a 	sub	r2, r2, sl
  1419ac:	e152000a 	cmp	r2, sl
  1419b0:	e3a03000 	mov	r3, #0
  1419b4:	31a0200a 	movcc	r2, sl
  1419b8:	e58d300c 	str	r3, [sp, #12]
  1419bc:	e2823001 	add	r3, r2, #1
  1419c0:	e58d3008 	str	r3, [sp, #8]
  1419c4:	e1a04009 	mov	r4, r9
  1419c8:	e3a06000 	mov	r6, #0
  1419cc:	e3a07001 	mov	r7, #1
  1419d0:	e385303f 	orr	r3, r5, #63	; 0x3f
  1419d4:	e58d3004 	str	r3, [sp, #4]
  1419d8:	e0493004 	sub	r3, r9, r4
  1419dc:	e1530005 	cmp	r3, r5
  1419e0:	3a000014 	bcc	141a38 <twoway_strstr+0x200>
  1419e4:	e0841005 	add	r1, r4, r5
  1419e8:	e5513001 	ldrb	r3, [r1, #-1]
  1419ec:	e28d0e43 	add	r0, sp, #1072	; 0x430
  1419f0:	e1a022a3 	lsr	r2, r3, #5
  1419f4:	e0802102 	add	r2, r0, r2, lsl #2
  1419f8:	e5122420 	ldr	r2, [r2, #-1056]	; 0xfffffbe0
  1419fc:	e203001f 	and	r0, r3, #31
  141a00:	e0122017 	ands	r2, r2, r7, lsl r0
  141a04:	0a000040 	beq	141b0c <twoway_strstr+0x2d4>
  141a08:	e28d2e43 	add	r2, sp, #1072	; 0x430
  141a0c:	e0823103 	add	r3, r2, r3, lsl #2
  141a10:	e5133400 	ldr	r3, [r3, #-1024]	; 0xfffffc00
  141a14:	e0553003 	subs	r3, r5, r3
  141a18:	0a000015 	beq	141a74 <twoway_strstr+0x23c>
  141a1c:	e1560003 	cmp	r6, r3
  141a20:	20844006 	addcs	r4, r4, r6
  141a24:	30844003 	addcc	r4, r4, r3
  141a28:	e0493004 	sub	r3, r9, r4
  141a2c:	e1530005 	cmp	r3, r5
  141a30:	e3a06000 	mov	r6, #0
  141a34:	2affffea 	bcs	1419e4 <twoway_strstr+0x1ac>
  141a38:	e59d2004 	ldr	r2, [sp, #4]
  141a3c:	e3a01000 	mov	r1, #0
  141a40:	e1a00009 	mov	r0, r9
  141a44:	eb000953 	bl	143f98 <memchr>
  141a48:	e3500000 	cmp	r0, #0
  141a4c:	0a000035 	beq	141b28 <twoway_strstr+0x2f0>
  141a50:	e0403004 	sub	r3, r0, r4
  141a54:	e1530005 	cmp	r3, r5
  141a58:	21a09000 	movcs	r9, r0
  141a5c:	2affffe0 	bcs	1419e4 <twoway_strstr+0x1ac>
  141a60:	e3a04000 	mov	r4, #0
  141a64:	e1a00004 	mov	r0, r4
  141a68:	e28dde43 	add	sp, sp, #1072	; 0x430
  141a6c:	e28dd004 	add	sp, sp, #4
  141a70:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  141a74:	e156000b 	cmp	r6, fp
  141a78:	21a03006 	movcs	r3, r6
  141a7c:	31a0300b 	movcc	r3, fp
  141a80:	e7d82003 	ldrb	r2, [r8, r3]
  141a84:	e0881003 	add	r1, r8, r3
  141a88:	e3520000 	cmp	r2, #0
  141a8c:	0a00000b 	beq	141ac0 <twoway_strstr+0x288>
  141a90:	e7d4c003 	ldrb	ip, [r4, r3]
  141a94:	e0840003 	add	r0, r4, r3
  141a98:	e15c0002 	cmp	ip, r2
  141a9c:	0a000003 	beq	141ab0 <twoway_strstr+0x278>
  141aa0:	ea00001c 	b	141b18 <twoway_strstr+0x2e0>
  141aa4:	e5f0c001 	ldrb	ip, [r0, #1]!
  141aa8:	e15c0002 	cmp	ip, r2
  141aac:	1a000019 	bne	141b18 <twoway_strstr+0x2e0>
  141ab0:	e5f12001 	ldrb	r2, [r1, #1]!
  141ab4:	e2833001 	add	r3, r3, #1
  141ab8:	e3520000 	cmp	r2, #0
  141abc:	1afffff8 	bne	141aa4 <twoway_strstr+0x26c>
  141ac0:	e156000b 	cmp	r6, fp
  141ac4:	2affffe6 	bcs	141a64 <twoway_strstr+0x22c>
  141ac8:	e7d8300a 	ldrb	r3, [r8, sl]
  141acc:	e7d4100a 	ldrb	r1, [r4, sl]
  141ad0:	e088200a 	add	r2, r8, sl
  141ad4:	e1510003 	cmp	r1, r3
  141ad8:	e084300a 	add	r3, r4, sl
  141adc:	1a000006 	bne	141afc <twoway_strstr+0x2c4>
  141ae0:	e0431004 	sub	r1, r3, r4
  141ae4:	e1560001 	cmp	r6, r1
  141ae8:	2affffdd 	bcs	141a64 <twoway_strstr+0x22c>
  141aec:	e5720001 	ldrb	r0, [r2, #-1]!
  141af0:	e5731001 	ldrb	r1, [r3, #-1]!
  141af4:	e1500001 	cmp	r0, r1
  141af8:	0afffff8 	beq	141ae0 <twoway_strstr+0x2a8>
  141afc:	e59d3008 	ldr	r3, [sp, #8]
  141b00:	e59d600c 	ldr	r6, [sp, #12]
  141b04:	e0844003 	add	r4, r4, r3
  141b08:	eaffffb2 	b	1419d8 <twoway_strstr+0x1a0>
  141b0c:	e1a04001 	mov	r4, r1
  141b10:	e1a06002 	mov	r6, r2
  141b14:	eaffffaf 	b	1419d8 <twoway_strstr+0x1a0>
  141b18:	e043300a 	sub	r3, r3, sl
  141b1c:	e0844003 	add	r4, r4, r3
  141b20:	e3a06000 	mov	r6, #0
  141b24:	eaffffab 	b	1419d8 <twoway_strstr+0x1a0>
  141b28:	e59d3004 	ldr	r3, [sp, #4]
  141b2c:	e0899003 	add	r9, r9, r3
  141b30:	eaffffab 	b	1419e4 <twoway_strstr+0x1ac>
  141b34:	e1510000 	cmp	r1, r0
  141b38:	12811001 	addne	r1, r1, #1
  141b3c:	1affff64 	bne	1418d4 <twoway_strstr+0x9c>
  141b40:	eaffff6d 	b	1418fc <twoway_strstr+0xc4>
  141b44:	e1520006 	cmp	r2, r6
  141b48:	12822001 	addne	r2, r2, #1
  141b4c:	1affff74 	bne	141924 <twoway_strstr+0xec>
  141b50:	eaffff7d 	b	14194c <twoway_strstr+0x114>
  141b54:	e3a00001 	mov	r0, #1
  141b58:	e1a0c003 	mov	ip, r3
  141b5c:	e1a01000 	mov	r1, r0
  141b60:	e0833000 	add	r3, r3, r0
  141b64:	eaffff5a 	b	1418d4 <twoway_strstr+0x9c>
  141b68:	e3a06001 	mov	r6, #1
  141b6c:	e1a0a001 	mov	sl, r1
  141b70:	e1a02006 	mov	r2, r6
  141b74:	e0811006 	add	r1, r1, r6
  141b78:	eaffff69 	b	141924 <twoway_strstr+0xec>
  141b7c:	e59d3008 	ldr	r3, [sp, #8]
  141b80:	e0453003 	sub	r3, r5, r3
  141b84:	e58d300c 	str	r3, [sp, #12]
  141b88:	eaffff8d 	b	1419c4 <twoway_strstr+0x18c>
  141b8c:	e3e0c000 	mvn	ip, #0
  141b90:	e3a00001 	mov	r0, #1
  141b94:	e1a05003 	mov	r5, r3
  141b98:	e1a0a00c 	mov	sl, ip
  141b9c:	e58d0008 	str	r0, [sp, #8]
  141ba0:	eaffff70 	b	141968 <twoway_strstr+0x130>

00141ba4 <strstr>:
  141ba4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  141ba8:	e1a04001 	mov	r4, r1
  141bac:	e5d11000 	ldrb	r1, [r1]
  141bb0:	e1a03000 	mov	r3, r0
  141bb4:	e3510000 	cmp	r1, #0
  141bb8:	1a000001 	bne	141bc4 <strstr+0x20>
  141bbc:	e1a00003 	mov	r0, r3
  141bc0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  141bc4:	eb0009cc 	bl	1442fc <strchr>
  141bc8:	e2503000 	subs	r3, r0, #0
  141bcc:	0afffffa 	beq	141bbc <strstr+0x18>
  141bd0:	e5d41001 	ldrb	r1, [r4, #1]
  141bd4:	e3510000 	cmp	r1, #0
  141bd8:	0afffff7 	beq	141bbc <strstr+0x18>
  141bdc:	e5d3c001 	ldrb	ip, [r3, #1]
  141be0:	e35c0000 	cmp	ip, #0
  141be4:	0a000051 	beq	141d30 <strstr+0x18c>
  141be8:	e5d4e002 	ldrb	lr, [r4, #2]
  141bec:	e35e0000 	cmp	lr, #0
  141bf0:	0a000029 	beq	141c9c <strstr+0xf8>
  141bf4:	e5d35002 	ldrb	r5, [r3, #2]
  141bf8:	e3550000 	cmp	r5, #0
  141bfc:	0a00004d 	beq	141d38 <strstr+0x194>
  141c00:	e5d47003 	ldrb	r7, [r4, #3]
  141c04:	e3570000 	cmp	r7, #0
  141c08:	0a000032 	beq	141cd8 <strstr+0x134>
  141c0c:	e5d36003 	ldrb	r6, [r3, #3]
  141c10:	e3560000 	cmp	r6, #0
  141c14:	0a000049 	beq	141d40 <strstr+0x19c>
  141c18:	e5d42004 	ldrb	r2, [r4, #4]
  141c1c:	e3520000 	cmp	r2, #0
  141c20:	0a000002 	beq	141c30 <strstr+0x8c>
  141c24:	e1a01004 	mov	r1, r4
  141c28:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  141c2c:	eaffff01 	b	141838 <twoway_strstr>
  141c30:	e5d40000 	ldrb	r0, [r4]
  141c34:	e4d32003 	ldrb	r2, [r3], #3
  141c38:	e1800401 	orr	r0, r0, r1, lsl #8
  141c3c:	e182240c 	orr	r2, r2, ip, lsl #8
  141c40:	e180080e 	orr	r0, r0, lr, lsl #16
  141c44:	e1822805 	orr	r2, r2, r5, lsl #16
  141c48:	e180ec07 	orr	lr, r0, r7, lsl #24
  141c4c:	e1825c06 	orr	r5, r2, r6, lsl #24
  141c50:	e0252865 	eor	r2, r5, r5, ror #16
  141c54:	e02e086e 	eor	r0, lr, lr, ror #16
  141c58:	e1a02422 	lsr	r2, r2, #8
  141c5c:	e1a00420 	lsr	r0, r0, #8
  141c60:	e3c22cff 	bic	r2, r2, #65280	; 0xff00
  141c64:	e3c00cff 	bic	r0, r0, #65280	; 0xff00
  141c68:	e0222465 	eor	r2, r2, r5, ror #8
  141c6c:	e020046e 	eor	r0, r0, lr, ror #8
  141c70:	e1520000 	cmp	r2, r0
  141c74:	1a000002 	bne	141c84 <strstr+0xe0>
  141c78:	ea000028 	b	141d20 <strstr+0x17c>
  141c7c:	e1500002 	cmp	r0, r2
  141c80:	0a000026 	beq	141d20 <strstr+0x17c>
  141c84:	e5f31001 	ldrb	r1, [r3, #1]!
  141c88:	e3510000 	cmp	r1, #0
  141c8c:	e1812402 	orr	r2, r1, r2, lsl #8
  141c90:	1afffff9 	bne	141c7c <strstr+0xd8>
  141c94:	e1a03001 	mov	r3, r1
  141c98:	eaffffc7 	b	141bbc <strstr+0x18>
  141c9c:	e5d40000 	ldrb	r0, [r4]
  141ca0:	e4d32001 	ldrb	r2, [r3], #1
  141ca4:	e1811400 	orr	r1, r1, r0, lsl #8
  141ca8:	e18c2402 	orr	r2, ip, r2, lsl #8
  141cac:	ea000005 	b	141cc8 <strstr+0x124>
  141cb0:	e5f30001 	ldrb	r0, [r3, #1]!
  141cb4:	e1802402 	orr	r2, r0, r2, lsl #8
  141cb8:	e1a02802 	lsl	r2, r2, #16
  141cbc:	e3500000 	cmp	r0, #0
  141cc0:	e1a02822 	lsr	r2, r2, #16
  141cc4:	0a000017 	beq	141d28 <strstr+0x184>
  141cc8:	e1510002 	cmp	r1, r2
  141ccc:	1afffff7 	bne	141cb0 <strstr+0x10c>
  141cd0:	e2433001 	sub	r3, r3, #1
  141cd4:	eaffffb8 	b	141bbc <strstr+0x18>
  141cd8:	e5d46000 	ldrb	r6, [r4]
  141cdc:	e4d34002 	ldrb	r4, [r3], #2
  141ce0:	e1a00801 	lsl	r0, r1, #16
  141ce4:	e1a0280c 	lsl	r2, ip, #16
  141ce8:	e1800c06 	orr	r0, r0, r6, lsl #24
  141cec:	e1822c04 	orr	r2, r2, r4, lsl #24
  141cf0:	e180040e 	orr	r0, r0, lr, lsl #8
  141cf4:	e1822405 	orr	r2, r2, r5, lsl #8
  141cf8:	ea000004 	b	141d10 <strstr+0x16c>
  141cfc:	e5f31001 	ldrb	r1, [r3, #1]!
  141d00:	e1812002 	orr	r2, r1, r2
  141d04:	e3510000 	cmp	r1, #0
  141d08:	e1a02402 	lsl	r2, r2, #8
  141d0c:	0affffe0 	beq	141c94 <strstr+0xf0>
  141d10:	e1500002 	cmp	r0, r2
  141d14:	1afffff8 	bne	141cfc <strstr+0x158>
  141d18:	e2433002 	sub	r3, r3, #2
  141d1c:	eaffffa6 	b	141bbc <strstr+0x18>
  141d20:	e2433003 	sub	r3, r3, #3
  141d24:	eaffffa4 	b	141bbc <strstr+0x18>
  141d28:	e1a03000 	mov	r3, r0
  141d2c:	eaffffa2 	b	141bbc <strstr+0x18>
  141d30:	e1a0300c 	mov	r3, ip
  141d34:	eaffffa0 	b	141bbc <strstr+0x18>
  141d38:	e1a03005 	mov	r3, r5
  141d3c:	eaffff9e 	b	141bbc <strstr+0x18>
  141d40:	e1a03006 	mov	r3, r6
  141d44:	eaffff9c 	b	141bbc <strstr+0x18>

00141d48 <__lock>:
  141d48:	e59f3150 	ldr	r3, [pc, #336]	; 141ea0 <__lock+0x158>
  141d4c:	e593300c 	ldr	r3, [r3, #12]
  141d50:	e3530000 	cmp	r3, #0
  141d54:	012fff1e 	bxeq	lr
  141d58:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  141d5c:	e1a04000 	mov	r4, r0
  141d60:	e59f613c 	ldr	r6, [pc, #316]	; 141ea4 <__lock+0x15c>
  141d64:	e3a00000 	mov	r0, #0
  141d68:	e3a01106 	mov	r1, #-2147483647	; 0x80000001
  141d6c:	e1a02004 	mov	r2, r4
  141d70:	e5963000 	ldr	r3, [r6]
  141d74:	e12fff33 	blx	r3
  141d78:	e3500000 	cmp	r0, #0
  141d7c:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  141d80:	e5945000 	ldr	r5, [r4]
  141d84:	e3550000 	cmp	r5, #0
  141d88:	0afffff5 	beq	141d64 <__lock+0x1c>
  141d8c:	e3a0800a 	mov	r8, #10
  141d90:	e3550000 	cmp	r5, #0
  141d94:	b2455106 	sublt	r5, r5, #-2147483647	; 0x80000001
  141d98:	e2857106 	add	r7, r5, #-2147483647	; 0x80000001
  141d9c:	e1a00005 	mov	r0, r5
  141da0:	e1a01007 	mov	r1, r7
  141da4:	e1a02004 	mov	r2, r4
  141da8:	e5963000 	ldr	r3, [r6]
  141dac:	e12fff33 	blx	r3
  141db0:	e3500000 	cmp	r0, #0
  141db4:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  141db8:	e5943000 	ldr	r3, [r4]
  141dbc:	e1550003 	cmp	r5, r3
  141dc0:	0afffff5 	beq	141d9c <__lock+0x54>
  141dc4:	e2588001 	subs	r8, r8, #1
  141dc8:	e1a05003 	mov	r5, r3
  141dcc:	1affffef 	bne	141d90 <__lock+0x48>
  141dd0:	e5947000 	ldr	r7, [r4]
  141dd4:	e2875001 	add	r5, r7, #1
  141dd8:	ea000002 	b	141de8 <__lock+0xa0>
  141ddc:	e5943000 	ldr	r3, [r4]
  141de0:	e1570003 	cmp	r7, r3
  141de4:	1afffff9 	bne	141dd0 <__lock+0x88>
  141de8:	e1a00007 	mov	r0, r7
  141dec:	e1a01005 	mov	r1, r5
  141df0:	e1a02004 	mov	r2, r4
  141df4:	e5963000 	ldr	r3, [r6]
  141df8:	e12fff33 	blx	r3
  141dfc:	e3500000 	cmp	r0, #0
  141e00:	1afffff5 	bne	141ddc <__lock+0x94>
  141e04:	e3550000 	cmp	r5, #0
  141e08:	ba00000d 	blt	141e44 <__lock+0xfc>
  141e0c:	e2857102 	add	r7, r5, #-2147483648	; 0x80000000
  141e10:	e1a00005 	mov	r0, r5
  141e14:	e1a01007 	mov	r1, r7
  141e18:	e1a02004 	mov	r2, r4
  141e1c:	e5963000 	ldr	r3, [r6]
  141e20:	e12fff33 	blx	r3
  141e24:	e3500000 	cmp	r0, #0
  141e28:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  141e2c:	e5943000 	ldr	r3, [r4]
  141e30:	e1550003 	cmp	r5, r3
  141e34:	0afffff5 	beq	141e10 <__lock+0xc8>
  141e38:	e1a05003 	mov	r5, r3
  141e3c:	e3550000 	cmp	r5, #0
  141e40:	aafffff1 	bge	141e0c <__lock+0xc4>
  141e44:	e3a000f0 	mov	r0, #240	; 0xf0
  141e48:	ebffe9d8 	bl	13c5b0 <get_rtt_syscall>
  141e4c:	e2507000 	subs	r7, r0, #0
  141e50:	0a000006 	beq	141e70 <__lock+0x128>
  141e54:	e3a03000 	mov	r3, #0
  141e58:	e1a02005 	mov	r2, r5
  141e5c:	e3a01080 	mov	r1, #128	; 0x80
  141e60:	e1a00004 	mov	r0, r4
  141e64:	e12fff37 	blx	r7
  141e68:	e3700026 	cmn	r0, #38	; 0x26
  141e6c:	0a000001 	beq	141e78 <__lock+0x130>
  141e70:	e2455106 	sub	r5, r5, #-2147483647	; 0x80000001
  141e74:	eaffffe4 	b	141e0c <__lock+0xc4>
  141e78:	e3a000f0 	mov	r0, #240	; 0xf0
  141e7c:	ebffe9cb 	bl	13c5b0 <get_rtt_syscall>
  141e80:	e2507000 	subs	r7, r0, #0
  141e84:	0afffff9 	beq	141e70 <__lock+0x128>
  141e88:	e3a03000 	mov	r3, #0
  141e8c:	e1a02005 	mov	r2, r5
  141e90:	e1a01003 	mov	r1, r3
  141e94:	e1a00004 	mov	r0, r4
  141e98:	e12fff37 	blx	r7
  141e9c:	eafffff3 	b	141e70 <__lock+0x128>
  141ea0:	00576e84 	.word	0x00576e84
  141ea4:	0014e3d8 	.word	0x0014e3d8

00141ea8 <__unlock>:
  141ea8:	e5903000 	ldr	r3, [r0]
  141eac:	e3530000 	cmp	r3, #0
  141eb0:	a12fff1e 	bxge	lr
  141eb4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  141eb8:	e1a05000 	mov	r5, r0
  141ebc:	e59f7084 	ldr	r7, [pc, #132]	; 141f48 <__unlock+0xa0>
  141ec0:	e5954000 	ldr	r4, [r5]
  141ec4:	e2446106 	sub	r6, r4, #-2147483647	; 0x80000001
  141ec8:	ea000002 	b	141ed8 <__unlock+0x30>
  141ecc:	e5953000 	ldr	r3, [r5]
  141ed0:	e1540003 	cmp	r4, r3
  141ed4:	1afffff9 	bne	141ec0 <__unlock+0x18>
  141ed8:	e1a00004 	mov	r0, r4
  141edc:	e1a01006 	mov	r1, r6
  141ee0:	e1a02005 	mov	r2, r5
  141ee4:	e5973000 	ldr	r3, [r7]
  141ee8:	e12fff33 	blx	r3
  141eec:	e3500000 	cmp	r0, #0
  141ef0:	1afffff5 	bne	141ecc <__unlock+0x24>
  141ef4:	e3540106 	cmp	r4, #-2147483647	; 0x80000001
  141ef8:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  141efc:	e3a000f0 	mov	r0, #240	; 0xf0
  141f00:	ebffe9aa 	bl	13c5b0 <get_rtt_syscall>
  141f04:	e2503000 	subs	r3, r0, #0
  141f08:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  141f0c:	e3a02001 	mov	r2, #1
  141f10:	e3a01081 	mov	r1, #129	; 0x81
  141f14:	e1a00005 	mov	r0, r5
  141f18:	e12fff33 	blx	r3
  141f1c:	e3700026 	cmn	r0, #38	; 0x26
  141f20:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
  141f24:	e3a000f0 	mov	r0, #240	; 0xf0
  141f28:	ebffe9a0 	bl	13c5b0 <get_rtt_syscall>
  141f2c:	e2503000 	subs	r3, r0, #0
  141f30:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  141f34:	e3a02001 	mov	r2, #1
  141f38:	e1a00005 	mov	r0, r5
  141f3c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  141f40:	e1a01002 	mov	r1, r2
  141f44:	e12fff13 	bx	r3
  141f48:	0014e3d8 	.word	0x0014e3d8

00141f4c <__syscall_cp_c>:
  141f4c:	eaffe9c1 	b	13c658 <__syscall>

00141f50 <__syscall_cp>:
  141f50:	eaffe9c0 	b	13c658 <__syscall>

00141f54 <__wait>:
  141f54:	e3530000 	cmp	r3, #0
  141f58:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  141f5c:	e3a03064 	mov	r3, #100	; 0x64
  141f60:	e1a04001 	mov	r4, r1
  141f64:	e1a07000 	mov	r7, r0
  141f68:	e1a08002 	mov	r8, r2
  141f6c:	13a09080 	movne	r9, #128	; 0x80
  141f70:	03a09000 	moveq	r9, #0
  141f74:	e59f1120 	ldr	r1, [pc, #288]	; 14209c <__wait+0x148>
  141f78:	ea000006 	b	141f98 <__wait+0x44>
  141f7c:	e5972000 	ldr	r2, [r7]
  141f80:	e1520008 	cmp	r2, r8
  141f84:	18bd87f0 	popne	{r4, r5, r6, r7, r8, r9, sl, pc}
  141f88:	e591c000 	ldr	ip, [r1]
  141f8c:	e12fff3c 	blx	ip
  141f90:	e2533001 	subs	r3, r3, #1
  141f94:	0a00003d 	beq	142090 <__wait+0x13c>
  141f98:	e3540000 	cmp	r4, #0
  141f9c:	0afffff6 	beq	141f7c <__wait+0x28>
  141fa0:	e5942000 	ldr	r2, [r4]
  141fa4:	e3520000 	cmp	r2, #0
  141fa8:	0afffff3 	beq	141f7c <__wait+0x28>
  141fac:	e59f60ec 	ldr	r6, [pc, #236]	; 1420a0 <__wait+0x14c>
  141fb0:	e5945000 	ldr	r5, [r4]
  141fb4:	e285a001 	add	sl, r5, #1
  141fb8:	ea000002 	b	141fc8 <__wait+0x74>
  141fbc:	e5943000 	ldr	r3, [r4]
  141fc0:	e1550003 	cmp	r5, r3
  141fc4:	1afffff9 	bne	141fb0 <__wait+0x5c>
  141fc8:	e1a00005 	mov	r0, r5
  141fcc:	e1a0100a 	mov	r1, sl
  141fd0:	e1a02004 	mov	r2, r4
  141fd4:	e5963000 	ldr	r3, [r6]
  141fd8:	e12fff33 	blx	r3
  141fdc:	e3500000 	cmp	r0, #0
  141fe0:	1afffff5 	bne	141fbc <__wait+0x68>
  141fe4:	e5973000 	ldr	r3, [r7]
  141fe8:	e1530008 	cmp	r3, r8
  141fec:	1a000006 	bne	14200c <__wait+0xb8>
  141ff0:	e3a000f0 	mov	r0, #240	; 0xf0
  141ff4:	ebffe96d 	bl	13c5b0 <get_rtt_syscall>
  141ff8:	e2505000 	subs	r5, r0, #0
  141ffc:	1a000012 	bne	14204c <__wait+0xf8>
  142000:	e5973000 	ldr	r3, [r7]
  142004:	e1530008 	cmp	r3, r8
  142008:	0afffff8 	beq	141ff0 <__wait+0x9c>
  14200c:	e3540000 	cmp	r4, #0
  142010:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
  142014:	e59f6084 	ldr	r6, [pc, #132]	; 1420a0 <__wait+0x14c>
  142018:	e5945000 	ldr	r5, [r4]
  14201c:	e2457001 	sub	r7, r5, #1
  142020:	e1a00005 	mov	r0, r5
  142024:	e1a01007 	mov	r1, r7
  142028:	e1a02004 	mov	r2, r4
  14202c:	e5963000 	ldr	r3, [r6]
  142030:	e12fff33 	blx	r3
  142034:	e3500000 	cmp	r0, #0
  142038:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
  14203c:	e5943000 	ldr	r3, [r4]
  142040:	e1550003 	cmp	r5, r3
  142044:	0afffff5 	beq	142020 <__wait+0xcc>
  142048:	eafffff2 	b	142018 <__wait+0xc4>
  14204c:	e3a03000 	mov	r3, #0
  142050:	e1a02008 	mov	r2, r8
  142054:	e1a01009 	mov	r1, r9
  142058:	e1a00007 	mov	r0, r7
  14205c:	e12fff35 	blx	r5
  142060:	e3700026 	cmn	r0, #38	; 0x26
  142064:	1affffe5 	bne	142000 <__wait+0xac>
  142068:	e3a000f0 	mov	r0, #240	; 0xf0
  14206c:	ebffe94f 	bl	13c5b0 <get_rtt_syscall>
  142070:	e2505000 	subs	r5, r0, #0
  142074:	0affffe1 	beq	142000 <__wait+0xac>
  142078:	e3a03000 	mov	r3, #0
  14207c:	e1a02008 	mov	r2, r8
  142080:	e1a01003 	mov	r1, r3
  142084:	e1a00007 	mov	r0, r7
  142088:	e12fff35 	blx	r5
  14208c:	eaffffdb 	b	142000 <__wait+0xac>
  142090:	e3540000 	cmp	r4, #0
  142094:	0affffd9 	beq	142000 <__wait+0xac>
  142098:	eaffffc3 	b	141fac <__wait+0x58>
  14209c:	0014e3d4 	.word	0x0014e3d4
  1420a0:	0014e3d8 	.word	0x0014e3d8

001420a4 <__a_barrier_dummy>:
  1420a4:	e12fff1e 	bx	lr

001420a8 <__a_barrier_oldkuser>:
  1420a8:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
  1420ac:	e1a01000 	mov	r1, r0
  1420b0:	e1a0200d 	mov	r2, sp
  1420b4:	e59fc080 	ldr	ip, [pc, #128]	; 14213c <__a_gettp_cp15+0x8>
  1420b8:	e1a0e00f 	mov	lr, pc
  1420bc:	e1a0f00c 	mov	pc, ip
  1420c0:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
  1420c4:	e12fff1e 	bx	lr

001420c8 <__a_barrier_v6>:
  1420c8:	ee070fba 	mcr	15, 0, r0, cr7, cr10, {5}
  1420cc:	e12fff1e 	bx	lr

001420d0 <__a_barrier_v7>:
  1420d0:	f57ff05b 	dmb	ish
  1420d4:	e12fff1e 	bx	lr

001420d8 <__a_cas_dummy>:
  1420d8:	e1a03000 	mov	r3, r0
  1420dc:	e5920000 	ldr	r0, [r2]
  1420e0:	e0530000 	subs	r0, r3, r0
  1420e4:	05821000 	streq	r1, [r2]
  1420e8:	e12fff1e 	bx	lr

001420ec <__a_cas_v6>:
  1420ec:	e1a03000 	mov	r3, r0
  1420f0:	ee070fba 	mcr	15, 0, r0, cr7, cr10, {5}
  1420f4:	e1920f9f 	ldrex	r0, [r2]
  1420f8:	e0530000 	subs	r0, r3, r0
  1420fc:	01820f91 	strexeq	r0, r1, [r2]
  142100:	03300001 	teqeq	r0, #1
  142104:	0afffffa 	beq	1420f4 <__a_cas_v6+0x8>
  142108:	ee070fba 	mcr	15, 0, r0, cr7, cr10, {5}
  14210c:	e12fff1e 	bx	lr

00142110 <__a_cas_v7>:
  142110:	e1a03000 	mov	r3, r0
  142114:	f57ff05b 	dmb	ish
  142118:	e1920f9f 	ldrex	r0, [r2]
  14211c:	e0530000 	subs	r0, r3, r0
  142120:	01820f91 	strexeq	r0, r1, [r2]
  142124:	03300001 	teqeq	r0, #1
  142128:	0afffffa 	beq	142118 <__a_cas_v7+0x8>
  14212c:	f57ff05b 	dmb	ish
  142130:	e12fff1e 	bx	lr

00142134 <__a_gettp_cp15>:
  142134:	ee1d0f70 	mrc	15, 0, r0, cr13, cr0, {3}
  142138:	e12fff1e 	bx	lr
  14213c:	ffff0fc0 	.word	0xffff0fc0

00142140 <__wake.constprop.2>:
  142140:	e92d4070 	push	{r4, r5, r6, lr}
  142144:	e3510000 	cmp	r1, #0
  142148:	e1a04000 	mov	r4, r0
  14214c:	e3a000f0 	mov	r0, #240	; 0xf0
  142150:	03a05001 	moveq	r5, #1
  142154:	13a05081 	movne	r5, #129	; 0x81
  142158:	ebffe914 	bl	13c5b0 <get_rtt_syscall>
  14215c:	e2503000 	subs	r3, r0, #0
  142160:	08bd8070 	popeq	{r4, r5, r6, pc}
  142164:	e1a01005 	mov	r1, r5
  142168:	e3a02001 	mov	r2, #1
  14216c:	e1a00004 	mov	r0, r4
  142170:	e12fff33 	blx	r3
  142174:	e3700026 	cmn	r0, #38	; 0x26
  142178:	18bd8070 	popne	{r4, r5, r6, pc}
  14217c:	e3a000f0 	mov	r0, #240	; 0xf0
  142180:	ebffe90a 	bl	13c5b0 <get_rtt_syscall>
  142184:	e2503000 	subs	r3, r0, #0
  142188:	08bd8070 	popeq	{r4, r5, r6, pc}
  14218c:	e3a02001 	mov	r2, #1
  142190:	e1a00004 	mov	r0, r4
  142194:	e8bd4070 	pop	{r4, r5, r6, lr}
  142198:	e1a01002 	mov	r1, r2
  14219c:	e12fff13 	bx	r3

001421a0 <__acquire_ptc>:
  1421a0:	e12fff1e 	bx	lr

001421a4 <__tl_lock>:
  1421a4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  1421a8:	e59f3070 	ldr	r3, [pc, #112]	; 142220 <__tl_lock+0x7c>
  1421ac:	e59f4070 	ldr	r4, [pc, #112]	; 142224 <__tl_lock+0x80>
  1421b0:	e5930000 	ldr	r0, [r3]
  1421b4:	e5943000 	ldr	r3, [r4]
  1421b8:	e12fff30 	blx	r0
  1421bc:	e510505c 	ldr	r5, [r0, #-92]	; 0xffffffa4
  1421c0:	e1550003 	cmp	r5, r3
  1421c4:	0a000010 	beq	14220c <__tl_lock+0x68>
  1421c8:	e59f6058 	ldr	r6, [pc, #88]	; 142228 <__tl_lock+0x84>
  1421cc:	e59f7058 	ldr	r7, [pc, #88]	; 14222c <__tl_lock+0x88>
  1421d0:	e3a00000 	mov	r0, #0
  1421d4:	e1a01005 	mov	r1, r5
  1421d8:	e1a02004 	mov	r2, r4
  1421dc:	e5963000 	ldr	r3, [r6]
  1421e0:	e12fff33 	blx	r3
  1421e4:	e3500000 	cmp	r0, #0
  1421e8:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  1421ec:	e5942000 	ldr	r2, [r4]
  1421f0:	e3520000 	cmp	r2, #0
  1421f4:	0afffff5 	beq	1421d0 <__tl_lock+0x2c>
  1421f8:	e3a03000 	mov	r3, #0
  1421fc:	e1a01007 	mov	r1, r7
  142200:	e1a00004 	mov	r0, r4
  142204:	ebffff52 	bl	141f54 <__wait>
  142208:	eafffff0 	b	1421d0 <__tl_lock+0x2c>
  14220c:	e59f201c 	ldr	r2, [pc, #28]	; 142230 <__tl_lock+0x8c>
  142210:	e5923000 	ldr	r3, [r2]
  142214:	e2833001 	add	r3, r3, #1
  142218:	e5823000 	str	r3, [r2]
  14221c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  142220:	0014e3dc 	.word	0x0014e3dc
  142224:	00576ecc 	.word	0x00576ecc
  142228:	0014e3d8 	.word	0x0014e3d8
  14222c:	00150474 	.word	0x00150474
  142230:	00150470 	.word	0x00150470

00142234 <__tl_unlock>:
  142234:	e59f2090 	ldr	r2, [pc, #144]	; 1422cc <__tl_unlock+0x98>
  142238:	e5923000 	ldr	r3, [r2]
  14223c:	e3530000 	cmp	r3, #0
  142240:	1a00001e 	bne	1422c0 <__tl_unlock+0x8c>
  142244:	e59f2084 	ldr	r2, [pc, #132]	; 1422d0 <__tl_unlock+0x9c>
  142248:	e92d4010 	push	{r4, lr}
  14224c:	e592c000 	ldr	ip, [r2]
  142250:	e12fff3c 	blx	ip
  142254:	e59f4078 	ldr	r4, [pc, #120]	; 1422d4 <__tl_unlock+0xa0>
  142258:	e592c000 	ldr	ip, [r2]
  14225c:	e5843000 	str	r3, [r4]
  142260:	e12fff3c 	blx	ip
  142264:	e59f306c 	ldr	r3, [pc, #108]	; 1422d8 <__tl_unlock+0xa4>
  142268:	e5933000 	ldr	r3, [r3]
  14226c:	e3530000 	cmp	r3, #0
  142270:	08bd8010 	popeq	{r4, pc}
  142274:	e3a000f0 	mov	r0, #240	; 0xf0
  142278:	ebffe8cc 	bl	13c5b0 <get_rtt_syscall>
  14227c:	e2503000 	subs	r3, r0, #0
  142280:	08bd8010 	popeq	{r4, pc}
  142284:	e3a02001 	mov	r2, #1
  142288:	e1a00004 	mov	r0, r4
  14228c:	e1a01002 	mov	r1, r2
  142290:	e12fff33 	blx	r3
  142294:	e3700026 	cmn	r0, #38	; 0x26
  142298:	18bd8010 	popne	{r4, pc}
  14229c:	e3a000f0 	mov	r0, #240	; 0xf0
  1422a0:	ebffe8c2 	bl	13c5b0 <get_rtt_syscall>
  1422a4:	e2503000 	subs	r3, r0, #0
  1422a8:	08bd8010 	popeq	{r4, pc}
  1422ac:	e3a02001 	mov	r2, #1
  1422b0:	e1a00004 	mov	r0, r4
  1422b4:	e8bd4010 	pop	{r4, lr}
  1422b8:	e1a01002 	mov	r1, r2
  1422bc:	e12fff13 	bx	r3
  1422c0:	e2433001 	sub	r3, r3, #1
  1422c4:	e5823000 	str	r3, [r2]
  1422c8:	e12fff1e 	bx	lr
  1422cc:	00150470 	.word	0x00150470
  1422d0:	0014e3d4 	.word	0x0014e3d4
  1422d4:	00576ecc 	.word	0x00576ecc
  1422d8:	00150474 	.word	0x00150474

001422dc <__tl_sync>:
  1422dc:	e59f3084 	ldr	r3, [pc, #132]	; 142368 <__tl_sync+0x8c>
  1422e0:	e92d4070 	push	{r4, r5, r6, lr}
  1422e4:	e593c000 	ldr	ip, [r3]
  1422e8:	e12fff3c 	blx	ip
  1422ec:	e59f4078 	ldr	r4, [pc, #120]	; 14236c <__tl_sync+0x90>
  1422f0:	e5942000 	ldr	r2, [r4]
  1422f4:	e3520000 	cmp	r2, #0
  1422f8:	08bd8070 	popeq	{r4, r5, r6, pc}
  1422fc:	e59f506c 	ldr	r5, [pc, #108]	; 142370 <__tl_sync+0x94>
  142300:	e3a03000 	mov	r3, #0
  142304:	e1a01005 	mov	r1, r5
  142308:	e1a00004 	mov	r0, r4
  14230c:	ebffff10 	bl	141f54 <__wait>
  142310:	e5953000 	ldr	r3, [r5]
  142314:	e3530000 	cmp	r3, #0
  142318:	08bd8070 	popeq	{r4, r5, r6, pc}
  14231c:	e3a000f0 	mov	r0, #240	; 0xf0
  142320:	ebffe8a2 	bl	13c5b0 <get_rtt_syscall>
  142324:	e2503000 	subs	r3, r0, #0
  142328:	08bd8070 	popeq	{r4, r5, r6, pc}
  14232c:	e3a02001 	mov	r2, #1
  142330:	e1a00004 	mov	r0, r4
  142334:	e1a01002 	mov	r1, r2
  142338:	e12fff33 	blx	r3
  14233c:	e3700026 	cmn	r0, #38	; 0x26
  142340:	18bd8070 	popne	{r4, r5, r6, pc}
  142344:	e3a000f0 	mov	r0, #240	; 0xf0
  142348:	ebffe898 	bl	13c5b0 <get_rtt_syscall>
  14234c:	e2503000 	subs	r3, r0, #0
  142350:	08bd8070 	popeq	{r4, r5, r6, pc}
  142354:	e3a02001 	mov	r2, #1
  142358:	e1a00004 	mov	r0, r4
  14235c:	e8bd4070 	pop	{r4, r5, r6, lr}
  142360:	e1a01002 	mov	r1, r2
  142364:	e12fff13 	bx	r3
  142368:	0014e3d4 	.word	0x0014e3d4
  14236c:	00576ecc 	.word	0x00576ecc
  142370:	00150474 	.word	0x00150474

00142374 <__pthread_exit>:
  142374:	e3a02000 	mov	r2, #0
  142378:	e1a0c000 	mov	ip, r0
  14237c:	e3a01001 	mov	r1, #1
  142380:	e59f3224 	ldr	r3, [pc, #548]	; 1425ac <__pthread_exit+0x238>
  142384:	e92d4880 	push	{r7, fp, lr}
  142388:	e5930000 	ldr	r0, [r3]
  14238c:	e12fff30 	blx	r0
  142390:	e2404078 	sub	r4, r0, #120	; 0x78
  142394:	e5943048 	ldr	r3, [r4, #72]	; 0x48
  142398:	e5c4102c 	strb	r1, [r4, #44]	; 0x2c
  14239c:	e1530002 	cmp	r3, r2
  1423a0:	e24dd08c 	sub	sp, sp, #140	; 0x8c
  1423a4:	e584c044 	str	ip, [r4, #68]	; 0x44
  1423a8:	e5c4202d 	strb	r2, [r4, #45]	; 0x2d
  1423ac:	0a000006 	beq	1423cc <__pthread_exit+0x58>
  1423b0:	e9930005 	ldmib	r3, {r0, r2}
  1423b4:	e5933000 	ldr	r3, [r3]
  1423b8:	e5842048 	str	r2, [r4, #72]	; 0x48
  1423bc:	e12fff33 	blx	r3
  1423c0:	e5943048 	ldr	r3, [r4, #72]	; 0x48
  1423c4:	e3530000 	cmp	r3, #0
  1423c8:	1afffff8 	bne	1423b0 <__pthread_exit+0x3c>
  1423cc:	e2849064 	add	r9, r4, #100	; 0x64
  1423d0:	ebffff72 	bl	1421a0 <__acquire_ptc>
  1423d4:	e1a00009 	mov	r0, r9
  1423d8:	ebfffe5a 	bl	141d48 <__lock>
  1423dc:	e28d0008 	add	r0, sp, #8
  1423e0:	eb0004ad 	bl	14369c <__block_app_sigs>
  1423e4:	ebffff6e 	bl	1421a4 <__tl_lock>
  1423e8:	e594300c 	ldr	r3, [r4, #12]
  1423ec:	e1530004 	cmp	r3, r4
  1423f0:	0a000041 	beq	1424fc <__pthread_exit+0x188>
  1423f4:	e59f11b4 	ldr	r1, [pc, #436]	; 1425b0 <__pthread_exit+0x23c>
  1423f8:	e5940008 	ldr	r0, [r4, #8]
  1423fc:	e591200c 	ldr	r2, [r1, #12]
  142400:	e59f81ac 	ldr	r8, [pc, #428]	; 1425b4 <__pthread_exit+0x240>
  142404:	e2422001 	sub	r2, r2, #1
  142408:	e581200c 	str	r2, [r1, #12]
  14240c:	e5830008 	str	r0, [r3, #8]
  142410:	e5942008 	ldr	r2, [r4, #8]
  142414:	e582300c 	str	r3, [r2, #12]
  142418:	e584400c 	str	r4, [r4, #12]
  14241c:	e5844008 	str	r4, [r4, #8]
  142420:	eb00028a 	bl	142e50 <__vm_lock>
  142424:	e2843050 	add	r3, r4, #80	; 0x50
  142428:	e58d3004 	str	r3, [sp, #4]
  14242c:	e5946050 	ldr	r6, [r4, #80]	; 0x50
  142430:	e3560000 	cmp	r6, #0
  142434:	0a000020 	beq	1424bc <__pthread_exit+0x148>
  142438:	e59d3004 	ldr	r3, [sp, #4]
  14243c:	e1560003 	cmp	r6, r3
  142440:	0a00001d 	beq	1424bc <__pthread_exit+0x148>
  142444:	e1a07006 	mov	r7, r6
  142448:	e516b008 	ldr	fp, [r6, #-8]
  14244c:	e516a010 	ldr	sl, [r6, #-16]
  142450:	e5846058 	str	r6, [r4, #88]	; 0x58
  142454:	e417300c 	ldr	r3, [r7], #-12
  142458:	e5843050 	str	r3, [r4, #80]	; 0x50
  14245c:	e516500c 	ldr	r5, [r6, #-12]
  142460:	ea000002 	b	142470 <__pthread_exit+0xfc>
  142464:	e516300c 	ldr	r3, [r6, #-12]
  142468:	e1550003 	cmp	r5, r3
  14246c:	1afffffa 	bne	14245c <__pthread_exit+0xe8>
  142470:	e1a00005 	mov	r0, r5
  142474:	e3a01101 	mov	r1, #1073741824	; 0x40000000
  142478:	e1a02007 	mov	r2, r7
  14247c:	e5983000 	ldr	r3, [r8]
  142480:	e12fff33 	blx	r3
  142484:	e3500000 	cmp	r0, #0
  142488:	1afffff5 	bne	142464 <__pthread_exit+0xf0>
  14248c:	e29bb000 	adds	fp, fp, #0
  142490:	13a0b001 	movne	fp, #1
  142494:	e19b3fa5 	orrs	r3, fp, r5, lsr #31
  142498:	e5840058 	str	r0, [r4, #88]	; 0x58
  14249c:	0affffe2 	beq	14242c <__pthread_exit+0xb8>
  1424a0:	e1e0100a 	mvn	r1, sl
  1424a4:	e1a00007 	mov	r0, r7
  1424a8:	e2011080 	and	r1, r1, #128	; 0x80
  1424ac:	ebffff23 	bl	142140 <__wake.constprop.2>
  1424b0:	e5946050 	ldr	r6, [r4, #80]	; 0x50
  1424b4:	e3560000 	cmp	r6, #0
  1424b8:	1affffde 	bne	142438 <__pthread_exit+0xc4>
  1424bc:	eb000276 	bl	142e9c <__vm_unlock>
  1424c0:	e2845024 	add	r5, r4, #36	; 0x24
  1424c4:	ebffff35 	bl	1421a0 <__acquire_ptc>
  1424c8:	ebffff34 	bl	1421a0 <__acquire_ptc>
  1424cc:	ea000002 	b	1424dc <__pthread_exit+0x168>
  1424d0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
  1424d4:	e3530001 	cmp	r3, #1
  1424d8:	1a00000e 	bne	142518 <__pthread_exit+0x1a4>
  1424dc:	e3a00001 	mov	r0, #1
  1424e0:	e3a01000 	mov	r1, #0
  1424e4:	e1a02005 	mov	r2, r5
  1424e8:	e5983000 	ldr	r3, [r8]
  1424ec:	e12fff33 	blx	r3
  1424f0:	e1500001 	cmp	r0, r1
  1424f4:	1afffff5 	bne	1424d0 <__pthread_exit+0x15c>
  1424f8:	ea000008 	b	142520 <__pthread_exit+0x1ac>
  1424fc:	ebffff4c 	bl	142234 <__tl_unlock>
  142500:	e28d0008 	add	r0, sp, #8
  142504:	eb000472 	bl	1436d4 <__restore_sigs>
  142508:	e1a00009 	mov	r0, r9
  14250c:	ebfffe65 	bl	141ea8 <__unlock>
  142510:	e3a00000 	mov	r0, #0
  142514:	ebffdb37 	bl	1391f8 <exit>
  142518:	e3530002 	cmp	r3, #2
  14251c:	0a00000d 	beq	142558 <__pthread_exit+0x1e4>
  142520:	e1a00005 	mov	r0, r5
  142524:	e3a01001 	mov	r1, #1
  142528:	ebffff04 	bl	142140 <__wake.constprop.2>
  14252c:	e3a03000 	mov	r3, #0
  142530:	e1a00009 	mov	r0, r9
  142534:	e584301c 	str	r3, [r4, #28]
  142538:	ebfffe5a 	bl	141ea8 <__unlock>
  14253c:	e3a00001 	mov	r0, #1
  142540:	ebffe81a 	bl	13c5b0 <get_rtt_syscall>
  142544:	e2503000 	subs	r3, r0, #0
  142548:	0afffffb 	beq	14253c <__pthread_exit+0x1c8>
  14254c:	e3a00000 	mov	r0, #0
  142550:	e12fff33 	blx	r3
  142554:	eafffff8 	b	14253c <__pthread_exit+0x1c8>
  142558:	e5943030 	ldr	r3, [r4, #48]	; 0x30
  14255c:	e1530001 	cmp	r3, r1
  142560:	0affffee 	beq	142520 <__pthread_exit+0x1ac>
  142564:	e28d0008 	add	r0, sp, #8
  142568:	eb00043d 	bl	143664 <__block_all_sigs>
  14256c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
  142570:	e3530000 	cmp	r3, #0
  142574:	1a000004 	bne	14258c <__pthread_exit+0x218>
  142578:	eb000225 	bl	142e14 <__vm_wait>
  14257c:	e5941034 	ldr	r1, [r4, #52]	; 0x34
  142580:	e5940030 	ldr	r0, [r4, #48]	; 0x30
  142584:	eb0007f3 	bl	144558 <__unmapself>
  142588:	eaffffe4 	b	142520 <__pthread_exit+0x1ac>
  14258c:	e59f0024 	ldr	r0, [pc, #36]	; 1425b8 <__pthread_exit+0x244>
  142590:	ebffe806 	bl	13c5b0 <get_rtt_syscall>
  142594:	e2503000 	subs	r3, r0, #0
  142598:	0afffff6 	beq	142578 <__pthread_exit+0x204>
  14259c:	e3a0100c 	mov	r1, #12
  1425a0:	e3a00000 	mov	r0, #0
  1425a4:	e12fff33 	blx	r3
  1425a8:	eafffff2 	b	142578 <__pthread_exit+0x204>
  1425ac:	0014e3dc 	.word	0x0014e3dc
  1425b0:	00576e84 	.word	0x00576e84
  1425b4:	0014e3d8 	.word	0x0014e3d8
  1425b8:	00000152 	.word	0x00000152

001425bc <start>:
  1425bc:	e5902008 	ldr	r2, [r0, #8]
  1425c0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  1425c4:	e3520000 	cmp	r2, #0
  1425c8:	e1a08000 	mov	r8, r0
  1425cc:	0a000022 	beq	14265c <start+0xa0>
  1425d0:	e59f30d8 	ldr	r3, [pc, #216]	; 1426b0 <start+0xf4>
  1425d4:	e5926014 	ldr	r6, [r2, #20]
  1425d8:	e5930000 	ldr	r0, [r3]
  1425dc:	e12fff30 	blx	r0
  1425e0:	e2409078 	sub	r9, r0, #120	; 0x78
  1425e4:	e3a0009c 	mov	r0, #156	; 0x9c
  1425e8:	e599501c 	ldr	r5, [r9, #28]
  1425ec:	e2824018 	add	r4, r2, #24
  1425f0:	ebffe7ee 	bl	13c5b0 <get_rtt_syscall>
  1425f4:	e250a000 	subs	sl, r0, #0
  1425f8:	0a000004 	beq	142610 <start+0x54>
  1425fc:	e1a02004 	mov	r2, r4
  142600:	e1a01006 	mov	r1, r6
  142604:	e1a00005 	mov	r0, r5
  142608:	e12fff3a 	blx	sl
  14260c:	e1a0a000 	mov	sl, r0
  142610:	e598500c 	ldr	r5, [r8, #12]
  142614:	e59f7098 	ldr	r7, [pc, #152]	; 1426b4 <start+0xf8>
  142618:	e26a6000 	rsb	r6, sl, #0
  14261c:	e5954000 	ldr	r4, [r5]
  142620:	ea000002 	b	142630 <start+0x74>
  142624:	e5953000 	ldr	r3, [r5]
  142628:	e1540003 	cmp	r4, r3
  14262c:	1afffffa 	bne	14261c <start+0x60>
  142630:	e1a00004 	mov	r0, r4
  142634:	e1a01006 	mov	r1, r6
  142638:	e1a02005 	mov	r2, r5
  14263c:	e5973000 	ldr	r3, [r7]
  142640:	e12fff33 	blx	r3
  142644:	e3500000 	cmp	r0, #0
  142648:	1afffff5 	bne	142624 <start+0x68>
  14264c:	e3740002 	cmn	r4, #2
  142650:	0a000012 	beq	1426a0 <start+0xe4>
  142654:	e35a0000 	cmp	sl, #0
  142658:	1a00000c 	bne	142690 <start+0xd4>
  14265c:	e3a000af 	mov	r0, #175	; 0xaf
  142660:	ebffe7d2 	bl	13c5b0 <get_rtt_syscall>
  142664:	e2504000 	subs	r4, r0, #0
  142668:	e2881010 	add	r1, r8, #16
  14266c:	0a000003 	beq	142680 <start+0xc4>
  142670:	e3a03008 	mov	r3, #8
  142674:	e3a02000 	mov	r2, #0
  142678:	e3a00002 	mov	r0, #2
  14267c:	e12fff34 	blx	r4
  142680:	e5983000 	ldr	r3, [r8]
  142684:	e5980004 	ldr	r0, [r8, #4]
  142688:	e12fff33 	blx	r3
  14268c:	ebffff38 	bl	142374 <__pthread_exit>
  142690:	e3a03002 	mov	r3, #2
  142694:	e3a00000 	mov	r0, #0
  142698:	e5893024 	str	r3, [r9, #36]	; 0x24
  14269c:	ebffff34 	bl	142374 <__pthread_exit>
  1426a0:	e3a01001 	mov	r1, #1
  1426a4:	e598000c 	ldr	r0, [r8, #12]
  1426a8:	ebfffea4 	bl	142140 <__wake.constprop.2>
  1426ac:	eaffffe8 	b	142654 <start+0x98>
  1426b0:	0014e3dc 	.word	0x0014e3dc
  1426b4:	0014e3d8 	.word	0x0014e3d8

001426b8 <start_c11>:
  1426b8:	e5903000 	ldr	r3, [r0]
  1426bc:	e92d4010 	push	{r4, lr}
  1426c0:	e5900004 	ldr	r0, [r0, #4]
  1426c4:	e12fff33 	blx	r3
  1426c8:	ebffff29 	bl	142374 <__pthread_exit>

001426cc <__do_cleanup_push>:
  1426cc:	e1a03000 	mov	r3, r0
  1426d0:	e59f2018 	ldr	r2, [pc, #24]	; 1426f0 <__do_cleanup_push+0x24>
  1426d4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  1426d8:	e5920000 	ldr	r0, [r2]
  1426dc:	e12fff30 	blx	r0
  1426e0:	e5102030 	ldr	r2, [r0, #-48]	; 0xffffffd0
  1426e4:	e5832008 	str	r2, [r3, #8]
  1426e8:	e5003030 	str	r3, [r0, #-48]	; 0xffffffd0
  1426ec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  1426f0:	0014e3dc 	.word	0x0014e3dc

001426f4 <__do_cleanup_pop>:
  1426f4:	e5903008 	ldr	r3, [r0, #8]
  1426f8:	e59f2010 	ldr	r2, [pc, #16]	; 142710 <__do_cleanup_pop+0x1c>
  1426fc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  142700:	e5920000 	ldr	r0, [r2]
  142704:	e12fff30 	blx	r0
  142708:	e5003030 	str	r3, [r0, #-48]	; 0xffffffd0
  14270c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  142710:	0014e3dc 	.word	0x0014e3dc

00142714 <__pthread_create>:
  142714:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  142718:	e24dd0dc 	sub	sp, sp, #220	; 0xdc
  14271c:	e58d001c 	str	r0, [sp, #28]
  142720:	e58d2014 	str	r2, [sp, #20]
  142724:	e1a09001 	mov	r9, r1
  142728:	e28d0034 	add	r0, sp, #52	; 0x34
  14272c:	e3a02024 	mov	r2, #36	; 0x24
  142730:	e3a01000 	mov	r1, #0
  142734:	e58d3018 	str	r3, [sp, #24]
  142738:	ebfffb4d 	bl	141474 <memset>
  14273c:	e3e03000 	mvn	r3, #0
  142740:	e59f656c 	ldr	r6, [pc, #1388]	; 142cb4 <__pthread_create+0x5a0>
  142744:	e58d3028 	str	r3, [sp, #40]	; 0x28
  142748:	e5963000 	ldr	r3, [r6]
  14274c:	e3530000 	cmp	r3, #0
  142750:	03a00026 	moveq	r0, #38	; 0x26
  142754:	0a0000a3 	beq	1429e8 <__pthread_create+0x2d4>
  142758:	e59f3558 	ldr	r3, [pc, #1368]	; 142cb8 <__pthread_create+0x5a4>
  14275c:	e5964004 	ldr	r4, [r6, #4]
  142760:	e5930000 	ldr	r0, [r3]
  142764:	e12fff30 	blx	r0
  142768:	e3540000 	cmp	r4, #0
  14276c:	e240a078 	sub	sl, r0, #120	; 0x78
  142770:	0a0000da 	beq	142ae0 <__pthread_create+0x3cc>
  142774:	e2493001 	sub	r3, r9, #1
  142778:	e3730003 	cmn	r3, #3
  14277c:	9a00009b 	bls	1429f0 <__pthread_create+0x2dc>
  142780:	ebfffe86 	bl	1421a0 <__acquire_ptc>
  142784:	e59f2530 	ldr	r2, [pc, #1328]	; 142cbc <__pthread_create+0x5a8>
  142788:	e59f3530 	ldr	r3, [pc, #1328]	; 142cc0 <__pthread_create+0x5ac>
  14278c:	e5927000 	ldr	r7, [r2]
  142790:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
  142794:	e5933000 	ldr	r3, [r3]
  142798:	e3520000 	cmp	r2, #0
  14279c:	e58d7034 	str	r7, [sp, #52]	; 0x34
  1427a0:	e58d3038 	str	r3, [sp, #56]	; 0x38
  1427a4:	e5960018 	ldr	r0, [r6, #24]
  1427a8:	0a00009e 	beq	142a28 <__pthread_create+0x314>
  1427ac:	e59f4510 	ldr	r4, [pc, #1296]	; 142cc4 <__pthread_create+0x5b0>
  1427b0:	e1a031a7 	lsr	r3, r7, #3
  1427b4:	e5941000 	ldr	r1, [r4]
  1427b8:	e3c2500f 	bic	r5, r2, #15
  1427bc:	e0811000 	add	r1, r1, r0
  1427c0:	e3510b02 	cmp	r1, #2048	; 0x800
  1427c4:	23a0c000 	movcs	ip, #0
  1427c8:	33a0c001 	movcc	ip, #1
  1427cc:	e1530001 	cmp	r3, r1
  1427d0:	93a0c000 	movls	ip, #0
  1427d4:	e0423007 	sub	r3, r2, r7
  1427d8:	e35c0000 	cmp	ip, #0
  1427dc:	e58d3020 	str	r3, [sp, #32]
  1427e0:	1a000111 	bne	142c2c <__pthread_create+0x518>
  1427e4:	e2817eff 	add	r7, r1, #4080	; 0xff0
  1427e8:	e287700f 	add	r7, r7, #15
  1427ec:	e3c77eff 	bic	r7, r7, #4080	; 0xff0
  1427f0:	e3c7700f 	bic	r7, r7, #15
  1427f4:	e3a00000 	mov	r0, #0
  1427f8:	e3a01000 	mov	r1, #0
  1427fc:	e3e03000 	mvn	r3, #0
  142800:	e58d0008 	str	r0, [sp, #8]
  142804:	e58d100c 	str	r1, [sp, #12]
  142808:	e58d3000 	str	r3, [sp]
  14280c:	e3a02003 	mov	r2, #3
  142810:	e3a03022 	mov	r3, #34	; 0x22
  142814:	e1a01007 	mov	r1, r7
  142818:	ebffeda8 	bl	13dec0 <__mmap>
  14281c:	e3700001 	cmn	r0, #1
  142820:	e1a0b000 	mov	fp, r0
  142824:	0a0000ed 	beq	142be0 <__pthread_create+0x4cc>
  142828:	e5943000 	ldr	r3, [r4]
  14282c:	e5960018 	ldr	r0, [r6, #24]
  142830:	e0473003 	sub	r3, r7, r3
  142834:	e08b3003 	add	r3, fp, r3
  142838:	e3550000 	cmp	r5, #0
  14283c:	e58d3024 	str	r3, [sp, #36]	; 0x24
  142840:	e2600000 	rsb	r0, r0, #0
  142844:	0a000108 	beq	142c6c <__pthread_create+0x558>
  142848:	e3a08000 	mov	r8, #0
  14284c:	e0830000 	add	r0, r3, r0
  142850:	eb000209 	bl	14307c <__copy_tls>
  142854:	e1a04000 	mov	r4, r0
  142858:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
  14285c:	e5805038 	str	r5, [r0, #56]	; 0x38
  142860:	e3530000 	cmp	r3, #0
  142864:	e59f345c 	ldr	r3, [pc, #1116]	; 142cc8 <__pthread_create+0x5b4>
  142868:	e5808040 	str	r8, [r0, #64]	; 0x40
  14286c:	e580b030 	str	fp, [r0, #48]	; 0x30
  142870:	e5807034 	str	r7, [r0, #52]	; 0x34
  142874:	e5840000 	str	r0, [r4]
  142878:	e5803060 	str	r3, [r0, #96]	; 0x60
  14287c:	13a03002 	movne	r3, #2
  142880:	03a03001 	moveq	r3, #1
  142884:	e59d2020 	ldr	r2, [sp, #32]
  142888:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
  14288c:	e0452002 	sub	r2, r5, r2
  142890:	e5803024 	str	r3, [r0, #36]	; 0x24
  142894:	e580203c 	str	r2, [r0, #60]	; 0x3c
  142898:	e59a2014 	ldr	r2, [sl, #20]
  14289c:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
  1428a0:	e5802014 	str	r2, [r0, #20]
  1428a4:	e2802050 	add	r2, r0, #80	; 0x50
  1428a8:	e5802050 	str	r2, [r0, #80]	; 0x50
  1428ac:	e59d2014 	ldr	r2, [sp, #20]
  1428b0:	e3c55003 	bic	r5, r5, #3
  1428b4:	e580104c 	str	r1, [r0, #76]	; 0x4c
  1428b8:	e5052018 	str	r2, [r5, #-24]	; 0xffffffe8
  1428bc:	e59d2018 	ldr	r2, [sp, #24]
  1428c0:	e3530000 	cmp	r3, #0
  1428c4:	128d3028 	addne	r3, sp, #40	; 0x28
  1428c8:	e5052014 	str	r2, [r5, #-20]	; 0xffffffec
  1428cc:	128d2034 	addne	r2, sp, #52	; 0x34
  1428d0:	15052010 	strne	r2, [r5, #-16]
  1428d4:	05053010 	streq	r3, [r5, #-16]
  1428d8:	e505300c 	str	r3, [r5, #-12]
  1428dc:	e28d0058 	add	r0, sp, #88	; 0x58
  1428e0:	eb00036d 	bl	14369c <__block_app_sigs>
  1428e4:	e28d1058 	add	r1, sp, #88	; 0x58
  1428e8:	e3a02008 	mov	r2, #8
  1428ec:	e2450008 	sub	r0, r5, #8
  1428f0:	ebfff9a7 	bl	140f94 <memcpy>
  1428f4:	e5153004 	ldr	r3, [r5, #-4]
  1428f8:	e2458018 	sub	r8, r5, #24
  1428fc:	e3c33001 	bic	r3, r3, #1
  142900:	e5053004 	str	r3, [r5, #-4]
  142904:	ebfffe26 	bl	1421a4 <__tl_lock>
  142908:	e59f33bc 	ldr	r3, [pc, #956]	; 142ccc <__pthread_create+0x5b8>
  14290c:	e596c00c 	ldr	ip, [r6, #12]
  142910:	e3790001 	cmn	r9, #1
  142914:	e59f13b4 	ldr	r1, [pc, #948]	; 142cd0 <__pthread_create+0x5bc>
  142918:	e59f03b4 	ldr	r0, [pc, #948]	; 142cd4 <__pthread_create+0x5c0>
  14291c:	e2842078 	add	r2, r4, #120	; 0x78
  142920:	01a00003 	moveq	r0, r3
  142924:	e284301c 	add	r3, r4, #28
  142928:	e28cc001 	add	ip, ip, #1
  14292c:	e58d1008 	str	r1, [sp, #8]
  142930:	e58d2004 	str	r2, [sp, #4]
  142934:	e58d3000 	str	r3, [sp]
  142938:	e1a01008 	mov	r1, r8
  14293c:	e1a03008 	mov	r3, r8
  142940:	e59f2390 	ldr	r2, [pc, #912]	; 142cd8 <__pthread_create+0x5c4>
  142944:	e586c00c 	str	ip, [r6, #12]
  142948:	eb000706 	bl	144568 <__clone>
  14294c:	e3500000 	cmp	r0, #0
  142950:	ba0000a5 	blt	142bec <__pthread_create+0x4d8>
  142954:	e59a300c 	ldr	r3, [sl, #12]
  142958:	e584a008 	str	sl, [r4, #8]
  14295c:	e584300c 	str	r3, [r4, #12]
  142960:	e5834008 	str	r4, [r3, #8]
  142964:	e5943008 	ldr	r3, [r4, #8]
  142968:	e583400c 	str	r4, [r3, #12]
  14296c:	ebfffe30 	bl	142234 <__tl_unlock>
  142970:	e28d0058 	add	r0, sp, #88	; 0x58
  142974:	eb000356 	bl	1436d4 <__restore_sigs>
  142978:	ebfffe08 	bl	1421a0 <__acquire_ptc>
  14297c:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
  142980:	e3530000 	cmp	r3, #0
  142984:	0a000014 	beq	1429dc <__pthread_create+0x2c8>
  142988:	e59f534c 	ldr	r5, [pc, #844]	; 142cdc <__pthread_create+0x5c8>
  14298c:	ea000002 	b	14299c <__pthread_create+0x288>
  142990:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  142994:	e3730001 	cmn	r3, #1
  142998:	1a00000c 	bne	1429d0 <__pthread_create+0x2bc>
  14299c:	e3e00000 	mvn	r0, #0
  1429a0:	e3e01001 	mvn	r1, #1
  1429a4:	e28d2028 	add	r2, sp, #40	; 0x28
  1429a8:	e5953000 	ldr	r3, [r5]
  1429ac:	e12fff33 	blx	r3
  1429b0:	e3500000 	cmp	r0, #0
  1429b4:	1afffff5 	bne	142990 <__pthread_create+0x27c>
  1429b8:	e1a03000 	mov	r3, r0
  1429bc:	e1a02001 	mov	r2, r1
  1429c0:	e28d0028 	add	r0, sp, #40	; 0x28
  1429c4:	e1a01003 	mov	r1, r3
  1429c8:	e3a03001 	mov	r3, #1
  1429cc:	ebfffd60 	bl	141f54 <__wait>
  1429d0:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
  1429d4:	e3500000 	cmp	r0, #0
  1429d8:	1a000002 	bne	1429e8 <__pthread_create+0x2d4>
  1429dc:	e3a00000 	mov	r0, #0
  1429e0:	e59d301c 	ldr	r3, [sp, #28]
  1429e4:	e5834000 	str	r4, [r3]
  1429e8:	e28dd0dc 	add	sp, sp, #220	; 0xdc
  1429ec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  1429f0:	e1a0e009 	mov	lr, r9
  1429f4:	e28dc034 	add	ip, sp, #52	; 0x34
  1429f8:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
  1429fc:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  142a00:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
  142a04:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
  142a08:	e59e3000 	ldr	r3, [lr]
  142a0c:	e58c3000 	str	r3, [ip]
  142a10:	ebfffde2 	bl	1421a0 <__acquire_ptc>
  142a14:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
  142a18:	e59d7034 	ldr	r7, [sp, #52]	; 0x34
  142a1c:	e3520000 	cmp	r2, #0
  142a20:	e5960018 	ldr	r0, [r6, #24]
  142a24:	1affff60 	bne	1427ac <__pthread_create+0x98>
  142a28:	e59f5294 	ldr	r5, [pc, #660]	; 142cc4 <__pthread_create+0x5b0>
  142a2c:	e3a01000 	mov	r1, #0
  142a30:	e5953000 	ldr	r3, [r5]
  142a34:	e59d8038 	ldr	r8, [sp, #56]	; 0x38
  142a38:	e0833000 	add	r3, r3, r0
  142a3c:	e2833eff 	add	r3, r3, #4080	; 0xff0
  142a40:	e283300f 	add	r3, r3, #15
  142a44:	e0837007 	add	r7, r3, r7
  142a48:	e3a00000 	mov	r0, #0
  142a4c:	e3e03000 	mvn	r3, #0
  142a50:	e59f4288 	ldr	r4, [pc, #648]	; 142ce0 <__pthread_create+0x5cc>
  142a54:	e2888eff 	add	r8, r8, #4080	; 0xff0
  142a58:	e288800f 	add	r8, r8, #15
  142a5c:	e0088004 	and	r8, r8, r4
  142a60:	e3580000 	cmp	r8, #0
  142a64:	e0044007 	and	r4, r4, r7
  142a68:	e58d3000 	str	r3, [sp]
  142a6c:	e58d0008 	str	r0, [sp, #8]
  142a70:	e58d100c 	str	r1, [sp, #12]
  142a74:	e3a03022 	mov	r3, #34	; 0x22
  142a78:	e0847008 	add	r7, r4, r8
  142a7c:	0a00007d 	beq	142c78 <__pthread_create+0x564>
  142a80:	e1a00002 	mov	r0, r2
  142a84:	e1a01007 	mov	r1, r7
  142a88:	ebffed0c 	bl	13dec0 <__mmap>
  142a8c:	e3700001 	cmn	r0, #1
  142a90:	e1a0b000 	mov	fp, r0
  142a94:	0a000051 	beq	142be0 <__pthread_create+0x4cc>
  142a98:	e0803008 	add	r3, r0, r8
  142a9c:	e1a01004 	mov	r1, r4
  142aa0:	e1a00003 	mov	r0, r3
  142aa4:	e3a02003 	mov	r2, #3
  142aa8:	e58d3020 	str	r3, [sp, #32]
  142aac:	eb0002d2 	bl	1435fc <__mprotect>
  142ab0:	e3500000 	cmp	r0, #0
  142ab4:	1a000042 	bne	142bc4 <__pthread_create+0x4b0>
  142ab8:	e5953000 	ldr	r3, [r5]
  142abc:	e5960018 	ldr	r0, [r6, #24]
  142ac0:	e0473003 	sub	r3, r7, r3
  142ac4:	e08b3003 	add	r3, fp, r3
  142ac8:	e58d3024 	str	r3, [sp, #36]	; 0x24
  142acc:	e2600000 	rsb	r0, r0, #0
  142ad0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
  142ad4:	e0835000 	add	r5, r3, r0
  142ad8:	e1a00005 	mov	r0, r5
  142adc:	eaffff5b 	b	142850 <__pthread_create+0x13c>
  142ae0:	ebffeee1 	bl	13e66c <__ofl_lock>
  142ae4:	e5903000 	ldr	r3, [r0]
  142ae8:	e3530000 	cmp	r3, #0
  142aec:	0a000005 	beq	142b08 <__pthread_create+0x3f4>
  142af0:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
  142af4:	e3520000 	cmp	r2, #0
  142af8:	b583404c 	strlt	r4, [r3, #76]	; 0x4c
  142afc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
  142b00:	e3530000 	cmp	r3, #0
  142b04:	1afffff9 	bne	142af0 <__pthread_create+0x3dc>
  142b08:	ebffeede 	bl	13e688 <__ofl_unlock>
  142b0c:	e59f31d0 	ldr	r3, [pc, #464]	; 142ce4 <__pthread_create+0x5d0>
  142b10:	e5933000 	ldr	r3, [r3]
  142b14:	e3530000 	cmp	r3, #0
  142b18:	0a000003 	beq	142b2c <__pthread_create+0x418>
  142b1c:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
  142b20:	e3520000 	cmp	r2, #0
  142b24:	b3a02000 	movlt	r2, #0
  142b28:	b583204c 	strlt	r2, [r3, #76]	; 0x4c
  142b2c:	e59f31b4 	ldr	r3, [pc, #436]	; 142ce8 <__pthread_create+0x5d4>
  142b30:	e5933000 	ldr	r3, [r3]
  142b34:	e3530000 	cmp	r3, #0
  142b38:	0a000003 	beq	142b4c <__pthread_create+0x438>
  142b3c:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
  142b40:	e3520000 	cmp	r2, #0
  142b44:	b3a02000 	movlt	r2, #0
  142b48:	b583204c 	strlt	r2, [r3, #76]	; 0x4c
  142b4c:	e59f3198 	ldr	r3, [pc, #408]	; 142cec <__pthread_create+0x5d8>
  142b50:	e5933000 	ldr	r3, [r3]
  142b54:	e3530000 	cmp	r3, #0
  142b58:	0a000003 	beq	142b6c <__pthread_create+0x458>
  142b5c:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
  142b60:	e3520000 	cmp	r2, #0
  142b64:	b3a02000 	movlt	r2, #0
  142b68:	b583204c 	strlt	r2, [r3, #76]	; 0x4c
  142b6c:	e3a03003 	mov	r3, #3
  142b70:	e3a04000 	mov	r4, #0
  142b74:	e3a000af 	mov	r0, #175	; 0xaf
  142b78:	e58d402c 	str	r4, [sp, #44]	; 0x2c
  142b7c:	e58d3030 	str	r3, [sp, #48]	; 0x30
  142b80:	ebffe68a 	bl	13c5b0 <get_rtt_syscall>
  142b84:	e2505000 	subs	r5, r0, #0
  142b88:	0a000004 	beq	142ba0 <__pthread_create+0x48c>
  142b8c:	e1a02004 	mov	r2, r4
  142b90:	e28d102c 	add	r1, sp, #44	; 0x2c
  142b94:	e3a03008 	mov	r3, #8
  142b98:	e3a00001 	mov	r0, #1
  142b9c:	e12fff35 	blx	r5
  142ba0:	e59f3148 	ldr	r3, [pc, #328]	; 142cf0 <__pthread_create+0x5dc>
  142ba4:	e58a304c 	str	r3, [sl, #76]	; 0x4c
  142ba8:	ebfffd7c 	bl	1421a0 <__acquire_ptc>
  142bac:	e3a03001 	mov	r3, #1
  142bb0:	e5863004 	str	r3, [r6, #4]
  142bb4:	e2493001 	sub	r3, r9, #1
  142bb8:	e3730003 	cmn	r3, #3
  142bbc:	8afffeef 	bhi	142780 <__pthread_create+0x6c>
  142bc0:	eaffff8a 	b	1429f0 <__pthread_create+0x2dc>
  142bc4:	ebffd943 	bl	1390d8 <__errno_location>
  142bc8:	e5903000 	ldr	r3, [r0]
  142bcc:	e3530026 	cmp	r3, #38	; 0x26
  142bd0:	0affffb8 	beq	142ab8 <__pthread_create+0x3a4>
  142bd4:	e1a01007 	mov	r1, r7
  142bd8:	e1a0000b 	mov	r0, fp
  142bdc:	ebffed1d 	bl	13e058 <__munmap>
  142be0:	ebfffd6e 	bl	1421a0 <__acquire_ptc>
  142be4:	e3a0000b 	mov	r0, #11
  142be8:	eaffff7e 	b	1429e8 <__pthread_create+0x2d4>
  142bec:	ebfffd90 	bl	142234 <__tl_unlock>
  142bf0:	e28d0058 	add	r0, sp, #88	; 0x58
  142bf4:	eb0002b6 	bl	1436d4 <__restore_sigs>
  142bf8:	ebfffd68 	bl	1421a0 <__acquire_ptc>
  142bfc:	e596300c 	ldr	r3, [r6, #12]
  142c00:	e35b0000 	cmp	fp, #0
  142c04:	e2433001 	sub	r3, r3, #1
  142c08:	e586300c 	str	r3, [r6, #12]
  142c0c:	03a0000b 	moveq	r0, #11
  142c10:	0affff74 	beq	1429e8 <__pthread_create+0x2d4>
  142c14:	e1a01007 	mov	r1, r7
  142c18:	e1a0000b 	mov	r0, fp
  142c1c:	ebffed0d 	bl	13e058 <__munmap>
  142c20:	e3a0000b 	mov	r0, #11
  142c24:	e28dd0dc 	add	sp, sp, #220	; 0xdc
  142c28:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  142c2c:	e5943000 	ldr	r3, [r4]
  142c30:	e1a02001 	mov	r2, r1
  142c34:	e0458003 	sub	r8, r5, r3
  142c38:	e0485000 	sub	r5, r8, r0
  142c3c:	e1a00005 	mov	r0, r5
  142c40:	e3a01000 	mov	r1, #0
  142c44:	e58d8024 	str	r8, [sp, #36]	; 0x24
  142c48:	ebfffa09 	bl	141474 <memset>
  142c4c:	e3580000 	cmp	r8, #0
  142c50:	e1a03008 	mov	r3, r8
  142c54:	0afffee6 	beq	1427f4 <__pthread_create+0xe0>
  142c58:	e3a08000 	mov	r8, #0
  142c5c:	e5960018 	ldr	r0, [r6, #24]
  142c60:	e1a0b008 	mov	fp, r8
  142c64:	e0430000 	sub	r0, r3, r0
  142c68:	eafffef8 	b	142850 <__pthread_create+0x13c>
  142c6c:	e1a08005 	mov	r8, r5
  142c70:	e58db020 	str	fp, [sp, #32]
  142c74:	eaffff95 	b	142ad0 <__pthread_create+0x3bc>
  142c78:	e3a02003 	mov	r2, #3
  142c7c:	e1a01007 	mov	r1, r7
  142c80:	e1a00008 	mov	r0, r8
  142c84:	ebffec8d 	bl	13dec0 <__mmap>
  142c88:	e3700001 	cmn	r0, #1
  142c8c:	e1a0b000 	mov	fp, r0
  142c90:	0affffd2 	beq	142be0 <__pthread_create+0x4cc>
  142c94:	e5953000 	ldr	r3, [r5]
  142c98:	e5960018 	ldr	r0, [r6, #24]
  142c9c:	e0473003 	sub	r3, r7, r3
  142ca0:	e08b3003 	add	r3, fp, r3
  142ca4:	e58d3024 	str	r3, [sp, #36]	; 0x24
  142ca8:	e2600000 	rsb	r0, r0, #0
  142cac:	e58db020 	str	fp, [sp, #32]
  142cb0:	eaffff86 	b	142ad0 <__pthread_create+0x3bc>
  142cb4:	00576e84 	.word	0x00576e84
  142cb8:	0014e3dc 	.word	0x0014e3dc
  142cbc:	0014e3e4 	.word	0x0014e3e4
  142cc0:	0014e3e0 	.word	0x0014e3e0
  142cc4:	00150464 	.word	0x00150464
  142cc8:	00576eac 	.word	0x00576eac
  142ccc:	001426b8 	.word	0x001426b8
  142cd0:	00576ecc 	.word	0x00576ecc
  142cd4:	001425bc 	.word	0x001425bc
  142cd8:	007d0f00 	.word	0x007d0f00
  142cdc:	0014e3d8 	.word	0x0014e3d8
  142ce0:	fffff000 	.word	0xfffff000
  142ce4:	00150468 	.word	0x00150468
  142ce8:	0014e3d0 	.word	0x0014e3d0
  142cec:	0014e338 	.word	0x0014e338
  142cf0:	0015046c 	.word	0x0015046c

00142cf4 <__get_thread_map>:
  142cf4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  142cf8:	e2504000 	subs	r4, r0, #0
  142cfc:	e24dd014 	sub	sp, sp, #20
  142d00:	0a000002 	beq	142d10 <__get_thread_map+0x1c>
  142d04:	e2840078 	add	r0, r4, #120	; 0x78
  142d08:	e28dd014 	add	sp, sp, #20
  142d0c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  142d10:	e3a06000 	mov	r6, #0
  142d14:	e3a07000 	mov	r7, #0
  142d18:	e3e03000 	mvn	r3, #0
  142d1c:	e58d6008 	str	r6, [sp, #8]
  142d20:	e58d700c 	str	r7, [sp, #12]
  142d24:	e59f5074 	ldr	r5, [pc, #116]	; 142da0 <__get_thread_map+0xac>
  142d28:	e3a02003 	mov	r2, #3
  142d2c:	e5951018 	ldr	r1, [r5, #24]
  142d30:	e58d3000 	str	r3, [sp]
  142d34:	e3510000 	cmp	r1, #0
  142d38:	03a01078 	moveq	r1, #120	; 0x78
  142d3c:	e3a03022 	mov	r3, #34	; 0x22
  142d40:	ebffec5e 	bl	13dec0 <__mmap>
  142d44:	e2504000 	subs	r4, r0, #0
  142d48:	0a000012 	beq	142d98 <__get_thread_map+0xa4>
  142d4c:	e59f3050 	ldr	r3, [pc, #80]	; 142da4 <__get_thread_map+0xb0>
  142d50:	e2855028 	add	r5, r5, #40	; 0x28
  142d54:	e5932000 	ldr	r2, [r3]
  142d58:	e2843050 	add	r3, r4, #80	; 0x50
  142d5c:	e5845060 	str	r5, [r4, #96]	; 0x60
  142d60:	e5844000 	str	r4, [r4]
  142d64:	e5844008 	str	r4, [r4, #8]
  142d68:	e584400c 	str	r4, [r4, #12]
  142d6c:	e5842014 	str	r2, [r4, #20]
  142d70:	e5843050 	str	r3, [r4, #80]	; 0x50
  142d74:	e3a000e0 	mov	r0, #224	; 0xe0
  142d78:	ebffe60c 	bl	13c5b0 <get_rtt_syscall>
  142d7c:	e3500000 	cmp	r0, #0
  142d80:	0a000000 	beq	142d88 <__get_thread_map+0x94>
  142d84:	e12fff30 	blx	r0
  142d88:	e3a03000 	mov	r3, #0
  142d8c:	e584001c 	str	r0, [r4, #28]
  142d90:	e5843020 	str	r3, [r4, #32]
  142d94:	eaffffda 	b	142d04 <__get_thread_map+0x10>
  142d98:	e1a00004 	mov	r0, r4
  142d9c:	eaffffd9 	b	142d08 <__get_thread_map+0x14>
  142da0:	00576e84 	.word	0x00576e84
  142da4:	00576ed0 	.word	0x00576ed0

00142da8 <__put_thread_map>:
  142da8:	e3500000 	cmp	r0, #0
  142dac:	012fff1e 	bxeq	lr
  142db0:	e59f3010 	ldr	r3, [pc, #16]	; 142dc8 <__put_thread_map+0x20>
  142db4:	e2400078 	sub	r0, r0, #120	; 0x78
  142db8:	e5931018 	ldr	r1, [r3, #24]
  142dbc:	e3510000 	cmp	r1, #0
  142dc0:	03a01078 	moveq	r1, #120	; 0x78
  142dc4:	eaffeca3 	b	13e058 <__munmap>
  142dc8:	00576e84 	.word	0x00576e84

00142dcc <__pthread_init_run>:
  142dcc:	e92d4070 	push	{r4, r5, r6, lr}
  142dd0:	e1a05000 	mov	r5, r0
  142dd4:	e3a00000 	mov	r0, #0
  142dd8:	e1a06001 	mov	r6, r1
  142ddc:	ebffffc4 	bl	142cf4 <__get_thread_map>
  142de0:	e2504000 	subs	r4, r0, #0
  142de4:	08bd8070 	popeq	{r4, r5, r6, pc}
  142de8:	eb000589 	bl	144414 <__set_thread_area>
  142dec:	e1a00006 	mov	r0, r6
  142df0:	e12fff35 	blx	r5
  142df4:	e59f3014 	ldr	r3, [pc, #20]	; 142e10 <__pthread_init_run+0x44>
  142df8:	e2440078 	sub	r0, r4, #120	; 0x78
  142dfc:	e5931018 	ldr	r1, [r3, #24]
  142e00:	e8bd4070 	pop	{r4, r5, r6, lr}
  142e04:	e3510000 	cmp	r1, #0
  142e08:	03a01078 	moveq	r1, #120	; 0x78
  142e0c:	eaffec91 	b	13e058 <__munmap>
  142e10:	00576e84 	.word	0x00576e84

00142e14 <__vm_wait>:
  142e14:	e92d4070 	push	{r4, r5, r6, lr}
  142e18:	e59f402c 	ldr	r4, [pc, #44]	; 142e4c <__vm_wait+0x38>
  142e1c:	e5942000 	ldr	r2, [r4]
  142e20:	e3520000 	cmp	r2, #0
  142e24:	08bd8070 	popeq	{r4, r5, r6, pc}
  142e28:	e2845004 	add	r5, r4, #4
  142e2c:	e3a03001 	mov	r3, #1
  142e30:	e1a01005 	mov	r1, r5
  142e34:	e59f0010 	ldr	r0, [pc, #16]	; 142e4c <__vm_wait+0x38>
  142e38:	ebfffc45 	bl	141f54 <__wait>
  142e3c:	e5942000 	ldr	r2, [r4]
  142e40:	e3520000 	cmp	r2, #0
  142e44:	1afffff8 	bne	142e2c <__vm_wait+0x18>
  142e48:	e8bd8070 	pop	{r4, r5, r6, pc}
  142e4c:	00150478 	.word	0x00150478

00142e50 <__vm_lock>:
  142e50:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  142e54:	e59f6038 	ldr	r6, [pc, #56]	; 142e94 <__vm_lock+0x44>
  142e58:	e59f8038 	ldr	r8, [pc, #56]	; 142e98 <__vm_lock+0x48>
  142e5c:	e1a07006 	mov	r7, r6
  142e60:	e5964000 	ldr	r4, [r6]
  142e64:	e2845001 	add	r5, r4, #1
  142e68:	e1a00004 	mov	r0, r4
  142e6c:	e1a01005 	mov	r1, r5
  142e70:	e1a02007 	mov	r2, r7
  142e74:	e5983000 	ldr	r3, [r8]
  142e78:	e12fff33 	blx	r3
  142e7c:	e3500000 	cmp	r0, #0
  142e80:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  142e84:	e5963000 	ldr	r3, [r6]
  142e88:	e1540003 	cmp	r4, r3
  142e8c:	0afffff5 	beq	142e68 <__vm_lock+0x18>
  142e90:	eafffff2 	b	142e60 <__vm_lock+0x10>
  142e94:	00150478 	.word	0x00150478
  142e98:	0014e3d8 	.word	0x0014e3d8

00142e9c <__vm_unlock>:
  142e9c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  142ea0:	e59f6098 	ldr	r6, [pc, #152]	; 142f40 <__vm_unlock+0xa4>
  142ea4:	e59f8098 	ldr	r8, [pc, #152]	; 142f44 <__vm_unlock+0xa8>
  142ea8:	e1a07006 	mov	r7, r6
  142eac:	e5964000 	ldr	r4, [r6]
  142eb0:	e2445001 	sub	r5, r4, #1
  142eb4:	ea000002 	b	142ec4 <__vm_unlock+0x28>
  142eb8:	e5963000 	ldr	r3, [r6]
  142ebc:	e1540003 	cmp	r4, r3
  142ec0:	1afffff9 	bne	142eac <__vm_unlock+0x10>
  142ec4:	e1a00004 	mov	r0, r4
  142ec8:	e1a01005 	mov	r1, r5
  142ecc:	e1a02007 	mov	r2, r7
  142ed0:	e5983000 	ldr	r3, [r8]
  142ed4:	e12fff33 	blx	r3
  142ed8:	e3500000 	cmp	r0, #0
  142edc:	1afffff5 	bne	142eb8 <__vm_unlock+0x1c>
  142ee0:	e3540001 	cmp	r4, #1
  142ee4:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
  142ee8:	e5963004 	ldr	r3, [r6, #4]
  142eec:	e3530000 	cmp	r3, #0
  142ef0:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  142ef4:	e3a000f0 	mov	r0, #240	; 0xf0
  142ef8:	ebffe5ac 	bl	13c5b0 <get_rtt_syscall>
  142efc:	e2503000 	subs	r3, r0, #0
  142f00:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  142f04:	e3e02102 	mvn	r2, #-2147483648	; 0x80000000
  142f08:	e3a01081 	mov	r1, #129	; 0x81
  142f0c:	e59f002c 	ldr	r0, [pc, #44]	; 142f40 <__vm_unlock+0xa4>
  142f10:	e12fff33 	blx	r3
  142f14:	e3700026 	cmn	r0, #38	; 0x26
  142f18:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
  142f1c:	e3a000f0 	mov	r0, #240	; 0xf0
  142f20:	ebffe5a2 	bl	13c5b0 <get_rtt_syscall>
  142f24:	e2503000 	subs	r3, r0, #0
  142f28:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  142f2c:	e1a01004 	mov	r1, r4
  142f30:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  142f34:	e3e02102 	mvn	r2, #-2147483648	; 0x80000000
  142f38:	e59f0000 	ldr	r0, [pc]	; 142f40 <__vm_unlock+0xa4>
  142f3c:	e12fff13 	bx	r3
  142f40:	00150478 	.word	0x00150478
  142f44:	0014e3d8 	.word	0x0014e3d8

00142f48 <time>:
  142f48:	e92d4010 	push	{r4, lr}
  142f4c:	e1a04000 	mov	r4, r0
  142f50:	e24dd010 	sub	sp, sp, #16
  142f54:	e1a0100d 	mov	r1, sp
  142f58:	e3a00000 	mov	r0, #0
  142f5c:	eb00059c 	bl	1445d4 <__clock_gettime>
  142f60:	e89d0003 	ldm	sp, {r0, r1}
  142f64:	e3540000 	cmp	r4, #0
  142f68:	18840003 	stmne	r4, {r0, r1}
  142f6c:	e28dd010 	add	sp, sp, #16
  142f70:	e8bd8010 	pop	{r4, pc}

00142f74 <__aio_close>:
  142f74:	e12fff1e 	bx	lr

00142f78 <close>:
  142f78:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  142f7c:	e24dd014 	sub	sp, sp, #20
  142f80:	ebfffffb 	bl	142f74 <__aio_close>
  142f84:	e3a03000 	mov	r3, #0
  142f88:	e1a01000 	mov	r1, r0
  142f8c:	e58d3008 	str	r3, [sp, #8]
  142f90:	e58d3004 	str	r3, [sp, #4]
  142f94:	e58d3000 	str	r3, [sp]
  142f98:	e1a02003 	mov	r2, r3
  142f9c:	e3a00006 	mov	r0, #6
  142fa0:	ebfffbea 	bl	141f50 <__syscall_cp>
  142fa4:	e3700004 	cmn	r0, #4
  142fa8:	03a00000 	moveq	r0, #0
  142fac:	e28dd014 	add	sp, sp, #20
  142fb0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  142fb4:	eaffe5b2 	b	13c684 <__syscall_ret>

00142fb8 <getpid>:
  142fb8:	e92d4010 	push	{r4, lr}
  142fbc:	e3a00014 	mov	r0, #20
  142fc0:	ebffe57a 	bl	13c5b0 <get_rtt_syscall>
  142fc4:	e2503000 	subs	r3, r0, #0
  142fc8:	08bd8010 	popeq	{r4, pc}
  142fcc:	e8bd4010 	pop	{r4, lr}
  142fd0:	e12fff13 	bx	r3

00142fd4 <tolower>:
  142fd4:	e2403041 	sub	r3, r0, #65	; 0x41
  142fd8:	e3530019 	cmp	r3, #25
  142fdc:	93800020 	orrls	r0, r0, #32
  142fe0:	e12fff1e 	bx	lr

00142fe4 <__tolower_l>:
  142fe4:	e2403041 	sub	r3, r0, #65	; 0x41
  142fe8:	e3530019 	cmp	r3, #25
  142fec:	93800020 	orrls	r0, r0, #32
  142ff0:	e12fff1e 	bx	lr

00142ff4 <__init_tp>:
  142ff4:	e92d4010 	push	{r4, lr}
  142ff8:	e5800000 	str	r0, [r0]
  142ffc:	e1a04000 	mov	r4, r0
  143000:	e2800078 	add	r0, r0, #120	; 0x78
  143004:	eb000502 	bl	144414 <__set_thread_area>
  143008:	e3500000 	cmp	r0, #0
  14300c:	ba000015 	blt	143068 <__init_tp+0x74>
  143010:	03a02001 	moveq	r2, #1
  143014:	059f3054 	ldreq	r3, [pc, #84]	; 143070 <__init_tp+0x7c>
  143018:	e3a00c01 	mov	r0, #256	; 0x100
  14301c:	05832000 	streq	r2, [r3]
  143020:	e3a03001 	mov	r3, #1
  143024:	e5843024 	str	r3, [r4, #36]	; 0x24
  143028:	ebffe560 	bl	13c5b0 <get_rtt_syscall>
  14302c:	e2503000 	subs	r3, r0, #0
  143030:	0a00000a 	beq	143060 <__init_tp+0x6c>
  143034:	e59f0038 	ldr	r0, [pc, #56]	; 143074 <__init_tp+0x80>
  143038:	e12fff33 	blx	r3
  14303c:	e59f2034 	ldr	r2, [pc, #52]	; 143078 <__init_tp+0x84>
  143040:	e2843050 	add	r3, r4, #80	; 0x50
  143044:	e584001c 	str	r0, [r4, #28]
  143048:	e5844008 	str	r4, [r4, #8]
  14304c:	e584400c 	str	r4, [r4, #12]
  143050:	e5842060 	str	r2, [r4, #96]	; 0x60
  143054:	e5843050 	str	r3, [r4, #80]	; 0x50
  143058:	e3a00000 	mov	r0, #0
  14305c:	e8bd8010 	pop	{r4, pc}
  143060:	e1a00003 	mov	r0, r3
  143064:	eafffff4 	b	14303c <__init_tp+0x48>
  143068:	e3e00000 	mvn	r0, #0
  14306c:	e8bd8010 	pop	{r4, pc}
  143070:	00576e84 	.word	0x00576e84
  143074:	00576ecc 	.word	0x00576ecc
  143078:	00576eac 	.word	0x00576eac

0014307c <__copy_tls>:
  14307c:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  143080:	e59f808c 	ldr	r8, [pc, #140]	; 143114 <__copy_tls+0x98>
  143084:	e3e03077 	mvn	r3, #119	; 0x77
  143088:	e5982020 	ldr	r2, [r8, #32]
  14308c:	e598601c 	ldr	r6, [r8, #28]
  143090:	e1a07102 	lsl	r7, r2, #2
  143094:	e2277003 	eor	r7, r7, #3
  143098:	e1e07007 	mvn	r7, r7
  14309c:	e5981018 	ldr	r1, [r8, #24]
  1430a0:	e5984014 	ldr	r4, [r8, #20]
  1430a4:	e2466001 	sub	r6, r6, #1
  1430a8:	e0433000 	sub	r3, r3, r0
  1430ac:	e0066003 	and	r6, r6, r3
  1430b0:	e0877001 	add	r7, r7, r1
  1430b4:	e3540000 	cmp	r4, #0
  1430b8:	e1a09000 	mov	r9, r0
  1430bc:	e0806006 	add	r6, r0, r6
  1430c0:	e080a007 	add	sl, r0, r7
  1430c4:	0a00000d 	beq	143100 <__copy_tls+0x84>
  1430c8:	e1a0b00a 	mov	fp, sl
  1430cc:	e2865078 	add	r5, r6, #120	; 0x78
  1430d0:	e5943014 	ldr	r3, [r4, #20]
  1430d4:	e5941004 	ldr	r1, [r4, #4]
  1430d8:	e0853003 	add	r3, r5, r3
  1430dc:	e5ab3004 	str	r3, [fp, #4]!
  1430e0:	e5940014 	ldr	r0, [r4, #20]
  1430e4:	e5942008 	ldr	r2, [r4, #8]
  1430e8:	e0850000 	add	r0, r5, r0
  1430ec:	ebfff7a8 	bl	140f94 <memcpy>
  1430f0:	e5944000 	ldr	r4, [r4]
  1430f4:	e3540000 	cmp	r4, #0
  1430f8:	1afffff4 	bne	1430d0 <__copy_tls+0x54>
  1430fc:	e5982020 	ldr	r2, [r8, #32]
  143100:	e7892007 	str	r2, [r9, r7]
  143104:	e1a00006 	mov	r0, r6
  143108:	e586a074 	str	sl, [r6, #116]	; 0x74
  14310c:	e586a004 	str	sl, [r6, #4]
  143110:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  143114:	00576e84 	.word	0x00576e84

00143118 <__init_tls>:
  143118:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  14311c:	e5901014 	ldr	r1, [r0, #20]
  143120:	e24dd00c 	sub	sp, sp, #12
  143124:	e3510000 	cmp	r1, #0
  143128:	e590600c 	ldr	r6, [r0, #12]
  14312c:	0a000062 	beq	1432bc <__init_tls+0x1a4>
  143130:	e3a04000 	mov	r4, #0
  143134:	e59f81a0 	ldr	r8, [pc, #416]	; 1432dc <__init_tls+0x1c4>
  143138:	e1a02006 	mov	r2, r6
  14313c:	e1a03004 	mov	r3, r4
  143140:	e1a0e004 	mov	lr, r4
  143144:	e590c010 	ldr	ip, [r0, #16]
  143148:	e5987000 	ldr	r7, [r8]
  14314c:	e59f918c 	ldr	r9, [pc, #396]	; 1432e0 <__init_tls+0x1c8>
  143150:	e59f518c 	ldr	r5, [pc, #396]	; 1432e4 <__init_tls+0x1cc>
  143154:	ea000007 	b	143178 <__init_tls+0x60>
  143158:	e3500002 	cmp	r0, #2
  14315c:	1a00003c 	bne	143254 <__init_tls+0x13c>
  143160:	e3550000 	cmp	r5, #0
  143164:	15923008 	ldrne	r3, [r2, #8]
  143168:	10453003 	subne	r3, r5, r3
  14316c:	e2511001 	subs	r1, r1, #1
  143170:	e082200c 	add	r2, r2, ip
  143174:	0a000007 	beq	143198 <__init_tls+0x80>
  143178:	e5920000 	ldr	r0, [r2]
  14317c:	e3500006 	cmp	r0, #6
  143180:	1afffff4 	bne	143158 <__init_tls+0x40>
  143184:	e5923008 	ldr	r3, [r2, #8]
  143188:	e2511001 	subs	r1, r1, #1
  14318c:	e0463003 	sub	r3, r6, r3
  143190:	e082200c 	add	r2, r2, ip
  143194:	1afffff7 	bne	143178 <__init_tls+0x60>
  143198:	e3540000 	cmp	r4, #0
  14319c:	15887000 	strne	r7, [r8]
  1431a0:	e35e0000 	cmp	lr, #0
  1431a4:	0a000044 	beq	1432bc <__init_tls+0x1a4>
  1431a8:	e3a04001 	mov	r4, #1
  1431ac:	e59ec008 	ldr	ip, [lr, #8]
  1431b0:	e59e1010 	ldr	r1, [lr, #16]
  1431b4:	e59f212c 	ldr	r2, [pc, #300]	; 1432e8 <__init_tls+0x1d0>
  1431b8:	e59e001c 	ldr	r0, [lr, #28]
  1431bc:	e083300c 	add	r3, r3, ip
  1431c0:	e59fc124 	ldr	ip, [pc, #292]	; 1432ec <__init_tls+0x1d4>
  1431c4:	e5821008 	str	r1, [r2, #8]
  1431c8:	e5823004 	str	r3, [r2, #4]
  1431cc:	e59e1014 	ldr	r1, [lr, #20]
  1431d0:	e5820010 	str	r0, [r2, #16]
  1431d4:	e58c2014 	str	r2, [ip, #20]
  1431d8:	e58c4020 	str	r4, [ip, #32]
  1431dc:	e3500003 	cmp	r0, #3
  1431e0:	93a0e004 	movls	lr, #4
  1431e4:	e0833001 	add	r3, r3, r1
  1431e8:	e2404001 	sub	r4, r0, #1
  1431ec:	e2633000 	rsb	r3, r3, #0
  1431f0:	e0033004 	and	r3, r3, r4
  1431f4:	e0833001 	add	r3, r3, r1
  1431f8:	93a01087 	movls	r1, #135	; 0x87
  1431fc:	91a0000e 	movls	r0, lr
  143200:	e3c44007 	bic	r4, r4, #7
  143204:	e2844008 	add	r4, r4, #8
  143208:	82801083 	addhi	r1, r0, #131	; 0x83
  14320c:	e5824014 	str	r4, [r2, #20]
  143210:	e0834004 	add	r4, r3, r4
  143214:	e0844001 	add	r4, r4, r1
  143218:	e3c44003 	bic	r4, r4, #3
  14321c:	9582e010 	strls	lr, [r2, #16]
  143220:	e35400bc 	cmp	r4, #188	; 0xbc
  143224:	e58c001c 	str	r0, [ip, #28]
  143228:	e582300c 	str	r3, [r2, #12]
  14322c:	e58c4018 	str	r4, [ip, #24]
  143230:	959f00b8 	ldrls	r0, [pc, #184]	; 1432f0 <__init_tls+0x1d8>
  143234:	8a000013 	bhi	143288 <__init_tls+0x170>
  143238:	ebffff8f 	bl	14307c <__copy_tls>
  14323c:	ebffff6c 	bl	142ff4 <__init_tp>
  143240:	e3500000 	cmp	r0, #0
  143244:	aa000000 	bge	14324c <__init_tls+0x134>
  143248:	e7f000f0 	.word	0xe7f000f0
  14324c:	e28dd00c 	add	sp, sp, #12
  143250:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  143254:	e3500007 	cmp	r0, #7
  143258:	01a0e002 	moveq	lr, r2
  14325c:	0affffc2 	beq	14316c <__init_tls+0x54>
  143260:	e1500009 	cmp	r0, r9
  143264:	1affffc0 	bne	14316c <__init_tls+0x54>
  143268:	e5920014 	ldr	r0, [r2, #20]
  14326c:	e1500007 	cmp	r0, r7
  143270:	9affffbd 	bls	14316c <__init_tls+0x54>
  143274:	e3500502 	cmp	r0, #8388608	; 0x800000
  143278:	31a07000 	movcc	r7, r0
  14327c:	23a07502 	movcs	r7, #8388608	; 0x800000
  143280:	e3a04001 	mov	r4, #1
  143284:	eaffffb8 	b	14316c <__init_tls+0x54>
  143288:	e3a000c0 	mov	r0, #192	; 0xc0
  14328c:	ebffe4c7 	bl	13c5b0 <get_rtt_syscall>
  143290:	e2505000 	subs	r5, r0, #0
  143294:	0a00000e 	beq	1432d4 <__init_tls+0x1bc>
  143298:	e3e03000 	mvn	r3, #0
  14329c:	e3a00000 	mov	r0, #0
  1432a0:	e58d3000 	str	r3, [sp]
  1432a4:	e1a01004 	mov	r1, r4
  1432a8:	e58d0004 	str	r0, [sp, #4]
  1432ac:	e3a03022 	mov	r3, #34	; 0x22
  1432b0:	e3a02003 	mov	r2, #3
  1432b4:	e12fff35 	blx	r5
  1432b8:	eaffffde 	b	143238 <__init_tls+0x120>
  1432bc:	e59f2024 	ldr	r2, [pc, #36]	; 1432e8 <__init_tls+0x1d0>
  1432c0:	e59fc024 	ldr	ip, [pc, #36]	; 1432ec <__init_tls+0x1d4>
  1432c4:	e592100c 	ldr	r1, [r2, #12]
  1432c8:	e5923004 	ldr	r3, [r2, #4]
  1432cc:	e5920010 	ldr	r0, [r2, #16]
  1432d0:	eaffffc1 	b	1431dc <__init_tls+0xc4>
  1432d4:	e1a00005 	mov	r0, r5
  1432d8:	eaffffd6 	b	143238 <__init_tls+0x120>
  1432dc:	0014e3e4 	.word	0x0014e3e4
  1432e0:	6474e551 	.word	0x6474e551
  1432e4:	00000000 	.word	0x00000000
  1432e8:	00150540 	.word	0x00150540
  1432ec:	00576e84 	.word	0x00576e84
  1432f0:	00150484 	.word	0x00150484

001432f4 <__init_ssp>:
  1432f4:	e2501000 	subs	r1, r0, #0
  1432f8:	e92d4010 	push	{r4, lr}
  1432fc:	1a000009 	bne	143328 <__init_ssp+0x34>
  143300:	e59f3034 	ldr	r3, [pc, #52]	; 14333c <__init_ssp+0x48>
  143304:	e59f2034 	ldr	r2, [pc, #52]	; 143340 <__init_ssp+0x4c>
  143308:	e0010293 	mul	r1, r3, r2
  14330c:	e5831000 	str	r1, [r3]
  143310:	e5933000 	ldr	r3, [r3]
  143314:	e59f2028 	ldr	r2, [pc, #40]	; 143344 <__init_ssp+0x50>
  143318:	e5920000 	ldr	r0, [r2]
  14331c:	e12fff30 	blx	r0
  143320:	e5003064 	str	r3, [r0, #-100]	; 0xffffff9c
  143324:	e8bd8010 	pop	{r4, pc}
  143328:	e3a02004 	mov	r2, #4
  14332c:	e59f0008 	ldr	r0, [pc, #8]	; 14333c <__init_ssp+0x48>
  143330:	ebfff717 	bl	140f94 <memcpy>
  143334:	e59f3000 	ldr	r3, [pc]	; 14333c <__init_ssp+0x48>
  143338:	eafffff4 	b	143310 <__init_ssp+0x1c>
  14333c:	00576ed0 	.word	0x00576ed0
  143340:	41c64e6d 	.word	0x41c64e6d
  143344:	0014e3dc 	.word	0x0014e3dc

00143348 <__stack_chk_fail>:
  143348:	e7f000f0 	.word	0xe7f000f0
  14334c:	e12fff1e 	bx	lr

00143350 <_Exit>:
  143350:	e92d4010 	push	{r4, lr}
  143354:	e1a04000 	mov	r4, r0
  143358:	e3a000f8 	mov	r0, #248	; 0xf8
  14335c:	ebffe493 	bl	13c5b0 <get_rtt_syscall>
  143360:	e2503000 	subs	r3, r0, #0
  143364:	0a000001 	beq	143370 <_Exit+0x20>
  143368:	e1a00004 	mov	r0, r4
  14336c:	e12fff33 	blx	r3
  143370:	e3a00001 	mov	r0, #1
  143374:	ebffe48d 	bl	13c5b0 <get_rtt_syscall>
  143378:	e2503000 	subs	r3, r0, #0
  14337c:	0afffffb 	beq	143370 <_Exit+0x20>
  143380:	eafffff8 	b	143368 <_Exit+0x18>

00143384 <abort>:
  143384:	e3a04000 	mov	r4, #0
  143388:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  14338c:	e3a00006 	mov	r0, #6
  143390:	e24dd024 	sub	sp, sp, #36	; 0x24
  143394:	ebffec1d 	bl	13e410 <raise>
  143398:	e1a00004 	mov	r0, r4
  14339c:	eb0000b0 	bl	143664 <__block_all_sigs>
  1433a0:	e59f00b0 	ldr	r0, [pc, #176]	; 143458 <abort+0xd4>
  1433a4:	ebfffa67 	bl	141d48 <__lock>
  1433a8:	e3a000ae 	mov	r0, #174	; 0xae
  1433ac:	e58d400c 	str	r4, [sp, #12]
  1433b0:	e58d4010 	str	r4, [sp, #16]
  1433b4:	e58d4014 	str	r4, [sp, #20]
  1433b8:	e58d4018 	str	r4, [sp, #24]
  1433bc:	e58d401c 	str	r4, [sp, #28]
  1433c0:	ebffe47a 	bl	13c5b0 <get_rtt_syscall>
  1433c4:	e2505000 	subs	r5, r0, #0
  1433c8:	0a000004 	beq	1433e0 <abort+0x5c>
  1433cc:	e1a02004 	mov	r2, r4
  1433d0:	e28d100c 	add	r1, sp, #12
  1433d4:	e3a03008 	mov	r3, #8
  1433d8:	e3a00006 	mov	r0, #6
  1433dc:	e12fff35 	blx	r5
  1433e0:	e59f3074 	ldr	r3, [pc, #116]	; 14345c <abort+0xd8>
  1433e4:	e5930000 	ldr	r0, [r3]
  1433e8:	e12fff30 	blx	r0
  1433ec:	e510405c 	ldr	r4, [r0, #-92]	; 0xffffffa4
  1433f0:	e3a000ee 	mov	r0, #238	; 0xee
  1433f4:	ebffe46d 	bl	13c5b0 <get_rtt_syscall>
  1433f8:	e2503000 	subs	r3, r0, #0
  1433fc:	0a000002 	beq	14340c <abort+0x88>
  143400:	e1a00004 	mov	r0, r4
  143404:	e3a01006 	mov	r1, #6
  143408:	e12fff33 	blx	r3
  14340c:	e3a03020 	mov	r3, #32
  143410:	e3a05000 	mov	r5, #0
  143414:	e08d4003 	add	r4, sp, r3
  143418:	e3a000af 	mov	r0, #175	; 0xaf
  14341c:	e58d5008 	str	r5, [sp, #8]
  143420:	e524301c 	str	r3, [r4, #-28]!	; 0xffffffe4
  143424:	ebffe461 	bl	13c5b0 <get_rtt_syscall>
  143428:	e2506000 	subs	r6, r0, #0
  14342c:	0a000004 	beq	143444 <abort+0xc0>
  143430:	e1a02005 	mov	r2, r5
  143434:	e1a01004 	mov	r1, r4
  143438:	e3a03008 	mov	r3, #8
  14343c:	e3a00001 	mov	r0, #1
  143440:	e12fff36 	blx	r6
  143444:	e7f000f0 	.word	0xe7f000f0
  143448:	e3a00009 	mov	r0, #9
  14344c:	ebffebef 	bl	13e410 <raise>
  143450:	e3a0007f 	mov	r0, #127	; 0x7f
  143454:	ebffffbd 	bl	143350 <_Exit>
  143458:	00576ed4 	.word	0x00576ed4
  14345c:	0014e3dc 	.word	0x0014e3dc

00143460 <__expand_heap>:
  143460:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  143464:	e59f2178 	ldr	r2, [pc, #376]	; 1435e4 <__expand_heap+0x184>
  143468:	e5903000 	ldr	r3, [r0]
  14346c:	e24dd01c 	sub	sp, sp, #28
  143470:	e1530002 	cmp	r3, r2
  143474:	8a000051 	bhi	1435c0 <__expand_heap+0x160>
  143478:	e59f7168 	ldr	r7, [pc, #360]	; 1435e8 <__expand_heap+0x188>
  14347c:	e59f8168 	ldr	r8, [pc, #360]	; 1435ec <__expand_heap+0x18c>
  143480:	e5975000 	ldr	r5, [r7]
  143484:	e2634000 	rsb	r4, r3, #0
  143488:	e3550000 	cmp	r5, #0
  14348c:	e0044008 	and	r4, r4, r8
  143490:	e0844003 	add	r4, r4, r3
  143494:	e1a06000 	mov	r6, r0
  143498:	11e03005 	mvnne	r3, r5
  14349c:	0a00003b 	beq	143590 <__expand_heap+0x130>
  1434a0:	e1540003 	cmp	r4, r3
  1434a4:	2a00001d 	bcs	143520 <__expand_heap+0xc0>
  1434a8:	e59f3140 	ldr	r3, [pc, #320]	; 1435f0 <__expand_heap+0x190>
  1434ac:	e0848005 	add	r8, r4, r5
  1434b0:	e5933010 	ldr	r3, [r3, #16]
  1434b4:	e3530502 	cmp	r3, #8388608	; 0x800000
  1434b8:	21a02003 	movcs	r2, r3
  1434bc:	33a02502 	movcc	r2, #8388608	; 0x800000
  1434c0:	e2422502 	sub	r2, r2, #8388608	; 0x800000
  1434c4:	e1580002 	cmp	r8, r2
  1434c8:	81530005 	cmphi	r3, r5
  1434cc:	8a000013 	bhi	143520 <__expand_heap+0xc0>
  1434d0:	e28d3014 	add	r3, sp, #20
  1434d4:	e3530502 	cmp	r3, #8388608	; 0x800000
  1434d8:	21a02003 	movcs	r2, r3
  1434dc:	33a02502 	movcc	r2, #8388608	; 0x800000
  1434e0:	e2422502 	sub	r2, r2, #8388608	; 0x800000
  1434e4:	e1580002 	cmp	r8, r2
  1434e8:	81530005 	cmphi	r3, r5
  1434ec:	8a00000b 	bhi	143520 <__expand_heap+0xc0>
  1434f0:	e3a0002d 	mov	r0, #45	; 0x2d
  1434f4:	ebffe42d 	bl	13c5b0 <get_rtt_syscall>
  1434f8:	e2503000 	subs	r3, r0, #0
  1434fc:	0a000036 	beq	1435dc <__expand_heap+0x17c>
  143500:	e1a00008 	mov	r0, r8
  143504:	e12fff33 	blx	r3
  143508:	e5972000 	ldr	r2, [r7]
  14350c:	e0823004 	add	r3, r2, r4
  143510:	e1530000 	cmp	r3, r0
  143514:	05864000 	streq	r4, [r6]
  143518:	05870000 	streq	r0, [r7]
  14351c:	0a000018 	beq	143584 <__expand_heap+0x124>
  143520:	e3a01a01 	mov	r1, #4096	; 0x1000
  143524:	e59f50c8 	ldr	r5, [pc, #200]	; 1435f4 <__expand_heap+0x194>
  143528:	e3a08000 	mov	r8, #0
  14352c:	e5953000 	ldr	r3, [r5]
  143530:	e3a09000 	mov	r9, #0
  143534:	e1a030a3 	lsr	r3, r3, #1
  143538:	e1a01311 	lsl	r1, r1, r3
  14353c:	e1510004 	cmp	r1, r4
  143540:	21a04001 	movcs	r4, r1
  143544:	e3e03000 	mvn	r3, #0
  143548:	e3a02003 	mov	r2, #3
  14354c:	e58d3000 	str	r3, [sp]
  143550:	e58d8008 	str	r8, [sp, #8]
  143554:	e58d900c 	str	r9, [sp, #12]
  143558:	e3a03022 	mov	r3, #34	; 0x22
  14355c:	e1a01004 	mov	r1, r4
  143560:	e3a00000 	mov	r0, #0
  143564:	ebffea55 	bl	13dec0 <__mmap>
  143568:	e3700001 	cmn	r0, #1
  14356c:	e1a02000 	mov	r2, r0
  143570:	03a02000 	moveq	r2, #0
  143574:	15953000 	ldrne	r3, [r5]
  143578:	15864000 	strne	r4, [r6]
  14357c:	12833001 	addne	r3, r3, #1
  143580:	15853000 	strne	r3, [r5]
  143584:	e1a00002 	mov	r0, r2
  143588:	e28dd01c 	add	sp, sp, #28
  14358c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  143590:	e3a0002d 	mov	r0, #45	; 0x2d
  143594:	ebffe405 	bl	13c5b0 <get_rtt_syscall>
  143598:	e2503000 	subs	r3, r0, #0
  14359c:	0a00000c 	beq	1435d4 <__expand_heap+0x174>
  1435a0:	e1a00005 	mov	r0, r5
  1435a4:	e12fff33 	blx	r3
  1435a8:	e2605000 	rsb	r5, r0, #0
  1435ac:	e0055008 	and	r5, r5, r8
  1435b0:	e0855000 	add	r5, r5, r0
  1435b4:	e1e03005 	mvn	r3, r5
  1435b8:	e5875000 	str	r5, [r7]
  1435bc:	eaffffb7 	b	1434a0 <__expand_heap+0x40>
  1435c0:	ebffd6c4 	bl	1390d8 <__errno_location>
  1435c4:	e3a0300c 	mov	r3, #12
  1435c8:	e3a02000 	mov	r2, #0
  1435cc:	e5803000 	str	r3, [r0]
  1435d0:	eaffffeb 	b	143584 <__expand_heap+0x124>
  1435d4:	e3e03000 	mvn	r3, #0
  1435d8:	eafffff6 	b	1435b8 <__expand_heap+0x158>
  1435dc:	e1a00003 	mov	r0, r3
  1435e0:	eaffffc8 	b	143508 <__expand_heap+0xa8>
  1435e4:	7fffefff 	.word	0x7fffefff
  1435e8:	00150558 	.word	0x00150558
  1435ec:	00000fff 	.word	0x00000fff
  1435f0:	00576e84 	.word	0x00576e84
  1435f4:	0015055c 	.word	0x0015055c

001435f8 <frexpl>:
  1435f8:	ea000417 	b	14465c <frexp>

001435fc <__mprotect>:
  1435fc:	e2811eff 	add	r1, r1, #4080	; 0xff0
  143600:	e92d4070 	push	{r4, r5, r6, lr}
  143604:	e281100f 	add	r1, r1, #15
  143608:	e59f5040 	ldr	r5, [pc, #64]	; 143650 <__mprotect+0x54>
  14360c:	e0801001 	add	r1, r0, r1
  143610:	e0011005 	and	r1, r1, r5
  143614:	e0055000 	and	r5, r5, r0
  143618:	e3a0007d 	mov	r0, #125	; 0x7d
  14361c:	e1a06002 	mov	r6, r2
  143620:	e0414005 	sub	r4, r1, r5
  143624:	ebffe3e1 	bl	13c5b0 <get_rtt_syscall>
  143628:	e2503000 	subs	r3, r0, #0
  14362c:	0a000005 	beq	143648 <__mprotect+0x4c>
  143630:	e1a02006 	mov	r2, r6
  143634:	e1a01004 	mov	r1, r4
  143638:	e1a00005 	mov	r0, r5
  14363c:	e12fff33 	blx	r3
  143640:	e8bd4070 	pop	{r4, r5, r6, lr}
  143644:	eaffe40e 	b	13c684 <__syscall_ret>
  143648:	e1a00003 	mov	r0, r3
  14364c:	eafffffb 	b	143640 <__mprotect+0x44>
  143650:	fffff000 	.word	0xfffff000

00143654 <wctomb>:
  143654:	e3500000 	cmp	r0, #0
  143658:	012fff1e 	bxeq	lr
  14365c:	e3a02000 	mov	r2, #0
  143660:	ea00042a 	b	144710 <wcrtomb>

00143664 <__block_all_sigs>:
  143664:	e92d4010 	push	{r4, lr}
  143668:	e1a04000 	mov	r4, r0
  14366c:	e3a000af 	mov	r0, #175	; 0xaf
  143670:	ebffe3ce 	bl	13c5b0 <get_rtt_syscall>
  143674:	e250e000 	subs	lr, r0, #0
  143678:	08bd8010 	popeq	{r4, pc}
  14367c:	e1a02004 	mov	r2, r4
  143680:	e1a0c00e 	mov	ip, lr
  143684:	e8bd4010 	pop	{r4, lr}
  143688:	e3a03008 	mov	r3, #8
  14368c:	e59f1004 	ldr	r1, [pc, #4]	; 143698 <__block_all_sigs+0x34>
  143690:	e3a00000 	mov	r0, #0
  143694:	e12fff1c 	bx	ip
  143698:	0014d1c8 	.word	0x0014d1c8

0014369c <__block_app_sigs>:
  14369c:	e92d4010 	push	{r4, lr}
  1436a0:	e1a04000 	mov	r4, r0
  1436a4:	e3a000af 	mov	r0, #175	; 0xaf
  1436a8:	ebffe3c0 	bl	13c5b0 <get_rtt_syscall>
  1436ac:	e250e000 	subs	lr, r0, #0
  1436b0:	08bd8010 	popeq	{r4, pc}
  1436b4:	e1a02004 	mov	r2, r4
  1436b8:	e1a0c00e 	mov	ip, lr
  1436bc:	e8bd4010 	pop	{r4, lr}
  1436c0:	e3a03008 	mov	r3, #8
  1436c4:	e59f1004 	ldr	r1, [pc, #4]	; 1436d0 <__block_app_sigs+0x34>
  1436c8:	e3a00000 	mov	r0, #0
  1436cc:	e12fff1c 	bx	ip
  1436d0:	0014d1d0 	.word	0x0014d1d0

001436d4 <__restore_sigs>:
  1436d4:	e92d4010 	push	{r4, lr}
  1436d8:	e1a04000 	mov	r4, r0
  1436dc:	e3a000af 	mov	r0, #175	; 0xaf
  1436e0:	ebffe3b2 	bl	13c5b0 <get_rtt_syscall>
  1436e4:	e250e000 	subs	lr, r0, #0
  1436e8:	08bd8010 	popeq	{r4, pc}
  1436ec:	e1a01004 	mov	r1, r4
  1436f0:	e1a0c00e 	mov	ip, lr
  1436f4:	e8bd4010 	pop	{r4, lr}
  1436f8:	e3a03008 	mov	r3, #8
  1436fc:	e3a02000 	mov	r2, #0
  143700:	e3a00002 	mov	r0, #2
  143704:	e12fff1c 	bx	ip

00143708 <__lockfile>:
  143708:	e59f2124 	ldr	r2, [pc, #292]	; 143834 <__lockfile+0x12c>
  14370c:	e590304c 	ldr	r3, [r0, #76]	; 0x4c
  143710:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  143714:	e1a06000 	mov	r6, r0
  143718:	e5920000 	ldr	r0, [r2]
  14371c:	e12fff30 	blx	r0
  143720:	e510805c 	ldr	r8, [r0, #-92]	; 0xffffffa4
  143724:	e3c33101 	bic	r3, r3, #1073741824	; 0x40000000
  143728:	e1530008 	cmp	r3, r8
  14372c:	0a00003e 	beq	14382c <__lockfile+0x124>
  143730:	e59f7100 	ldr	r7, [pc, #256]	; 143838 <__lockfile+0x130>
  143734:	e286504c 	add	r5, r6, #76	; 0x4c
  143738:	ea000002 	b	143748 <__lockfile+0x40>
  14373c:	e596304c 	ldr	r3, [r6, #76]	; 0x4c
  143740:	e3530000 	cmp	r3, #0
  143744:	1a000008 	bne	14376c <__lockfile+0x64>
  143748:	e3a00000 	mov	r0, #0
  14374c:	e1a01008 	mov	r1, r8
  143750:	e1a02005 	mov	r2, r5
  143754:	e5973000 	ldr	r3, [r7]
  143758:	e12fff33 	blx	r3
  14375c:	e3500000 	cmp	r0, #0
  143760:	1afffff5 	bne	14373c <__lockfile+0x34>
  143764:	e3a00001 	mov	r0, #1
  143768:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  14376c:	e3888101 	orr	r8, r8, #1073741824	; 0x40000000
  143770:	ea000002 	b	143780 <__lockfile+0x78>
  143774:	e596404c 	ldr	r4, [r6, #76]	; 0x4c
  143778:	e3540000 	cmp	r4, #0
  14377c:	1a000007 	bne	1437a0 <__lockfile+0x98>
  143780:	e3a00000 	mov	r0, #0
  143784:	e1a01008 	mov	r1, r8
  143788:	e1a02005 	mov	r2, r5
  14378c:	e5973000 	ldr	r3, [r7]
  143790:	e12fff33 	blx	r3
  143794:	e3500000 	cmp	r0, #0
  143798:	1afffff5 	bne	143774 <__lockfile+0x6c>
  14379c:	eafffff0 	b	143764 <__lockfile+0x5c>
  1437a0:	e3140101 	tst	r4, #1073741824	; 0x40000000
  1437a4:	e3849101 	orr	r9, r4, #1073741824	; 0x40000000
  1437a8:	0a000017 	beq	14380c <__lockfile+0x104>
  1437ac:	e3a000f0 	mov	r0, #240	; 0xf0
  1437b0:	ebffe37e 	bl	13c5b0 <get_rtt_syscall>
  1437b4:	e2504000 	subs	r4, r0, #0
  1437b8:	0afffff0 	beq	143780 <__lockfile+0x78>
  1437bc:	e3a03000 	mov	r3, #0
  1437c0:	e1a02009 	mov	r2, r9
  1437c4:	e3a01080 	mov	r1, #128	; 0x80
  1437c8:	e1a00005 	mov	r0, r5
  1437cc:	e12fff34 	blx	r4
  1437d0:	e3700026 	cmn	r0, #38	; 0x26
  1437d4:	1affffe9 	bne	143780 <__lockfile+0x78>
  1437d8:	e3a000f0 	mov	r0, #240	; 0xf0
  1437dc:	ebffe373 	bl	13c5b0 <get_rtt_syscall>
  1437e0:	e2504000 	subs	r4, r0, #0
  1437e4:	0affffe5 	beq	143780 <__lockfile+0x78>
  1437e8:	e3a03000 	mov	r3, #0
  1437ec:	e1a02009 	mov	r2, r9
  1437f0:	e1a01003 	mov	r1, r3
  1437f4:	e1a00005 	mov	r0, r5
  1437f8:	e12fff34 	blx	r4
  1437fc:	eaffffdf 	b	143780 <__lockfile+0x78>
  143800:	e596304c 	ldr	r3, [r6, #76]	; 0x4c
  143804:	e1530004 	cmp	r3, r4
  143808:	1affffdc 	bne	143780 <__lockfile+0x78>
  14380c:	e1a00004 	mov	r0, r4
  143810:	e1a01009 	mov	r1, r9
  143814:	e1a02005 	mov	r2, r5
  143818:	e5973000 	ldr	r3, [r7]
  14381c:	e12fff33 	blx	r3
  143820:	e3500000 	cmp	r0, #0
  143824:	1afffff5 	bne	143800 <__lockfile+0xf8>
  143828:	eaffffdf 	b	1437ac <__lockfile+0xa4>
  14382c:	e3a00000 	mov	r0, #0
  143830:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  143834:	0014e3dc 	.word	0x0014e3dc
  143838:	0014e3d8 	.word	0x0014e3d8

0014383c <__unlockfile>:
  14383c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  143840:	e1a05000 	mov	r5, r0
  143844:	e59f7084 	ldr	r7, [pc, #132]	; 1438d0 <__unlockfile+0x94>
  143848:	e280604c 	add	r6, r0, #76	; 0x4c
  14384c:	e595404c 	ldr	r4, [r5, #76]	; 0x4c
  143850:	ea000002 	b	143860 <__unlockfile+0x24>
  143854:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
  143858:	e1540003 	cmp	r4, r3
  14385c:	1afffffa 	bne	14384c <__unlockfile+0x10>
  143860:	e1a00004 	mov	r0, r4
  143864:	e3a01000 	mov	r1, #0
  143868:	e1a02006 	mov	r2, r6
  14386c:	e5973000 	ldr	r3, [r7]
  143870:	e12fff33 	blx	r3
  143874:	e1500001 	cmp	r0, r1
  143878:	1afffff5 	bne	143854 <__unlockfile+0x18>
  14387c:	e3140101 	tst	r4, #1073741824	; 0x40000000
  143880:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  143884:	e3a000f0 	mov	r0, #240	; 0xf0
  143888:	ebffe348 	bl	13c5b0 <get_rtt_syscall>
  14388c:	e2503000 	subs	r3, r0, #0
  143890:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  143894:	e3a02001 	mov	r2, #1
  143898:	e3a01081 	mov	r1, #129	; 0x81
  14389c:	e1a00006 	mov	r0, r6
  1438a0:	e12fff33 	blx	r3
  1438a4:	e3700026 	cmn	r0, #38	; 0x26
  1438a8:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
  1438ac:	e3a000f0 	mov	r0, #240	; 0xf0
  1438b0:	ebffe33e 	bl	13c5b0 <get_rtt_syscall>
  1438b4:	e2503000 	subs	r3, r0, #0
  1438b8:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  1438bc:	e3a02001 	mov	r2, #1
  1438c0:	e1a00006 	mov	r0, r6
  1438c4:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  1438c8:	e1a01002 	mov	r1, r2
  1438cc:	e12fff13 	bx	r3
  1438d0:	0014e3d8 	.word	0x0014e3d8

001438d4 <__overflow>:
  1438d4:	e92d4010 	push	{r4, lr}
  1438d8:	e5903010 	ldr	r3, [r0, #16]
  1438dc:	e24dd008 	sub	sp, sp, #8
  1438e0:	e3530000 	cmp	r3, #0
  1438e4:	e1a04000 	mov	r4, r0
  1438e8:	e5cd1007 	strb	r1, [sp, #7]
  1438ec:	0a000015 	beq	143948 <__overflow+0x74>
  1438f0:	e5942014 	ldr	r2, [r4, #20]
  1438f4:	e1520003 	cmp	r2, r3
  1438f8:	1a000009 	bne	143924 <__overflow+0x50>
  1438fc:	e5943024 	ldr	r3, [r4, #36]	; 0x24
  143900:	e1a00004 	mov	r0, r4
  143904:	e3a02001 	mov	r2, #1
  143908:	e28d1007 	add	r1, sp, #7
  14390c:	e12fff33 	blx	r3
  143910:	e3500001 	cmp	r0, #1
  143914:	1a00000f 	bne	143958 <__overflow+0x84>
  143918:	e5dd0007 	ldrb	r0, [sp, #7]
  14391c:	e28dd008 	add	sp, sp, #8
  143920:	e8bd8010 	pop	{r4, pc}
  143924:	e5dd0007 	ldrb	r0, [sp, #7]
  143928:	e5943050 	ldr	r3, [r4, #80]	; 0x50
  14392c:	e1500003 	cmp	r0, r3
  143930:	0afffff1 	beq	1438fc <__overflow+0x28>
  143934:	e2823001 	add	r3, r2, #1
  143938:	e5843014 	str	r3, [r4, #20]
  14393c:	e5c20000 	strb	r0, [r2]
  143940:	e28dd008 	add	sp, sp, #8
  143944:	e8bd8010 	pop	{r4, pc}
  143948:	eb00008c 	bl	143b80 <__towrite>
  14394c:	e3500000 	cmp	r0, #0
  143950:	05943010 	ldreq	r3, [r4, #16]
  143954:	0affffe5 	beq	1438f0 <__overflow+0x1c>
  143958:	e3e00000 	mvn	r0, #0
  14395c:	eaffffee 	b	14391c <__overflow+0x48>

00143960 <dummy>:
  143960:	e12fff1e 	bx	lr

00143964 <__stdio_close>:
  143964:	e92d4010 	push	{r4, lr}
  143968:	e590003c 	ldr	r0, [r0, #60]	; 0x3c
  14396c:	ebfffd80 	bl	142f74 <__aio_close>
  143970:	e1a04000 	mov	r4, r0
  143974:	e3a00006 	mov	r0, #6
  143978:	ebffe30c 	bl	13c5b0 <get_rtt_syscall>
  14397c:	e2503000 	subs	r3, r0, #0
  143980:	0a000003 	beq	143994 <__stdio_close+0x30>
  143984:	e1a00004 	mov	r0, r4
  143988:	e12fff33 	blx	r3
  14398c:	e8bd4010 	pop	{r4, lr}
  143990:	eaffe33b 	b	13c684 <__syscall_ret>
  143994:	e1a00003 	mov	r0, r3
  143998:	eafffffb 	b	14398c <__stdio_close+0x28>

0014399c <__stdio_seek>:
  14399c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  1439a0:	e590503c 	ldr	r5, [r0, #60]	; 0x3c
  1439a4:	e24dd014 	sub	sp, sp, #20
  1439a8:	e3a0008c 	mov	r0, #140	; 0x8c
  1439ac:	e1a07002 	mov	r7, r2
  1439b0:	e1a06003 	mov	r6, r3
  1439b4:	ebffe2fd 	bl	13c5b0 <get_rtt_syscall>
  1439b8:	e2504000 	subs	r4, r0, #0
  1439bc:	0a00000e 	beq	1439fc <__stdio_seek+0x60>
  1439c0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
  1439c4:	e1a02007 	mov	r2, r7
  1439c8:	e58d3000 	str	r3, [sp]
  1439cc:	e1a01006 	mov	r1, r6
  1439d0:	e28d3008 	add	r3, sp, #8
  1439d4:	e1a00005 	mov	r0, r5
  1439d8:	e12fff34 	blx	r4
  1439dc:	ebffe328 	bl	13c684 <__syscall_ret>
  1439e0:	e3500000 	cmp	r0, #0
  1439e4:	b3e00000 	mvnlt	r0, #0
  1439e8:	b3e01000 	mvnlt	r1, #0
  1439ec:	a28d1008 	addge	r1, sp, #8
  1439f0:	a8910003 	ldmge	r1, {r0, r1}
  1439f4:	e28dd014 	add	sp, sp, #20
  1439f8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  1439fc:	e1a00004 	mov	r0, r4
  143a00:	eafffff5 	b	1439dc <__stdio_seek+0x40>

00143a04 <__stdio_write>:
  143a04:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  143a08:	e590301c 	ldr	r3, [r0, #28]
  143a0c:	e5905014 	ldr	r5, [r0, #20]
  143a10:	e24dd014 	sub	sp, sp, #20
  143a14:	e0455003 	sub	r5, r5, r3
  143a18:	e88d0028 	stm	sp, {r3, r5}
  143a1c:	e1a06000 	mov	r6, r0
  143a20:	e1a08002 	mov	r8, r2
  143a24:	e3a07002 	mov	r7, #2
  143a28:	e58d200c 	str	r2, [sp, #12]
  143a2c:	e58d1008 	str	r1, [sp, #8]
  143a30:	e0855002 	add	r5, r5, r2
  143a34:	e1a0400d 	mov	r4, sp
  143a38:	ea00000d 	b	143a74 <__stdio_write+0x70>
  143a3c:	e3500000 	cmp	r0, #0
  143a40:	ba000020 	blt	143ac8 <__stdio_write+0xc4>
  143a44:	e5943004 	ldr	r3, [r4, #4]
  143a48:	e0455000 	sub	r5, r5, r0
  143a4c:	e1500003 	cmp	r0, r3
  143a50:	80400003 	subhi	r0, r0, r3
  143a54:	8594300c 	ldrhi	r3, [r4, #12]
  143a58:	82844008 	addhi	r4, r4, #8
  143a5c:	e5942000 	ldr	r2, [r4]
  143a60:	e0433000 	sub	r3, r3, r0
  143a64:	e0820000 	add	r0, r2, r0
  143a68:	82477001 	subhi	r7, r7, #1
  143a6c:	e5843004 	str	r3, [r4, #4]
  143a70:	e5840000 	str	r0, [r4]
  143a74:	e3a00092 	mov	r0, #146	; 0x92
  143a78:	e596903c 	ldr	r9, [r6, #60]	; 0x3c
  143a7c:	ebffe2cb 	bl	13c5b0 <get_rtt_syscall>
  143a80:	e2503000 	subs	r3, r0, #0
  143a84:	0a00001c 	beq	143afc <__stdio_write+0xf8>
  143a88:	e1a00009 	mov	r0, r9
  143a8c:	e1a02007 	mov	r2, r7
  143a90:	e1a01004 	mov	r1, r4
  143a94:	e12fff33 	blx	r3
  143a98:	ebffe2f9 	bl	13c684 <__syscall_ret>
  143a9c:	e1500005 	cmp	r0, r5
  143aa0:	1affffe5 	bne	143a3c <__stdio_write+0x38>
  143aa4:	e1a00008 	mov	r0, r8
  143aa8:	e596202c 	ldr	r2, [r6, #44]	; 0x2c
  143aac:	e5963030 	ldr	r3, [r6, #48]	; 0x30
  143ab0:	e586201c 	str	r2, [r6, #28]
  143ab4:	e0823003 	add	r3, r2, r3
  143ab8:	e5862014 	str	r2, [r6, #20]
  143abc:	e5863010 	str	r3, [r6, #16]
  143ac0:	e28dd014 	add	sp, sp, #20
  143ac4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  143ac8:	e3a00000 	mov	r0, #0
  143acc:	e5963000 	ldr	r3, [r6]
  143ad0:	e3570002 	cmp	r7, #2
  143ad4:	e3833020 	orr	r3, r3, #32
  143ad8:	e5863000 	str	r3, [r6]
  143adc:	e5860010 	str	r0, [r6, #16]
  143ae0:	e586001c 	str	r0, [r6, #28]
  143ae4:	e5860014 	str	r0, [r6, #20]
  143ae8:	0afffff4 	beq	143ac0 <__stdio_write+0xbc>
  143aec:	e5940004 	ldr	r0, [r4, #4]
  143af0:	e0480000 	sub	r0, r8, r0
  143af4:	e28dd014 	add	sp, sp, #20
  143af8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  143afc:	e1a00003 	mov	r0, r3
  143b00:	eaffffe4 	b	143a98 <__stdio_write+0x94>

00143b04 <__stdout_write>:
  143b04:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  143b08:	e1a04000 	mov	r4, r0
  143b0c:	e5900000 	ldr	r0, [r0]
  143b10:	e59f3060 	ldr	r3, [pc, #96]	; 143b78 <__stdout_write+0x74>
  143b14:	e3100040 	tst	r0, #64	; 0x40
  143b18:	e24dd00c 	sub	sp, sp, #12
  143b1c:	e1a05001 	mov	r5, r1
  143b20:	e1a06002 	mov	r6, r2
  143b24:	e5843024 	str	r3, [r4, #36]	; 0x24
  143b28:	0a000005 	beq	143b44 <__stdout_write+0x40>
  143b2c:	e1a02006 	mov	r2, r6
  143b30:	e1a01005 	mov	r1, r5
  143b34:	e1a00004 	mov	r0, r4
  143b38:	ebffffb1 	bl	143a04 <__stdio_write>
  143b3c:	e28dd00c 	add	sp, sp, #12
  143b40:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  143b44:	e3a00036 	mov	r0, #54	; 0x36
  143b48:	e594703c 	ldr	r7, [r4, #60]	; 0x3c
  143b4c:	ebffe297 	bl	13c5b0 <get_rtt_syscall>
  143b50:	e2503000 	subs	r3, r0, #0
  143b54:	0afffff4 	beq	143b2c <__stdout_write+0x28>
  143b58:	e1a0200d 	mov	r2, sp
  143b5c:	e1a00007 	mov	r0, r7
  143b60:	e59f1014 	ldr	r1, [pc, #20]	; 143b7c <__stdout_write+0x78>
  143b64:	e12fff33 	blx	r3
  143b68:	e3500000 	cmp	r0, #0
  143b6c:	13e03000 	mvnne	r3, #0
  143b70:	15843050 	strne	r3, [r4, #80]	; 0x50
  143b74:	eaffffec 	b	143b2c <__stdout_write+0x28>
  143b78:	00143a04 	.word	0x00143a04
  143b7c:	00005413 	.word	0x00005413

00143b80 <__towrite>:
  143b80:	e1a03000 	mov	r3, r0
  143b84:	e5901048 	ldr	r1, [r0, #72]	; 0x48
  143b88:	e5900000 	ldr	r0, [r0]
  143b8c:	e2412001 	sub	r2, r1, #1
  143b90:	e1822001 	orr	r2, r2, r1
  143b94:	e2101008 	ands	r1, r0, #8
  143b98:	e5832048 	str	r2, [r3, #72]	; 0x48
  143b9c:	1a000009 	bne	143bc8 <__towrite+0x48>
  143ba0:	e593c02c 	ldr	ip, [r3, #44]	; 0x2c
  143ba4:	e5932030 	ldr	r2, [r3, #48]	; 0x30
  143ba8:	e1a00001 	mov	r0, r1
  143bac:	e08c2002 	add	r2, ip, r2
  143bb0:	e5831008 	str	r1, [r3, #8]
  143bb4:	e5831004 	str	r1, [r3, #4]
  143bb8:	e583c01c 	str	ip, [r3, #28]
  143bbc:	e583c014 	str	ip, [r3, #20]
  143bc0:	e5832010 	str	r2, [r3, #16]
  143bc4:	e12fff1e 	bx	lr
  143bc8:	e3800020 	orr	r0, r0, #32
  143bcc:	e5830000 	str	r0, [r3]
  143bd0:	e3e00000 	mvn	r0, #0
  143bd4:	e12fff1e 	bx	lr

00143bd8 <__towrite_needs_stdio_exit>:
  143bd8:	ea000336 	b	1448b8 <__stdio_exit>

00143bdc <locking_putc>:
  143bdc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  143be0:	e1a05001 	mov	r5, r1
  143be4:	e1a04000 	mov	r4, r0
  143be8:	e59f7110 	ldr	r7, [pc, #272]	; 143d00 <locking_putc+0x124>
  143bec:	e281604c 	add	r6, r1, #76	; 0x4c
  143bf0:	ea000002 	b	143c00 <locking_putc+0x24>
  143bf4:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
  143bf8:	e3530000 	cmp	r3, #0
  143bfc:	1a000021 	bne	143c88 <locking_putc+0xac>
  143c00:	e3a00000 	mov	r0, #0
  143c04:	e3e01103 	mvn	r1, #-1073741824	; 0xc0000000
  143c08:	e1a02006 	mov	r2, r6
  143c0c:	e5973000 	ldr	r3, [r7]
  143c10:	e12fff33 	blx	r3
  143c14:	e3500000 	cmp	r0, #0
  143c18:	1afffff5 	bne	143bf4 <locking_putc+0x18>
  143c1c:	e5953050 	ldr	r3, [r5, #80]	; 0x50
  143c20:	e20480ff 	and	r8, r4, #255	; 0xff
  143c24:	e1530008 	cmp	r3, r8
  143c28:	0a00001c 	beq	143ca0 <locking_putc+0xc4>
  143c2c:	e5953014 	ldr	r3, [r5, #20]
  143c30:	e5952010 	ldr	r2, [r5, #16]
  143c34:	e1530002 	cmp	r3, r2
  143c38:	0a000018 	beq	143ca0 <locking_putc+0xc4>
  143c3c:	e2832001 	add	r2, r3, #1
  143c40:	e5852014 	str	r2, [r5, #20]
  143c44:	e5c34000 	strb	r4, [r3]
  143c48:	e595404c 	ldr	r4, [r5, #76]	; 0x4c
  143c4c:	ea000002 	b	143c5c <locking_putc+0x80>
  143c50:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
  143c54:	e1540003 	cmp	r4, r3
  143c58:	1afffffa 	bne	143c48 <locking_putc+0x6c>
  143c5c:	e1a00004 	mov	r0, r4
  143c60:	e3a01000 	mov	r1, #0
  143c64:	e1a02006 	mov	r2, r6
  143c68:	e5973000 	ldr	r3, [r7]
  143c6c:	e12fff33 	blx	r3
  143c70:	e1500001 	cmp	r0, r1
  143c74:	1afffff5 	bne	143c50 <locking_putc+0x74>
  143c78:	e3140101 	tst	r4, #1073741824	; 0x40000000
  143c7c:	1a00000c 	bne	143cb4 <locking_putc+0xd8>
  143c80:	e1a00008 	mov	r0, r8
  143c84:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  143c88:	e1a00005 	mov	r0, r5
  143c8c:	ebfffe9d 	bl	143708 <__lockfile>
  143c90:	e5953050 	ldr	r3, [r5, #80]	; 0x50
  143c94:	e20480ff 	and	r8, r4, #255	; 0xff
  143c98:	e1530008 	cmp	r3, r8
  143c9c:	1affffe2 	bne	143c2c <locking_putc+0x50>
  143ca0:	e1a01008 	mov	r1, r8
  143ca4:	e1a00005 	mov	r0, r5
  143ca8:	ebffff09 	bl	1438d4 <__overflow>
  143cac:	e1a08000 	mov	r8, r0
  143cb0:	eaffffe4 	b	143c48 <locking_putc+0x6c>
  143cb4:	e3a000f0 	mov	r0, #240	; 0xf0
  143cb8:	ebffe23c 	bl	13c5b0 <get_rtt_syscall>
  143cbc:	e2503000 	subs	r3, r0, #0
  143cc0:	0affffee 	beq	143c80 <locking_putc+0xa4>
  143cc4:	e3a02001 	mov	r2, #1
  143cc8:	e3a01081 	mov	r1, #129	; 0x81
  143ccc:	e1a00006 	mov	r0, r6
  143cd0:	e12fff33 	blx	r3
  143cd4:	e3700026 	cmn	r0, #38	; 0x26
  143cd8:	1affffe8 	bne	143c80 <locking_putc+0xa4>
  143cdc:	e3a000f0 	mov	r0, #240	; 0xf0
  143ce0:	ebffe232 	bl	13c5b0 <get_rtt_syscall>
  143ce4:	e2503000 	subs	r3, r0, #0
  143ce8:	0affffe4 	beq	143c80 <locking_putc+0xa4>
  143cec:	e3a02001 	mov	r2, #1
  143cf0:	e1a00006 	mov	r0, r6
  143cf4:	e1a01002 	mov	r1, r2
  143cf8:	e12fff33 	blx	r3
  143cfc:	eaffffdf 	b	143c80 <locking_putc+0xa4>
  143d00:	0014e3d8 	.word	0x0014e3d8

00143d04 <fputc>:
  143d04:	e591204c 	ldr	r2, [r1, #76]	; 0x4c
  143d08:	e1a03001 	mov	r3, r1
  143d0c:	e3520000 	cmp	r2, #0
  143d10:	e1a0c000 	mov	ip, r0
  143d14:	ba00001d 	blt	143d90 <fputc+0x8c>
  143d18:	0a000017 	beq	143d7c <fputc+0x78>
  143d1c:	e59f10a8 	ldr	r1, [pc, #168]	; 143dcc <fputc+0xc8>
  143d20:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  143d24:	e5910000 	ldr	r0, [r1]
  143d28:	e12fff30 	blx	r0
  143d2c:	e510105c 	ldr	r1, [r0, #-92]	; 0xffffffa4
  143d30:	e3c22101 	bic	r2, r2, #1073741824	; 0x40000000
  143d34:	e1520001 	cmp	r2, r1
  143d38:	0a000003 	beq	143d4c <fputc+0x48>
  143d3c:	e1a01003 	mov	r1, r3
  143d40:	e1a0000c 	mov	r0, ip
  143d44:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  143d48:	eaffffa3 	b	143bdc <locking_putc>
  143d4c:	e5932050 	ldr	r2, [r3, #80]	; 0x50
  143d50:	e20c00ff 	and	r0, ip, #255	; 0xff
  143d54:	e1500002 	cmp	r0, r2
  143d58:	0a000008 	beq	143d80 <fputc+0x7c>
  143d5c:	e5932014 	ldr	r2, [r3, #20]
  143d60:	e5931010 	ldr	r1, [r3, #16]
  143d64:	e1520001 	cmp	r2, r1
  143d68:	0a000004 	beq	143d80 <fputc+0x7c>
  143d6c:	e2821001 	add	r1, r2, #1
  143d70:	e5831014 	str	r1, [r3, #20]
  143d74:	e5c2c000 	strb	ip, [r2]
  143d78:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  143d7c:	eaffff96 	b	143bdc <locking_putc>
  143d80:	e1a01000 	mov	r1, r0
  143d84:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  143d88:	e1a00003 	mov	r0, r3
  143d8c:	eafffed0 	b	1438d4 <__overflow>
  143d90:	e5912050 	ldr	r2, [r1, #80]	; 0x50
  143d94:	e20000ff 	and	r0, r0, #255	; 0xff
  143d98:	e1500002 	cmp	r0, r2
  143d9c:	0a000007 	beq	143dc0 <fputc+0xbc>
  143da0:	e5912014 	ldr	r2, [r1, #20]
  143da4:	e5911010 	ldr	r1, [r1, #16]
  143da8:	e1520001 	cmp	r2, r1
  143dac:	0a000003 	beq	143dc0 <fputc+0xbc>
  143db0:	e2821001 	add	r1, r2, #1
  143db4:	e5831014 	str	r1, [r3, #20]
  143db8:	e5c2c000 	strb	ip, [r2]
  143dbc:	e12fff1e 	bx	lr
  143dc0:	e1a01000 	mov	r1, r0
  143dc4:	e1a00003 	mov	r0, r3
  143dc8:	eafffec1 	b	1438d4 <__overflow>
  143dcc:	0014e3dc 	.word	0x0014e3dc

00143dd0 <fputs>:
  143dd0:	e92d4070 	push	{r4, r5, r6, lr}
  143dd4:	e1a06001 	mov	r6, r1
  143dd8:	e1a05000 	mov	r5, r0
  143ddc:	ebfff635 	bl	1416b8 <strlen>
  143de0:	e1a03006 	mov	r3, r6
  143de4:	e1a04000 	mov	r4, r0
  143de8:	e1a02000 	mov	r2, r0
  143dec:	e3a01001 	mov	r1, #1
  143df0:	e1a00005 	mov	r0, r5
  143df4:	eb000041 	bl	143f00 <fwrite>
  143df8:	e0500004 	subs	r0, r0, r4
  143dfc:	13e00000 	mvnne	r0, #0
  143e00:	e8bd8070 	pop	{r4, r5, r6, pc}

00143e04 <__fwritex>:
  143e04:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  143e08:	e5924010 	ldr	r4, [r2, #16]
  143e0c:	e1a05002 	mov	r5, r2
  143e10:	e3540000 	cmp	r4, #0
  143e14:	e1a06000 	mov	r6, r0
  143e18:	e1a07001 	mov	r7, r1
  143e1c:	0a000009 	beq	143e48 <__fwritex+0x44>
  143e20:	e5950014 	ldr	r0, [r5, #20]
  143e24:	e0444000 	sub	r4, r4, r0
  143e28:	e1540007 	cmp	r4, r7
  143e2c:	2a00000b 	bcs	143e60 <__fwritex+0x5c>
  143e30:	e1a02007 	mov	r2, r7
  143e34:	e1a01006 	mov	r1, r6
  143e38:	e5953024 	ldr	r3, [r5, #36]	; 0x24
  143e3c:	e1a00005 	mov	r0, r5
  143e40:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  143e44:	e12fff13 	bx	r3
  143e48:	e1a00002 	mov	r0, r2
  143e4c:	ebffff4b 	bl	143b80 <__towrite>
  143e50:	e3500000 	cmp	r0, #0
  143e54:	1a000027 	bne	143ef8 <__fwritex+0xf4>
  143e58:	e5954010 	ldr	r4, [r5, #16]
  143e5c:	eaffffef 	b	143e20 <__fwritex+0x1c>
  143e60:	e5953050 	ldr	r3, [r5, #80]	; 0x50
  143e64:	e3530000 	cmp	r3, #0
  143e68:	ba00000d 	blt	143ea4 <__fwritex+0xa0>
  143e6c:	e3570000 	cmp	r7, #0
  143e70:	0a00000b 	beq	143ea4 <__fwritex+0xa0>
  143e74:	e2473001 	sub	r3, r7, #1
  143e78:	e7d62003 	ldrb	r2, [r6, r3]
  143e7c:	e0863003 	add	r3, r6, r3
  143e80:	e352000a 	cmp	r2, #10
  143e84:	1a000003 	bne	143e98 <__fwritex+0x94>
  143e88:	ea00000e 	b	143ec8 <__fwritex+0xc4>
  143e8c:	e5732001 	ldrb	r2, [r3, #-1]!
  143e90:	e352000a 	cmp	r2, #10
  143e94:	0a00000c 	beq	143ecc <__fwritex+0xc8>
  143e98:	e1530006 	cmp	r3, r6
  143e9c:	e0434006 	sub	r4, r3, r6
  143ea0:	1afffff9 	bne	143e8c <__fwritex+0x88>
  143ea4:	e1a04007 	mov	r4, r7
  143ea8:	e1a02004 	mov	r2, r4
  143eac:	e1a01006 	mov	r1, r6
  143eb0:	ebfff437 	bl	140f94 <memcpy>
  143eb4:	e5953014 	ldr	r3, [r5, #20]
  143eb8:	e1a00007 	mov	r0, r7
  143ebc:	e0834004 	add	r4, r3, r4
  143ec0:	e5854014 	str	r4, [r5, #20]
  143ec4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  143ec8:	e1a04007 	mov	r4, r7
  143ecc:	e5953024 	ldr	r3, [r5, #36]	; 0x24
  143ed0:	e1a02004 	mov	r2, r4
  143ed4:	e1a01006 	mov	r1, r6
  143ed8:	e1a00005 	mov	r0, r5
  143edc:	e12fff33 	blx	r3
  143ee0:	e1500004 	cmp	r0, r4
  143ee4:	38bd81f0 	popcc	{r4, r5, r6, r7, r8, pc}
  143ee8:	e0866004 	add	r6, r6, r4
  143eec:	e5950014 	ldr	r0, [r5, #20]
  143ef0:	e0474004 	sub	r4, r7, r4
  143ef4:	eaffffeb 	b	143ea8 <__fwritex+0xa4>
  143ef8:	e1a00004 	mov	r0, r4
  143efc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00143f00 <fwrite>:
  143f00:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  143f04:	e1a05003 	mov	r5, r3
  143f08:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
  143f0c:	e3510000 	cmp	r1, #0
  143f10:	e1a04002 	mov	r4, r2
  143f14:	11a04002 	movne	r4, r2
  143f18:	03a04000 	moveq	r4, #0
  143f1c:	e3530000 	cmp	r3, #0
  143f20:	e1a06001 	mov	r6, r1
  143f24:	e0070192 	mul	r7, r2, r1
  143f28:	aa000009 	bge	143f54 <fwrite+0x54>
  143f2c:	e1a02005 	mov	r2, r5
  143f30:	e1a01007 	mov	r1, r7
  143f34:	ebffffb2 	bl	143e04 <__fwritex>
  143f38:	e1a08000 	mov	r8, r0
  143f3c:	e1570008 	cmp	r7, r8
  143f40:	0a000012 	beq	143f90 <fwrite+0x90>
  143f44:	e1a01006 	mov	r1, r6
  143f48:	e1a00008 	mov	r0, r8
  143f4c:	ebffd2c8 	bl	138a74 <__udivsi3>
  143f50:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  143f54:	e1a08000 	mov	r8, r0
  143f58:	e1a00005 	mov	r0, r5
  143f5c:	ebfffde9 	bl	143708 <__lockfile>
  143f60:	e1a02005 	mov	r2, r5
  143f64:	e1a09000 	mov	r9, r0
  143f68:	e1a01007 	mov	r1, r7
  143f6c:	e1a00008 	mov	r0, r8
  143f70:	ebffffa3 	bl	143e04 <__fwritex>
  143f74:	e3590000 	cmp	r9, #0
  143f78:	e1a08000 	mov	r8, r0
  143f7c:	0affffee 	beq	143f3c <fwrite+0x3c>
  143f80:	e1a00005 	mov	r0, r5
  143f84:	ebfffe2c 	bl	14383c <__unlockfile>
  143f88:	e1570008 	cmp	r7, r8
  143f8c:	1affffec 	bne	143f44 <fwrite+0x44>
  143f90:	e1a00004 	mov	r0, r4
  143f94:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

00143f98 <memchr>:
  143f98:	e3100003 	tst	r0, #3
  143f9c:	e20110ff 	and	r1, r1, #255	; 0xff
  143fa0:	0a000010 	beq	143fe8 <memchr+0x50>
  143fa4:	e3520000 	cmp	r2, #0
  143fa8:	0a000031 	beq	144074 <memchr+0xdc>
  143fac:	e5d03000 	ldrb	r3, [r0]
  143fb0:	e1530001 	cmp	r3, r1
  143fb4:	0a00003e 	beq	1440b4 <memchr+0x11c>
  143fb8:	e2803001 	add	r3, r0, #1
  143fbc:	ea000005 	b	143fd8 <memchr+0x40>
  143fc0:	e3520000 	cmp	r2, #0
  143fc4:	0a00002a 	beq	144074 <memchr+0xdc>
  143fc8:	e5d3c000 	ldrb	ip, [r3]
  143fcc:	e2833001 	add	r3, r3, #1
  143fd0:	e15c0001 	cmp	ip, r1
  143fd4:	0a000036 	beq	1440b4 <memchr+0x11c>
  143fd8:	e3130003 	tst	r3, #3
  143fdc:	e2422001 	sub	r2, r2, #1
  143fe0:	e1a00003 	mov	r0, r3
  143fe4:	1afffff5 	bne	143fc0 <memchr+0x28>
  143fe8:	e3520000 	cmp	r2, #0
  143fec:	0a000020 	beq	144074 <memchr+0xdc>
  143ff0:	e5d03000 	ldrb	r3, [r0]
  143ff4:	e1530001 	cmp	r3, r1
  143ff8:	0a00002d 	beq	1440b4 <memchr+0x11c>
  143ffc:	e92d4070 	push	{r4, r5, r6, lr}
  144000:	e3520003 	cmp	r2, #3
  144004:	e0814401 	add	r4, r1, r1, lsl #8
  144008:	e0844804 	add	r4, r4, r4, lsl #16
  14400c:	9a00001d 	bls	144088 <memchr+0xf0>
  144010:	e5903000 	ldr	r3, [r0]
  144014:	e59f60cc 	ldr	r6, [pc, #204]	; 1440e8 <memchr+0x150>
  144018:	e0233004 	eor	r3, r3, r4
  14401c:	e083c006 	add	ip, r3, r6
  144020:	e59f50c4 	ldr	r5, [pc, #196]	; 1440ec <memchr+0x154>
  144024:	e1cc3003 	bic	r3, ip, r3
  144028:	e1130005 	tst	r3, r5
  14402c:	1a000015 	bne	144088 <memchr+0xf0>
  144030:	e280e004 	add	lr, r0, #4
  144034:	ea000006 	b	144054 <memchr+0xbc>
  144038:	e59e3000 	ldr	r3, [lr]
  14403c:	e28ee004 	add	lr, lr, #4
  144040:	e0233004 	eor	r3, r3, r4
  144044:	e083c006 	add	ip, r3, r6
  144048:	e1cc3003 	bic	r3, ip, r3
  14404c:	e1130005 	tst	r3, r5
  144050:	1a000009 	bne	14407c <memchr+0xe4>
  144054:	e2422004 	sub	r2, r2, #4
  144058:	e3520003 	cmp	r2, #3
  14405c:	e1a0000e 	mov	r0, lr
  144060:	8afffff4 	bhi	144038 <memchr+0xa0>
  144064:	e3520000 	cmp	r2, #0
  144068:	1a000003 	bne	14407c <memchr+0xe4>
  14406c:	e3a00000 	mov	r0, #0
  144070:	e8bd8070 	pop	{r4, r5, r6, pc}
  144074:	e3a00000 	mov	r0, #0
  144078:	e12fff1e 	bx	lr
  14407c:	e5d03000 	ldrb	r3, [r0]
  144080:	e1510003 	cmp	r1, r3
  144084:	08bd8070 	popeq	{r4, r5, r6, pc}
  144088:	e0802002 	add	r2, r0, r2
  14408c:	e2803001 	add	r3, r0, #1
  144090:	ea000003 	b	1440a4 <memchr+0x10c>
  144094:	e5d3c000 	ldrb	ip, [r3]
  144098:	e2833001 	add	r3, r3, #1
  14409c:	e15c0001 	cmp	ip, r1
  1440a0:	08bd8070 	popeq	{r4, r5, r6, pc}
  1440a4:	e1520003 	cmp	r2, r3
  1440a8:	e1a00003 	mov	r0, r3
  1440ac:	1afffff8 	bne	144094 <memchr+0xfc>
  1440b0:	eaffffed 	b	14406c <memchr+0xd4>
  1440b4:	e5d03000 	ldrb	r3, [r0]
  1440b8:	e1510003 	cmp	r1, r3
  1440bc:	012fff1e 	bxeq	lr
  1440c0:	e0802002 	add	r2, r0, r2
  1440c4:	e2803001 	add	r3, r0, #1
  1440c8:	e1520003 	cmp	r2, r3
  1440cc:	e1a00003 	mov	r0, r3
  1440d0:	0affffe7 	beq	144074 <memchr+0xdc>
  1440d4:	e5d3c000 	ldrb	ip, [r3]
  1440d8:	e2833001 	add	r3, r3, #1
  1440dc:	e15c0001 	cmp	ip, r1
  1440e0:	1afffff8 	bne	1440c8 <memchr+0x130>
  1440e4:	e12fff1e 	bx	lr
  1440e8:	fefefeff 	.word	0xfefefeff
  1440ec:	80808080 	.word	0x80808080

001440f0 <__stpcpy>:
  1440f0:	e0203001 	eor	r3, r0, r1
  1440f4:	e3130003 	tst	r3, #3
  1440f8:	e92d4010 	push	{r4, lr}
  1440fc:	1a00001f 	bne	144180 <__stpcpy+0x90>
  144100:	e3110003 	tst	r1, #3
  144104:	0a00000e 	beq	144144 <__stpcpy+0x54>
  144108:	e5d13000 	ldrb	r3, [r1]
  14410c:	e3530000 	cmp	r3, #0
  144110:	e5c03000 	strb	r3, [r0]
  144114:	08bd8010 	popeq	{r4, pc}
  144118:	e2813001 	add	r3, r1, #1
  14411c:	e2802001 	add	r2, r0, #1
  144120:	ea000003 	b	144134 <__stpcpy+0x44>
  144124:	e4d31001 	ldrb	r1, [r3], #1
  144128:	e3510000 	cmp	r1, #0
  14412c:	e4c21001 	strb	r1, [r2], #1
  144130:	08bd8010 	popeq	{r4, pc}
  144134:	e3130003 	tst	r3, #3
  144138:	e1a01003 	mov	r1, r3
  14413c:	e1a00002 	mov	r0, r2
  144140:	1afffff7 	bne	144124 <__stpcpy+0x34>
  144144:	e5913000 	ldr	r3, [r1]
  144148:	e59f405c 	ldr	r4, [pc, #92]	; 1441ac <__stpcpy+0xbc>
  14414c:	e59fe05c 	ldr	lr, [pc, #92]	; 1441b0 <__stpcpy+0xc0>
  144150:	e0832004 	add	r2, r3, r4
  144154:	e1c22003 	bic	r2, r2, r3
  144158:	e112000e 	tst	r2, lr
  14415c:	1a000007 	bne	144180 <__stpcpy+0x90>
  144160:	e281c004 	add	ip, r1, #4
  144164:	e4803004 	str	r3, [r0], #4
  144168:	e1a0100c 	mov	r1, ip
  14416c:	e49c3004 	ldr	r3, [ip], #4
  144170:	e0832004 	add	r2, r3, r4
  144174:	e1c22003 	bic	r2, r2, r3
  144178:	e112000e 	tst	r2, lr
  14417c:	0afffff8 	beq	144164 <__stpcpy+0x74>
  144180:	e5d13000 	ldrb	r3, [r1]
  144184:	e3530000 	cmp	r3, #0
  144188:	e5c03000 	strb	r3, [r0]
  14418c:	08bd8010 	popeq	{r4, pc}
  144190:	e2803001 	add	r3, r0, #1
  144194:	e5f12001 	ldrb	r2, [r1, #1]!
  144198:	e1a00003 	mov	r0, r3
  14419c:	e3520000 	cmp	r2, #0
  1441a0:	e4c32001 	strb	r2, [r3], #1
  1441a4:	1afffffa 	bne	144194 <__stpcpy+0xa4>
  1441a8:	e8bd8010 	pop	{r4, pc}
  1441ac:	fefefeff 	.word	0xfefefeff
  1441b0:	80808080 	.word	0x80808080

001441b4 <__stpncpy>:
  1441b4:	e0203001 	eor	r3, r0, r1
  1441b8:	e3130003 	tst	r3, #3
  1441bc:	e92d4070 	push	{r4, r5, r6, lr}
  1441c0:	1a000030 	bne	144288 <__stpncpy+0xd4>
  1441c4:	e3110003 	tst	r1, #3
  1441c8:	0a000044 	beq	1442e0 <__stpncpy+0x12c>
  1441cc:	e3520000 	cmp	r2, #0
  1441d0:	0a000040 	beq	1442d8 <__stpncpy+0x124>
  1441d4:	e5d13000 	ldrb	r3, [r1]
  1441d8:	e3530000 	cmp	r3, #0
  1441dc:	e5c03000 	strb	r3, [r0]
  1441e0:	0a00003c 	beq	1442d8 <__stpncpy+0x124>
  1441e4:	e2813001 	add	r3, r1, #1
  1441e8:	e2800001 	add	r0, r0, #1
  1441ec:	ea000005 	b	144208 <__stpncpy+0x54>
  1441f0:	e3520000 	cmp	r2, #0
  1441f4:	0a000032 	beq	1442c4 <__stpncpy+0x110>
  1441f8:	e4d31001 	ldrb	r1, [r3], #1
  1441fc:	e3510000 	cmp	r1, #0
  144200:	e4c01001 	strb	r1, [r0], #1
  144204:	0a00002e 	beq	1442c4 <__stpncpy+0x110>
  144208:	e3130003 	tst	r3, #3
  14420c:	e2422001 	sub	r2, r2, #1
  144210:	e1a01003 	mov	r1, r3
  144214:	e1a04000 	mov	r4, r0
  144218:	1afffff4 	bne	1441f0 <__stpncpy+0x3c>
  14421c:	e3520000 	cmp	r2, #0
  144220:	0a000027 	beq	1442c4 <__stpncpy+0x110>
  144224:	e5d1c000 	ldrb	ip, [r1]
  144228:	e35c0000 	cmp	ip, #0
  14422c:	0a000024 	beq	1442c4 <__stpncpy+0x110>
  144230:	e3520003 	cmp	r2, #3
  144234:	9a00002b 	bls	1442e8 <__stpncpy+0x134>
  144238:	e5913000 	ldr	r3, [r1]
  14423c:	e59f60b0 	ldr	r6, [pc, #176]	; 1442f4 <__stpncpy+0x140>
  144240:	e59f50b0 	ldr	r5, [pc, #176]	; 1442f8 <__stpncpy+0x144>
  144244:	e0830006 	add	r0, r3, r6
  144248:	e1c00003 	bic	r0, r0, r3
  14424c:	e1100005 	tst	r0, r5
  144250:	1a000024 	bne	1442e8 <__stpncpy+0x134>
  144254:	e281e004 	add	lr, r1, #4
  144258:	ea000004 	b	144270 <__stpncpy+0xbc>
  14425c:	e49e3004 	ldr	r3, [lr], #4
  144260:	e083c006 	add	ip, r3, r6
  144264:	e1ccc003 	bic	ip, ip, r3
  144268:	e11c0005 	tst	ip, r5
  14426c:	1a000007 	bne	144290 <__stpncpy+0xdc>
  144270:	e2422004 	sub	r2, r2, #4
  144274:	e4843004 	str	r3, [r4], #4
  144278:	e3520003 	cmp	r2, #3
  14427c:	e1a00004 	mov	r0, r4
  144280:	e1a0100e 	mov	r1, lr
  144284:	8afffff4 	bhi	14425c <__stpncpy+0xa8>
  144288:	e3520000 	cmp	r2, #0
  14428c:	0a000011 	beq	1442d8 <__stpncpy+0x124>
  144290:	e5d13000 	ldrb	r3, [r1]
  144294:	e3530000 	cmp	r3, #0
  144298:	e5c03000 	strb	r3, [r0]
  14429c:	0a00000d 	beq	1442d8 <__stpncpy+0x124>
  1442a0:	e2800001 	add	r0, r0, #1
  1442a4:	ea000003 	b	1442b8 <__stpncpy+0x104>
  1442a8:	e5f13001 	ldrb	r3, [r1, #1]!
  1442ac:	e3530000 	cmp	r3, #0
  1442b0:	e4c03001 	strb	r3, [r0], #1
  1442b4:	0a000002 	beq	1442c4 <__stpncpy+0x110>
  1442b8:	e2522001 	subs	r2, r2, #1
  1442bc:	e1a04000 	mov	r4, r0
  1442c0:	1afffff8 	bne	1442a8 <__stpncpy+0xf4>
  1442c4:	e3a01000 	mov	r1, #0
  1442c8:	e1a00004 	mov	r0, r4
  1442cc:	ebfff468 	bl	141474 <memset>
  1442d0:	e1a00004 	mov	r0, r4
  1442d4:	e8bd8070 	pop	{r4, r5, r6, pc}
  1442d8:	e1a04000 	mov	r4, r0
  1442dc:	eafffff8 	b	1442c4 <__stpncpy+0x110>
  1442e0:	e1a04000 	mov	r4, r0
  1442e4:	eaffffcc 	b	14421c <__stpncpy+0x68>
  1442e8:	e5c4c000 	strb	ip, [r4]
  1442ec:	e1a00004 	mov	r0, r4
  1442f0:	eaffffea 	b	1442a0 <__stpncpy+0xec>
  1442f4:	fefefeff 	.word	0xfefefeff
  1442f8:	80808080 	.word	0x80808080

001442fc <strchr>:
  1442fc:	e92d4010 	push	{r4, lr}
  144300:	e1a04001 	mov	r4, r1
  144304:	eb000004 	bl	14431c <__strchrnul>
  144308:	e5d03000 	ldrb	r3, [r0]
  14430c:	e20440ff 	and	r4, r4, #255	; 0xff
  144310:	e1540003 	cmp	r4, r3
  144314:	13a00000 	movne	r0, #0
  144318:	e8bd8010 	pop	{r4, pc}

0014431c <__strchrnul>:
  14431c:	e20110ff 	and	r1, r1, #255	; 0xff
  144320:	e3510000 	cmp	r1, #0
  144324:	e92d4070 	push	{r4, r5, r6, lr}
  144328:	e1a04000 	mov	r4, r0
  14432c:	0a000031 	beq	1443f8 <__strchrnul+0xdc>
  144330:	e3100003 	tst	r0, #3
  144334:	0a00000e 	beq	144374 <__strchrnul+0x58>
  144338:	e5d02000 	ldrb	r2, [r0]
  14433c:	e3520000 	cmp	r2, #0
  144340:	0a00002f 	beq	144404 <__strchrnul+0xe8>
  144344:	e1510002 	cmp	r1, r2
  144348:	0a00002d 	beq	144404 <__strchrnul+0xe8>
  14434c:	e2803001 	add	r3, r0, #1
  144350:	ea000004 	b	144368 <__strchrnul+0x4c>
  144354:	e4d32001 	ldrb	r2, [r3], #1
  144358:	e3520000 	cmp	r2, #0
  14435c:	08bd8070 	popeq	{r4, r5, r6, pc}
  144360:	e1520001 	cmp	r2, r1
  144364:	08bd8070 	popeq	{r4, r5, r6, pc}
  144368:	e3130003 	tst	r3, #3
  14436c:	e1a00003 	mov	r0, r3
  144370:	1afffff7 	bne	144354 <__strchrnul+0x38>
  144374:	e590c000 	ldr	ip, [r0]
  144378:	e0815401 	add	r5, r1, r1, lsl #8
  14437c:	e59f4088 	ldr	r4, [pc, #136]	; 14440c <__strchrnul+0xf0>
  144380:	e0855805 	add	r5, r5, r5, lsl #16
  144384:	e025e00c 	eor	lr, r5, ip
  144388:	e08e2004 	add	r2, lr, r4
  14438c:	e08c3004 	add	r3, ip, r4
  144390:	e1c2200e 	bic	r2, r2, lr
  144394:	e1c3300c 	bic	r3, r3, ip
  144398:	e59f6070 	ldr	r6, [pc, #112]	; 144410 <__strchrnul+0xf4>
  14439c:	e1833002 	orr	r3, r3, r2
  1443a0:	e1130006 	tst	r3, r6
  1443a4:	1a000008 	bne	1443cc <__strchrnul+0xb0>
  1443a8:	e5b0c004 	ldr	ip, [r0, #4]!
  1443ac:	e02ce005 	eor	lr, ip, r5
  1443b0:	e08e2004 	add	r2, lr, r4
  1443b4:	e08c3004 	add	r3, ip, r4
  1443b8:	e1c2200e 	bic	r2, r2, lr
  1443bc:	e1c3300c 	bic	r3, r3, ip
  1443c0:	e1833002 	orr	r3, r3, r2
  1443c4:	e1130006 	tst	r3, r6
  1443c8:	0afffff6 	beq	1443a8 <__strchrnul+0x8c>
  1443cc:	e5d03000 	ldrb	r3, [r0]
  1443d0:	e3530000 	cmp	r3, #0
  1443d4:	08bd8070 	popeq	{r4, r5, r6, pc}
  1443d8:	e1510003 	cmp	r1, r3
  1443dc:	08bd8070 	popeq	{r4, r5, r6, pc}
  1443e0:	e5f03001 	ldrb	r3, [r0, #1]!
  1443e4:	e3530000 	cmp	r3, #0
  1443e8:	08bd8070 	popeq	{r4, r5, r6, pc}
  1443ec:	e1530001 	cmp	r3, r1
  1443f0:	1afffffa 	bne	1443e0 <__strchrnul+0xc4>
  1443f4:	e8bd8070 	pop	{r4, r5, r6, pc}
  1443f8:	ebfff4ae 	bl	1416b8 <strlen>
  1443fc:	e0840000 	add	r0, r4, r0
  144400:	e8bd8070 	pop	{r4, r5, r6, pc}
  144404:	e1a00004 	mov	r0, r4
  144408:	e8bd8070 	pop	{r4, r5, r6, pc}
  14440c:	fefefeff 	.word	0xfefefeff
  144410:	80808080 	.word	0x80808080

00144414 <__set_thread_area>:
  144414:	e59f3108 	ldr	r3, [pc, #264]	; 144524 <__set_thread_area+0x110>
  144418:	e92d4010 	push	{r4, lr}
  14441c:	e5933000 	ldr	r3, [r3]
  144420:	e1a04000 	mov	r4, r0
  144424:	e3130902 	tst	r3, #32768	; 0x8000
  144428:	0a000017 	beq	14448c <__set_thread_area+0x78>
  14442c:	e59f20f4 	ldr	r2, [pc, #244]	; 144528 <__set_thread_area+0x114>
  144430:	e59f10f4 	ldr	r1, [pc, #244]	; 14452c <__set_thread_area+0x118>
  144434:	e59f00f4 	ldr	r0, [pc, #244]	; 144530 <__set_thread_area+0x11c>
  144438:	e59fc0f4 	ldr	ip, [pc, #244]	; 144534 <__set_thread_area+0x120>
  14443c:	e59f30f4 	ldr	r3, [pc, #244]	; 144538 <__set_thread_area+0x124>
  144440:	e5922010 	ldr	r2, [r2, #16]
  144444:	e580c000 	str	ip, [r0]
  144448:	e5831000 	str	r1, [r3]
  14444c:	e5921000 	ldr	r1, [r2]
  144450:	e3510000 	cmp	r1, #0
  144454:	0a000005 	beq	144470 <__set_thread_area+0x5c>
  144458:	e351000f 	cmp	r1, #15
  14445c:	1a00001b 	bne	1444d0 <__set_thread_area+0xbc>
  144460:	e5922004 	ldr	r2, [r2, #4]
  144464:	e5d21000 	ldrb	r1, [r2]
  144468:	e3510076 	cmp	r1, #118	; 0x76
  14446c:	0a000021 	beq	1444f8 <__set_thread_area+0xe4>
  144470:	e59f00c4 	ldr	r0, [pc, #196]	; 14453c <__set_thread_area+0x128>
  144474:	ebffe04d 	bl	13c5b0 <get_rtt_syscall>
  144478:	e2503000 	subs	r3, r0, #0
  14447c:	08bd8010 	popeq	{r4, pc}
  144480:	e1a00004 	mov	r0, r4
  144484:	e8bd4010 	pop	{r4, lr}
  144488:	e12fff13 	bx	r3
  14448c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
  144490:	e59f10a8 	ldr	r1, [pc, #168]	; 144540 <__set_thread_area+0x12c>
  144494:	e5132003 	ldr	r2, [r3, #-3]
  144498:	e59f30a4 	ldr	r3, [pc, #164]	; 144544 <__set_thread_area+0x130>
  14449c:	e59f008c 	ldr	r0, [pc, #140]	; 144530 <__set_thread_area+0x11c>
  1444a0:	e5831000 	str	r1, [r3]
  1444a4:	e59fc09c 	ldr	ip, [pc, #156]	; 144548 <__set_thread_area+0x134>
  1444a8:	e59f3088 	ldr	r3, [pc, #136]	; 144538 <__set_thread_area+0x124>
  1444ac:	e2411040 	sub	r1, r1, #64	; 0x40
  1444b0:	e3520001 	cmp	r2, #1
  1444b4:	e580c000 	str	ip, [r0]
  1444b8:	e5831000 	str	r1, [r3]
  1444bc:	da000009 	ble	1444e8 <__set_thread_area+0xd4>
  1444c0:	e3520002 	cmp	r2, #2
  1444c4:	059f2080 	ldreq	r2, [pc, #128]	; 14454c <__set_thread_area+0x138>
  1444c8:	05832000 	streq	r2, [r3]
  1444cc:	eaffffe7 	b	144470 <__set_thread_area+0x5c>
  1444d0:	e5b21008 	ldr	r1, [r2, #8]!
  1444d4:	e3510000 	cmp	r1, #0
  1444d8:	0affffe4 	beq	144470 <__set_thread_area+0x5c>
  1444dc:	e351000f 	cmp	r1, #15
  1444e0:	0affffde 	beq	144460 <__set_thread_area+0x4c>
  1444e4:	eafffff9 	b	1444d0 <__set_thread_area+0xbc>
  1444e8:	e7f000f0 	.word	0xe7f000f0
  1444ec:	e59f2058 	ldr	r2, [pc, #88]	; 14454c <__set_thread_area+0x138>
  1444f0:	e5832000 	str	r2, [r3]
  1444f4:	eaffffdd 	b	144470 <__set_thread_area+0x5c>
  1444f8:	e5d21001 	ldrb	r1, [r2, #1]
  1444fc:	e3510036 	cmp	r1, #54	; 0x36
  144500:	1affffda 	bne	144470 <__set_thread_area+0x5c>
  144504:	e5d22002 	ldrb	r2, [r2, #2]
  144508:	e2422030 	sub	r2, r2, #48	; 0x30
  14450c:	e3520009 	cmp	r2, #9
  144510:	859f1038 	ldrhi	r1, [pc, #56]	; 144550 <__set_thread_area+0x13c>
  144514:	859f2038 	ldrhi	r2, [pc, #56]	; 144554 <__set_thread_area+0x140>
  144518:	85801000 	strhi	r1, [r0]
  14451c:	85832000 	strhi	r2, [r3]
  144520:	eaffffd2 	b	144470 <__set_thread_area+0x5c>
  144524:	00576e80 	.word	0x00576e80
  144528:	00576e84 	.word	0x00576e84
  14452c:	001420d0 	.word	0x001420d0
  144530:	0014e3d8 	.word	0x0014e3d8
  144534:	00142110 	.word	0x00142110
  144538:	0014e3d4 	.word	0x0014e3d4
  14453c:	000f0005 	.word	0x000f0005
  144540:	ffff0fe0 	.word	0xffff0fe0
  144544:	0014e3dc 	.word	0x0014e3dc
  144548:	ffff0fc0 	.word	0xffff0fc0
  14454c:	001420a8 	.word	0x001420a8
  144550:	001420ec 	.word	0x001420ec
  144554:	001420c8 	.word	0x001420c8

00144558 <__unmapself>:
  144558:	e3a07036 	mov	r7, #54	; 0x36
  14455c:	ef000000 	svc	0x00000000
  144560:	e3a07001 	mov	r7, #1
  144564:	ef000000 	svc	0x00000000

00144568 <__clone>:
  144568:	e92d00f0 	push	{r4, r5, r6, r7}
  14456c:	e3a07082 	mov	r7, #130	; 0x82
  144570:	e1a06003 	mov	r6, r3
  144574:	e1a05000 	mov	r5, r0
  144578:	e1a00002 	mov	r0, r2
  14457c:	e3c1100f 	bic	r1, r1, #15
  144580:	e59d2010 	ldr	r2, [sp, #16]
  144584:	e59d3014 	ldr	r3, [sp, #20]
  144588:	e59d4018 	ldr	r4, [sp, #24]
  14458c:	e92d007f 	push	{r0, r1, r2, r3, r4, r5, r6}
  144590:	e1a0000d 	mov	r0, sp
  144594:	ef000000 	svc	0x00000000
  144598:	e1100000 	tst	r0, r0
  14459c:	0a000002 	beq	1445ac <__clone+0x44>
  1445a0:	e28dd01c 	add	sp, sp, #28
  1445a4:	e8bd00f0 	pop	{r4, r5, r6, r7}
  1445a8:	e12fff1e 	bx	lr
  1445ac:	e1a00006 	mov	r0, r6
  1445b0:	e3150001 	tst	r5, #1
  1445b4:	1a000003 	bne	1445c8 <__clone+0x60>
  1445b8:	e1a0e00f 	mov	lr, pc
  1445bc:	e1a0f005 	mov	pc, r5
  1445c0:	e3a07001 	mov	r7, #1
  1445c4:	ef000000 	svc	0x00000000
  1445c8:	e1a0e00f 	mov	lr, pc
  1445cc:	e12fff15 	bx	r5
  1445d0:	eafffffa 	b	1445c0 <__clone+0x58>

001445d4 <__clock_gettime>:
  1445d4:	e92d4070 	push	{r4, r5, r6, lr}
  1445d8:	e1a04000 	mov	r4, r0
  1445dc:	e59f0074 	ldr	r0, [pc, #116]	; 144658 <__clock_gettime+0x84>
  1445e0:	e1a05001 	mov	r5, r1
  1445e4:	ebffdff1 	bl	13c5b0 <get_rtt_syscall>
  1445e8:	e2503000 	subs	r3, r0, #0
  1445ec:	0a000017 	beq	144650 <__clock_gettime+0x7c>
  1445f0:	e1a01005 	mov	r1, r5
  1445f4:	e1a00004 	mov	r0, r4
  1445f8:	e12fff33 	blx	r3
  1445fc:	e3700026 	cmn	r0, #38	; 0x26
  144600:	0a000001 	beq	14460c <__clock_gettime+0x38>
  144604:	e8bd4070 	pop	{r4, r5, r6, lr}
  144608:	eaffe01d 	b	13c684 <__syscall_ret>
  14460c:	e3540000 	cmp	r4, #0
  144610:	13e00015 	mvnne	r0, #21
  144614:	1afffffa 	bne	144604 <__clock_gettime+0x30>
  144618:	e3a0004e 	mov	r0, #78	; 0x4e
  14461c:	ebffdfe3 	bl	13c5b0 <get_rtt_syscall>
  144620:	e2503000 	subs	r3, r0, #0
  144624:	0a000002 	beq	144634 <__clock_gettime+0x60>
  144628:	e1a01004 	mov	r1, r4
  14462c:	e1a00005 	mov	r0, r5
  144630:	e12fff33 	blx	r3
  144634:	e5953008 	ldr	r3, [r5, #8]
  144638:	e3a00000 	mov	r0, #0
  14463c:	e0632283 	rsb	r2, r3, r3, lsl #5
  144640:	e0833102 	add	r3, r3, r2, lsl #2
  144644:	e1a03183 	lsl	r3, r3, #3
  144648:	e5853008 	str	r3, [r5, #8]
  14464c:	e8bd8070 	pop	{r4, r5, r6, pc}
  144650:	e1a00003 	mov	r0, r3
  144654:	eaffffea 	b	144604 <__clock_gettime+0x30>
  144658:	00000107 	.word	0x00000107

0014465c <frexp>:
  14465c:	e59fc09c 	ldr	ip, [pc, #156]	; 144700 <frexp+0xa4>
  144660:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  144664:	e01c6a21 	ands	r6, ip, r1, lsr #20
  144668:	e1a04000 	mov	r4, r0
  14466c:	e1a05001 	mov	r5, r1
  144670:	1a000009 	bne	14469c <frexp+0x40>
  144674:	e1a07002 	mov	r7, r2
  144678:	e3a03000 	mov	r3, #0
  14467c:	e3a02000 	mov	r2, #0
  144680:	eb0002e1 	bl	14520c <__aeabi_dcmpeq>
  144684:	e3500000 	cmp	r0, #0
  144688:	0a000011 	beq	1446d4 <frexp+0x78>
  14468c:	e5876000 	str	r6, [r7]
  144690:	e1a00004 	mov	r0, r4
  144694:	e1a01005 	mov	r1, r5
  144698:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  14469c:	e156000c 	cmp	r6, ip
  1446a0:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
  1446a4:	e3e00000 	mvn	r0, #0
  1446a8:	e0007004 	and	r7, r0, r4
  1446ac:	e3a04000 	mov	r4, #0
  1446b0:	e59f104c 	ldr	r1, [pc, #76]	; 144704 <frexp+0xa8>
  1446b4:	e2463fff 	sub	r3, r6, #1020	; 0x3fc
  1446b8:	e0018005 	and	r8, r1, r5
  1446bc:	e59f5044 	ldr	r5, [pc, #68]	; 144708 <frexp+0xac>
  1446c0:	e2433002 	sub	r3, r3, #2
  1446c4:	e5823000 	str	r3, [r2]
  1446c8:	e1870004 	orr	r0, r7, r4
  1446cc:	e1881005 	orr	r1, r8, r5
  1446d0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  1446d4:	e59f3030 	ldr	r3, [pc, #48]	; 14470c <frexp+0xb0>
  1446d8:	e1a00004 	mov	r0, r4
  1446dc:	e1a01005 	mov	r1, r5
  1446e0:	e3a02000 	mov	r2, #0
  1446e4:	eb00017a 	bl	144cd4 <__aeabi_dmul>
  1446e8:	e1a02007 	mov	r2, r7
  1446ec:	ebffffda 	bl	14465c <frexp>
  1446f0:	e5973000 	ldr	r3, [r7]
  1446f4:	e2433040 	sub	r3, r3, #64	; 0x40
  1446f8:	e5873000 	str	r3, [r7]
  1446fc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  144700:	000007ff 	.word	0x000007ff
  144704:	800fffff 	.word	0x800fffff
  144708:	3fe00000 	.word	0x3fe00000
  14470c:	43f00000 	.word	0x43f00000

00144710 <wcrtomb>:
  144710:	e2502000 	subs	r2, r0, #0
  144714:	0a000025 	beq	1447b0 <wcrtomb+0xa0>
  144718:	e351007f 	cmp	r1, #127	; 0x7f
  14471c:	9a000022 	bls	1447ac <wcrtomb+0x9c>
  144720:	e59f0114 	ldr	r0, [pc, #276]	; 14483c <wcrtomb+0x12c>
  144724:	e92d4010 	push	{r4, lr}
  144728:	e5900000 	ldr	r0, [r0]
  14472c:	e12fff30 	blx	r0
  144730:	e5100018 	ldr	r0, [r0, #-24]	; 0xffffffe8
  144734:	e1a03001 	mov	r3, r1
  144738:	e5900000 	ldr	r0, [r0]
  14473c:	e1a0c002 	mov	ip, r2
  144740:	e3500000 	cmp	r0, #0
  144744:	0a000025 	beq	1447e0 <wcrtomb+0xd0>
  144748:	e3510b02 	cmp	r1, #2048	; 0x800
  14474c:	3a00001a 	bcc	1447bc <wcrtomb+0xac>
  144750:	e2412a0e 	sub	r2, r1, #57344	; 0xe000
  144754:	e3510b36 	cmp	r1, #55296	; 0xd800
  144758:	23520a02 	cmpcs	r2, #8192	; 0x2000
  14475c:	3a00002a 	bcc	14480c <wcrtomb+0xfc>
  144760:	e2412801 	sub	r2, r1, #65536	; 0x10000
  144764:	e3520601 	cmp	r2, #1048576	; 0x100000
  144768:	2a000022 	bcs	1447f8 <wcrtomb+0xe8>
  14476c:	e3e0e00f 	mvn	lr, #15
  144770:	e3e0207f 	mvn	r2, #127	; 0x7f
  144774:	e18ee923 	orr	lr, lr, r3, lsr #18
  144778:	e203303f 	and	r3, r3, #63	; 0x3f
  14477c:	e1823003 	orr	r3, r2, r3
  144780:	e5cc3003 	strb	r3, [ip, #3]
  144784:	e3a03004 	mov	r3, #4
  144788:	e1a00701 	lsl	r0, r1, #14
  14478c:	e1a01a01 	lsl	r1, r1, #20
  144790:	e1820d20 	orr	r0, r2, r0, lsr #26
  144794:	e1821d21 	orr	r1, r2, r1, lsr #26
  144798:	e5cce000 	strb	lr, [ip]
  14479c:	e5cc0001 	strb	r0, [ip, #1]
  1447a0:	e5cc1002 	strb	r1, [ip, #2]
  1447a4:	e1a00003 	mov	r0, r3
  1447a8:	e8bd8010 	pop	{r4, pc}
  1447ac:	e5c21000 	strb	r1, [r2]
  1447b0:	e3a03001 	mov	r3, #1
  1447b4:	e1a00003 	mov	r0, r3
  1447b8:	e12fff1e 	bx	lr
  1447bc:	e201203f 	and	r2, r1, #63	; 0x3f
  1447c0:	e1e02c82 	mvn	r2, r2, lsl #25
  1447c4:	e3e0103f 	mvn	r1, #63	; 0x3f
  1447c8:	e1e02ca2 	mvn	r2, r2, lsr #25
  1447cc:	e1813323 	orr	r3, r1, r3, lsr #6
  1447d0:	e5cc3000 	strb	r3, [ip]
  1447d4:	e5cc2001 	strb	r2, [ip, #1]
  1447d8:	e3a03002 	mov	r3, #2
  1447dc:	eafffff0 	b	1447a4 <wcrtomb+0x94>
  1447e0:	e2413cdf 	sub	r3, r1, #57088	; 0xdf00
  1447e4:	e2433080 	sub	r3, r3, #128	; 0x80
  1447e8:	e353007f 	cmp	r3, #127	; 0x7f
  1447ec:	95c21000 	strbls	r1, [r2]
  1447f0:	93a03001 	movls	r3, #1
  1447f4:	9affffea 	bls	1447a4 <wcrtomb+0x94>
  1447f8:	ebffd236 	bl	1390d8 <__errno_location>
  1447fc:	e3a02054 	mov	r2, #84	; 0x54
  144800:	e3e03000 	mvn	r3, #0
  144804:	e5802000 	str	r2, [r0]
  144808:	eaffffe5 	b	1447a4 <wcrtomb+0x94>
  14480c:	e3e0207f 	mvn	r2, #127	; 0x7f
  144810:	e3e0001f 	mvn	r0, #31
  144814:	e203e03f 	and	lr, r3, #63	; 0x3f
  144818:	e1a01a01 	lsl	r1, r1, #20
  14481c:	e1803623 	orr	r3, r0, r3, lsr #12
  144820:	e1821d21 	orr	r1, r2, r1, lsr #26
  144824:	e182200e 	orr	r2, r2, lr
  144828:	e5cc3000 	strb	r3, [ip]
  14482c:	e5cc1001 	strb	r1, [ip, #1]
  144830:	e5cc2002 	strb	r2, [ip, #2]
  144834:	e3a03003 	mov	r3, #3
  144838:	eaffffd9 	b	1447a4 <wcrtomb+0x94>
  14483c:	0014e3dc 	.word	0x0014e3dc

00144840 <close_file>:
  144840:	e92d4010 	push	{r4, lr}
  144844:	e2504000 	subs	r4, r0, #0
  144848:	e24dd008 	sub	sp, sp, #8
  14484c:	0a000015 	beq	1448a8 <close_file+0x68>
  144850:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
  144854:	e3530000 	cmp	r3, #0
  144858:	aa000014 	bge	1448b0 <close_file+0x70>
  14485c:	e5942014 	ldr	r2, [r4, #20]
  144860:	e594301c 	ldr	r3, [r4, #28]
  144864:	e1520003 	cmp	r2, r3
  144868:	0a000004 	beq	144880 <close_file+0x40>
  14486c:	e3a02000 	mov	r2, #0
  144870:	e5943024 	ldr	r3, [r4, #36]	; 0x24
  144874:	e1a01002 	mov	r1, r2
  144878:	e1a00004 	mov	r0, r4
  14487c:	e12fff33 	blx	r3
  144880:	e994000c 	ldmib	r4, {r2, r3}
  144884:	e1520003 	cmp	r2, r3
  144888:	0a000006 	beq	1448a8 <close_file+0x68>
  14488c:	e3a01001 	mov	r1, #1
  144890:	e0422003 	sub	r2, r2, r3
  144894:	e58d1000 	str	r1, [sp]
  144898:	e5941028 	ldr	r1, [r4, #40]	; 0x28
  14489c:	e1a00004 	mov	r0, r4
  1448a0:	e1a03fc2 	asr	r3, r2, #31
  1448a4:	e12fff31 	blx	r1
  1448a8:	e28dd008 	add	sp, sp, #8
  1448ac:	e8bd8010 	pop	{r4, pc}
  1448b0:	ebfffb94 	bl	143708 <__lockfile>
  1448b4:	eaffffe8 	b	14485c <close_file+0x1c>

001448b8 <__stdio_exit>:
  1448b8:	e92d4010 	push	{r4, lr}
  1448bc:	ebffe76a 	bl	13e66c <__ofl_lock>
  1448c0:	e5904000 	ldr	r4, [r0]
  1448c4:	e3540000 	cmp	r4, #0
  1448c8:	0a000004 	beq	1448e0 <__stdio_exit+0x28>
  1448cc:	e1a00004 	mov	r0, r4
  1448d0:	ebffffda 	bl	144840 <close_file>
  1448d4:	e5944038 	ldr	r4, [r4, #56]	; 0x38
  1448d8:	e3540000 	cmp	r4, #0
  1448dc:	1afffffa 	bne	1448cc <__stdio_exit+0x14>
  1448e0:	e59f3020 	ldr	r3, [pc, #32]	; 144908 <__stdio_exit+0x50>
  1448e4:	e5930000 	ldr	r0, [r3]
  1448e8:	ebffffd4 	bl	144840 <close_file>
  1448ec:	e59f3018 	ldr	r3, [pc, #24]	; 14490c <__stdio_exit+0x54>
  1448f0:	e5930000 	ldr	r0, [r3]
  1448f4:	ebffffd1 	bl	144840 <close_file>
  1448f8:	e8bd4010 	pop	{r4, lr}
  1448fc:	e59f300c 	ldr	r3, [pc, #12]	; 144910 <__stdio_exit+0x58>
  144900:	e5930000 	ldr	r0, [r3]
  144904:	eaffffcd 	b	144840 <close_file>
  144908:	00150468 	.word	0x00150468
  14490c:	0014e3d0 	.word	0x0014e3d0
  144910:	0014e338 	.word	0x0014e338

00144914 <__aeabi_drsub>:
  144914:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000
  144918:	ea000000 	b	144920 <__adddf3>

0014491c <__aeabi_dsub>:
  14491c:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000

00144920 <__adddf3>:
  144920:	e92d4030 	push	{r4, r5, lr}
  144924:	e1a04081 	lsl	r4, r1, #1
  144928:	e1a05083 	lsl	r5, r3, #1
  14492c:	e1340005 	teq	r4, r5
  144930:	01300002 	teqeq	r0, r2
  144934:	1194c000 	orrsne	ip, r4, r0
  144938:	1195c002 	orrsne	ip, r5, r2
  14493c:	11f0cac4 	mvnsne	ip, r4, asr #21
  144940:	11f0cac5 	mvnsne	ip, r5, asr #21
  144944:	0a000079 	beq	144b30 <__adddf3+0x210>
  144948:	e1a04aa4 	lsr	r4, r4, #21
  14494c:	e0745aa5 	rsbs	r5, r4, r5, lsr #21
  144950:	b2655000 	rsblt	r5, r5, #0
  144954:	da000006 	ble	144974 <__adddf3+0x54>
  144958:	e0844005 	add	r4, r4, r5
  14495c:	e0202002 	eor	r2, r0, r2
  144960:	e0213003 	eor	r3, r1, r3
  144964:	e0220000 	eor	r0, r2, r0
  144968:	e0231001 	eor	r1, r3, r1
  14496c:	e0202002 	eor	r2, r0, r2
  144970:	e0213003 	eor	r3, r1, r3
  144974:	e3550036 	cmp	r5, #54	; 0x36
  144978:	88bd8030 	pophi	{r4, r5, pc}
  14497c:	e3110102 	tst	r1, #-2147483648	; 0x80000000
  144980:	e1a01601 	lsl	r1, r1, #12
  144984:	e3a0c601 	mov	ip, #1048576	; 0x100000
  144988:	e18c1621 	orr	r1, ip, r1, lsr #12
  14498c:	0a000001 	beq	144998 <__adddf3+0x78>
  144990:	e2700000 	rsbs	r0, r0, #0
  144994:	e2e11000 	rsc	r1, r1, #0
  144998:	e3130102 	tst	r3, #-2147483648	; 0x80000000
  14499c:	e1a03603 	lsl	r3, r3, #12
  1449a0:	e18c3623 	orr	r3, ip, r3, lsr #12
  1449a4:	0a000001 	beq	1449b0 <__adddf3+0x90>
  1449a8:	e2722000 	rsbs	r2, r2, #0
  1449ac:	e2e33000 	rsc	r3, r3, #0
  1449b0:	e1340005 	teq	r4, r5
  1449b4:	0a000057 	beq	144b18 <__adddf3+0x1f8>
  1449b8:	e2444001 	sub	r4, r4, #1
  1449bc:	e275e020 	rsbs	lr, r5, #32
  1449c0:	ba000005 	blt	1449dc <__adddf3+0xbc>
  1449c4:	e1a0ce12 	lsl	ip, r2, lr
  1449c8:	e0900532 	adds	r0, r0, r2, lsr r5
  1449cc:	e2a11000 	adc	r1, r1, #0
  1449d0:	e0900e13 	adds	r0, r0, r3, lsl lr
  1449d4:	e0b11553 	adcs	r1, r1, r3, asr r5
  1449d8:	ea000006 	b	1449f8 <__adddf3+0xd8>
  1449dc:	e2455020 	sub	r5, r5, #32
  1449e0:	e28ee020 	add	lr, lr, #32
  1449e4:	e3520001 	cmp	r2, #1
  1449e8:	e1a0ce13 	lsl	ip, r3, lr
  1449ec:	238cc002 	orrcs	ip, ip, #2
  1449f0:	e0900553 	adds	r0, r0, r3, asr r5
  1449f4:	e0b11fc3 	adcs	r1, r1, r3, asr #31
  1449f8:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
  1449fc:	5a000002 	bpl	144a0c <__adddf3+0xec>
  144a00:	e27cc000 	rsbs	ip, ip, #0
  144a04:	e2f00000 	rscs	r0, r0, #0
  144a08:	e2e11000 	rsc	r1, r1, #0
  144a0c:	e3510601 	cmp	r1, #1048576	; 0x100000
  144a10:	3a00000e 	bcc	144a50 <__adddf3+0x130>
  144a14:	e3510602 	cmp	r1, #2097152	; 0x200000
  144a18:	3a000006 	bcc	144a38 <__adddf3+0x118>
  144a1c:	e1b010a1 	lsrs	r1, r1, #1
  144a20:	e1b00060 	rrxs	r0, r0
  144a24:	e1a0c06c 	rrx	ip, ip
  144a28:	e2844001 	add	r4, r4, #1
  144a2c:	e1a02a84 	lsl	r2, r4, #21
  144a30:	e3720501 	cmn	r2, #4194304	; 0x400000
  144a34:	2a000055 	bcs	144b90 <__adddf3+0x270>
  144a38:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
  144a3c:	01b0c0a0 	lsrseq	ip, r0, #1
  144a40:	e2b00000 	adcs	r0, r0, #0
  144a44:	e0a11a04 	adc	r1, r1, r4, lsl #20
  144a48:	e1811005 	orr	r1, r1, r5
  144a4c:	e8bd8030 	pop	{r4, r5, pc}
  144a50:	e1b0c08c 	lsls	ip, ip, #1
  144a54:	e0b00000 	adcs	r0, r0, r0
  144a58:	e0a11001 	adc	r1, r1, r1
  144a5c:	e3110601 	tst	r1, #1048576	; 0x100000
  144a60:	e2444001 	sub	r4, r4, #1
  144a64:	1afffff3 	bne	144a38 <__adddf3+0x118>
  144a68:	e3310000 	teq	r1, #0
  144a6c:	01a01000 	moveq	r1, r0
  144a70:	03a00000 	moveq	r0, #0
  144a74:	e16f3f11 	clz	r3, r1
  144a78:	02833020 	addeq	r3, r3, #32
  144a7c:	e243300b 	sub	r3, r3, #11
  144a80:	e2532020 	subs	r2, r3, #32
  144a84:	aa000007 	bge	144aa8 <__adddf3+0x188>
  144a88:	e292200c 	adds	r2, r2, #12
  144a8c:	da000004 	ble	144aa4 <__adddf3+0x184>
  144a90:	e282c014 	add	ip, r2, #20
  144a94:	e262200c 	rsb	r2, r2, #12
  144a98:	e1a00c11 	lsl	r0, r1, ip
  144a9c:	e1a01231 	lsr	r1, r1, r2
  144aa0:	ea000004 	b	144ab8 <__adddf3+0x198>
  144aa4:	e2822014 	add	r2, r2, #20
  144aa8:	d262c020 	rsble	ip, r2, #32
  144aac:	e1a01211 	lsl	r1, r1, r2
  144ab0:	d1811c30 	orrle	r1, r1, r0, lsr ip
  144ab4:	d1a00210 	lslle	r0, r0, r2
  144ab8:	e0544003 	subs	r4, r4, r3
  144abc:	a0811a04 	addge	r1, r1, r4, lsl #20
  144ac0:	a1811005 	orrge	r1, r1, r5
  144ac4:	a8bd8030 	popge	{r4, r5, pc}
  144ac8:	e1e04004 	mvn	r4, r4
  144acc:	e254401f 	subs	r4, r4, #31
  144ad0:	aa00000d 	bge	144b0c <__adddf3+0x1ec>
  144ad4:	e294400c 	adds	r4, r4, #12
  144ad8:	ca000005 	bgt	144af4 <__adddf3+0x1d4>
  144adc:	e2844014 	add	r4, r4, #20
  144ae0:	e2642020 	rsb	r2, r4, #32
  144ae4:	e1a00430 	lsr	r0, r0, r4
  144ae8:	e1800211 	orr	r0, r0, r1, lsl r2
  144aec:	e1851431 	orr	r1, r5, r1, lsr r4
  144af0:	e8bd8030 	pop	{r4, r5, pc}
  144af4:	e264400c 	rsb	r4, r4, #12
  144af8:	e2642020 	rsb	r2, r4, #32
  144afc:	e1a00230 	lsr	r0, r0, r2
  144b00:	e1800411 	orr	r0, r0, r1, lsl r4
  144b04:	e1a01005 	mov	r1, r5
  144b08:	e8bd8030 	pop	{r4, r5, pc}
  144b0c:	e1a00431 	lsr	r0, r1, r4
  144b10:	e1a01005 	mov	r1, r5
  144b14:	e8bd8030 	pop	{r4, r5, pc}
  144b18:	e3340000 	teq	r4, #0
  144b1c:	e2233601 	eor	r3, r3, #1048576	; 0x100000
  144b20:	02211601 	eoreq	r1, r1, #1048576	; 0x100000
  144b24:	02844001 	addeq	r4, r4, #1
  144b28:	12455001 	subne	r5, r5, #1
  144b2c:	eaffffa1 	b	1449b8 <__adddf3+0x98>
  144b30:	e1f0cac4 	mvns	ip, r4, asr #21
  144b34:	11f0cac5 	mvnsne	ip, r5, asr #21
  144b38:	0a000018 	beq	144ba0 <__adddf3+0x280>
  144b3c:	e1340005 	teq	r4, r5
  144b40:	01300002 	teqeq	r0, r2
  144b44:	0a000003 	beq	144b58 <__adddf3+0x238>
  144b48:	e194c000 	orrs	ip, r4, r0
  144b4c:	01a01003 	moveq	r1, r3
  144b50:	01a00002 	moveq	r0, r2
  144b54:	e8bd8030 	pop	{r4, r5, pc}
  144b58:	e1310003 	teq	r1, r3
  144b5c:	13a01000 	movne	r1, #0
  144b60:	13a00000 	movne	r0, #0
  144b64:	18bd8030 	popne	{r4, r5, pc}
  144b68:	e1b0caa4 	lsrs	ip, r4, #21
  144b6c:	1a000003 	bne	144b80 <__adddf3+0x260>
  144b70:	e1b00080 	lsls	r0, r0, #1
  144b74:	e0b11001 	adcs	r1, r1, r1
  144b78:	23811102 	orrcs	r1, r1, #-2147483648	; 0x80000000
  144b7c:	e8bd8030 	pop	{r4, r5, pc}
  144b80:	e2944501 	adds	r4, r4, #4194304	; 0x400000
  144b84:	32811601 	addcc	r1, r1, #1048576	; 0x100000
  144b88:	38bd8030 	popcc	{r4, r5, pc}
  144b8c:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
  144b90:	e385147f 	orr	r1, r5, #2130706432	; 0x7f000000
  144b94:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
  144b98:	e3a00000 	mov	r0, #0
  144b9c:	e8bd8030 	pop	{r4, r5, pc}
  144ba0:	e1f0cac4 	mvns	ip, r4, asr #21
  144ba4:	11a01003 	movne	r1, r3
  144ba8:	11a00002 	movne	r0, r2
  144bac:	01f0cac5 	mvnseq	ip, r5, asr #21
  144bb0:	11a03001 	movne	r3, r1
  144bb4:	11a02000 	movne	r2, r0
  144bb8:	e1904601 	orrs	r4, r0, r1, lsl #12
  144bbc:	01925603 	orrseq	r5, r2, r3, lsl #12
  144bc0:	01310003 	teqeq	r1, r3
  144bc4:	13811702 	orrne	r1, r1, #524288	; 0x80000
  144bc8:	e8bd8030 	pop	{r4, r5, pc}

00144bcc <__aeabi_ui2d>:
  144bcc:	e3300000 	teq	r0, #0
  144bd0:	03a01000 	moveq	r1, #0
  144bd4:	012fff1e 	bxeq	lr
  144bd8:	e92d4030 	push	{r4, r5, lr}
  144bdc:	e3a04b01 	mov	r4, #1024	; 0x400
  144be0:	e2844032 	add	r4, r4, #50	; 0x32
  144be4:	e3a05000 	mov	r5, #0
  144be8:	e3a01000 	mov	r1, #0
  144bec:	eaffff9d 	b	144a68 <__adddf3+0x148>

00144bf0 <__aeabi_i2d>:
  144bf0:	e3300000 	teq	r0, #0
  144bf4:	03a01000 	moveq	r1, #0
  144bf8:	012fff1e 	bxeq	lr
  144bfc:	e92d4030 	push	{r4, r5, lr}
  144c00:	e3a04b01 	mov	r4, #1024	; 0x400
  144c04:	e2844032 	add	r4, r4, #50	; 0x32
  144c08:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
  144c0c:	42600000 	rsbmi	r0, r0, #0
  144c10:	e3a01000 	mov	r1, #0
  144c14:	eaffff93 	b	144a68 <__adddf3+0x148>

00144c18 <__aeabi_f2d>:
  144c18:	e1b02080 	lsls	r2, r0, #1
  144c1c:	e1a011c2 	asr	r1, r2, #3
  144c20:	e1a01061 	rrx	r1, r1
  144c24:	e1a00e02 	lsl	r0, r2, #28
  144c28:	121234ff 	andsne	r3, r2, #-16777216	; 0xff000000
  144c2c:	133304ff 	teqne	r3, #-16777216	; 0xff000000
  144c30:	1221130e 	eorne	r1, r1, #939524096	; 0x38000000
  144c34:	112fff1e 	bxne	lr
  144c38:	e3d224ff 	bics	r2, r2, #-16777216	; 0xff000000
  144c3c:	012fff1e 	bxeq	lr
  144c40:	e33304ff 	teq	r3, #-16777216	; 0xff000000
  144c44:	03811702 	orreq	r1, r1, #524288	; 0x80000
  144c48:	012fff1e 	bxeq	lr
  144c4c:	e92d4030 	push	{r4, r5, lr}
  144c50:	e3a04d0e 	mov	r4, #896	; 0x380
  144c54:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
  144c58:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
  144c5c:	eaffff81 	b	144a68 <__adddf3+0x148>

00144c60 <__aeabi_ul2d>:
  144c60:	e1902001 	orrs	r2, r0, r1
  144c64:	012fff1e 	bxeq	lr
  144c68:	e92d4030 	push	{r4, r5, lr}
  144c6c:	e3a05000 	mov	r5, #0
  144c70:	ea000006 	b	144c90 <__aeabi_l2d+0x1c>

00144c74 <__aeabi_l2d>:
  144c74:	e1902001 	orrs	r2, r0, r1
  144c78:	012fff1e 	bxeq	lr
  144c7c:	e92d4030 	push	{r4, r5, lr}
  144c80:	e2115102 	ands	r5, r1, #-2147483648	; 0x80000000
  144c84:	5a000001 	bpl	144c90 <__aeabi_l2d+0x1c>
  144c88:	e2700000 	rsbs	r0, r0, #0
  144c8c:	e2e11000 	rsc	r1, r1, #0
  144c90:	e3a04b01 	mov	r4, #1024	; 0x400
  144c94:	e2844032 	add	r4, r4, #50	; 0x32
  144c98:	e1b0cb21 	lsrs	ip, r1, #22
  144c9c:	0affff5a 	beq	144a0c <__adddf3+0xec>
  144ca0:	e3a02003 	mov	r2, #3
  144ca4:	e1b0c1ac 	lsrs	ip, ip, #3
  144ca8:	12822003 	addne	r2, r2, #3
  144cac:	e1b0c1ac 	lsrs	ip, ip, #3
  144cb0:	12822003 	addne	r2, r2, #3
  144cb4:	e08221ac 	add	r2, r2, ip, lsr #3
  144cb8:	e2623020 	rsb	r3, r2, #32
  144cbc:	e1a0c310 	lsl	ip, r0, r3
  144cc0:	e1a00230 	lsr	r0, r0, r2
  144cc4:	e1800311 	orr	r0, r0, r1, lsl r3
  144cc8:	e1a01231 	lsr	r1, r1, r2
  144ccc:	e0844002 	add	r4, r4, r2
  144cd0:	eaffff4d 	b	144a0c <__adddf3+0xec>

00144cd4 <__aeabi_dmul>:
  144cd4:	e92d4070 	push	{r4, r5, r6, lr}
  144cd8:	e3a0c0ff 	mov	ip, #255	; 0xff
  144cdc:	e38ccc07 	orr	ip, ip, #1792	; 0x700
  144ce0:	e01c4a21 	ands	r4, ip, r1, lsr #20
  144ce4:	101c5a23 	andsne	r5, ip, r3, lsr #20
  144ce8:	1134000c 	teqne	r4, ip
  144cec:	1135000c 	teqne	r5, ip
  144cf0:	0b00006f 	bleq	144eb4 <__aeabi_dmul+0x1e0>
  144cf4:	e0844005 	add	r4, r4, r5
  144cf8:	e0216003 	eor	r6, r1, r3
  144cfc:	e1c11a8c 	bic	r1, r1, ip, lsl #21
  144d00:	e1c33a8c 	bic	r3, r3, ip, lsl #21
  144d04:	e1905601 	orrs	r5, r0, r1, lsl #12
  144d08:	11925603 	orrsne	r5, r2, r3, lsl #12
  144d0c:	e3811601 	orr	r1, r1, #1048576	; 0x100000
  144d10:	e3833601 	orr	r3, r3, #1048576	; 0x100000
  144d14:	0a00001c 	beq	144d8c <__aeabi_dmul+0xb8>
  144d18:	e08ec290 	umull	ip, lr, r0, r2
  144d1c:	e3a05000 	mov	r5, #0
  144d20:	e0a5e291 	umlal	lr, r5, r1, r2
  144d24:	e2062102 	and	r2, r6, #-2147483648	; 0x80000000
  144d28:	e0a5e390 	umlal	lr, r5, r0, r3
  144d2c:	e3a06000 	mov	r6, #0
  144d30:	e0a65391 	umlal	r5, r6, r1, r3
  144d34:	e33c0000 	teq	ip, #0
  144d38:	138ee001 	orrne	lr, lr, #1
  144d3c:	e24440ff 	sub	r4, r4, #255	; 0xff
  144d40:	e3560c02 	cmp	r6, #512	; 0x200
  144d44:	e2c44c03 	sbc	r4, r4, #768	; 0x300
  144d48:	2a000002 	bcs	144d58 <__aeabi_dmul+0x84>
  144d4c:	e1b0e08e 	lsls	lr, lr, #1
  144d50:	e0b55005 	adcs	r5, r5, r5
  144d54:	e0a66006 	adc	r6, r6, r6
  144d58:	e1821586 	orr	r1, r2, r6, lsl #11
  144d5c:	e1811aa5 	orr	r1, r1, r5, lsr #21
  144d60:	e1a00585 	lsl	r0, r5, #11
  144d64:	e1800aae 	orr	r0, r0, lr, lsr #21
  144d68:	e1a0e58e 	lsl	lr, lr, #11
  144d6c:	e254c0fd 	subs	ip, r4, #253	; 0xfd
  144d70:	835c0c07 	cmphi	ip, #1792	; 0x700
  144d74:	8a00000f 	bhi	144db8 <__aeabi_dmul+0xe4>
  144d78:	e35e0102 	cmp	lr, #-2147483648	; 0x80000000
  144d7c:	01b0e0a0 	lsrseq	lr, r0, #1
  144d80:	e2b00000 	adcs	r0, r0, #0
  144d84:	e0a11a04 	adc	r1, r1, r4, lsl #20
  144d88:	e8bd8070 	pop	{r4, r5, r6, pc}
  144d8c:	e2066102 	and	r6, r6, #-2147483648	; 0x80000000
  144d90:	e1861001 	orr	r1, r6, r1
  144d94:	e1800002 	orr	r0, r0, r2
  144d98:	e0211003 	eor	r1, r1, r3
  144d9c:	e05440ac 	subs	r4, r4, ip, lsr #1
  144da0:	c074500c 	rsbsgt	r5, r4, ip
  144da4:	c1811a04 	orrgt	r1, r1, r4, lsl #20
  144da8:	c8bd8070 	popgt	{r4, r5, r6, pc}
  144dac:	e3811601 	orr	r1, r1, #1048576	; 0x100000
  144db0:	e3a0e000 	mov	lr, #0
  144db4:	e2544001 	subs	r4, r4, #1
  144db8:	ca000058 	bgt	144f20 <__aeabi_dmul+0x24c>
  144dbc:	e3740036 	cmn	r4, #54	; 0x36
  144dc0:	d3a00000 	movle	r0, #0
  144dc4:	d2011102 	andle	r1, r1, #-2147483648	; 0x80000000
  144dc8:	d8bd8070 	pople	{r4, r5, r6, pc}
  144dcc:	e2644000 	rsb	r4, r4, #0
  144dd0:	e2544020 	subs	r4, r4, #32
  144dd4:	aa000018 	bge	144e3c <__aeabi_dmul+0x168>
  144dd8:	e294400c 	adds	r4, r4, #12
  144ddc:	ca00000b 	bgt	144e10 <__aeabi_dmul+0x13c>
  144de0:	e2844014 	add	r4, r4, #20
  144de4:	e2645020 	rsb	r5, r4, #32
  144de8:	e1a03510 	lsl	r3, r0, r5
  144dec:	e1a00430 	lsr	r0, r0, r4
  144df0:	e1800511 	orr	r0, r0, r1, lsl r5
  144df4:	e2012102 	and	r2, r1, #-2147483648	; 0x80000000
  144df8:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
  144dfc:	e0900fa3 	adds	r0, r0, r3, lsr #31
  144e00:	e0a21431 	adc	r1, r2, r1, lsr r4
  144e04:	e19ee083 	orrs	lr, lr, r3, lsl #1
  144e08:	01c00fa3 	biceq	r0, r0, r3, lsr #31
  144e0c:	e8bd8070 	pop	{r4, r5, r6, pc}
  144e10:	e264400c 	rsb	r4, r4, #12
  144e14:	e2645020 	rsb	r5, r4, #32
  144e18:	e1a03410 	lsl	r3, r0, r4
  144e1c:	e1a00530 	lsr	r0, r0, r5
  144e20:	e1800411 	orr	r0, r0, r1, lsl r4
  144e24:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
  144e28:	e0900fa3 	adds	r0, r0, r3, lsr #31
  144e2c:	e2a11000 	adc	r1, r1, #0
  144e30:	e19ee083 	orrs	lr, lr, r3, lsl #1
  144e34:	01c00fa3 	biceq	r0, r0, r3, lsr #31
  144e38:	e8bd8070 	pop	{r4, r5, r6, pc}
  144e3c:	e2645020 	rsb	r5, r4, #32
  144e40:	e18ee510 	orr	lr, lr, r0, lsl r5
  144e44:	e1a03430 	lsr	r3, r0, r4
  144e48:	e1833511 	orr	r3, r3, r1, lsl r5
  144e4c:	e1a00431 	lsr	r0, r1, r4
  144e50:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
  144e54:	e1c00431 	bic	r0, r0, r1, lsr r4
  144e58:	e0800fa3 	add	r0, r0, r3, lsr #31
  144e5c:	e19ee083 	orrs	lr, lr, r3, lsl #1
  144e60:	01c00fa3 	biceq	r0, r0, r3, lsr #31
  144e64:	e8bd8070 	pop	{r4, r5, r6, pc}
  144e68:	e3340000 	teq	r4, #0
  144e6c:	1a000008 	bne	144e94 <__aeabi_dmul+0x1c0>
  144e70:	e2016102 	and	r6, r1, #-2147483648	; 0x80000000
  144e74:	e1b00080 	lsls	r0, r0, #1
  144e78:	e0a11001 	adc	r1, r1, r1
  144e7c:	e3110601 	tst	r1, #1048576	; 0x100000
  144e80:	02444001 	subeq	r4, r4, #1
  144e84:	0afffffa 	beq	144e74 <__aeabi_dmul+0x1a0>
  144e88:	e1811006 	orr	r1, r1, r6
  144e8c:	e3350000 	teq	r5, #0
  144e90:	112fff1e 	bxne	lr
  144e94:	e2036102 	and	r6, r3, #-2147483648	; 0x80000000
  144e98:	e1b02082 	lsls	r2, r2, #1
  144e9c:	e0a33003 	adc	r3, r3, r3
  144ea0:	e3130601 	tst	r3, #1048576	; 0x100000
  144ea4:	02455001 	subeq	r5, r5, #1
  144ea8:	0afffffa 	beq	144e98 <__aeabi_dmul+0x1c4>
  144eac:	e1833006 	orr	r3, r3, r6
  144eb0:	e12fff1e 	bx	lr
  144eb4:	e134000c 	teq	r4, ip
  144eb8:	e00c5a23 	and	r5, ip, r3, lsr #20
  144ebc:	1135000c 	teqne	r5, ip
  144ec0:	0a000006 	beq	144ee0 <__aeabi_dmul+0x20c>
  144ec4:	e1906081 	orrs	r6, r0, r1, lsl #1
  144ec8:	11926083 	orrsne	r6, r2, r3, lsl #1
  144ecc:	1affffe5 	bne	144e68 <__aeabi_dmul+0x194>
  144ed0:	e0211003 	eor	r1, r1, r3
  144ed4:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
  144ed8:	e3a00000 	mov	r0, #0
  144edc:	e8bd8070 	pop	{r4, r5, r6, pc}
  144ee0:	e1906081 	orrs	r6, r0, r1, lsl #1
  144ee4:	01a00002 	moveq	r0, r2
  144ee8:	01a01003 	moveq	r1, r3
  144eec:	11926083 	orrsne	r6, r2, r3, lsl #1
  144ef0:	0a00000f 	beq	144f34 <__aeabi_dmul+0x260>
  144ef4:	e134000c 	teq	r4, ip
  144ef8:	1a000001 	bne	144f04 <__aeabi_dmul+0x230>
  144efc:	e1906601 	orrs	r6, r0, r1, lsl #12
  144f00:	1a00000b 	bne	144f34 <__aeabi_dmul+0x260>
  144f04:	e135000c 	teq	r5, ip
  144f08:	1a000003 	bne	144f1c <__aeabi_dmul+0x248>
  144f0c:	e1926603 	orrs	r6, r2, r3, lsl #12
  144f10:	11a00002 	movne	r0, r2
  144f14:	11a01003 	movne	r1, r3
  144f18:	1a000005 	bne	144f34 <__aeabi_dmul+0x260>
  144f1c:	e0211003 	eor	r1, r1, r3
  144f20:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
  144f24:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
  144f28:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
  144f2c:	e3a00000 	mov	r0, #0
  144f30:	e8bd8070 	pop	{r4, r5, r6, pc}
  144f34:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
  144f38:	e381173e 	orr	r1, r1, #16252928	; 0xf80000
  144f3c:	e8bd8070 	pop	{r4, r5, r6, pc}

00144f40 <__aeabi_ddiv>:
  144f40:	e92d4070 	push	{r4, r5, r6, lr}
  144f44:	e3a0c0ff 	mov	ip, #255	; 0xff
  144f48:	e38ccc07 	orr	ip, ip, #1792	; 0x700
  144f4c:	e01c4a21 	ands	r4, ip, r1, lsr #20
  144f50:	101c5a23 	andsne	r5, ip, r3, lsr #20
  144f54:	1134000c 	teqne	r4, ip
  144f58:	1135000c 	teqne	r5, ip
  144f5c:	0b00005c 	bleq	1450d4 <__aeabi_ddiv+0x194>
  144f60:	e0444005 	sub	r4, r4, r5
  144f64:	e021e003 	eor	lr, r1, r3
  144f68:	e1925603 	orrs	r5, r2, r3, lsl #12
  144f6c:	e1a01601 	lsl	r1, r1, #12
  144f70:	0a00004b 	beq	1450a4 <__aeabi_ddiv+0x164>
  144f74:	e1a03603 	lsl	r3, r3, #12
  144f78:	e3a05201 	mov	r5, #268435456	; 0x10000000
  144f7c:	e1853223 	orr	r3, r5, r3, lsr #4
  144f80:	e1833c22 	orr	r3, r3, r2, lsr #24
  144f84:	e1a02402 	lsl	r2, r2, #8
  144f88:	e1855221 	orr	r5, r5, r1, lsr #4
  144f8c:	e1855c20 	orr	r5, r5, r0, lsr #24
  144f90:	e1a06400 	lsl	r6, r0, #8
  144f94:	e20e1102 	and	r1, lr, #-2147483648	; 0x80000000
  144f98:	e1550003 	cmp	r5, r3
  144f9c:	01560002 	cmpeq	r6, r2
  144fa0:	e2a440fd 	adc	r4, r4, #253	; 0xfd
  144fa4:	e2844c03 	add	r4, r4, #768	; 0x300
  144fa8:	2a000001 	bcs	144fb4 <__aeabi_ddiv+0x74>
  144fac:	e1b030a3 	lsrs	r3, r3, #1
  144fb0:	e1a02062 	rrx	r2, r2
  144fb4:	e0566002 	subs	r6, r6, r2
  144fb8:	e0c55003 	sbc	r5, r5, r3
  144fbc:	e1b030a3 	lsrs	r3, r3, #1
  144fc0:	e1a02062 	rrx	r2, r2
  144fc4:	e3a00601 	mov	r0, #1048576	; 0x100000
  144fc8:	e3a0c702 	mov	ip, #524288	; 0x80000
  144fcc:	e056e002 	subs	lr, r6, r2
  144fd0:	e0d5e003 	sbcs	lr, r5, r3
  144fd4:	20466002 	subcs	r6, r6, r2
  144fd8:	21a0500e 	movcs	r5, lr
  144fdc:	2180000c 	orrcs	r0, r0, ip
  144fe0:	e1b030a3 	lsrs	r3, r3, #1
  144fe4:	e1a02062 	rrx	r2, r2
  144fe8:	e056e002 	subs	lr, r6, r2
  144fec:	e0d5e003 	sbcs	lr, r5, r3
  144ff0:	20466002 	subcs	r6, r6, r2
  144ff4:	21a0500e 	movcs	r5, lr
  144ff8:	218000ac 	orrcs	r0, r0, ip, lsr #1
  144ffc:	e1b030a3 	lsrs	r3, r3, #1
  145000:	e1a02062 	rrx	r2, r2
  145004:	e056e002 	subs	lr, r6, r2
  145008:	e0d5e003 	sbcs	lr, r5, r3
  14500c:	20466002 	subcs	r6, r6, r2
  145010:	21a0500e 	movcs	r5, lr
  145014:	2180012c 	orrcs	r0, r0, ip, lsr #2
  145018:	e1b030a3 	lsrs	r3, r3, #1
  14501c:	e1a02062 	rrx	r2, r2
  145020:	e056e002 	subs	lr, r6, r2
  145024:	e0d5e003 	sbcs	lr, r5, r3
  145028:	20466002 	subcs	r6, r6, r2
  14502c:	21a0500e 	movcs	r5, lr
  145030:	218001ac 	orrcs	r0, r0, ip, lsr #3
  145034:	e195e006 	orrs	lr, r5, r6
  145038:	0a00000d 	beq	145074 <__aeabi_ddiv+0x134>
  14503c:	e1a05205 	lsl	r5, r5, #4
  145040:	e1855e26 	orr	r5, r5, r6, lsr #28
  145044:	e1a06206 	lsl	r6, r6, #4
  145048:	e1a03183 	lsl	r3, r3, #3
  14504c:	e1833ea2 	orr	r3, r3, r2, lsr #29
  145050:	e1a02182 	lsl	r2, r2, #3
  145054:	e1b0c22c 	lsrs	ip, ip, #4
  145058:	1affffdb 	bne	144fcc <__aeabi_ddiv+0x8c>
  14505c:	e3110601 	tst	r1, #1048576	; 0x100000
  145060:	1a000006 	bne	145080 <__aeabi_ddiv+0x140>
  145064:	e1811000 	orr	r1, r1, r0
  145068:	e3a00000 	mov	r0, #0
  14506c:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
  145070:	eaffffd5 	b	144fcc <__aeabi_ddiv+0x8c>
  145074:	e3110601 	tst	r1, #1048576	; 0x100000
  145078:	01811000 	orreq	r1, r1, r0
  14507c:	03a00000 	moveq	r0, #0
  145080:	e254c0fd 	subs	ip, r4, #253	; 0xfd
  145084:	835c0c07 	cmphi	ip, #1792	; 0x700
  145088:	8affff4a 	bhi	144db8 <__aeabi_dmul+0xe4>
  14508c:	e055c003 	subs	ip, r5, r3
  145090:	0056c002 	subseq	ip, r6, r2
  145094:	01b0c0a0 	lsrseq	ip, r0, #1
  145098:	e2b00000 	adcs	r0, r0, #0
  14509c:	e0a11a04 	adc	r1, r1, r4, lsl #20
  1450a0:	e8bd8070 	pop	{r4, r5, r6, pc}
  1450a4:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
  1450a8:	e18e1621 	orr	r1, lr, r1, lsr #12
  1450ac:	e09440ac 	adds	r4, r4, ip, lsr #1
  1450b0:	c074500c 	rsbsgt	r5, r4, ip
  1450b4:	c1811a04 	orrgt	r1, r1, r4, lsl #20
  1450b8:	c8bd8070 	popgt	{r4, r5, r6, pc}
  1450bc:	e3811601 	orr	r1, r1, #1048576	; 0x100000
  1450c0:	e3a0e000 	mov	lr, #0
  1450c4:	e2544001 	subs	r4, r4, #1
  1450c8:	eaffff3a 	b	144db8 <__aeabi_dmul+0xe4>
  1450cc:	e185e006 	orr	lr, r5, r6
  1450d0:	eaffff38 	b	144db8 <__aeabi_dmul+0xe4>
  1450d4:	e00c5a23 	and	r5, ip, r3, lsr #20
  1450d8:	e134000c 	teq	r4, ip
  1450dc:	0135000c 	teqeq	r5, ip
  1450e0:	0affff93 	beq	144f34 <__aeabi_dmul+0x260>
  1450e4:	e134000c 	teq	r4, ip
  1450e8:	1a000006 	bne	145108 <__aeabi_ddiv+0x1c8>
  1450ec:	e1904601 	orrs	r4, r0, r1, lsl #12
  1450f0:	1affff8f 	bne	144f34 <__aeabi_dmul+0x260>
  1450f4:	e135000c 	teq	r5, ip
  1450f8:	1affff87 	bne	144f1c <__aeabi_dmul+0x248>
  1450fc:	e1a00002 	mov	r0, r2
  145100:	e1a01003 	mov	r1, r3
  145104:	eaffff8a 	b	144f34 <__aeabi_dmul+0x260>
  145108:	e135000c 	teq	r5, ip
  14510c:	1a000004 	bne	145124 <__aeabi_ddiv+0x1e4>
  145110:	e1925603 	orrs	r5, r2, r3, lsl #12
  145114:	0affff6d 	beq	144ed0 <__aeabi_dmul+0x1fc>
  145118:	e1a00002 	mov	r0, r2
  14511c:	e1a01003 	mov	r1, r3
  145120:	eaffff83 	b	144f34 <__aeabi_dmul+0x260>
  145124:	e1906081 	orrs	r6, r0, r1, lsl #1
  145128:	11926083 	orrsne	r6, r2, r3, lsl #1
  14512c:	1affff4d 	bne	144e68 <__aeabi_dmul+0x194>
  145130:	e1904081 	orrs	r4, r0, r1, lsl #1
  145134:	1affff78 	bne	144f1c <__aeabi_dmul+0x248>
  145138:	e1925083 	orrs	r5, r2, r3, lsl #1
  14513c:	1affff63 	bne	144ed0 <__aeabi_dmul+0x1fc>
  145140:	eaffff7b 	b	144f34 <__aeabi_dmul+0x260>

00145144 <__gedf2>:
  145144:	e3e0c000 	mvn	ip, #0
  145148:	ea000002 	b	145158 <__cmpdf2+0x4>

0014514c <__ledf2>:
  14514c:	e3a0c001 	mov	ip, #1
  145150:	ea000000 	b	145158 <__cmpdf2+0x4>

00145154 <__cmpdf2>:
  145154:	e3a0c001 	mov	ip, #1
  145158:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
  14515c:	e1a0c081 	lsl	ip, r1, #1
  145160:	e1f0cacc 	mvns	ip, ip, asr #21
  145164:	e1a0c083 	lsl	ip, r3, #1
  145168:	11f0cacc 	mvnsne	ip, ip, asr #21
  14516c:	0a00000e 	beq	1451ac <__cmpdf2+0x58>
  145170:	e28dd004 	add	sp, sp, #4
  145174:	e190c081 	orrs	ip, r0, r1, lsl #1
  145178:	0192c083 	orrseq	ip, r2, r3, lsl #1
  14517c:	11310003 	teqne	r1, r3
  145180:	01300002 	teqeq	r0, r2
  145184:	03a00000 	moveq	r0, #0
  145188:	012fff1e 	bxeq	lr
  14518c:	e3700000 	cmn	r0, #0
  145190:	e1310003 	teq	r1, r3
  145194:	51510003 	cmppl	r1, r3
  145198:	01500002 	cmpeq	r0, r2
  14519c:	21a00fc3 	asrcs	r0, r3, #31
  1451a0:	31e00fc3 	mvncc	r0, r3, asr #31
  1451a4:	e3800001 	orr	r0, r0, #1
  1451a8:	e12fff1e 	bx	lr
  1451ac:	e1a0c081 	lsl	ip, r1, #1
  1451b0:	e1f0cacc 	mvns	ip, ip, asr #21
  1451b4:	1a000001 	bne	1451c0 <__cmpdf2+0x6c>
  1451b8:	e190c601 	orrs	ip, r0, r1, lsl #12
  1451bc:	1a000004 	bne	1451d4 <__cmpdf2+0x80>
  1451c0:	e1a0c083 	lsl	ip, r3, #1
  1451c4:	e1f0cacc 	mvns	ip, ip, asr #21
  1451c8:	1affffe8 	bne	145170 <__cmpdf2+0x1c>
  1451cc:	e192c603 	orrs	ip, r2, r3, lsl #12
  1451d0:	0affffe6 	beq	145170 <__cmpdf2+0x1c>
  1451d4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
  1451d8:	e12fff1e 	bx	lr

001451dc <__aeabi_cdrcmple>:
  1451dc:	e1a0c000 	mov	ip, r0
  1451e0:	e1a00002 	mov	r0, r2
  1451e4:	e1a0200c 	mov	r2, ip
  1451e8:	e1a0c001 	mov	ip, r1
  1451ec:	e1a01003 	mov	r1, r3
  1451f0:	e1a0300c 	mov	r3, ip
  1451f4:	eaffffff 	b	1451f8 <__aeabi_cdcmpeq>

001451f8 <__aeabi_cdcmpeq>:
  1451f8:	e92d4001 	push	{r0, lr}
  1451fc:	ebffffd4 	bl	145154 <__cmpdf2>
  145200:	e3500000 	cmp	r0, #0
  145204:	43700000 	cmnmi	r0, #0
  145208:	e8bd8001 	pop	{r0, pc}

0014520c <__aeabi_dcmpeq>:
  14520c:	e52de008 	str	lr, [sp, #-8]!
  145210:	ebfffff8 	bl	1451f8 <__aeabi_cdcmpeq>
  145214:	03a00001 	moveq	r0, #1
  145218:	13a00000 	movne	r0, #0
  14521c:	e49df008 	ldr	pc, [sp], #8

00145220 <__aeabi_dcmplt>:
  145220:	e52de008 	str	lr, [sp, #-8]!
  145224:	ebfffff3 	bl	1451f8 <__aeabi_cdcmpeq>
  145228:	33a00001 	movcc	r0, #1
  14522c:	23a00000 	movcs	r0, #0
  145230:	e49df008 	ldr	pc, [sp], #8

00145234 <__aeabi_dcmple>:
  145234:	e52de008 	str	lr, [sp, #-8]!
  145238:	ebffffee 	bl	1451f8 <__aeabi_cdcmpeq>
  14523c:	93a00001 	movls	r0, #1
  145240:	83a00000 	movhi	r0, #0
  145244:	e49df008 	ldr	pc, [sp], #8

00145248 <__aeabi_dcmpge>:
  145248:	e52de008 	str	lr, [sp, #-8]!
  14524c:	ebffffe2 	bl	1451dc <__aeabi_cdrcmple>
  145250:	93a00001 	movls	r0, #1
  145254:	83a00000 	movhi	r0, #0
  145258:	e49df008 	ldr	pc, [sp], #8

0014525c <__aeabi_dcmpgt>:
  14525c:	e52de008 	str	lr, [sp, #-8]!
  145260:	ebffffdd 	bl	1451dc <__aeabi_cdrcmple>
  145264:	33a00001 	movcc	r0, #1
  145268:	23a00000 	movcs	r0, #0
  14526c:	e49df008 	ldr	pc, [sp], #8

00145270 <__aeabi_d2iz>:
  145270:	e1a02081 	lsl	r2, r1, #1
  145274:	e2922602 	adds	r2, r2, #2097152	; 0x200000
  145278:	2a00000c 	bcs	1452b0 <__aeabi_d2iz+0x40>
  14527c:	5a000009 	bpl	1452a8 <__aeabi_d2iz+0x38>
  145280:	e3e03e3e 	mvn	r3, #992	; 0x3e0
  145284:	e0532ac2 	subs	r2, r3, r2, asr #21
  145288:	9a00000a 	bls	1452b8 <__aeabi_d2iz+0x48>
  14528c:	e1a03581 	lsl	r3, r1, #11
  145290:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
  145294:	e1833aa0 	orr	r3, r3, r0, lsr #21
  145298:	e3110102 	tst	r1, #-2147483648	; 0x80000000
  14529c:	e1a00233 	lsr	r0, r3, r2
  1452a0:	12600000 	rsbne	r0, r0, #0
  1452a4:	e12fff1e 	bx	lr
  1452a8:	e3a00000 	mov	r0, #0
  1452ac:	e12fff1e 	bx	lr
  1452b0:	e1900601 	orrs	r0, r0, r1, lsl #12
  1452b4:	1a000002 	bne	1452c4 <__aeabi_d2iz+0x54>
  1452b8:	e2110102 	ands	r0, r1, #-2147483648	; 0x80000000
  1452bc:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
  1452c0:	e12fff1e 	bx	lr
  1452c4:	e3a00000 	mov	r0, #0
  1452c8:	e12fff1e 	bx	lr

001452cc <__aeabi_d2uiz>:
  1452cc:	e1b02081 	lsls	r2, r1, #1
  1452d0:	2a00000a 	bcs	145300 <__aeabi_d2uiz+0x34>
  1452d4:	e2922602 	adds	r2, r2, #2097152	; 0x200000
  1452d8:	2a00000a 	bcs	145308 <__aeabi_d2uiz+0x3c>
  1452dc:	5a000007 	bpl	145300 <__aeabi_d2uiz+0x34>
  1452e0:	e3e03e3e 	mvn	r3, #992	; 0x3e0
  1452e4:	e0532ac2 	subs	r2, r3, r2, asr #21
  1452e8:	4a000008 	bmi	145310 <__aeabi_d2uiz+0x44>
  1452ec:	e1a03581 	lsl	r3, r1, #11
  1452f0:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
  1452f4:	e1833aa0 	orr	r3, r3, r0, lsr #21
  1452f8:	e1a00233 	lsr	r0, r3, r2
  1452fc:	e12fff1e 	bx	lr
  145300:	e3a00000 	mov	r0, #0
  145304:	e12fff1e 	bx	lr
  145308:	e1900601 	orrs	r0, r0, r1, lsl #12
  14530c:	1a000001 	bne	145318 <__aeabi_d2uiz+0x4c>
  145310:	e3e00000 	mvn	r0, #0
  145314:	e12fff1e 	bx	lr
  145318:	e3a00000 	mov	r0, #0
  14531c:	e12fff1e 	bx	lr

00145320 <__aeabi_ldivmod>:
  145320:	e3530000 	cmp	r3, #0
  145324:	03520000 	cmpeq	r2, #0
  145328:	1a000007 	bne	14534c <__aeabi_ldivmod+0x2c>
  14532c:	e3510000 	cmp	r1, #0
  145330:	b3a01102 	movlt	r1, #-2147483648	; 0x80000000
  145334:	b3a00000 	movlt	r0, #0
  145338:	ba000002 	blt	145348 <__aeabi_ldivmod+0x28>
  14533c:	03500000 	cmpeq	r0, #0
  145340:	13e01102 	mvnne	r1, #-2147483648	; 0x80000000
  145344:	13e00000 	mvnne	r0, #0
  145348:	eaffcedc 	b	138ec0 <__aeabi_idiv0>
  14534c:	e24dd008 	sub	sp, sp, #8
  145350:	e92d6000 	push	{sp, lr}
  145354:	e3510000 	cmp	r1, #0
  145358:	ba000006 	blt	145378 <__aeabi_ldivmod+0x58>
  14535c:	e3530000 	cmp	r3, #0
  145360:	ba000011 	blt	1453ac <__aeabi_ldivmod+0x8c>
  145364:	eb000031 	bl	145430 <__udivmoddi4>
  145368:	e59de004 	ldr	lr, [sp, #4]
  14536c:	e28dd008 	add	sp, sp, #8
  145370:	e8bd000c 	pop	{r2, r3}
  145374:	e12fff1e 	bx	lr
  145378:	e2700000 	rsbs	r0, r0, #0
  14537c:	e0c11081 	sbc	r1, r1, r1, lsl #1
  145380:	e3530000 	cmp	r3, #0
  145384:	ba000011 	blt	1453d0 <__aeabi_ldivmod+0xb0>
  145388:	eb000028 	bl	145430 <__udivmoddi4>
  14538c:	e59de004 	ldr	lr, [sp, #4]
  145390:	e28dd008 	add	sp, sp, #8
  145394:	e8bd000c 	pop	{r2, r3}
  145398:	e2700000 	rsbs	r0, r0, #0
  14539c:	e0c11081 	sbc	r1, r1, r1, lsl #1
  1453a0:	e2722000 	rsbs	r2, r2, #0
  1453a4:	e0c33083 	sbc	r3, r3, r3, lsl #1
  1453a8:	e12fff1e 	bx	lr
  1453ac:	e2722000 	rsbs	r2, r2, #0
  1453b0:	e0c33083 	sbc	r3, r3, r3, lsl #1
  1453b4:	eb00001d 	bl	145430 <__udivmoddi4>
  1453b8:	e59de004 	ldr	lr, [sp, #4]
  1453bc:	e28dd008 	add	sp, sp, #8
  1453c0:	e8bd000c 	pop	{r2, r3}
  1453c4:	e2700000 	rsbs	r0, r0, #0
  1453c8:	e0c11081 	sbc	r1, r1, r1, lsl #1
  1453cc:	e12fff1e 	bx	lr
  1453d0:	e2722000 	rsbs	r2, r2, #0
  1453d4:	e0c33083 	sbc	r3, r3, r3, lsl #1
  1453d8:	eb000014 	bl	145430 <__udivmoddi4>
  1453dc:	e59de004 	ldr	lr, [sp, #4]
  1453e0:	e28dd008 	add	sp, sp, #8
  1453e4:	e8bd000c 	pop	{r2, r3}
  1453e8:	e2722000 	rsbs	r2, r2, #0
  1453ec:	e0c33083 	sbc	r3, r3, r3, lsl #1
  1453f0:	e12fff1e 	bx	lr

001453f4 <__aeabi_uldivmod>:
  1453f4:	e3530000 	cmp	r3, #0
  1453f8:	03520000 	cmpeq	r2, #0
  1453fc:	1a000004 	bne	145414 <__aeabi_uldivmod+0x20>
  145400:	e3510000 	cmp	r1, #0
  145404:	03500000 	cmpeq	r0, #0
  145408:	13e01000 	mvnne	r1, #0
  14540c:	13e00000 	mvnne	r0, #0
  145410:	eaffceaa 	b	138ec0 <__aeabi_idiv0>
  145414:	e24dd008 	sub	sp, sp, #8
  145418:	e92d6000 	push	{sp, lr}
  14541c:	eb000003 	bl	145430 <__udivmoddi4>
  145420:	e59de004 	ldr	lr, [sp, #4]
  145424:	e28dd008 	add	sp, sp, #8
  145428:	e8bd000c 	pop	{r2, r3}
  14542c:	e12fff1e 	bx	lr

00145430 <__udivmoddi4>:
  145430:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  145434:	e1510003 	cmp	r1, r3
  145438:	e24dd008 	sub	sp, sp, #8
  14543c:	01500002 	cmpeq	r0, r2
  145440:	e1a09000 	mov	r9, r0
  145444:	e1a0a001 	mov	sl, r1
  145448:	e59d8028 	ldr	r8, [sp, #40]	; 0x28
  14544c:	3a00003c 	bcc	145544 <__udivmoddi4+0x114>
  145450:	e1a00002 	mov	r0, r2
  145454:	e3530000 	cmp	r3, #0
  145458:	e1a01003 	mov	r1, r3
  14545c:	016f3f10 	clzeq	r3, r0
  145460:	116f2f13 	clzne	r2, r3
  145464:	02832020 	addeq	r2, r3, #32
  145468:	e35a0000 	cmp	sl, #0
  14546c:	016f3f19 	clzeq	r3, r9
  145470:	116f3f1a 	clzne	r3, sl
  145474:	02833020 	addeq	r3, r3, #32
  145478:	e0423003 	sub	r3, r2, r3
  14547c:	e243c020 	sub	ip, r3, #32
  145480:	e1a07311 	lsl	r7, r1, r3
  145484:	e1877c10 	orr	r7, r7, r0, lsl ip
  145488:	e263e020 	rsb	lr, r3, #32
  14548c:	e1877e30 	orr	r7, r7, r0, lsr lr
  145490:	e1a06310 	lsl	r6, r0, r3
  145494:	e15a0007 	cmp	sl, r7
  145498:	01590006 	cmpeq	r9, r6
  14549c:	2a000030 	bcs	145564 <__udivmoddi4+0x134>
  1454a0:	e3a01000 	mov	r1, #0
  1454a4:	e3a02000 	mov	r2, #0
  1454a8:	e88d0006 	stm	sp, {r1, r2}
  1454ac:	e3530000 	cmp	r3, #0
  1454b0:	0a000026 	beq	145550 <__udivmoddi4+0x120>
  1454b4:	e1b070a7 	lsrs	r7, r7, #1
  1454b8:	e1a06066 	rrx	r6, r6
  1454bc:	e1a02003 	mov	r2, r3
  1454c0:	ea000007 	b	1454e4 <__udivmoddi4+0xb4>
  1454c4:	e0590006 	subs	r0, r9, r6
  1454c8:	e0ca1007 	sbc	r1, sl, r7
  1454cc:	e0904000 	adds	r4, r0, r0
  1454d0:	e0a15001 	adc	r5, r1, r1
  1454d4:	e2949001 	adds	r9, r4, #1
  1454d8:	e2a5a000 	adc	sl, r5, #0
  1454dc:	e2522001 	subs	r2, r2, #1
  1454e0:	0a000006 	beq	145500 <__udivmoddi4+0xd0>
  1454e4:	e15a0007 	cmp	sl, r7
  1454e8:	01590006 	cmpeq	r9, r6
  1454ec:	2afffff4 	bcs	1454c4 <__udivmoddi4+0x94>
  1454f0:	e0999009 	adds	r9, r9, r9
  1454f4:	e0aaa00a 	adc	sl, sl, sl
  1454f8:	e2522001 	subs	r2, r2, #1
  1454fc:	1afffff8 	bne	1454e4 <__udivmoddi4+0xb4>
  145500:	e89d00c0 	ldm	sp, {r6, r7}
  145504:	e1a02339 	lsr	r2, r9, r3
  145508:	e0966009 	adds	r6, r6, r9
  14550c:	e1822e1a 	orr	r2, r2, sl, lsl lr
  145510:	e1a0133a 	lsr	r1, sl, r3
  145514:	e1822c3a 	orr	r2, r2, sl, lsr ip
  145518:	e0a7700a 	adc	r7, r7, sl
  14551c:	e1a0a001 	mov	sl, r1
  145520:	e1a0131a 	lsl	r1, sl, r3
  145524:	e1811c12 	orr	r1, r1, r2, lsl ip
  145528:	e1a00312 	lsl	r0, r2, r3
  14552c:	e0566000 	subs	r6, r6, r0
  145530:	e1811e32 	orr	r1, r1, r2, lsr lr
  145534:	e0c77001 	sbc	r7, r7, r1
  145538:	e1a09002 	mov	r9, r2
  14553c:	e88d00c0 	stm	sp, {r6, r7}
  145540:	ea000002 	b	145550 <__udivmoddi4+0x120>
  145544:	e3a03000 	mov	r3, #0
  145548:	e3a04000 	mov	r4, #0
  14554c:	e88d0018 	stm	sp, {r3, r4}
  145550:	e3580000 	cmp	r8, #0
  145554:	18880600 	stmne	r8, {r9, sl}
  145558:	e89d0003 	ldm	sp, {r0, r1}
  14555c:	e28dd008 	add	sp, sp, #8
  145560:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  145564:	e3a02001 	mov	r2, #1
  145568:	e1a01c12 	lsl	r1, r2, ip
  14556c:	e1811e32 	orr	r1, r1, r2, lsr lr
  145570:	e0599006 	subs	r9, r9, r6
  145574:	e1a02312 	lsl	r2, r2, r3
  145578:	e58d1004 	str	r1, [sp, #4]
  14557c:	e0caa007 	sbc	sl, sl, r7
  145580:	e58d2000 	str	r2, [sp]
  145584:	eaffffc8 	b	1454ac <__udivmoddi4+0x7c>

00145588 <_init>:
  145588:	e92d4001 	push	{r0, lr}
  14558c:	e8bd4001 	pop	{r0, lr}
  145590:	e12fff1e 	bx	lr

00145594 <_fini>:
  145594:	e92d4001 	push	{r0, lr}
  145598:	e8bd4001 	pop	{r0, lr}
  14559c:	e12fff1e 	bx	lr
  1455a0:	706d6f63 	.word	0x706d6f63
  1455a4:	6974656c 	.word	0x6974656c
  1455a8:	00006e6f 	.word	0x00006e6f
  1455ac:	20746553 	.word	0x20746553
  1455b0:	6c626f6e 	.word	0x6c626f6e
  1455b4:	696b636f 	.word	0x696b636f
  1455b8:	6520676e 	.word	0x6520676e
  1455bc:	726f7272 	.word	0x726f7272
  1455c0:	00000021 	.word	0x00000021
  1455c4:	61657243 	.word	0x61657243
  1455c8:	6c206574 	.word	0x6c206574
  1455cc:	65747369 	.word	0x65747369
  1455d0:	2064666e 	.word	0x2064666e
  1455d4:	6b636f73 	.word	0x6b636f73
  1455d8:	65207465 	.word	0x65207465
  1455dc:	726f7272 	.word	0x726f7272
  1455e0:	7325203a 	.word	0x7325203a
  1455e4:	72726528 	.word	0x72726528
  1455e8:	203a6f6e 	.word	0x203a6f6e
  1455ec:	0a296425 	.word	0x0a296425
  1455f0:	00000000 	.word	0x00000000
  1455f4:	73746553 	.word	0x73746553
  1455f8:	6f6b636f 	.word	0x6f6b636f
  1455fc:	72207470 	.word	0x72207470
  145600:	65737565 	.word	0x65737565
  145604:	20646461 	.word	0x20646461
  145608:	6c696166 	.word	0x6c696166
  14560c:	00006465 	.word	0x00006465
  145610:	646e6942 	.word	0x646e6942
  145614:	636f7320 	.word	0x636f7320
  145618:	2074656b 	.word	0x2074656b
  14561c:	6f727265 	.word	0x6f727265
  145620:	25203a72 	.word	0x25203a72
  145624:	72652873 	.word	0x72652873
  145628:	3a6f6e72 	.word	0x3a6f6e72
  14562c:	29642520 	.word	0x29642520
  145630:	6466202c 	.word	0x6466202c
  145634:	0a64253d 	.word	0x0a64253d
  145638:	00000000 	.word	0x00000000
  14563c:	7473694c 	.word	0x7473694c
  145640:	73206e65 	.word	0x73206e65
  145644:	656b636f 	.word	0x656b636f
  145648:	72652074 	.word	0x72652074
  14564c:	3a726f72 	.word	0x3a726f72
  145650:	28732520 	.word	0x28732520
  145654:	6e727265 	.word	0x6e727265
  145658:	25203a6f 	.word	0x25203a6f
  14565c:	000a2964 	.word	0x000a2964
  145660:	61657243 	.word	0x61657243
  145664:	63206574 	.word	0x63206574
  145668:	6e65696c 	.word	0x6e65696c
  14566c:	20646674 	.word	0x20646674
  145670:	6b636f73 	.word	0x6b636f73
  145674:	65207465 	.word	0x65207465
  145678:	726f7272 	.word	0x726f7272
  14567c:	7325203a 	.word	0x7325203a
  145680:	72726528 	.word	0x72726528
  145684:	203a6f6e 	.word	0x203a6f6e
  145688:	0a296425 	.word	0x0a296425
  14568c:	00000000 	.word	0x00000000
  145690:	656c6573 	.word	0x656c6573
  145694:	65207463 	.word	0x65207463
  145698:	726f7272 	.word	0x726f7272
  14569c:	00000000 	.word	0x00000000
  1456a0:	746e6f63 	.word	0x746e6f63
  1456a4:	65756e69 	.word	0x65756e69
  1456a8:	00000000 	.word	0x00000000
  1456ac:	69745f75 	.word	0x69745f75
  1456b0:	0072656d 	.word	0x0072656d
  1456b4:	5f6d7475 	.word	0x5f6d7475
  1456b8:	6574756d 	.word	0x6574756d
  1456bc:	00000078 	.word	0x00000078
  1456c0:	00007325 	.word	0x00007325
  1456c4:	72657355 	.word	0x72657355
  1456c8:	3a505041 	.word	0x3a505041
  1456cc:	73252820 	.word	0x73252820
  1456d0:	73612029 	.word	0x73612029
  1456d4:	74726573 	.word	0x74726573
  1456d8:	206e6f69 	.word	0x206e6f69
  1456dc:	6c696166 	.word	0x6c696166
  1456e0:	61206465 	.word	0x61206465
  1456e4:	75662074 	.word	0x75662074
  1456e8:	6974636e 	.word	0x6974636e
  1456ec:	253a6e6f 	.word	0x253a6e6f
  1456f0:	6c202c73 	.word	0x6c202c73
  1456f4:	20656e69 	.word	0x20656e69
  1456f8:	626d756e 	.word	0x626d756e
  1456fc:	253a7265 	.word	0x253a7265
  145700:	000a2064 	.word	0x000a2064
  145704:	6e616863 	.word	0x6e616863
  145708:	206c656e 	.word	0x206c656e
  14570c:	30203d3e 	.word	0x30203d3e
  145710:	00000000 	.word	0x00000000
  145714:	5049776c 	.word	0x5049776c
  145718:	0074694b 	.word	0x0074694b
  14571c:	61746164 	.word	0x61746164
  145720:	00646e49 	.word	0x00646e49
  145724:	6c207325 	.word	0x6c207325
  145728:	20656e69 	.word	0x20656e69
  14572c:	73206425 	.word	0x73206425
  145730:	74646e65 	.word	0x74646e65
  145734:	7265206f 	.word	0x7265206f
  145738:	0a726f72 	.word	0x0a726f72
  14573c:	00000000 	.word	0x00000000
  145740:	5049776c 	.word	0x5049776c
  145744:	2074694b 	.word	0x2074694b
  145748:	67617355 	.word	0x67617355
  14574c:	090a3a65 	.word	0x090a3a65
  145750:	5049776c 	.word	0x5049776c
  145754:	2074694b 	.word	0x2074694b
  145758:	20202020 	.word	0x20202020
  14575c:	20202020 	.word	0x20202020
  145760:	20202020 	.word	0x20202020
  145764:	203a2020 	.word	0x203a2020
  145768:	6e757220 	.word	0x6e757220
  14576c:	49776c20 	.word	0x49776c20
  145770:	74694b50 	.word	0x74694b50
  145774:	6177202c 	.word	0x6177202c
  145778:	66207469 	.word	0x66207469
  14577c:	6520726f 	.word	0x6520726f
  145780:	65646874 	.word	0x65646874
  145784:	6f742076 	.word	0x6f742076
  145788:	74746120 	.word	0x74746120
  14578c:	0a686361 	.word	0x0a686361
  145790:	49776c09 	.word	0x49776c09
  145794:	74694b50 	.word	0x74694b50
  145798:	74746120 	.word	0x74746120
  14579c:	20686361 	.word	0x20686361
  1457a0:	653c2020 	.word	0x653c2020
  1457a4:	3a3e6874 	.word	0x3a3e6874
  1457a8:	74612020 	.word	0x74612020
  1457ac:	68636174 	.word	0x68636174
  1457b0:	65687420 	.word	0x65687420
  1457b4:	76656420 	.word	0x76656420
  1457b8:	20656369 	.word	0x20656369
  1457bc:	6874653c 	.word	0x6874653c
  1457c0:	6f74203e 	.word	0x6f74203e
  1457c4:	49776c20 	.word	0x49776c20
  1457c8:	74694b50 	.word	0x74694b50
  1457cc:	776c090a 	.word	0x776c090a
  1457d0:	694b5049 	.word	0x694b5049
  1457d4:	65642074 	.word	0x65642074
  1457d8:	61747461 	.word	0x61747461
  1457dc:	3c206863 	.word	0x3c206863
  1457e0:	3e687465 	.word	0x3e687465
  1457e4:	6420203a 	.word	0x6420203a
  1457e8:	74612d65 	.word	0x74612d65
  1457ec:	68636174 	.word	0x68636174
  1457f0:	65687420 	.word	0x65687420
  1457f4:	76656420 	.word	0x76656420
  1457f8:	20656369 	.word	0x20656369
  1457fc:	6874653c 	.word	0x6874653c
  145800:	7266203e 	.word	0x7266203e
  145804:	6c206d6f 	.word	0x6c206d6f
  145808:	4b504977 	.word	0x4b504977
  14580c:	090a7469 	.word	0x090a7469
  145810:	5049776c 	.word	0x5049776c
  145814:	2074694b 	.word	0x2074694b
  145818:	61666564 	.word	0x61666564
  14581c:	20746c75 	.word	0x20746c75
  145820:	74653c20 	.word	0x74653c20
  145824:	203a3e68 	.word	0x203a3e68
  145828:	74657320 	.word	0x74657320
  14582c:	74653c20 	.word	0x74653c20
  145830:	61203e68 	.word	0x61203e68
  145834:	68742073 	.word	0x68742073
  145838:	65642065 	.word	0x65642065
  14583c:	6c756166 	.word	0x6c756166
  145840:	65642074 	.word	0x65642074
  145844:	65636976 	.word	0x65636976
  145848:	776c090a 	.word	0x776c090a
  14584c:	694b5049 	.word	0x694b5049
  145850:	74732074 	.word	0x74732074
  145854:	73757461 	.word	0x73757461
  145858:	20202020 	.word	0x20202020
  14585c:	20202020 	.word	0x20202020
  145860:	7320203a 	.word	0x7320203a
  145864:	20776f68 	.word	0x20776f68
  145868:	20656874 	.word	0x20656874
  14586c:	74617473 	.word	0x74617473
  145870:	6f207375 	.word	0x6f207375
  145874:	75722066 	.word	0x75722066
  145878:	6e696e6e 	.word	0x6e696e6e
  14587c:	776c2067 	.word	0x776c2067
  145880:	494b5049 	.word	0x494b5049
  145884:	00000074 	.word	0x00000074
  145888:	7069776c 	.word	0x7069776c
  14588c:	2074696b 	.word	0x2074696b
  145890:	20646970 	.word	0x20646970
  145894:	6425203d 	.word	0x6425203d
  145898:	0000000a 	.word	0x0000000a
  14589c:	5049776c 	.word	0x5049776c
  1458a0:	3a74694b 	.word	0x3a74694b
  1458a4:	61747320 	.word	0x61747320
  1458a8:	20737472 	.word	0x20737472
  1458ac:	72206f74 	.word	0x72206f74
  1458b0:	61206e75 	.word	0x61206e75
  1458b4:	68742073 	.word	0x68742073
  1458b8:	65732065 	.word	0x65732065
  1458bc:	72657672 	.word	0x72657672
  1458c0:	00000000 	.word	0x00000000
  1458c4:	2e2e2e20 	.word	0x2e2e2e20
  1458c8:	6c696166 	.word	0x6c696166
  1458cc:	00216465 	.word	0x00216465
  1458d0:	2e2e2e20 	.word	0x2e2e2e20
  1458d4:	70696b73 	.word	0x70696b73
  1458d8:	21646570 	.word	0x21646570
  1458dc:	726c4120 	.word	0x726c4120
  1458e0:	79646165 	.word	0x79646165
  1458e4:	696e6920 	.word	0x696e6920
  1458e8:	6c616974 	.word	0x6c616974
  1458ec:	64657a69 	.word	0x64657a69
  1458f0:	00000000 	.word	0x00000000
  1458f4:	2e2e2e20 	.word	0x2e2e2e20
  1458f8:	63637573 	.word	0x63637573
  1458fc:	65646565 	.word	0x65646565
  145900:	00002164 	.word	0x00002164
  145904:	5049776c 	.word	0x5049776c
  145908:	3a74694b 	.word	0x3a74694b
  14590c:	696e6920 	.word	0x696e6920
  145910:	74652074 	.word	0x74652074
  145914:	65642068 	.word	0x65642068
  145918:	2e2e2e76 	.word	0x2e2e2e76
  14591c:	00000000 	.word	0x00000000
  145920:	63637573 	.word	0x63637573
  145924:	65646565 	.word	0x65646565
  145928:	00000064 	.word	0x00000064
  14592c:	61747461 	.word	0x61747461
  145930:	00006863 	.word	0x00006863
  145934:	5049776c 	.word	0x5049776c
  145938:	3a74694b 	.word	0x3a74694b
  14593c:	74746120 	.word	0x74746120
  145940:	20686361 	.word	0x20686361
  145944:	69766564 	.word	0x69766564
  145948:	25206563 	.word	0x25206563
  14594c:	00000a73 	.word	0x00000a73
  145950:	6e6e6163 	.word	0x6e6e6163
  145954:	6f20746f 	.word	0x6f20746f
  145958:	206e6570 	.word	0x206e6570
  14595c:	61746164 	.word	0x61746164
  145960:	6168635f 	.word	0x6168635f
  145964:	6c656e6e 	.word	0x6c656e6e
  145968:	6c70202c 	.word	0x6c70202c
  14596c:	65736165 	.word	0x65736165
  145970:	6b616d20 	.word	0x6b616d20
  145974:	75732065 	.word	0x75732065
  145978:	6c206572 	.word	0x6c206572
  14597c:	4b504977 	.word	0x4b504977
  145980:	73207469 	.word	0x73207469
  145984:	65767265 	.word	0x65767265
  145988:	73692072 	.word	0x73692072
  14598c:	6e757220 	.word	0x6e757220
  145990:	676e696e 	.word	0x676e696e
  145994:	00000021 	.word	0x00000021
  145998:	74616564 	.word	0x74616564
  14599c:	68636174 	.word	0x68636174
  1459a0:	00000000 	.word	0x00000000
  1459a4:	5049776c 	.word	0x5049776c
  1459a8:	3a74694b 	.word	0x3a74694b
  1459ac:	2d656420 	.word	0x2d656420
  1459b0:	61747461 	.word	0x61747461
  1459b4:	64206863 	.word	0x64206863
  1459b8:	63697665 	.word	0x63697665
  1459bc:	73252065 	.word	0x73252065
  1459c0:	0000000a 	.word	0x0000000a
  1459c4:	61666564 	.word	0x61666564
  1459c8:	00746c75 	.word	0x00746c75
  1459cc:	5049776c 	.word	0x5049776c
  1459d0:	3a74694b 	.word	0x3a74694b
  1459d4:	74657320 	.word	0x74657320
  1459d8:	65687420 	.word	0x65687420
  1459dc:	66656420 	.word	0x66656420
  1459e0:	746c7561 	.word	0x746c7561
  1459e4:	76656420 	.word	0x76656420
  1459e8:	20656369 	.word	0x20656369
  1459ec:	00007325 	.word	0x00007325
  1459f0:	74617473 	.word	0x74617473
  1459f4:	00007375 	.word	0x00007375
  1459f8:	5049776c 	.word	0x5049776c
  1459fc:	3a74694b 	.word	0x3a74694b
  145a00:	65687420 	.word	0x65687420
  145a04:	61747320 	.word	0x61747320
  145a08:	20737574 	.word	0x20737574
  145a0c:	7420666f 	.word	0x7420666f
  145a10:	61206568 	.word	0x61206568
  145a14:	63617474 	.word	0x63617474
  145a18:	20646568 	.word	0x20646568
  145a1c:	69766564 	.word	0x69766564
  145a20:	20736563 	.word	0x20736563
  145a24:	66207361 	.word	0x66207361
  145a28:	6f6c6c6f 	.word	0x6f6c6c6f
  145a2c:	00007377 	.word	0x00007377

00145a30 <__func__.9889>:
  145a30:	63617473 75725f6b 0000006e              stack_run...

00145a3c <__FUNCTION__.6247>:
  145a3c:	6e616863 5f6c656e 5f646d63 76636572     channel_cmd_recv
  145a4c:	00000000                                ....

00145a50 <__FUNCTION__.6253>:
  145a50:	6e616863 5f6c656e 5f646d63 6c706572     channel_cmd_repl
  145a60:	00000079                                y...

00145a64 <__FUNCTION__.6242>:
  145a64:	6e616863 5f6c656e 5f646d63 646e6573     channel_cmd_send
  145a74:	00000000 3a207325 6c696146 206f7420     ....%s :Fail to 
  145a84:	6f6c6c61 65746163 73206120 65726168     allocate a share
  145a94:	656d2064 79726f6d 735f2021 6b5f6d68     d memory! _shm_k
  145aa4:	25207965 000a646c 20656854 6f6c6c61     ey %ld..The allo
  145ab4:	65746163 68732064 64657261 6d656d20     cated shared mem
  145ac4:	2079726f 73656f64 2074276e 65766168     ory doesn't have
  145ad4:	76206120 64696c61 64646120 73736572      a valid address
  145ae4:	00000021                                !...

00145ae8 <__func__.6282>:
  145ae8:	6e616863 5f6c656e 706d6f63 5f65736f     channel_compose_
  145af8:	00646d63 6e616863 206c656e 30203d3e     cmd.channel >= 0
  145b08:	00000000 68746575 7672735f 00000000     ....ueth_srv....
  145b18:	68746575 746e695f 00000000 6e65706f     ueth_int....open
  145b28:	20732520 6c696166 000a6465               %s failed..

00145b34 <__FUNCTION__.5856>:
  145b34:	6e616863 5f6c656e 5f646d63 76636572     channel_cmd_recv
  145b44:	00000000                                ....

00145b48 <__FUNCTION__.5845>:
  145b48:	6e616863 5f6c656e 5f646d63 646e6573     channel_cmd_send
  145b58:	6365725f 00000076                       _recv...

00145b60 <unet_socket_ops>:
  145b60:	00108e28 00108ea4 00108ed0 00108f08     (...............
  145b70:	00108f38 00108f70 00108fac 0010905c     8...p.......\...
  145b80:	001090f0 00109138 00109180 001091b0     ....8...........
  145b90:	001091e8 001048ec 00000000              .....H......

00145b9c <unet_netdb_ops>:
  145b9c:	00109290 001093d0 00109400 00109440     ............@...

00145bac <unet_inet_family>:
  145bac:	00000002 00000002 00145b60 00145b9c     ........`[...[..
  145bbc:	6474656e 00007665                       netdev..

00145bc4 <__FUNCTION__.7159>:
  145bc4:	5f6c6173 74656e75 74656e5f 5f766564     sal_unet_netdev_
  145bd4:	5f746573 695f6670 006f666e 20766564     set_pf_info.dev 
  145be4:	52203d21 554e5f54 00004c4c 2d766564     != RT_NULL..dev-
  145bf4:	7261703e 2e746e65 65707974 203d3d20     >parent.type == 
  145c04:	4f5f5452 63656a62 6c435f74 5f737361     RT_Object_Class_
  145c14:	69766544 00006563 69206f54 6974696e     Device..To initi
  145c24:	7a696c61 65642065 65636976 2073253a     alize device:%s 
  145c34:	6c696166 202e6465 20656854 6f727265     failed. The erro
  145c44:	6f632072 69206564 6c252073 00000a64     r code is %ld...

00145c54 <__FUNCTION__.6035>:
  145c54:	68746575 7665645f 5f656369 65726e75     ueth_device_unre
  145c64:	74736967 00007265                       gister..

00145c6c <__FUNCTION__.6044>:
  145c6c:	68746575 7665645f 5f656369 74696e69     ueth_device_init
  145c7c:	00000000                                ....

00145c80 <__FUNCTION__.6049>:
  145c80:	68746575 7665645f 5f656369 736f6c63     ueth_device_clos
  145c90:	00000065                                e...

00145c94 <__FUNCTION__.6055>:
  145c94:	68746575 7665645f 5f656369 746e6f63     ueth_device_cont
  145ca4:	006c6f72 6474656e 00007665 656d616e     rol.netdev..name
  145cb4:	00000000 31335b1b 2f455b6d 6474656e     .....[31m[E/netd
  145cc4:	205d7665 00000000 20656854 7774656e     ev] ....The netw
  145cd4:	206b726f 65746e69 63616672 65642065     ork interface de
  145ce4:	65636976 29732528 746f6e20 70757320     vice(%s) not sup
  145cf4:	74726f70 206f7420 20746573 74617473     port to set stat
  145d04:	002e7375 6d305b1b 0000000a 20656854     us...[0m....The 
  145d14:	7774656e 206b726f 65746e69 63616672     network interfac
  145d24:	65642065 65636976 29732528 746f6e20     e device(%s) not
  145d34:	70757320 74726f70 206f7420 20746573      support to set 
  145d44:	50434844 61747320 2e737574 00000000     DHCP status.....
  145d54:	615f7069 00726464 20656854 7774656e     ip_addr.The netw
  145d64:	206b726f 65746e69 63616672 65642065     ork interface de
  145d74:	65636976 29732528 746f6e20 70757320     vice(%s) not sup
  145d84:	74726f70 206f7420 20746573 61205049     port to set IP a
  145d94:	65726464 002e7373 20656854 7774656e     ddress..The netw
  145da4:	206b726f 65746e69 63616672 65642065     ork interface de
  145db4:	65636976 29732528 43484420 61632050     vice(%s) DHCP ca
  145dc4:	69626170 7974696c 20736920 62616e65     pability is enab
  145dd4:	202c656c 20746f6e 70707573 2074726f     le, not support 
  145de4:	20746573 61205049 65726464 002e7373     set IP address..
  145df4:	6d74656e 006b7361 20656854 7774656e     netmask.The netw
  145e04:	206b726f 65746e69 63616672 65642065     ork interface de
  145e14:	65636976 29732528 746f6e20 70757320     vice(%s) not sup
  145e24:	74726f70 206f7420 20746573 6d74656e     port to set netm
  145e34:	206b7361 72646461 2e737365 00000000     ask address.....
  145e44:	20656854 7774656e 206b726f 65746e69     The network inte
  145e54:	63616672 65642065 65636976 29732528     rface device(%s)
  145e64:	43484420 61632050 69626170 7974696c      DHCP capability
  145e74:	20736920 62616e65 202c656c 20746f6e      is enable, not 
  145e84:	70707573 2074726f 20746573 6d74656e     support set netm
  145e94:	206b7361 72646461 2e737365 00000000     ask address.....
  145ea4:	00007767 20656854 7774656e 206b726f     gw..The network 
  145eb4:	65746e69 63616672 65642065 65636976     interface device
  145ec4:	29732528 746f6e20 70757320 74726f70     (%s) not support
  145ed4:	206f7420 20746573 65746167 20796177      to set gateway 
  145ee4:	72646461 2e737365 00000000 20656854     address.....The 
  145ef4:	7774656e 206b726f 65746e69 63616672     network interfac
  145f04:	65642065 65636976 29732528 43484420     e device(%s) DHC
  145f14:	61632050 69626170 7974696c 20736920     P capability is 
  145f24:	62616e65 202c656c 20746f6e 70707573     enable, not supp
  145f34:	2074726f 20746573 65746167 20796177     ort set gateway 
  145f44:	72646461 2e737365 00000000 5f736e64     address.....dns_
  145f54:	76726573 00007265 20656854 626d756e     server..The numb
  145f64:	6f207265 4e442066 65732053 72657672     er of DNS server
  145f74:	64252873 65732029 78652074 64656563     s(%d) set exceed
  145f84:	68742073 616d2065 756d6978 756e206d     s the maximum nu
  145f94:	7265626d 29642528 0000002e 20656854     mber(%d)....The 
  145fa4:	7774656e 206b726f 65746e69 63616672     network interfac
  145fb4:	65642065 65636976 29732528 746f6e20     e device(%s) not
  145fc4:	70757320 74726f70 206f7420 20746573      support to set 
  145fd4:	20534e44 76726573 61207265 65726464     DNS server addre
  145fe4:	002e7373 74617473 635f7375 626c6c61     ss..status_callb
  145ff4:	006b6361 72646461 6c61635f 6361626c     ack.addr_callbac
  146004:	0000006b                                k...

00146008 <__FUNCTION__.6920>:
  146008:	6474656e 725f7665 73696765 00726574     netdev_register.

00146018 <__FUNCTION__.6929>:
  146018:	6474656e 755f7665 6765726e 65747369     netdev_unregiste
  146028:	00000072                                r...

0014602c <__FUNCTION__.6975>:
  14602c:	6474656e 665f7665 6c696d61 65675f79     netdev_family_ge
  14603c:	00000074                                t...

00146040 <__FUNCTION__.6982>:
  146040:	6474656e 735f7665 755f7465 00000070     netdev_set_up...

00146050 <__FUNCTION__.6986>:
  146050:	6474656e 735f7665 645f7465 006e776f     netdev_set_down.

00146060 <__FUNCTION__.6991>:
  146060:	6474656e 645f7665 5f706368 62616e65     netdev_dhcp_enab
  146070:	0064656c                                led.

00146074 <__FUNCTION__.6996>:
  146074:	6474656e 735f7665 695f7465 64646170     netdev_set_ipadd
  146084:	00000072                                r...

00146088 <__FUNCTION__.7001>:
  146088:	6474656e 735f7665 6e5f7465 616d7465     netdev_set_netma
  146098:	00006b73                                sk..

0014609c <__FUNCTION__.7006>:
  14609c:	6474656e 735f7665 675f7465 00000077     netdev_set_gw...

001460ac <__FUNCTION__.7012>:
  1460ac:	6474656e 735f7665 645f7465 735f736e     netdev_set_dns_s
  1460bc:	65767265 00000072                       erver...

001460c4 <__FUNCTION__.7017>:
  1460c4:	6474656e 735f7665 735f7465 75746174     netdev_set_statu
  1460d4:	61635f73 61626c6c 00006b63              s_callback..

001460e0 <__FUNCTION__.7022>:
  1460e0:	6474656e 735f7665 615f7465 5f726464     netdev_set_addr_
  1460f0:	6c6c6163 6b636162 00000000              callback....

001460fc <__FUNCTION__.7027>:
  1460fc:	6474656e 6c5f7665 6c5f776f 6c657665     netdev_low_level
  14610c:	7465735f 6170695f 00726464              _set_ipaddr.

00146118 <__FUNCTION__.7032>:
  146118:	6474656e 6c5f7665 6c5f776f 6c657665     netdev_low_level
  146128:	7465735f 74656e5f 6b73616d 00000000     _set_netmask....

00146138 <__FUNCTION__.7037>:
  146138:	6474656e 6c5f7665 6c5f776f 6c657665     netdev_low_level
  146148:	7465735f 0077675f                       _set_gw.

00146150 <__FUNCTION__.7044>:
  146150:	6474656e 6c5f7665 6c5f776f 6c657665     netdev_low_level
  146160:	7465735f 736e645f 7265735f 00726576     _set_dns_server.
  146170:	00000030                                0...

00146174 <__FUNCTION__.5841>:
  146174:	6474656e 695f7665 64613470 615f7264     netdev_ip4addr_a
  146184:	006e6f74 31335b1b 2f455b6d 2e6c6173     ton..[31m[E/sal.
  146194:	5d746b73 00000020 6d206f4e 726f6d65     skt] ...No memor
  1461a4:	6f662079 6f732072 74656b63 62617420     y for socket tab
  1461b4:	0a2e656c 00000000 6d305b1b 0000000a     le.......[0m....
  1461c4:	5f6c6173 6b636f6c 00000000 32335b1b     sal_lock.....[32
  1461d4:	2f495b6d 2e6c6173 5d746b73 00000020     m[I/sal.skt] ...
  1461e4:	6b636f53 41207465 72747362 69746361     Socket Abstracti
  1461f4:	4c206e6f 72657961 696e6920 6c616974     on Layer initial
  146204:	20657a69 63637573 2e737365 00000000     ize success.....
  146214:	6b6e696c 2d74722e 65726874 6f2e6461     link.rt-thread.o
  146224:	00006772 20706553 32203031 00323230     rg..Sep 10 2022.
  146234:	00007325 006e614a 00626546 0072614d     %s..Jan.Feb.Mar.
  146244:	00727041 0079614d 006e754a 006c754a     Apr.May.Jun.Jul.
  146254:	00677541 00706553 0074634f 00766f4e     Aug.Sep.Oct.Nov.
  146264:	00636544 3e2d7473 6b636f73 5b737465     Dec.st->sockets[
  146274:	6b636f73 2d5d7465 67616d3e 3d206369     socket]->magic =
  146284:	4153203d 4f535f4c 54454b43 47414d5f     = SAL_SOCKET_MAG
  146294:	00004349 00000030 20746f6e 646e6966     IC..0...not find
  1462a4:	74656e20 6b726f77 746e6920 61667265      network interfa
  1462b4:	64206563 63697665 79622065 6f727020     ce device by pro
  1462c4:	6f636f74 6166206c 796c696d 29642528     tocol family(%d)
  1462d4:	0000002e 6b636f73 203d2120 4e5f5452     ....sock != RT_N
  1462e4:	004c4c55 2077654e 6b636f73 72207465     ULL.New socket r
  1462f4:	73696765 65726574 61662064 64656c69     egistered failed
  146304:	6572202c 6e727574 72726520 2520726f     , return error %
  146314:	00002e64 656d616e 00000000 204c4153     d...name....SAL 
  146324:	6b636f73 70207465 6f746f72 206c6f63     socket protocol 
  146334:	696d6166 6920796c 7475706e 69616620     family input fai
  146344:	2c64656c 74657220 206e7275 6f727265     led, return erro
  146354:	64252072 0000002e                       r %d....

0014635c <__FUNCTION__.6969>:
  14635c:	5f6c6173 5f746567 6b636f73 00007465     sal_get_socket..

0014636c <__FUNCTION__.6974>:
  14636c:	5f6c6173 6b636f6c 00000000              sal_lock....

00146378 <__FUNCTION__.7032>:
  146378:	6b636f73 645f7465 74656c65 00000065     socket_delete...

00146388 <__FUNCTION__.7057>:
  146388:	5f6c6173 646e6962 00000000 6c207325     sal_bind....%s l
  146398:	20656e69 73206425 74646e65 7265206f     ine %d sendto er
  1463a8:	0a726f72 00000000                       ror.....

001463b0 <__func__.6506>:
  1463b0:	74656e75 6e65735f 006f7464 20736664     unet_sendto.dfs 
  1463c0:	65726c61 20796461 74696e69 00000a2e     already init....
  1463d0:	6f6c7366 00006b63 6f6c6466 00006b63     fslock..fdlock..
  1463e0:	00000030 20534644 6e206466 69207765     0...DFS fd new i
  1463f0:	61662073 64656c69 6f432021 20646c75     s failed! Could 
  146400:	20746f6e 6e756f66 6e612064 706d6520     not found an emp
  146410:	66207974 6e652064 2e797274 00000000     ty fd entry.....
  146420:	20746466 4e203d21 004c4c55 735f6466     fdt != NULL.fd_s
  146430:	2d746f6c 67616d3e 3d206369 4644203d     lot->magic == DF
  146440:	44465f53 47414d5f 00004349              S_FD_MAGIC..

0014644c <__FUNCTION__.6409>:
  14644c:	5f736664 6b636f6c 00000000              dfs_lock....

00146458 <__FUNCTION__.6417>:
  146458:	5f736664 6c5f6466 006b636f              dfs_fd_lock.

00146464 <__FUNCTION__.6470>:
  146464:	5f746466 725f6466 61656c65 00006573     fdt_fd_release..
  146474:	5f736664 0072676d                       dfs_mgr.

0014647c <_net_fops>:
  14647c:	0010a408 0010a284 0010a2f8 0010a380     ................
  14648c:	0010a460 7069776c 73797320 206d6574     `...lwip system 
  14649c:	65726c61 20796461 74696e69 00000a2e     already init....
  1464ac:	656e6f64 00000000 6c696146 74206465     done....Failed t
  1464bc:	7263206f 65746165 6d657320 6f687061     o create semapho
  1464cc:	00006572 76726573 73656369 49776c2f     re..services/lwI
  1464dc:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  1464ec:	2f637273 68637261 7379732f 6372615f     src/arch/sys_arc
  1464fc:	00632e68 69706374 626d5f70 6d69745f     h.c.tcpip_mb_tim
  14650c:	00007265 006d6573 64257325 00000000     er..sem.%s%d....
  14651c:	0000756d 786f626d 00000000 6d5f7472     mu..mbox....rt_m
  14652c:	65725f62 72207663 72757465 2064656e     b_recv returned 
  14653c:	68746977 72726520 0021726f 3d212074     with error!.t !=
  14654c:	5f545220 4c4c554e 00000000 7373410a      RT_NULL.....Ass
  14655c:	69747265 203a6e6f 69206425 7325206e     ertion: %d in %s
  14656c:	0000000a 00000030                       ....0...

00146574 <__FUNCTION__.7531>:
  146574:	5f737973 65726874 6e5f6461 00007765     sys_thread_new..

00146584 <__FUNCTION__.7543>:
  146584:	5f737973 68637261 7373615f 00747265     sys_arch_assert.
  146594:	65657266 20676e69 6e6e6f63 74697720     freeing conn wit
  1465a4:	74756f68 65726620 676e6965 62637020     hout freeing pcb
  1465b4:	00000000 76726573 73656369 49776c2f     ....services/lwI
  1465c4:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  1465d4:	2f637273 2f697061 5f697061 2e62696c     src/api/api_lib.
  1465e4:	00000063 6e6e6f63 73616820 206f6e20     c...conn has no 
  1465f4:	76636572 786f626d 00000000 6e6e6f63     recvmbox....conn
  146604:	63613e2d 74706563 786f626d 6f687320     ->acceptmbox sho
  146614:	6e646c75 65207427 74736978 00000000     uldn't exist....
  146624:	6e6e6f63 73616820 206f6e20 635f706f     conn has no op_c
  146634:	6c706d6f 64657465 00000000 6374656e     ompleted....netc
  146644:	5f6e6e6f 61746567 3a726464 766e6920     onn_getaddr: inv
  146654:	64696c61 6e6f6320 0000006e 6374656e     alid conn...netc
  146664:	5f6e6e6f 61746567 3a726464 766e6920     onn_getaddr: inv
  146674:	64696c61 64646120 00000072 6374656e     alid addr...netc
  146684:	5f6e6e6f 61746567 3a726464 766e6920     onn_getaddr: inv
  146694:	64696c61 726f7020 00000074 6374656e     alid port...netc
  1466a4:	5f6e6e6f 646e6962 6e69203a 696c6176     onn_bind: invali
  1466b4:	6f632064 00006e6e 6374656e 5f6e6e6f     d conn..netconn_
  1466c4:	6e6e6f63 3a746365 766e6920 64696c61     connect: invalid
  1466d4:	6e6f6320 0000006e 6374656e 5f6e6e6f      conn...netconn_
  1466e4:	63736964 656e6e6f 203a7463 61766e69     disconnect: inva
  1466f4:	2064696c 6e6e6f63 00000000 6374656e     lid conn....netc
  146704:	5f6e6e6f 7473696c 203a6e65 61766e69     onn_listen: inva
  146714:	2064696c 6e6e6f63 00000000 6374656e     lid conn....netc
  146724:	5f6e6e6f 65636361 203a7470 61766e69     onn_accept: inva
  146734:	2064696c 6e696f70 00726574 6374656e     lid pointer.netc
  146744:	5f6e6e6f 65636361 203a7470 61766e69     onn_accept: inva
  146754:	2064696c 6e6e6f63 00000000 6374656e     lid conn....netc
  146764:	5f6e6e6f 76636572 6e69203a 696c6176     onn_recv: invali
  146774:	6f702064 65746e69 00000072 6374656e     d pointer...netc
  146784:	5f6e6e6f 76636572 6e69203a 696c6176     onn_recv: invali
  146794:	6f632064 00006e6e 6374656e 5f6e6e6f     d conn..netconn_
  1467a4:	76636572 6e69203a 696c6176 65722064     recv: invalid re
  1467b4:	626d7663 0000786f 20667562 4e203d21     cvmbox..buf != N
  1467c4:	004c4c55 3d212070 4c554e20 0000004c     ULL.p != NULL...
  1467d4:	6374656e 5f6e6e6f 646e6573 6e69203a     netconn_send: in
  1467e4:	696c6176 6f632064 00006e6e 6374656e     valid conn..netc
  1467f4:	5f6e6e6f 74697277 69203a65 6c61766e     onn_write: inval
  146804:	63206469 006e6e6f 6374656e 5f6e6e6f     id conn.netconn_
  146814:	74697277 69203a65 6c61766e 63206469     write: invalid c
  146824:	2d6e6e6f 7079743e 00000065 6374656e     onn->type...netc
  146834:	5f6e6e6f 736f6c63 69203a65 6c61766e     onn_close: inval
  146844:	63206469 006e6e6f 6374656e 5f6e6e6f     id conn.netconn_
  146854:	6e696f6a 61656c5f 675f6576 70756f72     join_leave_group
  146864:	6e69203a 696c6176 6f632064 00006e6e     : invalid conn..
  146874:	6374656e 5f6e6e6f 68746567 6274736f     netconn_gethostb
  146884:	6d616e79 69203a65 6c61766e 6e206469     yname: invalid n
  146894:	00656d61 6374656e 5f6e6e6f 68746567     ame.netconn_geth
  1468a4:	6274736f 6d616e79 69203a65 6c61766e     ostbyname: inval
  1468b4:	61206469 00726464 76726573 73656369     id addr.services
  1468c4:	49776c2f 74694b50 69776c2f 2e322d70     /lwIPKit/lwip-2.
  1468d4:	2f322e30 2f637273 2f697061 5f697061     0.2/src/api/api_
  1468e4:	2e67736d 00000063 76636572 7064755f     msg.c...recv_udp
  1468f4:	73756d20 61682074 61206576 62637020      must have a pcb
  146904:	67726120 6e656d75 00000074 76636572      argument...recv
  146914:	7064755f 73756d20 61682074 61206576     _udp must have a
  146924:	7261206e 656d7567 0000746e 76636572     n argument..recv
  146934:	7064755f 6572203a 66207663 7720726f     _udp: recv for w
  146944:	676e6f72 62637020 00000021 76636572     rong pcb!...recv
  146954:	7063745f 73756d20 61682074 61206576     _tcp must have a
  146964:	62637020 67726120 6e656d75 00000074      pcb argument...
  146974:	76636572 7063745f 73756d20 61682074     recv_tcp must ha
  146984:	61206576 7261206e 656d7567 0000746e     ve an argument..
  146994:	76636572 7063745f 6572203a 66207663     recv_tcp: recv f
  1469a4:	7720726f 676e6f72 62637020 00000021     or wrong pcb!...
  1469b4:	6e6e6f63 203d2120 4c4c554e 00000000     conn != NULL....
  1469c4:	6e6e6f63 75633e2d 6e657272 736d5f74     conn->current_ms
  1469d4:	3d212067 4c554e20 0000004c 76616e69     g != NULL...inav
  1469e4:	2064696c 635f706f 6c706d6f 64657465     lid op_completed
  1469f4:	6d65735f 00000000 6e6e6f63 75633e2d     _sem....conn->cu
  146a04:	6e657272 736d5f74 3d3d2067 4c554e20     rrent_msg == NUL
  146a14:	0000004c 5f626370 3a77656e 62637020     L...pcb_new: pcb
  146a24:	726c6120 79646165 6c6c6120 7461636f      already allocat
  146a34:	00006465 6374656e 5f6e6e6f 6f6c6c61     ed..netconn_allo
  146a44:	75203a63 6665646e 64656e69 74656e20     c: undefined net
  146a54:	6e6e6f63 7079745f 00000065 20424350     conn_type...PCB 
  146a64:	7473756d 20656220 6c616564 61636f6c     must be dealloca
  146a74:	20646574 7374756f 20656469 73696874     ted outside this
  146a84:	6e756620 6f697463 0000006e 76636572      function...recv
  146a94:	786f626d 73756d20 65622074 61656420     mbox must be dea
  146aa4:	636f6c6c 64657461 66656220 2065726f     llocated before 
  146ab4:	6c6c6163 20676e69 73696874 6e756620     calling this fun
  146ac4:	6f697463 0000006e 65636361 626d7470     ction...acceptmb
  146ad4:	6d20786f 20747375 64206562 6c6c6165     ox must be deall
  146ae4:	7461636f 62206465 726f6665 61632065     ocated before ca
  146af4:	6e696c6c 68742067 66207369 74636e75     lling this funct
  146b04:	006e6f69 61766e69 2064696c 6e6e6f63     ion.invalid conn
  146b14:	00000000 73696874 20736920 20726f66     ....this is for 
  146b24:	20706374 6374656e 736e6e6f 6c6e6f20     tcp netconns onl
  146b34:	00000079 6e6e6f63 73756d20 65622074     y...conn must be
  146b44:	206e6920 74617473 454e2065 4e4f4354      in state NETCON
  146b54:	4c435f4e 0045534f 20626370 65726c61     N_CLOSE.pcb alre
  146b64:	20796461 736f6c63 00006465 736f6c43     ady closed..Clos
  146b74:	20676e69 696c2061 6e657473 62637020     ing a listen pcb
  146b84:	79616d20 746f6e20 69616620 0000216c      may not fail!..
  146b94:	20727265 45203d21 4f5f5252 0000004b     err != ERR_OK...
  146ba4:	6374656e 206e6e6f 74617473 72652065     netconn state er
  146bb4:	00726f72 636f6c62 676e696b 6e6f6320     ror.blocking con
  146bc4:	7463656e 206e6920 676f7270 73736572     nect in progress
  146bd4:	00000000 65726c61 20796461 74697277     ....already writ
  146be4:	20676e69 6320726f 69736f6c 0000676e     ing or closing..
  146bf4:	74617473 00002165 6e6e6f63 74733e2d     state!..conn->st
  146c04:	20657461 4e203d3d 4f435445 435f4e4e     ate == NETCONN_C
  146c14:	454e4e4f 00005443 6e6f6328 633e2d6e     ONNECT..(conn->c
  146c24:	65727275 6d5f746e 21206773 554e203d     urrent_msg != NU
  146c34:	20294c4c 63207c7c 2d6e6e6f 5f6e693e     LL) || conn->in_
  146c44:	5f6e6f6e 636f6c62 676e696b 6e6f635f     non_blocking_con
  146c54:	7463656e 00000000 636f6c62 676e696b     nect....blocking
  146c64:	6e6f6320 7463656e 61747320 65206574      connect state e
  146c74:	726f7272 00000000 61766e49 2064696c     rror....Invalid 
  146c84:	6374656e 206e6e6f 65707974 00000000     netconn type....
  146c94:	6e6e6f63 74733e2d 20657461 4e203d3d     conn->state == N
  146ca4:	4f435445 575f4e4e 45544952 00000000     ETCONN_WRITE....
  146cb4:	6e6e6f63 63703e2d 63742e62 3d212070     conn->pcb.tcp !=
  146cc4:	4c554e20 0000004c 6e6e6f63 72773e2d      NULL...conn->wr
  146cd4:	5f657469 7366666f 3c207465 6e6f6320     ite_offset < con
  146ce4:	633e2d6e 65727275 6d5f746e 3e2d6773     n->current_msg->
  146cf4:	2e67736d 656c2e77 0000006e 7069776c     msg.w.len...lwip
  146d04:	74656e5f 6e6e6f63 5f6f645f 74697277     _netconn_do_writ
  146d14:	726f6d65 69203a65 6c61766e 6c206469     emore: invalid l
  146d24:	74676e65 00002168 2d67736d 67736d3e     ength!..msg->msg
  146d34:	6c2e772e 21206e65 0030203d 61766e69     .w.len != 0.inva
  146d44:	2064696c 6374656e 5f6e6e6f 65707974     lid netconn_type
  146d54:	00000000                                ....

00146d58 <err_to_errno_table>:
  146d58:	00000000 0000000c 00000069 0000000b     ........i.......
  146d68:	00000071 00000073 00000016 0000000b     q...s...........
  146d78:	00000062 00000072 0000006a 0000006b     b...r...j...k...
  146d88:	ffffffff 00000067 00000068 0000006b     ....g...h...k...
  146d98:	00000005 76726573 73656369 49776c2f     ....services/lwI
  146da8:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  146db8:	2f637273 2f697061 6274656e 632e6675     src/api/netbuf.c
  146dc8:	00000000 6274656e 615f6675 636f6c6c     ....netbuf_alloc
  146dd8:	6e69203a 696c6176 75622064 00000066     : invalid buf...
  146de8:	63656863 6874206b 66207461 74737269     check that first
  146df8:	75627020 61632066 6f68206e 7320646c      pbuf can hold s
  146e08:	00657a69 6274656e 665f6675 3a656572     ize.netbuf_free:
  146e18:	766e6920 64696c61 66756220 00000000      invalid buf....
  146e28:	6274656e 725f6675 203a6665 61766e69     netbuf_ref: inva
  146e38:	2064696c 00667562 6274656e 635f6675     lid buf.netbuf_c
  146e48:	6e696168 6e69203a 696c6176 65682064     hain: invalid he
  146e58:	00006461 6274656e 635f6675 6e696168     ad..netbuf_chain
  146e68:	6e69203a 696c6176 61742064 00006c69     : invalid tail..
  146e78:	6274656e 645f6675 3a617461 766e6920     netbuf_data: inv
  146e88:	64696c61 66756220 00000000 6274656e     alid buf....netb
  146e98:	645f6675 3a617461 766e6920 64696c61     uf_data: invalid
  146ea8:	74616420 72747061 00000000 6274656e      dataptr....netb
  146eb8:	645f6675 3a617461 766e6920 64696c61     uf_data: invalid
  146ec8:	6e656c20 00000000 6274656e 6e5f6675      len....netbuf_n
  146ed8:	3a747865 766e6920 64696c61 66756220     ext: invalid buf
  146ee8:	00000000 6274656e 665f6675 74737269     ....netbuf_first
  146ef8:	6e69203a 696c6176 75622064 00000066     : invalid buf...
  146f08:	656d616e 206e656c 74207369 6c206f6f     namelen is too l
  146f18:	00676e6f 76726573 73656369 49776c2f     ong.services/lwI
  146f28:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  146f38:	2f637273 2f697061 6474656e 00632e62     src/api/netdb.c.
  146f48:	61746f74 69735f6c 3c20657a 454e203d     total_size <= NE
  146f58:	5f424454 4d454c45 5a49535f 70203a45     TDB_ELEM_SIZE: p
  146f68:	7361656c 65722065 74726f70 69687420     lease report thi
  146f78:	00002173 6377656e 206e6e6f 4e203d21     s!..newconn != N
  146f88:	004c4c55 76726573 73656369 49776c2f     ULL.services/lwI
  146f98:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  146fa8:	2f637273 2f697061 6b636f73 2e737465     src/api/sockets.
  146fb8:	00000063 61766e69 2064696c 6b636f73     c...invalid sock
  146fc8:	69207465 7865646e 00000000 72646461     et index....addr
  146fd8:	6c617620 62206469 61207475 6c726464      valid but addrl
  146fe8:	4e206e65 004c4c55 7069776c 6e69625f     en NULL.lwip_bin
  146ff8:	69203a64 6c61766e 61206469 65726464     d: invalid addre
  147008:	00007373 6b636f73 616c3e2d 61647473     ss..sock->lastda
  147018:	3d206174 554e203d 00004c4c 7069776c     ta == NULL..lwip
  147028:	6e6f635f 7463656e 6e69203a 696c6176     _connect: invali
  147038:	64612064 73657264 00000073 20667562     d address...buf 
  147048:	4e203d21 004c4c55 61766e69 2064696c     != NULL.invalid 
  147058:	79706f63 2c6e656c 6e656c20 756f7720     copylen, len wou
  147068:	7520646c 7265646e 776f6c66 00000000     ld underflow....
  147078:	7069776c 6e65735f 67736d64 6e69203a     lwip_sendmsg: in
  147088:	696c6176 736d2064 72646867 00000000     valid msghdr....
  147098:	7069776c 6e65735f 67736d64 6e69203a     lwip_sendmsg: in
  1470a8:	696c6176 736d2064 72646867 766f6920     valid msghdr iov
  1470b8:	00000000 7069776c 6e65735f 67736d64     ....lwip_sendmsg
  1470c8:	6e69203a 696c6176 736d2064 72646867     : invalid msghdr
  1470d8:	6d616e20 00000065 5f766f69 206e656c      name...iov_len 
  1470e8:	3175203c 00745f36 7069776c 6e65735f     < u16_t.lwip_sen
  1470f8:	3a6f7464 7a697320 756d2065 66207473     dto: size must f
  147108:	69207469 3175206e 00745f36 7069776c     it in u16_t.lwip
  147118:	6e65735f 3a6f7464 766e6920 64696c61     _sendto: invalid
  147128:	64646120 73736572 00000000 6165726e      address....nrea
  147138:	3e207964 0030203d 6b636f73 65733e2d     dy >= 0.sock->se
  147148:	7463656c 6961775f 676e6974 30203e20     lect_waiting > 0
  147158:	00000000 656c6573 635f7463 72702e62     ....select_cb.pr
  147168:	3d207665 554e203d 00004c4c 656c6573     ev == NULL..sele
  147178:	635f7463 72702e62 21207665 554e203d     ct_cb.prev != NU
  147188:	00004c4c 6e6b6e75 206e776f 6e657665     LL..unknown even
  147198:	00000074 69706374 68745f70 64616572     t...tcpip_thread
  1471a8:	6e69203a 696c6176 656d2064 67617373     : invalid messag
  1471b8:	00000065 76726573 73656369 49776c2f     e...services/lwI
  1471c8:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  1471d8:	2f637273 2f697061 69706374 00632e70     src/api/tcpip.c.
  1471e8:	61766e49 2064696c 786f626d 00000000     Invalid mbox....
  1471f8:	6c696166 74206465 7263206f 65746165     failed to create
  147208:	70637420 745f7069 61657268 626d2064      tcpip_thread mb
  147218:	0000786f 6c696166 74206465 7263206f     ox..failed to cr
  147228:	65746165 636f6c20 63745f6b 5f706970     eate lock_tcpip_
  147238:	65726f63 00000000 69706374 00000070     core....tcpip...
  147248:	7778797a 73747576 6f707172 6b6c6d6e     zyxwvutsrqponmlk
  147258:	6768696a 63646566 38396162 34353637     jihgfedcba987654
  147268:	30313233 34333231 38373635 63626139     3210123456789abc
  147278:	67666564 6b6a6968 6f6e6d6c 73727170     defghijklmnopqrs
  147288:	77767574 007a7978                       tuvwxyz.

00147290 <dns_mquery_v4group>:
  147290:	fb0000e0 20736e64 76726573 6f207265     ....dns server o
  1472a0:	6f207475 72612066 00796172 76726573     ut of array.serv
  1472b0:	73656369 49776c2f 74694b50 69776c2f     ices/lwIPKit/lwi
  1472c0:	2e322d70 2f322e30 2f637273 65726f63     p-2.0.2/src/core
  1472d0:	736e642f 0000632e 61727261 6e692079     /dns.c..array in
  1472e0:	20786564 2074756f 6220666f 646e756f     dex out of bound
  1472f0:	00000073 6e6b6e75 206e776f 5f736e64     s...unknown dns_
  147300:	6c626174 6e652065 20797274 74617473     table entry stat
  147310:	00003a65 656c6564 6d206574 00000065     e:..delete me...
  147320:	76726573 73656369 49776c2f 74694b50     services/lwIPKit
  147330:	69776c2f 2e322d70 2f322e30 2f637273     /lwip-2.0.2/src/
  147340:	65726f63 656e692f 68635f74 6d75736b     core/inet_chksum
  147350:	0000632e 5f574152 00424350              .c..RAW_PCB.

0014735c <memp_RAW_PCB>:
  14735c:	00147354 0014f0c0 0004001c 0018cd88     Ts..............
  14736c:	0014f0d0 5f504455 00424350              ....UDP_PCB.

00147378 <memp_UDP_PCB>:
  147378:	00147370 0014f0d4 00080028 0057581c     ps......(....XW.
  147388:	0014f0e4 5f504354 00424350              ....TCP_PCB.

00147394 <memp_TCP_PCB>:
  147394:	0014738c 0014f0e8 000800a4 00576008     .s...........`W.
  1473a4:	0014f0f8 5f504354 5f424350 5453494c     ....TCP_PCB_LIST
  1473b4:	00004e45                                EN..

001473b8 <memp_TCP_PCB_LISTEN>:
  1473b8:	001473a8 0014f0fc 00080020 005752bc     .s...... ....RW.
  1473c8:	0014f10c 5f504354 00474553              ....TCP_SEG.

001473d4 <memp_TCP_SEG>:
  1473d4:	001473cc 0014f110 20000010 0018ceac     .s......... ....
  1473e4:	0014f120 53414552 54414453 00000041      ...REASSDATA...

001473f4 <memp_REASSDATA>:
  1473f4:	001473e8 0014f124 000a0020 00575520     .s..$... ... UW.
  147404:	0014f134 47415246 5542505f 00000046     4...FRAG_PBUF...

00147414 <memp_FRAG_PBUF>:
  147414:	00147408 0014f138 000f0018 00528eb4     .t..8.........R.
  147424:	0014f148 4254454e 00004655              H...NETBUF..

00147430 <memp_NETBUF>:
  147430:	00147428 0014f14c 08000010 00150764     (t..L.......d...
  147440:	0014f15c 4354454e 004e4e4f              \...NETCONN.

0014744c <memp_NETCONN>:
  14744c:	00147444 0014f160 00080040 00575ac0     Dt..`...@....ZW.
  14745c:	0014f170 49504354 534d5f50 50415f47     p...TCPIP_MSG_AP
  14746c:	00000049                                I...

00147470 <memp_TCPIP_MSG_API>:
  147470:	00147460 0014f174 08000010 005292b4     `t..t.........R.
  147480:	0014f184 49504354 534d5f50 4e495f47     ....TCPIP_MSG_IN
  147490:	00544b50                                PKT.

00147494 <memp_TCPIP_MSG_INPKT>:
  147494:	00147484 0014f188 08000010 0016e768     .t..........h...
  1474a4:	0014f198 5f505241 55455551 00000045     ....ARP_QUEUE...

001474b4 <memp_ARP_QUEUE>:
  1474b4:	001474a8 0014f19c 001e0008 0018c76c     .t..........l...
  1474c4:	0014f1ac 504d4749 4f52475f 00005055     ....IGMP_GROUP..

001474d4 <memp_IGMP_GROUP>:
  1474d4:	001474c8 0014f1b0 00080010 00575e24     .t..........$^W.
  1474e4:	0014f1c0 5f535953 454d4954 0054554f     ....SYS_TIMEOUT.

001474f4 <memp_SYS_TIMEOUT>:
  1474f4:	001474e8 0014f1c4 00070010 0057668c     .t...........fW.
  147504:	0014f1d4 4454454e 00000042              ....NETDB...

00147510 <memp_NETDB>:
  147510:	00147508 0014f1d8 00010134 00150600     .u......4.......
  147520:	0014f1e8 46554250 4645525f 4d4f522f     ....PBUF_REF/ROM
  147530:	00000000                                ....

00147534 <memp_PBUF>:
  147534:	00147524 0014f1ec 08000030 005472b8     $u......0....rT.
  147544:	0014f1fc 46554250 4f4f505f 0000004c     ....PBUF_POOL...

00147554 <memp_PBUF_POOL>:
  147554:	00147548 0014f200 0800061c 00204eb0     Hu...........N .
  147564:	0014f210                                ....

00147568 <memp_pools>:
  147568:	0014735c 00147378 00147394 001473b8     \s..xs...s...s..
  147578:	001473d4 001473f4 00147414 00147430     .s...s...t..0t..
  147588:	0014744c 00147470 00147494 001474b4     Lt..pt...t...t..
  147598:	001474d4 001474f4 00147510 00147534     .t...t...u..4u..
  1475a8:	00147554 76726573 73656369 49776c2f     Tu..services/lwI
  1475b8:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  1475c8:	2f637273 65726f63 6d656d2f 00632e70     src/core/memp.c.
  1475d8:	65746564 64657463 6d656d20 766f2070     detected memp ov
  1475e8:	6c667265 6920776f 6f70206e 00206c6f     erflow in pool .
	...
  147658:	65746564 64657463 6d656d20 6e752070     detected memp un
  147668:	66726564 20776f6c 70206e69 206c6f6f     derflow in pool 
	...
  1476d8:	706d656d 6c616d5f 3a636f6c 6d656d20     memp_malloc: mem
  1476e8:	72702070 7265706f 6120796c 6e67696c     p properly align
  1476f8:	00006465 61766e69 2064696c 6c6f6f70     ed..invalid pool
  147708:	73656420 00000063 706d656d 6c616d5f      desc...memp_mal
  147718:	3a636f6c 70797420 203c2065 504d454d     loc: type < MEMP
  147728:	58414d5f 00000000 706d656d 6572665f     _MAX....memp_fre
  147738:	6d203a65 70206d65 65706f72 20796c72     e: mem properly 
  147748:	67696c61 0064656e 706d656d 6572665f     aligned.memp_fre
  147758:	74203a65 20657079 454d203c 4d5f504d     e: type < MEMP_M
  147768:	00005841 69206f4e 2074696e 636e7566     AX..No init func
  147778:	6e6f6974 76696720 00006e65 76726573     tion given..serv
  147788:	73656369 49776c2f 74694b50 69776c2f     ices/lwIPKit/lwi
  147798:	2e322d70 2f322e30 2f637273 65726f63     p-2.0.2/src/core
  1477a8:	74656e2f 632e6669 00000000 66206669     /netif.c....if f
  1477b8:	74737269 203d2120 4c4c554e 616c202c     irst != NULL, la
  1477c8:	6d207473 20747375 6f736c61 20656220     st must also be 
  1477d8:	4e203d21 004c4c55 75676f62 62702073     != NULL.bogus pb
  1477e8:	203a6675 206e656c 74203d21 6c5f746f     uf: len != tot_l
  1477f8:	62206e65 6e207475 20747865 4e203d3d     en but next == N
  147808:	214c4c55 00000000 756f6873 6e20646c     ULL!....should n
  147818:	6220746f 756e2065 73206c6c 65636e69     ot be null since
  147828:	72696620 21207473 616c203d 00217473      first != last!.
  147838:	66756270 6c6c615f 203a636f 20646162     pbuf_alloc: bad 
  147848:	66756270 79616c20 00007265 76726573     pbuf layer..serv
  147858:	73656369 49776c2f 74694b50 69776c2f     ices/lwIPKit/lwi
  147868:	2e322d70 2f322e30 2f637273 65726f63     p-2.0.2/src/core
  147878:	7562702f 00632e66 66756270 6c6c615f     /pbuf.c.pbuf_all
  147888:	203a636f 66756270 3e2d7020 6c796170     oc: pbuf p->payl
  147898:	2064616f 706f7270 796c7265 696c6120     oad properly ali
  1478a8:	64656e67 00000000 63656863 2d70206b     gned....check p-
  1478b8:	7961703e 64616f6c 70202b20 656c3e2d     >payload + p->le
  1478c8:	6f64206e 6e207365 6f20746f 66726576     n does not overf
  1478d8:	20776f6c 66756270 00000000 46554250     low pbuf....PBUF
  1478e8:	4f4f505f 55425f4c 5a495346 756d2045     _POOL_BUFSIZE mu
  1478f8:	62207473 69622065 72656767 61687420     st be bigger tha
  147908:	454d206e 4c415f4d 4d4e4749 00544e45     n MEM_ALIGNMENT.
  147918:	5f6d6572 206e656c 616d203c 31755f78     rem_len < max_u1
  147928:	00745f36 66756270 6c6c615f 203a636f     6_t.pbuf_alloc: 
  147938:	66756270 3e2d7120 6c796170 2064616f     pbuf q->payload 
  147948:	706f7270 796c7265 696c6120 64656e67     properly aligned
  147958:	00000000 66756270 6c6c615f 203a636f     ....pbuf_alloc: 
  147968:	66756270 61703e2d 616f6c79 72702064     pbuf->payload pr
  147978:	7265706f 6120796c 6e67696c 00006465     operly aligned..
  147988:	66756270 6c6c615f 203a636f 6f727265     pbuf_alloc: erro
  147998:	756f656e 79742073 00006570 66756270     neous type..pbuf
  1479a8:	6c6c615f 6465636f 7375635f 3a6d6f74     _alloced_custom:
  1479b8:	64616220 75627020 616c2066 00726579      bad pbuf layer.
  1479c8:	66756270 6165725f 636f6c6c 2070203a     pbuf_realloc: p 
  1479d8:	4e203d21 004c4c55 66756270 6165725f     != NULL.pbuf_rea
  1479e8:	636f6c6c 6173203a 7020656e 79743e2d     lloc: sane p->ty
  1479f8:	00006570 776f7267 6d203c20 755f7861     pe..grow < max_u
  147a08:	745f3631 00000000 66756270 6165725f     16_t....pbuf_rea
  147a18:	636f6c6c 2071203a 4e203d21 004c4c55     lloc: q != NULL.
  147a28:	5f6d656d 6d697274 74657220 656e7275     mem_trim returne
  147a38:	20712064 4e203d3d 004c4c55 3d212070     d q == NULL.p !=
  147a48:	4c554e20 0000004c 72636e69 6e656d65      NULL...incremen
  147a58:	616d5f74 74696e67 20656475 70203d3c     t_magnitude <= p
  147a68:	656c3e2d 0000006e 20646162 66756270     ->len...bad pbuf
  147a78:	70797420 00000065 66756270 6572665f      type...pbuf_fre
  147a88:	73203a65 20656e61 65707974 00000000     e: sane type....
  147a98:	66756270 6572665f 70203a65 65723e2d     pbuf_free: p->re
  147aa8:	203e2066 00000030 3e2d6370 74737563     f > 0...pc->cust
  147ab8:	665f6d6f 5f656572 636e7566 6e6f6974     om_free_function
  147ac8:	203d2120 4c4c554e 00000000 66756270      != NULL....pbuf
  147ad8:	66657220 65766f20 6f6c6672 00000077      ref overflow...
  147ae8:	21206828 554e203d 20294c4c 28202626     (h != NULL) && (
  147af8:	3d212074 4c554e20 2820294c 676f7270     t != NULL) (prog
  147b08:	6d6d6172 76207265 616c6f69 20736574     rammer violates 
  147b18:	29495041 00000000 743e2d70 6c5f746f     API)....p->tot_l
  147b28:	3d206e65 2d70203d 6e656c3e 666f2820     en == p->len (of
  147b38:	73616c20 62702074 69206675 6863206e      last pbuf in ch
  147b48:	296e6961 00000000 6e3e2d70 20747865     ain)....p->next 
  147b58:	4e203d3d 004c4c55 743e2d70 6c5f746f     == NULL.p->tot_l
  147b68:	3d206e65 2d70203d 6e656c3e 71202b20     en == p->len + q
  147b78:	6f743e2d 656c5f74 0000006e 743e2d70     ->tot_len...p->t
  147b88:	6c5f746f 3d206e65 2d70203d 6e656c3e     ot_len == p->len
  147b98:	00000000 66756270 706f635f 74203a79     ....pbuf_copy: t
  147ba8:	65677261 6f6e2074 69622074 6e652067     arget not big en
  147bb8:	6867756f 206f7420 646c6f68 756f7320     ough to hold sou
  147bc8:	00656372 7366666f 745f7465 3d3c206f     rce.offset_to <=
  147bd8:	745f7020 6c3e2d6f 00006e65 7366666f      p_to->len..offs
  147be8:	665f7465 206d6f72 70203d3c 6f72665f     et_from <= p_fro
  147bf8:	6c3e2d6d 00006e65 6f745f70 203d2120     m->len..p_to != 
  147c08:	4c4c554e 00000000 66756270 706f635f     NULL....pbuf_cop
  147c18:	20292879 73656f64 746f6e20 6c6c6120     y() does not all
  147c28:	7020776f 656b6361 75712074 73657565     ow packet queues
  147c38:	00000021 66756270 706f635f 61705f79     !...pbuf_copy_pa
  147c48:	61697472 69203a6c 6c61766e 62206469     rtial: invalid b
  147c58:	00006675 66756270 706f635f 61705f79     uf..pbuf_copy_pa
  147c68:	61697472 69203a6c 6c61766e 64206469     rtial: invalid d
  147c78:	70617461 00007274 66756270 6b61745f     ataptr..pbuf_tak
  147c88:	69203a65 6c61766e 62206469 00006675     e: invalid buf..
  147c98:	66756270 6b61745f 69203a65 6c61766e     pbuf_take: inval
  147ca8:	64206469 70617461 00007274 66756270     id dataptr..pbuf
  147cb8:	6b61745f 62203a65 6e206675 6c20746f     _take: buf not l
  147cc8:	65677261 6f6e6520 00686775 66756270     arge enough.pbuf
  147cd8:	6b61745f 69203a65 6c61766e 70206469     _take: invalid p
  147ce8:	00667562 20646964 20746f6e 79706f63     buf.did not copy
  147cf8:	6c6c6120 74616420 00000061 66756270      all data...pbuf
  147d08:	706f635f 61662079 64656c69 00000000     _copy failed....
  147d18:	20776172 20626370 76636572 6c616320     raw pcb recv cal
  147d28:	6361626c 6c61206b 65726574 62702064     lback altered pb
  147d38:	70206675 6f6c7961 70206461 746e696f     uf payload point
  147d48:	77207265 6f687469 65207475 6e697461     er without eatin
  147d58:	61702067 74656b63 00000000 76726573     g packet....serv
  147d68:	73656369 49776c2f 74694b50 69776c2f     ices/lwIPKit/lwi
  147d78:	2e322d70 2f322e30 2f637273 65726f63     p-2.0.2/src/core
  147d88:	7761722f 0000632e 276e6143 65722074     /raw.c..Can't re
  147d98:	726f7473 65682065 72656461 20657720     store header we 
  147da8:	7473756a 6d657220 6465766f 00000021     just removed!...
  147db8:	0a73250a 00000009 74696d78 6825203a     .%s.....xmit: %h
  147dc8:	00090a75 76636572 6825203a 00090a75     u...recv: %hu...
  147dd8:	203a7766 0a756825 00000009 706f7264     fw: %hu.....drop
  147de8:	6825203a 00090a75 656b6863 203a7272     : %hu...chkerr: 
  147df8:	0a756825 00000009 656e656c 203a7272     %hu.....lenerr: 
  147e08:	0a756825 00000009 656d656d 203a7272     %hu.....memerr: 
  147e18:	0a756825 00000009 72657472 25203a72     %hu.....rterr: %
  147e28:	090a7568 00000000 746f7270 3a727265     hu......proterr:
  147e38:	75682520 0000090a 6574706f 203a7272      %hu....opterr: 
  147e48:	0a756825 00000009 3a727265 75682520     %hu.....err: %hu
  147e58:	0000090a 68636163 74696865 6825203a     ....cachehit: %h
  147e68:	00000a75 765f7872 25203a31 090a7568     u...rx_v1: %hu..
  147e78:	00000000 675f7872 70756f72 6825203a     ....rx_group: %h
  147e88:	00090a75 675f7872 72656e65 203a6c61     u...rx_general: 
  147e98:	0a756825 00000009 725f7872 726f7065     %hu.....rx_repor
  147ea8:	25203a74 090a7568 00000000 6a5f7874     t: %hu......tx_j
  147eb8:	3a6e696f 75682520 0000090a 6c5f7874     oin: %hu....tx_l
  147ec8:	65766165 6825203a 00090a75 725f7874     eave: %hu...tx_r
  147ed8:	726f7065 25203a74 000a7568 4d454d0a     eport: %hu...MEM
  147ee8:	0a732520 00000009 69617661 25203a6c      %s.....avail: %
  147ef8:	090a756c 00000000 64657375 6c25203a     lu......used: %l
  147f08:	00090a75 3a78616d 756c2520 0000090a     u...max: %lu....
  147f18:	3a727265 756c2520 0000000a 5359530a     err: %lu.....SYS
  147f28:	0000090a 2e6d6573 64657375 2520203a     ....sem.used:  %
  147f38:	090a756c 00000000 2e6d6573 3a78616d     lu......sem.max:
  147f48:	25202020 090a756c 00000000 2e6d6573        %lu......sem.
  147f58:	3a727265 25202020 090a756c 00000000     err:   %lu......
  147f68:	6574756d 73752e78 203a6465 0a756c25     mutex.used: %lu.
  147f78:	00000009 6574756d 616d2e78 20203a78     ....mutex.max:  
  147f88:	0a756c25 00000009 6574756d 72652e78     %lu.....mutex.er
  147f98:	20203a72 0a756c25 00000009 786f626d     r:  %lu.....mbox
  147fa8:	6573752e 20203a64 0a756c25 00000009     .used:  %lu.....
  147fb8:	786f626d 78616d2e 2020203a 0a756c25     mbox.max:   %lu.
  147fc8:	00000009 786f626d 7272652e 2020203a     ....mbox.err:   
  147fd8:	0a756c25 00000000 4b4e494c 00000000     %lu.....LINK....
  147fe8:	41485445 00005052 465f5049 00474152     ETHARP..IP_FRAG.
  147ff8:	00005049 504d4749 00000000 504d4349     IP..IGMP....ICMP
  148008:	00000000 00504455 00504354 50414548     ....UDP.TCP.HEAP
  148018:	00000000 534f4c43 00004445 5453494c     ....CLOSED..LIST
  148028:	00004e45 5f4e5953 544e4553 00000000     EN..SYN_SENT....
  148038:	5f4e5953 44564352 00000000 41545345     SYN_RCVD....ESTA
  148048:	53494c42 00444548 5f4e4946 54494157     BLISHED.FIN_WAIT
  148058:	0000315f 5f4e4946 54494157 0000325f     _1..FIN_WAIT_2..
  148068:	534f4c43 41575f45 00005449 534f4c43     CLOSE_WAIT..CLOS
  148078:	00474e49 5453414c 4b43415f 00000000     ING.LAST_ACK....
  148088:	454d4954 4941575f 00000054              TIME_WAIT...

00148094 <tcp_state_str>:
  148094:	0014801c 00148024 0014802c 00148038     ....$...,...8...
  1480a4:	00148044 00148050 0014805c 00148068     D...P...\...h...
  1480b4:	00148074 0014807c 00148088              t...|.......

001480c0 <tcp_backoff>:
  1480c0:	04030201 07070605 07070707 00000007     ................

001480d0 <tcp_persist_backoff>:
  1480d0:	180c0603 00786030                       ....0`x.

001480d8 <tcp_pcb_lists>:
  1480d8:	00576a38 00576a3c 00576a30 00576a40     8jW.<jW.0jW.@jW.
  1480e8:	20626370 4e203d21 004c4c55 76726573     pcb != NULL.serv
  1480f8:	73656369 49776c2f 74694b50 69776c2f     ices/lwIPKit/lwi
  148108:	2e322d70 2f322e30 2f637273 65726f63     p-2.0.2/src/core
  148118:	7063742f 0000632e 2d626370 6174733e     /tcp.c..pcb->sta
  148128:	3d206574 494c203d 4e455453 00000000     te == LISTEN....
  148138:	2d626370 616c663e 26207367 5f465420     pcb->flags & TF_
  148148:	4c435852 4445534f 00000000 276e6f64     RXCLOSED....don'
  148158:	61632074 74206c6c 615f7063 74726f62     t call tcp_abort
  148168:	7063742f 6162615f 6e6f646e 726f6620     /tcp_abandon for
  148178:	73696c20 2d6e6574 73626370 00000000      listen-pcbs....
  148188:	5f706374 646e6962 6163203a 6e6f206e     tcp_bind: can on
  148198:	6220796c 20646e69 73206e69 65746174     ly bind in state
  1481a8:	4f4c4320 00444553 5f706374 7473696c      CLOSED.tcp_list
  1481b8:	203a6e65 20626370 65726c61 20796461     en: pcb already 
  1481c8:	6e6e6f63 65746365 00000064 5f77656e     connected...new_
  1481d8:	5f766372 5f6e6e61 20646e77 30203d3c     rcv_ann_wnd <= 0
  1481e8:	66666678 00000066 276e6f64 61632074     xffff...don't ca
  1481f8:	74206c6c 725f7063 65766365 6f662064     ll tcp_recved fo
  148208:	696c2072 6e657473 6263702d 00000073     r listen-pcbs...
  148218:	5f706374 76636572 203a6465 206e656c     tcp_recved: len 
  148228:	70617277 20646570 5f766372 0a646e77     wrapped rcv_wnd.
  148238:	00000000 5f706374 6e6e6f63 3a746365     ....tcp_connect:
  148248:	6e616320 6c6e6f20 6f632079 63656e6e      can only connec
  148258:	72662074 73206d6f 65746174 4f4c4320     t from state CLO
  148268:	00444553 5f706374 776f6c73 3a726d74     SED.tcp_slowtmr:
  148278:	74636120 20657669 2d626370 6174733e      active pcb->sta
  148288:	21206574 4c43203d 4445534f 0000000a     te != CLOSED....
  148298:	5f706374 776f6c73 3a726d74 74636120     tcp_slowtmr: act
  1482a8:	20657669 2d626370 6174733e 21206574     ive pcb->state !
  1482b8:	494c203d 4e455453 0000000a 5f706374     = LISTEN....tcp_
  1482c8:	776f6c73 3a726d74 74636120 20657669     slowtmr: active 
  1482d8:	2d626370 6174733e 21206574 4954203d     pcb->state != TI
  1482e8:	572d454d 0a544941 00000000 5f706374     ME-WAIT.....tcp_
  1482f8:	776f6c73 3a726d74 64696d20 20656c64     slowtmr: middle 
  148308:	20706374 74203d21 615f7063 76697463     tcp != tcp_activ
  148318:	63705f65 00007362 5f706374 776f6c73     e_pcbs..tcp_slow
  148328:	3a726d74 72696620 70207473 3d206263     tmr: first pcb =
  148338:	6374203d 63615f70 65766974 6263705f     = tcp_active_pcb
  148348:	00000073 5f706374 776f6c73 3a726d74     s...tcp_slowtmr:
  148358:	4d495420 41572d45 70205449 3e2d6263      TIME-WAIT pcb->
  148368:	74617473 3d3d2065 4d495420 41572d45     state == TIME-WA
  148378:	00005449 5f706374 776f6c73 3a726d74     IT..tcp_slowtmr:
  148388:	64696d20 20656c64 20706374 74203d21      middle tcp != t
  148398:	745f7063 63705f77 00007362 5f706374     cp_tw_pcbs..tcp_
  1483a8:	776f6c73 3a726d74 72696620 70207473     slowtmr: first p
  1483b8:	3d206263 6374203d 77745f70 6263705f     cb == tcp_tw_pcb
  1483c8:	00000073 61766e69 2064696c 74617473     s...invalid stat
  1483d8:	00000065 61766e69 2064696c 6b636f73     e...invalid sock
  1483e8:	73207465 65746174 726f6620 63657220     et state for rec
  1483f8:	61632076 61626c6c 00006b63 61766e69     v callback..inva
  148408:	2064696c 6b636f73 73207465 65746174     lid socket state
  148418:	726f6620 6e657320 61632074 61626c6c      for sent callba
  148428:	00006b63 61766e69 2064696c 6b636f73     ck..invalid sock
  148438:	73207465 65746174 726f6620 72726520     et state for err
  148448:	6c616320 6361626c 0000006b 61766e69      callback...inva
  148458:	2064696c 6b636f73 73207465 65746174     lid socket state
  148468:	726f6620 6c6f7020 0000006c 65736e75      for poll...unse
  148478:	7320746e 656d6765 2073746e 6b61656c     nt segments leak
  148488:	00676e69 63616e75 2064656b 6d676573     ing.unacked segm
  148498:	73746e65 61656c20 676e696b 00000000     ents leaking....
  1484a8:	65736f6f 65732071 6e656d67 6c207374     ooseq segments l
  1484b8:	696b6165 0000676e 6e3e2d70 20747865     eaking..p->next 
  1484c8:	4e203d21 004c4c55 76726573 73656369     != NULL.services
  1484d8:	49776c2f 74694b50 69776c2f 2e322d70     /lwIPKit/lwip-2.
  1484e8:	2f322e30 2f637273 65726f63 7063742f     0.2/src/core/tcp
  1484f8:	2e6e695f 00000063 6c3e2d70 3d206e65     _in.c...p->len =
  148508:	0030203d 743e2d70 6c5f746f 3d206e65     = 0.p->tot_len =
  148518:	2d70203d 78656e3e 743e2d74 6c5f746f     = p->next->tot_l
  148528:	00006e65 5f706374 75706e69 61203a74     en..tcp_input: a
  148538:	76697463 63702065 733e2d62 65746174     ctive pcb->state
  148548:	203d2120 534f4c43 00004445 5f706374      != CLOSED..tcp_
  148558:	75706e69 61203a74 76697463 63702065     input: active pc
  148568:	733e2d62 65746174 203d2120 454d4954     b->state != TIME
  148578:	4941572d 00000054 5f706374 75706e69     -WAIT...tcp_inpu
  148588:	61203a74 76697463 63702065 733e2d62     t: active pcb->s
  148598:	65746174 203d2120 5453494c 00004e45     tate != LISTEN..
  1485a8:	5f706374 75706e69 70203a74 3e2d6263     tcp_input: pcb->
  1485b8:	7478656e 203d2120 20626370 66656228     next != pcb (bef
  1485c8:	2065726f 68636163 00002965 5f706374     ore cache)..tcp_
  1485d8:	75706e69 70203a74 3e2d6263 7478656e     input: pcb->next
  1485e8:	203d2120 20626370 74666128 63207265      != pcb (after c
  1485f8:	65686361 00000029 5f706374 75706e69     ache)...tcp_inpu
  148608:	54203a74 2d454d49 54494157 62637020     t: TIME-WAIT pcb
  148618:	74733e2d 20657461 54203d3d 2d454d49     ->state == TIME-
  148628:	54494157 00000000 2d626370 6665723e     WAIT....pcb->ref
  148638:	64657375 7461645f 3d3d2061 4c554e20     used_data == NUL
  148648:	0000004c 5f706374 75706e69 70203a74     L...tcp_input: p
  148658:	3e2d6263 74617473 3d212065 4f4c4320     cb->state != CLO
  148668:	00444553 2d626370 646e733e 6575715f     SED.pcb->snd_que
  148678:	656c6575 203e206e 00000030 73206f6e     uelen > 0...no s
  148688:	656d6765 7420746e 7266206f 00006565     egment to free..
  148698:	2d626370 73696c3e 656e6574 613e2d72     pcb->listener->a
  1486a8:	70656363 3d212074 4c554e20 0000004c     ccept != NULL...
  1486b8:	5f706374 65636572 3a657669 6f727720     tcp_receive: wro
  1486c8:	7320676e 65746174 00000000 2d626370     ng state....pcb-
  1486d8:	646e733e 6575715f 656c6575 3d3e206e     >snd_queuelen >=
  1486e8:	75627020 6c635f66 6e286e65 2d747865      pbuf_clen(next-
  1486f8:	0029703e 5f706374 65636572 3a657669     >p).tcp_receive:
  148708:	6c617620 71206469 65756575 6e656c20      valid queue len
  148718:	00687467 65736e69 20702e67 4e203d21     gth.inseg.p != N
  148728:	004c4c55 61736e69 6f20656e 65736666     ULL.insane offse
  148738:	00002174 66756270 6f6f7420 6f687320     t!..pbuf too sho
  148748:	00217472 66756270 6165685f 20726564     rt!.pbuf_header 
  148758:	6c696166 00006465 5f706374 65636572     failed..tcp_rece
  148768:	3a657669 67657320 746e656d 746f6e20     ive: segment not
  148778:	69727420 64656d6d 726f6320 74636572      trimmed correct
  148788:	7420796c 6372206f 6e775f76 00000a64     ly to rcv_wnd...
  148798:	5f706374 65636572 3a657669 67657320     tcp_receive: seg
  1487a8:	746e656d 746f6e20 69727420 64656d6d     ment not trimmed
  1487b8:	726f6320 74636572 7420796c 6f6f206f      correctly to oo
  1487c8:	20716573 75657571 00000a65 5f706374     seq queue...tcp_
  1487d8:	65636572 3a657669 70637420 206e656c     receive: tcplen 
  1487e8:	6372203e 6e775f76 00000a64 5f706374     > rcv_wnd...tcp_
  1487f8:	65636572 3a657669 736f6f20 74207165     receive: ooseq t
  148808:	656c7063 203e206e 5f766372 0a646e77     cplen > rcv_wnd.
  148818:	00000000 63656863 6874206b 66207461     ....check that f
  148828:	74737269 75627020 61632066 6f68206e     irst pbuf can ho
  148838:	7320646c 63757274 63742074 64685f70     ld struct tcp_hd
  148848:	00000072 76726573 73656369 49776c2f     r...services/lwI
  148858:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  148868:	2f637273 65726f63 7063742f 74756f5f     src/core/tcp_out
  148878:	0000632e 743e2d70 6c5f746f 3e206e65     .c..p->tot_len >
  148888:	706f203d 6e656c74 00000000 6465656e     = optlen....need
  148898:	636e7520 6e696168 70206465 00667562      unchained pbuf.
  1488a8:	5f706374 74697277 70203a65 73667562     tcp_write: pbufs
  1488b8:	206e6f20 75657571 3e3d2065 20746120      on queue => at 
  1488c8:	7361656c 6e6f2074 75712065 20657565     least one queue 
  1488d8:	2d6e6f6e 74706d65 00000079 5f706374     non-empty...tcp_
  1488e8:	74697277 6e203a65 6270206f 20736675     write: no pbufs 
  1488f8:	71206e6f 65756575 203e3d20 68746f62     on queue => both
  148908:	65757120 20736575 74706d65 00000079      queues empty...
  148918:	5f706374 74697277 61203a65 3d206772     tcp_write: arg =
  148928:	554e203d 28204c4c 676f7270 6d6d6172     = NULL (programm
  148938:	76207265 616c6f69 20736574 29495041     er violates API)
  148948:	00000000 5f73736d 61636f6c 7369206c     ....mss_local is
  148958:	6f6f7420 616d7320 00006c6c 6f636e69      too small..inco
  148968:	7369736e 746e6574 65766f20 7a697372     nsistent oversiz
  148978:	73762065 7073202e 00656361 6f636e69     e vs. space.inco
  148988:	7369736e 746e6574 65766f20 7a697372     nsistent oversiz
  148998:	73762065 656c202e 0000006e 5f706374     e vs. len...tcp_
  1489a8:	74697277 52203a65 70204d4f 73667562     write: ROM pbufs
  1489b8:	6e616320 20746f6e 6f206562 73726576      cannot be overs
  1489c8:	64657a69 00000000 65736e75 6f5f746e     ized....unsent_o
  1489d8:	73726576 20657a69 6d73696d 68637461     versize mismatch
  1489e8:	63702820 753e2d62 6e65736e 73692074      (pcb->unsent is
  1489f8:	4c554e20 0000294c 5f706374 74697277      NULL)..tcp_writ
  148a08:	63203a65 6b636568 61687420 69662074     e: check that fi
  148a18:	20747372 66756270 6e616320 6c6f6820     rst pbuf can hol
  148a28:	68742064 6f632065 656c706d 73206574     d the complete s
  148a38:	656c6765 0000006e 7265766f 657a6973     eglen...oversize
  148a48:	203d3d20 00000030 76657270 6765735f      == 0...prev_seg
  148a58:	203d2120 4c4c554e 00000000 5f706374      != NULL....tcp_
  148a68:	74697277 63203a65 6f6e6e61 6f632074     write: cannot co
  148a78:	7461636e 74616e65 68772065 70206e65     ncatenate when p
  148a88:	3e2d6263 65736e75 6920746e 6d652073     cb->unsent is em
  148a98:	00797470 5f706374 74697277 65203a65     pty.tcp_write: e
  148aa8:	6e657478 6e6f6973 20666f20 65666572     xtension of refe
  148ab8:	636e6572 65722065 72697571 72207365     rence requires r
  148ac8:	72656665 65636e65 00000000 5f706374     eference....tcp_
  148ad8:	74697277 76203a65 64696c61 65757120     write: valid que
  148ae8:	6c206575 74676e65 00000068 5f706374     ue length...tcp_
  148af8:	75716e65 5f657565 67616c66 6e203a73     enqueue_flags: n
  148b08:	20646565 68746965 54207265 535f5043     eed either TCP_S
  148b18:	6f204e59 43542072 49465f50 6e69204e     YN or TCP_FIN in
  148b28:	616c6620 28207367 676f7270 6d6d6172      flags (programm
  148b38:	76207265 616c6f69 20736574 29495041     er violates API)
  148b48:	00000000 5f706374 75716e65 5f657565     ....tcp_enqueue_
  148b58:	67616c66 63203a73 6b636568 61687420     flags: check tha
  148b68:	69662074 20747372 66756270 6e616320     t first pbuf can
  148b78:	6c6f6820 706f2064 6e656c74 00000000      hold optlen....
  148b88:	2d676573 7063743e 20726468 20746f6e     seg->tcphdr not 
  148b98:	67696c61 0064656e 5f706374 75716e65     aligned.tcp_enqu
  148ba8:	5f657565 67616c66 69203a73 6c61766e     eue_flags: inval
  148bb8:	73206469 656d6765 6c20746e 74676e65     id segment lengt
  148bc8:	00000068 5f706374 75716e65 5f657565     h...tcp_enqueue_
  148bd8:	67616c66 69203a73 6c61766e 71206469     flags: invalid q
  148be8:	65756575 6e656c20 00687467 276e6f64     ueue length.don'
  148bf8:	61632074 74206c6c 6f5f7063 75707475     t call tcp_outpu
  148c08:	6f662074 696c2072 6e657473 6263702d     t for listen-pcb
  148c18:	00000073 20545352 20746f6e 65707865     s...RST not expe
  148c28:	64657463 72656820 00002165              cted here!..

00148c34 <lwip_cyclic_timers>:
  148c34:	000000fa 0011d1d4 000003e8 00132ed8     ................
  148c44:	000003e8 0012db28 0000ea60 0012a768     ....(...`...h...
  148c54:	000001f4 0012a89c 00000064 00130ed4     ........d.......
  148c64:	000003e8 00116cf0 76726573 73656369     .....l..services
  148c74:	49776c2f 74694b50 69776c2f 2e322d70     /lwIPKit/lwip-2.
  148c84:	2f322e30 2f637273 65726f63 6d69742f     0.2/src/core/tim
  148c94:	74756f65 00632e73 5f737973 656d6974     eouts.c.sys_time
  148ca4:	3a74756f 6d697420 74756f65 203d2120     out: timeout != 
  148cb4:	4c4c554e 6f70202c 4d206c6f 5f504d45     NULL, pool MEMP_
  148cc4:	5f535953 454d4954 2054554f 65207369     SYS_TIMEOUT is e
  148cd4:	7974706d 00000000 66756270 6165685f     mpty....pbuf_hea
  148ce4:	20726564 6c696166 000a6465 76726573     der failed..serv
  148cf4:	73656369 49776c2f 74694b50 69776c2f     ices/lwIPKit/lwi
  148d04:	2e322d70 2f322e30 2f637273 65726f63     p-2.0.2/src/core
  148d14:	7064752f 0000632e 63656863 6874206b     /udp.c..check th
  148d24:	66207461 74737269 75627020 61632066     at first pbuf ca
  148d34:	6f68206e 7320646c 63757274 64752074     n hold struct ud
  148d44:	64685f70 00000072                       p_hdr...

00148d4c <ethbroadcast>:
  148d4c:	ffffffff 0000ffff                       ........

00148d54 <ethzero>:
	...
  148d5c:	6974656e 683e2d66 64646177 656c5f72     netif->hwaddr_le
  148d6c:	756d206e 62207473 20362065 20726f66     n must be 6 for 
  148d7c:	65687465 74656e72 74756f5f 21747570     ethernet_output!
  148d8c:	00000000 76726573 73656369 49776c2f     ....services/lwI
  148d9c:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  148dac:	2f637273 6974656e 74652f66 6e726568     src/netif/ethern
  148dbc:	632e7465 00000000 6974656e 00000066     et.c....netif...
  148dcc:	74736f68 00000000 676e6970 7365725f     host....ping_res
  148ddc:	00000070                                p...

00148de0 <lwip_netdev_ops>:
  148de0:	00129200 00129230 00129260 0012932c     ....0...`...,...
  148df0:	00129368 001293c8 00000000 00129688     h...............
  148e00:	7069776c 74656e5f 00006669 6974656e     lwip_netif..neti
  148e10:	3d212066 5f545220 4c4c554e 00000000     f != RT_NULL....
  148e20:	6c6c616d 6e20636f 66697465 69616620     malloc netif fai
  148e30:	0a64656c 00000000 68747472 64616572     led.....rtthread
  148e40:	3230255f 32302578 00000078 69706374     _%02x%02x...tcpi
  148e50:	00000070 20766564 52203d21 554e5f54     p...dev != RT_NU
  148e60:	00004c4c 6d787265 00000062 75736572     LL..erxmb...resu
  148e70:	3d20746c 5452203d 4b4f455f 00000000     lt == RT_EOK....
  148e80:	00787265 6d787465 00000062 7774656e     erx.etxmb...netw
  148e90:	206b726f 65746e69 63616672 616e2065     ork interface na
  148ea0:	7420656d 6c206f6f 21676e6f 00000a0d     me too long!....
  148eb0:	7774656e 206b726f 65746e69 63616672     network interfac
  148ec0:	25203a65 6f6e2073 6f662074 21646e75     e: %s not found!
  148ed0:	00000a0d                                ....

00148ed4 <__FUNCTION__.7805>:
  148ed4:	7069776c 74656e5f 5f766564 676e6970     lwip_netdev_ping
  148ee4:	00000000                                ....

00148ee8 <__FUNCTION__.7817>:
  148ee8:	6474656e 615f7665 00006464              netdev_add..

00148ef4 <__FUNCTION__.7826>:
  148ef4:	6474656e 645f7665 00006c65              netdev_del..

00148f00 <__FUNCTION__.7831>:
  148f00:	6474656e 665f7665 7367616c 6e79735f     netdev_flags_syn
  148f10:	00000063                                c...

00148f14 <__FUNCTION__.7837>:
  148f14:	65687465 74656e72 6c5f6669 6f6b6e69     ethernetif_linko
  148f24:	75707475 00000074                       utput...

00148f2c <__FUNCTION__.7869>:
  148f2c:	5f687465 69766564 6c5f6563 636b6e69     eth_device_linkc
  148f3c:	676e6168 00000065                       hange...

00148f44 <__FUNCTION__.7893>:
  148f44:	5f687465 74737973 645f6d65 63697665     eth_system_devic
  148f54:	6e695f65 705f7469 61766972 00006574     e_init_private..
  148f64:	70636864 636e695f 6263705f 6665725f     dhcp_inc_pcb_ref
  148f74:	6e756f63 3a292874 6d656d20 2079726f     count(): memory 
  148f84:	6b61656c 00000000 76726573 73656369     leak....services
  148f94:	49776c2f 74694b50 69776c2f 2e322d70     /lwIPKit/lwip-2.
  148fa4:	2f322e30 2f637273 65726f63 7670692f     0.2/src/core/ipv
  148fb4:	68642f34 632e7063 00000000 70636864     4/dhcp.c....dhcp
  148fc4:	6263705f 6665725f 6e756f63 3a292874     _pcb_refcount():
  148fd4:	66657220 6e756f63 72652074 00726f72      refcount error.
  148fe4:	6974656e 3d212066 4c554e20 0000004c     netif != NULL...
  148ff4:	70636864 203d2120 4c4c554e 00000000     dhcp != NULL....
  149004:	6974656e 6c612066 64616572 61682079     netif already ha
  149014:	20612073 75727473 64207463 20706368     s a struct dhcp 
  149024:	00746573 6974656e 73692066 746f6e20     set.netif is not
  149034:	2c707520 646c6f20 79747320 7020656c      up, old style p
  149044:	3f74726f 00000000 66756270 6f5f7020     ort?....pbuf p_o
  149054:	77207475 276e7361 72662074 00646565     ut wasn't freed.
  149064:	6c706572 61772079 74276e73 65726620     reply wasn't fre
  149074:	00006465 70636864 6e69625f 6e203a64     ed..dhcp_bind: n
  149084:	66697465 203d2120 4c4c554e 00000000     etif != NULL....
  149094:	70636864 6e69625f 64203a64 20706368     dhcp_bind: dhcp 
  1490a4:	4e203d21 004c4c55 70636864 6f74735f     != NULL.dhcp_sto
  1490b4:	6e203a70 66697465 203d2120 4c4c554e     p: netif != NULL
  1490c4:	00000000 70636864 74706f5f 3a6e6f69     ....dhcp_option:
  1490d4:	63686420 6f3e2d70 6f697470 6f5f736e      dhcp->options_o
  1490e4:	6c5f7475 2b206e65 2b203220 74706f20     ut_len + 2 + opt
  1490f4:	5f6e6f69 206e656c 44203d3c 5f504348     ion_len <= DHCP_
  149104:	4954504f 5f534e4f 004e454c 70636864     OPTIONS_LEN.dhcp
  149114:	74706f5f 5f6e6f69 65747962 6864203a     _option_byte: dh
  149124:	3e2d7063 6974706f 5f736e6f 5f74756f     cp->options_out_
  149134:	206e656c 4844203c 4f5f5043 4f495450     len < DHCP_OPTIO
  149144:	4c5f534e 00004e45 70636864 74706f5f     NS_LEN..dhcp_opt
  149154:	5f6e6f69 726f6873 64203a74 2d706368     ion_short: dhcp-
  149164:	74706f3e 736e6f69 74756f5f 6e656c5f     >options_out_len
  149174:	32202b20 203d3c20 50434844 54504f5f      + 2 <= DHCP_OPT
  149184:	534e4f49 4e454c5f 00000000 70636864     IONS_LEN....dhcp
  149194:	74706f5f 5f6e6f69 676e6f6c 6864203a     _option_long: dh
  1491a4:	3e2d7063 6974706f 5f736e6f 5f74756f     cp->options_out_
  1491b4:	206e656c 2034202b 44203d3c 5f504348     len + 4 <= DHCP_
  1491c4:	4954504f 5f534e4f 004e454c 50434844     OPTIONS_LEN.DHCP
  1491d4:	6f68203a 616e7473 6920656d 6f742073     : hostname is to
  1491e4:	6f6c206f 0021676e 206e656c 34203d3d     o long!.len == 4
  1491f4:	00000000 206e656c 64203d3e 646f6365     ....len >= decod
  149204:	656c5f65 0000006e 206e656c 34202525     e_len...len %% 4
  149214:	203d3d20 00000030 206e656c 31203d3d      == 0...len == 1
  149224:	00000000 7265766f 64616f6c 206e6920     ....overload in 
  149234:	656c6966 616e732f 0000656d 63656863     file/sname..chec
  149244:	6564206b 65646f63 7864695f 00000000     k decode_idx....
  149254:	6f636564 6c5f6564 25206e65 20342025     decode_len %% 4 
  149264:	30203d3d 00000000 61766e69 2064696c     == 0....invalid 
  149274:	6f636564 6c5f6564 00006e65 7478656e     decode_len..next
  149284:	75627020 61772066 756e2073 00006c6c      pbuf was null..
  149294:	70636864 6572635f 5f657461 3a67736d     dhcp_create_msg:
  1492a4:	74656e20 21206669 554e203d 00004c4c      netif != NULL..
  1492b4:	70636864 6572635f 5f657461 3a67736d     dhcp_create_msg:
  1492c4:	63686420 3d212070 4c554e20 0000004c      dhcp != NULL...
  1492d4:	70636864 6572635f 5f657461 3a67736d     dhcp_create_msg:
  1492e4:	63686420 703e2d70 74756f5f 203d3d20      dhcp->p_out == 
  1492f4:	4c4c554e 00000000 70636864 6572635f     NULL....dhcp_cre
  149304:	5f657461 3a67736d 63686420 6d3e2d70     ate_msg: dhcp->m
  149314:	6f5f6773 3d207475 554e203d 00004c4c     sg_out == NULL..
  149324:	70636864 6572635f 5f657461 3a67736d     dhcp_create_msg:
  149334:	65686320 74206b63 20746168 73726966      check that firs
  149344:	62702074 63206675 68206e61 20646c6f     t pbuf can hold 
  149354:	75727473 64207463 5f706368 0067736d     struct dhcp_msg.
  149364:	70636864 6c65645f 5f657465 3a67736d     dhcp_delete_msg:
  149374:	63686420 3d212070 4c554e20 0000004c      dhcp != NULL...
  149384:	70636864 6c65645f 5f657465 3a67736d     dhcp_delete_msg:
  149394:	63686420 703e2d70 74756f5f 203d2120      dhcp->p_out != 
  1493a4:	4c4c554e 00000000 70636864 6c65645f     NULL....dhcp_del
  1493b4:	5f657465 3a67736d 63686420 6d3e2d70     ete_msg: dhcp->m
  1493c4:	6f5f6773 21207475 554e203d 00004c4c     sg_out != NULL..
  1493d4:	70636864 74706f5f 5f6e6f69 69617274     dhcp_option_trai
  1493e4:	3a72656c 63686420 3d212070 4c554e20     ler: dhcp != NUL
  1493f4:	0000004c 70636864 74706f5f 5f6e6f69     L...dhcp_option_
  149404:	69617274 3a72656c 63686420 6d3e2d70     trailer: dhcp->m
  149414:	6f5f6773 21207475 554e203d 000a4c4c     sg_out != NULL..
  149424:	70636864 74706f5f 5f6e6f69 69617274     dhcp_option_trai
  149434:	3a72656c 63686420 6f3e2d70 6f697470     ler: dhcp->optio
  149444:	6f5f736e 6c5f7475 3c206e65 43484420     ns_out_len < DHC
  149454:	504f5f50 4e4f4954 454c5f53 00000a4e     P_OPTIONS_LEN...
  149464:	3d212071 4c554e20 0000004c 76726573     q != NULL...serv
  149474:	73656369 49776c2f 74694b50 69776c2f     ices/lwIPKit/lwi
  149484:	2e322d70 2f322e30 2f637273 65726f63     p-2.0.2/src/core
  149494:	7670692f 74652f34 70726168 0000632e     /ipv4/etharp.c..
  1494a4:	703e2d71 203d2120 4c4c554e 00000000     q->p != NULL....
  1494b4:	703e2d72 203d2120 4c4c554e 00000000     r->p != NULL....
  1494c4:	74617473 3d3d2065 48544520 5f505241     state == ETHARP_
  1494d4:	54415453 45505f45 4e49444e 7c7c2047     STATE_PENDING ||
  1494e4:	61747320 3e206574 5445203d 50524148      state >= ETHARP
  1494f4:	4154535f 535f4554 4c424154 00000045     _STATE_STABLE...
  149504:	5f707261 6c626174 5d695b65 3d20712e     arp_table[i].q =
  149514:	554e203d 00004c4c 203c2069 5f505241     = NULL..i < ARP_
  149524:	4c424154 49535f45 0000455a 5f707261     TABLE_SIZE..arp_
  149534:	6c626174 5d695b65 6174732e 3d206574     table[i].state =
  149544:	5445203d 50524148 4154535f 455f4554     = ETHARP_STATE_E
  149554:	5954504d 00000000 6974656e 683e2d66     MPTY....netif->h
  149564:	64646177 656c5f72 3d3d206e 48544520     waddr_len == ETH
  149574:	4157485f 5f524444 004e454c 5f687465     _HWADDR_LEN.eth_
  149584:	20746572 4e203d21 204c4c55 69202626     ret != NULL && i
  149594:	65725f70 3d212074 4c554e20 0000004c     p_ret != NULL...
  1495a4:	64617069 21207264 554e203d 00004c4c     ipaddr != NULL..
  1495b4:	6974656e 3d212066 4c554e20 0000004c     netif != NULL...
  1495c4:	5f687465 20746572 4e203d21 004c4c55     eth_ret != NULL.
  1495d4:	5f707261 6c626174 72615b65 64695f70     arp_table[arp_id
  1495e4:	732e5d78 65746174 203d3e20 41485445     x].state >= ETHA
  1495f4:	535f5052 45544154 4154535f 00454c42     RP_STATE_STABLE.
  149604:	5f707261 6c626174 5d695b65 6174732e     arp_table[i].sta
  149614:	3d206574 4550203d 4e49444e 726f2047     te == PENDING or
  149624:	41545320 00454c42 70206f6e 656b6361      STABLE.no packe
  149634:	75712074 73657565 6c6c6120 6465776f     t queues allowed
  149644:	00000021 63656863 6874206b 66207461     !...check that f
  149654:	74737269 75627020 61632066 6f68206e     irst pbuf can ho
  149664:	7320646c 63757274 74652074 70726168     ld struct etharp
  149674:	7264685f 00000000 6974656e 683e2d66     _hdr....netif->h
  149684:	64646177 656c5f72 756d206e 62207473     waddr_len must b
  149694:	68742065 61732065 6120656d 54452073     e the same as ET
  1496a4:	57485f48 52444441 4e454c5f 726f6620     H_HWADDR_LEN for
  1496b4:	68746520 21707261 00000000 706d6369      etharp!....icmp
  1496c4:	706e695f 203a7475 69766f6d 7220676e     _input: moving r
  1496d4:	61703e2d 616f6c79 6f742064 6d636920     ->payload to icm
  1496e4:	65682070 72656461 69616620 0a64656c     p header failed.
  1496f4:	00000000 76726573 73656369 49776c2f     ....services/lwI
  149704:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  149714:	2f637273 65726f63 7670692f 63692f34     src/core/ipv4/ic
  149724:	632e706d 00000000 706d6369 706e695f     mp.c....icmp_inp
  149734:	203a7475 74736572 6e69726f 726f2067     ut: restoring or
  149744:	6e696769 70206c61 61703e2d 616f6c79     iginal p->payloa
  149754:	61662064 64656c69 0000000a 63656863     d failed....chec
  149764:	6874206b 66207461 74737269 75627020     k that first pbu
  149774:	61632066 6f68206e 6920646c 20706d63     f can hold icmp 
  149784:	7373656d 00656761 76726573 73656369     message.services
  149794:	49776c2f 74694b50 69776c2f 2e322d70     /lwIPKit/lwip-2.
  1497a4:	2f322e30 2f637273 65726f63 7670692f     0.2/src/core/ipv
  1497b4:	67692f34 632e706d 00000000 706d6769     4/igmp.c....igmp
  1497c4:	6f6f6c5f 5f70756b 756f7267 66203a70     _lookup_group: f
  1497d4:	74737269 6f726720 6d207075 20747375     irst group must 
  1497e4:	61206562 79736c6c 6d657473 00000073     be allsystems...
  1497f4:	706d6769 6f6f6c5f 5f70756b 756f7267     igmp_lookup_grou
  149804:	61203a70 65206c6c 70656378 69662074     p: all except fi
  149814:	20747372 756f7267 756d2070 6e207473     rst group must n
  149824:	6220746f 6c612065 7379736c 736d6574     ot be allsystems
  149834:	00000000 706d6769 696f6a5f 6f72676e     ....igmp_joingro
  149844:	203a7075 65747461 2074706d 6a206f74     up: attempt to j
  149854:	206e696f 2d6e6f6e 746c756d 73616369     oin non-multicas
  149864:	64612074 73657264 00000073 706d6769     t address...igmp
  149874:	696f6a5f 6f72676e 203a7075 65747461     _joingroup: atte
  149884:	2074706d 6a206f74 206e696f 736c6c61     mpt to join alls
  149894:	65747379 6120736d 65726464 00007373     ystems address..
  1498a4:	706d6769 696f6a5f 6f72676e 6e5f7075     igmp_joingroup_n
  1498b4:	66697465 7461203a 706d6574 6f742074     etif: attempt to
  1498c4:	696f6a20 6f6e206e 756d2d6e 6369746c      join non-multic
  1498d4:	20747361 72646461 00737365 706d6769     ast address.igmp
  1498e4:	696f6a5f 6f72676e 6e5f7075 66697465     _joingroup_netif
  1498f4:	7461203a 706d6574 6f742074 696f6a20     : attempt to joi
  149904:	6c61206e 7379736c 736d6574 64646120     n allsystems add
  149914:	73736572 00000000 706d6769 696f6a5f     ress....igmp_joi
  149924:	6f72676e 6e5f7075 66697465 7461203a     ngroup_netif: at
  149934:	706d6574 6f742074 696f6a20 6e6f206e     tempt to join on
  149944:	6e6f6e20 4d47492d 656e2050 00666974      non-IGMP netif.
  149954:	706d6769 61656c5f 72676576 3a70756f     igmp_leavegroup:
  149964:	74746120 74706d65 206f7420 7661656c      attempt to leav
  149974:	6f6e2065 756d2d6e 6369746c 20747361     e non-multicast 
  149984:	72646461 00737365 706d6769 61656c5f     address.igmp_lea
  149994:	72676576 3a70756f 74746120 74706d65     vegroup: attempt
  1499a4:	206f7420 7661656c 6c612065 7379736c      to leave allsys
  1499b4:	736d6574 64646120 73736572 00000000     tems address....
  1499c4:	706d6769 61656c5f 72676576 5f70756f     igmp_leavegroup_
  1499d4:	6974656e 61203a66 6d657474 74207470     netif: attempt t
  1499e4:	656c206f 20657661 2d6e6f6e 746c756d     o leave non-mult
  1499f4:	73616369 64612074 73657264 00000073     icast address...
  149a04:	706d6769 61656c5f 72676576 5f70756f     igmp_leavegroup_
  149a14:	6974656e 61203a66 6d657474 74207470     netif: attempt t
  149a24:	656c206f 20657661 736c6c61 65747379     o leave allsyste
  149a34:	6120736d 65726464 00007373 706d6769     ms address..igmp
  149a44:	61656c5f 72676576 5f70756f 6974656e     _leavegroup_neti
  149a54:	61203a66 6d657474 74207470 656c206f     f: attempt to le
  149a64:	20657661 6e206e6f 492d6e6f 20504d47     ave on non-IGMP 
  149a74:	6974656e 00000066 706d6769 6e65735f     netif...igmp_sen
  149a84:	63203a64 6b636568 61687420 69662074     d: check that fi
  149a94:	20747372 66756270 6e616320 6c6f6820     rst pbuf can hol
  149aa4:	74732064 74637572 6d676920 736d5f70     d struct igmp_ms
  149ab4:	00000067 723e2d70 3d206665 0031203d     g...p->ref == 1.
  149ac4:	76726573 73656369 49776c2f 74694b50     services/lwIPKit
  149ad4:	69776c2f 2e322d70 2f322e30 2f637273     /lwip-2.0.2/src/
  149ae4:	65726f63 7670692f 70692f34 00632e34     core/ipv4/ip4.c.
  149af4:	63656863 6874206b 66207461 74737269     check that first
  149b04:	75627020 61632066 6f68206e 7320646c      pbuf can hold s
  149b14:	63757274 70692074 7264685f 00000000     truct ip_hdr....

00149b24 <ip_addr_any>:
  149b24:	00000000                                ....

00149b28 <ip_addr_broadcast>:
  149b28:	ffffffff 61686e75 656c646e 00000064     ....unhandled...
  149b38:	76726573 73656369 49776c2f 74694b50     services/lwIPKit
  149b48:	69776c2f 2e322d70 2f322e30 2f637273     /lwip-2.0.2/src/
  149b58:	65726f63 7670692f 70692f34 64615f34     core/ipv4/ip4_ad
  149b68:	632e7264 00000000 76657270 203d2120     dr.c....prev != 
  149b78:	00727069 76726573 73656369 49776c2f     ipr.services/lwI
  149b88:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  149b98:	2f637273 65726f63 7670692f 70692f34     src/core/ipv4/ip
  149ba8:	72665f34 632e6761 00000000 76657270     4_frag.c....prev
  149bb8:	656e3e2d 3d207478 7069203d 00000072     ->next == ipr...
  149bc8:	66756270 72665f73 20646565 6c63202b     pbufs_freed + cl
  149bd8:	3c206e65 7830203d 66666666 00000000     en <= 0xffff....
  149be8:	725f7069 73736165 7562705f 756f6366     ip_reass_pbufcou
  149bf8:	3e20746e 6c63203d 00006e65 696e6173     nt >= clen..sani
  149c08:	63207974 6b636568 6e696c20 2064656b     ty check linked 
  149c18:	7473696c 00000000 63656863 7266206b     list....check fr
  149c28:	656d6761 2073746e 276e6f64 766f2074     agments don't ov
  149c38:	616c7265 00000070 70206f6e 69766572     erlap...no previ
  149c48:	2073756f 67617266 746e656d 6874202c     ous fragment, th
  149c58:	6d207369 20747375 74206562 66206568     is must be the f
  149c68:	74737269 61726620 6e656d67 00002174     irst fragment!..
  149c78:	696e6173 63207974 6b636568 00000000     sanity check....
  149c88:	696c6176 65746164 7461645f 61726761     validate_datagra
  149c98:	656e3a6d 705f7478 21667562 4c554e3d     m:next_pbuf!=NUL
  149ca8:	0000004c 696c6176 65746164 7461645f     L...validate_dat
  149cb8:	61726761 61643a6d 72676174 65206d61     agram:datagram e
  149cc8:	3d21646e 61746164 6d617267 6e656c20     nd!=datagram len
  149cd8:	00000000 3d212070 4c554e20 0000004c     ....p != NULL...
  149ce8:	20726370 4e203d21 004c4c55 20726370     pcr != NULL.pcr 
  149cf8:	70203d3d 00000000 5f347069 67617266     == p....ip4_frag
  149d08:	64202928 2073656f 20746f6e 70707573     () does not supp
  149d18:	2074726f 6f205049 6f697470 0000736e     ort IP options..
  149d28:	665f7069 28676172 4d203a29 6c612046     ip_frag(): MF al
  149d38:	64616572 65732079 00000074 73696874     ready set...this
  149d48:	65656e20 61207364 75627020 6e692066      needs a pbuf in
  149d58:	656e6f20 65697020 00216563 676e6970      one piece!.ping
  149d68:	7a69735f 73692065 6f6f7420 67696220     _size is too big
  149d78:	00000000 76726573 73656369 49776c2f     ....services/lwI
  149d88:	74694b50 69776c2f 2e322d70 2f322e30     PKit/lwip-2.0.2/
  149d98:	2f637273 73707061 6e69702f 69702f67     src/apps/ping/pi
  149da8:	632e676e 00000000 00003165 63616d65     ng.c....e1..emac
  149db8:	6e695f31 00007274 6d305b1b 642f445b     1_intr...[0m[D/d
  149dc8:	652e7672 5d74656e 00000020 74656e65     rv.enet] ...enet
  149dd8:	6c206425 206b6e69 00007075 6d305b1b     %d link up...[0m
  149de8:	0000000a 74656e65 6c206425 206b6e69     ....enet%d link 
  149df8:	6e776f64 00000000 31335b1b 2f455b6d     down.....[31m[E/
  149e08:	2e767264 74656e65 0000205d 4f525245     drv.enet] ..ERRO
  149e18:	61203a52 636f6c6c 6d656d20 746f6e20     R: alloc mem not
  149e28:	6f6e6520 20686775 20726f66 74656e65      enough for enet
  149e38:	69726420 00726576 4f525245 72203a52      driver.ERROR: r
  149e48:	75622078 70206666 20656761 6f6c6c61     x buff page allo
  149e58:	61662063 64656c69 00000000 4f525245     c failed....ERRO
  149e68:	74203a52 75622078 70206666 20656761     R: tx buff page 
  149e78:	6f6c6c61 61662063 64656c69 00000000     alloc failed....
  149e88:	4f525245 72203a52 64622078 67617020     ERROR: rx bd pag
  149e98:	6c612065 20636f6c 6c696166 00006465     e alloc failed..
  149ea8:	4f525245 74203a52 64622078 67617020     ERROR: tx bd pag
  149eb8:	6c612065 20636f6c 6c696166 00006465     e alloc failed..
  149ec8:	51494e55 495f4555 73692044 25782520     UNIQUE_ID is %x%
  149ed8:	00000078 51494e55 495f4555 68632044     x...UNIQUE_ID ch
  149ee8:	65676e61 206f7420 62203233 20737469     ange to 32 bits 
  149ef8:	00007825 00000070 2074656e 6f727265     %x..p...net erro
  149f08:	65732072 6c20646e 74676e65 64252068     r send length %d
  149f18:	63786520 20646565 2078616d 676e656c      exceed max leng
  149f28:	00006874 2074656e 6f727265 65722072     th..net error re
  149f38:	6c207663 74676e65 64252068 63786520     cv length %d exc
  149f48:	20646565 2078616d 676e656c 00006874     eed max length..
  149f58:	20687465 64616572 766e6920 64696c61     eth read invalid
  149f68:	72617020 74656d61 62207265 65666675      parameter buffe
  149f78:	70252072 7a697320 64252065 00000000     r %p size %d....
  149f88:	20687465 74697277 6e692065 696c6176     eth write invali
  149f98:	61702064 656d6172 20726574 66667562     d parameter buff
  149fa8:	25207265 69732070 2520657a 00000064     er %p size %d...
  149fb8:	65746e69 75707272 616d2074 20686374     interrput match 
  149fc8:	65736162 64646120 72652072 00726f72     base addr error.
  149fd8:	33335b1b 2f575b6d 2e767264 74656e65     .[33m[W/drv.enet
  149fe8:	0000205d 20594850 6b6e694c 776f6420     ] ..PHY Link dow
  149ff8:	70202c6e 7361656c 68632065 206b6365     n, please check 
  14a008:	20656874 6c626163 6f632065 63656e6e     the cable connec
  14a018:	6e6f6974 646e6120 6e696c20 6170206b     tion and link pa
  14a028:	656e7472 65732072 6e697474 00002e67     rtner setting...

0014a038 <_k_enet_ops>:
  14a038:	00000000 00135458 001354a0 001354dc     ....XT...T...T..
  14a048:	0013558c 00134e8c 32335b1b 2f495b6d     .U...N...[32m[I/
  14a058:	2e767264 74656e65 0000205d 63616d65     drv.enet] ..emac
  14a068:	76656420 20656369 74696e69 63757320      device init suc
  14a078:	73736563 00000000 63616d65 76656420     cess....emac dev
  14a088:	20656369 74696e69 69616620 203a646c     ice init faild: 
  14a098:	00006425 6b6e696c 6425645f 00000000     %d..link_d%d....

0014a0a8 <__FUNCTION__.9268>:
  14a0a8:	695f7472 7536786d 74655f6c 78745f68     rt_imx6ul_eth_tx
  14a0b8:	00000000 45535341 45205452 524f5252     ....ASSERT ERROR
  14a0c8:	25202220 3a222073 6c696620 25222065      " %s ": file "%
  14a0d8:	4c202273 20656e69 22642522 6e756620     s" Line "%d" fun
  14a0e8:	6f697463 616e206e 2220656d 20227325     ction name "%s" 
  14a0f8:	0000000a                                ....

0014a0fc <s_enetBases>:
  14a0fc:	00000000 02188000 020b4000 74736e69     .........@..inst
  14a10c:	65636e61 41203c20 59415252 5a49535f     ance < ARRAY_SIZ
  14a11c:	5f732845 74656e65 65736142 00002973     E(s_enetBases)..
  14a12c:	666e6f63 00006769 646e6168 0000656c     config..handle..
  14a13c:	66667562 6f437265 6769666e 00000000     bufferConfig....
  14a14c:	66667562 6f437265 6769666e 78723e2d     bufferConfig->rx
  14a15c:	74536442 41747261 41726464 6e67696c     BdStartAddrAlign
  14a16c:	00000000 66667562 6f437265 6769666e     ....bufferConfig
  14a17c:	78743e2d 74536442 41747261 41726464     ->txBdStartAddrA
  14a18c:	6e67696c 00000000 66667562 6f437265     lign....bufferCo
  14a19c:	6769666e 78723e2d 66667542 6c417265     nfig->rxBufferAl
  14a1ac:	006e6769 66667562 6f437265 6769666e     ign.bufferConfig
  14a1bc:	78743e2d 66667542 6c417265 006e6769     ->txBufferAlign.
  14a1cc:	4163616d 00726464 66667562 6f437265     macAddr.bufferCo
  14a1dc:	6769666e 78723e2d 66667542 657a6953     nfig->rxBuffSize
  14a1ec:	67696c41 3d3e206e 454e4520 58525f54     Align >= ENET_RX
  14a1fc:	4e494d5f 4655425f 53524546 00455a49     _MIN_BUFFERSIZE.
  14a20c:	66667562 6f437265 6769666e 78743e2d     bufferConfig->tx
  14a21c:	66667542 657a6953 67696c41 202a206e     BuffSizeAlign * 
  14a22c:	66667562 6f437265 6769666e 78743e2d     bufferConfig->tx
  14a23c:	754e6442 7265626d 28203e20 54454e45     BdNumber > (ENET
  14a24c:	4152465f 4d5f454d 465f5841 454d4152     _FRAME_MAX_FRAME
  14a25c:	204e454c 4e45202b 465f5445 454d4152     LEN + ENET_FRAME
  14a26c:	414c565f 41545f4e 4e454c47 00000029     _VLAN_TAGLEN)...
  14a27c:	66667562 6f437265 6769666e 78743e2d     bufferConfig->tx
  14a28c:	66667542 657a6953 67696c41 202a206e     BuffSizeAlign * 
  14a29c:	66667562 6f437265 6769666e 78743e2d     bufferConfig->tx
  14a2ac:	754e6442 7265626d 45203e20 5f54454e     BdNumber > ENET_
  14a2bc:	4d415246 414d5f45 52465f58 4c454d41     FRAME_MAX_FRAMEL
  14a2cc:	00004e45 66667562 6f437265 6769666e     EN..bufferConfig
  14a2dc:	78723e2d 66667542 657a6953 67696c41     ->rxBuffSizeAlig
  14a2ec:	202a206e 66667562 6f437265 6769666e     n * bufferConfig
  14a2fc:	78723e2d 754e6442 7265626d 63203e20     ->rxBdNumber > c
  14a30c:	69666e6f 723e2d67 78614d78 6d617246     onfig->rxMaxFram
  14a31c:	6e654c65 00000000 64427874 72617453     eLen....txBdStar
  14a32c:	696c4174 00006e67 75427874 74536666     tAlign..txBuffSt
  14a33c:	41747261 6e67696c 00000000 64427872     artAlign....rxBd
  14a34c:	72617453 696c4174 00006e67 75427872     StartAlign..rxBu
  14a35c:	74536666 41747261 6e67696c 00000000     ffStartAlign....
  14a36c:	43637273 6b636f6c 007a485f 646e6168     srcClock_Hz.hand
  14a37c:	3e2d656c 64427872 72727543 00746e65     le->rxBdCurrent.
  14a38c:	72724565 7453726f 63697461 00000000     eErrorStatic....
  14a39c:	676e656c 00006874 31335b1b 2f455b6d     length...[31m[E/
  14a3ac:	2e767264 74656e65 0000205d 6d617266     drv.enet] ..fram
  14a3bc:	72652065 30726f72 72756320 66667542     e error0 curBuff
  14a3cc:	63736544 2d706972 6e6f633e 6c6f7274     Descrip->control
  14a3dc:	25783020 20783430 676e656c 25206874      0x%04x length %
  14a3ec:	00000a64 6d305b1b 0000000a 6d617266     d....[0m....fram
  14a3fc:	72652065 31726f72 72756320 66667542     e error1 curBuff
  14a40c:	63736544 2d706972 6e6f633e 6c6f7274     Descrip->control
  14a41c:	25783020 20783430 676e656c 25206874      0x%04x length %
  14a42c:	00000a64 646e6168 3e2d656c 64427874     d...handle->txBd
  14a43c:	72727543 00746e65 61746164 00000000     Current.data....
  14a44c:	676e656c 3c206874 4e45203d 465f5445     length <= ENET_F
  14a45c:	454d4152 58414d5f 4152465f 454c454d     RAME_MAX_FRAMELE
  14a46c:	0000004e 72646461 00737365              N...address.

0014a478 <__FUNCTION__.9236>:
  14a478:	54454e45 7465475f 74736e49 65636e61     ENET_GetInstance
  14a488:	00000000                                ....

0014a48c <__FUNCTION__.9241>:
  14a48c:	54454e45 7465475f 61666544 43746c75     ENET_GetDefaultC
  14a49c:	69666e6f 00000067                       onfig...

0014a4a4 <__FUNCTION__.9250>:
  14a4a4:	54454e45 696e495f 00000074              ENET_Init...

0014a4b0 <__FUNCTION__.9259>:
  14a4b0:	54454e45 7465535f 6c6c6143 6b636162     ENET_SetCallback
  14a4c0:	00000000                                ....

0014a4c4 <__FUNCTION__.9288>:
  14a4c4:	54454e45 7465535f 75427854 72656666     ENET_SetTxBuffer
  14a4d4:	63736544 74706972 0073726f              Descriptors.

0014a4e0 <__FUNCTION__.9302>:
  14a4e0:	54454e45 7465535f 75427852 72656666     ENET_SetRxBuffer
  14a4f0:	63736544 74706972 0073726f              Descriptors.

0014a4fc <__FUNCTION__.9324>:
  14a4fc:	54454e45 7465475f 4163614d 00726464     ENET_GetMacAddr.

0014a50c <__FUNCTION__.9331>:
  14a50c:	54454e45 7465535f 00494d53              ENET_SetSMI.

0014a518 <__FUNCTION__.9371>:
  14a518:	54454e45 7465475f 72457852 66654272     ENET_GetRxErrBef
  14a528:	5265726f 46646165 656d6172 00000000     oreReadFrame....

0014a538 <__FUNCTION__.9383>:
  14a538:	54454e45 6165525f 61724664 0000656d     ENET_ReadFrame..

0014a548 <__FUNCTION__.9390>:
  14a548:	54454e45 6470555f 52657461 42646165     ENET_UpdateReadB
  14a558:	65666675 00007372                       uffers..

0014a560 <__FUNCTION__.9398>:
  14a560:	54454e45 6e65535f 61724664 0000656d     ENET_SendFrame..

0014a570 <__FUNCTION__.9407>:
  14a570:	54454e45 6464415f 746c754d 73616369     ENET_AddMulticas
  14a580:	6f724774 00007075                       tGroup..

0014a588 <__FUNCTION__.9422>:
  14a588:	54454e45 61654c5f 754d6576 6369746c     ENET_LeaveMultic
  14a598:	47747361 70756f72 00000000              astGroup....

0014a5a4 <__FUNCTION__.9439>:
  14a5a4:	54454e45 6172545f 696d736e 51524974     ENET_TransmitIRQ
  14a5b4:	646e6148 0072656c                       Handler.

0014a5bc <__FUNCTION__.9446>:
  14a5bc:	54454e45 6365525f 65766965 48515249     ENET_ReceiveIRQH
  14a5cc:	6c646e61 00007265                       andler..

0014a5d4 <__FUNCTION__.9451>:
  14a5d4:	54454e45 7272455f 5249726f 6e614851     ENET_ErrorIRQHan
  14a5e4:	72656c64 00000000 76726573 73656369     dler....services
  14a5f4:	49776c2f 74694b50 7672642f 656e655f     /lwIPKit/drv_ene
  14a604:	72642f74 72657669 6c73662f 6970675f     t/driver/fsl_gpi
  14a614:	00632e6f 206e6970 3233203c 00000000     o.c.pin < 32....

0014a624 <__func__.6332>:
  14a624:	4f495047 6972575f 69506574 74754f6e     GPIO_WritePinOut
  14a634:	00747570 61746164 00727450 74617473     put.dataPtr.stat
  14a644:	00007375 6c707564 00007865              us..duplex..

0014a650 <__FUNCTION__.8416>:
  14a650:	5f594850 64616552 00000000              PHY_Read....

0014a65c <__FUNCTION__.8434>:
  14a65c:	5f594850 4c746547 536b6e69 75746174     PHY_GetLinkStatu
  14a66c:	00000073                                s...

0014a670 <__FUNCTION__.8443>:
  14a670:	5f594850 4c746547 536b6e69 64656570     PHY_GetLinkSpeed
  14a680:	6c707544 00007865                       Duplex..

0014a688 <errid>:
  14a688:	19222154 0302010d 0c1c4b11 1d0b0410     T!"......K......
  14a698:	68271e12 71706f6e 06052062 1514130f     ..'hnopqb ......
  14a6a8:	0716081a 18172428 1b0e0a09 8323251f     ....($.......%#.
  14a6b8:	2a267d82 3e3d3c2b 4a47433f 5a59584d     .}&*+<=>?CGJMXYZ
  14a6c8:	5e5d5c5b 6361605f 67666564 6c6b6a69     [\]^_`acdefgijkl
  14a6d8:	79747372 487c7b7a 00000000              rstyz{|H....

0014a6e4 <errmsg>:
  14a6e4:	656c6c49 206c6167 65747962 71657320     Illegal byte seq
  14a6f4:	636e6575 6f440065 6e69616d 72726520     uence.Domain err
  14a704:	5200726f 6c757365 6f6e2074 65722074     or.Result not re
  14a714:	73657270 61746e65 00656c62 20746f4e     presentable.Not 
  14a724:	74742061 65500079 73696d72 6e6f6973     a tty.Permission
  14a734:	6e656420 00646569 7265704f 6f697461      denied.Operatio
  14a744:	6f6e206e 65702074 74696d72 00646574     n not permitted.
  14a754:	73206f4e 20686375 656c6966 20726f20     No such file or 
  14a764:	65726964 726f7463 6f4e0079 63757320     directory.No suc
  14a774:	72702068 7365636f 69460073 6520656c     h process.File e
  14a784:	74736978 61560073 2065756c 206f6f74     xists.Value too 
  14a794:	6772616c 6f662065 61642072 74206174     large for data t
  14a7a4:	00657079 73206f4e 65636170 66656c20     ype.No space lef
  14a7b4:	6e6f2074 76656420 00656369 2074754f     t on device.Out 
  14a7c4:	6d20666f 726f6d65 65520079 72756f73     of memory.Resour
  14a7d4:	62206563 00797375 65746e49 70757272     ce busy.Interrup
  14a7e4:	20646574 74737973 63206d65 006c6c61     ted system call.
  14a7f4:	6f736552 65637275 6d657420 61726f70     Resource tempora
  14a804:	796c6972 616e7520 6c696176 656c6261     rily unavailable
  14a814:	766e4900 64696c61 65657320 7243006b     .Invalid seek.Cr
  14a824:	2d73736f 69766564 6c206563 006b6e69     oss-device link.
  14a834:	64616552 6c6e6f2d 69662079 7320656c     Read-only file s
  14a844:	65747379 6944006d 74636572 2079726f     ystem.Directory 
  14a854:	20746f6e 74706d65 6f430079 63656e6e     not empty.Connec
  14a864:	6e6f6974 73657220 62207465 65702079     tion reset by pe
  14a874:	4f007265 61726570 6e6f6974 6d697420     er.Operation tim
  14a884:	6f206465 43007475 656e6e6f 6f697463     ed out.Connectio
  14a894:	6572206e 65737566 6f480064 69207473     n refused.Host i
  14a8a4:	6f642073 48006e77 2074736f 75207369     s down.Host is u
  14a8b4:	6165726e 62616863 4100656c 65726464     nreachable.Addre
  14a8c4:	69207373 7375206e 72420065 6e656b6f     ss in use.Broken
  14a8d4:	70697020 2f490065 7265204f 00726f72      pipe.I/O error.
  14a8e4:	73206f4e 20686375 69766564 6f206563     No such device o
  14a8f4:	64612072 73657264 6c420073 206b636f     r address.Block 
  14a904:	69766564 72206563 69757165 00646572     device required.
  14a914:	73206f4e 20686375 69766564 4e006563     No such device.N
  14a924:	6120746f 72696420 6f746365 49007972     ot a directory.I
  14a934:	20612073 65726964 726f7463 65540079     s a directory.Te
  14a944:	66207478 20656c69 79737562 65784500     xt file busy.Exe
  14a954:	6f662063 74616d72 72726520 4900726f     c format error.I
  14a964:	6c61766e 61206469 6d756772 00746e65     nvalid argument.
  14a974:	75677241 746e656d 73696c20 6f742074     Argument list to
  14a984:	6f6c206f 5300676e 6f626d79 2063696c     o long.Symbolic 
  14a994:	6b6e696c 6f6f6c20 69460070 616e656c     link loop.Filena
  14a9a4:	7420656d 6c206f6f 00676e6f 206f6f54     me too long.Too 
  14a9b4:	796e616d 65706f20 6966206e 2073656c     many open files 
  14a9c4:	73206e69 65747379 6f4e006d 6c696620     in system.No fil
  14a9d4:	65642065 69726373 726f7470 76612073     e descriptors av
  14a9e4:	616c6961 00656c62 20646142 656c6966     ailable.Bad file
  14a9f4:	73656420 70697263 00726f74 63206f4e      descriptor.No c
  14aa04:	646c6968 6f727020 73736563 64614200     hild process.Bad
  14aa14:	64646120 73736572 6c694600 6f742065      address.File to
  14aa24:	616c206f 00656772 206f6f54 796e616d     o large.Too many
  14aa34:	6e696c20 4e00736b 6f6c206f 20736b63      links.No locks 
  14aa44:	69617661 6c62616c 65520065 72756f73     available.Resour
  14aa54:	64206563 6c646165 206b636f 6c756f77     ce deadlock woul
  14aa64:	636f2064 00727563 74617453 6f6e2065     d occur.State no
  14aa74:	65722074 65766f63 6c626172 72500065     t recoverable.Pr
  14aa84:	6f697665 6f207375 72656e77 65696420     evious owner die
  14aa94:	704f0064 74617265 206e6f69 636e6163     d.Operation canc
  14aaa4:	64656c65 6e754600 6f697463 6f6e206e     eled.Function no
  14aab4:	6d692074 6d656c70 65746e65 6f4e0064     t implemented.No
  14aac4:	73656d20 65676173 20666f20 69736564      message of desi
  14aad4:	20646572 65707974 65644900 6669746e     red type.Identif
  14aae4:	20726569 6f6d6572 00646576 69766544     ier removed.Devi
  14aaf4:	6e206563 6120746f 72747320 006d6165     ce not a stream.
  14ab04:	64206f4e 20617461 69617661 6c62616c     No data availabl
  14ab14:	65440065 65636976 6d697420 74756f65     e.Device timeout
  14ab24:	74754f00 20666f20 65727473 20736d61     .Out of streams 
  14ab34:	6f736572 65637275 694c0073 68206b6e     resources.Link h
  14ab44:	62207361 206e6565 65766573 00646572     as been severed.
  14ab54:	746f7250 6c6f636f 72726520 4200726f     Protocol error.B
  14ab64:	6d206461 61737365 46006567 20656c69     ad message.File 
  14ab74:	63736564 74706972 6920726f 6162206e     descriptor in ba
  14ab84:	74732064 00657461 20746f4e 6f732061     d state.Not a so
  14ab94:	74656b63 73654400 616e6974 6e6f6974     cket.Destination
  14aba4:	64646120 73736572 71657220 65726975      address require
  14abb4:	654d0064 67617373 6f742065 616c206f     d.Message too la
  14abc4:	00656772 746f7250 6c6f636f 6f727720     rge.Protocol wro
  14abd4:	7420676e 20657079 20726f66 6b636f73     ng type for sock
  14abe4:	50007465 6f746f72 206c6f63 20746f6e     et.Protocol not 
  14abf4:	69617661 6c62616c 72500065 636f746f     available.Protoc
  14ac04:	6e206c6f 7320746f 6f707075 64657472     ol not supported
  14ac14:	636f5300 2074656b 65707974 746f6e20     .Socket type not
  14ac24:	70757320 74726f70 4e006465 7320746f      supported.Not s
  14ac34:	6f707075 64657472 6f725000 6f636f74     upported.Protoco
  14ac44:	6166206c 796c696d 746f6e20 70757320     l family not sup
  14ac54:	74726f70 41006465 65726464 66207373     ported.Address f
  14ac64:	6c696d61 6f6e2079 75732074 726f7070     amily not suppor
  14ac74:	20646574 70207962 6f746f72 006c6f63     ted by protocol.
  14ac84:	72646441 20737365 20746f6e 69617661     Address not avai
  14ac94:	6c62616c 654e0065 726f7774 7369206b     lable.Network is
  14aca4:	776f6420 654e006e 726f7774 6e75206b      down.Network un
  14acb4:	63616572 6c626168 6f430065 63656e6e     reachable.Connec
  14acc4:	6e6f6974 73657220 62207465 656e2079     tion reset by ne
  14acd4:	726f7774 6f43006b 63656e6e 6e6f6974     twork.Connection
  14ace4:	6f626120 64657472 206f4e00 66667562      aborted.No buff
  14acf4:	73207265 65636170 61766120 62616c69     er space availab
  14ad04:	5300656c 656b636f 73692074 6e6f6320     le.Socket is con
  14ad14:	7463656e 53006465 656b636f 6f6e2074     nected.Socket no
  14ad24:	6f632074 63656e6e 00646574 6e6e6143     t connected.Cann
  14ad34:	7320746f 20646e65 65746661 6f732072     ot send after so
  14ad44:	74656b63 75687320 776f6474 704f006e     cket shutdown.Op
  14ad54:	74617265 206e6f69 65726c61 20796461     eration already 
  14ad64:	70206e69 72676f72 00737365 7265704f     in progress.Oper
  14ad74:	6f697461 6e69206e 6f727020 73657267     ation in progres
  14ad84:	74530073 20656c61 656c6966 6e616820     s.Stale file han
  14ad94:	00656c64 6f6d6552 49206574 65204f2f     dle.Remote I/O e
  14ada4:	726f7272 6f755100 65206174 65656378     rror.Quota excee
  14adb4:	00646564 6d206f4e 75696465 6f66206d     ded.No medium fo
  14adc4:	00646e75 6e6f7257 656d2067 6d756964     und.Wrong medium
  14add4:	70797420 754d0065 6869746c 6120706f      type.Multihop a
  14ade4:	6d657474 64657470 206f4e00 6f727265     ttempted.No erro
  14adf4:	6e692072 6d726f66 6f697461 0000006e     r information...
  14ae04:	65737341 6f697472 6166206e 64656c69     Assertion failed
  14ae14:	7325203a 73252820 7325203a 6425203a     : %s (%s: %s: %d
  14ae24:	00000a29                                )...

0014ae28 <__FUNCTION__.6013>:
  14ae28:	63737973 5f6c6c61 74736572 5f747261     syscall_restart_
  14ae38:	63737973 006c6c61                       syscall.

0014ae40 <__FUNCTION__.6017>:
  14ae40:	63737973 5f6c6c61 74697865 00000000     syscall_exit....

0014ae50 <__FUNCTION__.6020>:
  14ae50:	63737973 5f6c6c61 6b726f66 00000000     syscall_fork....

0014ae60 <__FUNCTION__.6026>:
  14ae60:	63737973 5f6c6c61 64616572 00000000     syscall_read....

0014ae70 <__FUNCTION__.6032>:
  14ae70:	63737973 5f6c6c61 74697277 00000065     syscall_write...

0014ae80 <__FUNCTION__.6038>:
  14ae80:	63737973 5f6c6c61 6e65706f 00000000     syscall_open....

0014ae90 <__FUNCTION__.6042>:
  14ae90:	63737973 5f6c6c61 736f6c63 00000065     syscall_close...

0014aea0 <__FUNCTION__.6045>:
  14aea0:	63737973 5f6c6c61 61657263 00000074     syscall_creat...

0014aeb0 <__FUNCTION__.6048>:
  14aeb0:	63737973 5f6c6c61 6b6e696c 00000000     syscall_link....

0014aec0 <__FUNCTION__.6052>:
  14aec0:	63737973 5f6c6c61 696c6e75 00006b6e     syscall_unlink..

0014aed0 <__FUNCTION__.6058>:
  14aed0:	63737973 5f6c6c61 63657865 00006576     syscall_execve..

0014aee0 <__FUNCTION__.6062>:
  14aee0:	63737973 5f6c6c61 69646863 00000072     syscall_chdir...

0014aef0 <__FUNCTION__.6065>:
  14aef0:	63737973 5f6c6c61 6f6e6b6d 00000064     syscall_mknod...

0014af00 <__FUNCTION__.6068>:
  14af00:	63737973 5f6c6c61 6f6d6863 00000064     syscall_chmod...

0014af10 <__FUNCTION__.6071>:
  14af10:	63737973 5f6c6c61 6f68636c 00006e77     syscall_lchown..

0014af20 <__FUNCTION__.6077>:
  14af20:	63737973 5f6c6c61 6565736c 0000006b     syscall_lseek...

0014af30 <__FUNCTION__.6080>:
  14af30:	63737973 5f6c6c61 70746567 00006469     syscall_getpid..

0014af40 <__FUNCTION__.6083>:
  14af40:	63737973 5f6c6c61 6e756f6d 00000074     syscall_mount...

0014af50 <__FUNCTION__.6086>:
  14af50:	63737973 5f6c6c61 75746573 00006469     syscall_setuid..

0014af60 <__FUNCTION__.6089>:
  14af60:	63737973 5f6c6c61 75746567 00006469     syscall_getuid..

0014af70 <__FUNCTION__.6092>:
  14af70:	63737973 5f6c6c61 61727470 00006563     syscall_ptrace..

0014af80 <__FUNCTION__.6095>:
  14af80:	63737973 5f6c6c61 73756170 00000065     syscall_pause...

0014af90 <__FUNCTION__.6100>:
  14af90:	63737973 5f6c6c61 65636361 00007373     syscall_access..

0014afa0 <__FUNCTION__.6103>:
  14afa0:	63737973 5f6c6c61 6563696e 00000000     syscall_nice....

0014afb0 <__FUNCTION__.6106>:
  14afb0:	63737973 5f6c6c61 636e7973 00000000     syscall_sync....

0014afc0 <__FUNCTION__.6111>:
  14afc0:	63737973 5f6c6c61 6c6c696b 00000000     syscall_kill....

0014afd0 <__FUNCTION__.6116>:
  14afd0:	63737973 5f6c6c61 616e6572 0000656d     syscall_rename..

0014afe0 <__FUNCTION__.6121>:
  14afe0:	63737973 5f6c6c61 69646b6d 00000072     syscall_mkdir...

0014aff0 <__FUNCTION__.6125>:
  14aff0:	63737973 5f6c6c61 69646d72 00000072     syscall_rmdir...

0014b000 <__FUNCTION__.6129>:
  14b000:	63737973 5f6c6c61 00707564              syscall_dup.

0014b00c <__FUNCTION__.6133>:
  14b00c:	63737973 5f6c6c61 65706970 00000000     syscall_pipe....

0014b01c <__FUNCTION__.6136>:
  14b01c:	63737973 5f6c6c61 656d6974 00000073     syscall_times...

0014b02c <__FUNCTION__.6140>:
  14b02c:	63737973 5f6c6c61 006b7262              syscall_brk.

0014b038 <__FUNCTION__.6143>:
  14b038:	63737973 5f6c6c61 67746573 00006469     syscall_setgid..

0014b048 <__FUNCTION__.6146>:
  14b048:	63737973 5f6c6c61 67746567 00006469     syscall_getgid..

0014b058 <__FUNCTION__.6149>:
  14b058:	63737973 5f6c6c61 65746567 00646975     syscall_geteuid.

0014b068 <__FUNCTION__.6152>:
  14b068:	63737973 5f6c6c61 65746567 00646967     syscall_getegid.

0014b078 <__FUNCTION__.6155>:
  14b078:	63737973 5f6c6c61 74636361 00000000     syscall_acct....

0014b088 <__FUNCTION__.6158>:
  14b088:	63737973 5f6c6c61 756f6d75 0032746e     syscall_umount2.

0014b098 <__FUNCTION__.6164>:
  14b098:	63737973 5f6c6c61 74636f69 0000006c     syscall_ioctl...

0014b0a8 <__FUNCTION__.6170>:
  14b0a8:	63737973 5f6c6c61 746e6366 0000006c     syscall_fcntl...

0014b0b8 <__FUNCTION__.6173>:
  14b0b8:	63737973 5f6c6c61 70746573 00646967     syscall_setpgid.

0014b0c8 <__FUNCTION__.6176>:
  14b0c8:	63737973 5f6c6c61 73616d75 0000006b     syscall_umask...

0014b0d8 <__FUNCTION__.6179>:
  14b0d8:	63737973 5f6c6c61 6f726863 0000746f     syscall_chroot..

0014b0e8 <__FUNCTION__.6182>:
  14b0e8:	63737973 5f6c6c61 61747375 00000074     syscall_ustat...

0014b0f8 <__FUNCTION__.6187>:
  14b0f8:	63737973 5f6c6c61 32707564 00000000     syscall_dup2....

0014b108 <__FUNCTION__.6190>:
  14b108:	63737973 5f6c6c61 70746567 00646970     syscall_getppid.

0014b118 <__FUNCTION__.6193>:
  14b118:	63737973 5f6c6c61 70746567 00707267     syscall_getpgrp.

0014b128 <__FUNCTION__.6196>:
  14b128:	63737973 5f6c6c61 73746573 00006469     syscall_setsid..

0014b138 <__FUNCTION__.6203>:
  14b138:	63737973 5f6c6c61 61676973 6f697463     syscall_sigactio
  14b148:	0000006e                                n...

0014b14c <__FUNCTION__.6206>:
  14b14c:	63737973 5f6c6c61 72746573 64697565     syscall_setreuid
  14b15c:	00000000                                ....

0014b160 <__FUNCTION__.6209>:
  14b160:	63737973 5f6c6c61 72746573 64696765     syscall_setregid
  14b170:	00000000                                ....

0014b174 <__FUNCTION__.6212>:
  14b174:	63737973 5f6c6c61 73676973 65707375     syscall_sigsuspe
  14b184:	0000646e                                nd..

0014b188 <__FUNCTION__.6215>:
  14b188:	63737973 5f6c6c61 70676973 69646e65     syscall_sigpendi
  14b198:	0000676e                                ng..

0014b19c <__FUNCTION__.6218>:
  14b19c:	63737973 5f6c6c61 68746573 6e74736f     syscall_sethostn
  14b1ac:	00656d61                                ame.

0014b1b0 <__FUNCTION__.6223>:
  14b1b0:	63737973 5f6c6c61 72746573 696d696c     syscall_setrlimi
  14b1c0:	00000074                                t...

0014b1c4 <__FUNCTION__.6226>:
  14b1c4:	63737973 5f6c6c61 72746567 67617375     syscall_getrusag
  14b1d4:	00000065                                e...

0014b1d8 <__FUNCTION__.6229>:
  14b1d8:	63737973 5f6c6c61 74746567 6f656d69     syscall_gettimeo
  14b1e8:	79616466 00000000                       fday....

0014b1f0 <__FUNCTION__.6232>:
  14b1f0:	63737973 5f6c6c61 74746573 6f656d69     syscall_settimeo
  14b200:	79616466 00000000                       fday....

0014b208 <__FUNCTION__.6235>:
  14b208:	63737973 5f6c6c61 67746567 70756f72     syscall_getgroup
  14b218:	00000073                                s...

0014b21c <__FUNCTION__.6238>:
  14b21c:	63737973 5f6c6c61 67746573 70756f72     syscall_setgroup
  14b22c:	00000073                                s...

0014b230 <__FUNCTION__.6241>:
  14b230:	63737973 5f6c6c61 6c6d7973 006b6e69     syscall_symlink.

0014b240 <__FUNCTION__.6247>:
  14b240:	63737973 5f6c6c61 64616572 6b6e696c     syscall_readlink
  14b250:	00000000                                ....

0014b254 <__FUNCTION__.6250>:
  14b254:	63737973 5f6c6c61 6c657375 00006269     syscall_uselib..

0014b264 <__FUNCTION__.6253>:
  14b264:	63737973 5f6c6c61 70617773 00006e6f     syscall_swapon..

0014b274 <__FUNCTION__.6256>:
  14b274:	63737973 5f6c6c61 6f626572 0000746f     syscall_reboot..

0014b284 <__FUNCTION__.6261>:
  14b284:	63737973 5f6c6c61 6d6e756d 00007061     syscall_munmap..

0014b294 <__FUNCTION__.6264>:
  14b294:	63737973 5f6c6c61 6e757274 65746163     syscall_truncate
  14b2a4:	00000000                                ....

0014b2a8 <__FUNCTION__.6267>:
  14b2a8:	63737973 5f6c6c61 75727466 7461636e     syscall_ftruncat
  14b2b8:	00000065                                e...

0014b2bc <__FUNCTION__.6270>:
  14b2bc:	63737973 5f6c6c61 6d686366 0000646f     syscall_fchmod..

0014b2cc <__FUNCTION__.6273>:
  14b2cc:	63737973 5f6c6c61 6f686366 00006e77     syscall_fchown..

0014b2dc <__FUNCTION__.6276>:
  14b2dc:	63737973 5f6c6c61 70746567 726f6972     syscall_getprior
  14b2ec:	00797469                                ity.

0014b2f0 <__FUNCTION__.6279>:
  14b2f0:	63737973 5f6c6c61 70746573 726f6972     syscall_setprior
  14b300:	00797469                                ity.

0014b304 <__FUNCTION__.6285>:
  14b304:	63737973 5f6c6c61 74617473 00007366     syscall_statfs..

0014b314 <__FUNCTION__.6291>:
  14b314:	63737973 5f6c6c61 61747366 00736674     syscall_fstatfs.

0014b324 <__FUNCTION__.6294>:
  14b324:	63737973 5f6c6c61 6c737973 0000676f     syscall_syslog..

0014b334 <__FUNCTION__.6297>:
  14b334:	63737973 5f6c6c61 69746573 656d6974     syscall_setitime
  14b344:	00000072                                r...

0014b348 <__FUNCTION__.6300>:
  14b348:	63737973 5f6c6c61 69746567 656d6974     syscall_getitime
  14b358:	00000072                                r...

0014b35c <__FUNCTION__.6305>:
  14b35c:	63737973 5f6c6c61 74617473 00000000     syscall_stat....

0014b36c <__FUNCTION__.6310>:
  14b36c:	63737973 5f6c6c61 6174736c 00000074     syscall_lstat...

0014b37c <__FUNCTION__.6315>:
  14b37c:	63737973 5f6c6c61 61747366 00000074     syscall_fstat...

0014b38c <__FUNCTION__.6318>:
  14b38c:	63737973 5f6c6c61 6e616876 00707567     syscall_vhangup.

0014b39c <__FUNCTION__.6321>:
  14b39c:	63737973 5f6c6c61 74696177 00000034     syscall_wait4...

0014b3ac <__FUNCTION__.6324>:
  14b3ac:	63737973 5f6c6c61 70617773 0066666f     syscall_swapoff.

0014b3bc <__FUNCTION__.6327>:
  14b3bc:	63737973 5f6c6c61 69737973 006f666e     syscall_sysinfo.

0014b3cc <__FUNCTION__.6331>:
  14b3cc:	63737973 5f6c6c61 6e797366 00000063     syscall_fsync...

0014b3dc <__FUNCTION__.6334>:
  14b3dc:	63737973 5f6c6c61 72676973 72757465     syscall_sigretur
  14b3ec:	0000006e                                n...

0014b3f0 <__FUNCTION__.6337>:
  14b3f0:	63737973 5f6c6c61 6e6f6c63 00000065     syscall_clone...

0014b400 <__FUNCTION__.6340>:
  14b400:	63737973 5f6c6c61 64746573 69616d6f     syscall_setdomai
  14b410:	6d616e6e 00000065                       nname...

0014b418 <__FUNCTION__.6343>:
  14b418:	63737973 5f6c6c61 6d616e75 00000065     syscall_uname...

0014b428 <__FUNCTION__.6346>:
  14b428:	63737973 5f6c6c61 746a6461 78656d69     syscall_adjtimex
  14b438:	00000000                                ....

0014b43c <__FUNCTION__.6349>:
  14b43c:	63737973 5f6c6c61 6f72706d 74636574     syscall_mprotect
  14b44c:	00000000                                ....

0014b450 <__FUNCTION__.6356>:
  14b450:	63737973 5f6c6c61 70676973 6d636f72     syscall_sigprocm
  14b460:	006b7361                                ask.

0014b464 <__FUNCTION__.6359>:
  14b464:	63737973 5f6c6c61 74696e69 646f6d5f     syscall_init_mod
  14b474:	00656c75                                ule.

0014b478 <__FUNCTION__.6362>:
  14b478:	63737973 5f6c6c61 656c6564 6d5f6574     syscall_delete_m
  14b488:	6c75646f 00000065                       odule...

0014b490 <__FUNCTION__.6365>:
  14b490:	63737973 5f6c6c61 746f7571 6c746361     syscall_quotactl
  14b4a0:	00000000                                ....

0014b4a4 <__FUNCTION__.6368>:
  14b4a4:	63737973 5f6c6c61 70746567 00646967     syscall_getpgid.

0014b4b4 <__FUNCTION__.6371>:
  14b4b4:	63737973 5f6c6c61 64686366 00007269     syscall_fchdir..

0014b4c4 <__FUNCTION__.6374>:
  14b4c4:	63737973 5f6c6c61 6c666462 00687375     syscall_bdflush.

0014b4d4 <__FUNCTION__.6377>:
  14b4d4:	63737973 5f6c6c61 66737973 00000073     syscall_sysfs...

0014b4e4 <__FUNCTION__.6380>:
  14b4e4:	63737973 5f6c6c61 73726570 6c616e6f     syscall_personal
  14b4f4:	00797469                                ity.

0014b4f8 <__FUNCTION__.6383>:
  14b4f8:	63737973 5f6c6c61 66746573 64697573     syscall_setfsuid
  14b508:	00000000                                ....

0014b50c <__FUNCTION__.6386>:
  14b50c:	63737973 5f6c6c61 66746573 64696773     syscall_setfsgid
  14b51c:	00000000                                ....

0014b520 <__FUNCTION__.6394>:
  14b520:	63737973 5f6c6c61 736c6c5f 006b6565     syscall__llseek.

0014b530 <__FUNCTION__.6400>:
  14b530:	63737973 5f6c6c61 64746567 73746e65     syscall_getdents
  14b540:	00000000                                ....

0014b544 <__FUNCTION__.6408>:
  14b544:	63737973 5f6c6c61 77656e5f 656c6573     syscall__newsele
  14b554:	00007463                                ct..

0014b558 <__FUNCTION__.6411>:
  14b558:	63737973 5f6c6c61 636f6c66 0000006b     syscall_flock...

0014b568 <__FUNCTION__.6414>:
  14b568:	63737973 5f6c6c61 6e79736d 00000063     syscall_msync...

0014b578 <__FUNCTION__.6422>:
  14b578:	63737973 5f6c6c61 64616572 00000076     syscall_readv...

0014b588 <__FUNCTION__.6434>:
  14b588:	63737973 5f6c6c61 74697277 00007665     syscall_writev..

0014b598 <__FUNCTION__.6441>:
  14b598:	63737973 5f6c6c61 73746567 00006469     syscall_getsid..

0014b5a8 <__FUNCTION__.6444>:
  14b5a8:	63737973 5f6c6c61 74616466 6e797361     syscall_fdatasyn
  14b5b8:	00000063                                c...

0014b5bc <__FUNCTION__.6447>:
  14b5bc:	63737973 5f6c6c61 7379735f 006c7463     syscall__sysctl.

0014b5cc <__FUNCTION__.6450>:
  14b5cc:	63737973 5f6c6c61 636f6c6d 0000006b     syscall_mlock...

0014b5dc <__FUNCTION__.6453>:
  14b5dc:	63737973 5f6c6c61 6c6e756d 006b636f     syscall_munlock.

0014b5ec <__FUNCTION__.6456>:
  14b5ec:	63737973 5f6c6c61 636f6c6d 6c6c616b     syscall_mlockall
  14b5fc:	00000000                                ....

0014b600 <__FUNCTION__.6459>:
  14b600:	63737973 5f6c6c61 6c6e756d 616b636f     syscall_munlocka
  14b610:	00006c6c                                ll..

0014b614 <__FUNCTION__.6464>:
  14b614:	63737973 5f6c6c61 65686373 65735f64     syscall_sched_se
  14b624:	72617074 00006d61                       tparam..

0014b62c <__FUNCTION__.6469>:
  14b62c:	63737973 5f6c6c61 65686373 65675f64     syscall_sched_ge
  14b63c:	72617074 00006d61                       tparam..

0014b644 <__FUNCTION__.6475>:
  14b644:	63737973 5f6c6c61 65686373 65735f64     syscall_sched_se
  14b654:	68637374 6c756465 00007265              tscheduler..

0014b660 <__FUNCTION__.6481>:
  14b660:	63737973 5f6c6c61 65686373 65675f64     syscall_sched_ge
  14b670:	68637374 6c756465 00007265              tscheduler..

0014b67c <__FUNCTION__.6484>:
  14b67c:	63737973 5f6c6c61 65686373 69795f64     syscall_sched_yi
  14b68c:	00646c65                                eld.

0014b690 <__FUNCTION__.6488>:
  14b690:	63737973 5f6c6c61 65686373 65675f64     syscall_sched_ge
  14b6a0:	72705f74 69726f69 6d5f7974 00007861     t_priority_max..

0014b6b0 <__FUNCTION__.6492>:
  14b6b0:	63737973 5f6c6c61 65686373 65675f64     syscall_sched_ge
  14b6c0:	72705f74 69726f69 6d5f7974 00006e69     t_priority_min..

0014b6d0 <__FUNCTION__.6495>:
  14b6d0:	63737973 5f6c6c61 65686373 72725f64     syscall_sched_rr
  14b6e0:	7465675f 746e695f 61767265 0000006c     _get_interval...

0014b6f0 <__FUNCTION__.6500>:
  14b6f0:	63737973 5f6c6c61 6f6e616e 65656c73     syscall_nanoslee
  14b700:	00000070                                p...

0014b704 <__FUNCTION__.6508>:
  14b704:	63737973 5f6c6c61 6d65726d 00007061     syscall_mremap..

0014b714 <__FUNCTION__.6511>:
  14b714:	63737973 5f6c6c61 72746573 69757365     syscall_setresui
  14b724:	00000064                                d...

0014b728 <__FUNCTION__.6514>:
  14b728:	63737973 5f6c6c61 72746567 69757365     syscall_getresui
  14b738:	00000064                                d...

0014b73c <__FUNCTION__.6520>:
  14b73c:	63737973 5f6c6c61 6c6c6f70 00000000     syscall_poll....

0014b74c <__FUNCTION__.6523>:
  14b74c:	63737973 5f6c6c61 7373666e 63767265     syscall_nfsservc
  14b75c:	00006c74                                tl..

0014b760 <__FUNCTION__.6526>:
  14b760:	63737973 5f6c6c61 72746573 69677365     syscall_setresgi
  14b770:	00000064                                d...

0014b774 <__FUNCTION__.6529>:
  14b774:	63737973 5f6c6c61 72746567 69677365     syscall_getresgi
  14b784:	00000064                                d...

0014b788 <__FUNCTION__.6532>:
  14b788:	63737973 5f6c6c61 74637270 0000006c     syscall_prctl...

0014b798 <__FUNCTION__.6535>:
  14b798:	63737973 5f6c6c61 735f7472 65726769     syscall_rt_sigre
  14b7a8:	6e727574 00000000                       turn....

0014b7b0 <__FUNCTION__.6543>:
  14b7b0:	63737973 5f6c6c61 735f7472 63616769     syscall_rt_sigac
  14b7c0:	6e6f6974 00000000                       tion....

0014b7c8 <__FUNCTION__.6551>:
  14b7c8:	63737973 5f6c6c61 735f7472 72706769     syscall_rt_sigpr
  14b7d8:	616d636f 00006b73                       ocmask..

0014b7e0 <__FUNCTION__.6554>:
  14b7e0:	63737973 5f6c6c61 735f7472 65706769     syscall_rt_sigpe
  14b7f0:	6e69646e 00000067                       nding...

0014b7f8 <__FUNCTION__.6557>:
  14b7f8:	63737973 5f6c6c61 735f7472 69746769     syscall_rt_sigti
  14b808:	7764656d 00746961                       medwait.

0014b810 <__FUNCTION__.6560>:
  14b810:	63737973 5f6c6c61 735f7472 75716769     syscall_rt_sigqu
  14b820:	69657565 006f666e                       eueinfo.

0014b828 <__FUNCTION__.6563>:
  14b828:	63737973 5f6c6c61 735f7472 75736769     syscall_rt_sigsu
  14b838:	6e657073 00000064                       spend...

0014b840 <__FUNCTION__.6566>:
  14b840:	63737973 5f6c6c61 61657270 00343664     syscall_pread64.

0014b850 <__FUNCTION__.6569>:
  14b850:	63737973 5f6c6c61 69727770 34366574     syscall_pwrite64
  14b860:	00000000                                ....

0014b864 <__FUNCTION__.6572>:
  14b864:	63737973 5f6c6c61 776f6863 0000006e     syscall_chown...

0014b874 <__FUNCTION__.6577>:
  14b874:	63737973 5f6c6c61 63746567 00006477     syscall_getcwd..

0014b884 <__FUNCTION__.6580>:
  14b884:	63737973 5f6c6c61 67706163 00007465     syscall_capget..

0014b894 <__FUNCTION__.6583>:
  14b894:	63737973 5f6c6c61 73706163 00007465     syscall_capset..

0014b8a4 <__FUNCTION__.6586>:
  14b8a4:	63737973 5f6c6c61 61676973 7473746c     syscall_sigaltst
  14b8b4:	006b6361                                ack.

0014b8b8 <__FUNCTION__.6589>:
  14b8b8:	63737973 5f6c6c61 646e6573 656c6966     syscall_sendfile
  14b8c8:	00000000                                ....

0014b8cc <__FUNCTION__.6592>:
  14b8cc:	63737973 5f6c6c61 726f6676 0000006b     syscall_vfork...

0014b8dc <__FUNCTION__.6597>:
  14b8dc:	63737973 5f6c6c61 74656775 6d696c72     syscall_ugetrlim
  14b8ec:	00007469                                it..

0014b8f0 <__FUNCTION__.6606>:
  14b8f0:	63737973 5f6c6c61 70616d6d 00000032     syscall_mmap2...

0014b900 <__FUNCTION__.6609>:
  14b900:	63737973 5f6c6c61 6e757274 65746163     syscall_truncate
  14b910:	00003436                                64..

0014b914 <__FUNCTION__.6612>:
  14b914:	63737973 5f6c6c61 75727466 7461636e     syscall_ftruncat
  14b924:	00343665                                e64.

0014b928 <__FUNCTION__.6617>:
  14b928:	63737973 5f6c6c61 74617473 00003436     syscall_stat64..

0014b938 <__FUNCTION__.6622>:
  14b938:	63737973 5f6c6c61 6174736c 00343674     syscall_lstat64.

0014b948 <__FUNCTION__.6627>:
  14b948:	63737973 5f6c6c61 61747366 00343674     syscall_fstat64.

0014b958 <__FUNCTION__.6630>:
  14b958:	63737973 5f6c6c61 6f68636c 32336e77     syscall_lchown32
  14b968:	00000000                                ....

0014b96c <__FUNCTION__.6633>:
  14b96c:	63737973 5f6c6c61 75746567 32336469     syscall_getuid32
  14b97c:	00000000                                ....

0014b980 <__FUNCTION__.6636>:
  14b980:	63737973 5f6c6c61 67746567 32336469     syscall_getgid32
  14b990:	00000000                                ....

0014b994 <__FUNCTION__.6639>:
  14b994:	63737973 5f6c6c61 65746567 33646975     syscall_geteuid3
  14b9a4:	00000032                                2...

0014b9a8 <__FUNCTION__.6642>:
  14b9a8:	63737973 5f6c6c61 65746567 33646967     syscall_getegid3
  14b9b8:	00000032                                2...

0014b9bc <__FUNCTION__.6645>:
  14b9bc:	63737973 5f6c6c61 72746573 64697565     syscall_setreuid
  14b9cc:	00003233                                32..

0014b9d0 <__FUNCTION__.6648>:
  14b9d0:	63737973 5f6c6c61 72746573 64696765     syscall_setregid
  14b9e0:	00003233                                32..

0014b9e4 <__FUNCTION__.6651>:
  14b9e4:	63737973 5f6c6c61 67746567 70756f72     syscall_getgroup
  14b9f4:	00323373                                s32.

0014b9f8 <__FUNCTION__.6654>:
  14b9f8:	63737973 5f6c6c61 67746573 70756f72     syscall_setgroup
  14ba08:	00323373                                s32.

0014ba0c <__FUNCTION__.6657>:
  14ba0c:	63737973 5f6c6c61 6f686366 32336e77     syscall_fchown32
  14ba1c:	00000000                                ....

0014ba20 <__FUNCTION__.6660>:
  14ba20:	63737973 5f6c6c61 72746573 69757365     syscall_setresui
  14ba30:	00323364                                d32.

0014ba34 <__FUNCTION__.6663>:
  14ba34:	63737973 5f6c6c61 72746567 69757365     syscall_getresui
  14ba44:	00323364                                d32.

0014ba48 <__FUNCTION__.6666>:
  14ba48:	63737973 5f6c6c61 72746573 69677365     syscall_setresgi
  14ba58:	00323364                                d32.

0014ba5c <__FUNCTION__.6669>:
  14ba5c:	63737973 5f6c6c61 72746567 69677365     syscall_getresgi
  14ba6c:	00323364                                d32.

0014ba70 <__FUNCTION__.6672>:
  14ba70:	63737973 5f6c6c61 776f6863 0032336e     syscall_chown32.

0014ba80 <__FUNCTION__.6675>:
  14ba80:	63737973 5f6c6c61 75746573 32336469     syscall_setuid32
  14ba90:	00000000                                ....

0014ba94 <__FUNCTION__.6678>:
  14ba94:	63737973 5f6c6c61 67746573 32336469     syscall_setgid32
  14baa4:	00000000                                ....

0014baa8 <__FUNCTION__.6681>:
  14baa8:	63737973 5f6c6c61 66746573 64697573     syscall_setfsuid
  14bab8:	00003233                                32..

0014babc <__FUNCTION__.6684>:
  14babc:	63737973 5f6c6c61 66746573 64696773     syscall_setfsgid
  14bacc:	00003233                                32..

0014bad0 <__FUNCTION__.6690>:
  14bad0:	63737973 5f6c6c61 64746567 73746e65     syscall_getdents
  14bae0:	00003436                                64..

0014bae4 <__FUNCTION__.6693>:
  14bae4:	63737973 5f6c6c61 6f766970 6f725f74     syscall_pivot_ro
  14baf4:	0000746f                                ot..

0014baf8 <__FUNCTION__.6696>:
  14baf8:	63737973 5f6c6c61 636e696d 0065726f     syscall_mincore.

0014bb08 <__FUNCTION__.6702>:
  14bb08:	63737973 5f6c6c61 7664616d 00657369     syscall_madvise.

0014bb18 <__FUNCTION__.6708>:
  14bb18:	63737973 5f6c6c61 746e6366 0034366c     syscall_fcntl64.

0014bb28 <__FUNCTION__.6711>:
  14bb28:	63737973 5f6c6c61 74746567 00006469     syscall_gettid..

0014bb38 <__FUNCTION__.6714>:
  14bb38:	63737973 5f6c6c61 64616572 61656861     syscall_readahea
  14bb48:	00000064                                d...

0014bb4c <__FUNCTION__.6717>:
  14bb4c:	63737973 5f6c6c61 78746573 72747461     syscall_setxattr
  14bb5c:	00000000                                ....

0014bb60 <__FUNCTION__.6720>:
  14bb60:	63737973 5f6c6c61 7465736c 74746178     syscall_lsetxatt
  14bb70:	00000072                                r...

0014bb74 <__FUNCTION__.6723>:
  14bb74:	63737973 5f6c6c61 74657366 74746178     syscall_fsetxatt
  14bb84:	00000072                                r...

0014bb88 <__FUNCTION__.6726>:
  14bb88:	63737973 5f6c6c61 78746567 72747461     syscall_getxattr
  14bb98:	00000000                                ....

0014bb9c <__FUNCTION__.6729>:
  14bb9c:	63737973 5f6c6c61 7465676c 74746178     syscall_lgetxatt
  14bbac:	00000072                                r...

0014bbb0 <__FUNCTION__.6732>:
  14bbb0:	63737973 5f6c6c61 74656766 74746178     syscall_fgetxatt
  14bbc0:	00000072                                r...

0014bbc4 <__FUNCTION__.6735>:
  14bbc4:	63737973 5f6c6c61 7473696c 74746178     syscall_listxatt
  14bbd4:	00000072                                r...

0014bbd8 <__FUNCTION__.6738>:
  14bbd8:	63737973 5f6c6c61 73696c6c 74617874     syscall_llistxat
  14bbe8:	00007274                                tr..

0014bbec <__FUNCTION__.6741>:
  14bbec:	63737973 5f6c6c61 73696c66 74617874     syscall_flistxat
  14bbfc:	00007274                                tr..

0014bc00 <__FUNCTION__.6744>:
  14bc00:	63737973 5f6c6c61 6f6d6572 61786576     syscall_removexa
  14bc10:	00727474                                ttr.

0014bc14 <__FUNCTION__.6747>:
  14bc14:	63737973 5f6c6c61 6d65726c 7865766f     syscall_lremovex
  14bc24:	72747461 00000000                       attr....

0014bc2c <__FUNCTION__.6750>:
  14bc2c:	63737973 5f6c6c61 6d657266 7865766f     syscall_fremovex
  14bc3c:	72747461 00000000                       attr....

0014bc44 <__FUNCTION__.6755>:
  14bc44:	63737973 5f6c6c61 6c696b74 0000006c     syscall_tkill...

0014bc54 <__FUNCTION__.6758>:
  14bc54:	63737973 5f6c6c61 646e6573 656c6966     syscall_sendfile
  14bc64:	00003436                                64..

0014bc68 <__FUNCTION__.6767>:
  14bc68:	63737973 5f6c6c61 65747566 00000078     syscall_futex...

0014bc78 <__FUNCTION__.6773>:
  14bc78:	63737973 5f6c6c61 65686373 65735f64     syscall_sched_se
  14bc88:	66666174 74696e69 00000079              taffinity...

0014bc94 <__FUNCTION__.6776>:
  14bc94:	63737973 5f6c6c61 65686373 65675f64     syscall_sched_ge
  14bca4:	66666174 74696e69 00000079              taffinity...

0014bcb0 <__FUNCTION__.6779>:
  14bcb0:	63737973 5f6c6c61 735f6f69 70757465     syscall_io_setup
  14bcc0:	00000000                                ....

0014bcc4 <__FUNCTION__.6782>:
  14bcc4:	63737973 5f6c6c61 645f6f69 72747365     syscall_io_destr
  14bcd4:	0000796f                                oy..

0014bcd8 <__FUNCTION__.6785>:
  14bcd8:	63737973 5f6c6c61 675f6f69 76657465     syscall_io_getev
  14bce8:	73746e65 00000000                       ents....

0014bcf0 <__FUNCTION__.6788>:
  14bcf0:	63737973 5f6c6c61 735f6f69 696d6275     syscall_io_submi
  14bd00:	00000074                                t...

0014bd04 <__FUNCTION__.6791>:
  14bd04:	63737973 5f6c6c61 635f6f69 65636e61     syscall_io_cance
  14bd14:	0000006c                                l...

0014bd18 <__FUNCTION__.6795>:
  14bd18:	63737973 5f6c6c61 74697865 6f72675f     syscall_exit_gro
  14bd28:	00007075                                up..

0014bd2c <__FUNCTION__.6798>:
  14bd2c:	63737973 5f6c6c61 6b6f6f6c 645f7075     syscall_lookup_d
  14bd3c:	6b6f6f63 00006569                       cookie..

0014bd44 <__FUNCTION__.6801>:
  14bd44:	63737973 5f6c6c61 6c6f7065 72635f6c     syscall_epoll_cr
  14bd54:	65746165 00000000                       eate....

0014bd5c <__FUNCTION__.6804>:
  14bd5c:	63737973 5f6c6c61 6c6f7065 74635f6c     syscall_epoll_ct
  14bd6c:	0000006c                                l...

0014bd70 <__FUNCTION__.6807>:
  14bd70:	63737973 5f6c6c61 6c6f7065 61775f6c     syscall_epoll_wa
  14bd80:	00007469                                it..

0014bd84 <__FUNCTION__.6810>:
  14bd84:	63737973 5f6c6c61 616d6572 69665f70     syscall_remap_fi
  14bd94:	705f656c 73656761 00000000              le_pages....

0014bda0 <__FUNCTION__.6814>:
  14bda0:	63737973 5f6c6c61 5f746573 5f646974     syscall_set_tid_
  14bdb0:	72646461 00737365                       address.

0014bdb8 <__FUNCTION__.6817>:
  14bdb8:	63737973 5f6c6c61 656d6974 72635f72     syscall_timer_cr
  14bdc8:	65746165 00000000                       eate....

0014bdd0 <__FUNCTION__.6820>:
  14bdd0:	63737973 5f6c6c61 656d6974 65735f72     syscall_timer_se
  14bde0:	6d697474 00000065                       ttime...

0014bde8 <__FUNCTION__.6823>:
  14bde8:	63737973 5f6c6c61 656d6974 65675f72     syscall_timer_ge
  14bdf8:	6d697474 00000065                       ttime...

0014be00 <__FUNCTION__.6826>:
  14be00:	63737973 5f6c6c61 656d6974 65675f72     syscall_timer_ge
  14be10:	65766f74 6e757272 00000000              toverrun....

0014be1c <__FUNCTION__.6829>:
  14be1c:	63737973 5f6c6c61 656d6974 65645f72     syscall_timer_de
  14be2c:	6574656c 00000000                       lete....

0014be34 <__FUNCTION__.6834>:
  14be34:	63737973 5f6c6c61 636f6c63 65735f6b     syscall_clock_se
  14be44:	6d697474 00000065                       ttime...

0014be4c <__FUNCTION__.6839>:
  14be4c:	63737973 5f6c6c61 636f6c63 65675f6b     syscall_clock_ge
  14be5c:	6d697474 00000065                       ttime...

0014be64 <__FUNCTION__.6844>:
  14be64:	63737973 5f6c6c61 636f6c63 65675f6b     syscall_clock_ge
  14be74:	73657274 00000000                       tres....

0014be7c <__FUNCTION__.6847>:
  14be7c:	63737973 5f6c6c61 636f6c63 616e5f6b     syscall_clock_na
  14be8c:	6c736f6e 00706565                       nosleep.

0014be94 <__FUNCTION__.6853>:
  14be94:	63737973 5f6c6c61 74617473 34367366     syscall_statfs64
  14bea4:	00000000                                ....

0014bea8 <__FUNCTION__.6859>:
  14bea8:	63737973 5f6c6c61 61747366 36736674     syscall_fstatfs6
  14beb8:	00000034                                4...

0014bebc <__FUNCTION__.6862>:
  14bebc:	63737973 5f6c6c61 696b6774 00006c6c     syscall_tgkill..

0014becc <__FUNCTION__.6865>:
  14becc:	63737973 5f6c6c61 6d697475 00007365     syscall_utimes..

0014bedc <__FUNCTION__.6868>:
  14bedc:	63737973 5f6c6c61 5f6d7261 76646166     syscall_arm_fadv
  14beec:	36657369 34365f34 00000000              ise64_64....

0014bef8 <__FUNCTION__.6871>:
  14bef8:	63737973 5f6c6c61 63696370 69666e6f     syscall_pciconfi
  14bf08:	6f695f67 65736162 00000000              g_iobase....

0014bf14 <__FUNCTION__.6874>:
  14bf14:	63737973 5f6c6c61 63696370 69666e6f     syscall_pciconfi
  14bf24:	65725f67 00006461                       g_read..

0014bf2c <__FUNCTION__.6877>:
  14bf2c:	63737973 5f6c6c61 63696370 69666e6f     syscall_pciconfi
  14bf3c:	72775f67 00657469                       g_write.

0014bf44 <__FUNCTION__.6880>:
  14bf44:	63737973 5f6c6c61 6f5f716d 006e6570     syscall_mq_open.

0014bf54 <__FUNCTION__.6883>:
  14bf54:	63737973 5f6c6c61 755f716d 6e696c6e     syscall_mq_unlin
  14bf64:	0000006b                                k...

0014bf68 <__FUNCTION__.6886>:
  14bf68:	63737973 5f6c6c61 745f716d 64656d69     syscall_mq_timed
  14bf78:	646e6573 00000000                       send....

0014bf80 <__FUNCTION__.6889>:
  14bf80:	63737973 5f6c6c61 745f716d 64656d69     syscall_mq_timed
  14bf90:	65636572 00657669                       receive.

0014bf98 <__FUNCTION__.6892>:
  14bf98:	63737973 5f6c6c61 6e5f716d 6669746f     syscall_mq_notif
  14bfa8:	00000079                                y...

0014bfac <__FUNCTION__.6895>:
  14bfac:	63737973 5f6c6c61 675f716d 65737465     syscall_mq_getse
  14bfbc:	74746174 00000072                       tattr...

0014bfc4 <__FUNCTION__.6898>:
  14bfc4:	63737973 5f6c6c61 74696177 00006469     syscall_waitid..

0014bfd4 <__FUNCTION__.6904>:
  14bfd4:	63737973 5f6c6c61 6b636f73 00007465     syscall_socket..

0014bfe4 <__FUNCTION__.6910>:
  14bfe4:	63737973 5f6c6c61 646e6962 00000000     syscall_bind....

0014bff4 <__FUNCTION__.6916>:
  14bff4:	63737973 5f6c6c61 6e6e6f63 00746365     syscall_connect.

0014c004 <__FUNCTION__.6921>:
  14c004:	63737973 5f6c6c61 7473696c 00006e65     syscall_listen..

0014c014 <__FUNCTION__.6927>:
  14c014:	63737973 5f6c6c61 65636361 00007470     syscall_accept..

0014c024 <__FUNCTION__.6933>:
  14c024:	63737973 5f6c6c61 73746567 6e6b636f     syscall_getsockn
  14c034:	00656d61                                ame.

0014c038 <__FUNCTION__.6939>:
  14c038:	63737973 5f6c6c61 70746567 6e726565     syscall_getpeern
  14c048:	00656d61                                ame.

0014c04c <__FUNCTION__.6942>:
  14c04c:	63737973 5f6c6c61 6b636f73 61707465     syscall_socketpa
  14c05c:	00007269                                ir..

0014c060 <__FUNCTION__.6949>:
  14c060:	63737973 5f6c6c61 646e6573 00000000     syscall_send....

0014c070 <__FUNCTION__.6958>:
  14c070:	63737973 5f6c6c61 646e6573 00006f74     syscall_sendto..

0014c080 <__FUNCTION__.6965>:
  14c080:	63737973 5f6c6c61 76636572 00000000     syscall_recv....

0014c090 <__FUNCTION__.6974>:
  14c090:	63737973 5f6c6c61 76636572 6d6f7266     syscall_recvfrom
  14c0a0:	00000000                                ....

0014c0a4 <__FUNCTION__.6977>:
  14c0a4:	63737973 5f6c6c61 74756873 6e776f64     syscall_shutdown
  14c0b4:	00000000                                ....

0014c0b8 <__FUNCTION__.6985>:
  14c0b8:	63737973 5f6c6c61 73746573 6f6b636f     syscall_setsocko
  14c0c8:	00007470                                pt..

0014c0cc <__FUNCTION__.6993>:
  14c0cc:	63737973 5f6c6c61 73746567 6f6b636f     syscall_getsocko
  14c0dc:	00007470                                pt..

0014c0e0 <__FUNCTION__.6996>:
  14c0e0:	63737973 5f6c6c61 646e6573 0067736d     syscall_sendmsg.

0014c0f0 <__FUNCTION__.6999>:
  14c0f0:	63737973 5f6c6c61 76636572 0067736d     syscall_recvmsg.

0014c100 <__FUNCTION__.7002>:
  14c100:	63737973 5f6c6c61 6f6d6573 00000070     syscall_semop...

0014c110 <__FUNCTION__.7005>:
  14c110:	63737973 5f6c6c61 676d6573 00007465     syscall_semget..

0014c120 <__FUNCTION__.7008>:
  14c120:	63737973 5f6c6c61 636d6573 00006c74     syscall_semctl..

0014c130 <__FUNCTION__.7011>:
  14c130:	63737973 5f6c6c61 7367736d 0000646e     syscall_msgsnd..

0014c140 <__FUNCTION__.7014>:
  14c140:	63737973 5f6c6c61 7267736d 00007663     syscall_msgrcv..

0014c150 <__FUNCTION__.7017>:
  14c150:	63737973 5f6c6c61 6767736d 00007465     syscall_msgget..

0014c160 <__FUNCTION__.7020>:
  14c160:	63737973 5f6c6c61 6367736d 00006c74     syscall_msgctl..

0014c170 <__FUNCTION__.7026>:
  14c170:	63737973 5f6c6c61 616d6873 00000074     syscall_shmat...

0014c180 <__FUNCTION__.7030>:
  14c180:	63737973 5f6c6c61 646d6873 00000074     syscall_shmdt...

0014c190 <__FUNCTION__.7036>:
  14c190:	63737973 5f6c6c61 676d6873 00007465     syscall_shmget..

0014c1a0 <__FUNCTION__.7042>:
  14c1a0:	63737973 5f6c6c61 636d6873 00006c74     syscall_shmctl..

0014c1b0 <__FUNCTION__.7045>:
  14c1b0:	63737973 5f6c6c61 5f646461 0079656b     syscall_add_key.

0014c1c0 <__FUNCTION__.7048>:
  14c1c0:	63737973 5f6c6c61 75716572 5f747365     syscall_request_
  14c1d0:	0079656b                                key.

0014c1d4 <__FUNCTION__.7051>:
  14c1d4:	63737973 5f6c6c61 6379656b 00006c74     syscall_keyctl..

0014c1e4 <__FUNCTION__.7054>:
  14c1e4:	63737973 5f6c6c61 746d6573 64656d69     syscall_semtimed
  14c1f4:	0000706f                                op..

0014c1f8 <__FUNCTION__.7057>:
  14c1f8:	63737973 5f6c6c61 72657376 00726576     syscall_vserver.

0014c208 <__FUNCTION__.7060>:
  14c208:	63737973 5f6c6c61 72706f69 735f6f69     syscall_ioprio_s
  14c218:	00007465                                et..

0014c21c <__FUNCTION__.7063>:
  14c21c:	63737973 5f6c6c61 72706f69 675f6f69     syscall_ioprio_g
  14c22c:	00007465                                et..

0014c230 <__FUNCTION__.7066>:
  14c230:	63737973 5f6c6c61 746f6e69 5f796669     syscall_inotify_
  14c240:	74696e69 00000000                       init....

0014c248 <__FUNCTION__.7069>:
  14c248:	63737973 5f6c6c61 746f6e69 5f796669     syscall_inotify_
  14c258:	5f646461 63746177 00000068              add_watch...

0014c264 <__FUNCTION__.7072>:
  14c264:	63737973 5f6c6c61 746f6e69 5f796669     syscall_inotify_
  14c274:	775f6d72 68637461 00000000              rm_watch....

0014c280 <__FUNCTION__.7075>:
  14c280:	63737973 5f6c6c61 6e69626d 00000064     syscall_mbind...

0014c290 <__FUNCTION__.7078>:
  14c290:	63737973 5f6c6c61 5f746567 706d656d     syscall_get_memp
  14c2a0:	63696c6f 00000079                       olicy...

0014c2a8 <__FUNCTION__.7081>:
  14c2a8:	63737973 5f6c6c61 5f746573 706d656d     syscall_set_memp
  14c2b8:	63696c6f 00000079                       olicy...

0014c2c0 <__FUNCTION__.7084>:
  14c2c0:	63737973 5f6c6c61 6e65706f 00007461     syscall_openat..

0014c2d0 <__FUNCTION__.7087>:
  14c2d0:	63737973 5f6c6c61 69646b6d 00746172     syscall_mkdirat.

0014c2e0 <__FUNCTION__.7090>:
  14c2e0:	63737973 5f6c6c61 6f6e6b6d 00746164     syscall_mknodat.

0014c2f0 <__FUNCTION__.7093>:
  14c2f0:	63737973 5f6c6c61 6f686366 74616e77     syscall_fchownat
  14c300:	00000000                                ....

0014c304 <__FUNCTION__.7096>:
  14c304:	63737973 5f6c6c61 69747566 6173656d     syscall_futimesa
  14c314:	00000074                                t...

0014c318 <__FUNCTION__.7099>:
  14c318:	63737973 5f6c6c61 61747366 36746174     syscall_fstatat6
  14c328:	00000034                                4...

0014c32c <__FUNCTION__.7102>:
  14c32c:	63737973 5f6c6c61 696c6e75 74616b6e     syscall_unlinkat
  14c33c:	00000000                                ....

0014c340 <__FUNCTION__.7105>:
  14c340:	63737973 5f6c6c61 616e6572 7461656d     syscall_renameat
  14c350:	00000000                                ....

0014c354 <__FUNCTION__.7108>:
  14c354:	63737973 5f6c6c61 6b6e696c 00007461     syscall_linkat..

0014c364 <__FUNCTION__.7111>:
  14c364:	63737973 5f6c6c61 6c6d7973 616b6e69     syscall_symlinka
  14c374:	00000074                                t...

0014c378 <__FUNCTION__.7114>:
  14c378:	63737973 5f6c6c61 64616572 6b6e696c     syscall_readlink
  14c388:	00007461                                at..

0014c38c <__FUNCTION__.7117>:
  14c38c:	63737973 5f6c6c61 6d686366 7461646f     syscall_fchmodat
  14c39c:	00000000                                ....

0014c3a0 <__FUNCTION__.7120>:
  14c3a0:	63737973 5f6c6c61 63636166 61737365     syscall_faccessa
  14c3b0:	00000074                                t...

0014c3b4 <__FUNCTION__.7123>:
  14c3b4:	63737973 5f6c6c61 6c657370 36746365     syscall_pselect6
  14c3c4:	00000000                                ....

0014c3c8 <__FUNCTION__.7126>:
  14c3c8:	63737973 5f6c6c61 6c6f7070 0000006c     syscall_ppoll...

0014c3d8 <__FUNCTION__.7129>:
  14c3d8:	63737973 5f6c6c61 68736e75 00657261     syscall_unshare.

0014c3e8 <__FUNCTION__.7132>:
  14c3e8:	63737973 5f6c6c61 5f746573 75626f72     syscall_set_robu
  14c3f8:	6c5f7473 00747369                       st_list.

0014c400 <__FUNCTION__.7135>:
  14c400:	63737973 5f6c6c61 5f746567 75626f72     syscall_get_robu
  14c410:	6c5f7473 00747369                       st_list.

0014c418 <__FUNCTION__.7138>:
  14c418:	63737973 5f6c6c61 696c7073 00006563     syscall_splice..

0014c428 <__FUNCTION__.7141>:
  14c428:	63737973 5f6c6c61 5f6d7261 636e7973     syscall_arm_sync
  14c438:	6c69665f 61725f65 0065676e              _file_range.

0014c444 <__FUNCTION__.7144>:
  14c444:	63737973 5f6c6c61 00656574              syscall_tee.

0014c450 <__FUNCTION__.7147>:
  14c450:	63737973 5f6c6c61 70736d76 6563696c     syscall_vmsplice
  14c460:	00000000                                ....

0014c464 <__FUNCTION__.7150>:
  14c464:	63737973 5f6c6c61 65766f6d 6761705f     syscall_move_pag
  14c474:	00007365                                es..

0014c478 <__FUNCTION__.7153>:
  14c478:	63737973 5f6c6c61 63746567 00007570     syscall_getcpu..

0014c488 <__FUNCTION__.7156>:
  14c488:	63737973 5f6c6c61 6c6f7065 77705f6c     syscall_epoll_pw
  14c498:	00746961                                ait.

0014c49c <__FUNCTION__.7159>:
  14c49c:	63737973 5f6c6c61 6578656b 6f6c5f63     syscall_kexec_lo
  14c4ac:	00006461                                ad..

0014c4b0 <__FUNCTION__.7162>:
  14c4b0:	63737973 5f6c6c61 6d697475 61736e65     syscall_utimensa
  14c4c0:	00000074                                t...

0014c4c4 <__FUNCTION__.7165>:
  14c4c4:	63737973 5f6c6c61 6e676973 64666c61     syscall_signalfd
  14c4d4:	00000000                                ....

0014c4d8 <__FUNCTION__.7168>:
  14c4d8:	63737973 5f6c6c61 656d6974 5f646672     syscall_timerfd_
  14c4e8:	61657263 00006574                       create..

0014c4f0 <__FUNCTION__.7171>:
  14c4f0:	63737973 5f6c6c61 6e657665 00646674     syscall_eventfd.

0014c500 <__FUNCTION__.7174>:
  14c500:	63737973 5f6c6c61 6c6c6166 7461636f     syscall_fallocat
  14c510:	00000065                                e...

0014c514 <__FUNCTION__.7177>:
  14c514:	63737973 5f6c6c61 656d6974 5f646672     syscall_timerfd_
  14c524:	74746573 00656d69                       settime.

0014c52c <__FUNCTION__.7180>:
  14c52c:	63737973 5f6c6c61 656d6974 5f646672     syscall_timerfd_
  14c53c:	74746567 00656d69                       gettime.

0014c544 <__FUNCTION__.7183>:
  14c544:	63737973 5f6c6c61 6e676973 64666c61     syscall_signalfd
  14c554:	00000034                                4...

0014c558 <__FUNCTION__.7186>:
  14c558:	63737973 5f6c6c61 6e657665 32646674     syscall_eventfd2
  14c568:	00000000                                ....

0014c56c <__FUNCTION__.7189>:
  14c56c:	63737973 5f6c6c61 6c6f7065 72635f6c     syscall_epoll_cr
  14c57c:	65746165 00000031                       eate1...

0014c584 <__FUNCTION__.7192>:
  14c584:	63737973 5f6c6c61 33707564 00000000     syscall_dup3....

0014c594 <__FUNCTION__.7195>:
  14c594:	63737973 5f6c6c61 65706970 00000032     syscall_pipe2...

0014c5a4 <__FUNCTION__.7198>:
  14c5a4:	63737973 5f6c6c61 746f6e69 5f796669     syscall_inotify_
  14c5b4:	74696e69 00000031                       init1...

0014c5bc <__FUNCTION__.7201>:
  14c5bc:	63737973 5f6c6c61 61657270 00007664     syscall_preadv..

0014c5cc <__FUNCTION__.7204>:
  14c5cc:	63737973 5f6c6c61 69727770 00766574     syscall_pwritev.

0014c5dc <__FUNCTION__.7207>:
  14c5dc:	63737973 5f6c6c61 745f7472 67697367     syscall_rt_tgsig
  14c5ec:	75657571 666e6965 0000006f              queueinfo...

0014c5f8 <__FUNCTION__.7210>:
  14c5f8:	63737973 5f6c6c61 66726570 6576655f     syscall_perf_eve
  14c608:	6f5f746e 006e6570                       nt_open.

0014c610 <__FUNCTION__.7213>:
  14c610:	63737973 5f6c6c61 76636572 67736d6d     syscall_recvmmsg
  14c620:	00000000                                ....

0014c624 <__FUNCTION__.7216>:
  14c624:	63737973 5f6c6c61 65636361 00347470     syscall_accept4.

0014c634 <__FUNCTION__.7219>:
  14c634:	63737973 5f6c6c61 6f6e6166 79666974     syscall_fanotify
  14c644:	696e695f 00000074                       _init...

0014c64c <__FUNCTION__.7222>:
  14c64c:	63737973 5f6c6c61 6f6e6166 79666974     syscall_fanotify
  14c65c:	72616d5f 0000006b                       _mark...

0014c664 <__FUNCTION__.7230>:
  14c664:	63737973 5f6c6c61 696c7270 3674696d     syscall_prlimit6
  14c674:	00000034                                4...

0014c678 <__FUNCTION__.7233>:
  14c678:	63737973 5f6c6c61 656d616e 5f6f745f     syscall_name_to_
  14c688:	646e6168 615f656c 00000074              handle_at...

0014c694 <__FUNCTION__.7236>:
  14c694:	63737973 5f6c6c61 6e65706f 5f79625f     syscall_open_by_
  14c6a4:	646e6168 615f656c 00000074              handle_at...

0014c6b0 <__FUNCTION__.7239>:
  14c6b0:	63737973 5f6c6c61 636f6c63 64615f6b     syscall_clock_ad
  14c6c0:	6d69746a 00000065                       jtime...

0014c6c8 <__FUNCTION__.7242>:
  14c6c8:	63737973 5f6c6c61 636e7973 00007366     syscall_syncfs..

0014c6d8 <__FUNCTION__.7245>:
  14c6d8:	63737973 5f6c6c61 646e6573 67736d6d     syscall_sendmmsg
  14c6e8:	00000000                                ....

0014c6ec <__FUNCTION__.7248>:
  14c6ec:	63737973 5f6c6c61 6e746573 00000073     syscall_setns...

0014c6fc <__FUNCTION__.7251>:
  14c6fc:	63737973 5f6c6c61 636f7270 5f737365     syscall_process_
  14c70c:	725f6d76 76646165 00000000              vm_readv....

0014c718 <__FUNCTION__.7254>:
  14c718:	63737973 5f6c6c61 636f7270 5f737365     syscall_process_
  14c728:	775f6d76 65746972 00000076              vm_writev...

0014c734 <__FUNCTION__.7257>:
  14c734:	63737973 5f6c6c61 706d636b 00000000     syscall_kcmp....

0014c744 <__FUNCTION__.7260>:
  14c744:	63737973 5f6c6c61 696e6966 6f6d5f74     syscall_finit_mo
  14c754:	656c7564 00000000                       dule....

0014c75c <__FUNCTION__.7263>:
  14c75c:	63737973 5f6c6c61 65686373 65735f64     syscall_sched_se
  14c76c:	74746174 00000072                       tattr...

0014c774 <__FUNCTION__.7266>:
  14c774:	63737973 5f6c6c61 65686373 65675f64     syscall_sched_ge
  14c784:	74746174 00000072                       tattr...

0014c78c <__FUNCTION__.7269>:
  14c78c:	63737973 5f6c6c61 616e6572 7461656d     syscall_renameat
  14c79c:	00000032                                2...

0014c7a0 <__FUNCTION__.7272>:
  14c7a0:	63737973 5f6c6c61 63636573 00706d6f     syscall_seccomp.

0014c7b0 <__FUNCTION__.7278>:
  14c7b0:	63737973 5f6c6c61 72746567 6f646e61     syscall_getrando
  14c7c0:	0000006d                                m...

0014c7c4 <__FUNCTION__.7281>:
  14c7c4:	63737973 5f6c6c61 666d656d 72635f64     syscall_memfd_cr
  14c7d4:	65746165 00000000                       eate....

0014c7dc <__FUNCTION__.7284>:
  14c7dc:	63737973 5f6c6c61 00667062              syscall_bpf.

0014c7e8 <__FUNCTION__.7287>:
  14c7e8:	63737973 5f6c6c61 63657865 74616576     syscall_execveat
  14c7f8:	00000000                                ....

0014c7fc <__FUNCTION__.7290>:
  14c7fc:	63737973 5f6c6c61 72657375 6c756166     syscall_userfaul
  14c80c:	00646674                                tfd.

0014c810 <__FUNCTION__.7293>:
  14c810:	63737973 5f6c6c61 626d656d 69727261     syscall_membarri
  14c820:	00007265                                er..

0014c824 <__FUNCTION__.7296>:
  14c824:	63737973 5f6c6c61 636f6c6d 0000326b     syscall_mlock2..

0014c834 <__FUNCTION__.7299>:
  14c834:	63737973 5f6c6c61 79706f63 6c69665f     syscall_copy_fil
  14c844:	61725f65 0065676e                       e_range.

0014c84c <__FUNCTION__.7302>:
  14c84c:	63737973 5f6c6c61 61657270 00327664     syscall_preadv2.

0014c85c <__FUNCTION__.7305>:
  14c85c:	63737973 5f6c6c61 69727770 32766574     syscall_pwritev2
  14c86c:	00000000                                ....

0014c870 <__FUNCTION__.7308>:
  14c870:	63737973 5f6c6c61 79656b70 72706d5f     syscall_pkey_mpr
  14c880:	6365746f 00000074                       otect...

0014c888 <__FUNCTION__.7311>:
  14c888:	63737973 5f6c6c61 79656b70 6c6c615f     syscall_pkey_all
  14c898:	0000636f                                oc..

0014c89c <__FUNCTION__.7314>:
  14c89c:	63737973 5f6c6c61 79656b70 6572665f     syscall_pkey_fre
  14c8ac:	00000065                                e...

0014c8b0 <__FUNCTION__.7317>:
  14c8b0:	63737973 5f6c6c61 74617473 00000078     syscall_statx...

0014c8c0 <__FUNCTION__.7320>:
  14c8c0:	63737973 5f6c6c61 71657372 00000000     syscall_rseq....

0014c8d0 <__FUNCTION__.7323>:
  14c8d0:	63737973 5f6c6c61 705f6f69 65746567     syscall_io_pgete
  14c8e0:	746e6576 00000073 335b1a0a 5b206d34     vents.....[34m [
  14c8f0:	64202020 7973206f 6c616373 203a5d6c        do syscall]: 
  14c900:	6d305b1b 00000000                       .[0m....

0014c908 <syscall_table>:
  14c908:	0013b23c 0013b498 0013c4d0 0013bf38     <...........8...
  14c918:	0013bf00 0013bec8 0013b470 00000000     ........p.......
  14c928:	0013b220 0013b204 0013b448 0013be90      .......H.......
  14c938:	0013b420 00000000 0013b1e8 0013b1cc      ...............
  14c948:	0013b1b0 00000000 00000000 0013c538     ............8...
  14c958:	0013c4b0 0013b194 00000000 0013b178     ............x...
  14c968:	0013b15c 00000000 0013b140 00000000     \.......@.......
  14c978:	00000000 0013b124 00000000 00000000     ....$...........
  14c988:	00000000 0013b8b0 0013b108 00000000     ................
  14c998:	0013b0ec 0013b880 0013b850 0013b820     ........P... ...
  14c9a8:	0013b3f8 0013b3d0 0013b3a8 0013b0d0     ................
  14c9b8:	00000000 0013b380 0013b0b4 0013b098     ................
  14c9c8:	00000000 0013b07c 0013b060 0013b044     ....|...`...D...
  14c9d8:	0013b028 00000000 0013c4f0 0013be58     (...........X...
  14c9e8:	00000000 0013b00c 00000000 00000000     ................
  14c9f8:	0013aff0 0013afd4 0013afb8 0013b7f0     ................
  14ca08:	0013af9c 0013af80 0013c490 0013c120     ............ ...
	...
  14ca20:	0013af64 0013af48 0013af2c 0013af10     d...H...,.......
  14ca30:	0013aef4 0013b7c0 00000000 0013aed8     ................
  14ca40:	0013aebc 0013aea0 0013ae84 0013ae68     ............h...
  14ca50:	00000000 0013ae4c 00000000 0013be20     ....L....... ...
  14ca60:	0013ae30 0013ae14 0013adf8 00000000     0...............
  14ca70:	00000000 0013b790 0013addc 0013adc0     ................
  14ca80:	0013ada4 0013ad88 0013ad6c 0013ad50     ........l...P...
  14ca90:	00000000 0013ad34 0013ad18 00000000     ....4...........
  14caa0:	00000000 0013acfc 0013ace0 0013acc4     ................
  14cab0:	0013b760 0013b730 0013aca8 00000000     `...0...........
  14cac0:	00000000 0013ac8c 00000000 00000000     ................
  14cad0:	0013ac70 0013ac54 0013ac38 00000000     p...T...8.......
  14cae0:	0013b358 0013ac1c 0013ac00 0013abe4     X...............
  14caf0:	0013abc8 00000000 0013abac 0013ab90     ................
  14cb00:	0013c0d8 00000000 0013ab74 0013ab58     ........t...X...
  14cb10:	00000000 0013ab3c 0013ab20 0013ab04     ....<... .......
  14cb20:	0013aae8 0013aacc 0013aab0 00000000     ................
  14cb30:	0013aa94 0013aa78 0013c2a8 0013bde8     ....x...........
  14cb40:	0013c258 0013aa5c 0013aa40 0013bd44     X...\...@...D...
  14cb50:	0013bca0 0013aa24 0013aa08 0013a9ec     ....$...........
  14cb60:	0013a9d0 0013a9b4 0013a998 0013a97c     ............|...
  14cb70:	0013b700 0013b6d0 0013bc68 0013bc30     ........h...0...
  14cb80:	0013a960 0013b330 0013b308 0013a944     `...0.......D...
  14cb90:	0013b6a0 0013c208 0013a928 0013a90c     ........(.......
	...
  14cba8:	0013bbf8 0013a8f0 0013a8d4 0013a8b8     ................
  14cbb8:	0013a89c 0013a880 0013c090 0013c048     ............H...
  14cbc8:	0013a864 0013a848 0013a82c 0013a810     d...H...,.......
  14cbd8:	0013a7f4 0013a7d8 0013a7bc 0013b670     ............p...
  14cbe8:	0013a7a0 0013a784 0013a768 0013a74c     ........h...L...
	...
  14cc00:	0013c470 0013b640 0013c400 0013a730     p...@.......0...
  14cc10:	0013a714 0013b610 0013b5e0 0013b5b0     ................
  14cc20:	0013a6f8 0013a6dc 0013a6c0 0013a6a4     ................
  14cc30:	0013a688 0013a66c 0013a650 0013a634     ....l...P...4...
  14cc40:	0013a618 0013a5fc 0013a5e0 0013a5c4     ................
  14cc50:	0013a5a8 0013a58c 0013a570 0013a554     ........p...T...
  14cc60:	0013a538 0013a51c 0013a500 0013bbc0     8...............
  14cc70:	0013a4e4 0013a4c8 0013bb88 0013bb50     ............P...
	...
  14cc88:	0013c450 0013a4ac 0013a490 0013a474     P...........t...
  14cc98:	0013a458 0013a43c 0013a420 0013a404     X...<... .......
  14cca8:	0013a3e8 0013a3cc 0013a3b0 0013a394     ................
  14ccb8:	0013a378 0013a35c 0013b580 0013a340     x...\.......@...
  14ccc8:	0013c3ac 0013bb18 0013a324 0013a308     ........$.......
  14ccd8:	0013a2ec 0013a2d0 0013a2b4 0013a298     ................
  14cce8:	0013b2e0 0013a27c 0013a260 0013a244     ....|...`...D...
  14ccf8:	0013a228 0013a20c 00000000 00000000     (...............
  14cd08:	0013b2b8 0013a1f0 0013a1d4 0013a1b8     ................
  14cd18:	0013a19c 0013a180 0013b550 0013b520     ........P... ...
  14cd28:	0013b4f0 0013a164 0013a148 0013a12c     ....d...H...,...
  14cd38:	0013a110 0013a0f4 0013a0d8 0013a0bc     ................
  14cd48:	0013a0a0 0013a084 0013a068 0013a04c     ........h...L...
  14cd58:	0013a030 0013a014 00139ff8 00139fdc     0...............
  14cd68:	00139fc0 0013bae0 0013baa8 0013ba70     ............p...
  14cd78:	0013b4c0 0013ba38 0013ba00 0013b9c8     ....8...........
  14cd88:	00139fa4 0013c000 0013c358 0013bfb8     ........X.......
  14cd98:	0013c304 00139f88 0013c1b8 0013c168     ............h...
  14cda8:	00139f6c 00139f50 00139f34 00139f18     l...P...4.......
  14cdb8:	00139efc 00139ee0 00139ec4 00139ea8     ................
  14cdc8:	00139e8c 0013b98c 0013b28c 0013b950     ............P...
  14cdd8:	0013b918 00139e70 00139e54 00139e38     ....p...T...8...
  14cde8:	00139e1c 00139e00 00139de4 00139dc8     ................
  14cdf8:	00139dac 00139d90 00139d74 00139d58     ........t...X...
  14ce08:	00139d3c 00139d20 00139d04 00139ce8     <... ...........
  14ce18:	00139ccc 00139cb0 00139c94 00139c78     ............x...
  14ce28:	00139c5c 00139c40 00139c24 00139c08     \...@...$.......
  14ce38:	00139bec 00139bd0 00139bb4 00139b98     ................
  14ce48:	00139b7c 00139b60 00139b44 00139b28     |...`...D...(...
  14ce58:	00139b0c 00139af0 00139ad4 00139ab8     ................
  14ce68:	00139a9c 00139a80 00139a64 00139a48     ........d...H...
  14ce78:	00139a2c 00139a10 001399f4 001399d8     ,...............
  14ce88:	001399bc 001399a0 00139984 00139968     ............h...
  14ce98:	0013994c 00139930 00139914 001398f8     L...0...........
  14cea8:	001398dc 001398c0 001398a4 00139888     ................
  14ceb8:	0013986c 00139850 00139834 00139818     l...P...4.......
  14cec8:	001397fc 0013bf70 001397e0 001397c4     ....p...........
  14ced8:	001397a8 0013978c 00139770 00139754     ........p...T...
  14cee8:	00139738 0013971c 00139700 001396e4     8...............
  14cef8:	001396c8 001396ac 00139690 00139674     ............t...
  14cf08:	0013b8e0 00139658 0013963c 00139620     ....X...<... ...
  14cf18:	00139604 001395e8 001395cc 001395b0     ................
  14cf28:	00139594 00139578 0013955c 00139540     ....x...\...@...
  14cf38:	00139524 00139508 001394ec 001394d0     $...............
  14cf48:	335b1b0a 5b206d31 74706d65 79732079     ..[31m [empty sy
  14cf58:	6c616373 203a5d6c 6d305b1b 00000000     scall]: .[0m....

0014cf68 <bin_tab>:
  14cf68:	23222120 25252424 27272626 28282828      !"#$$%%&&''((((
  14cf78:	29292929 2a2a2a2a 2b2b2b2b 2c2c2c2c     ))))****++++,,,,
  14cf88:	2c2c2c2c 2d2d2d2d 2d2d2d2d 2e2e2e2e     ,,,,--------....
  14cf98:	2e2e2e2e 2f2f2f2f 2f2f2f2f              ....////////

0014cfa4 <stderr>:
  14cfa4:	0014e2a8                                ....

0014cfa8 <stdout>:
  14cfa8:	0014e340 20202b2d 30583020 00000078     @...-+   0X0x...
  14cfb8:	6c756e28 0000296c 2b58302d 30205830     (null)..-0X+0X 0
  14cfc8:	78302d58 2078302b 00007830 00666e69     X-0x+0x 0x..inf.
  14cfd8:	00464e49 006e616e 004e414e 0000002e     INF.nan.NAN.....

0014cfe8 <states>:
  14cfe8:	000a0019 00191919 05000000 00000000     ................
  14cff8:	00090000 0b000000 00000000 00000000     ................
  14d008:	0a110019 03191919 0100070a 180b091b     ................
  14d018:	06090000 0b00000b 00190600 19190000     ................
  14d028:	00000019 00000000 00000000 00000000     ................
  14d038:	00000e00 00000000 00190000 19190d0a     ................
  14d048:	000d0019 09000200 0000000e 000e0009     ................
  14d058:	00000e00 00000000 00000000 00000000     ................
	...
  14d070:	0c000000 00000000 00000000 13000000     ................
  14d080:	00000000 00000013 000c0900 00000000     ................
  14d090:	0c00000c 00000000 00000000 00000000     ................
	...
  14d0ac:	00001000 00000000 00000000 00000f00     ................
  14d0bc:	000f0400 09000000 00000010 00100000     ................
  14d0cc:	00001000 00000000 00000000 00000000     ................
	...
  14d0e4:	12000000 00000000 00000000 11000000     ................
  14d0f4:	00000000 00000011 00120900 00000000     ................
  14d104:	12000012 001a0000 1a1a0000 0000001a     ................
	...
  14d128:	001a0000 1a1a0000 0000001a 09000000     ................
	...
  14d158:	14000000 00000000 00000000 17000000     ................
  14d168:	00000000 00000017 00140900 00000000     ................
  14d178:	14000014 00000000 00000000 00000000     ................
	...
  14d194:	00001600 00000000 00000000 00001500     ................
  14d1a4:	00150000 09000000 00000016 00160000     ................
  14d1b4:	00001600                                ....

0014d1b8 <xdigits>:
  14d1b8:	33323130 37363534 42413938 46454443     0123456789ABCDEF

0014d1c8 <all_mask>:
  14d1c8:	ffffffff ffffffff                       ........

0014d1d0 <app_mask>:
  14d1d0:	7fffffff fffffffc                       ........

0014d1d8 <__EH_FRAME_BEGIN__>:
  14d1d8:	00000000                                ....
